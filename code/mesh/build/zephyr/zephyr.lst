
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
			msg->flags & I2C_MSG_READ ? 'R' : 'W', msg->len);
		if (!(msg->flags & I2C_MSG_READ)) {
			LOG_HEXDUMP_DBG(msg->buf, msg->len, "contents:");
		}
	}
}
   0:	00 5b 00 20 b5 4e 00 00 f3 75 02 00 89 4e 00 00     .[. .N...u...N..
  10:	89 4e 00 00 89 4e 00 00 89 4e 00 00 00 00 00 00     .N...N...N......
	...
  2c:	e1 47 00 00 89 4e 00 00 00 00 00 00 8d 47 00 00     .G...N.......G..
  3c:	89 4e 00 00                                         .N..

00000040 <_irq_vector_table>:
  40:	91 48 00 00 df b5 02 00 91 48 00 00 91 48 00 00     .H.......H...H..
  50:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  60:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  70:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  80:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  90:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  a0:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  b0:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  c0:	91 48 00 00 91 48 00 00 91 48 00 00 91 48 00 00     .H...H...H...H..
  d0:	91 48 00 00 91 48 00 00 91 48 00 00                 .H...H...H..

Disassembly of section text:

000000e0 <__aeabi_uldivmod>:
      e0:	b953      	cbnz	r3, f8 <__aeabi_uldivmod+0x18>
      e2:	b94a      	cbnz	r2, f8 <__aeabi_uldivmod+0x18>
      e4:	2900      	cmp	r1, #0
      e6:	bf08      	it	eq
      e8:	2800      	cmpeq	r0, #0
      ea:	bf1c      	itt	ne
      ec:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
      f0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
      f4:	f000 b80c 	b.w	110 <__aeabi_idiv0>
      f8:	f1ad 0c08 	sub.w	ip, sp, #8
      fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     100:	f000 f81b 	bl	13a <__udivmoddi4>
     104:	f8dd e004 	ldr.w	lr, [sp, #4]
     108:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     10c:	b004      	add	sp, #16
     10e:	4770      	bx	lr

00000110 <__aeabi_idiv0>:
     110:	4770      	bx	lr
     112:	bf00      	nop

00000114 <__popcountsi2>:
     114:	0843      	lsrs	r3, r0, #1
     116:	f003 3355 	and.w	r3, r3, #1431655765	; 0x55555555
     11a:	1ac0      	subs	r0, r0, r3
     11c:	f000 3333 	and.w	r3, r0, #858993459	; 0x33333333
     120:	0880      	lsrs	r0, r0, #2
     122:	f000 3033 	and.w	r0, r0, #858993459	; 0x33333333
     126:	4418      	add	r0, r3
     128:	eb00 1010 	add.w	r0, r0, r0, lsr #4
     12c:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
     130:	f000 300f 	and.w	r0, r0, #252645135	; 0xf0f0f0f
     134:	4358      	muls	r0, r3
     136:	0e00      	lsrs	r0, r0, #24
     138:	4770      	bx	lr

0000013a <__udivmoddi4>:
     13a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     13e:	4607      	mov	r7, r0
     140:	468c      	mov	ip, r1
     142:	4608      	mov	r0, r1
     144:	9e09      	ldr	r6, [sp, #36]	; 0x24
     146:	4615      	mov	r5, r2
     148:	463c      	mov	r4, r7
     14a:	4619      	mov	r1, r3
     14c:	2b00      	cmp	r3, #0
     14e:	f040 80c6 	bne.w	2de <CONFIG_BT_HCI_TX_STACK_SIZE+0x5e>
     152:	4282      	cmp	r2, r0
     154:	fab2 f782 	clz	r7, r2
     158:	d946      	bls.n	1e8 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x28>
     15a:	b14f      	cbz	r7, 170 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x3>
     15c:	f1c7 0e20 	rsb	lr, r7, #32
     160:	fa24 fe0e 	lsr.w	lr, r4, lr
     164:	fa00 f307 	lsl.w	r3, r0, r7
     168:	40bd      	lsls	r5, r7
     16a:	ea4e 0c03 	orr.w	ip, lr, r3
     16e:	40bc      	lsls	r4, r7
     170:	ea4f 4815 	mov.w	r8, r5, lsr #16
     174:	fa1f fe85 	uxth.w	lr, r5
     178:	fbbc f9f8 	udiv	r9, ip, r8
     17c:	0c22      	lsrs	r2, r4, #16
     17e:	fb08 c319 	mls	r3, r8, r9, ip
     182:	fb09 fa0e 	mul.w	sl, r9, lr
     186:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     18a:	459a      	cmp	sl, r3
     18c:	d928      	bls.n	1e0 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x20>
     18e:	18eb      	adds	r3, r5, r3
     190:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     194:	d204      	bcs.n	1a0 <CONFIG_BT_MESH_TX_SEG_RETRANS_TIMEOUT_UNICAST+0x10>
     196:	459a      	cmp	sl, r3
     198:	d902      	bls.n	1a0 <CONFIG_BT_MESH_TX_SEG_RETRANS_TIMEOUT_UNICAST+0x10>
     19a:	f1a9 0002 	sub.w	r0, r9, #2
     19e:	442b      	add	r3, r5
     1a0:	eba3 030a 	sub.w	r3, r3, sl
     1a4:	b2a4      	uxth	r4, r4
     1a6:	fbb3 f2f8 	udiv	r2, r3, r8
     1aa:	fb08 3312 	mls	r3, r8, r2, r3
     1ae:	fb02 fe0e 	mul.w	lr, r2, lr
     1b2:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     1b6:	45a6      	cmp	lr, r4
     1b8:	d914      	bls.n	1e4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x24>
     1ba:	192c      	adds	r4, r5, r4
     1bc:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     1c0:	d203      	bcs.n	1ca <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xa>
     1c2:	45a6      	cmp	lr, r4
     1c4:	d901      	bls.n	1ca <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xa>
     1c6:	1e93      	subs	r3, r2, #2
     1c8:	442c      	add	r4, r5
     1ca:	eba4 040e 	sub.w	r4, r4, lr
     1ce:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1d2:	b11e      	cbz	r6, 1dc <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1c>
     1d4:	40fc      	lsrs	r4, r7
     1d6:	2300      	movs	r3, #0
     1d8:	6034      	str	r4, [r6, #0]
     1da:	6073      	str	r3, [r6, #4]
     1dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1e0:	4648      	mov	r0, r9
     1e2:	e7dd      	b.n	1a0 <CONFIG_BT_MESH_TX_SEG_RETRANS_TIMEOUT_UNICAST+0x10>
     1e4:	4613      	mov	r3, r2
     1e6:	e7f0      	b.n	1ca <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xa>
     1e8:	b902      	cbnz	r2, 1ec <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x2c>
     1ea:	deff      	udf	#255	; 0xff
     1ec:	bb87      	cbnz	r7, 250 <CONFIG_FLASH_SIZE+0x50>
     1ee:	1a83      	subs	r3, r0, r2
     1f0:	2101      	movs	r1, #1
     1f2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1f6:	b2aa      	uxth	r2, r5
     1f8:	fbb3 fcfe 	udiv	ip, r3, lr
     1fc:	0c20      	lsrs	r0, r4, #16
     1fe:	fb0e 331c 	mls	r3, lr, ip, r3
     202:	fb0c f802 	mul.w	r8, ip, r2
     206:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
     20a:	4598      	cmp	r8, r3
     20c:	d963      	bls.n	2d6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x56>
     20e:	18eb      	adds	r3, r5, r3
     210:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     214:	d204      	bcs.n	220 <CONFIG_FLASH_SIZE+0x20>
     216:	4598      	cmp	r8, r3
     218:	d902      	bls.n	220 <CONFIG_FLASH_SIZE+0x20>
     21a:	f1ac 0002 	sub.w	r0, ip, #2
     21e:	442b      	add	r3, r5
     220:	eba3 0308 	sub.w	r3, r3, r8
     224:	b2a4      	uxth	r4, r4
     226:	fbb3 fcfe 	udiv	ip, r3, lr
     22a:	fb0e 331c 	mls	r3, lr, ip, r3
     22e:	fb0c f202 	mul.w	r2, ip, r2
     232:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     236:	42a2      	cmp	r2, r4
     238:	d94f      	bls.n	2da <CONFIG_BT_HCI_TX_STACK_SIZE+0x5a>
     23a:	192c      	adds	r4, r5, r4
     23c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
     240:	d204      	bcs.n	24c <CONFIG_FLASH_SIZE+0x4c>
     242:	42a2      	cmp	r2, r4
     244:	d902      	bls.n	24c <CONFIG_FLASH_SIZE+0x4c>
     246:	f1ac 0302 	sub.w	r3, ip, #2
     24a:	442c      	add	r4, r5
     24c:	1aa4      	subs	r4, r4, r2
     24e:	e7be      	b.n	1ce <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0xe>
     250:	f1c7 0c20 	rsb	ip, r7, #32
     254:	fa20 f80c 	lsr.w	r8, r0, ip
     258:	fa00 f307 	lsl.w	r3, r0, r7
     25c:	fa24 fc0c 	lsr.w	ip, r4, ip
     260:	40bd      	lsls	r5, r7
     262:	ea4c 0203 	orr.w	r2, ip, r3
     266:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     26a:	b2ab      	uxth	r3, r5
     26c:	fbb8 fcfe 	udiv	ip, r8, lr
     270:	0c11      	lsrs	r1, r2, #16
     272:	fb0e 801c 	mls	r0, lr, ip, r8
     276:	fb0c f903 	mul.w	r9, ip, r3
     27a:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
     27e:	4581      	cmp	r9, r0
     280:	fa04 f407 	lsl.w	r4, r4, r7
     284:	d923      	bls.n	2ce <CONFIG_BT_HCI_TX_STACK_SIZE+0x4e>
     286:	1828      	adds	r0, r5, r0
     288:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
     28c:	d204      	bcs.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     28e:	4581      	cmp	r9, r0
     290:	d902      	bls.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     292:	f1ac 0102 	sub.w	r1, ip, #2
     296:	4428      	add	r0, r5
     298:	eba0 0009 	sub.w	r0, r0, r9
     29c:	b292      	uxth	r2, r2
     29e:	fbb0 fcfe 	udiv	ip, r0, lr
     2a2:	fb0e 001c 	mls	r0, lr, ip, r0
     2a6:	fb0c f803 	mul.w	r8, ip, r3
     2aa:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
     2ae:	4598      	cmp	r8, r3
     2b0:	d90f      	bls.n	2d2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x52>
     2b2:	18eb      	adds	r3, r5, r3
     2b4:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
     2b8:	d204      	bcs.n	2c4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x44>
     2ba:	4598      	cmp	r8, r3
     2bc:	d902      	bls.n	2c4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x44>
     2be:	f1ac 0202 	sub.w	r2, ip, #2
     2c2:	442b      	add	r3, r5
     2c4:	eba3 0308 	sub.w	r3, r3, r8
     2c8:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
     2cc:	e791      	b.n	1f2 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x32>
     2ce:	4661      	mov	r1, ip
     2d0:	e7e2      	b.n	298 <CONFIG_BT_HCI_TX_STACK_SIZE+0x18>
     2d2:	4662      	mov	r2, ip
     2d4:	e7f6      	b.n	2c4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x44>
     2d6:	4660      	mov	r0, ip
     2d8:	e7a2      	b.n	220 <CONFIG_FLASH_SIZE+0x20>
     2da:	4663      	mov	r3, ip
     2dc:	e7b6      	b.n	24c <CONFIG_FLASH_SIZE+0x4c>
     2de:	4283      	cmp	r3, r0
     2e0:	d905      	bls.n	2ee <CONFIG_BT_HCI_TX_STACK_SIZE+0x6e>
     2e2:	b10e      	cbz	r6, 2e8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x68>
     2e4:	e9c6 7000 	strd	r7, r0, [r6]
     2e8:	2100      	movs	r1, #0
     2ea:	4608      	mov	r0, r1
     2ec:	e776      	b.n	1dc <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1c>
     2ee:	fab3 f183 	clz	r1, r3
     2f2:	b981      	cbnz	r1, 316 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x16>
     2f4:	4283      	cmp	r3, r0
     2f6:	d301      	bcc.n	2fc <CONFIG_BT_HCI_TX_STACK_SIZE+0x7c>
     2f8:	42ba      	cmp	r2, r7
     2fa:	d80a      	bhi.n	312 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x12>
     2fc:	1abc      	subs	r4, r7, r2
     2fe:	eb60 0303 	sbc.w	r3, r0, r3
     302:	2001      	movs	r0, #1
     304:	469c      	mov	ip, r3
     306:	2e00      	cmp	r6, #0
     308:	d068      	beq.n	3dc <CONFIG_BT_MESH_ADV_STACK_SIZE+0xdc>
     30a:	e9c6 4c00 	strd	r4, ip, [r6]
     30e:	2100      	movs	r1, #0
     310:	e764      	b.n	1dc <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1c>
     312:	4608      	mov	r0, r1
     314:	e7f7      	b.n	306 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x6>
     316:	f1c1 0c20 	rsb	ip, r1, #32
     31a:	408b      	lsls	r3, r1
     31c:	fa22 f40c 	lsr.w	r4, r2, ip
     320:	431c      	orrs	r4, r3
     322:	fa02 f501 	lsl.w	r5, r2, r1
     326:	fa00 f301 	lsl.w	r3, r0, r1
     32a:	fa27 f20c 	lsr.w	r2, r7, ip
     32e:	fa20 fb0c 	lsr.w	fp, r0, ip
     332:	ea4f 4914 	mov.w	r9, r4, lsr #16
     336:	4313      	orrs	r3, r2
     338:	fbbb f8f9 	udiv	r8, fp, r9
     33c:	fa1f fe84 	uxth.w	lr, r4
     340:	fb09 bb18 	mls	fp, r9, r8, fp
     344:	0c1a      	lsrs	r2, r3, #16
     346:	fb08 fa0e 	mul.w	sl, r8, lr
     34a:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
     34e:	4592      	cmp	sl, r2
     350:	fa07 f701 	lsl.w	r7, r7, r1
     354:	d93e      	bls.n	3d4 <CONFIG_BT_MESH_ADV_STACK_SIZE+0xd4>
     356:	18a2      	adds	r2, r4, r2
     358:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     35c:	d204      	bcs.n	368 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x68>
     35e:	4592      	cmp	sl, r2
     360:	d902      	bls.n	368 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x68>
     362:	f1a8 0002 	sub.w	r0, r8, #2
     366:	4422      	add	r2, r4
     368:	eba2 020a 	sub.w	r2, r2, sl
     36c:	b29b      	uxth	r3, r3
     36e:	fbb2 f8f9 	udiv	r8, r2, r9
     372:	fb09 2218 	mls	r2, r9, r8, r2
     376:	fb08 fe0e 	mul.w	lr, r8, lr
     37a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     37e:	4596      	cmp	lr, r2
     380:	d92a      	bls.n	3d8 <CONFIG_BT_MESH_ADV_STACK_SIZE+0xd8>
     382:	18a2      	adds	r2, r4, r2
     384:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
     388:	d204      	bcs.n	394 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x94>
     38a:	4596      	cmp	lr, r2
     38c:	d902      	bls.n	394 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x94>
     38e:	f1a8 0302 	sub.w	r3, r8, #2
     392:	4422      	add	r2, r4
     394:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     398:	fba0 9305 	umull	r9, r3, r0, r5
     39c:	eba2 020e 	sub.w	r2, r2, lr
     3a0:	429a      	cmp	r2, r3
     3a2:	46ce      	mov	lr, r9
     3a4:	4698      	mov	r8, r3
     3a6:	d302      	bcc.n	3ae <CONFIG_BT_MESH_ADV_STACK_SIZE+0xae>
     3a8:	d106      	bne.n	3b8 <CONFIG_BT_MESH_ADV_STACK_SIZE+0xb8>
     3aa:	454f      	cmp	r7, r9
     3ac:	d204      	bcs.n	3b8 <CONFIG_BT_MESH_ADV_STACK_SIZE+0xb8>
     3ae:	ebb9 0e05 	subs.w	lr, r9, r5
     3b2:	eb63 0804 	sbc.w	r8, r3, r4
     3b6:	3801      	subs	r0, #1
     3b8:	b186      	cbz	r6, 3dc <CONFIG_BT_MESH_ADV_STACK_SIZE+0xdc>
     3ba:	ebb7 030e 	subs.w	r3, r7, lr
     3be:	eb62 0708 	sbc.w	r7, r2, r8
     3c2:	fa07 fc0c 	lsl.w	ip, r7, ip
     3c6:	40cb      	lsrs	r3, r1
     3c8:	ea4c 0303 	orr.w	r3, ip, r3
     3cc:	40cf      	lsrs	r7, r1
     3ce:	e9c6 3700 	strd	r3, r7, [r6]
     3d2:	e79c      	b.n	30e <CONFIG_BT_MESH_ADV_STACK_SIZE+0xe>
     3d4:	4640      	mov	r0, r8
     3d6:	e7c7      	b.n	368 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x68>
     3d8:	4643      	mov	r3, r8
     3da:	e7db      	b.n	394 <CONFIG_BT_MESH_ADV_STACK_SIZE+0x94>
     3dc:	4631      	mov	r1, r6
     3de:	e6fd      	b.n	1dc <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1c>

000003e0 <ull_drift_ticks_get>:
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_drift_ticks_get(struct node_rx_event_done *done,
			 uint32_t *ticks_drift_plus,
			 uint32_t *ticks_drift_minus)
{
     3e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     3e4:	4603      	mov	r3, r0
	uint32_t window_widening_event_us;
	uint32_t preamble_to_addr_us;

	start_to_address_actual_us =
		done->extra.drift.start_to_address_actual_us;
	window_widening_event_us =
     3e6:	e9d0 800a 	ldrd	r8, r0, [r0, #40]	; 0x28
		done->extra.drift.window_widening_event_us;
	preamble_to_addr_us =
     3ea:	6b1e      	ldr	r6, [r3, #48]	; 0x30
		done->extra.drift.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
     3ec:	4d18      	ldr	r5, [pc, #96]	; (450 <CONFIG_LOG_BUFFER_SIZE+0x50>)
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
     3ee:	1984      	adds	r4, r0, r6
	start_to_address_expected_us = EVENT_JITTER_US +
     3f0:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
     3f2:	45a0      	cmp	r8, r4
{
     3f4:	4617      	mov	r7, r2
     3f6:	4689      	mov	r9, r1
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
     3f8:	a313      	add	r3, pc, #76	; (adr r3, 448 <CONFIG_LOG_BUFFER_SIZE+0x48>)
     3fa:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (start_to_address_actual_us <= start_to_address_expected_us) {
     3fe:	d815      	bhi.n	42c <CONFIG_LOG_BUFFER_SIZE+0x2c>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
     400:	fba0 0105 	umull	r0, r1, r0, r5
     404:	f7ff fe6c 	bl	e0 <__aeabi_uldivmod>
     408:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
     40c:	f8c9 0000 	str.w	r0, [r9]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
     410:	eba4 0008 	sub.w	r0, r4, r8
					       start_to_address_actual_us));
	} else {
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
     414:	a30c      	add	r3, pc, #48	; (adr r3, 448 <CONFIG_LOG_BUFFER_SIZE+0x48>)
     416:	e9d3 2300 	ldrd	r2, r3, [r3]
     41a:	fba0 0105 	umull	r0, r1, r0, r5
     41e:	f7ff fe5f 	bl	e0 <__aeabi_uldivmod>
     422:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
     426:	6038      	str	r0, [r7, #0]
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
     428:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
     42c:	fba8 0105 	umull	r0, r1, r8, r5
     430:	f7ff fe56 	bl	e0 <__aeabi_uldivmod>
     434:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
     438:	f8c9 0000 	str.w	r0, [r9]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
     43c:	f106 0030 	add.w	r0, r6, #48	; 0x30
     440:	e7e8      	b.n	414 <CONFIG_LOG_BUFFER_SIZE+0x14>
     442:	bf00      	nop
     444:	f3af 8000 	nop.w
     448:	1afd498d 	.word	0x1afd498d
     44c:	00000007 	.word	0x00000007
     450:	3b9aca00 	.word	0x3b9aca00
     454:	00000000 	.word	0x00000000

00000458 <ll_adv_enable>:
	uint8_t aux_is_started = 0U;
	uint32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
uint8_t ll_adv_enable(uint8_t enable)
{
     458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     45c:	b08f      	sub	sp, #60	; 0x3c
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	uint8_t hci_err;
	uint32_t ret;

	if (!enable) {
     45e:	b920      	cbnz	r0, 46a <ll_adv_enable+0x12>
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
     460:	b00f      	add	sp, #60	; 0x3c
     462:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return disable(handle);
     466:	f01c b8d7 	b.w	1c618 <disable.constprop.0>
static inline struct ll_adv_set *is_disabled_get(uint8_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
     46a:	4ebd      	ldr	r6, [pc, #756]	; (760 <CONFIG_BT_COMPANY_ID+0x16f>)
     46c:	f896 706a 	ldrb.w	r7, [r6, #106]	; 0x6a
     470:	f017 0701 	ands.w	r7, r7, #1
     474:	f040 816e 	bne.w	754 <CONFIG_BT_COMPANY_ID+0x163>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     478:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
     47c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
     480:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     484:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
     488:	eb06 0383 	add.w	r3, r6, r3, lsl #2
     48c:	f8d3 b038 	ldr.w	fp, [r3, #56]	; 0x38
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		pdu_adv_to_update = pdu;
	}

	if (pdu_adv_to_update) {
     490:	f1b9 0f00 	cmp.w	r9, #0
     494:	d013      	beq.n	4be <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4a>
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		} else if (ll_adv_cmds_is_ext() && pdu->tx_addr) {
			own_id_addr = adv->rnd_addr;
#endif
		} else {
			own_id_addr = ll_addr_get(pdu->tx_addr);
     496:	464c      	mov	r4, r9
     498:	f814 0b02 	ldrb.w	r0, [r4], #2
     49c:	f3c0 1080 	ubfx	r0, r0, #6, #1
     4a0:	f019 fdfa 	bl	1a098 <ll_addr_get>
	} else {
		tx_addr = own_id_addr;
	}

	adv_addr = adv_pdu_adva_get(pdu);
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
     4a4:	2206      	movs	r2, #6
			own_id_addr = ll_addr_get(pdu->tx_addr);
     4a6:	4601      	mov	r1, r0
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
     4a8:	4620      	mov	r0, r4
     4aa:	f027 f9e1 	bl	27870 <memcpy>
		if (pdu_adv_to_update->tx_addr &&
     4ae:	f899 3000 	ldrb.w	r3, [r9]
     4b2:	065a      	lsls	r2, r3, #25
     4b4:	d40d      	bmi.n	4d2 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x5e>
			ull_adv_pdu_update_addrs(adv, pdu_scan);
     4b6:	48aa      	ldr	r0, [pc, #680]	; (760 <CONFIG_BT_COMPANY_ID+0x16f>)
     4b8:	4659      	mov	r1, fp
     4ba:	f02a fdf7 	bl	2b0ac <ull_adv_pdu_update_addrs>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
     4be:	f899 3000 	ldrb.w	r3, [r9]
     4c2:	f013 0f0e 	tst.w	r3, #14
     4c6:	f040 80a2 	bne.w	60e <CONFIG_BT_COMPANY_ID+0x1d>
		if (lll->conn) {
     4ca:	6a33      	ldr	r3, [r6, #32]
     4cc:	b14b      	cbz	r3, 4e2 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x6e>
	return BT_HCI_ERR_CMD_DISALLOWED;
     4ce:	270c      	movs	r7, #12
     4d0:	e099      	b.n	606 <CONFIG_BT_COMPANY_ID+0x15>
		    !mem_nz((void *)adv_addr, BDADDR_SIZE)) {
     4d2:	2106      	movs	r1, #6
     4d4:	4620      	mov	r0, r4
     4d6:	f02a f9e0 	bl	2a89a <mem_nz>
		if (pdu_adv_to_update->tx_addr &&
     4da:	2800      	cmp	r0, #0
     4dc:	d1eb      	bne.n	4b6 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x42>
			return BT_HCI_ERR_INVALID_PARAM;
     4de:	2712      	movs	r7, #18
     4e0:	e091      	b.n	606 <CONFIG_BT_COMPANY_ID+0x15>
		link = ll_rx_link_alloc();
     4e2:	f01b f863 	bl	1b5ac <ll_rx_link_alloc>
		if (!link) {
     4e6:	4680      	mov	r8, r0
     4e8:	b130      	cbz	r0, 4f8 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x84>
		node_rx = ll_rx_alloc();
     4ea:	f01b f86b 	bl	1b5c4 <ll_rx_alloc>
		if (!node_rx) {
     4ee:	4682      	mov	sl, r0
     4f0:	b920      	cbnz	r0, 4fc <CONFIG_BT_HCI_ECC_STACK_SIZE+0x88>
			ll_rx_link_release(link);
     4f2:	4640      	mov	r0, r8
     4f4:	f01b f860 	bl	1b5b8 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
     4f8:	2707      	movs	r7, #7
     4fa:	e084      	b.n	606 <CONFIG_BT_COMPANY_ID+0x15>
		conn = ll_conn_acquire();
     4fc:	f01c fb46 	bl	1cb8c <ll_conn_acquire>
		if (!conn) {
     500:	4604      	mov	r4, r0
     502:	b918      	cbnz	r0, 50c <CONFIG_BT_HCI_ECC_STACK_SIZE+0x98>
			ll_rx_release(node_rx);
     504:	4650      	mov	r0, sl
     506:	f01b f863 	bl	1b5d0 <ll_rx_release>
     50a:	e7f2      	b.n	4f2 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x7e>
		conn_lll->handle = 0xFFFF;
     50c:	f64f 72ff 	movw	r2, #65535	; 0xffff
     510:	8502      	strh	r2, [r0, #40]	; 0x28
		if (!conn_lll->link_tx_free) {
     512:	6e82      	ldr	r2, [r0, #104]	; 0x68
		conn_lll = &conn->lll;
     514:	f100 031c 	add.w	r3, r0, #28
		if (!conn_lll->link_tx_free) {
     518:	b912      	cbnz	r2, 520 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>
			conn_lll->link_tx_free = &conn_lll->link_tx;
     51a:	f100 0260 	add.w	r2, r0, #96	; 0x60
     51e:	6682      	str	r2, [r0, #104]	; 0x68
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
     520:	f104 025c 	add.w	r2, r4, #92	; 0x5c
     524:	f104 0158 	add.w	r1, r4, #88	; 0x58
     528:	6ea0      	ldr	r0, [r4, #104]	; 0x68
     52a:	930b      	str	r3, [sp, #44]	; 0x2c
     52c:	f02a f9c0 	bl	2a8b0 <memq_init>
		conn_lll->sn = 0;
     530:	f894 206e 	ldrb.w	r2, [r4, #110]	; 0x6e
     534:	f022 0207 	bic.w	r2, r2, #7
     538:	f884 206e 	strb.w	r2, [r4, #110]	; 0x6e
		conn_lll->data_chan_sel = 0;
     53c:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
     540:	f002 023f 	and.w	r2, r2, #63	; 0x3f
     544:	f062 027f 	orn	r2, r2, #127	; 0x7f
     548:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
		conn_lll->periph.initiated = 0;
     54c:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
     550:	f022 0207 	bic.w	r2, r2, #7
     554:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
		conn->connect_expire = 6;
     558:	2206      	movs	r2, #6
     55a:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
		conn->common.fex_valid = 0;
     55e:	f894 207c 	ldrb.w	r2, [r4, #124]	; 0x7c
		conn_lll->link_tx_free = NULL;
     562:	2500      	movs	r5, #0
		conn->common.fex_valid = 0;
     564:	f022 0207 	bic.w	r2, r2, #7
     568:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
		conn_lll->periph.window_widening_event_us = 0;
     56c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
		conn_lll->link_tx_free = NULL;
     570:	66a5      	str	r5, [r4, #104]	; 0x68
		conn_lll->packet_tx_head_len = 0;
     572:	f8a4 506c 	strh.w	r5, [r4, #108]	; 0x6c
		conn_lll->latency_prepare = 0;
     576:	85e5      	strh	r5, [r4, #46]	; 0x2e
		conn_lll->latency_event = 0;
     578:	6325      	str	r5, [r4, #48]	; 0x30
		conn_lll->data_chan_use = 0;
     57a:	f884 503b 	strb.w	r5, [r4, #59]	; 0x3b
		conn_lll->periph.window_size_prepare_us = 0;
     57e:	6525      	str	r5, [r4, #80]	; 0x50
		conn->supervision_expire = 0;
     580:	f8a4 5074 	strh.w	r5, [r4, #116]	; 0x74
		conn->procedure_expire = 0;
     584:	f8a4 5078 	strh.w	r5, [r4, #120]	; 0x78
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
     588:	f8a4 5088 	strh.w	r5, [r4, #136]	; 0x88
     58c:	f884 508a 	strb.w	r5, [r4, #138]	; 0x8a
		conn->llcp_rx = NULL;
     590:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
     594:	f8a4 509c 	strh.w	r5, [r4, #156]	; 0x9c
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
     598:	f8a4 50b0 	strh.w	r5, [r4, #176]	; 0xb0
		conn->llcp_feature.features_conn = ll_feat_get();
     59c:	f02a fcbc 	bl	2af18 <ll_feat_get>
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     5a0:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
		lll->conn = conn_lll;
     5a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     5a6:	6233      	str	r3, [r6, #32]
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
     5a8:	f022 0203 	bic.w	r2, r2, #3
     5ac:	f884 20ca 	strb.w	r2, [r4, #202]	; 0xca
		conn->llcp_conn_param.disabled = 0;
     5b0:	f894 20f6 	ldrb.w	r2, [r4, #246]	; 0xf6
		conn->llcp_version.req = conn->llcp_version.ack = 0;
     5b4:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
		conn->llcp_feature.features_conn = ll_feat_get();
     5b8:	e9c4 012e 	strd	r0, r1, [r4, #184]	; 0xb8
		conn->llcp_conn_param.disabled = 0;
     5bc:	f365 1245 	bfi	r2, r5, #5, #1
		conn->llcp_feature.features_peer = 0;
     5c0:	2000      	movs	r0, #0
     5c2:	2100      	movs	r1, #0
		adv->node_rx_cc_free = node_rx;
     5c4:	e9c6 8a18 	strd	r8, sl, [r6, #96]	; 0x60
		conn->llcp_feature.features_peer = 0;
     5c8:	e9c4 0130 	strd	r0, r1, [r4, #192]	; 0xc0
		conn->tx_data = conn->tx_data_last = 0;
     5cc:	e9c4 554a 	strd	r5, r5, [r4, #296]	; 0x128
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
     5d0:	e9c4 5548 	strd	r5, r5, [r4, #288]	; 0x120
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->ref = 0U;
	hdr->disabled_cb = hdr->disabled_param = NULL;
     5d4:	e9c4 5505 	strd	r5, r5, [r4, #20]
		conn->llcp_terminate.req = conn->llcp_terminate.ack = 0;
     5d8:	f8a4 50d0 	strh.w	r5, [r4, #208]	; 0xd0
		conn->llcp_terminate.reason_final = 0;
     5dc:	f884 50d3 	strb.w	r5, [r4, #211]	; 0xd3
		conn->llcp_terminate.node_rx.hdr.link = link;
     5e0:	f8c4 80d4 	str.w	r8, [r4, #212]	; 0xd4
		conn->llcp_conn_param.req = 0;
     5e4:	f8a4 50f4 	strh.w	r5, [r4, #244]	; 0xf4
		conn->llcp_conn_param.disabled = 0;
     5e8:	f884 20f6 	strb.w	r2, [r4, #246]	; 0xf6
		conn->periph.ticks_to_offset = 0;
     5ec:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
     5f0:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
	hdr->ref = 0U;
     5f4:	7025      	strb	r5, [r4, #0]

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
     5f6:	61e4      	str	r4, [r4, #28]
		err = lll_clock_wait();
     5f8:	f01e f8fe 	bl	1e7f8 <lll_clock_wait>
		if (err) {
     5fc:	b138      	cbz	r0, 60e <CONFIG_BT_COMPANY_ID+0x1d>
			conn_release(adv);
     5fe:	4858      	ldr	r0, [pc, #352]	; (760 <CONFIG_BT_COMPANY_ID+0x16f>)
     600:	f01b fdb2 	bl	1c168 <conn_release>
			return BT_HCI_ERR_HW_FAILURE;
     604:	2703      	movs	r7, #3
}
     606:	4638      	mov	r0, r7
     608:	b00f      	add	sp, #60	; 0x3c
     60a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t ch_map = lll->chan_map;
     60e:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     612:	2101      	movs	r1, #1
	uint8_t ch_map = lll->chan_map;
     614:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     618:	f10d 0033 	add.w	r0, sp, #51	; 0x33
	uint8_t ch_map = lll->chan_map;
     61c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     620:	f02a f972 	bl	2a908 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
     624:	4602      	mov	r2, r0
     626:	2800      	cmp	r0, #0
     628:	f000 808c 	beq.w	744 <CONFIG_BT_COMPANY_ID+0x153>
	uint16_t time_us = adv_time_get(pdu_adv, pdu_scan, adv_chn_cnt, phy,
     62c:	f89b 1001 	ldrb.w	r1, [fp, #1]
     630:	4648      	mov	r0, r9
     632:	f02a fcf1 	bl	2b018 <adv_time_get.constprop.0.isra.0>
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     636:	494b      	ldr	r1, [pc, #300]	; (764 <CONFIG_BT_COMPANY_ID+0x173>)
	uint16_t interval = adv->interval;
     638:	f8b6 8068 	ldrh.w	r8, [r6, #104]	; 0x68
     63c:	2400      	movs	r4, #0
	adv->ull.ticks_prepare_to_start =
     63e:	2331      	movs	r3, #49	; 0x31
	adv->ull.ticks_preempt_to_start =
     640:	e9c6 3402 	strd	r3, r4, [r6, #8]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     644:	fba0 0101 	umull	r0, r1, r0, r1
     648:	a343      	add	r3, pc, #268	; (adr r3, 758 <CONFIG_BT_COMPANY_ID+0x167>)
     64a:	e9d3 2300 	ldrd	r2, r3, [r3]
	hdr->disabled_cb = hdr->disabled_param = NULL;
     64e:	e9c6 4405 	strd	r4, r4, [r6, #20]
	hdr->ref = 0U;
     652:	7034      	strb	r4, [r6, #0]
	adv->ull.ticks_active_to_start = 0;
     654:	6074      	str	r4, [r6, #4]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     656:	f7ff fd43 	bl	e0 <__aeabi_uldivmod>
     65a:	6130      	str	r0, [r6, #16]
	ticks_anchor = ticker_ticks_now_get();
     65c:	f02a fbfc 	bl	2ae58 <ticker_ticks_now_get>
     660:	4605      	mov	r5, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
     662:	f1b8 0f00 	cmp.w	r8, #0
     666:	d106      	bne.n	676 <CONFIG_BT_COMPANY_ID+0x85>
     668:	f899 4000 	ldrb.w	r4, [r9]
     66c:	f004 040f 	and.w	r4, r4, #15
     670:	1e63      	subs	r3, r4, #1
     672:	425c      	negs	r4, r3
     674:	415c      	adcs	r4, r3
     676:	f896 9024 	ldrb.w	r9, [r6, #36]	; 0x24
				   (adv->ull.ticks_slot + ticks_slot_overhead),
     67a:	6933      	ldr	r3, [r6, #16]
     67c:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 768 <CONFIG_BT_COMPANY_ID+0x177>
     680:	4a3a      	ldr	r2, [pc, #232]	; (76c <CONFIG_BT_COMPANY_ID+0x17b>)
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
     682:	f364 0900 	bfi	r9, r4, #0, #1
     686:	f886 9024 	strb.w	r9, [r6, #36]	; 0x24
	if (lll->is_hdcd) {
     68a:	f04f 0a02 	mov.w	sl, #2
     68e:	f019 0901 	ands.w	r9, r9, #1
     692:	ac0d      	add	r4, sp, #52	; 0x34
		ret_cb = TICKER_STATUS_BUSY;
     694:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
	if (lll->is_hdcd) {
     698:	d031      	beq.n	6fe <CONFIG_BT_COMPANY_ID+0x10d>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     69a:	2000      	movs	r0, #0
     69c:	e9cd 2605 	strd	r2, r6, [sp, #20]
     6a0:	e9cd 0300 	strd	r0, r3, [sp]
     6a4:	9304      	str	r3, [sp, #16]
     6a6:	2103      	movs	r1, #3
     6a8:	e9cd b407 	strd	fp, r4, [sp, #28]
     6ac:	e9cd 0002 	strd	r0, r0, [sp, #8]
     6b0:	462b      	mov	r3, r5
     6b2:	4652      	mov	r2, sl
     6b4:	f02a fb9d 	bl	2adf2 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
     6b8:	4621      	mov	r1, r4
     6ba:	f01b f89d 	bl	1b7f8 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
     6be:	2800      	cmp	r0, #0
     6c0:	d140      	bne.n	744 <CONFIG_BT_COMPANY_ID+0x153>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     6c2:	4a2b      	ldr	r2, [pc, #172]	; (770 <CONFIG_BT_COMPANY_ID+0x17f>)
     6c4:	9606      	str	r6, [sp, #24]
     6c6:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
     6ca:	e9cd 0204 	strd	r0, r2, [sp, #16]
     6ce:	9300      	str	r3, [sp, #0]
     6d0:	e9cd b407 	strd	fp, r4, [sp, #28]
     6d4:	e9cd 0002 	strd	r0, r0, [sp, #8]
     6d8:	9001      	str	r0, [sp, #4]
     6da:	462b      	mov	r3, r5
     6dc:	2201      	movs	r2, #1
     6de:	2103      	movs	r1, #3
		ret_cb = TICKER_STATUS_BUSY;
     6e0:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     6e4:	f02a fb85 	bl	2adf2 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
     6e8:	4621      	mov	r1, r4
     6ea:	f01b f885 	bl	1b7f8 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     6ee:	bb48      	cbnz	r0, 744 <CONFIG_BT_COMPANY_ID+0x153>
	adv->is_enabled = 1;
     6f0:	f896 306a 	ldrb.w	r3, [r6, #106]	; 0x6a
     6f4:	f043 0301 	orr.w	r3, r3, #1
     6f8:	f886 306a 	strb.w	r3, [r6, #106]	; 0x6a
	return 0;
     6fc:	e783      	b.n	606 <CONFIG_BT_COMPANY_ID+0x15>
		ll_adv_ticker_ext[handle].ticks_slot_window =
     6fe:	491d      	ldr	r1, [pc, #116]	; (774 <CONFIG_BT_COMPANY_ID+0x183>)
			ULL_ADV_RANDOM_DELAY + ticks_slot;
     700:	f203 1047 	addw	r0, r3, #327	; 0x147
		ll_adv_ticker_ext[handle].ticks_slot_window =
     704:	6008      	str	r0, [r1, #0]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     706:	481c      	ldr	r0, [pc, #112]	; (778 <CONFIG_BT_COMPANY_ID+0x187>)
		ret = ticker_start_ext(
     708:	e9cd 3204 	strd	r3, r2, [sp, #16]
     70c:	e9cd 4108 	strd	r4, r1, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     710:	f04f 0c91 	mov.w	ip, #145	; 0x91
     714:	fba8 0100 	umull	r0, r1, r8, r0
		ret = ticker_start_ext(
     718:	f64f 73ff 	movw	r3, #65535	; 0xffff
     71c:	e9cd 9302 	strd	r9, r3, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     720:	fb0c 1108 	mla	r1, ip, r8, r1
     724:	a30c      	add	r3, pc, #48	; (adr r3, 758 <CONFIG_BT_COMPANY_ID+0x167>)
     726:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
     72a:	e9cd 6b06 	strd	r6, fp, [sp, #24]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     72e:	f7ff fcd7 	bl	e0 <__aeabi_uldivmod>
		ret = ticker_start_ext(
     732:	462b      	mov	r3, r5
     734:	e9cd 9000 	strd	r9, r0, [sp]
     738:	4652      	mov	r2, sl
     73a:	2103      	movs	r1, #3
     73c:	4648      	mov	r0, r9
     73e:	f019 fbb7 	bl	19eb0 <ticker_start_ext>
     742:	e7d1      	b.n	6e8 <CONFIG_BT_COMPANY_ID+0xf7>
	if (adv->lll.conn) {
     744:	6a33      	ldr	r3, [r6, #32]
     746:	2b00      	cmp	r3, #0
     748:	f43f aec1 	beq.w	4ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x5a>
		conn_release(adv);
     74c:	4804      	ldr	r0, [pc, #16]	; (760 <CONFIG_BT_COMPANY_ID+0x16f>)
     74e:	f01b fd0b 	bl	1c168 <conn_release>
     752:	e6bc      	b.n	4ce <CONFIG_BT_HCI_ECC_STACK_SIZE+0x5a>
			return 0;
     754:	2700      	movs	r7, #0
     756:	e756      	b.n	606 <CONFIG_BT_COMPANY_ID+0x15>
     758:	1afd498d 	.word	0x1afd498d
     75c:	00000007 	.word	0x00000007
     760:	20003160 	.word	0x20003160
     764:	3b9aca00 	.word	0x3b9aca00
     768:	0001b24d 	.word	0x0001b24d
     76c:	0001c331 	.word	0x0001c331
     770:	0001c065 	.word	0x0001c065
     774:	200031cc 	.word	0x200031cc
     778:	84e72a00 	.word	0x84e72a00
     77c:	00000000 	.word	0x00000000

00000780 <ull_adv_time_update>:
{
     780:	b570      	push	{r4, r5, r6, lr}
	chan_map = lll->chan_map;
     782:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
{
     786:	b08a      	sub	sp, #40	; 0x28
	chan_map = lll->chan_map;
     788:	f3c3 0342 	ubfx	r3, r3, #1, #3
{
     78c:	460d      	mov	r5, r1
     78e:	4604      	mov	r4, r0
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     790:	2101      	movs	r1, #1
     792:	f10d 0023 	add.w	r0, sp, #35	; 0x23
{
     796:	4616      	mov	r6, r2
	chan_map = lll->chan_map;
     798:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     79c:	f02a f8b4 	bl	2a908 <util_ones_count_get>
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
     7a0:	7871      	ldrb	r1, [r6, #1]
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     7a2:	4602      	mov	r2, r0
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
     7a4:	4628      	mov	r0, r5
     7a6:	f02a fc37 	bl	2b018 <adv_time_get.constprop.0.isra.0>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     7aa:	491d      	ldr	r1, [pc, #116]	; (820 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x20>)
     7ac:	a31a      	add	r3, pc, #104	; (adr r3, 818 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x18>)
     7ae:	e9d3 2300 	ldrd	r2, r3, [r3]
     7b2:	fba0 0101 	umull	r0, r1, r0, r1
     7b6:	f7ff fc93 	bl	e0 <__aeabi_uldivmod>
	if (adv->ull.ticks_slot > time_ticks) {
     7ba:	6921      	ldr	r1, [r4, #16]
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     7bc:	4605      	mov	r5, r0
	if (adv->ull.ticks_slot > time_ticks) {
     7be:	428d      	cmp	r5, r1
     7c0:	d21f      	bcs.n	802 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x2>
		ticks_minus = adv->ull.ticks_slot - time_ticks;
     7c2:	1b48      	subs	r0, r1, r5
		ticks_plus = 0U;
     7c4:	2100      	movs	r1, #0
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     7c6:	4a17      	ldr	r2, [pc, #92]	; (824 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x24>)
	ret_cb = TICKER_STATUS_BUSY;
     7c8:	2302      	movs	r3, #2
     7ca:	9309      	str	r3, [sp, #36]	; 0x24
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     7cc:	1aa2      	subs	r2, r4, r2
     7ce:	236c      	movs	r3, #108	; 0x6c
     7d0:	fbb2 f2f3 	udiv	r2, r2, r3
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     7d4:	4b14      	ldr	r3, [pc, #80]	; (828 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x28>)
     7d6:	9305      	str	r3, [sp, #20]
     7d8:	ae09      	add	r6, sp, #36	; 0x24
     7da:	2300      	movs	r3, #0
     7dc:	3202      	adds	r2, #2
     7de:	e9cd 1001 	strd	r1, r0, [sp, #4]
     7e2:	e9cd 3303 	strd	r3, r3, [sp, #12]
     7e6:	2103      	movs	r1, #3
     7e8:	9606      	str	r6, [sp, #24]
     7ea:	9300      	str	r3, [sp, #0]
     7ec:	b2d2      	uxtb	r2, r2
     7ee:	4618      	mov	r0, r3
     7f0:	f02a fb1a 	bl	2ae28 <ticker_update>
	ret = ull_ticker_status_take(ret, &ret_cb);
     7f4:	4631      	mov	r1, r6
     7f6:	f01a ffff 	bl	1b7f8 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     7fa:	b940      	cbnz	r0, 80e <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xe>
	adv->ull.ticks_slot = time_ticks;
     7fc:	6125      	str	r5, [r4, #16]
}
     7fe:	b00a      	add	sp, #40	; 0x28
     800:	bd70      	pop	{r4, r5, r6, pc}
	} else if (adv->ull.ticks_slot < time_ticks) {
     802:	d902      	bls.n	80a <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa>
		ticks_plus = time_ticks - adv->ull.ticks_slot;
     804:	1a69      	subs	r1, r5, r1
		ticks_minus = 0U;
     806:	2000      	movs	r0, #0
     808:	e7dd      	b.n	7c6 <ull_adv_time_update+0x46>
		return BT_HCI_ERR_SUCCESS;
     80a:	2000      	movs	r0, #0
     80c:	e7f7      	b.n	7fe <ull_adv_time_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
     80e:	200c      	movs	r0, #12
     810:	e7f5      	b.n	7fe <ull_adv_time_update+0x7e>
     812:	bf00      	nop
     814:	f3af 8000 	nop.w
     818:	1afd498d 	.word	0x1afd498d
     81c:	00000007 	.word	0x00000007
     820:	3b9aca00 	.word	0x3b9aca00
     824:	20003160 	.word	0x20003160
     828:	0001b24d 	.word	0x0001b24d
     82c:	00000000 	.word	0x00000000

00000830 <ull_scan_enable>:
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
						   SCAN_INT_UNIT_US);
}

uint8_t ull_scan_enable(struct ll_scan_set *scan)
{
     830:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     834:	4604      	mov	r4, r0
	scan->is_stop = 0U;
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	/* Initialize LLL scan context */
	lll = &scan->lll;
	lll->init_addr_type = scan->own_addr_type;
     836:	f890 0030 	ldrb.w	r0, [r0, #48]	; 0x30
     83a:	f894 3020 	ldrb.w	r3, [r4, #32]
	lll->is_stop = 0U;

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     83e:	4f3e      	ldr	r7, [pc, #248]	; (938 <ull_scan_enable+0x108>)
	lll->init_addr_type = scan->own_addr_type;
     840:	f3c0 0040 	ubfx	r0, r0, #1, #1
     844:	f360 1386 	bfi	r3, r0, #6, #1
{
     848:	b08c      	sub	sp, #48	; 0x30
	lll->init_addr_type = scan->own_addr_type;
     84a:	f884 3020 	strb.w	r3, [r4, #32]
	(void)ll_addr_read(lll->init_addr_type, lll->init_addr);
     84e:	f104 0121 	add.w	r1, r4, #33	; 0x21
     852:	f02a fb07 	bl	2ae64 <ll_addr_read>
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     856:	8d26      	ldrh	r6, [r4, #40]	; 0x28
	lll->chan = 0U;
     858:	f894 3020 	ldrb.w	r3, [r4, #32]
     85c:	61e4      	str	r4, [r4, #28]
     85e:	2500      	movs	r5, #0
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     860:	fba6 0107 	umull	r0, r1, r6, r7
     864:	f04f 0c91 	mov.w	ip, #145	; 0x91
	lll->chan = 0U;
     868:	f003 0379 	and.w	r3, r3, #121	; 0x79
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     86c:	fb0c 1106 	mla	r1, ip, r6, r1
	hdr->disabled_cb = hdr->disabled_param = NULL;
     870:	e9c4 5505 	strd	r5, r5, [r4, #20]
	lll->chan = 0U;
     874:	f884 3020 	strb.w	r3, [r4, #32]
	hdr->ref = 0U;
     878:	7025      	strb	r5, [r4, #0]
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     87a:	a32d      	add	r3, pc, #180	; (adr r3, 930 <ull_scan_enable+0x100>)
     87c:	e9d3 2300 	ldrd	r2, r3, [r3]
     880:	f7ff fc2e 	bl	e0 <__aeabi_uldivmod>
						SCAN_INT_UNIT_US);

	/* TODO: active_to_start feature port */
	scan->ull.ticks_active_to_start = 0U;
	scan->ull.ticks_prepare_to_start =
     884:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->ull.ticks_preempt_to_start =
     886:	e9c4 3502 	strd	r3, r5, [r4, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
     88a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	scan->ull.ticks_active_to_start = 0U;
     88c:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
     88e:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
     890:	f1a0 0231 	sub.w	r2, r0, #49	; 0x31
	if ((lll->ticks_window +
     894:	4293      	cmp	r3, r2
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US))) {
		scan->ull.ticks_slot =
     896:	bf32      	itee	cc
     898:	6123      	strcc	r3, [r4, #16]
			(lll->ticks_window +
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US));
	} else {
		if (IS_ENABLED(CONFIG_BT_CTLR_SCAN_UNRESERVED)) {
			scan->ull.ticks_slot = 0U;
     89a:	6125      	strcs	r5, [r4, #16]
		} else {
			scan->ull.ticks_slot = ticks_interval -
				HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
		}

		lll->ticks_window = 0U;
     89c:	62e5      	strcs	r5, [r4, #44]	; 0x2c
	return &ll_scan[handle];
}

uint8_t ull_scan_handle_get(struct ll_scan_set *scan)
{
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
     89e:	4d27      	ldr	r5, [pc, #156]	; (93c <ull_scan_enable+0x10c>)
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
     8a0:	4606      	mov	r6, r0
	ticks_anchor = ticker_ticks_now_get();
     8a2:	f02a fad9 	bl	2ae58 <ticker_ticks_now_get>
	ret_cb = TICKER_STATUS_BUSY;
     8a6:	2302      	movs	r3, #2
     8a8:	930b      	str	r3, [sp, #44]	; 0x2c
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
     8aa:	1b65      	subs	r5, r4, r5
     8ac:	2334      	movs	r3, #52	; 0x34
     8ae:	fbb5 f5f3 	udiv	r5, r5, r3
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8b2:	4b23      	ldr	r3, [pc, #140]	; (940 <ull_scan_enable+0x110>)
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
     8b4:	f8b4 c028 	ldrh.w	ip, [r4, #40]	; 0x28
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8b8:	e9cd 4306 	strd	r4, r3, [sp, #24]
     8bc:	46b8      	mov	r8, r7
     8be:	4b21      	ldr	r3, [pc, #132]	; (944 <ull_scan_enable+0x114>)
     8c0:	9305      	str	r3, [sp, #20]
	ticks_anchor = ticker_ticks_now_get();
     8c2:	4607      	mov	r7, r0
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8c4:	6923      	ldr	r3, [r4, #16]
     8c6:	9304      	str	r3, [sp, #16]
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
     8c8:	fbac 0808 	umull	r0, r8, ip, r8
     8cc:	2191      	movs	r1, #145	; 0x91
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8ce:	f04f 0900 	mov.w	r9, #0
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
     8d2:	fb01 810c 	mla	r1, r1, ip, r8
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8d6:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
     8da:	a315      	add	r3, pc, #84	; (adr r3, 930 <ull_scan_enable+0x100>)
     8dc:	e9d3 2300 	ldrd	r2, r3, [r3]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8e0:	f8cd a020 	str.w	sl, [sp, #32]
     8e4:	f8cd 900c 	str.w	r9, [sp, #12]
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
     8e8:	f7ff fbfa 	bl	e0 <__aeabi_uldivmod>
     8ec:	4610      	mov	r0, r2
     8ee:	4619      	mov	r1, r3
     8f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     8f4:	2300      	movs	r3, #0
     8f6:	f7ff fbf3 	bl	e0 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
     8fa:	3504      	adds	r5, #4
     8fc:	b2ed      	uxtb	r5, r5
     8fe:	e9cd 6001 	strd	r6, r0, [sp, #4]
     902:	2103      	movs	r1, #3
     904:	f8cd 9000 	str.w	r9, [sp]
     908:	463b      	mov	r3, r7
     90a:	462a      	mov	r2, r5
     90c:	4648      	mov	r0, r9
     90e:	f02a fa70 	bl	2adf2 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
     912:	4651      	mov	r1, sl
     914:	f01a ff70 	bl	1b7f8 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     918:	b940      	cbnz	r0, 92c <ull_scan_enable+0xfc>
	scan->is_enabled = 1U;
     91a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
     91e:	f043 0301 	orr.w	r3, r3, #1
     922:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
     926:	b00c      	add	sp, #48	; 0x30
     928:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     92c:	200c      	movs	r0, #12
     92e:	e7fa      	b.n	926 <ull_scan_enable+0xf6>
     930:	1afd498d 	.word	0x1afd498d
     934:	00000007 	.word	0x00000007
     938:	84e72a00 	.word	0x84e72a00
     93c:	200031f0 	.word	0x200031f0
     940:	0001b24d 	.word	0x0001b24d
     944:	0001c77d 	.word	0x0001c77d

00000948 <ll_scan_params_set>:
{
     948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     94a:	4604      	mov	r4, r0
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
     94c:	2000      	movs	r0, #0
{
     94e:	4616      	mov	r6, r2
     950:	461f      	mov	r7, r3
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
     952:	f01b ff8f 	bl	1c874 <ull_scan_is_disabled_get>
	if (!scan) {
     956:	4605      	mov	r5, r0
     958:	b320      	cbz	r0, 9a4 <ll_scan_params_set+0x5c>
	scan->own_addr_type = own_addr_type;
     95a:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
	lll->interval = interval;
     95e:	8501      	strh	r1, [r0, #40]	; 0x28
	scan->own_addr_type = own_addr_type;
     960:	f367 0342 	bfi	r3, r7, #1, #2
     964:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
	lll->filter_policy = filter_policy;
     968:	f89d 3018 	ldrb.w	r3, [sp, #24]
     96c:	0164      	lsls	r4, r4, #5
     96e:	00db      	lsls	r3, r3, #3
     970:	f003 0318 	and.w	r3, r3, #24
     974:	f004 0420 	and.w	r4, r4, #32
     978:	431c      	orrs	r4, r3
     97a:	f890 3020 	ldrb.w	r3, [r0, #32]
     97e:	f023 0338 	bic.w	r3, r3, #56	; 0x38
     982:	431c      	orrs	r4, r3
     984:	f880 4020 	strb.w	r4, [r0, #32]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
     988:	4809      	ldr	r0, [pc, #36]	; (9b0 <ll_scan_params_set+0x68>)
     98a:	2491      	movs	r4, #145	; 0x91
     98c:	fba6 0100 	umull	r0, r1, r6, r0
     990:	a305      	add	r3, pc, #20	; (adr r3, 9a8 <ll_scan_params_set+0x60>)
     992:	e9d3 2300 	ldrd	r2, r3, [r3]
     996:	fb04 1106 	mla	r1, r4, r6, r1
     99a:	f7ff fba1 	bl	e0 <__aeabi_uldivmod>
     99e:	62e8      	str	r0, [r5, #44]	; 0x2c
	return 0;
     9a0:	2000      	movs	r0, #0
}
     9a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
     9a4:	200c      	movs	r0, #12
     9a6:	e7fc      	b.n	9a2 <ll_scan_params_set+0x5a>
     9a8:	1afd498d 	.word	0x1afd498d
     9ac:	00000007 	.word	0x00000007
     9b0:	84e72a00 	.word	0x84e72a00
     9b4:	00000000 	.word	0x00000000

000009b8 <ull_conn_llcp>:

	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, uint32_t ticks_at_expire, uint16_t lazy)
{
     9b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     9bc:	4615      	mov	r5, r2
#if defined(CONFIG_BT_LL_SW_LLCP_LEGACY)
	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
     9be:	f890 3088 	ldrb.w	r3, [r0, #136]	; 0x88
     9c2:	f890 2089 	ldrb.w	r2, [r0, #137]	; 0x89
     9c6:	4293      	cmp	r3, r2
{
     9c8:	b08b      	sub	sp, #44	; 0x2c
     9ca:	4604      	mov	r4, r0
     9cc:	4689      	mov	r9, r1
	if ((conn->llcp_ack == conn->llcp_req) &&
     9ce:	d10b      	bne.n	9e8 <ull_conn_llcp+0x30>
#endif /* !CONFIG_BT_CTLR_LE_ENC */

		/* TODO: Optimize the checks below, maybe have common flag */

		/* check if connection update procedure is requested */
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
     9d0:	f890 109d 	ldrb.w	r1, [r0, #157]	; 0x9d
     9d4:	f890 209c 	ldrb.w	r2, [r0, #156]	; 0x9c
     9d8:	428a      	cmp	r2, r1
     9da:	d025      	beq.n	a28 <ull_conn_llcp+0x70>
			/* switch to LLCP_CONN_UPD state machine */
			conn->llcp_type = LLCP_CONN_UPD;
     9dc:	2201      	movs	r2, #1
			conn->llcp_ack -= 2U;
     9de:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CONN_UPD;
     9e0:	f880 208a 	strb.w	r2, [r0, #138]	; 0x8a
			conn->llcp_ack -= 2U;
     9e4:	f880 3089 	strb.w	r3, [r0, #137]	; 0x89
	}

	/* Check if procedures with instant or encryption setup is requested or
	 * active.
	 */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
     9e8:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
     9ec:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
     9f0:	1a9a      	subs	r2, r3, r2
     9f2:	f002 0203 	and.w	r2, r2, #3
     9f6:	2a02      	cmp	r2, #2
     9f8:	f040 826d 	bne.w	ed6 <__data_size+0xc6>
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}

		/* Process procedures with instants or encryption setup */
		/* FIXME: Make LE Ping cacheable */
		switch (conn->llcp_type) {
     9fc:	f894 008a 	ldrb.w	r0, [r4, #138]	; 0x8a
     a00:	2801      	cmp	r0, #1
     a02:	f000 8214 	beq.w	e2e <__data_size+0x1e>
     a06:	2802      	cmp	r0, #2
     a08:	f000 842c 	beq.w	1264 <__data_size+0x454>
		}
		break;
#endif /* CONFIG_BT_CTLR_PHY */

		default:
			LL_ASSERT(0);
     a0c:	4acc      	ldr	r2, [pc, #816]	; (d40 <ull_conn_llcp+0x388>)
     a0e:	49cd      	ldr	r1, [pc, #820]	; (d44 <ull_conn_llcp+0x38c>)
     a10:	48cd      	ldr	r0, [pc, #820]	; (d48 <ull_conn_llcp+0x390>)
     a12:	f240 43e1 	movw	r3, #1249	; 0x4e1
     a16:	f024 fbd1 	bl	251bc <printk>
     a1a:	4040      	eors	r0, r0
     a1c:	f380 8811 	msr	BASEPRI, r0
     a20:	f04f 0003 	mov.w	r0, #3
     a24:	df02      	svc	2
			break;
     a26:	e256      	b.n	ed6 <__data_size+0xc6>
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
     a28:	f890 30b1 	ldrb.w	r3, [r0, #177]	; 0xb1
     a2c:	f890 20b0 	ldrb.w	r2, [r0, #176]	; 0xb0
     a30:	4293      	cmp	r3, r2
     a32:	d05b      	beq.n	aec <ull_conn_llcp+0x134>
static inline void event_fex_prep(struct ll_conn *conn)
{
	struct node_tx *tx;

	/* If waiting for response, do nothing */
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
     a34:	1a9b      	subs	r3, r3, r2
     a36:	07da      	lsls	r2, r3, #31
     a38:	d5d6      	bpl.n	9e8 <ull_conn_llcp+0x30>
		return;
	}

	if (conn->common.fex_valid) {
     a3a:	f890 107c 	ldrb.w	r1, [r0, #124]	; 0x7c
     a3e:	f011 0801 	ands.w	r8, r1, #1
     a42:	d026      	beq.n	a92 <ull_conn_llcp+0xda>
		struct node_rx_pdu *rx;
		struct pdu_data *pdu;

		/* get a rx node for ULL->LL */
		rx = ll_pdu_rx_alloc();
     a44:	f01a fe76 	bl	1b734 <ll_pdu_rx_alloc>
		if (!rx) {
     a48:	4606      	mov	r6, r0
     a4a:	2800      	cmp	r0, #0
     a4c:	d0cc      	beq.n	9e8 <ull_conn_llcp+0x30>
			return;
		}

		/* procedure request acked */
		conn->llcp_feature.ack = conn->llcp_feature.req;
     a4e:	f894 30b0 	ldrb.w	r3, [r4, #176]	; 0xb0
     a52:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1

		/* prepare feature rsp structure */
		rx->hdr.handle = conn->lll.handle;
     a56:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     a58:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     a5a:	2303      	movs	r3, #3
     a5c:	7103      	strb	r3, [r0, #4]
		pdu = (void *)rx->pdu;
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     a5e:	7f03      	ldrb	r3, [r0, #28]
     a60:	f043 0303 	orr.w	r3, r3, #3
     a64:	7703      	strb	r3, [r0, #28]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
			   sizeof(struct pdu_data_llctrl_feature_rsp);
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
     a66:	f100 0720 	add.w	r7, r0, #32
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
     a6a:	2309      	movs	r3, #9
     a6c:	7743      	strb	r3, [r0, #29]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
     a6e:	77c3      	strb	r3, [r0, #31]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
     a70:	2208      	movs	r2, #8
     a72:	2100      	movs	r1, #0
     a74:	4638      	mov	r0, r7
     a76:	f026 ff06 	bl	27886 <memset>
			sizeof(pdu->llctrl.feature_rsp.features));
		sys_put_le64(conn->llcp_feature.features_peer,
     a7a:	e9d4 0130 	ldrd	r0, r1, [r4, #192]	; 0xc0
     a7e:	463a      	mov	r2, r7
     a80:	f02a fc11 	bl	2b2a6 <sys_put_le64>
			     pdu->llctrl.feature_req.features);

		/* enqueue feature rsp structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     a84:	4631      	mov	r1, r6
			sys_cpu_to_le16(conn->llcp_version.company_id);
		pdu->llctrl.version_ind.sub_version_number =
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);

		/* enqueue version ind structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
     a86:	6808      	ldr	r0, [r1, #0]
     a88:	f01a fda8 	bl	1b5dc <ll_rx_put>
		ll_rx_sched();
     a8c:	f01a fdb0 	bl	1b5f0 <ll_rx_sched>
     a90:	e7aa      	b.n	9e8 <ull_conn_llcp+0x30>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     a92:	48ae      	ldr	r0, [pc, #696]	; (d4c <ull_conn_llcp+0x394>)
     a94:	f029 febc 	bl	2a810 <mem_acquire>
	if (tx) {
     a98:	4606      	mov	r6, r0
     a9a:	2800      	cmp	r0, #0
     a9c:	d0a4      	beq.n	9e8 <ull_conn_llcp+0x30>
		conn->llcp_feature.ack--;
     a9e:	f894 30b1 	ldrb.w	r3, [r4, #177]	; 0xb1
     aa2:	3b01      	subs	r3, #1
     aa4:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     aa8:	7903      	ldrb	r3, [r0, #4]
     aaa:	f043 0303 	orr.w	r3, r3, #3
     aae:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
     ab0:	2309      	movs	r3, #9
     ab2:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
     ab4:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
     ab8:	2b00      	cmp	r3, #0
     aba:	bfac      	ite	ge
     abc:	2308      	movge	r3, #8
     abe:	230e      	movlt	r3, #14
		(void)memset(&pdu->llctrl.feature_req.features[0],
     ac0:	f100 0708 	add.w	r7, r0, #8
		pdu->llctrl.opcode = !conn->lll.role ?
     ac4:	71c3      	strb	r3, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
     ac6:	2208      	movs	r2, #8
     ac8:	4641      	mov	r1, r8
     aca:	4638      	mov	r0, r7
     acc:	f026 fedb 	bl	27886 <memset>
		sys_put_le64(conn->llcp_feature.features_conn,
     ad0:	e9d4 012e 	ldrd	r0, r1, [r4, #184]	; 0xb8
     ad4:	463a      	mov	r2, r7
     ad6:	f02a fbe6 	bl	2b2a6 <sys_put_le64>
		ctrl_tx_enqueue(conn, tx);
     ada:	4631      	mov	r1, r6
			ctrl_tx_enqueue(conn, tx);
     adc:	4620      	mov	r0, r4
     ade:	f02a fbf3 	bl	2b2c8 <ctrl_tx_enqueue>
			conn->procedure_expire = conn->procedure_reload;
     ae2:	f8b4 3076 	ldrh.w	r3, [r4, #118]	; 0x76
     ae6:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
     aea:	e77d      	b.n	9e8 <ull_conn_llcp+0x30>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
     aec:	f890 30c9 	ldrb.w	r3, [r0, #201]	; 0xc9
     af0:	f890 20c8 	ldrb.w	r2, [r0, #200]	; 0xc8
     af4:	4293      	cmp	r3, r2
     af6:	d05f      	beq.n	bb8 <ull_conn_llcp+0x200>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
     af8:	1a9b      	subs	r3, r3, r2
     afa:	07db      	lsls	r3, r3, #31
     afc:	f57f af74 	bpl.w	9e8 <ull_conn_llcp+0x30>
	if (conn->llcp_version.tx == 0U) {
     b00:	f890 30ca 	ldrb.w	r3, [r0, #202]	; 0xca
     b04:	07df      	lsls	r7, r3, #31
     b06:	d424      	bmi.n	b52 <ull_conn_llcp+0x19a>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     b08:	4890      	ldr	r0, [pc, #576]	; (d4c <ull_conn_llcp+0x394>)
     b0a:	f029 fe81 	bl	2a810 <mem_acquire>
		if (tx) {
     b0e:	4601      	mov	r1, r0
     b10:	2800      	cmp	r0, #0
     b12:	f43f af69 	beq.w	9e8 <ull_conn_llcp+0x30>
			conn->llcp_version.ack--;
     b16:	f894 30c9 	ldrb.w	r3, [r4, #201]	; 0xc9
     b1a:	3b01      	subs	r3, #1
     b1c:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
			conn->llcp_version.tx = 1U;
     b20:	f894 30ca 	ldrb.w	r3, [r4, #202]	; 0xca
     b24:	f043 0301 	orr.w	r3, r3, #1
     b28:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
			pdu->ll_id = PDU_DATA_LLID_CTRL;
     b2c:	7903      	ldrb	r3, [r0, #4]
     b2e:	f043 0303 	orr.w	r3, r3, #3
     b32:	7103      	strb	r3, [r0, #4]
			pdu->len =
     b34:	2306      	movs	r3, #6
     b36:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
     b38:	230c      	movs	r3, #12
     b3a:	71c3      	strb	r3, [r0, #7]
			pdu->llctrl.version_ind.version_number =
     b3c:	7203      	strb	r3, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
     b3e:	f06f 030e 	mvn.w	r3, #14
     b42:	7243      	strb	r3, [r0, #9]
     b44:	2305      	movs	r3, #5
     b46:	7283      	strb	r3, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
     b48:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     b4c:	72c3      	strb	r3, [r0, #11]
     b4e:	7303      	strb	r3, [r0, #12]
     b50:	e7c4      	b.n	adc <ull_conn_llcp+0x124>
	} else if (conn->llcp_version.rx) {
     b52:	079e      	lsls	r6, r3, #30
     b54:	d522      	bpl.n	b9c <ull_conn_llcp+0x1e4>
		rx = ll_pdu_rx_alloc();
     b56:	f01a fded 	bl	1b734 <ll_pdu_rx_alloc>
		if (!rx) {
     b5a:	4601      	mov	r1, r0
     b5c:	2800      	cmp	r0, #0
     b5e:	f43f af43 	beq.w	9e8 <ull_conn_llcp+0x30>
		conn->llcp_version.ack = conn->llcp_version.req;
     b62:	f894 30c8 	ldrb.w	r3, [r4, #200]	; 0xc8
     b66:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
		rx->hdr.handle = conn->lll.handle;
     b6a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     b6c:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     b6e:	2303      	movs	r3, #3
     b70:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     b72:	7f03      	ldrb	r3, [r0, #28]
     b74:	f043 0303 	orr.w	r3, r3, #3
     b78:	7703      	strb	r3, [r0, #28]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
     b7a:	2306      	movs	r3, #6
     b7c:	7743      	strb	r3, [r0, #29]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
     b7e:	230c      	movs	r3, #12
     b80:	77c3      	strb	r3, [r0, #31]
		pdu->llctrl.version_ind.version_number =
     b82:	f894 30cb 	ldrb.w	r3, [r4, #203]	; 0xcb
     b86:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->llctrl.version_ind.company_id =
     b8a:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
     b8e:	f8a0 3021 	strh.w	r3, [r0, #33]	; 0x21
		pdu->llctrl.version_ind.sub_version_number =
     b92:	f8b4 30ce 	ldrh.w	r3, [r4, #206]	; 0xce
     b96:	f8a0 3023 	strh.w	r3, [r0, #35]	; 0x23
     b9a:	e774      	b.n	a86 <ull_conn_llcp+0xce>
	} else {
		/* tx-ed but no rx, and new request placed */
		LL_ASSERT(0);
     b9c:	f640 63a1 	movw	r3, #3745	; 0xea1
	}
	break;
#endif /* CONFIG_BT_CTLR_SCHED_ADVANCED */

	default:
		LL_ASSERT(0);
     ba0:	4a67      	ldr	r2, [pc, #412]	; (d40 <ull_conn_llcp+0x388>)
     ba2:	4968      	ldr	r1, [pc, #416]	; (d44 <ull_conn_llcp+0x38c>)
     ba4:	4868      	ldr	r0, [pc, #416]	; (d48 <ull_conn_llcp+0x390>)
     ba6:	f024 fb09 	bl	251bc <printk>
     baa:	4040      	eors	r0, r0
     bac:	f380 8811 	msr	BASEPRI, r0
     bb0:	f04f 0003 	mov.w	r0, #3
     bb4:	df02      	svc	2
		break;
     bb6:	e717      	b.n	9e8 <ull_conn_llcp+0x30>
		} else if (conn->llcp_conn_param.ack !=
     bb8:	f890 20f5 	ldrb.w	r2, [r0, #245]	; 0xf5
     bbc:	f890 30f4 	ldrb.w	r3, [r0, #244]	; 0xf4
     bc0:	429a      	cmp	r2, r3
     bc2:	f43f af11 	beq.w	9e8 <ull_conn_llcp+0x30>
	return conn_upd_curr && (conn_upd_curr != conn);
     bc6:	4e62      	ldr	r6, [pc, #392]	; (d50 <ull_conn_llcp+0x398>)
     bc8:	6833      	ldr	r3, [r6, #0]
     bca:	b113      	cbz	r3, bd2 <ull_conn_llcp+0x21a>
	if (cpr_active_is_set(conn)) {
     bcc:	4298      	cmp	r0, r3
     bce:	f47f af0b 	bne.w	9e8 <ull_conn_llcp+0x30>
	switch (conn->llcp_conn_param.state) {
     bd2:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
     bd6:	f003 030f 	and.w	r3, r3, #15
     bda:	2b06      	cmp	r3, #6
     bdc:	f200 8124 	bhi.w	e28 <__data_size+0x18>
     be0:	a201      	add	r2, pc, #4	; (adr r2, be8 <ull_conn_llcp+0x230>)
     be2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     be6:	bf00      	nop
     be8:	00000c05 	.word	0x00000c05
     bec:	00000c89 	.word	0x00000c89
     bf0:	00000ddf 	.word	0x00000ddf
     bf4:	000009e9 	.word	0x000009e9
     bf8:	000009e9 	.word	0x000009e9
     bfc:	000009e9 	.word	0x000009e9
     c00:	000009e9 	.word	0x000009e9
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     c04:	4851      	ldr	r0, [pc, #324]	; (d4c <ull_conn_llcp+0x394>)
			event_counter = lll->event_counter +
     c06:	8e67      	ldrh	r7, [r4, #50]	; 0x32
					lll->latency_prepare + lazy;
     c08:	f8b4 802e 	ldrh.w	r8, [r4, #46]	; 0x2e
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     c0c:	f029 fe00 	bl	2a810 <mem_acquire>
	if (!tx) {
     c10:	4601      	mov	r1, r0
     c12:	2800      	cmp	r0, #0
     c14:	f43f aee8 	beq.w	9e8 <ull_conn_llcp+0x30>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     c18:	7903      	ldrb	r3, [r0, #4]
	conn_upd_curr = conn;
     c1a:	6034      	str	r4, [r6, #0]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     c1c:	f043 0303 	orr.w	r3, r3, #3
     c20:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
     c22:	2318      	movs	r3, #24
     c24:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     c26:	230f      	movs	r3, #15
     c28:	71c3      	strb	r3, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
     c2a:	f8b4 30f8 	ldrh.w	r3, [r4, #248]	; 0xf8
     c2e:	8103      	strh	r3, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
     c30:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
     c34:	8143      	strh	r3, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
     c36:	f8b4 30fc 	ldrh.w	r3, [r4, #252]	; 0xfc
     c3a:	8183      	strh	r3, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
     c3c:	f8b4 30fe 	ldrh.w	r3, [r4, #254]	; 0xfe
     c40:	81c3      	strh	r3, [r0, #14]
	p->preferred_periodicity = 0U;
     c42:	2300      	movs	r3, #0
     c44:	7403      	strb	r3, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
     c46:	74c3      	strb	r3, [r0, #19]
     c48:	7503      	strb	r3, [r0, #20]
			event_counter = lll->event_counter +
     c4a:	4447      	add	r7, r8
	p->offset1 = sys_cpu_to_le16(0xffff);
     c4c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     c50:	7543      	strb	r3, [r0, #21]
     c52:	7583      	strb	r3, [r0, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
     c54:	75c3      	strb	r3, [r0, #23]
     c56:	7603      	strb	r3, [r0, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
     c58:	7643      	strb	r3, [r0, #25]
     c5a:	7683      	strb	r3, [r0, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
     c5c:	76c3      	strb	r3, [r0, #27]
     c5e:	7703      	strb	r3, [r0, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
     c60:	7743      	strb	r3, [r0, #29]
     c62:	7783      	strb	r3, [r0, #30]
			event_counter = lll->event_counter +
     c64:	442f      	add	r7, r5
	conn->procedure_expire = conn->procedure_reload;
     c66:	f8b4 3076 	ldrh.w	r3, [r4, #118]	; 0x76
     c6a:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
     c6e:	f8a0 7011 	strh.w	r7, [r0, #17]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
     c72:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
     c76:	2204      	movs	r2, #4
     c78:	f362 0303 	bfi	r3, r2, #0, #4
     c7c:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
	ctrl_tx_enqueue(conn, tx);
     c80:	4620      	mov	r0, r4
     c82:	f02a fb21 	bl	2b2c8 <ctrl_tx_enqueue>
     c86:	e6af      	b.n	9e8 <ull_conn_llcp+0x30>
	if (conn->llcp_conn_param.status) {
     c88:	f894 30f7 	ldrb.w	r3, [r4, #247]	; 0xf7
     c8c:	b1eb      	cbz	r3, cca <ull_conn_llcp+0x312>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     c8e:	482f      	ldr	r0, [pc, #188]	; (d4c <ull_conn_llcp+0x394>)
     c90:	f029 fdbe 	bl	2a810 <mem_acquire>
		if (!tx) {
     c94:	4601      	mov	r1, r0
     c96:	2800      	cmp	r0, #0
     c98:	f43f aea6 	beq.w	9e8 <ull_conn_llcp+0x30>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
     c9c:	7903      	ldrb	r3, [r0, #4]
     c9e:	f043 0303 	orr.w	r3, r3, #3
     ca2:	7103      	strb	r3, [r0, #4]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
     ca4:	2311      	movs	r3, #17
     ca6:	71c3      	strb	r3, [r0, #7]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
     ca8:	2303      	movs	r3, #3
     caa:	7143      	strb	r3, [r0, #5]
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     cac:	230f      	movs	r3, #15
     cae:	7203      	strb	r3, [r0, #8]
		rej->error_code = conn->llcp_conn_param.status;
     cb0:	f894 30f7 	ldrb.w	r3, [r4, #247]	; 0xf7
     cb4:	7243      	strb	r3, [r0, #9]
		ctrl_tx_enqueue(conn, tx);
     cb6:	4620      	mov	r0, r4
     cb8:	f02a fb06 	bl	2b2c8 <ctrl_tx_enqueue>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
     cbc:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
     cc0:	f884 30f5 	strb.w	r3, [r4, #245]	; 0xf5
	conn_upd_curr = NULL;
     cc4:	2300      	movs	r3, #0
     cc6:	6033      	str	r3, [r6, #0]
		return;
     cc8:	e68e      	b.n	9e8 <ull_conn_llcp+0x30>
	if (!conn->lll.role) {
     cca:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
     cce:	2a00      	cmp	r2, #0
     cd0:	db40      	blt.n	d54 <ull_conn_llcp+0x39c>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     cd2:	f894 20f6 	ldrb.w	r2, [r4, #246]	; 0xf6
		conn->llcp_cu.win_offset_us = 0U;
     cd6:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     cda:	2006      	movs	r0, #6
     cdc:	f360 0203 	bfi	r2, r0, #0, #4
		preferred_periodicity = conn->llcp_conn_param.preferred_periodicity;
     ce0:	f894 0100 	ldrb.w	r0, [r4, #256]	; 0x100
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
     ce4:	f884 20f6 	strb.w	r2, [r4, #246]	; 0xf6
		conn->llcp_cu.win_size = 1U;
     ce8:	2201      	movs	r2, #1
     cea:	f884 20ac 	strb.w	r2, [r4, #172]	; 0xac
		interval_max = conn->llcp_conn_param.interval_max;
     cee:	f8b4 20fa 	ldrh.w	r2, [r4, #250]	; 0xfa
		if (preferred_periodicity) {
     cf2:	b148      	cbz	r0, d08 <ull_conn_llcp+0x350>
			conn->llcp_cu.interval = (interval_max / preferred_periodicity) *
     cf4:	fbb2 f3f0 	udiv	r3, r2, r0
     cf8:	fb13 f300 	smulbb	r3, r3, r0
			if (conn->llcp_cu.interval < conn->llcp_conn_param.interval_min) {
     cfc:	f8b4 00f8 	ldrh.w	r0, [r4, #248]	; 0xf8
			conn->llcp_cu.interval = (interval_max / preferred_periodicity) *
     d00:	b29b      	uxth	r3, r3
				conn->llcp_cu.interval = interval_max;
     d02:	4298      	cmp	r0, r3
     d04:	bf98      	it	ls
     d06:	461a      	movls	r2, r3
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
     d08:	f8b4 30fc 	ldrh.w	r3, [r4, #252]	; 0xfc
     d0c:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
     d10:	f8b4 30fe 	ldrh.w	r3, [r4, #254]	; 0xfe
     d14:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
     d18:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
			conn->llcp_cu.interval = interval_max;
     d1c:	f8a4 20a0 	strh.w	r2, [r4, #160]	; 0xa0
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
     d20:	f3c3 1300 	ubfx	r3, r3, #4, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
     d24:	f894 209e 	ldrb.w	r2, [r4, #158]	; 0x9e
     d28:	00db      	lsls	r3, r3, #3
     d2a:	f043 0302 	orr.w	r3, r3, #2
     d2e:	f022 020f 	bic.w	r2, r2, #15
     d32:	4313      	orrs	r3, r2
		conn->llcp_cu.ack--;
     d34:	3901      	subs	r1, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
     d36:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
		conn->llcp_cu.ack--;
     d3a:	f884 109d 	strb.w	r1, [r4, #157]	; 0x9d
		return;
     d3e:	e653      	b.n	9e8 <ull_conn_llcp+0x30>
     d40:	00034356 	.word	0x00034356
     d44:	00031059 	.word	0x00031059
     d48:	0002f8b5 	.word	0x0002f8b5
     d4c:	200032cc 	.word	0x200032cc
     d50:	20003238 	.word	0x20003238
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
     d54:	4866      	ldr	r0, [pc, #408]	; (ef0 <__data_size+0xe0>)
     d56:	f029 fd5b 	bl	2a810 <mem_acquire>
	if (!tx) {
     d5a:	4601      	mov	r1, r0
     d5c:	2800      	cmp	r0, #0
     d5e:	f43f ae43 	beq.w	9e8 <ull_conn_llcp+0x30>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
     d62:	7903      	ldrb	r3, [r0, #4]
     d64:	f043 0303 	orr.w	r3, r3, #3
     d68:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
     d6a:	2318      	movs	r3, #24
     d6c:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
     d6e:	2310      	movs	r3, #16
     d70:	71c3      	strb	r3, [r0, #7]
	rsp->interval_min =
     d72:	f8b4 30f8 	ldrh.w	r3, [r4, #248]	; 0xf8
     d76:	8103      	strh	r3, [r0, #8]
	rsp->interval_max =
     d78:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
     d7c:	8143      	strh	r3, [r0, #10]
	rsp->latency =
     d7e:	f8b4 30fc 	ldrh.w	r3, [r4, #252]	; 0xfc
     d82:	8183      	strh	r3, [r0, #12]
	rsp->timeout =
     d84:	f8b4 30fe 	ldrh.w	r3, [r4, #254]	; 0xfe
     d88:	81c3      	strh	r3, [r0, #14]
	rsp->preferred_periodicity =
     d8a:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
     d8e:	7403      	strb	r3, [r0, #16]
	rsp->reference_conn_event_count =
     d90:	f8b4 3102 	ldrh.w	r3, [r4, #258]	; 0x102
     d94:	f8a0 3011 	strh.w	r3, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
     d98:	f8b4 3104 	ldrh.w	r3, [r4, #260]	; 0x104
     d9c:	f8a0 3013 	strh.w	r3, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
     da0:	f8b4 3106 	ldrh.w	r3, [r4, #262]	; 0x106
     da4:	f8a0 3015 	strh.w	r3, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
     da8:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
     dac:	f8a0 3017 	strh.w	r3, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
     db0:	f8b4 310a 	ldrh.w	r3, [r4, #266]	; 0x10a
     db4:	f8a0 3019 	strh.w	r3, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
     db8:	f8b4 310c 	ldrh.w	r3, [r4, #268]	; 0x10c
     dbc:	f8a0 301b 	strh.w	r3, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
     dc0:	f8b4 310e 	ldrh.w	r3, [r4, #270]	; 0x10e
     dc4:	f8a0 301d 	strh.w	r3, [r0, #29]
	ctrl_tx_enqueue(conn, tx);
     dc8:	4620      	mov	r0, r4
     dca:	f02a fa7d 	bl	2b2c8 <ctrl_tx_enqueue>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD_WAIT;
     dce:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
     dd2:	2205      	movs	r2, #5
     dd4:	f362 0303 	bfi	r3, r2, #0, #4
     dd8:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
     ddc:	e604      	b.n	9e8 <ull_conn_llcp+0x30>
	rx = ll_pdu_rx_alloc();
     dde:	f01a fca9 	bl	1b734 <ll_pdu_rx_alloc>
	if (!rx) {
     de2:	4601      	mov	r1, r0
     de4:	2800      	cmp	r0, #0
     de6:	f43f adff 	beq.w	9e8 <ull_conn_llcp+0x30>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
     dea:	f894 20f6 	ldrb.w	r2, [r4, #246]	; 0xf6
     dee:	2303      	movs	r3, #3
     df0:	f363 0203 	bfi	r2, r3, #0, #4
     df4:	f884 20f6 	strb.w	r2, [r4, #246]	; 0xf6
	rx->hdr.handle = conn->lll.handle;
     df8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
     dfa:	7103      	strb	r3, [r0, #4]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
     dfc:	7f03      	ldrb	r3, [r0, #28]
	rx->hdr.handle = conn->lll.handle;
     dfe:	80c2      	strh	r2, [r0, #6]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
     e00:	f043 0303 	orr.w	r3, r3, #3
     e04:	7703      	strb	r3, [r0, #28]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
     e06:	2318      	movs	r3, #24
     e08:	7743      	strb	r3, [r0, #29]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
     e0a:	230f      	movs	r3, #15
     e0c:	77c3      	strb	r3, [r0, #31]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
     e0e:	f8b4 30f8 	ldrh.w	r3, [r4, #248]	; 0xf8
     e12:	8403      	strh	r3, [r0, #32]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
     e14:	f8b4 30fa 	ldrh.w	r3, [r4, #250]	; 0xfa
     e18:	8443      	strh	r3, [r0, #34]	; 0x22
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
     e1a:	f8b4 30fc 	ldrh.w	r3, [r4, #252]	; 0xfc
     e1e:	8483      	strh	r3, [r0, #36]	; 0x24
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
     e20:	f8b4 30fe 	ldrh.w	r3, [r4, #254]	; 0xfe
     e24:	84c3      	strh	r3, [r0, #38]	; 0x26
	ll_rx_put(rx->hdr.link, rx);
     e26:	e62e      	b.n	a86 <ull_conn_llcp+0xce>
		LL_ASSERT(0);
     e28:	f640 73e1 	movw	r3, #4065	; 0xfe1
     e2c:	e6b8      	b.n	ba0 <ull_conn_llcp+0x1e8>
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
     e2e:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
     e30:	8e62      	ldrh	r2, [r4, #50]	; 0x32
     e32:	440a      	add	r2, r1
     e34:	fa15 f582 	uxtah	r5, r5, r2
     e38:	fa1f fb82 	uxth.w	fp, r2
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
     e3c:	f894 209e 	ldrb.w	r2, [r4, #158]	; 0x9e
     e40:	f012 0107 	ands.w	r1, r2, #7
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
     e44:	b2ad      	uxth	r5, r5
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
     e46:	d055      	beq.n	ef4 <__data_size+0xe4>
		rx = ll_pdu_rx_alloc_peek(1);
     e48:	f01a fc5c 	bl	1b704 <ll_pdu_rx_alloc_peek>
		if (!rx) {
     e4c:	4607      	mov	r7, r0
     e4e:	2800      	cmp	r0, #0
     e50:	d041      	beq.n	ed6 <__data_size+0xc6>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
     e52:	4827      	ldr	r0, [pc, #156]	; (ef0 <__data_size+0xe0>)
     e54:	f029 fcdc 	bl	2a810 <mem_acquire>
		if (!tx) {
     e58:	4606      	mov	r6, r0
     e5a:	2800      	cmp	r0, #0
     e5c:	d03b      	beq.n	ed6 <__data_size+0xc6>
		cpr_active_check_and_set(conn);
     e5e:	4620      	mov	r0, r4
     e60:	f01b fd14 	bl	1c88c <cpr_active_check_and_set>
		(void)ll_pdu_rx_alloc();
     e64:	f01a fc66 	bl	1b734 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
     e68:	683b      	ldr	r3, [r7, #0]
     e6a:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
     e6e:	605a      	str	r2, [r3, #4]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     e70:	7933      	ldrb	r3, [r6, #4]
		conn->llcp_rx = rx;
     e72:	f8c4 7098 	str.w	r7, [r4, #152]	; 0x98
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
     e76:	f043 0303 	orr.w	r3, r3, #3
     e7a:	7133      	strb	r3, [r6, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
     e7c:	2200      	movs	r2, #0
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
     e7e:	230c      	movs	r3, #12
     e80:	7173      	strb	r3, [r6, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
     e82:	71f2      	strb	r2, [r6, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
     e84:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
     e88:	7233      	strb	r3, [r6, #8]
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us /
     e8a:	f240 41e2 	movw	r1, #1250	; 0x4e2
     e8e:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
     e92:	fbb3 f3f1 	udiv	r3, r3, r1
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
     e96:	f8a6 3009 	strh.w	r3, [r6, #9]
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
     e9a:	f8b4 30a0 	ldrh.w	r3, [r4, #160]	; 0xa0
     e9e:	f8a6 300b 	strh.w	r3, [r6, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
     ea2:	f8b4 30a2 	ldrh.w	r3, [r4, #162]	; 0xa2
     ea6:	f8a6 300d 	strh.w	r3, [r6, #13]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
     eaa:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
     eae:	f8a6 300f 	strh.w	r3, [r6, #15]
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
     eb2:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
     eb6:	f362 0302 	bfi	r3, r2, #0, #3
     eba:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
					      conn->lll.latency + 6;
     ebe:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     ec0:	3306      	adds	r3, #6
     ec2:	441d      	add	r5, r3
     ec4:	b2ad      	uxth	r5, r5
		conn->llcp.conn_upd.instant = event_counter +
     ec6:	f8a4 508c 	strh.w	r5, [r4, #140]	; 0x8c
		pdu_ctrl_tx->llctrl.conn_update_ind.instant =
     eca:	f8a6 5011 	strh.w	r5, [r6, #17]
			ctrl_tx_enqueue(conn, tx);
     ece:	4631      	mov	r1, r6
     ed0:	4620      	mov	r0, r4
     ed2:	f02a f9f9 	bl	2b2c8 <ctrl_tx_enqueue>
	if (((conn->llcp_terminate.req - conn->llcp_terminate.ack) & 0xFF) ==
     ed6:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
     eda:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
     ede:	1a9b      	subs	r3, r3, r2
     ee0:	b2db      	uxtb	r3, r3
     ee2:	2b01      	cmp	r3, #1
     ee4:	f000 820a 	beq.w	12fc <__data_size+0x4ec>
	return 0;
     ee8:	2000      	movs	r0, #0
}
     eea:	b00b      	add	sp, #44	; 0x2c
     eec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     ef0:	200032cc 	.word	0x200032cc
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
     ef4:	f8b4 808c 	ldrh.w	r8, [r4, #140]	; 0x8c
     ef8:	eba5 0508 	sub.w	r5, r5, r8
     efc:	fa1f fa85 	uxth.w	sl, r5
	} else if (instant_latency <= 0x7FFF) {
     f00:	042d      	lsls	r5, r5, #16
     f02:	d4e8      	bmi.n	ed6 <__data_size+0xc6>
			conn->llcp_ack = conn->llcp_req;
     f04:	f884 3089 	strb.w	r3, [r4, #137]	; 0x89
		conn->llcp_cu.ack = conn->llcp_cu.req;
     f08:	f894 309c 	ldrb.w	r3, [r4, #156]	; 0x9c
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
     f0c:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
		conn->llcp_cu.ack = conn->llcp_cu.req;
     f10:	f884 309d 	strb.w	r3, [r4, #157]	; 0x9d
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
     f14:	f894 30f5 	ldrb.w	r3, [r4, #245]	; 0xf5
     f18:	4293      	cmp	r3, r2
     f1a:	d009      	beq.n	f30 <__data_size+0x120>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
     f1c:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
     f20:	f003 030f 	and.w	r3, r3, #15
     f24:	2b06      	cmp	r3, #6
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
     f26:	bf04      	itt	eq
     f28:	f884 20f5 	strbeq.w	r2, [r4, #245]	; 0xf5
			conn->procedure_expire = 0U;
     f2c:	f8a4 1078 	strheq.w	r1, [r4, #120]	; 0x78
	if (conn == conn_upd_curr) {
     f30:	4bbf      	ldr	r3, [pc, #764]	; (1230 <__data_size+0x420>)
		rx = conn->llcp_rx;
     f32:	f8d4 5098 	ldr.w	r5, [r4, #152]	; 0x98
	if (conn == conn_upd_curr) {
     f36:	681a      	ldr	r2, [r3, #0]
     f38:	4294      	cmp	r4, r2
		conn_upd_curr = NULL;
     f3a:	bf04      	itt	eq
     f3c:	2200      	moveq	r2, #0
     f3e:	601a      	streq	r2, [r3, #0]
		LL_ASSERT(rx && rx->hdr.link);
     f40:	b10d      	cbz	r5, f46 <__data_size+0x136>
     f42:	682b      	ldr	r3, [r5, #0]
     f44:	b963      	cbnz	r3, f60 <__data_size+0x150>
     f46:	4abb      	ldr	r2, [pc, #748]	; (1234 <__data_size+0x424>)
     f48:	49bb      	ldr	r1, [pc, #748]	; (1238 <__data_size+0x428>)
     f4a:	48bc      	ldr	r0, [pc, #752]	; (123c <__data_size+0x42c>)
     f4c:	f44f 6342 	mov.w	r3, #3104	; 0xc20
     f50:	f024 f934 	bl	251bc <printk>
     f54:	4040      	eors	r0, r0
     f56:	f380 8811 	msr	BASEPRI, r0
     f5a:	f04f 0003 	mov.w	r0, #3
     f5e:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
     f60:	6828      	ldr	r0, [r5, #0]
		if ((conn->llcp_cu.interval != lll->interval) ||
     f62:	f8b4 20a0 	ldrh.w	r2, [r4, #160]	; 0xa0
		conn->llcp_rx = rx->hdr.link->mem;
     f66:	6843      	ldr	r3, [r0, #4]
     f68:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
		if ((conn->llcp_cu.interval != lll->interval) ||
     f6c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
		    (conn->llcp_cu.latency != lll->latency) ||
     f6e:	f8b4 60a2 	ldrh.w	r6, [r4, #162]	; 0xa2
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
     f72:	f8b4 10a4 	ldrh.w	r1, [r4, #164]	; 0xa4
		if ((conn->llcp_cu.interval != lll->interval) ||
     f76:	429a      	cmp	r2, r3
     f78:	d113      	bne.n	fa2 <__data_size+0x192>
     f7a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
     f7c:	42b3      	cmp	r3, r6
     f7e:	d110      	bne.n	fa2 <__data_size+0x192>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
     f80:	f240 43e2 	movw	r3, #1250	; 0x4e2
     f84:	fb03 f702 	mul.w	r7, r3, r2
     f88:	f242 7310 	movw	r3, #10000	; 0x2710
     f8c:	fb03 7301 	mla	r3, r3, r1, r7
     f90:	3b01      	subs	r3, #1
     f92:	fbb3 f3f7 	udiv	r3, r3, r7
		    (conn->llcp_cu.latency != lll->latency) ||
     f96:	f8b4 7072 	ldrh.w	r7, [r4, #114]	; 0x72
     f9a:	b29b      	uxth	r3, r3
     f9c:	429f      	cmp	r7, r3
     f9e:	f000 811f 	beq.w	11e0 <__data_size+0x3d0>
			rx->hdr.handle = lll->handle;
     fa2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     fa4:	80eb      	strh	r3, [r5, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
     fa6:	2318      	movs	r3, #24
     fa8:	712b      	strb	r3, [r5, #4]
			cu->status = 0x00;
     faa:	2300      	movs	r3, #0
     fac:	772b      	strb	r3, [r5, #28]
			cu->interval = conn->llcp_cu.interval;
     fae:	83ea      	strh	r2, [r5, #30]
			cu->latency = conn->llcp_cu.latency;
     fb0:	842e      	strh	r6, [r5, #32]
			cu->timeout = conn->llcp_cu.timeout;
     fb2:	8469      	strh	r1, [r5, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
     fb4:	4629      	mov	r1, r5
     fb6:	f01a fb11 	bl	1b5dc <ll_rx_put>
		ll_rx_sched();
     fba:	f01a fb19 	bl	1b5f0 <ll_rx_sched>
		if (conn->ull.ticks_prepare_to_start & XON_BITMASK) {
     fbe:	68a3      	ldr	r3, [r4, #8]
     fc0:	2b00      	cmp	r3, #0
     fc2:	da0a      	bge.n	fda <__data_size+0x1ca>
			uint32_t ticks_prepare_to_start =
     fc4:	68e0      	ldr	r0, [r4, #12]
     fc6:	6862      	ldr	r2, [r4, #4]
			conn->ull.ticks_prepare_to_start &= ~XON_BITMASK;
     fc8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			ticks_at_expire -= (conn->ull.ticks_prepare_to_start -
     fcc:	4290      	cmp	r0, r2
     fce:	bf2c      	ite	cs
     fd0:	4481      	addcs	r9, r0
     fd2:	4491      	addcc	r9, r2
			conn->ull.ticks_prepare_to_start &= ~XON_BITMASK;
     fd4:	60a3      	str	r3, [r4, #8]
			ticks_at_expire -= (conn->ull.ticks_prepare_to_start -
     fd6:	eba9 0903 	sub.w	r9, r9, r3
		conn_interval_old = instant_latency * lll->interval;
     fda:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
		latency = conn_interval_old / conn->llcp_cu.interval;
     fdc:	f8b4 60a0 	ldrh.w	r6, [r4, #160]	; 0xa0
     fe0:	4d97      	ldr	r5, [pc, #604]	; (1240 <__data_size+0x430>)
		conn_interval_old = instant_latency * lll->interval;
     fe2:	fb10 f00a 	smulbb	r0, r0, sl
     fe6:	b280      	uxth	r0, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
     fe8:	fbb0 f2f6 	udiv	r2, r0, r6
		conn_interval_new = latency * conn->llcp_cu.interval;
     fec:	fb16 f302 	smulbb	r3, r6, r2
     ff0:	b29b      	uxth	r3, r3
		if (conn_interval_new > conn_interval_old) {
     ff2:	4298      	cmp	r0, r3
		latency = conn_interval_old / conn->llcp_cu.interval;
     ff4:	b297      	uxth	r7, r2
		if (conn_interval_new > conn_interval_old) {
     ff6:	f240 41e2 	movw	r1, #1250	; 0x4e2
     ffa:	f080 80f4 	bcs.w	11e6 <__data_size+0x3d6>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
     ffe:	1a18      	subs	r0, r3, r0
    1000:	4348      	muls	r0, r1
    1002:	a389      	add	r3, pc, #548	; (adr r3, 1228 <__data_size+0x418>)
    1004:	e9d3 2300 	ldrd	r2, r3, [r3]
    1008:	fba0 0105 	umull	r0, r1, r0, r5
    100c:	f7ff f868 	bl	e0 <__aeabi_uldivmod>
    1010:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1014:	4481      	add	r9, r0
		lll->latency_prepare -= (instant_latency - latency);
    1016:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    1018:	4498      	add	r8, r3
		} else if (lll->role) {
    101a:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
		lll->latency_prepare -= (instant_latency - latency);
    101e:	eba8 0b0b 	sub.w	fp, r8, fp
    1022:	44bb      	add	fp, r7
		conn_interval_us = conn->llcp_cu.interval *
    1024:	f240 48e2 	movw	r8, #1250	; 0x4e2
		} else if (lll->role) {
    1028:	2b00      	cmp	r3, #0
		lll->latency_prepare -= (instant_latency - latency);
    102a:	f8a4 b02e 	strh.w	fp, [r4, #46]	; 0x2e
		conn_interval_us = conn->llcp_cu.interval *
    102e:	fb08 fb06 	mul.w	fp, r8, r6
		} else if (lll->role) {
    1032:	f280 80e6 	bge.w	1202 <__data_size+0x3f2>
				lll->periph.window_widening_periodic_us *
    1036:	6c22      	ldr	r2, [r4, #64]	; 0x40
			lll->periph.window_widening_prepare_us -=
    1038:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    103a:	fb02 331a 	mls	r3, r2, sl, r3
    103e:	64a3      	str	r3, [r4, #72]	; 0x48
				ceiling_fraction(((lll_clock_ppm_local_get() +
    1040:	f02a fb2e 	bl	2b6a0 <lll_clock_ppm_local_get>
    1044:	4606      	mov	r6, r0
    1046:	f894 007c 	ldrb.w	r0, [r4, #124]	; 0x7c
    104a:	f3c0 00c2 	ubfx	r0, r0, #3, #3
    104e:	f01d fc21 	bl	1e894 <lll_clock_ppm_get>
				conn->llcp_cu.win_size * CONN_INT_UNIT_US;
    1052:	f894 20ac 	ldrb.w	r2, [r4, #172]	; 0xac
				ceiling_fraction(((lll_clock_ppm_local_get() +
    1056:	4406      	add	r6, r0
				conn->llcp_cu.win_size * CONN_INT_UNIT_US;
    1058:	fb08 f202 	mul.w	r2, r8, r2
			lll->periph.window_size_prepare_us =
    105c:	6522      	str	r2, [r4, #80]	; 0x50
				ceiling_fraction(((lll_clock_ppm_local_get() +
    105e:	fb0b f606 	mul.w	r6, fp, r6
			conn->periph.ticks_to_offset = 0U;
    1062:	2200      	movs	r2, #0
    1064:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
				ceiling_fraction(((lll_clock_ppm_local_get() +
    1068:	f506 2674 	add.w	r6, r6, #999424	; 0xf4000
			lll->periph.window_widening_prepare_us +=
    106c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
				ceiling_fraction(((lll_clock_ppm_local_get() +
    106e:	4875      	ldr	r0, [pc, #468]	; (1244 <__data_size+0x434>)
    1070:	f206 263f 	addw	r6, r6, #575	; 0x23f
				(conn_interval_us >> 1) - EVENT_IFS_US;
    1074:	ea4f 035b 	mov.w	r3, fp, lsr #1
				ceiling_fraction(((lll_clock_ppm_local_get() +
    1078:	fbb6 f6f0 	udiv	r6, r6, r0
				lll->periph.window_widening_periodic_us *
    107c:	fb06 f007 	mul.w	r0, r6, r7
				(conn_interval_us >> 1) - EVENT_IFS_US;
    1080:	3b96      	subs	r3, #150	; 0x96
			lll->periph.window_widening_prepare_us +=
    1082:	4402      	add	r2, r0
			lll->periph.window_widening_periodic_us =
    1084:	6426      	str	r6, [r4, #64]	; 0x40
			lll->periph.window_widening_max_us =
    1086:	6463      	str	r3, [r4, #68]	; 0x44
			lll->periph.window_widening_prepare_us +=
    1088:	429a      	cmp	r2, r3
    108a:	bf94      	ite	ls
    108c:	64a2      	strls	r2, [r4, #72]	; 0x48
    108e:	64a3      	strhi	r3, [r4, #72]	; 0x48
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    1090:	fba0 0105 	umull	r0, r1, r0, r5
    1094:	a364      	add	r3, pc, #400	; (adr r3, 1228 <__data_size+0x418>)
    1096:	e9d3 2300 	ldrd	r2, r3, [r3]
    109a:	f7ff f821 	bl	e0 <__aeabi_uldivmod>
    109e:	eba9 0900 	sub.w	r9, r9, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    10a2:	f8d4 00a8 	ldr.w	r0, [r4, #168]	; 0xa8
    10a6:	fbb0 f0f8 	udiv	r0, r0, r8
    10aa:	fb08 f000 	mul.w	r0, r8, r0
    10ae:	a35e      	add	r3, pc, #376	; (adr r3, 1228 <__data_size+0x418>)
    10b0:	e9d3 2300 	ldrd	r2, r3, [r3]
    10b4:	fba0 0105 	umull	r0, r1, r0, r5
    10b8:	f7ff f812 	bl	e0 <__aeabi_uldivmod>
			periodic_us -= lll->periph.window_widening_periodic_us;
    10bc:	ebab 0606 	sub.w	r6, fp, r6
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    10c0:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
		lll->interval = conn->llcp_cu.interval;
    10c4:	f8b4 30a0 	ldrh.w	r3, [r4, #160]	; 0xa0
    10c8:	8563      	strh	r3, [r4, #42]	; 0x2a
		lll->latency = conn->llcp_cu.latency;
    10ca:	f8b4 30a2 	ldrh.w	r3, [r4, #162]	; 0xa2
    10ce:	85a3      	strh	r3, [r4, #44]	; 0x2c
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    10d0:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
    10d4:	f242 7210 	movw	r2, #10000	; 0x2710
    10d8:	fb02 b303 	mla	r3, r2, r3, fp
    10dc:	3b01      	subs	r3, #1
    10de:	fbb3 f3fb 	udiv	r3, r3, fp
    10e2:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    10e6:	4b58      	ldr	r3, [pc, #352]	; (1248 <__data_size+0x438>)
    10e8:	445b      	add	r3, fp
    10ea:	fbb3 f3fb 	udiv	r3, r3, fp
    10ee:	f8a4 3076 	strh.w	r3, [r4, #118]	; 0x76
		if (conn->llcp_cu.cmd) {
    10f2:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
    10f6:	0718      	lsls	r0, r3, #28
			conn->supervision_expire = 0U;
    10f8:	bf44      	itt	mi
    10fa:	2300      	movmi	r3, #0
    10fc:	f8a4 3074 	strhmi.w	r3, [r4, #116]	; 0x74
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    1100:	2102      	movs	r1, #2
    1102:	2001      	movs	r0, #1
    1104:	f01f fa30 	bl	20568 <mayfly_is_enabled>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    1108:	2200      	movs	r2, #0
    110a:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    110c:	4682      	mov	sl, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    110e:	2001      	movs	r0, #1
    1110:	f018 f976 	bl	19400 <mayfly_enable>
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    1114:	4620      	mov	r0, r4
    1116:	f01b fd45 	bl	1cba4 <ll_conn_handle_get>
    111a:	f100 0805 	add.w	r8, r0, #5
    111e:	fa5f f888 	uxtb.w	r8, r8
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
    1122:	4b4a      	ldr	r3, [pc, #296]	; (124c <__data_size+0x43c>)
    1124:	9400      	str	r4, [sp, #0]
    1126:	4642      	mov	r2, r8
    1128:	2101      	movs	r1, #1
    112a:	2000      	movs	r0, #0
    112c:	f018 ff5a 	bl	19fe4 <ticker_stop>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1130:	f030 0302 	bics.w	r3, r0, #2
    1134:	d00c      	beq.n	1150 <__data_size+0x340>
    1136:	4a3f      	ldr	r2, [pc, #252]	; (1234 <__data_size+0x424>)
    1138:	4945      	ldr	r1, [pc, #276]	; (1250 <__data_size+0x440>)
    113a:	4840      	ldr	r0, [pc, #256]	; (123c <__data_size+0x42c>)
    113c:	f640 43cb 	movw	r3, #3275	; 0xccb
    1140:	f024 f83c 	bl	251bc <printk>
    1144:	4040      	eors	r0, r0
    1146:	f380 8811 	msr	BASEPRI, r0
    114a:	f04f 0003 	mov.w	r0, #3
    114e:	df02      	svc	2
				     HAL_TICKER_US_TO_TICKS(periodic_us),
    1150:	fba6 6505 	umull	r6, r5, r6, r5
    1154:	a334      	add	r3, pc, #208	; (adr r3, 1228 <__data_size+0x418>)
    1156:	e9d3 2300 	ldrd	r2, r3, [r3]
    115a:	4630      	mov	r0, r6
    115c:	4629      	mov	r1, r5
    115e:	f7fe ffbf 	bl	e0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    1162:	4b3c      	ldr	r3, [pc, #240]	; (1254 <__data_size+0x444>)
    1164:	9408      	str	r4, [sp, #32]
    1166:	e9cd 4306 	strd	r4, r3, [sp, #24]
    116a:	4b3b      	ldr	r3, [pc, #236]	; (1258 <__data_size+0x448>)
    116c:	9305      	str	r3, [sp, #20]
    116e:	6923      	ldr	r3, [r4, #16]
    1170:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(periodic_us),
    1172:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
    1176:	4839      	ldr	r0, [pc, #228]	; (125c <__data_size+0x44c>)
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    1178:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    117c:	9303      	str	r3, [sp, #12]
				     HAL_TICKER_REMAINDER(periodic_us),
    117e:	fba4 0100 	umull	r0, r1, r4, r0
    1182:	2307      	movs	r3, #7
    1184:	1a30      	subs	r0, r6, r0
    1186:	fb03 1104 	mla	r1, r3, r4, r1
    118a:	eb65 0101 	sbc.w	r1, r5, r1
    118e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1192:	2300      	movs	r3, #0
    1194:	f7fe ffa4 	bl	e0 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    1198:	464b      	mov	r3, r9
    119a:	e9cd 4001 	strd	r4, r0, [sp, #4]
    119e:	9700      	str	r7, [sp, #0]
    11a0:	4642      	mov	r2, r8
    11a2:	2101      	movs	r1, #1
    11a4:	2000      	movs	r0, #0
    11a6:	f029 fe24 	bl	2adf2 <ticker_start>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    11aa:	f030 0302 	bics.w	r3, r0, #2
    11ae:	d00c      	beq.n	11ca <__data_size+0x3ba>
    11b0:	4a20      	ldr	r2, [pc, #128]	; (1234 <__data_size+0x424>)
    11b2:	4927      	ldr	r1, [pc, #156]	; (1250 <__data_size+0x440>)
    11b4:	4821      	ldr	r0, [pc, #132]	; (123c <__data_size+0x42c>)
    11b6:	f640 43e5 	movw	r3, #3301	; 0xce5
    11ba:	f023 ffff 	bl	251bc <printk>
    11be:	4040      	eors	r0, r0
    11c0:	f380 8811 	msr	BASEPRI, r0
    11c4:	f04f 0003 	mov.w	r0, #3
    11c8:	df02      	svc	2
		if (mayfly_was_enabled) {
    11ca:	f1ba 0f00 	cmp.w	sl, #0
    11ce:	d004      	beq.n	11da <__data_size+0x3ca>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
    11d0:	2201      	movs	r2, #1
    11d2:	2102      	movs	r1, #2
    11d4:	4610      	mov	r0, r2
    11d6:	f018 f913 	bl	19400 <mayfly_enable>
				return -ECANCELED;
    11da:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    11de:	e684      	b.n	eea <__data_size+0xda>
			rx->hdr.type = NODE_RX_TYPE_RELEASE;
    11e0:	2301      	movs	r3, #1
    11e2:	712b      	strb	r3, [r5, #4]
    11e4:	e6e6      	b.n	fb4 <__data_size+0x1a4>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    11e6:	fb06 0012 	mls	r0, r6, r2, r0
    11ea:	b280      	uxth	r0, r0
    11ec:	4348      	muls	r0, r1
    11ee:	a30e      	add	r3, pc, #56	; (adr r3, 1228 <__data_size+0x418>)
    11f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    11f4:	fba0 0105 	umull	r0, r1, r0, r5
    11f8:	f7fe ff72 	bl	e0 <__aeabi_uldivmod>
    11fc:	eba9 0900 	sub.w	r9, r9, r0
    1200:	e709      	b.n	1016 <__data_size+0x206>
			LL_ASSERT(0);
    1202:	4a0c      	ldr	r2, [pc, #48]	; (1234 <__data_size+0x424>)
    1204:	4916      	ldr	r1, [pc, #88]	; (1260 <__data_size+0x450>)
    1206:	480d      	ldr	r0, [pc, #52]	; (123c <__data_size+0x42c>)
    1208:	f640 439c 	movw	r3, #3228	; 0xc9c
    120c:	f023 ffd6 	bl	251bc <printk>
    1210:	4040      	eors	r0, r0
    1212:	f380 8811 	msr	BASEPRI, r0
    1216:	f04f 0003 	mov.w	r0, #3
    121a:	df02      	svc	2
		uint32_t ticks_win_offset = 0;
    121c:	2700      	movs	r7, #0
		periodic_us = conn_interval_us;
    121e:	465e      	mov	r6, fp
    1220:	e750      	b.n	10c4 <__data_size+0x2b4>
    1222:	bf00      	nop
    1224:	f3af 8000 	nop.w
    1228:	1afd498d 	.word	0x1afd498d
    122c:	00000007 	.word	0x00000007
    1230:	20003238 	.word	0x20003238
    1234:	00034356 	.word	0x00034356
    1238:	00034420 	.word	0x00034420
    123c:	0002f8b5 	.word	0x0002f8b5
    1240:	3b9aca00 	.word	0x3b9aca00
    1244:	000f4240 	.word	0x000f4240
    1248:	026259ff 	.word	0x026259ff
    124c:	0001cadd 	.word	0x0001cadd
    1250:	00034433 	.word	0x00034433
    1254:	0001ca85 	.word	0x0001ca85
    1258:	0001dd25 	.word	0x0001dd25
    125c:	1afd498d 	.word	0x1afd498d
    1260:	00031059 	.word	0x00031059
			event_counter = lll->event_counter +
    1264:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
    1266:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    1268:	440a      	add	r2, r1
    126a:	4415      	add	r5, r2
	if (conn->llcp.chan_map.initiate) {
    126c:	f894 208c 	ldrb.w	r2, [r4, #140]	; 0x8c
    1270:	07d1      	lsls	r1, r2, #31
			event_counter = lll->event_counter +
    1272:	b2ad      	uxth	r5, r5
	if (conn->llcp.chan_map.initiate) {
    1274:	d524      	bpl.n	12c0 <__data_size+0x4b0>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    1276:	4835      	ldr	r0, [pc, #212]	; (134c <__data_size+0x53c>)
    1278:	f029 faca 	bl	2a810 <mem_acquire>
		if (tx) {
    127c:	4606      	mov	r6, r0
    127e:	2800      	cmp	r0, #0
    1280:	f43f ae29 	beq.w	ed6 <__data_size+0xc6>
			conn->llcp.chan_map.initiate = 0U;
    1284:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
    1288:	f36f 0300 	bfc	r3, #0, #1
    128c:	f884 308c 	strb.w	r3, [r4, #140]	; 0x8c
						      conn->lll.latency + 6;
    1290:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    1292:	3306      	adds	r3, #6
    1294:	441d      	add	r5, r3
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    1296:	7903      	ldrb	r3, [r0, #4]
			conn->llcp.chan_map.instant = event_counter +
    1298:	f8a4 5092 	strh.w	r5, [r4, #146]	; 0x92
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    129c:	f043 0303 	orr.w	r3, r3, #3
    12a0:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    12a2:	2308      	movs	r3, #8
    12a4:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
    12a6:	2301      	movs	r3, #1
    12a8:	71c3      	strb	r3, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
    12aa:	2205      	movs	r2, #5
    12ac:	f104 018d 	add.w	r1, r4, #141	; 0x8d
    12b0:	3008      	adds	r0, #8
    12b2:	f026 fadd 	bl	27870 <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
    12b6:	f8b4 3092 	ldrh.w	r3, [r4, #146]	; 0x92
    12ba:	f8a6 300d 	strh.w	r3, [r6, #13]
    12be:	e606      	b.n	ece <__data_size+0xbe>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
    12c0:	f8b4 2092 	ldrh.w	r2, [r4, #146]	; 0x92
    12c4:	1aad      	subs	r5, r5, r2
    12c6:	042a      	lsls	r2, r5, #16
    12c8:	f53f ae05 	bmi.w	ed6 <__data_size+0xc6>
		memcpy(&lll->data_chan_map[0],
    12cc:	f104 0534 	add.w	r5, r4, #52	; 0x34
			conn->llcp_ack = conn->llcp_req;
    12d0:	f884 3089 	strb.w	r3, [r4, #137]	; 0x89
		memcpy(&lll->data_chan_map[0],
    12d4:	2205      	movs	r2, #5
    12d6:	f104 018d 	add.w	r1, r4, #141	; 0x8d
    12da:	4628      	mov	r0, r5
    12dc:	f026 fac8 	bl	27870 <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
    12e0:	2105      	movs	r1, #5
    12e2:	4628      	mov	r0, r5
    12e4:	f029 fb10 	bl	2a908 <util_ones_count_get>
		lll->data_chan_count =
    12e8:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    12ec:	f360 0305 	bfi	r3, r0, #0, #6
    12f0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
		conn->chm_updated = 1U;
    12f4:	2301      	movs	r3, #1
    12f6:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    12fa:	e5ec      	b.n	ed6 <__data_size+0xc6>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    12fc:	4813      	ldr	r0, [pc, #76]	; (134c <__data_size+0x53c>)
    12fe:	f029 fa87 	bl	2a810 <mem_acquire>
		if (tx) {
    1302:	4601      	mov	r1, r0
    1304:	b188      	cbz	r0, 132a <__data_size+0x51a>
			conn->llcp_terminate.ack--;
    1306:	f894 30d1 	ldrb.w	r3, [r4, #209]	; 0xd1
    130a:	3b01      	subs	r3, #1
    130c:	f884 30d1 	strb.w	r3, [r4, #209]	; 0xd1
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
    1310:	7903      	ldrb	r3, [r0, #4]
    1312:	f043 0303 	orr.w	r3, r3, #3
    1316:	7103      	strb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
    1318:	2302      	movs	r3, #2
    131a:	7143      	strb	r3, [r0, #5]
			pdu_tx->llctrl.opcode =
    131c:	71c3      	strb	r3, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
    131e:	f894 30d2 	ldrb.w	r3, [r4, #210]	; 0xd2
    1322:	7203      	strb	r3, [r0, #8]
			ctrl_tx_enqueue(conn, tx);
    1324:	4620      	mov	r0, r4
    1326:	f029 ffcf 	bl	2b2c8 <ctrl_tx_enqueue>
		if (!conn->procedure_expire) {
    132a:	f8b4 0078 	ldrh.w	r0, [r4, #120]	; 0x78
    132e:	2800      	cmp	r0, #0
    1330:	f47f adda 	bne.w	ee8 <__data_size+0xd8>
			conn->procedure_expire = conn->supervision_reload;
    1334:	f8b4 3072 	ldrh.w	r3, [r4, #114]	; 0x72
			if (conn->procedure_expire <= 1U) {
    1338:	2b01      	cmp	r3, #1
    133a:	d902      	bls.n	1342 <__data_size+0x532>
			conn->procedure_expire = conn->supervision_reload;
    133c:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
    1340:	e5d2      	b.n	ee8 <__data_size+0xd8>
				conn->procedure_expire++;
    1342:	3301      	adds	r3, #1
    1344:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
    1348:	e5cf      	b.n	eea <__data_size+0xda>
    134a:	bf00      	nop
    134c:	200032cc 	.word	0x200032cc

00001350 <ull_periph_setup>:
static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param);

void ull_periph_setup(struct node_rx_hdr *rx, struct node_rx_ftr *ftr,
		     struct lll_conn *lll)
{
    1350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	memq_link_t *link;
	uint16_t timeout;
	uint8_t chan_sel;
	void *node;

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    1354:	680b      	ldr	r3, [r1, #0]
{
    1356:	4615      	mov	r5, r2
	conn = lll->hdr.parent;
    1358:	4617      	mov	r7, r2

	/* Populate the peripheral context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;

	peer_addr_type = pdu_adv->tx_addr;
    135a:	4602      	mov	r2, r0
{
    135c:	b095      	sub	sp, #84	; 0x54
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    135e:	f8d3 9000 	ldr.w	r9, [r3]
	peer_addr_type = pdu_adv->tx_addr;
    1362:	f812 3f1c 	ldrb.w	r3, [r2, #28]!
    1366:	920d      	str	r2, [sp, #52]	; 0x34
{
    1368:	4604      	mov	r4, r0
	peer_addr_type = pdu_adv->tx_addr;
    136a:	f3c3 1380 	ubfx	r3, r3, #6, #1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    136e:	2206      	movs	r2, #6
{
    1370:	4688      	mov	r8, r1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    1372:	f100 011e 	add.w	r1, r0, #30
    1376:	a812      	add	r0, sp, #72	; 0x48
	peer_addr_type = pdu_adv->tx_addr;
    1378:	930c      	str	r3, [sp, #48]	; 0x30
	conn = lll->hdr.parent;
    137a:	f857 6b08 	ldr.w	r6, [r7], #8
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    137e:	f026 fa77 	bl	27870 <memcpy>
		peer_addr_type += 2;
	} else {
#else /* CONFIG_BT_CTLR_PRIVACY */
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		memcpy(peer_id_addr, peer_addr, BDADDR_SIZE);
    1382:	2206      	movs	r2, #6
    1384:	a912      	add	r1, sp, #72	; 0x48
    1386:	a810      	add	r0, sp, #64	; 0x40
    1388:	f026 fa72 	bl	27870 <memcpy>
	}

	/* Use the link stored in the node rx to enqueue connection
	 * complete node rx towards LL context.
	 */
	link = rx->link;
    138c:	4621      	mov	r1, r4
	conn->own_id_addr_type = own_id_addr_type;
	(void)memcpy(conn->own_id_addr, own_id_addr,
		     sizeof(conn->own_id_addr));
#endif /* CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN */

	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    138e:	2203      	movs	r2, #3
	link = rx->link;
    1390:	f851 ab2e 	ldr.w	sl, [r1], #46
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    1394:	4638      	mov	r0, r7
    1396:	f026 fa6b 	bl	27870 <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    139a:	1d2b      	adds	r3, r5, #4
    139c:	4618      	mov	r0, r3
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    139e:	f105 0718 	add.w	r7, r5, #24
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    13a2:	2204      	movs	r2, #4
    13a4:	f104 012a 	add.w	r1, r4, #42	; 0x2a
    13a8:	930b      	str	r3, [sp, #44]	; 0x2c
    13aa:	f026 fa61 	bl	27870 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    13ae:	2205      	movs	r2, #5
    13b0:	f104 013a 	add.w	r1, r4, #58	; 0x3a
    13b4:	4638      	mov	r0, r7
    13b6:	f026 fa5b 	bl	27870 <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
    13ba:	2105      	movs	r1, #5
    13bc:	4638      	mov	r0, r7
    13be:	f029 faa3 	bl	2a908 <util_ones_count_get>
    13c2:	7f6a      	ldrb	r2, [r5, #29]
    13c4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    13c8:	f360 0205 	bfi	r2, r0, #0, #6
    13cc:	776a      	strb	r2, [r5, #29]
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    13ce:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
    13d2:	f3c2 0104 	ubfx	r1, r2, #0, #5
    13d6:	77a9      	strb	r1, [r5, #30]
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    13d8:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
    13da:	81e9      	strh	r1, [r5, #14]
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
    13dc:	2801      	cmp	r0, #1
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    13de:	f002 021f 	and.w	r2, r2, #31
	lll->interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    13e2:	b28f      	uxth	r7, r1
	if ((lll->data_chan_count < CHM_USED_COUNT_MIN) ||
    13e4:	d906      	bls.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
    13e6:	321b      	adds	r2, #27
    13e8:	f002 021f 	and.w	r2, r2, #31
    13ec:	2a0b      	cmp	r2, #11
    13ee:	d801      	bhi.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
	    (lll->data_chan_hop < CHM_HOP_COUNT_MIN) ||
	    (lll->data_chan_hop > CHM_HOP_COUNT_MAX) ||
    13f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    13f2:	b99f      	cbnz	r7, 141c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x94>
{
	/* Reset the advertising disabled callback */
	hdr->disabled_cb = NULL;

	/* Let the advertiser continue with connectable advertising */
	lll->periph.initiated = 0U;
    13f4:	f895 3020 	ldrb.w	r3, [r5, #32]
	hdr->disabled_cb = NULL;
    13f8:	2200      	movs	r2, #0
	lll->periph.initiated = 0U;
    13fa:	f362 0300 	bfi	r3, r2, #0, #1
	hdr->disabled_cb = NULL;
    13fe:	f8c9 2014 	str.w	r2, [r9, #20]
	lll->periph.initiated = 0U;
    1402:	f885 3020 	strb.w	r3, [r5, #32]

	/* Mark for buffer for release */
	rx->type = NODE_RX_TYPE_RELEASE;
    1406:	2301      	movs	r3, #1
    1408:	7123      	strb	r3, [r4, #4]
		/* Mark for buffer for release */
		rx->type = NODE_RX_TYPE_RELEASE;
	}

	/* Enqueue connection or CSA event to be release */
	ll_rx_put(link, rx);
    140a:	4621      	mov	r1, r4
    140c:	4650      	mov	r0, sl
    140e:	f01a f8e5 	bl	1b5dc <ll_rx_put>
	ll_rx_sched();
    1412:	f01a f8ed 	bl	1b5f0 <ll_rx_sched>
}
    1416:	b015      	add	sp, #84	; 0x54
    1418:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	((struct lll_adv *)ftr->param)->conn = NULL;
    141c:	f8d8 2000 	ldr.w	r2, [r8]
    1420:	930f      	str	r3, [sp, #60]	; 0x3c
    1422:	2100      	movs	r1, #0
    1424:	6051      	str	r1, [r2, #4]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
    1426:	f894 1037 	ldrb.w	r1, [r4, #55]	; 0x37
    142a:	f894 2036 	ldrb.w	r2, [r4, #54]	; 0x36
    142e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    1432:	822a      	strh	r2, [r5, #16]
	conn->periph.sca = pdu_adv->connect_ind.sca;
    1434:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
    1438:	f896 107c 	ldrb.w	r1, [r6, #124]	; 0x7c
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
    143c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    143e:	930b      	str	r3, [sp, #44]	; 0x2c
	conn->periph.sca = pdu_adv->connect_ind.sca;
    1440:	0952      	lsrs	r2, r2, #5
    1442:	f362 01c5 	bfi	r1, r2, #3, #3
    1446:	f886 107c 	strb.w	r1, [r6, #124]	; 0x7c
		ceiling_fraction(((lll_clock_ppm_local_get() +
    144a:	f02a f929 	bl	2b6a0 <lll_clock_ppm_local_get>
    144e:	900e      	str	r0, [sp, #56]	; 0x38
    1450:	f896 007c 	ldrb.w	r0, [r6, #124]	; 0x7c
    1454:	f3c0 00c2 	ubfx	r0, r0, #3, #3
    1458:	f01d fa1c 	bl	1e894 <lll_clock_ppm_get>
    145c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
    145e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	conn_interval_us = lll->interval * CONN_INT_UNIT_US;
    1460:	f240 4be2 	movw	fp, #1250	; 0x4e2
    1464:	fb0b f707 	mul.w	r7, fp, r7
		ceiling_fraction(((lll_clock_ppm_local_get() +
    1468:	4410      	add	r0, r2
    146a:	4378      	muls	r0, r7
    146c:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
    1470:	4a7d      	ldr	r2, [pc, #500]	; (1668 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2e0>)
    1472:	f200 203f 	addw	r0, r0, #575	; 0x23f
    1476:	fbb0 f0f2 	udiv	r0, r0, r2
	lll->periph.window_widening_max_us = (conn_interval_us >> 1) -
    147a:	087a      	lsrs	r2, r7, #1
    147c:	3a96      	subs	r2, #150	; 0x96
    147e:	62aa      	str	r2, [r5, #40]	; 0x28
	lll->periph.window_size_event_us = pdu_adv->connect_ind.win_size *
    1480:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
	lll->periph.window_widening_periodic_us =
    1484:	6268      	str	r0, [r5, #36]	; 0x24
	lll->periph.window_size_event_us = pdu_adv->connect_ind.win_size *
    1486:	fb0b f202 	mul.w	r2, fp, r2
    148a:	63aa      	str	r2, [r5, #56]	; 0x38
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    148c:	f8b4 b038 	ldrh.w	fp, [r4, #56]	; 0x38
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    1490:	f242 7110 	movw	r1, #10000	; 0x2710
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    1494:	fa1f f28b 	uxth.w	r2, fp
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    1498:	fb01 7202 	mla	r2, r1, r2, r7
    149c:	3a01      	subs	r2, #1
    149e:	fbb2 f2f7 	udiv	r2, r2, r7
    14a2:	f8a6 2072 	strh.w	r2, [r6, #114]	; 0x72
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    14a6:	4a71      	ldr	r2, [pc, #452]	; (166c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2e4>)
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
    14a8:	4619      	mov	r1, r3
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    14aa:	443a      	add	r2, r7
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
    14ac:	f106 0080 	add.w	r0, r6, #128	; 0x80
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    14b0:	fbb2 f2f7 	udiv	r2, r2, r7
    14b4:	f8a6 2076 	strh.w	r2, [r6, #118]	; 0x76
	memcpy((void *)&conn->periph.force, &lll->access_addr[0],
    14b8:	2204      	movs	r2, #4
    14ba:	f026 f9d9 	bl	27870 <memcpy>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
    14be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    14c0:	07da      	lsls	r2, r3, #31
    14c2:	d50b      	bpl.n	14dc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x154>
    14c4:	4a6a      	ldr	r2, [pc, #424]	; (1670 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2e8>)
    14c6:	496b      	ldr	r1, [pc, #428]	; (1674 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2ec>)
    14c8:	486b      	ldr	r0, [pc, #428]	; (1678 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f0>)
    14ca:	23f1      	movs	r3, #241	; 0xf1
    14cc:	f023 fe76 	bl	251bc <printk>
    14d0:	4040      	eors	r0, r0
    14d2:	f380 8811 	msr	BASEPRI, r0
    14d6:	f04f 0003 	mov.w	r0, #3
    14da:	df02      	svc	2
	cc->status = 0U;
    14dc:	f44f 7380 	mov.w	r3, #256	; 0x100
    14e0:	83a3      	strh	r3, [r4, #28]
	cc->peer_addr_type = peer_addr_type;
    14e2:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    14e6:	77a3      	strb	r3, [r4, #30]
	memcpy(cc->peer_addr, peer_id_addr, BDADDR_SIZE);
    14e8:	2206      	movs	r2, #6
    14ea:	a910      	add	r1, sp, #64	; 0x40
    14ec:	f104 001f 	add.w	r0, r4, #31
    14f0:	f026 f9be 	bl	27870 <memcpy>
	cc->interval = lll->interval;
    14f4:	89eb      	ldrh	r3, [r5, #14]
    14f6:	84e3      	strh	r3, [r4, #38]	; 0x26
	cc->latency = lll->latency;
    14f8:	8a2b      	ldrh	r3, [r5, #16]
    14fa:	8523      	strh	r3, [r4, #40]	; 0x28
	cc->sca = conn->periph.sca;
    14fc:	f896 307c 	ldrb.w	r3, [r6, #124]	; 0x7c
	cc->timeout = timeout;
    1500:	f8a4 b02a 	strh.w	fp, [r4, #42]	; 0x2a
	cc->sca = conn->periph.sca;
    1504:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    1508:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	lll->handle = ll_conn_handle_get(conn);
    150c:	4630      	mov	r0, r6
    150e:	f01b fb49 	bl	1cba4 <ll_conn_handle_get>
	ll_rx_put(link, rx);
    1512:	4621      	mov	r1, r4
	lll->handle = ll_conn_handle_get(conn);
    1514:	81a8      	strh	r0, [r5, #12]
	rx->handle = lll->handle;
    1516:	80e0      	strh	r0, [r4, #6]
	ll_rx_put(link, rx);
    1518:	4650      	mov	r0, sl
    151a:	f01a f85f 	bl	1b5dc <ll_rx_put>
	ll_rx_sched();
    151e:	f01a f867 	bl	1b5f0 <ll_rx_sched>
	ready_delay_us = lll_radio_rx_ready_delay_get(0, 0);
    1522:	2100      	movs	r1, #0
    1524:	4608      	mov	r0, r1
    1526:	f02a f88f 	bl	2b648 <lll_radio_rx_ready_delay_get>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    152a:	4c54      	ldr	r4, [pc, #336]	; (167c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f4>)
	conn->ull.ticks_prepare_to_start =
    152c:	f04f 0a00 	mov.w	sl, #0
	ready_delay_us = lll_radio_rx_ready_delay_get(0, 0);
    1530:	4683      	mov	fp, r0
	conn->ull.ticks_prepare_to_start =
    1532:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1534:	f200 4052 	addw	r0, r0, #1106	; 0x452
	conn->ull.ticks_prepare_to_start =
    1538:	e9c6 a301 	strd	sl, r3, [r6, #4]
	conn->ull.ticks_preempt_to_start =
    153c:	f8c6 a00c 	str.w	sl, [r6, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1540:	a347      	add	r3, pc, #284	; (adr r3, 1660 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2d8>)
    1542:	e9d3 2300 	ldrd	r2, r3, [r3]
    1546:	fba0 0104 	umull	r0, r1, r0, r4
    154a:	f7fe fdc9 	bl	e0 <__aeabi_uldivmod>
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
    154e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	conn_offset_us = ftr->radio_end_us;
    1550:	f8d8 300c 	ldr.w	r3, [r8, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1554:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn_offset_us += win_offset * CONN_INT_UNIT_US;
    1558:	f240 41e2 	movw	r1, #1250	; 0x4e2
    155c:	fb01 3302 	mla	r3, r1, r2, r3
	conn->ull.ticks_slot =
    1560:	6130      	str	r0, [r6, #16]
	conn_interval_us -= lll->periph.window_widening_periodic_us;
    1562:	6a68      	ldr	r0, [r5, #36]	; 0x24
	conn_offset_us -= EVENT_JITTER_US;
    1564:	f203 41b2 	addw	r1, r3, #1202	; 0x4b2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    1568:	4652      	mov	r2, sl
	conn_interval_us -= lll->periph.window_widening_periodic_us;
    156a:	1a3f      	subs	r7, r7, r0
	conn_offset_us -= ready_delay_us;
    156c:	eba1 0b0b 	sub.w	fp, r1, fp
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    1570:	2001      	movs	r0, #1
    1572:	2102      	movs	r1, #2
    1574:	f017 ff44 	bl	19400 <mayfly_enable>
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
    1578:	4648      	mov	r0, r9
    157a:	f01b f82b 	bl	1c5d4 <ull_adv_handle_get>
    157e:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    1580:	4b3f      	ldr	r3, [pc, #252]	; (1680 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f8>)
    1582:	f8cd 9000 	str.w	r9, [sp]
    1586:	b2d2      	uxtb	r2, r2
    1588:	2101      	movs	r1, #1
    158a:	4650      	mov	r0, sl
    158c:	f018 fd2a 	bl	19fe4 <ticker_stop>
	ticker_op_stop_adv_cb(ticker_status, adv);
    1590:	4649      	mov	r1, r9
    1592:	f01c fbab 	bl	1dcec <ticker_op_stop_adv_cb>
	if (adv->lll.is_hdcd) {
    1596:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
    159a:	07db      	lsls	r3, r3, #31
    159c:	d507      	bpl.n	15ae <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x226>
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    159e:	2201      	movs	r2, #1
    15a0:	f8cd a000 	str.w	sl, [sp]
    15a4:	4653      	mov	r3, sl
    15a6:	4611      	mov	r1, r2
    15a8:	4650      	mov	r0, sl
    15aa:	f018 fd1b 	bl	19fe4 <ticker_stop>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    15ae:	4630      	mov	r0, r6
    15b0:	f01b faf8 	bl	1cba4 <ll_conn_handle_get>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    15b4:	fba7 7904 	umull	r7, r9, r7, r4
    15b8:	a329      	add	r3, pc, #164	; (adr r3, 1660 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2d8>)
    15ba:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    15be:	4605      	mov	r5, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    15c0:	4649      	mov	r1, r9
    15c2:	4638      	mov	r0, r7
    15c4:	f7fe fd8c 	bl	e0 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15c8:	f8d8 3008 	ldr.w	r3, [r8, #8]
    15cc:	f1a3 083a 	sub.w	r8, r3, #58	; 0x3a
    15d0:	f44f 73e4 	mov.w	r3, #456	; 0x1c8
    15d4:	9308      	str	r3, [sp, #32]
    15d6:	4b2b      	ldr	r3, [pc, #172]	; (1684 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2fc>)
    15d8:	e9cd 6306 	strd	r6, r3, [sp, #24]
    15dc:	4b2a      	ldr	r3, [pc, #168]	; (1688 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x300>)
    15de:	9305      	str	r3, [sp, #20]
    15e0:	6933      	ldr	r3, [r6, #16]
    15e2:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    15e4:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    15e8:	4828      	ldr	r0, [pc, #160]	; (168c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x304>)
    15ea:	2307      	movs	r3, #7
    15ec:	fba6 0100 	umull	r0, r1, r6, r0
    15f0:	1a38      	subs	r0, r7, r0
    15f2:	fb03 1106 	mla	r1, r3, r6, r1
    15f6:	eb69 0101 	sbc.w	r1, r9, r1
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15fa:	f04f 0a00 	mov.w	sl, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
    15fe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1602:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1604:	f8cd a00c 	str.w	sl, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    1608:	f7fe fd6a 	bl	e0 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    160c:	a314      	add	r3, pc, #80	; (adr r3, 1660 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2d8>)
    160e:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1612:	e9cd 6001 	strd	r6, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    1616:	fbab 0104 	umull	r0, r1, fp, r4
    161a:	f7fe fd61 	bl	e0 <__aeabi_uldivmod>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    161e:	3505      	adds	r5, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1620:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1624:	b2ed      	uxtb	r5, r5
    1626:	9000      	str	r0, [sp, #0]
    1628:	4643      	mov	r3, r8
    162a:	462a      	mov	r2, r5
    162c:	2101      	movs	r1, #1
    162e:	4650      	mov	r0, sl
    1630:	f029 fbdf 	bl	2adf2 <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1634:	f030 0302 	bics.w	r3, r0, #2
    1638:	d00c      	beq.n	1654 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2cc>
    163a:	4a0d      	ldr	r2, [pc, #52]	; (1670 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2e8>)
    163c:	4914      	ldr	r1, [pc, #80]	; (1690 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x308>)
    163e:	480e      	ldr	r0, [pc, #56]	; (1678 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2f0>)
    1640:	f240 13c9 	movw	r3, #457	; 0x1c9
    1644:	f023 fdba 	bl	251bc <printk>
    1648:	4040      	eors	r0, r0
    164a:	f380 8811 	msr	BASEPRI, r0
    164e:	f04f 0003 	mov.w	r0, #3
    1652:	df02      	svc	2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    1654:	2201      	movs	r2, #1
    1656:	2102      	movs	r1, #2
    1658:	4610      	mov	r0, r2
    165a:	f017 fed1 	bl	19400 <mayfly_enable>
    165e:	e6da      	b.n	1416 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x8e>
    1660:	1afd498d 	.word	0x1afd498d
    1664:	00000007 	.word	0x00000007
    1668:	000f4240 	.word	0x000f4240
    166c:	026259ff 	.word	0x026259ff
    1670:	000344e2 	.word	0x000344e2
    1674:	00033f0e 	.word	0x00033f0e
    1678:	0002f8b5 	.word	0x0002f8b5
    167c:	3b9aca00 	.word	0x3b9aca00
    1680:	0001dced 	.word	0x0001dced
    1684:	0001dcc1 	.word	0x0001dcc1
    1688:	0001dd25 	.word	0x0001dd25
    168c:	1afd498d 	.word	0x1afd498d
    1690:	00034433 	.word	0x00034433
    1694:	00000000 	.word	0x00000000

00001698 <nrf_flash_sync_exe>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
	_ticker_sync_context.slot = duration;
}

int nrf_flash_sync_exe(struct flash_op_desc *op_desc)
{
    1698:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    169c:	b08f      	sub	sp, #60	; 0x3c
			      /* (MAYFLY_CALL_ID_PROGRAM) */
			   ticker_id, /* flash ticker id */
			   ticker_ticks_now_get(), /* current tick */
			   0, /* first int. immediately */
			   /* period */
			   HAL_TICKER_US_TO_TICKS(
    169e:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 1778 <nrf_flash_sync_exe+0xe0>
{
    16a2:	900a      	str	r0, [sp, #40]	; 0x28
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    16a4:	f10d 0137 	add.w	r1, sp, #55	; 0x37
    16a8:	f10d 0036 	add.w	r0, sp, #54	; 0x36
    16ac:	f029 fc57 	bl	2af5e <ll_timeslice_ticker_id_get>
			   HAL_TICKER_US_TO_TICKS(
    16b0:	4f32      	ldr	r7, [pc, #200]	; (177c <nrf_flash_sync_exe+0xe4>)
	err = ticker_start(instance_index,
    16b2:	f89d a036 	ldrb.w	sl, [sp, #54]	; 0x36
    16b6:	f89d b037 	ldrb.w	fp, [sp, #55]	; 0x37
    16ba:	f029 fbcd 	bl	2ae58 <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(
    16be:	f8d8 4000 	ldr.w	r4, [r8]
    16c2:	fba4 5407 	umull	r5, r4, r4, r7
    16c6:	a32a      	add	r3, pc, #168	; (adr r3, 1770 <nrf_flash_sync_exe+0xd8>)
    16c8:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    16cc:	4681      	mov	r9, r0
			   HAL_TICKER_US_TO_TICKS(
    16ce:	4621      	mov	r1, r4
    16d0:	4628      	mov	r0, r5
    16d2:	f7fe fd05 	bl	e0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    16d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			   HAL_TICKER_US_TO_TICKS(
    16d8:	900b      	str	r0, [sp, #44]	; 0x2c
				_ticker_sync_context.interval),
			   /* period remainder */
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
			   0, /* lazy, voluntary skips */
			   HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot),
    16da:	f8d8 0004 	ldr.w	r0, [r8, #4]
	err = ticker_start(instance_index,
    16de:	9306      	str	r3, [sp, #24]
    16e0:	4b27      	ldr	r3, [pc, #156]	; (1780 <nrf_flash_sync_exe+0xe8>)
    16e2:	9305      	str	r3, [sp, #20]
    16e4:	2600      	movs	r6, #0
			   HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot),
    16e6:	a322      	add	r3, pc, #136	; (adr r3, 1770 <nrf_flash_sync_exe+0xd8>)
    16e8:	e9d3 2300 	ldrd	r2, r3, [r3]
    16ec:	fba0 0107 	umull	r0, r1, r0, r7
	err = ticker_start(instance_index,
    16f0:	e9cd 6607 	strd	r6, r6, [sp, #28]
			   HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot),
    16f4:	f7fe fcf4 	bl	e0 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
    16f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	err = ticker_start(instance_index,
    16fa:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    16fe:	e9cd 6003 	strd	r6, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(_ticker_sync_context.interval),
    1702:	4820      	ldr	r0, [pc, #128]	; (1784 <nrf_flash_sync_exe+0xec>)
    1704:	f023 477f 	bic.w	r7, r3, #4278190080	; 0xff000000
    1708:	fba7 0100 	umull	r0, r1, r7, r0
    170c:	2307      	movs	r3, #7
    170e:	1a28      	subs	r0, r5, r0
    1710:	fb03 1107 	mla	r1, r3, r7, r1
    1714:	eb64 0101 	sbc.w	r1, r4, r1
    1718:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    171c:	2300      	movs	r3, #0
    171e:	f7fe fcdf 	bl	e0 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    1722:	9600      	str	r6, [sp, #0]
    1724:	e9cd 7001 	strd	r7, r0, [sp, #4]
    1728:	464b      	mov	r3, r9
    172a:	465a      	mov	r2, fp
    172c:	2103      	movs	r1, #3
    172e:	4650      	mov	r0, sl
    1730:	f029 fb5f 	bl	2adf2 <ticker_start>
			   time_slot_callback_prepare,
			   op_desc,
			   NULL, /* no op callback */
			   NULL);

	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    1734:	f030 0402 	bics.w	r4, r0, #2
    1738:	d116      	bne.n	1768 <nrf_flash_sync_exe+0xd0>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    173a:	4a13      	ldr	r2, [pc, #76]	; (1788 <nrf_flash_sync_exe+0xf0>)
    173c:	4813      	ldr	r0, [pc, #76]	; (178c <nrf_flash_sync_exe+0xf4>)
    173e:	2300      	movs	r3, #0
    1740:	f022 fc2e 	bl	23fa0 <z_impl_k_sem_take>
		result = -ECANCELED;
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    1744:	b168      	cbz	r0, 1762 <nrf_flash_sync_exe+0xca>
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
    1746:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
    174a:	f89d 0036 	ldrb.w	r0, [sp, #54]	; 0x36
    174e:	9400      	str	r4, [sp, #0]
    1750:	4623      	mov	r3, r4
    1752:	2103      	movs	r1, #3
    1754:	f018 fc46 	bl	19fe4 <ticker_stop>
		/* Stop any scheduled jobs */
		_ticker_stop(instance_index, 3, ticker_id);

		/* wait for operation's complete overrun*/
		result = -ETIMEDOUT;
    1758:	f06f 0073 	mvn.w	r0, #115	; 0x73
	} else {
		result = _ticker_sync_context.result;
	}

	return result;
}
    175c:	b00f      	add	sp, #60	; 0x3c
    175e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = _ticker_sync_context.result;
    1762:	f8d8 000c 	ldr.w	r0, [r8, #12]
    1766:	e7f9      	b.n	175c <nrf_flash_sync_exe+0xc4>
		result = -ECANCELED;
    1768:	f06f 008b 	mvn.w	r0, #139	; 0x8b
	return result;
    176c:	e7f6      	b.n	175c <nrf_flash_sync_exe+0xc4>
    176e:	bf00      	nop
    1770:	1afd498d 	.word	0x1afd498d
    1774:	00000007 	.word	0x00000007
    1778:	200036ac 	.word	0x200036ac
    177c:	3b9aca00 	.word	0x3b9aca00
    1780:	00021949 	.word	0x00021949
    1784:	1afd498d 	.word	0x1afd498d
    1788:	000b7b44 	.word	0x000b7b44
    178c:	200036bc 	.word	0x200036bc

00001790 <nrf_flash_sync_check_time_limit>:
{
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
}

bool nrf_flash_sync_check_time_limit(uint32_t iteration)
{
    1790:	b538      	push	{r3, r4, r5, lr}
	uint32_t ticks_diff;

	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
    1792:	4d0f      	ldr	r5, [pc, #60]	; (17d0 <nrf_flash_sync_check_time_limit+0x40>)
{
    1794:	4604      	mov	r4, r0
	ticks_diff = ticker_ticks_diff_get(ticker_ticks_now_get(),
    1796:	f029 fb5f 	bl	2ae58 <ticker_ticks_now_get>
    179a:	68a9      	ldr	r1, [r5, #8]
    179c:	f029 fb5e 	bl	2ae5c <ticker_ticks_diff_get>
					   _ticker_sync_context.ticks_begin);
	if (ticks_diff + ticks_diff/iteration >
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
    17a0:	6869      	ldr	r1, [r5, #4]
	if (ticks_diff + ticks_diff/iteration >
    17a2:	fbb0 f4f4 	udiv	r4, r0, r4
    17a6:	4404      	add	r4, r0
	    HAL_TICKER_US_TO_TICKS(_ticker_sync_context.slot)) {
    17a8:	480a      	ldr	r0, [pc, #40]	; (17d4 <nrf_flash_sync_check_time_limit+0x44>)
    17aa:	a307      	add	r3, pc, #28	; (adr r3, 17c8 <nrf_flash_sync_check_time_limit+0x38>)
    17ac:	e9d3 2300 	ldrd	r2, r3, [r3]
    17b0:	fba1 0100 	umull	r0, r1, r1, r0
    17b4:	f7fe fc94 	bl	e0 <__aeabi_uldivmod>
    17b8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return true;
	}

	return false;
}
    17bc:	4284      	cmp	r4, r0
    17be:	bf94      	ite	ls
    17c0:	2000      	movls	r0, #0
    17c2:	2001      	movhi	r0, #1
    17c4:	bd38      	pop	{r3, r4, r5, pc}
    17c6:	bf00      	nop
    17c8:	1afd498d 	.word	0x1afd498d
    17cc:	00000007 	.word	0x00000007
    17d0:	200036ac 	.word	0x200036ac
    17d4:	3b9aca00 	.word	0x3b9aca00

000017d8 <gen_onoff_status>:
/* Generic OnOff Client */

static int gen_onoff_status(struct bt_mesh_model *model,
			    struct bt_mesh_msg_ctx *ctx,
			    struct net_buf_simple *buf)
{
    17d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t present = net_buf_simple_pull_u8(buf);
    17da:	4610      	mov	r0, r2
{
    17dc:	4614      	mov	r4, r2
	uint8_t present = net_buf_simple_pull_u8(buf);
    17de:	f02a fb2d 	bl	2be3c <net_buf_simple_pull_u8>

	if (buf->len) {
    17e2:	88a3      	ldrh	r3, [r4, #4]
    17e4:	4e12      	ldr	r6, [pc, #72]	; (1830 <gen_onoff_status+0x58>)
	uint8_t present = net_buf_simple_pull_u8(buf);
    17e6:	4605      	mov	r5, r0
	if (buf->len) {
    17e8:	b1e3      	cbz	r3, 1824 <gen_onoff_status+0x4c>
		uint8_t target = net_buf_simple_pull_u8(buf);
    17ea:	4620      	mov	r0, r4
    17ec:	f02a fb26 	bl	2be3c <net_buf_simple_pull_u8>
    17f0:	4607      	mov	r7, r0
		int32_t remaining_time =
			model_time_decode(net_buf_simple_pull_u8(buf));
    17f2:	4620      	mov	r0, r4
    17f4:	f02a fb22 	bl	2be3c <net_buf_simple_pull_u8>
	uint8_t steps = val & BIT_MASK(6);
    17f8:	f000 033f 	and.w	r3, r0, #63	; 0x3f
	if (steps == 0x3f) {
    17fc:	2b3f      	cmp	r3, #63	; 0x3f
	uint8_t resolution = (val >> 6) & BIT_MASK(2);
    17fe:	f3c0 1187 	ubfx	r1, r0, #6, #8
	return steps * time_res[resolution];
    1802:	bf1c      	itt	ne
    1804:	4a0b      	ldrne	r2, [pc, #44]	; (1834 <gen_onoff_status+0x5c>)
    1806:	f852 0021 	ldrne.w	r0, [r2, r1, lsl #2]

		printk("OnOff status: %s -> %s: (%d ms)\n", onoff_str[present],
    180a:	f856 2027 	ldr.w	r2, [r6, r7, lsl #2]
    180e:	f856 1025 	ldr.w	r1, [r6, r5, lsl #2]
	return steps * time_res[resolution];
    1812:	bf14      	ite	ne
    1814:	4343      	mulne	r3, r0
		return SYS_FOREVER_MS;
    1816:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
		printk("OnOff status: %s -> %s: (%d ms)\n", onoff_str[present],
    181a:	4807      	ldr	r0, [pc, #28]	; (1838 <gen_onoff_status+0x60>)
    181c:	f023 fcce 	bl	251bc <printk>
	}

	printk("OnOff status: %s\n", onoff_str[present]);

	return 0;
}
    1820:	2000      	movs	r0, #0
    1822:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	printk("OnOff status: %s\n", onoff_str[present]);
    1824:	f856 1020 	ldr.w	r1, [r6, r0, lsl #2]
    1828:	4804      	ldr	r0, [pc, #16]	; (183c <gen_onoff_status+0x64>)
    182a:	f023 fcc7 	bl	251bc <printk>
	return 0;
    182e:	e7f7      	b.n	1820 <gen_onoff_status+0x48>
    1830:	0002ddf8 	.word	0x0002ddf8
    1834:	0002de4c 	.word	0x0002de4c
    1838:	0002ea4c 	.word	0x0002ea4c
    183c:	0002ea6d 	.word	0x0002ea6d

00001840 <output_number>:
};

/* Provisioning */

static int output_number(bt_mesh_output_action_t action, uint32_t number)
{
    1840:	b538      	push	{r3, r4, r5, lr}
    1842:	4604      	mov	r4, r0
    1844:	460d      	mov	r5, r1
	printk("OOB Number: %u\n", number);
    1846:	4804      	ldr	r0, [pc, #16]	; (1858 <output_number+0x18>)
    1848:	f023 fcb8 	bl	251bc <printk>

	board_output_number(action, number);
    184c:	4620      	mov	r0, r4
    184e:	4629      	mov	r1, r5
    1850:	f023 fbd4 	bl	24ffc <board_output_number>

	return 0;
}
    1854:	2000      	movs	r0, #0
    1856:	bd38      	pop	{r3, r4, r5, pc}
    1858:	0002ea7f 	.word	0x0002ea7f

0000185c <bt_ready>:

	printk("Provisioned and configured!\n");
}

static void bt_ready(int err)
{
    185c:	b508      	push	{r3, lr}
	if (err) {
    185e:	4601      	mov	r1, r0
    1860:	b120      	cbz	r0, 186c <bt_ready+0x10>
		printk("Bluetooth init failed (err %d)\n", err);
    1862:	480d      	ldr	r0, [pc, #52]	; (1898 <bt_ready+0x3c>)

	/* This will be a no-op if settings_load() loaded provisioning info */
	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);

	printk("Mesh initialized\n");
}
    1864:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printk("Initializing mesh failed (err %d)\n", err);
    1868:	f023 bca8 	b.w	251bc <printk>
	printk("Bluetooth initialized\n");
    186c:	480b      	ldr	r0, [pc, #44]	; (189c <bt_ready+0x40>)
    186e:	f023 fca5 	bl	251bc <printk>
	err = bt_mesh_init(&prov, &comp);
    1872:	490b      	ldr	r1, [pc, #44]	; (18a0 <bt_ready+0x44>)
    1874:	480b      	ldr	r0, [pc, #44]	; (18a4 <bt_ready+0x48>)
    1876:	f027 fd5d 	bl	29334 <bt_mesh_init>
	if (err) {
    187a:	4601      	mov	r1, r0
    187c:	b108      	cbz	r0, 1882 <bt_ready+0x26>
		printk("Initializing mesh failed (err %d)\n", err);
    187e:	480a      	ldr	r0, [pc, #40]	; (18a8 <bt_ready+0x4c>)
    1880:	e7f0      	b.n	1864 <bt_ready+0x8>
		settings_load();
    1882:	f024 fcb5 	bl	261f0 <settings_load>
	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
    1886:	2003      	movs	r0, #3
    1888:	f015 feca 	bl	17620 <bt_mesh_prov_enable>
}
    188c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	printk("Mesh initialized\n");
    1890:	4806      	ldr	r0, [pc, #24]	; (18ac <bt_ready+0x50>)
    1892:	f023 bc93 	b.w	251bc <printk>
    1896:	bf00      	nop
    1898:	0002ea8f 	.word	0x0002ea8f
    189c:	0002eaaf 	.word	0x0002eaaf
    18a0:	0002dd88 	.word	0x0002dd88
    18a4:	0002de00 	.word	0x0002de00
    18a8:	0002eac6 	.word	0x0002eac6
    18ac:	0002eae9 	.word	0x0002eae9

000018b0 <onoff_timeout>:
{
    18b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (onoff.transition_time) {
    18b2:	4c10      	ldr	r4, [pc, #64]	; (18f4 <onoff_timeout+0x44>)
    18b4:	6863      	ldr	r3, [r4, #4]
    18b6:	b1c3      	cbz	r3, 18ea <onoff_timeout+0x3a>
		board_led_set(true);
    18b8:	2001      	movs	r0, #1
    18ba:	f000 fa0f 	bl	1cdc <board_led_set>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
    18be:	2500      	movs	r5, #0
    18c0:	6867      	ldr	r7, [r4, #4]
    18c2:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    18c6:	f240 30e7 	movw	r0, #999	; 0x3e7
    18ca:	4629      	mov	r1, r5
    18cc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    18d0:	2300      	movs	r3, #0
    18d2:	fbe7 0106 	umlal	r0, r1, r7, r6
    18d6:	f7fe fc03 	bl	e0 <__aeabi_uldivmod>
    18da:	4602      	mov	r2, r0
    18dc:	460b      	mov	r3, r1
		k_work_reschedule(&onoff.work, K_MSEC(onoff.transition_time));
    18de:	f104 0008 	add.w	r0, r4, #8
    18e2:	f022 fd3f 	bl	24364 <k_work_reschedule>
		onoff.transition_time = 0;
    18e6:	6065      	str	r5, [r4, #4]
}
    18e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	board_led_set(onoff.val);
    18ea:	7820      	ldrb	r0, [r4, #0]
}
    18ec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	board_led_set(onoff.val);
    18f0:	f000 b9f4 	b.w	1cdc <board_led_set>
    18f4:	200010f0 	.word	0x200010f0

000018f8 <button_pressed>:
{
    18f8:	b570      	push	{r4, r5, r6, lr}
    18fa:	b08a      	sub	sp, #40	; 0x28
	if (bt_mesh_is_provisioned()) {
    18fc:	f00a f860 	bl	b9c0 <bt_mesh_is_provisioned>
    1900:	4604      	mov	r4, r0
    1902:	2800      	cmp	r0, #0
    1904:	d03f      	beq.n	1986 <button_pressed+0x8e>
		.app_idx = models[3].keys[0], /* Use the bound key */
    1906:	4e35      	ldr	r6, [pc, #212]	; (19dc <button_pressed+0xe4>)
		(void)gen_onoff_send(!onoff.val);
    1908:	4b35      	ldr	r3, [pc, #212]	; (19e0 <button_pressed+0xe8>)
		.app_idx = models[3].keys[0], /* Use the bound key */
    190a:	f8b6 2078 	ldrh.w	r2, [r6, #120]	; 0x78
		(void)gen_onoff_send(!onoff.val);
    190e:	781d      	ldrb	r5, [r3, #0]
	struct bt_mesh_msg_ctx ctx = {
    1910:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1914:	2400      	movs	r4, #0
	if (ctx.app_idx == BT_MESH_KEY_UNUSED) {
    1916:	429a      	cmp	r2, r3
	struct bt_mesh_msg_ctx ctx = {
    1918:	e9cd 4404 	strd	r4, r4, [sp, #16]
		(void)gen_onoff_send(!onoff.val);
    191c:	f085 0501 	eor.w	r5, r5, #1
	struct bt_mesh_msg_ctx ctx = {
    1920:	f8cd 4017 	str.w	r4, [sp, #23]
    1924:	f8ad 2012 	strh.w	r2, [sp, #18]
    1928:	f8ad 3014 	strh.w	r3, [sp, #20]
    192c:	f88d 301b 	strb.w	r3, [sp, #27]
	if (ctx.app_idx == BT_MESH_KEY_UNUSED) {
    1930:	d104      	bne.n	193c <button_pressed+0x44>
		printk("The Generic OnOff Client must be bound to a key before "
    1932:	482c      	ldr	r0, [pc, #176]	; (19e4 <button_pressed+0xec>)
    1934:	f023 fc42 	bl	251bc <printk>
}
    1938:	b00a      	add	sp, #40	; 0x28
    193a:	bd70      	pop	{r4, r5, r6, pc}
	BT_MESH_MODEL_BUF_DEFINE(buf, OP_ONOFF_SET_UNACK, 2);
    193c:	ab02      	add	r3, sp, #8
    193e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
	bt_mesh_model_msg_init(&buf, OP_ONOFF_SET_UNACK);
    1942:	a807      	add	r0, sp, #28
    1944:	f248 2103 	movw	r1, #33283	; 0x8203
	BT_MESH_MODEL_BUF_DEFINE(buf, OP_ONOFF_SET_UNACK, 2);
    1948:	e9cd 2308 	strd	r2, r3, [sp, #32]
    194c:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&buf, OP_ONOFF_SET_UNACK);
    194e:	f028 fbea 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&buf, val);
    1952:	4629      	mov	r1, r5
    1954:	a807      	add	r0, sp, #28
    1956:	f02a fa00 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, tid++);
    195a:	4b23      	ldr	r3, [pc, #140]	; (19e8 <button_pressed+0xf0>)
    195c:	7819      	ldrb	r1, [r3, #0]
    195e:	a807      	add	r0, sp, #28
    1960:	1c4a      	adds	r2, r1, #1
    1962:	701a      	strb	r2, [r3, #0]
    1964:	f02a f9f9 	bl	2bd5a <net_buf_simple_add_u8>
	printk("Sending OnOff Set: %s\n", onoff_str[val]);
    1968:	4b20      	ldr	r3, [pc, #128]	; (19ec <button_pressed+0xf4>)
    196a:	4821      	ldr	r0, [pc, #132]	; (19f0 <button_pressed+0xf8>)
    196c:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
    1970:	f023 fc24 	bl	251bc <printk>
	return bt_mesh_model_send(&models[3], &ctx, &buf, NULL, NULL);
    1974:	9400      	str	r4, [sp, #0]
    1976:	4623      	mov	r3, r4
    1978:	aa07      	add	r2, sp, #28
    197a:	a904      	add	r1, sp, #16
    197c:	f106 006c 	add.w	r0, r6, #108	; 0x6c
    1980:	f00f faf8 	bl	10f74 <bt_mesh_model_send>
    1984:	e7d8      	b.n	1938 <button_pressed+0x40>
		addr = sys_get_le16(&dev_uuid[0]) & BIT_MASK(15);
    1986:	4b1b      	ldr	r3, [pc, #108]	; (19f4 <button_pressed+0xfc>)
	printk("Self-provisioning with address 0x%04x\n", addr);
    1988:	481b      	ldr	r0, [pc, #108]	; (19f8 <button_pressed+0x100>)
		addr = sys_get_le16(&dev_uuid[0]) & BIT_MASK(15);
    198a:	881d      	ldrh	r5, [r3, #0]
    198c:	f3c5 050e 	ubfx	r5, r5, #0, #15
	printk("Self-provisioning with address 0x%04x\n", addr);
    1990:	4629      	mov	r1, r5
    1992:	f023 fc13 	bl	251bc <printk>
	err = bt_mesh_provision(net_key, 0, 0, 0, addr, dev_key);
    1996:	4b19      	ldr	r3, [pc, #100]	; (19fc <button_pressed+0x104>)
    1998:	4819      	ldr	r0, [pc, #100]	; (1a00 <button_pressed+0x108>)
    199a:	e9cd 5300 	strd	r5, r3, [sp]
    199e:	4621      	mov	r1, r4
    19a0:	4623      	mov	r3, r4
    19a2:	4622      	mov	r2, r4
    19a4:	f00a f860 	bl	ba68 <bt_mesh_provision>
    19a8:	4601      	mov	r1, r0
	if (err) {
    19aa:	b128      	cbz	r0, 19b8 <button_pressed+0xc0>
		printk("Provisioning failed (err: %d)\n", err);
    19ac:	4815      	ldr	r0, [pc, #84]	; (1a04 <button_pressed+0x10c>)
}
    19ae:	b00a      	add	sp, #40	; 0x28
    19b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		printk("App key add failed (err: %d)\n", err);
    19b4:	f023 bc02 	b.w	251bc <printk>
	err = bt_mesh_app_key_add(0, 0, app_key);
    19b8:	4a13      	ldr	r2, [pc, #76]	; (1a08 <button_pressed+0x110>)
    19ba:	f027 fedf 	bl	2977c <bt_mesh_app_key_add>
	if (err) {
    19be:	4601      	mov	r1, r0
    19c0:	b108      	cbz	r0, 19c6 <button_pressed+0xce>
		printk("App key add failed (err: %d)\n", err);
    19c2:	4812      	ldr	r0, [pc, #72]	; (1a0c <button_pressed+0x114>)
    19c4:	e7f3      	b.n	19ae <button_pressed+0xb6>
	models[2].keys[0] = 0;
    19c6:	4b05      	ldr	r3, [pc, #20]	; (19dc <button_pressed+0xe4>)
    19c8:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
	models[3].keys[0] = 0;
    19cc:	f8a3 0078 	strh.w	r0, [r3, #120]	; 0x78
	printk("Provisioned and configured!\n");
    19d0:	480f      	ldr	r0, [pc, #60]	; (1a10 <button_pressed+0x118>)
}
    19d2:	b00a      	add	sp, #40	; 0x28
    19d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	printk("Provisioned and configured!\n");
    19d8:	f023 bbf0 	b.w	251bc <printk>
    19dc:	20000294 	.word	0x20000294
    19e0:	200010f0 	.word	0x200010f0
    19e4:	0002eafb 	.word	0x0002eafb
    19e8:	2000396c 	.word	0x2000396c
    19ec:	0002ddf8 	.word	0x0002ddf8
    19f0:	0002eb3c 	.word	0x0002eb3c
    19f4:	2000394c 	.word	0x2000394c
    19f8:	0002eb53 	.word	0x0002eb53
    19fc:	2000393c 	.word	0x2000393c
    1a00:	2000395c 	.word	0x2000395c
    1a04:	0002eb7a 	.word	0x0002eb7a
    1a08:	2000392c 	.word	0x2000392c
    1a0c:	0002eb99 	.word	0x0002eb99
    1a10:	0002ebb7 	.word	0x0002ebb7

00001a14 <onoff_status_send.isra.0>:
static int onoff_status_send(struct bt_mesh_model *model,
    1a14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
}

static inline k_ticks_t k_work_delayable_remaining_get(
	const struct k_work_delayable *dwork)
{
	return z_timeout_remaining(&dwork->timeout);
    1a18:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 1ad0 <onoff_status_send.isra.0+0xbc>
    1a1c:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(buf, OP_ONOFF_STATUS, 3);
    1a1e:	ab02      	add	r3, sp, #8
    1a20:	f44f 2210 	mov.w	r2, #589824	; 0x90000
static int onoff_status_send(struct bt_mesh_model *model,
    1a24:	4605      	mov	r5, r0
    1a26:	460e      	mov	r6, r1
	bt_mesh_model_msg_init(&buf, OP_ONOFF_STATUS);
    1a28:	a805      	add	r0, sp, #20
    1a2a:	f248 2104 	movw	r1, #33284	; 0x8204
	BT_MESH_MODEL_BUF_DEFINE(buf, OP_ONOFF_STATUS, 3);
    1a2e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    1a32:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&buf, OP_ONOFF_STATUS);
    1a34:	f028 fb77 	bl	2a126 <bt_mesh_model_msg_init>
    1a38:	f108 0018 	add.w	r0, r8, #24
    1a3c:	f02b fb4a 	bl	2d0d4 <z_timeout_remaining>
			return (uint32_t)((t * to_hz + off) / from_hz);
    1a40:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
    1a44:	fba0 0407 	umull	r0, r4, r0, r7
    1a48:	0bc0      	lsrs	r0, r0, #15
    1a4a:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
	remaining = k_ticks_to_ms_floor32(
    1a4e:	f8d8 4004 	ldr.w	r4, [r8, #4]
	if (remaining) {
    1a52:	f898 1000 	ldrb.w	r1, [r8]
    1a56:	1824      	adds	r4, r4, r0
    1a58:	d022      	beq.n	1aa0 <onoff_status_send.isra.0+0x8c>
		net_buf_simple_add_u8(&buf, !onoff.val);
    1a5a:	f081 0101 	eor.w	r1, r1, #1
    1a5e:	a805      	add	r0, sp, #20
    1a60:	f02a f97b 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_u8(&buf, onoff.val);
    1a64:	f898 1000 	ldrb.w	r1, [r8]
    1a68:	a805      	add	r0, sp, #20
    1a6a:	f02a f976 	bl	2bd5a <net_buf_simple_add_u8>
	if (ms == SYS_FOREVER_MS) {
    1a6e:	1c63      	adds	r3, r4, #1
    1a70:	d02c      	beq.n	1acc <onoff_status_send.isra.0+0xb8>
		if (ms >= BIT_MASK(6) * time_res[i]) {
    1a72:	f641 039b 	movw	r3, #6299	; 0x189b
    1a76:	429c      	cmp	r4, r3
    1a78:	d91f      	bls.n	1aba <onoff_status_send.isra.0+0xa6>
    1a7a:	f24f 6317 	movw	r3, #62999	; 0xf617
    1a7e:	429c      	cmp	r4, r3
    1a80:	d91e      	bls.n	1ac0 <onoff_status_send.isra.0+0xac>
    1a82:	4b14      	ldr	r3, [pc, #80]	; (1ad4 <onoff_status_send.isra.0+0xc0>)
    1a84:	429c      	cmp	r4, r3
    1a86:	d91d      	bls.n	1ac4 <onoff_status_send.isra.0+0xb0>
    1a88:	4b13      	ldr	r3, [pc, #76]	; (1ad8 <onoff_status_send.isra.0+0xc4>)
    1a8a:	429c      	cmp	r4, r3
    1a8c:	d81e      	bhi.n	1acc <onoff_status_send.isra.0+0xb8>
    1a8e:	4f13      	ldr	r7, [pc, #76]	; (1adc <onoff_status_send.isra.0+0xc8>)
	for (int i = 0; i < ARRAY_SIZE(time_res); i++) {
    1a90:	2303      	movs	r3, #3
		uint8_t steps = ceiling_fraction(ms, time_res[i]);
    1a92:	3c01      	subs	r4, #1
    1a94:	443c      	add	r4, r7
    1a96:	fbb4 f4f7 	udiv	r4, r4, r7
		return steps | (i << 6);
    1a9a:	ea44 1483 	orr.w	r4, r4, r3, lsl #6
    1a9e:	b2e1      	uxtb	r1, r4
		net_buf_simple_add_u8(&buf, onoff.val);
    1aa0:	a805      	add	r0, sp, #20
    1aa2:	f02a f95a 	bl	2bd5a <net_buf_simple_add_u8>
	return bt_mesh_model_send(model, ctx, &buf, NULL, NULL);
    1aa6:	2300      	movs	r3, #0
    1aa8:	9300      	str	r3, [sp, #0]
    1aaa:	aa05      	add	r2, sp, #20
    1aac:	4631      	mov	r1, r6
    1aae:	4628      	mov	r0, r5
    1ab0:	f00f fa60 	bl	10f74 <bt_mesh_model_send>
}
    1ab4:	b008      	add	sp, #32
    1ab6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (int i = 0; i < ARRAY_SIZE(time_res); i++) {
    1aba:	2300      	movs	r3, #0
		if (ms >= BIT_MASK(6) * time_res[i]) {
    1abc:	2764      	movs	r7, #100	; 0x64
    1abe:	e7e8      	b.n	1a92 <onoff_status_send.isra.0+0x7e>
	for (int i = 0; i < ARRAY_SIZE(time_res); i++) {
    1ac0:	2301      	movs	r3, #1
    1ac2:	e7e6      	b.n	1a92 <onoff_status_send.isra.0+0x7e>
    1ac4:	2302      	movs	r3, #2
		if (ms >= BIT_MASK(6) * time_res[i]) {
    1ac6:	f242 7710 	movw	r7, #10000	; 0x2710
    1aca:	e7e2      	b.n	1a92 <onoff_status_send.isra.0+0x7e>
		return 0x3f;
    1acc:	213f      	movs	r1, #63	; 0x3f
    1ace:	e7e7      	b.n	1aa0 <onoff_status_send.isra.0+0x8c>
    1ad0:	200010f0 	.word	0x200010f0
    1ad4:	00099cef 	.word	0x00099cef
    1ad8:	0240c83f 	.word	0x0240c83f
    1adc:	000927c0 	.word	0x000927c0

00001ae0 <gen_onoff_set_unack>:
{
    1ae0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t val = net_buf_simple_pull_u8(buf);
    1ae4:	4610      	mov	r0, r2
{
    1ae6:	4615      	mov	r5, r2
    1ae8:	460f      	mov	r7, r1
	uint8_t val = net_buf_simple_pull_u8(buf);
    1aea:	f02a f9a7 	bl	2be3c <net_buf_simple_pull_u8>
    1aee:	4606      	mov	r6, r0
	uint8_t tid = net_buf_simple_pull_u8(buf);
    1af0:	4628      	mov	r0, r5
    1af2:	f02a f9a3 	bl	2be3c <net_buf_simple_pull_u8>
	if (buf->len) {
    1af6:	88ac      	ldrh	r4, [r5, #4]
	uint8_t tid = net_buf_simple_pull_u8(buf);
    1af8:	4680      	mov	r8, r0
	if (buf->len) {
    1afa:	2c00      	cmp	r4, #0
    1afc:	d047      	beq.n	1b8e <gen_onoff_set_unack+0xae>
		trans = model_time_decode(net_buf_simple_pull_u8(buf));
    1afe:	4628      	mov	r0, r5
    1b00:	f02a f99c 	bl	2be3c <net_buf_simple_pull_u8>
	uint8_t steps = val & BIT_MASK(6);
    1b04:	f000 033f 	and.w	r3, r0, #63	; 0x3f
	if (steps == 0x3f) {
    1b08:	2b3f      	cmp	r3, #63	; 0x3f
	uint8_t resolution = (val >> 6) & BIT_MASK(2);
    1b0a:	f3c0 1187 	ubfx	r1, r0, #6, #8
	return steps * time_res[resolution];
    1b0e:	bf1e      	ittt	ne
    1b10:	4a20      	ldrne	r2, [pc, #128]	; (1b94 <gen_onoff_set_unack+0xb4>)
    1b12:	f852 0021 	ldrne.w	r0, [r2, r1, lsl #2]
    1b16:	fb00 f903 	mulne.w	r9, r0, r3
		delay = net_buf_simple_pull_u8(buf) * 5;
    1b1a:	4628      	mov	r0, r5
		return SYS_FOREVER_MS;
    1b1c:	bf08      	it	eq
    1b1e:	f04f 39ff 	moveq.w	r9, #4294967295	; 0xffffffff
		delay = net_buf_simple_pull_u8(buf) * 5;
    1b22:	f02a f98b 	bl	2be3c <net_buf_simple_pull_u8>
    1b26:	b204      	sxth	r4, r0
    1b28:	eb04 0484 	add.w	r4, r4, r4, lsl #2
	if (tid == onoff.tid && ctx->addr == onoff.src) {
    1b2c:	4d1a      	ldr	r5, [pc, #104]	; (1b98 <gen_onoff_set_unack+0xb8>)
    1b2e:	786b      	ldrb	r3, [r5, #1]
    1b30:	4543      	cmp	r3, r8
    1b32:	d103      	bne.n	1b3c <gen_onoff_set_unack+0x5c>
    1b34:	88ba      	ldrh	r2, [r7, #4]
    1b36:	886b      	ldrh	r3, [r5, #2]
    1b38:	429a      	cmp	r2, r3
    1b3a:	d025      	beq.n	1b88 <gen_onoff_set_unack+0xa8>
	if (val == onoff.val) {
    1b3c:	782b      	ldrb	r3, [r5, #0]
    1b3e:	42b3      	cmp	r3, r6
    1b40:	d022      	beq.n	1b88 <gen_onoff_set_unack+0xa8>
	printk("set: %s delay: %d ms time: %d ms\n", onoff_str[val], delay,
    1b42:	4916      	ldr	r1, [pc, #88]	; (1b9c <gen_onoff_set_unack+0xbc>)
    1b44:	4816      	ldr	r0, [pc, #88]	; (1ba0 <gen_onoff_set_unack+0xc0>)
    1b46:	f851 1026 	ldr.w	r1, [r1, r6, lsl #2]
    1b4a:	464b      	mov	r3, r9
    1b4c:	4622      	mov	r2, r4
    1b4e:	f023 fb35 	bl	251bc <printk>
	onoff.val = val;
    1b52:	3e00      	subs	r6, #0
	onoff.src = ctx->addr;
    1b54:	88bb      	ldrh	r3, [r7, #4]
    1b56:	806b      	strh	r3, [r5, #2]
	onoff.val = val;
    1b58:	bf18      	it	ne
    1b5a:	2601      	movne	r6, #1
	onoff.tid = tid;
    1b5c:	f885 8001 	strb.w	r8, [r5, #1]
	onoff.val = val;
    1b60:	702e      	strb	r6, [r5, #0]
	onoff.transition_time = trans;
    1b62:	f8c5 9004 	str.w	r9, [r5, #4]
			return ((t * to_hz + off) / from_hz);
    1b66:	f240 30e7 	movw	r0, #999	; 0x3e7
    1b6a:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    1b6e:	2100      	movs	r1, #0
    1b70:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1b74:	2300      	movs	r3, #0
    1b76:	fbc4 0105 	smlal	r0, r1, r4, r5
    1b7a:	f7fe fab1 	bl	e0 <__aeabi_uldivmod>
    1b7e:	4602      	mov	r2, r0
    1b80:	460b      	mov	r3, r1
	k_work_reschedule(&onoff.work, K_MSEC(delay));
    1b82:	4808      	ldr	r0, [pc, #32]	; (1ba4 <gen_onoff_set_unack+0xc4>)
    1b84:	f022 fbee 	bl	24364 <k_work_reschedule>
}
    1b88:	2000      	movs	r0, #0
    1b8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	int32_t trans = 0;
    1b8e:	46a1      	mov	r9, r4
    1b90:	e7cc      	b.n	1b2c <gen_onoff_set_unack+0x4c>
    1b92:	bf00      	nop
    1b94:	0002de4c 	.word	0x0002de4c
    1b98:	200010f0 	.word	0x200010f0
    1b9c:	0002ddf8 	.word	0x0002ddf8
    1ba0:	0002ebd4 	.word	0x0002ebd4
    1ba4:	200010f8 	.word	0x200010f8

00001ba8 <main>:

void main(void)
{
    1ba8:	b510      	push	{r4, lr}
	static struct k_work button_work;
	int err = -1;

	printk("Initializing...\n");
    1baa:	4814      	ldr	r0, [pc, #80]	; (1bfc <main+0x54>)
    1bac:	f023 fb06 	bl	251bc <printk>
		/* coverity[OVERRUN] */
		return (ssize_t) arch_syscall_invoke2(*(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
    1bb0:	4c13      	ldr	r4, [pc, #76]	; (1c00 <main+0x58>)
    1bb2:	2110      	movs	r1, #16
    1bb4:	4620      	mov	r0, r4
    1bb6:	f02a fc05 	bl	2c3c4 <z_impl_hwinfo_get_device_id>

	if (IS_ENABLED(CONFIG_HWINFO)) {
		err = hwinfo_get_device_id(dev_uuid, sizeof(dev_uuid));
	}

	if (err < 0) {
    1bba:	2800      	cmp	r0, #0
		dev_uuid[0] = 0xdd;
    1bbc:	bfb8      	it	lt
    1bbe:	23dd      	movlt	r3, #221	; 0xdd
		dev_uuid[1] = 0xdd;
	}

	k_work_init(&button_work, button_pressed);
    1bc0:	4910      	ldr	r1, [pc, #64]	; (1c04 <main+0x5c>)
    1bc2:	4811      	ldr	r0, [pc, #68]	; (1c08 <main+0x60>)
		dev_uuid[0] = 0xdd;
    1bc4:	bfbc      	itt	lt
    1bc6:	7023      	strblt	r3, [r4, #0]
		dev_uuid[1] = 0xdd;
    1bc8:	7063      	strblt	r3, [r4, #1]
	k_work_init(&button_work, button_pressed);
    1bca:	f02b f8d8 	bl	2cd7e <k_work_init>

	err = board_init(&button_work);
    1bce:	480e      	ldr	r0, [pc, #56]	; (1c08 <main+0x60>)
    1bd0:	f000 f82c 	bl	1c2c <board_init>
	if (err) {
    1bd4:	4601      	mov	r1, r0
    1bd6:	b120      	cbz	r0, 1be2 <main+0x3a>
		printk("Board init failed (err: %d)\n", err);
    1bd8:	480c      	ldr	r0, [pc, #48]	; (1c0c <main+0x64>)
	/* Initialize the Bluetooth Subsystem */
	err = bt_enable(bt_ready);
	if (err) {
		printk("Bluetooth init failed (err %d)\n", err);
	}
}
    1bda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		printk("Bluetooth init failed (err %d)\n", err);
    1bde:	f023 baed 	b.w	251bc <printk>
	k_work_init_delayable(&onoff.work, onoff_timeout);
    1be2:	490b      	ldr	r1, [pc, #44]	; (1c10 <main+0x68>)
    1be4:	480b      	ldr	r0, [pc, #44]	; (1c14 <main+0x6c>)
    1be6:	f02b f900 	bl	2cdea <k_work_init_delayable>
	err = bt_enable(bt_ready);
    1bea:	480b      	ldr	r0, [pc, #44]	; (1c18 <main+0x70>)
    1bec:	f005 f9b8 	bl	6f60 <bt_enable>
	if (err) {
    1bf0:	4601      	mov	r1, r0
    1bf2:	b108      	cbz	r0, 1bf8 <main+0x50>
		printk("Bluetooth init failed (err %d)\n", err);
    1bf4:	4809      	ldr	r0, [pc, #36]	; (1c1c <main+0x74>)
    1bf6:	e7f0      	b.n	1bda <main+0x32>
}
    1bf8:	bd10      	pop	{r4, pc}
    1bfa:	bf00      	nop
    1bfc:	0002ebf6 	.word	0x0002ebf6
    1c00:	2000394c 	.word	0x2000394c
    1c04:	000018f9 	.word	0x000018f9
    1c08:	200024a8 	.word	0x200024a8
    1c0c:	0002ec07 	.word	0x0002ec07
    1c10:	000018b1 	.word	0x000018b1
    1c14:	200010f8 	.word	0x200010f8
    1c18:	0000185d 	.word	0x0000185d
    1c1c:	0002ea8f 	.word	0x0002ea8f

00001c20 <button_cb>:
static struct k_work *button_work;

static void button_cb(const struct device *port, struct gpio_callback *cb,
		      gpio_port_pins_t pins)
{
	k_work_submit(button_work);
    1c20:	4b01      	ldr	r3, [pc, #4]	; (1c28 <button_cb+0x8>)
    1c22:	6818      	ldr	r0, [r3, #0]
    1c24:	f022 bb02 	b.w	2422c <k_work_submit>
    1c28:	200024b8 	.word	0x200024b8

00001c2c <board_init>:

	return 0;
}

int board_init(struct k_work *button_pressed)
{
    1c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1c30:	4607      	mov	r7, r0
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
    1c32:	4c25      	ldr	r4, [pc, #148]	; (1cc8 <board_init+0x9c>)
    1c34:	4620      	mov	r0, r4
    1c36:	f02a fe61 	bl	2c8fc <z_device_is_ready>
	if (!device_is_ready(led_dev)) {
    1c3a:	2800      	cmp	r0, #0
    1c3c:	d040      	beq.n	1cc0 <board_init+0x94>
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
    1c3e:	6922      	ldr	r2, [r4, #16]
	const struct gpio_driver_api *api =
    1c40:	68a1      	ldr	r1, [r4, #8]
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
    1c42:	6813      	ldr	r3, [r2, #0]
    1c44:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1c48:	6013      	str	r3, [r2, #0]
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
    1c4a:	4620      	mov	r0, r4
    1c4c:	680b      	ldr	r3, [r1, #0]
    1c4e:	f640 2201 	movw	r2, #2561	; 0xa01
    1c52:	2107      	movs	r1, #7
    1c54:	4798      	blx	r3
	if (err) {
    1c56:	4604      	mov	r4, r0
    1c58:	bb78      	cbnz	r0, 1cba <board_init+0x8e>
	const struct gpio_driver_api *api =
    1c5a:	4d1c      	ldr	r5, [pc, #112]	; (1ccc <board_init+0xa0>)
	struct gpio_driver_data *data =
    1c5c:	f8d5 8010 	ldr.w	r8, [r5, #16]
	const struct gpio_driver_api *api =
    1c60:	68ae      	ldr	r6, [r5, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
    1c62:	f8d8 3000 	ldr.w	r3, [r8]
    1c66:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    1c6a:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
    1c6e:	f240 1211 	movw	r2, #273	; 0x111
    1c72:	6833      	ldr	r3, [r6, #0]
    1c74:	210b      	movs	r1, #11
    1c76:	4628      	mov	r0, r5
    1c78:	4798      	blx	r3
	if (err) {
    1c7a:	4604      	mov	r4, r0
    1c7c:	b9e8      	cbnz	r0, 1cba <board_init+0x8e>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
    1c7e:	f8d8 3000 	ldr.w	r3, [r8]
	return api->pin_interrupt_configure(port, pin, mode, trig);
    1c82:	69b4      	ldr	r4, [r6, #24]
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
    1c84:	f413 6f00 	tst.w	r3, #2048	; 0x800
	return api->pin_interrupt_configure(port, pin, mode, trig);
    1c88:	bf0c      	ite	eq
    1c8a:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
    1c8e:	f44f 3300 	movne.w	r3, #131072	; 0x20000
    1c92:	f44f 32a0 	mov.w	r2, #81920	; 0x14000
    1c96:	210b      	movs	r1, #11
    1c98:	4628      	mov	r0, r5
    1c9a:	47a0      	blx	r4
	if (err) {
    1c9c:	4604      	mov	r4, r0
    1c9e:	b960      	cbnz	r0, 1cba <board_init+0x8e>
	button_work = button_pressed;
    1ca0:	4b0b      	ldr	r3, [pc, #44]	; (1cd0 <board_init+0xa4>)
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
    1ca2:	490c      	ldr	r1, [pc, #48]	; (1cd4 <board_init+0xa8>)
    1ca4:	601f      	str	r7, [r3, #0]
    1ca6:	4b0c      	ldr	r3, [pc, #48]	; (1cd8 <board_init+0xac>)
    1ca8:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
    1caa:	f44f 6300 	mov.w	r3, #2048	; 0x800
    1cae:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
    1cb0:	69f3      	ldr	r3, [r6, #28]
    1cb2:	b113      	cbz	r3, 1cba <board_init+0x8e>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
    1cb4:	2201      	movs	r2, #1
    1cb6:	4628      	mov	r0, r5
    1cb8:	4798      	blx	r3
	if (err) {
		return err;
	}

	return button_init(button_pressed);
}
    1cba:	4620      	mov	r0, r4
    1cbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENODEV;
    1cc0:	f06f 0412 	mvn.w	r4, #18
    1cc4:	e7f9      	b.n	1cba <board_init+0x8e>
    1cc6:	bf00      	nop
    1cc8:	0002d630 	.word	0x0002d630
    1ccc:	0002d588 	.word	0x0002d588
    1cd0:	200024b8 	.word	0x200024b8
    1cd4:	200024bc 	.word	0x200024bc
    1cd8:	00001c21 	.word	0x00001c21

00001cdc <board_led_set>:
	const struct gpio_driver_data *const data =
    1cdc:	4b07      	ldr	r3, [pc, #28]	; (1cfc <board_led_set+0x20>)
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    1cde:	691a      	ldr	r2, [r3, #16]
    1ce0:	6812      	ldr	r2, [r2, #0]
    1ce2:	0612      	lsls	r2, r2, #24
		value = (value != 0) ? 0 : 1;
    1ce4:	bf48      	it	mi
    1ce6:	f080 0001 	eormi.w	r0, r0, #1
	if (value != 0)	{
    1cea:	b120      	cbz	r0, 1cf6 <board_led_set+0x1a>
	return api->port_set_bits_raw(port, pins);
    1cec:	689b      	ldr	r3, [r3, #8]
    1cee:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
    1cf0:	4802      	ldr	r0, [pc, #8]	; (1cfc <board_led_set+0x20>)
    1cf2:	2180      	movs	r1, #128	; 0x80
    1cf4:	4718      	bx	r3
    1cf6:	689b      	ldr	r3, [r3, #8]
    1cf8:	691b      	ldr	r3, [r3, #16]
    1cfa:	e7f9      	b.n	1cf0 <board_led_set+0x14>
    1cfc:	0002d630 	.word	0x0002d630

00001d00 <cbvprintf_package>:

#endif

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
    1d00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d04:	4605      	mov	r5, r0
    1d06:	b08b      	sub	sp, #44	; 0x2c
    1d08:	4618      	mov	r0, r3
	unsigned int i;
	const char *s;
	bool parsing = false;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
    1d0a:	f015 0303 	ands.w	r3, r5, #3
    1d0e:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
{
    1d12:	9203      	str	r2, [sp, #12]
    1d14:	460e      	mov	r6, r1
	if ((uintptr_t)packaged % sizeof(void *)) {
    1d16:	9301      	str	r3, [sp, #4]
    1d18:	f040 81f5 	bne.w	2106 <cbvprintf_package+0x406>
	 *
	 * Given the next value to store is the format string pointer
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * a pointer size for the above to preserve alignment.
	 */
	buf += sizeof(char *);
    1d1c:	1d2c      	adds	r4, r5, #4
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
    1d1e:	2d00      	cmp	r5, #0
    1d20:	f040 81f4 	bne.w	210c <cbvprintf_package+0x40c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
    1d24:	f001 0607 	and.w	r6, r1, #7
    1d28:	1d34      	adds	r4, r6, #4
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
    1d2a:	f1c6 0608 	rsb	r6, r6, #8
	unsigned int s_ro_cnt = 0; /* number of ro strings */
    1d2e:	f04f 0a00 	mov.w	sl, #0
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
    1d32:	2704      	movs	r7, #4
	s = fmt--;
    1d34:	1e41      	subs	r1, r0, #1
	unsigned int s_rw_cnt = 0; /* number of rw strings */
    1d36:	f8cd a008 	str.w	sl, [sp, #8]
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
    1d3a:	f8cd a000 	str.w	sl, [sp]
	bool parsing = false;
    1d3e:	4652      	mov	r2, sl
	size = sizeof(char *);
    1d40:	46b9      	mov	r9, r7

		/* copy va_list data over to our buffer */
		if (*fmt == 's') {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
    1d42:	b105      	cbz	r5, 1d46 <cbvprintf_package+0x46>
				*(const char **)buf = s;
    1d44:	6020      	str	r0, [r4, #0]
			}

			bool is_ro = ptr_in_rodata(s);
			bool do_all = !!(flags & CBPRINTF_PACKAGE_ADD_STRING_IDXS);
    1d46:	9b03      	ldr	r3, [sp, #12]
    1d48:	f003 0e01 	and.w	lr, r3, #1
	return ((addr >= (const char *)RO_START) &&
    1d4c:	4bce      	ldr	r3, [pc, #824]	; (2088 <cbvprintf_package+0x388>)
    1d4e:	4298      	cmp	r0, r3
    1d50:	f0c0 812a 	bcc.w	1fa8 <cbvprintf_package+0x2a8>

			if (is_ro && !do_all) {
    1d54:	4bcd      	ldr	r3, [pc, #820]	; (208c <cbvprintf_package+0x38c>)
    1d56:	4298      	cmp	r0, r3
    1d58:	f080 8126 	bcs.w	1fa8 <cbvprintf_package+0x2a8>
    1d5c:	f1be 0f00 	cmp.w	lr, #0
    1d60:	f000 813c 	beq.w	1fdc <cbvprintf_package+0x2dc>
	return ((addr >= (const char *)RO_START) &&
    1d64:	f04f 0c01 	mov.w	ip, #1
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
    1d68:	eba4 0b05 	sub.w	fp, r4, r5
				 * In the do_all case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_all && s_ptr_idx > STR_POS_MASK) {
    1d6c:	f1be 0f00 	cmp.w	lr, #0
    1d70:	f000 811d 	beq.w	1fae <cbvprintf_package+0x2ae>
    1d74:	f5bb 7f00 	cmp.w	fp, #512	; 0x200
    1d78:	f0c0 8119 	bcc.w	1fae <cbvprintf_package+0x2ae>
					__ASSERT(false, "String with too many arguments");
					return -EINVAL;
    1d7c:	f06f 0015 	mvn.w	r0, #21
    1d80:	e0f5      	b.n	1f6e <cbvprintf_package+0x26e>
		if (!parsing) {
    1d82:	b932      	cbnz	r2, 1d92 <cbvprintf_package+0x92>
			if (*fmt == '%') {
    1d84:	2b25      	cmp	r3, #37	; 0x25
    1d86:	f040 812c 	bne.w	1fe2 <cbvprintf_package+0x2e2>
				parsing = true;
    1d8a:	2201      	movs	r2, #1
			align = VA_STACK_ALIGN(ptrdiff_t);
    1d8c:	2704      	movs	r7, #4
			size = sizeof(intmax_t);
    1d8e:	46b9      	mov	r9, r7
    1d90:	e127      	b.n	1fe2 <cbvprintf_package+0x2e2>
		switch (*fmt) {
    1d92:	2b2b      	cmp	r3, #43	; 0x2b
    1d94:	d824      	bhi.n	1de0 <cbvprintf_package+0xe0>
    1d96:	2b1f      	cmp	r3, #31
    1d98:	d801      	bhi.n	1d9e <cbvprintf_package+0x9e>
			parsing = false;
    1d9a:	2200      	movs	r2, #0
    1d9c:	e121      	b.n	1fe2 <cbvprintf_package+0x2e2>
		switch (*fmt) {
    1d9e:	f1a3 0020 	sub.w	r0, r3, #32
    1da2:	280b      	cmp	r0, #11
    1da4:	d8f9      	bhi.n	1d9a <cbvprintf_package+0x9a>
    1da6:	f20f 0c08 	addw	ip, pc, #8
    1daa:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
    1dae:	bf00      	nop
    1db0:	00001fe3 	.word	0x00001fe3
    1db4:	00001d9b 	.word	0x00001d9b
    1db8:	00001d9b 	.word	0x00001d9b
    1dbc:	00001fe3 	.word	0x00001fe3
    1dc0:	00001d9b 	.word	0x00001d9b
    1dc4:	00001d9b 	.word	0x00001d9b
    1dc8:	00001d9b 	.word	0x00001d9b
    1dcc:	00001d9b 	.word	0x00001d9b
    1dd0:	00001d9b 	.word	0x00001d9b
    1dd4:	00001d9b 	.word	0x00001d9b
    1dd8:	00001f87 	.word	0x00001f87
    1ddc:	00001fe3 	.word	0x00001fe3
    1de0:	f1a3 002d 	sub.w	r0, r3, #45	; 0x2d
    1de4:	fa5f fc80 	uxtb.w	ip, r0
    1de8:	f1bc 0f4d 	cmp.w	ip, #77	; 0x4d
    1dec:	d8d5      	bhi.n	1d9a <cbvprintf_package+0x9a>
    1dee:	284d      	cmp	r0, #77	; 0x4d
    1df0:	d8d3      	bhi.n	1d9a <cbvprintf_package+0x9a>
    1df2:	f20f 0c08 	addw	ip, pc, #8
    1df6:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
    1dfa:	bf00      	nop
    1dfc:	00001fe3 	.word	0x00001fe3
    1e00:	00001fe3 	.word	0x00001fe3
    1e04:	00001d9b 	.word	0x00001d9b
    1e08:	00001fe3 	.word	0x00001fe3
    1e0c:	00001fe3 	.word	0x00001fe3
    1e10:	00001fe3 	.word	0x00001fe3
    1e14:	00001fe3 	.word	0x00001fe3
    1e18:	00001fe3 	.word	0x00001fe3
    1e1c:	00001fe3 	.word	0x00001fe3
    1e20:	00001fe3 	.word	0x00001fe3
    1e24:	00001fe3 	.word	0x00001fe3
    1e28:	00001fe3 	.word	0x00001fe3
    1e2c:	00001fe3 	.word	0x00001fe3
    1e30:	00001d9b 	.word	0x00001d9b
    1e34:	00001d9b 	.word	0x00001d9b
    1e38:	00001d9b 	.word	0x00001d9b
    1e3c:	00001d9b 	.word	0x00001d9b
    1e40:	00001d9b 	.word	0x00001d9b
    1e44:	00001d9b 	.word	0x00001d9b
    1e48:	00001d9b 	.word	0x00001d9b
    1e4c:	00001f4f 	.word	0x00001f4f
    1e50:	00001d9b 	.word	0x00001d9b
    1e54:	00001d9b 	.word	0x00001d9b
    1e58:	00001d9b 	.word	0x00001d9b
    1e5c:	00001f4f 	.word	0x00001f4f
    1e60:	00001f4f 	.word	0x00001f4f
    1e64:	00001f4f 	.word	0x00001f4f
    1e68:	00001d9b 	.word	0x00001d9b
    1e6c:	00001d9b 	.word	0x00001d9b
    1e70:	00001d9b 	.word	0x00001d9b
    1e74:	00001d9b 	.word	0x00001d9b
    1e78:	00001fe3 	.word	0x00001fe3
    1e7c:	00001d9b 	.word	0x00001d9b
    1e80:	00001d9b 	.word	0x00001d9b
    1e84:	00001d9b 	.word	0x00001d9b
    1e88:	00001d9b 	.word	0x00001d9b
    1e8c:	00001d9b 	.word	0x00001d9b
    1e90:	00001d9b 	.word	0x00001d9b
    1e94:	00001d9b 	.word	0x00001d9b
    1e98:	00001d9b 	.word	0x00001d9b
    1e9c:	00001d9b 	.word	0x00001d9b
    1ea0:	00001d9b 	.word	0x00001d9b
    1ea4:	00001d9b 	.word	0x00001d9b
    1ea8:	00001f35 	.word	0x00001f35
    1eac:	00001d9b 	.word	0x00001d9b
    1eb0:	00001d9b 	.word	0x00001d9b
    1eb4:	00001d9b 	.word	0x00001d9b
    1eb8:	00001d9b 	.word	0x00001d9b
    1ebc:	00001d9b 	.word	0x00001d9b
    1ec0:	00001d9b 	.word	0x00001d9b
    1ec4:	00001d9b 	.word	0x00001d9b
    1ec8:	00001d9b 	.word	0x00001d9b
    1ecc:	00001f4f 	.word	0x00001f4f
    1ed0:	00001d9b 	.word	0x00001d9b
    1ed4:	00001f35 	.word	0x00001f35
    1ed8:	00001f35 	.word	0x00001f35
    1edc:	00001f4f 	.word	0x00001f4f
    1ee0:	00001f4f 	.word	0x00001f4f
    1ee4:	00001f4f 	.word	0x00001f4f
    1ee8:	00001fe3 	.word	0x00001fe3
    1eec:	00001f35 	.word	0x00001f35
    1ef0:	00001f7d 	.word	0x00001f7d
    1ef4:	00001d9b 	.word	0x00001d9b
    1ef8:	00001fe3 	.word	0x00001fe3
    1efc:	00001d9b 	.word	0x00001d9b
    1f00:	00001f81 	.word	0x00001f81
    1f04:	00001f35 	.word	0x00001f35
    1f08:	00001f81 	.word	0x00001f81
    1f0c:	00001d9b 	.word	0x00001d9b
    1f10:	00001d9b 	.word	0x00001d9b
    1f14:	00001f81 	.word	0x00001f81
    1f18:	00001d8d 	.word	0x00001d8d
    1f1c:	00001f35 	.word	0x00001f35
    1f20:	00001d9b 	.word	0x00001d9b
    1f24:	00001d9b 	.word	0x00001d9b
    1f28:	00001f35 	.word	0x00001f35
    1f2c:	00001d9b 	.word	0x00001d9b
    1f30:	00001d8d 	.word	0x00001d8d
			if (fmt[-1] == 'l') {
    1f34:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    1f38:	2a6c      	cmp	r2, #108	; 0x6c
    1f3a:	d123      	bne.n	1f84 <cbvprintf_package+0x284>
				if (fmt[-2] == 'l') {
    1f3c:	f811 2c02 	ldrb.w	r2, [r1, #-2]
    1f40:	2a6c      	cmp	r2, #108	; 0x6c
			parsing = false;
    1f42:	f04f 0200 	mov.w	r2, #0
				if (fmt[-2] == 'l') {
    1f46:	d02d      	beq.n	1fa4 <cbvprintf_package+0x2a4>
			align = VA_STACK_ALIGN(void *);
    1f48:	2704      	movs	r7, #4
					size = sizeof(long long);
    1f4a:	46b9      	mov	r9, r7
    1f4c:	e01b      	b.n	1f86 <cbvprintf_package+0x286>
				v.ld = va_arg(ap, long double);
    1f4e:	f108 0807 	add.w	r8, r8, #7
    1f52:	f028 0807 	bic.w	r8, r8, #7
			buf = (void *) ROUND_UP(buf, align);
    1f56:	3407      	adds	r4, #7
				v.ld = va_arg(ap, long double);
    1f58:	e8f8 2302 	ldrd	r2, r3, [r8], #8
			buf = (void *) ROUND_UP(buf, align);
    1f5c:	f024 0407 	bic.w	r4, r4, #7
			if (buf0 != NULL) {
    1f60:	b155      	cbz	r5, 1f78 <cbvprintf_package+0x278>
				if (BUF_OFFSET + size > len) {
    1f62:	eb0e 0004 	add.w	r0, lr, r4
    1f66:	42b0      	cmp	r0, r6
    1f68:	d904      	bls.n	1f74 <cbvprintf_package+0x274>
					return -ENOSPC;
    1f6a:	f06f 001b 	mvn.w	r0, #27
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
    1f6e:	b00b      	add	sp, #44	; 0x2c
    1f70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					*(long double *)buf = v.ld;
    1f74:	e9c4 2300 	strd	r2, r3, [r4]
			buf += size;
    1f78:	3408      	adds	r4, #8
			parsing = false;
    1f7a:	2200      	movs	r2, #0
			align = VA_STACK_ALIGN(intmax_t);
    1f7c:	2708      	movs	r7, #8
    1f7e:	e706      	b.n	1d8e <cbvprintf_package+0x8e>
			parsing = false;
    1f80:	2200      	movs	r2, #0
    1f82:	e7e1      	b.n	1f48 <cbvprintf_package+0x248>
			parsing = false;
    1f84:	2200      	movs	r2, #0
		buf = (void *) ROUND_UP(buf, align);
    1f86:	3c01      	subs	r4, #1
    1f88:	443c      	add	r4, r7
    1f8a:	4278      	negs	r0, r7
    1f8c:	4004      	ands	r4, r0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
    1f8e:	b125      	cbz	r5, 1f9a <cbvprintf_package+0x29a>
    1f90:	eba9 0005 	sub.w	r0, r9, r5
    1f94:	4420      	add	r0, r4
    1f96:	42b0      	cmp	r0, r6
    1f98:	d8e7      	bhi.n	1f6a <cbvprintf_package+0x26a>
		if (*fmt == 's') {
    1f9a:	2b73      	cmp	r3, #115	; 0x73
    1f9c:	d143      	bne.n	2026 <cbvprintf_package+0x326>
			s = va_arg(ap, char *);
    1f9e:	f858 0b04 	ldr.w	r0, [r8], #4
    1fa2:	e6ce      	b.n	1d42 <cbvprintf_package+0x42>
					align = VA_STACK_ALIGN(long long);
    1fa4:	2708      	movs	r7, #8
    1fa6:	e7d0      	b.n	1f4a <cbvprintf_package+0x24a>
	return ((addr >= (const char *)RO_START) &&
    1fa8:	f04f 0c00 	mov.w	ip, #0
    1fac:	e6dc      	b.n	1d68 <cbvprintf_package+0x68>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
    1fae:	9b00      	ldr	r3, [sp, #0]
    1fb0:	2b0f      	cmp	r3, #15
    1fb2:	f63f aee3 	bhi.w	1d7c <cbvprintf_package+0x7c>
				if (buf0 != NULL) {
    1fb6:	b345      	cbz	r5, 200a <cbvprintf_package+0x30a>
					str_ptr_pos[s_idx] = s_ptr_idx;
    1fb8:	f8dd e000 	ldr.w	lr, [sp]
    1fbc:	a80a      	add	r0, sp, #40	; 0x28
    1fbe:	f3cb 0387 	ubfx	r3, fp, #2, #8
					if (is_ro) {
    1fc2:	4470      	add	r0, lr
    1fc4:	f1bc 0f00 	cmp.w	ip, #0
    1fc8:	d019      	beq.n	1ffe <cbvprintf_package+0x2fe>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
    1fca:	f063 037f 	orn	r3, r3, #127	; 0x7f
    1fce:	f800 3c10 	strb.w	r3, [r0, #-16]
						s_ro_cnt++;
    1fd2:	f10a 0a01 	add.w	sl, sl, #1
				s_idx++;
    1fd6:	9b00      	ldr	r3, [sp, #0]
    1fd8:	3301      	adds	r3, #1
    1fda:	9300      	str	r3, [sp, #0]
			buf += sizeof(char *);
    1fdc:	3404      	adds	r4, #4
				if (BUF_OFFSET + size > len) {
    1fde:	f1c5 0e08 	rsb	lr, r5, #8
	while (*++fmt != '\0') {
    1fe2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    1fe6:	2b00      	cmp	r3, #0
    1fe8:	f47f aecb 	bne.w	1d82 <cbvprintf_package+0x82>
	if (BUF_OFFSET / sizeof(int) > 255) {
    1fec:	1b60      	subs	r0, r4, r5
    1fee:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    1ff2:	f4bf aec3 	bcs.w	1d7c <cbvprintf_package+0x7c>
	if (buf0 == NULL) {
    1ff6:	bb9d      	cbnz	r5, 2060 <cbvprintf_package+0x360>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
    1ff8:	3e08      	subs	r6, #8
    1ffa:	4430      	add	r0, r6
    1ffc:	e7b7      	b.n	1f6e <cbvprintf_package+0x26e>
					str_ptr_pos[s_idx] = s_ptr_idx;
    1ffe:	f800 3c10 	strb.w	r3, [r0, #-16]
						s_rw_cnt++;
    2002:	9b02      	ldr	r3, [sp, #8]
    2004:	3301      	adds	r3, #1
    2006:	9302      	str	r3, [sp, #8]
    2008:	e7e5      	b.n	1fd6 <cbvprintf_package+0x2d6>
				} else if (is_ro) {
    200a:	f1bc 0f00 	cmp.w	ip, #0
    200e:	d001      	beq.n	2014 <cbvprintf_package+0x314>
					len += 1;
    2010:	3601      	adds	r6, #1
    2012:	e7e0      	b.n	1fd6 <cbvprintf_package+0x2d6>
    2014:	e9cd 1204 	strd	r1, r2, [sp, #16]
					len += strlen(s) + 1 + 1;
    2018:	f025 fbec 	bl	277f4 <strlen>
    201c:	3602      	adds	r6, #2
    201e:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
    2022:	4406      	add	r6, r0
    2024:	e7d7      	b.n	1fd6 <cbvprintf_package+0x2d6>
		} else if (size == sizeof(int)) {
    2026:	f1b9 0f04 	cmp.w	r9, #4
    202a:	d108      	bne.n	203e <cbvprintf_package+0x33e>
			int v = va_arg(ap, int);
    202c:	f108 0004 	add.w	r0, r8, #4
			if (buf0 != NULL) {
    2030:	b115      	cbz	r5, 2038 <cbvprintf_package+0x338>
			int v = va_arg(ap, int);
    2032:	f8d8 3000 	ldr.w	r3, [r8]
				*(int *)buf = v;
    2036:	6023      	str	r3, [r4, #0]
			buf += sizeof(int);
    2038:	3404      	adds	r4, #4
			int v = va_arg(ap, int);
    203a:	4680      	mov	r8, r0
    203c:	e7d1      	b.n	1fe2 <cbvprintf_package+0x2e2>
		} else if (size == sizeof(long long)) {
    203e:	f1b9 0f08 	cmp.w	r9, #8
    2042:	f47f ae9b 	bne.w	1d7c <cbvprintf_package+0x7c>
			long long v = va_arg(ap, long long);
    2046:	f108 0307 	add.w	r3, r8, #7
    204a:	f023 0307 	bic.w	r3, r3, #7
    204e:	f103 0808 	add.w	r8, r3, #8
			if (buf0 != NULL) {
    2052:	b11d      	cbz	r5, 205c <cbvprintf_package+0x35c>
			long long v = va_arg(ap, long long);
    2054:	e9d3 bc00 	ldrd	fp, ip, [r3]
    2058:	e9c4 bc00 	strd	fp, ip, [r4]
			buf += sizeof(long long);
    205c:	3408      	adds	r4, #8
    205e:	e7c0      	b.n	1fe2 <cbvprintf_package+0x2e2>
	buf0[1] = s_rw_cnt;
    2060:	9a02      	ldr	r2, [sp, #8]
	*(char **)buf0 = NULL;
    2062:	602b      	str	r3, [r5, #0]
	buf0[0] = BUF_OFFSET / sizeof(int);
    2064:	0880      	lsrs	r0, r0, #2
    2066:	7028      	strb	r0, [r5, #0]
	buf0[1] = s_rw_cnt;
    2068:	706a      	strb	r2, [r5, #1]
	buf0[2] = s_ro_cnt;
    206a:	f885 a002 	strb.w	sl, [r5, #2]
	if (s_ro_cnt) {
    206e:	f1ba 0f00 	cmp.w	sl, #0
    2072:	d005      	beq.n	2080 <cbvprintf_package+0x380>
    2074:	a906      	add	r1, sp, #24
			if (BUF_OFFSET + 1 > len) {
    2076:	f1c5 0001 	rsb	r0, r5, #1
		for (i = 0; i < s_idx; i++) {
    207a:	9a00      	ldr	r2, [sp, #0]
    207c:	429a      	cmp	r2, r3
    207e:	d107      	bne.n	2090 <cbvprintf_package+0x390>
		if (BUF_OFFSET + 1 + size > len) {
    2080:	f1c5 0901 	rsb	r9, r5, #1
    2084:	e039      	b.n	20fa <cbvprintf_package+0x3fa>
    2086:	bf00      	nop
    2088:	0002d4b8 	.word	0x0002d4b8
    208c:	00034ee0 	.word	0x00034ee0
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
    2090:	f811 2b01 	ldrb.w	r2, [r1], #1
    2094:	0617      	lsls	r7, r2, #24
    2096:	d507      	bpl.n	20a8 <cbvprintf_package+0x3a8>
			if (BUF_OFFSET + 1 > len) {
    2098:	1827      	adds	r7, r4, r0
    209a:	42b7      	cmp	r7, r6
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
    209c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
			if (BUF_OFFSET + 1 > len) {
    20a0:	f63f af63 	bhi.w	1f6a <cbvprintf_package+0x26a>
			*buf++ = pos;
    20a4:	f804 2b01 	strb.w	r2, [r4], #1
		for (i = 0; i < s_idx; i++) {
    20a8:	3301      	adds	r3, #1
    20aa:	e7e6      	b.n	207a <cbvprintf_package+0x37a>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
    20ac:	9b01      	ldr	r3, [sp, #4]
    20ae:	aa06      	add	r2, sp, #24
    20b0:	f812 8003 	ldrb.w	r8, [r2, r3]
    20b4:	f1ba 0f00 	cmp.w	sl, #0
    20b8:	d002      	beq.n	20c0 <cbvprintf_package+0x3c0>
    20ba:	f018 0f80 	tst.w	r8, #128	; 0x80
    20be:	d119      	bne.n	20f4 <cbvprintf_package+0x3f4>
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
    20c0:	fa0f f288 	sxth.w	r2, r8
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
    20c4:	2300      	movs	r3, #0
		s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
    20c6:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
		*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
    20ca:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
		size = strlen(s) + 1;
    20ce:	4608      	mov	r0, r1
    20d0:	9102      	str	r1, [sp, #8]
    20d2:	f025 fb8f 	bl	277f4 <strlen>
		if (BUF_OFFSET + 1 + size > len) {
    20d6:	eb04 0209 	add.w	r2, r4, r9
		size = strlen(s) + 1;
    20da:	1c47      	adds	r7, r0, #1
		if (BUF_OFFSET + 1 + size > len) {
    20dc:	443a      	add	r2, r7
    20de:	42b2      	cmp	r2, r6
    20e0:	f63f af43 	bhi.w	1f6a <cbvprintf_package+0x26a>
		*buf++ = str_ptr_pos[i];
    20e4:	f804 8b01 	strb.w	r8, [r4], #1
		memcpy(buf, s, size);
    20e8:	9902      	ldr	r1, [sp, #8]
    20ea:	4620      	mov	r0, r4
    20ec:	463a      	mov	r2, r7
    20ee:	f025 fbbf 	bl	27870 <memcpy>
		buf += size;
    20f2:	443c      	add	r4, r7
	for (i = 0; i < s_idx; i++) {
    20f4:	9b01      	ldr	r3, [sp, #4]
    20f6:	3301      	adds	r3, #1
    20f8:	9301      	str	r3, [sp, #4]
    20fa:	e9dd 2300 	ldrd	r2, r3, [sp]
    20fe:	429a      	cmp	r2, r3
    2100:	d1d4      	bne.n	20ac <cbvprintf_package+0x3ac>
	return BUF_OFFSET;
    2102:	1b60      	subs	r0, r4, r5
    2104:	e733      	b.n	1f6e <cbvprintf_package+0x26e>
		return -EFAULT;
    2106:	f06f 000d 	mvn.w	r0, #13
    210a:	e730      	b.n	1f6e <cbvprintf_package+0x26e>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
    210c:	2907      	cmp	r1, #7
    210e:	f63f ae0e 	bhi.w	1d2e <cbvprintf_package+0x2e>
    2112:	e72a      	b.n	1f6a <cbvprintf_package+0x26a>

00002114 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

uint8_t crc8_ccitt(uint8_t val, const void *buf, size_t cnt)
{
    2114:	b530      	push	{r4, r5, lr}
	size_t i;
	const uint8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    2116:	4c0a      	ldr	r4, [pc, #40]	; (2140 <crc8_ccitt+0x2c>)
    2118:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
    211a:	4291      	cmp	r1, r2
    211c:	d100      	bne.n	2120 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
    211e:	bd30      	pop	{r4, r5, pc}
		val ^= p[i];
    2120:	f811 3b01 	ldrb.w	r3, [r1], #1
    2124:	4058      	eors	r0, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    2126:	0903      	lsrs	r3, r0, #4
    2128:	5ce3      	ldrb	r3, [r4, r3]
    212a:	ea83 1300 	eor.w	r3, r3, r0, lsl #4
    212e:	b2dd      	uxtb	r5, r3
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
    2130:	f3c3 1303 	ubfx	r3, r3, #4, #4
    2134:	5ce0      	ldrb	r0, [r4, r3]
    2136:	ea80 1005 	eor.w	r0, r0, r5, lsl #4
    213a:	b2c0      	uxtb	r0, r0
	for (i = 0; i < cnt; i++) {
    213c:	e7ed      	b.n	211a <crc8_ccitt+0x6>
    213e:	bf00      	nop
    2140:	0002ec28 	.word	0x0002ec28

00002144 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    2144:	680b      	ldr	r3, [r1, #0]
    2146:	3301      	adds	r3, #1
    2148:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    214a:	4b01      	ldr	r3, [pc, #4]	; (2150 <char_out+0xc>)
    214c:	681b      	ldr	r3, [r3, #0]
    214e:	4718      	bx	r3
    2150:	20000324 	.word	0x20000324

00002154 <__printk_hook_install>:
	_char_out = fn;
    2154:	4b01      	ldr	r3, [pc, #4]	; (215c <__printk_hook_install+0x8>)
    2156:	6018      	str	r0, [r3, #0]
}
    2158:	4770      	bx	lr
    215a:	bf00      	nop
    215c:	20000324 	.word	0x20000324

00002160 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
    2160:	b507      	push	{r0, r1, r2, lr}
    2162:	460b      	mov	r3, r1

		if (ctx.buf_count) {
			buf_flush(&ctx);
		}
	} else {
		struct out_context ctx = { 0 };
    2164:	2100      	movs	r1, #0
{
    2166:	4602      	mov	r2, r0
		struct out_context ctx = { 0 };
    2168:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
    216a:	4803      	ldr	r0, [pc, #12]	; (2178 <vprintk+0x18>)
    216c:	a901      	add	r1, sp, #4
    216e:	f000 f8f9 	bl	2364 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
    2172:	b003      	add	sp, #12
    2174:	f85d fb04 	ldr.w	pc, [sp], #4
    2178:	00002145 	.word	0x00002145

0000217c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    217c:	b530      	push	{r4, r5, lr}
    217e:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    2180:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    2184:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    2186:	2500      	movs	r5, #0

	cbvprintf(str_out, &ctx, fmt, ap);
    2188:	a901      	add	r1, sp, #4
    218a:	4805      	ldr	r0, [pc, #20]	; (21a0 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    218c:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
    218e:	f000 f8e9 	bl	2364 <cbvprintf>

	if (ctx.count < ctx.max) {
    2192:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    2196:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    2198:	bfb8      	it	lt
    219a:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    219c:	b005      	add	sp, #20
    219e:	bd30      	pop	{r4, r5, pc}
    21a0:	00025197 	.word	0x00025197

000021a4 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
    21a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    21a8:	f8b0 9018 	ldrh.w	r9, [r0, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
    21ac:	f019 0808 	ands.w	r8, r9, #8
{
    21b0:	4604      	mov	r4, r0
    21b2:	4693      	mov	fp, r2
	if (processing) {
    21b4:	d00d      	beq.n	21d2 <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
    21b6:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
    21b8:	bf0c      	ite	eq
    21ba:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
    21be:	f049 0920 	orrne.w	r9, r9, #32
    21c2:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    21c6:	f38b 8811 	msr	BASEPRI, fp
    21ca:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
    21ce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    21d2:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
    21d6:	2902      	cmp	r1, #2
    21d8:	d107      	bne.n	21ea <process_event+0x46>
			evt = process_recheck(mgr);
    21da:	4620      	mov	r0, r4
    21dc:	f023 f808 	bl	251f0 <process_recheck>
		if (evt == EVT_NOP) {
    21e0:	2800      	cmp	r0, #0
    21e2:	d0f0      	beq.n	21c6 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
    21e4:	2801      	cmp	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    21e6:	8b23      	ldrh	r3, [r4, #24]
		if (evt == EVT_COMPLETE) {
    21e8:	d14e      	bne.n	2288 <process_event+0xe4>
			res = mgr->last_res;
    21ea:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    21ec:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
    21ee:	2f00      	cmp	r7, #0
    21f0:	da15      	bge.n	221e <process_event+0x7a>
		*clients = mgr->clients;
    21f2:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    21f4:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    21f8:	e9c4 8800 	strd	r8, r8, [r4]
    21fc:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
    2200:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
    2202:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
    2204:	8b21      	ldrh	r1, [r4, #24]
    2206:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
    220a:	45ca      	cmp	sl, r9
    220c:	d002      	beq.n	2214 <process_event+0x70>
		if (do_monitors
    220e:	68a3      	ldr	r3, [r4, #8]
    2210:	2b00      	cmp	r3, #0
    2212:	d15a      	bne.n	22ca <process_event+0x126>
		    || !sys_slist_is_empty(&clients)
    2214:	b90d      	cbnz	r5, 221a <process_event+0x76>
		    || (transit != NULL)) {
    2216:	2e00      	cmp	r6, #0
    2218:	d071      	beq.n	22fe <process_event+0x15a>
    221a:	2300      	movs	r3, #0
    221c:	e056      	b.n	22cc <process_event+0x128>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    221e:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    2222:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    2224:	2a01      	cmp	r2, #1
    2226:	d81e      	bhi.n	2266 <process_event+0xc2>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    2228:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
    222c:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
    222e:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    2230:	b289      	uxth	r1, r1
    2232:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
    2236:	d10a      	bne.n	224e <process_event+0xaa>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    2238:	b13d      	cbz	r5, 224a <process_event+0xa6>
    223a:	8b63      	ldrh	r3, [r4, #26]
    223c:	462a      	mov	r2, r5

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
    223e:	6812      	ldr	r2, [r2, #0]
				mgr->refs += 1U;
    2240:	3301      	adds	r3, #1
    2242:	b29b      	uxth	r3, r3
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    2244:	2a00      	cmp	r2, #0
    2246:	d1fa      	bne.n	223e <process_event+0x9a>
    2248:	8363      	strh	r3, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    224a:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
    224e:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    2250:	4620      	mov	r0, r4
    2252:	f022 ffcd 	bl	251f0 <process_recheck>
    2256:	4606      	mov	r6, r0
    2258:	2800      	cmp	r0, #0
    225a:	d0d3      	beq.n	2204 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    225c:	8b23      	ldrh	r3, [r4, #24]
    225e:	f043 0320 	orr.w	r3, r3, #32
    2262:	8323      	strh	r3, [r4, #24]
    2264:	e7cd      	b.n	2202 <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
    2266:	2b04      	cmp	r3, #4
    2268:	d10c      	bne.n	2284 <process_event+0xe0>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    226a:	f021 0107 	bic.w	r1, r1, #7
    226e:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
    2270:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    2272:	4620      	mov	r0, r4
    2274:	f022 ffbc 	bl	251f0 <process_recheck>
    2278:	4605      	mov	r5, r0
    227a:	2800      	cmp	r0, #0
    227c:	d0c1      	beq.n	2202 <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    227e:	f041 0120 	orr.w	r1, r1, #32
    2282:	8321      	strh	r1, [r4, #24]
    2284:	2500      	movs	r5, #0
    2286:	e7bc      	b.n	2202 <process_event+0x5e>
		} else if (evt == EVT_START) {
    2288:	2803      	cmp	r0, #3
    228a:	d109      	bne.n	22a0 <process_event+0xfc>
			transit = mgr->transitions->start;
    228c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    228e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
    2292:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    2294:	f043 0306 	orr.w	r3, r3, #6
	mgr->flags = (state & ONOFF_STATE_MASK)
    2298:	8323      	strh	r3, [r4, #24]
}
    229a:	2500      	movs	r5, #0
		res = 0;
    229c:	462f      	mov	r7, r5
    229e:	e7b1      	b.n	2204 <process_event+0x60>
		} else if (evt == EVT_STOP) {
    22a0:	2804      	cmp	r0, #4
    22a2:	d106      	bne.n	22b2 <process_event+0x10e>
			transit = mgr->transitions->stop;
    22a4:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    22a6:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
    22aa:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    22ac:	f043 0304 	orr.w	r3, r3, #4
    22b0:	e7f2      	b.n	2298 <process_event+0xf4>
		} else if (evt == EVT_RESET) {
    22b2:	2805      	cmp	r0, #5
    22b4:	d106      	bne.n	22c4 <process_event+0x120>
			transit = mgr->transitions->reset;
    22b6:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    22b8:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
    22bc:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    22be:	f043 0305 	orr.w	r3, r3, #5
    22c2:	e7e9      	b.n	2298 <process_event+0xf4>
    22c4:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
    22c6:	462e      	mov	r6, r5
    22c8:	e7e8      	b.n	229c <process_event+0xf8>
				   && !sys_slist_is_empty(&mgr->monitors);
    22ca:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
    22cc:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
    22d0:	8321      	strh	r1, [r4, #24]
    22d2:	f38b 8811 	msr	BASEPRI, fp
    22d6:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
    22da:	b9fb      	cbnz	r3, 231c <process_event+0x178>
	while (!sys_slist_is_empty(list)) {
    22dc:	bb85      	cbnz	r5, 2340 <process_event+0x19c>
			if (transit != NULL) {
    22de:	b116      	cbz	r6, 22e6 <process_event+0x142>
				transit(mgr, transition_complete);
    22e0:	491f      	ldr	r1, [pc, #124]	; (2360 <process_event+0x1bc>)
    22e2:	4620      	mov	r0, r4
    22e4:	47b0      	blx	r6
	__asm__ volatile(
    22e6:	f04f 0320 	mov.w	r3, #32
    22ea:	f3ef 8b11 	mrs	fp, BASEPRI
    22ee:	f383 8812 	msr	BASEPRI_MAX, r3
    22f2:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
    22f6:	8b23      	ldrh	r3, [r4, #24]
    22f8:	f023 0308 	bic.w	r3, r3, #8
    22fc:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
    22fe:	8b23      	ldrh	r3, [r4, #24]
    2300:	06da      	lsls	r2, r3, #27
    2302:	d525      	bpl.n	2350 <process_event+0x1ac>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
    2304:	f023 0310 	bic.w	r3, r3, #16
    2308:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
    230a:	2101      	movs	r1, #1
		state = mgr->flags & ONOFF_STATE_MASK;
    230c:	f8b4 9018 	ldrh.w	r9, [r4, #24]
    2310:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
    2314:	2900      	cmp	r1, #0
    2316:	f47f af5e 	bne.w	21d6 <process_event+0x32>
out:
    231a:	e754      	b.n	21c6 <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    231c:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    231e:	2900      	cmp	r1, #0
    2320:	d0dc      	beq.n	22dc <process_event+0x138>
	return node->next;
    2322:	f8d1 9000 	ldr.w	r9, [r1]
		mon->callback(mgr, mon, state, res);
    2326:	f8d1 b004 	ldr.w	fp, [r1, #4]
    232a:	463b      	mov	r3, r7
    232c:	4652      	mov	r2, sl
    232e:	4620      	mov	r0, r4
    2330:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    2332:	f1b9 0f00 	cmp.w	r9, #0
    2336:	d0d1      	beq.n	22dc <process_event+0x138>
    2338:	4649      	mov	r1, r9
    233a:	f8d9 9000 	ldr.w	r9, [r9]
    233e:	e7f2      	b.n	2326 <process_event+0x182>
    2340:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
    2342:	463b      	mov	r3, r7
    2344:	4652      	mov	r2, sl
    2346:	4620      	mov	r0, r4
    2348:	682d      	ldr	r5, [r5, #0]
    234a:	f022 ff6d 	bl	25228 <notify_one>
    234e:	e7c5      	b.n	22dc <process_event+0x138>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
    2350:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    2354:	bf1e      	ittt	ne
    2356:	f023 0320 	bicne.w	r3, r3, #32
    235a:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
    235c:	2102      	movne	r1, #2
    235e:	e7d5      	b.n	230c <process_event+0x168>
    2360:	00025255 	.word	0x00025255

00002364 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    2364:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2368:	b091      	sub	sp, #68	; 0x44
    236a:	468b      	mov	fp, r1
    236c:	9002      	str	r0, [sp, #8]
    236e:	4692      	mov	sl, r2
    2370:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    2372:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    2374:	f89a 0000 	ldrb.w	r0, [sl]
    2378:	b908      	cbnz	r0, 237e <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
    237a:	4628      	mov	r0, r5
    237c:	e35f      	b.n	2a3e <cbvprintf+0x6da>
		if (*fp != '%') {
    237e:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
    2380:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
    2384:	d007      	beq.n	2396 <cbvprintf+0x32>
			OUTC('%');
    2386:	9b02      	ldr	r3, [sp, #8]
    2388:	4659      	mov	r1, fp
    238a:	4798      	blx	r3
    238c:	2800      	cmp	r0, #0
    238e:	f2c0 8356 	blt.w	2a3e <cbvprintf+0x6da>
    2392:	3501      	adds	r5, #1
			break;
    2394:	e212      	b.n	27bc <cbvprintf+0x458>
		} state = {
    2396:	2218      	movs	r2, #24
    2398:	2100      	movs	r1, #0
    239a:	a80a      	add	r0, sp, #40	; 0x28
    239c:	f025 fa73 	bl	27886 <memset>
	if (*sp == '%') {
    23a0:	f89a 3001 	ldrb.w	r3, [sl, #1]
    23a4:	2b25      	cmp	r3, #37	; 0x25
    23a6:	d078      	beq.n	249a <cbvprintf+0x136>
    23a8:	2200      	movs	r2, #0
    23aa:	4610      	mov	r0, r2
    23ac:	4696      	mov	lr, r2
    23ae:	4694      	mov	ip, r2
    23b0:	4616      	mov	r6, r2
    23b2:	4639      	mov	r1, r7
		switch (*sp) {
    23b4:	f817 3b01 	ldrb.w	r3, [r7], #1
    23b8:	2b2b      	cmp	r3, #43	; 0x2b
    23ba:	f000 809d 	beq.w	24f8 <cbvprintf+0x194>
    23be:	f200 8094 	bhi.w	24ea <cbvprintf+0x186>
    23c2:	2b20      	cmp	r3, #32
    23c4:	f000 809b 	beq.w	24fe <cbvprintf+0x19a>
    23c8:	2b23      	cmp	r3, #35	; 0x23
    23ca:	f000 809b 	beq.w	2504 <cbvprintf+0x1a0>
    23ce:	b12e      	cbz	r6, 23dc <cbvprintf+0x78>
    23d0:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    23d4:	f046 0604 	orr.w	r6, r6, #4
    23d8:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    23dc:	f1bc 0f00 	cmp.w	ip, #0
    23e0:	d005      	beq.n	23ee <cbvprintf+0x8a>
    23e2:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    23e6:	f046 0608 	orr.w	r6, r6, #8
    23ea:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    23ee:	f1be 0f00 	cmp.w	lr, #0
    23f2:	d005      	beq.n	2400 <cbvprintf+0x9c>
    23f4:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    23f8:	f046 0610 	orr.w	r6, r6, #16
    23fc:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    2400:	b128      	cbz	r0, 240e <cbvprintf+0xaa>
    2402:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    2406:	f040 0020 	orr.w	r0, r0, #32
    240a:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    240e:	b12a      	cbz	r2, 241c <cbvprintf+0xb8>
    2410:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    2414:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2418:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
    241c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    2420:	f002 0044 	and.w	r0, r2, #68	; 0x44
    2424:	2844      	cmp	r0, #68	; 0x44
    2426:	d103      	bne.n	2430 <cbvprintf+0xcc>
		conv->flag_zero = false;
    2428:	f36f 1286 	bfc	r2, #6, #1
    242c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
    2430:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    2434:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
    2436:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    243a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    243e:	d17b      	bne.n	2538 <cbvprintf+0x1d4>
		conv->width_star = true;
    2440:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    2444:	f042 0201 	orr.w	r2, r2, #1
			++sp;
    2448:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
    244a:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
    244e:	781a      	ldrb	r2, [r3, #0]
    2450:	2a2e      	cmp	r2, #46	; 0x2e
    2452:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    2456:	bf0c      	ite	eq
    2458:	2101      	moveq	r1, #1
    245a:	2100      	movne	r1, #0
    245c:	f361 0241 	bfi	r2, r1, #1, #1
    2460:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
    2464:	d174      	bne.n	2550 <cbvprintf+0x1ec>
	if (*sp == '*') {
    2466:	785a      	ldrb	r2, [r3, #1]
    2468:	2a2a      	cmp	r2, #42	; 0x2a
    246a:	d06a      	beq.n	2542 <cbvprintf+0x1de>
	++sp;
    246c:	3301      	adds	r3, #1
	size_t val = 0;
    246e:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
    2470:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    2472:	4618      	mov	r0, r3
    2474:	f810 2b01 	ldrb.w	r2, [r0], #1
    2478:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    247c:	2f09      	cmp	r7, #9
    247e:	f240 808e 	bls.w	259e <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
    2482:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
    2486:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
    2488:	f3c2 0040 	ubfx	r0, r2, #1, #1
    248c:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
    2490:	f361 0241 	bfi	r2, r1, #1, #1
    2494:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    2498:	e05a      	b.n	2550 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
    249a:	f10a 0702 	add.w	r7, sl, #2
    249e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
    24a2:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    24a6:	07d9      	lsls	r1, r3, #31
    24a8:	f140 8149 	bpl.w	273e <cbvprintf+0x3da>
			width = va_arg(ap, int);
    24ac:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
    24b0:	f1b9 0f00 	cmp.w	r9, #0
    24b4:	da07      	bge.n	24c6 <cbvprintf+0x162>
				conv->flag_dash = true;
    24b6:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    24ba:	f042 0204 	orr.w	r2, r2, #4
    24be:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				width = -width;
    24c2:	f1c9 0900 	rsb	r9, r9, #0
		if (conv->prec_star) {
    24c6:	075a      	lsls	r2, r3, #29
    24c8:	f140 8142 	bpl.w	2750 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
    24cc:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
    24d0:	f1b8 0f00 	cmp.w	r8, #0
    24d4:	f280 8141 	bge.w	275a <cbvprintf+0x3f6>
				conv->prec_present = false;
    24d8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    24dc:	f36f 0341 	bfc	r3, #1, #1
    24e0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
    24e4:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    24e8:	e137      	b.n	275a <cbvprintf+0x3f6>
		switch (*sp) {
    24ea:	2b2d      	cmp	r3, #45	; 0x2d
    24ec:	d00c      	beq.n	2508 <cbvprintf+0x1a4>
    24ee:	2b30      	cmp	r3, #48	; 0x30
    24f0:	f47f af6d 	bne.w	23ce <cbvprintf+0x6a>
			conv->flag_zero = true;
    24f4:	2201      	movs	r2, #1
	} while (loop);
    24f6:	e75c      	b.n	23b2 <cbvprintf+0x4e>
			conv->flag_plus = true;
    24f8:	f04f 0c01 	mov.w	ip, #1
    24fc:	e759      	b.n	23b2 <cbvprintf+0x4e>
			conv->flag_space = true;
    24fe:	f04f 0e01 	mov.w	lr, #1
    2502:	e756      	b.n	23b2 <cbvprintf+0x4e>
			conv->flag_hash = true;
    2504:	2001      	movs	r0, #1
    2506:	e754      	b.n	23b2 <cbvprintf+0x4e>
		switch (*sp) {
    2508:	2601      	movs	r6, #1
    250a:	e752      	b.n	23b2 <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
    250c:	fb0c 0202 	mla	r2, ip, r2, r0
    2510:	3a30      	subs	r2, #48	; 0x30
    2512:	4633      	mov	r3, r6
    2514:	461e      	mov	r6, r3
    2516:	f816 0b01 	ldrb.w	r0, [r6], #1
    251a:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    251e:	2f09      	cmp	r7, #9
    2520:	d9f4      	bls.n	250c <cbvprintf+0x1a8>
	if (sp != wp) {
    2522:	4299      	cmp	r1, r3
    2524:	d093      	beq.n	244e <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
    2526:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
    252a:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
    252c:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
    252e:	f362 0141 	bfi	r1, r2, #1, #1
    2532:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
    2536:	e78a      	b.n	244e <cbvprintf+0xea>
    2538:	460b      	mov	r3, r1
	size_t val = 0;
    253a:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
    253c:	f04f 0c0a 	mov.w	ip, #10
    2540:	e7e8      	b.n	2514 <cbvprintf+0x1b0>
		conv->prec_star = true;
    2542:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    2546:	f042 0204 	orr.w	r2, r2, #4
    254a:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
		return ++sp;
    254e:	3302      	adds	r3, #2
	switch (*sp) {
    2550:	461f      	mov	r7, r3
    2552:	f817 2b01 	ldrb.w	r2, [r7], #1
    2556:	2a6c      	cmp	r2, #108	; 0x6c
    2558:	d041      	beq.n	25de <cbvprintf+0x27a>
    255a:	d825      	bhi.n	25a8 <cbvprintf+0x244>
    255c:	2a68      	cmp	r2, #104	; 0x68
    255e:	d02b      	beq.n	25b8 <cbvprintf+0x254>
    2560:	2a6a      	cmp	r2, #106	; 0x6a
    2562:	d046      	beq.n	25f2 <cbvprintf+0x28e>
    2564:	2a4c      	cmp	r2, #76	; 0x4c
    2566:	d04c      	beq.n	2602 <cbvprintf+0x29e>
    2568:	461f      	mov	r7, r3
	conv->specifier = *sp++;
    256a:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    256e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	conv->specifier = *sp++;
    2572:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
    2576:	2a78      	cmp	r2, #120	; 0x78
    2578:	f200 80d9 	bhi.w	272e <cbvprintf+0x3ca>
    257c:	2a57      	cmp	r2, #87	; 0x57
    257e:	d84d      	bhi.n	261c <cbvprintf+0x2b8>
    2580:	2a41      	cmp	r2, #65	; 0x41
    2582:	d003      	beq.n	258c <cbvprintf+0x228>
    2584:	3a45      	subs	r2, #69	; 0x45
    2586:	2a02      	cmp	r2, #2
    2588:	f200 80d1 	bhi.w	272e <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
    258c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    2590:	2204      	movs	r2, #4
    2592:	f362 0302 	bfi	r3, r2, #0, #3
    2596:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
    259a:	2301      	movs	r3, #1
			break;
    259c:	e09e      	b.n	26dc <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
    259e:	fb06 2101 	mla	r1, r6, r1, r2
    25a2:	3930      	subs	r1, #48	; 0x30
    25a4:	4603      	mov	r3, r0
    25a6:	e764      	b.n	2472 <cbvprintf+0x10e>
	switch (*sp) {
    25a8:	2a74      	cmp	r2, #116	; 0x74
    25aa:	d026      	beq.n	25fa <cbvprintf+0x296>
    25ac:	2a7a      	cmp	r2, #122	; 0x7a
    25ae:	d1db      	bne.n	2568 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
    25b0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    25b4:	2206      	movs	r2, #6
    25b6:	e00d      	b.n	25d4 <cbvprintf+0x270>
		if (*++sp == 'h') {
    25b8:	785a      	ldrb	r2, [r3, #1]
    25ba:	2a68      	cmp	r2, #104	; 0x68
    25bc:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    25c0:	d106      	bne.n	25d0 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
    25c2:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
    25c4:	f361 02c6 	bfi	r2, r1, #3, #4
    25c8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
    25cc:	1c9f      	adds	r7, r3, #2
    25ce:	e7cc      	b.n	256a <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
    25d0:	4613      	mov	r3, r2
    25d2:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
    25d4:	f362 03c6 	bfi	r3, r2, #3, #4
    25d8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
    25dc:	e7c5      	b.n	256a <cbvprintf+0x206>
		if (*++sp == 'l') {
    25de:	785a      	ldrb	r2, [r3, #1]
    25e0:	2a6c      	cmp	r2, #108	; 0x6c
    25e2:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    25e6:	d101      	bne.n	25ec <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
    25e8:	2104      	movs	r1, #4
    25ea:	e7eb      	b.n	25c4 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
    25ec:	4613      	mov	r3, r2
    25ee:	2203      	movs	r2, #3
    25f0:	e7f0      	b.n	25d4 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
    25f2:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    25f6:	2205      	movs	r2, #5
    25f8:	e7ec      	b.n	25d4 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
    25fa:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    25fe:	2207      	movs	r2, #7
    2600:	e7e8      	b.n	25d4 <cbvprintf+0x270>
		conv->unsupported = true;
    2602:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    2606:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    260a:	f023 0302 	bic.w	r3, r3, #2
    260e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    2612:	f043 0302 	orr.w	r3, r3, #2
    2616:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
    261a:	e7a6      	b.n	256a <cbvprintf+0x206>
	switch (conv->specifier) {
    261c:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
    2620:	2920      	cmp	r1, #32
    2622:	f200 8084 	bhi.w	272e <cbvprintf+0x3ca>
    2626:	a001      	add	r0, pc, #4	; (adr r0, 262c <cbvprintf+0x2c8>)
    2628:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    262c:	000026f1 	.word	0x000026f1
    2630:	0000272f 	.word	0x0000272f
    2634:	0000272f 	.word	0x0000272f
    2638:	0000272f 	.word	0x0000272f
    263c:	0000272f 	.word	0x0000272f
    2640:	0000272f 	.word	0x0000272f
    2644:	0000272f 	.word	0x0000272f
    2648:	0000272f 	.word	0x0000272f
    264c:	0000272f 	.word	0x0000272f
    2650:	0000258d 	.word	0x0000258d
    2654:	0000272f 	.word	0x0000272f
    2658:	000026f1 	.word	0x000026f1
    265c:	000026b1 	.word	0x000026b1
    2660:	0000258d 	.word	0x0000258d
    2664:	0000258d 	.word	0x0000258d
    2668:	0000258d 	.word	0x0000258d
    266c:	0000272f 	.word	0x0000272f
    2670:	000026b1 	.word	0x000026b1
    2674:	0000272f 	.word	0x0000272f
    2678:	0000272f 	.word	0x0000272f
    267c:	0000272f 	.word	0x0000272f
    2680:	0000272f 	.word	0x0000272f
    2684:	000026f9 	.word	0x000026f9
    2688:	000026f1 	.word	0x000026f1
    268c:	00002715 	.word	0x00002715
    2690:	0000272f 	.word	0x0000272f
    2694:	0000272f 	.word	0x0000272f
    2698:	00002715 	.word	0x00002715
    269c:	0000272f 	.word	0x0000272f
    26a0:	000026f1 	.word	0x000026f1
    26a4:	0000272f 	.word	0x0000272f
    26a8:	0000272f 	.word	0x0000272f
    26ac:	000026f1 	.word	0x000026f1
		conv->specifier_cat = SPECIFIER_SINT;
    26b0:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    26b4:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    26b6:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    26ba:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    26be:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    26c0:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
    26c4:	bf02      	ittt	eq
    26c6:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
    26ca:	f041 0101 	orreq.w	r1, r1, #1
    26ce:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
    26d2:	2a63      	cmp	r2, #99	; 0x63
    26d4:	d131      	bne.n	273a <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
    26d6:	3b00      	subs	r3, #0
    26d8:	bf18      	it	ne
    26da:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    26dc:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    26e0:	f3c2 0140 	ubfx	r1, r2, #1, #1
    26e4:	430b      	orrs	r3, r1
    26e6:	f363 0241 	bfi	r2, r3, #1, #1
    26ea:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    26ee:	e6d8      	b.n	24a2 <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
    26f0:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    26f4:	2002      	movs	r0, #2
    26f6:	e7de      	b.n	26b6 <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
    26f8:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    26fc:	f003 0378 	and.w	r3, r3, #120	; 0x78
    2700:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    2704:	2103      	movs	r1, #3
    2706:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    270a:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    270c:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    2710:	4143      	adcs	r3, r0
    2712:	e7e3      	b.n	26dc <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
    2714:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    2718:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
    271a:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    271e:	f361 0202 	bfi	r2, r1, #0, #3
    2722:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    2726:	bf14      	ite	ne
    2728:	2301      	movne	r3, #1
    272a:	2300      	moveq	r3, #0
    272c:	e7d6      	b.n	26dc <cbvprintf+0x378>
		conv->invalid = true;
    272e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    2732:	f043 0301 	orr.w	r3, r3, #1
    2736:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
    273a:	2300      	movs	r3, #0
    273c:	e7ce      	b.n	26dc <cbvprintf+0x378>
		} else if (conv->width_present) {
    273e:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
    2742:	2a00      	cmp	r2, #0
			width = conv->width_value;
    2744:	bfb4      	ite	lt
    2746:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
    274a:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
    274e:	e6ba      	b.n	24c6 <cbvprintf+0x162>
		} else if (conv->prec_present) {
    2750:	079b      	lsls	r3, r3, #30
    2752:	f57f aec7 	bpl.w	24e4 <cbvprintf+0x180>
			precision = conv->prec_value;
    2756:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
			= (enum length_mod_enum)conv->length_mod;
    275a:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_value = 0;
    275e:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    2760:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
    2764:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
		enum specifier_cat_enum specifier_cat
    2768:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    276c:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    276e:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    2772:	d138      	bne.n	27e6 <cbvprintf+0x482>
			switch (length_mod) {
    2774:	1ecb      	subs	r3, r1, #3
    2776:	2b04      	cmp	r3, #4
    2778:	d822      	bhi.n	27c0 <cbvprintf+0x45c>
    277a:	e8df f003 	tbb	[pc, r3]
    277e:	0903      	.short	0x0903
    2780:	2109      	.short	0x2109
    2782:	21          	.byte	0x21
    2783:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    2784:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
    2788:	17da      	asrs	r2, r3, #31
    278a:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
    278e:	e006      	b.n	279e <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
    2790:	3407      	adds	r4, #7
    2792:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    2796:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    279a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
    279e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    27a2:	f013 0603 	ands.w	r6, r3, #3
    27a6:	d056      	beq.n	2856 <cbvprintf+0x4f2>
			OUTS(sp, fp);
    27a8:	9802      	ldr	r0, [sp, #8]
    27aa:	463b      	mov	r3, r7
    27ac:	4652      	mov	r2, sl
    27ae:	4659      	mov	r1, fp
    27b0:	f023 f830 	bl	25814 <outs>
    27b4:	2800      	cmp	r0, #0
    27b6:	f2c0 8142 	blt.w	2a3e <cbvprintf+0x6da>
    27ba:	4405      	add	r5, r0
			continue;
    27bc:	46ba      	mov	sl, r7
    27be:	e5d9      	b.n	2374 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    27c0:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    27c4:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    27c6:	ea4f 72e3 	mov.w	r2, r3, asr #31
    27ca:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    27ce:	d105      	bne.n	27dc <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
    27d0:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
    27d4:	930a      	str	r3, [sp, #40]	; 0x28
    27d6:	2300      	movs	r3, #0
    27d8:	930b      	str	r3, [sp, #44]	; 0x2c
    27da:	e7e0      	b.n	279e <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
    27dc:	2902      	cmp	r1, #2
    27de:	d1de      	bne.n	279e <cbvprintf+0x43a>
				value->sint = (short)value->sint;
    27e0:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    27e4:	e7d0      	b.n	2788 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
    27e6:	2b02      	cmp	r3, #2
    27e8:	d123      	bne.n	2832 <cbvprintf+0x4ce>
			switch (length_mod) {
    27ea:	1ecb      	subs	r3, r1, #3
    27ec:	2b04      	cmp	r3, #4
    27ee:	d813      	bhi.n	2818 <cbvprintf+0x4b4>
    27f0:	e8df f003 	tbb	[pc, r3]
    27f4:	120a0a03 	.word	0x120a0a03
    27f8:	12          	.byte	0x12
    27f9:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
    27fa:	6822      	ldr	r2, [r4, #0]
    27fc:	920a      	str	r2, [sp, #40]	; 0x28
    27fe:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
    2800:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
    2802:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
    2804:	4604      	mov	r4, r0
    2806:	e7ca      	b.n	279e <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
    2808:	1de0      	adds	r0, r4, #7
    280a:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
    280e:	e8f0 2302 	ldrd	r2, r3, [r0], #8
    2812:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
    2816:	e7f5      	b.n	2804 <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
    2818:	f854 3b04 	ldr.w	r3, [r4], #4
    281c:	930a      	str	r3, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    281e:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
    2820:	f04f 0300 	mov.w	r3, #0
    2824:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
    2826:	d0d3      	beq.n	27d0 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
    2828:	2902      	cmp	r1, #2
    282a:	d1b8      	bne.n	279e <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
    282c:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    2830:	e7d0      	b.n	27d4 <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
    2832:	2b04      	cmp	r3, #4
    2834:	d109      	bne.n	284a <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
    2836:	1de3      	adds	r3, r4, #7
    2838:	f023 0307 	bic.w	r3, r3, #7
    283c:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
    2840:	e9d3 2300 	ldrd	r2, r3, [r3]
    2844:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    2848:	e7a9      	b.n	279e <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
    284a:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    284c:	bf04      	itt	eq
    284e:	f854 3b04 	ldreq.w	r3, [r4], #4
    2852:	930a      	streq	r3, [sp, #40]	; 0x28
    2854:	e7a3      	b.n	279e <cbvprintf+0x43a>
		switch (conv->specifier) {
    2856:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    285a:	2878      	cmp	r0, #120	; 0x78
    285c:	d8ae      	bhi.n	27bc <cbvprintf+0x458>
    285e:	2862      	cmp	r0, #98	; 0x62
    2860:	d822      	bhi.n	28a8 <cbvprintf+0x544>
    2862:	2825      	cmp	r0, #37	; 0x25
    2864:	f43f ad8f 	beq.w	2386 <cbvprintf+0x22>
    2868:	2858      	cmp	r0, #88	; 0x58
    286a:	d1a7      	bne.n	27bc <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
    286c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    2870:	9300      	str	r3, [sp, #0]
    2872:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    2876:	ab04      	add	r3, sp, #16
    2878:	aa0c      	add	r2, sp, #48	; 0x30
    287a:	f022 ff85 	bl	25788 <encode_uint>
    287e:	4682      	mov	sl, r0
			if (precision >= 0) {
    2880:	f1b8 0f00 	cmp.w	r8, #0
    2884:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    2888:	db0c      	blt.n	28a4 <cbvprintf+0x540>
				conv->flag_zero = false;
    288a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
    288e:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
    2892:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    2896:	4598      	cmp	r8, r3
				conv->flag_zero = false;
    2898:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
    289c:	d902      	bls.n	28a4 <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
    289e:	eba8 0303 	sub.w	r3, r8, r3
    28a2:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
    28a4:	4680      	mov	r8, r0
    28a6:	e03d      	b.n	2924 <cbvprintf+0x5c0>
		switch (conv->specifier) {
    28a8:	3863      	subs	r0, #99	; 0x63
    28aa:	2815      	cmp	r0, #21
    28ac:	d886      	bhi.n	27bc <cbvprintf+0x458>
    28ae:	a201      	add	r2, pc, #4	; (adr r2, 28b4 <cbvprintf+0x550>)
    28b0:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
    28b4:	00002935 	.word	0x00002935
    28b8:	00002999 	.word	0x00002999
    28bc:	000027bd 	.word	0x000027bd
    28c0:	000027bd 	.word	0x000027bd
    28c4:	000027bd 	.word	0x000027bd
    28c8:	000027bd 	.word	0x000027bd
    28cc:	00002999 	.word	0x00002999
    28d0:	000027bd 	.word	0x000027bd
    28d4:	000027bd 	.word	0x000027bd
    28d8:	000027bd 	.word	0x000027bd
    28dc:	000027bd 	.word	0x000027bd
    28e0:	000029f3 	.word	0x000029f3
    28e4:	000029c1 	.word	0x000029c1
    28e8:	000029c5 	.word	0x000029c5
    28ec:	000027bd 	.word	0x000027bd
    28f0:	000027bd 	.word	0x000027bd
    28f4:	0000290d 	.word	0x0000290d
    28f8:	000027bd 	.word	0x000027bd
    28fc:	000029c1 	.word	0x000029c1
    2900:	000027bd 	.word	0x000027bd
    2904:	000027bd 	.word	0x000027bd
    2908:	000029c1 	.word	0x000029c1
			if (precision >= 0) {
    290c:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
    2910:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
    2914:	db0a      	blt.n	292c <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
    2916:	4641      	mov	r1, r8
    2918:	4650      	mov	r0, sl
    291a:	f024 ff72 	bl	27802 <strnlen>
			bpe = bps + len;
    291e:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
    2922:	2600      	movs	r6, #0
		if (bps == NULL) {
    2924:	f1ba 0f00 	cmp.w	sl, #0
    2928:	d10c      	bne.n	2944 <cbvprintf+0x5e0>
    292a:	e747      	b.n	27bc <cbvprintf+0x458>
				len = strlen(bps);
    292c:	4650      	mov	r0, sl
    292e:	f024 ff61 	bl	277f4 <strlen>
    2932:	e7f4      	b.n	291e <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    2934:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2936:	f88d 3010 	strb.w	r3, [sp, #16]
			break;
    293a:	2600      	movs	r6, #0
			bps = buf;
    293c:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
    2940:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
    2944:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
    2948:	b106      	cbz	r6, 294c <cbvprintf+0x5e8>
			nj_len += 1U;
    294a:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    294c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    2950:	06d0      	lsls	r0, r2, #27
    2952:	d568      	bpl.n	2a26 <cbvprintf+0x6c2>
			nj_len += 2U;
    2954:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    2956:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    2958:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
    295a:	bf48      	it	mi
    295c:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
    295e:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    2960:	bf48      	it	mi
    2962:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    2964:	f1b9 0f00 	cmp.w	r9, #0
    2968:	dd76      	ble.n	2a58 <cbvprintf+0x6f4>
			if (!conv->flag_dash) {
    296a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
    296e:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
    2972:	f3c2 0380 	ubfx	r3, r2, #2, #1
    2976:	9303      	str	r3, [sp, #12]
    2978:	0753      	lsls	r3, r2, #29
    297a:	d46d      	bmi.n	2a58 <cbvprintf+0x6f4>
				if (conv->flag_zero) {
    297c:	0650      	lsls	r0, r2, #25
    297e:	d561      	bpl.n	2a44 <cbvprintf+0x6e0>
					if (sign != 0) {
    2980:	b146      	cbz	r6, 2994 <cbvprintf+0x630>
						OUTC(sign);
    2982:	9b02      	ldr	r3, [sp, #8]
    2984:	4659      	mov	r1, fp
    2986:	4630      	mov	r0, r6
    2988:	4798      	blx	r3
    298a:	2800      	cmp	r0, #0
    298c:	db57      	blt.n	2a3e <cbvprintf+0x6da>
						sign = 0;
    298e:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    2990:	3501      	adds	r5, #1
						sign = 0;
    2992:	461e      	mov	r6, r3
					pad = '0';
    2994:	2330      	movs	r3, #48	; 0x30
    2996:	e056      	b.n	2a46 <cbvprintf+0x6e2>
			if (conv->flag_plus) {
    2998:	071e      	lsls	r6, r3, #28
    299a:	d40f      	bmi.n	29bc <cbvprintf+0x658>
				sign = ' ';
    299c:	f013 0610 	ands.w	r6, r3, #16
    29a0:	bf18      	it	ne
    29a2:	2620      	movne	r6, #32
			sint = value->sint;
    29a4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
    29a8:	2b00      	cmp	r3, #0
    29aa:	f6bf af5f 	bge.w	286c <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
    29ae:	4252      	negs	r2, r2
    29b0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    29b4:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				sign = '-';
    29b8:	262d      	movs	r6, #45	; 0x2d
    29ba:	e757      	b.n	286c <cbvprintf+0x508>
				sign = '+';
    29bc:	262b      	movs	r6, #43	; 0x2b
    29be:	e7f1      	b.n	29a4 <cbvprintf+0x640>
		switch (conv->specifier) {
    29c0:	2600      	movs	r6, #0
    29c2:	e753      	b.n	286c <cbvprintf+0x508>
			if (value->ptr != NULL) {
    29c4:	980a      	ldr	r0, [sp, #40]	; 0x28
    29c6:	b340      	cbz	r0, 2a1a <cbvprintf+0x6b6>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    29c8:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    29cc:	9300      	str	r3, [sp, #0]
    29ce:	aa0c      	add	r2, sp, #48	; 0x30
    29d0:	ab04      	add	r3, sp, #16
    29d2:	2100      	movs	r1, #0
    29d4:	f022 fed8 	bl	25788 <encode_uint>
				conv->altform_0c = true;
    29d8:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    29dc:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    29e0:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    29e4:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
    29e8:	4682      	mov	sl, r0
				conv->altform_0c = true;
    29ea:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
		char sign = 0;
    29ee:	2600      	movs	r6, #0
				goto prec_int_pad0;
    29f0:	e746      	b.n	2880 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
    29f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
    29f4:	2907      	cmp	r1, #7
    29f6:	f63f aee1 	bhi.w	27bc <cbvprintf+0x458>
    29fa:	e8df f001 	tbb	[pc, r1]
    29fe:	040c      	.short	0x040c
    2a00:	08080c06 	.word	0x08080c06
    2a04:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
    2a06:	701d      	strb	r5, [r3, #0]
		break;
    2a08:	e6d8      	b.n	27bc <cbvprintf+0x458>
		*(short *)dp = (short)count;
    2a0a:	801d      	strh	r5, [r3, #0]
		break;
    2a0c:	e6d6      	b.n	27bc <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
    2a0e:	17ea      	asrs	r2, r5, #31
    2a10:	e9c3 5200 	strd	r5, r2, [r3]
		break;
    2a14:	e6d2      	b.n	27bc <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    2a16:	601d      	str	r5, [r3, #0]
		break;
    2a18:	e6d0      	b.n	27bc <cbvprintf+0x458>
			bps = "(nil)";
    2a1a:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 2ae4 <cbvprintf+0x780>
    2a1e:	4606      	mov	r6, r0
			bpe = bps + 5;
    2a20:	f10a 0805 	add.w	r8, sl, #5
    2a24:	e78e      	b.n	2944 <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
    2a26:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    2a28:	bf48      	it	mi
    2a2a:	3301      	addmi	r3, #1
    2a2c:	e793      	b.n	2956 <cbvprintf+0x5f2>
					OUTC(pad);
    2a2e:	4618      	mov	r0, r3
    2a30:	9303      	str	r3, [sp, #12]
    2a32:	4659      	mov	r1, fp
    2a34:	9b02      	ldr	r3, [sp, #8]
    2a36:	4798      	blx	r3
    2a38:	2800      	cmp	r0, #0
    2a3a:	9b03      	ldr	r3, [sp, #12]
    2a3c:	da04      	bge.n	2a48 <cbvprintf+0x6e4>
#undef OUTS
#undef OUTC
}
    2a3e:	b011      	add	sp, #68	; 0x44
    2a40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    2a44:	2320      	movs	r3, #32
    2a46:	444d      	add	r5, r9
    2a48:	464a      	mov	r2, r9
				while (width-- > 0) {
    2a4a:	2a00      	cmp	r2, #0
    2a4c:	eba5 0109 	sub.w	r1, r5, r9
    2a50:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    2a54:	dceb      	bgt.n	2a2e <cbvprintf+0x6ca>
    2a56:	460d      	mov	r5, r1
		if (sign != 0) {
    2a58:	b136      	cbz	r6, 2a68 <cbvprintf+0x704>
			OUTC(sign);
    2a5a:	9b02      	ldr	r3, [sp, #8]
    2a5c:	4659      	mov	r1, fp
    2a5e:	4630      	mov	r0, r6
    2a60:	4798      	blx	r3
    2a62:	2800      	cmp	r0, #0
    2a64:	dbeb      	blt.n	2a3e <cbvprintf+0x6da>
    2a66:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    2a68:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    2a6c:	06d9      	lsls	r1, r3, #27
    2a6e:	d401      	bmi.n	2a74 <cbvprintf+0x710>
    2a70:	071a      	lsls	r2, r3, #28
    2a72:	d506      	bpl.n	2a82 <cbvprintf+0x71e>
				OUTC('0');
    2a74:	9b02      	ldr	r3, [sp, #8]
    2a76:	4659      	mov	r1, fp
    2a78:	2030      	movs	r0, #48	; 0x30
    2a7a:	4798      	blx	r3
    2a7c:	2800      	cmp	r0, #0
    2a7e:	dbde      	blt.n	2a3e <cbvprintf+0x6da>
    2a80:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    2a82:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    2a86:	06db      	lsls	r3, r3, #27
    2a88:	d507      	bpl.n	2a9a <cbvprintf+0x736>
				OUTC(conv->specifier);
    2a8a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    2a8e:	9b02      	ldr	r3, [sp, #8]
    2a90:	4659      	mov	r1, fp
    2a92:	4798      	blx	r3
    2a94:	2800      	cmp	r0, #0
    2a96:	dbd2      	blt.n	2a3e <cbvprintf+0x6da>
    2a98:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    2a9a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    2a9c:	442e      	add	r6, r5
    2a9e:	1b73      	subs	r3, r6, r5
    2aa0:	2b00      	cmp	r3, #0
    2aa2:	dc16      	bgt.n	2ad2 <cbvprintf+0x76e>
			OUTS(bps, bpe);
    2aa4:	9802      	ldr	r0, [sp, #8]
    2aa6:	4643      	mov	r3, r8
    2aa8:	4652      	mov	r2, sl
    2aaa:	4659      	mov	r1, fp
    2aac:	f022 feb2 	bl	25814 <outs>
    2ab0:	2800      	cmp	r0, #0
    2ab2:	dbc4      	blt.n	2a3e <cbvprintf+0x6da>
    2ab4:	4405      	add	r5, r0
		while (width > 0) {
    2ab6:	44a9      	add	r9, r5
    2ab8:	eba9 0305 	sub.w	r3, r9, r5
    2abc:	2b00      	cmp	r3, #0
    2abe:	f77f ae7d 	ble.w	27bc <cbvprintf+0x458>
			OUTC(' ');
    2ac2:	9b02      	ldr	r3, [sp, #8]
    2ac4:	4659      	mov	r1, fp
    2ac6:	2020      	movs	r0, #32
    2ac8:	4798      	blx	r3
    2aca:	2800      	cmp	r0, #0
    2acc:	dbb7      	blt.n	2a3e <cbvprintf+0x6da>
    2ace:	3501      	adds	r5, #1
			--width;
    2ad0:	e7f2      	b.n	2ab8 <cbvprintf+0x754>
				OUTC('0');
    2ad2:	9b02      	ldr	r3, [sp, #8]
    2ad4:	4659      	mov	r1, fp
    2ad6:	2030      	movs	r0, #48	; 0x30
    2ad8:	4798      	blx	r3
    2ada:	2800      	cmp	r0, #0
    2adc:	dbaf      	blt.n	2a3e <cbvprintf+0x6da>
    2ade:	3501      	adds	r5, #1
    2ae0:	e7dd      	b.n	2a9e <cbvprintf+0x73a>
    2ae2:	bf00      	nop
    2ae4:	0002ec38 	.word	0x0002ec38

00002ae8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    2ae8:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    2aea:	4910      	ldr	r1, [pc, #64]	; (2b2c <enable_logger+0x44>)
    2aec:	4810      	ldr	r0, [pc, #64]	; (2b30 <enable_logger+0x48>)
{
    2aee:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
    2af0:	2200      	movs	r2, #0
    2af2:	f02a fb5e 	bl	2d1b2 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    2af6:	4d0f      	ldr	r5, [pc, #60]	; (2b34 <enable_logger+0x4c>)
    2af8:	490f      	ldr	r1, [pc, #60]	; (2b38 <enable_logger+0x50>)
    2afa:	2200      	movs	r2, #0
    2afc:	2300      	movs	r3, #0
    2afe:	e9cd 2306 	strd	r2, r3, [sp, #24]
    2b02:	2400      	movs	r4, #0
    2b04:	230e      	movs	r3, #14
    2b06:	e9cd 3403 	strd	r3, r4, [sp, #12]
    2b0a:	e9cd 4401 	strd	r4, r4, [sp, #4]
    2b0e:	4b0b      	ldr	r3, [pc, #44]	; (2b3c <enable_logger+0x54>)
    2b10:	9400      	str	r4, [sp, #0]
    2b12:	f44f 7240 	mov.w	r2, #768	; 0x300
    2b16:	4628      	mov	r0, r5
    2b18:	f021 f88a 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    2b1c:	4908      	ldr	r1, [pc, #32]	; (2b40 <enable_logger+0x58>)
    2b1e:	4628      	mov	r0, r5
    2b20:	f029 ffa3 	bl	2ca6a <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    2b24:	4620      	mov	r0, r4
    2b26:	b009      	add	sp, #36	; 0x24
    2b28:	bd30      	pop	{r4, r5, pc}
    2b2a:	bf00      	nop
    2b2c:	00002b45 	.word	0x00002b45
    2b30:	20001528 	.word	0x20001528
    2b34:	20001560 	.word	0x20001560
    2b38:	20003f80 	.word	0x20003f80
    2b3c:	00002d5d 	.word	0x00002d5d
    2b40:	0002ec3e 	.word	0x0002ec3e

00002b44 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    2b44:	4801      	ldr	r0, [pc, #4]	; (2b4c <log_process_thread_timer_expiry_fn+0x8>)
    2b46:	f021 ba05 	b.w	23f54 <z_impl_k_sem_give>
    2b4a:	bf00      	nop
    2b4c:	20000f14 	.word	0x20000f14

00002b50 <log_init>:
{
    2b50:	b570      	push	{r4, r5, r6, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    2b52:	4b12      	ldr	r3, [pc, #72]	; (2b9c <log_init+0x4c>)
    2b54:	f3bf 8f5b 	dmb	ish
    2b58:	e853 5f00 	ldrex	r5, [r3]
    2b5c:	1c6a      	adds	r2, r5, #1
    2b5e:	e843 2100 	strex	r1, r2, [r3]
    2b62:	2900      	cmp	r1, #0
    2b64:	d1f8      	bne.n	2b58 <log_init+0x8>
    2b66:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    2b6a:	b92d      	cbnz	r5, 2b78 <log_init+0x28>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    2b6c:	4c0c      	ldr	r4, [pc, #48]	; (2ba0 <log_init+0x50>)
    2b6e:	4e0d      	ldr	r6, [pc, #52]	; (2ba4 <log_init+0x54>)
    2b70:	1b36      	subs	r6, r6, r4
    2b72:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    2b74:	42b5      	cmp	r5, r6
    2b76:	db00      	blt.n	2b7a <log_init+0x2a>
}
    2b78:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    2b7a:	7b23      	ldrb	r3, [r4, #12]
    2b7c:	b153      	cbz	r3, 2b94 <log_init+0x44>
			if (backend->api->init != NULL) {
    2b7e:	6823      	ldr	r3, [r4, #0]
    2b80:	699b      	ldr	r3, [r3, #24]
    2b82:	b10b      	cbz	r3, 2b88 <log_init+0x38>
				backend->api->init(backend);
    2b84:	4620      	mov	r0, r4
    2b86:	4798      	blx	r3
			log_backend_enable(backend,
    2b88:	6863      	ldr	r3, [r4, #4]
    2b8a:	2204      	movs	r2, #4
    2b8c:	6819      	ldr	r1, [r3, #0]
    2b8e:	4620      	mov	r0, r4
    2b90:	f000 f992 	bl	2eb8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    2b94:	3501      	adds	r5, #1
    2b96:	3410      	adds	r4, #16
    2b98:	e7ec      	b.n	2b74 <log_init+0x24>
    2b9a:	bf00      	nop
    2b9c:	200024d0 	.word	0x200024d0
    2ba0:	0002dc2c 	.word	0x0002dc2c
    2ba4:	0002dc4c 	.word	0x0002dc4c

00002ba8 <z_log_notify_backend_enabled>:
{
    2ba8:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    2baa:	4c04      	ldr	r4, [pc, #16]	; (2bbc <z_log_notify_backend_enabled+0x14>)
    2bac:	7823      	ldrb	r3, [r4, #0]
    2bae:	b913      	cbnz	r3, 2bb6 <z_log_notify_backend_enabled+0xe>
    2bb0:	4803      	ldr	r0, [pc, #12]	; (2bc0 <z_log_notify_backend_enabled+0x18>)
    2bb2:	f021 f9cf 	bl	23f54 <z_impl_k_sem_give>
	backend_attached = true;
    2bb6:	2301      	movs	r3, #1
    2bb8:	7023      	strb	r3, [r4, #0]
}
    2bba:	bd10      	pop	{r4, pc}
    2bbc:	2000396d 	.word	0x2000396d
    2bc0:	20000f14 	.word	0x20000f14

00002bc4 <z_log_dropped>:
    2bc4:	4b0c      	ldr	r3, [pc, #48]	; (2bf8 <z_log_dropped+0x34>)
    2bc6:	f3bf 8f5b 	dmb	ish
    2bca:	e853 2f00 	ldrex	r2, [r3]
    2bce:	3201      	adds	r2, #1
    2bd0:	e843 2100 	strex	r1, r2, [r3]
    2bd4:	2900      	cmp	r1, #0
    2bd6:	d1f8      	bne.n	2bca <z_log_dropped+0x6>
    2bd8:	f3bf 8f5b 	dmb	ish
	if (buffered) {
    2bdc:	b158      	cbz	r0, 2bf6 <z_log_dropped+0x32>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2bde:	f3bf 8f5b 	dmb	ish
    2be2:	4b06      	ldr	r3, [pc, #24]	; (2bfc <z_log_dropped+0x38>)
    2be4:	e853 2f00 	ldrex	r2, [r3]
    2be8:	3a01      	subs	r2, #1
    2bea:	e843 2100 	strex	r1, r2, [r3]
    2bee:	2900      	cmp	r1, #0
    2bf0:	d1f8      	bne.n	2be4 <z_log_dropped+0x20>
    2bf2:	f3bf 8f5b 	dmb	ish
}
    2bf6:	4770      	bx	lr
    2bf8:	200024cc 	.word	0x200024cc
    2bfc:	200024c8 	.word	0x200024c8

00002c00 <z_log_dropped_read_and_clear>:
}
    2c00:	2000      	movs	r0, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2c02:	4b06      	ldr	r3, [pc, #24]	; (2c1c <z_log_dropped_read_and_clear+0x1c>)
    2c04:	f3bf 8f5b 	dmb	ish
    2c08:	4602      	mov	r2, r0
    2c0a:	e853 0f00 	ldrex	r0, [r3]
    2c0e:	e843 2100 	strex	r1, r2, [r3]
    2c12:	2900      	cmp	r1, #0
    2c14:	d1f9      	bne.n	2c0a <z_log_dropped_read_and_clear+0xa>
    2c16:	f3bf 8f5b 	dmb	ish
    2c1a:	4770      	bx	lr
    2c1c:	200024cc 	.word	0x200024cc

00002c20 <dropped_notify>:
{
    2c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
    2c22:	f7ff ffed 	bl	2c00 <z_log_dropped_read_and_clear>
    2c26:	4c0a      	ldr	r4, [pc, #40]	; (2c50 <dropped_notify+0x30>)
    2c28:	4d0a      	ldr	r5, [pc, #40]	; (2c54 <dropped_notify+0x34>)
    2c2a:	1b2d      	subs	r5, r5, r4
    2c2c:	4607      	mov	r7, r0
    2c2e:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    2c30:	2600      	movs	r6, #0
    2c32:	42ae      	cmp	r6, r5
    2c34:	db00      	blt.n	2c38 <dropped_notify+0x18>
}
    2c36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    2c38:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    2c3a:	795b      	ldrb	r3, [r3, #5]
    2c3c:	b12b      	cbz	r3, 2c4a <dropped_notify+0x2a>
	if (backend->api->dropped != NULL) {
    2c3e:	6823      	ldr	r3, [r4, #0]
    2c40:	691b      	ldr	r3, [r3, #16]
    2c42:	b113      	cbz	r3, 2c4a <dropped_notify+0x2a>
		backend->api->dropped(backend, cnt);
    2c44:	4639      	mov	r1, r7
    2c46:	4620      	mov	r0, r4
    2c48:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    2c4a:	3601      	adds	r6, #1
    2c4c:	3410      	adds	r4, #16
    2c4e:	e7f0      	b.n	2c32 <dropped_notify+0x12>
    2c50:	0002dc2c 	.word	0x0002dc2c
    2c54:	0002dc4c 	.word	0x0002dc4c

00002c58 <z_log_msg2_init>:
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
    2c58:	4901      	ldr	r1, [pc, #4]	; (2c60 <z_log_msg2_init+0x8>)
    2c5a:	4802      	ldr	r0, [pc, #8]	; (2c64 <z_log_msg2_init+0xc>)
    2c5c:	f022 be83 	b.w	25966 <mpsc_pbuf_init>
    2c60:	0002de5c 	.word	0x0002de5c
    2c64:	200024d4 	.word	0x200024d4

00002c68 <log_core_init>:
	panic_mode = false;
    2c68:	4a08      	ldr	r2, [pc, #32]	; (2c8c <log_core_init+0x24>)
{
    2c6a:	b508      	push	{r3, lr}
	panic_mode = false;
    2c6c:	2300      	movs	r3, #0
    2c6e:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
    2c70:	4a07      	ldr	r2, [pc, #28]	; (2c90 <log_core_init+0x28>)
    2c72:	6013      	str	r3, [r2, #0]
	timestamp_func = timestamp_getter;
    2c74:	4b07      	ldr	r3, [pc, #28]	; (2c94 <log_core_init+0x2c>)
    2c76:	4a08      	ldr	r2, [pc, #32]	; (2c98 <log_core_init+0x30>)
    2c78:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    2c7a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    2c7e:	f000 fafb 	bl	3278 <log_output_timestamp_freq_set>
}
    2c82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		z_log_msg2_init();
    2c86:	f7ff bfe7 	b.w	2c58 <z_log_msg2_init>
    2c8a:	bf00      	nop
    2c8c:	2000396e 	.word	0x2000396e
    2c90:	200024cc 	.word	0x200024cc
    2c94:	20000328 	.word	0x20000328
    2c98:	00025c05 	.word	0x00025c05

00002c9c <z_log_msg2_alloc>:
{
    2c9c:	4601      	mov	r1, r0
	return (struct log_msg2 *)mpsc_pbuf_alloc(&log_buffer, wlen,
    2c9e:	2200      	movs	r2, #0
    2ca0:	4801      	ldr	r0, [pc, #4]	; (2ca8 <z_log_msg2_alloc+0xc>)
    2ca2:	2300      	movs	r3, #0
    2ca4:	f022 be7e 	b.w	259a4 <mpsc_pbuf_alloc>
    2ca8:	200024d4 	.word	0x200024d4

00002cac <z_log_msg2_claim>:
	return (union log_msg2_generic *)mpsc_pbuf_claim(&log_buffer);
    2cac:	4801      	ldr	r0, [pc, #4]	; (2cb4 <z_log_msg2_claim+0x8>)
    2cae:	f022 bf0c 	b.w	25aca <mpsc_pbuf_claim>
    2cb2:	bf00      	nop
    2cb4:	200024d4 	.word	0x200024d4

00002cb8 <z_log_msg2_free>:
{
    2cb8:	4601      	mov	r1, r0
	mpsc_pbuf_free(&log_buffer, (union mpsc_pbuf_generic *)msg);
    2cba:	4801      	ldr	r0, [pc, #4]	; (2cc0 <z_log_msg2_free+0x8>)
    2cbc:	f022 bf51 	b.w	25b62 <mpsc_pbuf_free>
    2cc0:	200024d4 	.word	0x200024d4

00002cc4 <z_log_msg2_pending>:
	return mpsc_pbuf_is_pending(&log_buffer);
    2cc4:	4801      	ldr	r0, [pc, #4]	; (2ccc <z_log_msg2_pending+0x8>)
    2cc6:	f022 bf80 	b.w	25bca <mpsc_pbuf_is_pending>
    2cca:	bf00      	nop
    2ccc:	200024d4 	.word	0x200024d4

00002cd0 <z_impl_log_process>:
	if (!backend_attached && !bypass) {
    2cd0:	4b1d      	ldr	r3, [pc, #116]	; (2d48 <z_impl_log_process+0x78>)
    2cd2:	781b      	ldrb	r3, [r3, #0]
{
    2cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2cd8:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
    2cda:	b903      	cbnz	r3, 2cde <z_impl_log_process+0xe>
    2cdc:	b388      	cbz	r0, 2d42 <z_impl_log_process+0x72>
	msg = get_msg();
    2cde:	f022 ff98 	bl	25c12 <get_msg>
	if (msg.msg) {
    2ce2:	4606      	mov	r6, r0
    2ce4:	b118      	cbz	r0, 2cee <z_impl_log_process+0x1e>
		if (!bypass) {
    2ce6:	b16d      	cbz	r5, 2d04 <z_impl_log_process+0x34>
		z_log_msg2_free(msg.msg2);
    2ce8:	4630      	mov	r0, r6
    2cea:	f7ff ffe5 	bl	2cb8 <z_log_msg2_free>
	if (!bypass && z_log_dropped_pending()) {
    2cee:	b92d      	cbnz	r5, 2cfc <z_impl_log_process+0x2c>
	return dropped_cnt > 0;
    2cf0:	4b16      	ldr	r3, [pc, #88]	; (2d4c <z_impl_log_process+0x7c>)
	if (!bypass && z_log_dropped_pending()) {
    2cf2:	681b      	ldr	r3, [r3, #0]
    2cf4:	2b00      	cmp	r3, #0
    2cf6:	dd01      	ble.n	2cfc <z_impl_log_process+0x2c>
		dropped_notify();
    2cf8:	f7ff ff92 	bl	2c20 <dropped_notify>
}
    2cfc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_log_msg2_pending();
    2d00:	f7ff bfe0 	b.w	2cc4 <z_log_msg2_pending>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    2d04:	4b12      	ldr	r3, [pc, #72]	; (2d50 <z_impl_log_process+0x80>)
    2d06:	f3bf 8f5b 	dmb	ish
    2d0a:	e853 2f00 	ldrex	r2, [r3]
    2d0e:	3a01      	subs	r2, #1
    2d10:	e843 2100 	strex	r1, r2, [r3]
    2d14:	2900      	cmp	r1, #0
    2d16:	d1f8      	bne.n	2d0a <z_impl_log_process+0x3a>
    2d18:	f3bf 8f5b 	dmb	ish
	return __log_backends_end - __log_backends_start;
    2d1c:	4c0d      	ldr	r4, [pc, #52]	; (2d54 <z_impl_log_process+0x84>)
    2d1e:	4f0e      	ldr	r7, [pc, #56]	; (2d58 <z_impl_log_process+0x88>)
    2d20:	1b3f      	subs	r7, r7, r4
    2d22:	113f      	asrs	r7, r7, #4
    2d24:	46a8      	mov	r8, r5
		for (int i = 0; i < log_backend_count_get(); i++) {
    2d26:	45b8      	cmp	r8, r7
    2d28:	dade      	bge.n	2ce8 <z_impl_log_process+0x18>
	return backend->cb->active;
    2d2a:	6863      	ldr	r3, [r4, #4]
			if (log_backend_is_active(backend) &&
    2d2c:	795b      	ldrb	r3, [r3, #5]
    2d2e:	b123      	cbz	r3, 2d3a <z_impl_log_process+0x6a>
	backend->api->process(backend, msg);
    2d30:	6823      	ldr	r3, [r4, #0]
    2d32:	4631      	mov	r1, r6
    2d34:	681b      	ldr	r3, [r3, #0]
    2d36:	4620      	mov	r0, r4
    2d38:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    2d3a:	f108 0801 	add.w	r8, r8, #1
    2d3e:	3410      	adds	r4, #16
    2d40:	e7f1      	b.n	2d26 <z_impl_log_process+0x56>
}
    2d42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2d46:	bf00      	nop
    2d48:	2000396d 	.word	0x2000396d
    2d4c:	200024cc 	.word	0x200024cc
    2d50:	200024c8 	.word	0x200024c8
    2d54:	0002dc2c 	.word	0x0002dc2c
    2d58:	0002dc4c 	.word	0x0002dc4c

00002d5c <log_process_thread_func>:
{
    2d5c:	b510      	push	{r4, lr}
	log_init();
    2d5e:	f7ff fef7 	bl	2b50 <log_init>
	return z_impl_z_current_get();
    2d62:	f021 fdf5 	bl	24950 <z_impl_z_current_get>
	proc_tid = process_tid;
    2d66:	4b0c      	ldr	r3, [pc, #48]	; (2d98 <log_process_thread_func+0x3c>)
    2d68:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    2d6a:	b130      	cbz	r0, 2d7a <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    2d6c:	4b0b      	ldr	r3, [pc, #44]	; (2d9c <log_process_thread_func+0x40>)
	    process_tid &&
    2d6e:	681b      	ldr	r3, [r3, #0]
    2d70:	2b09      	cmp	r3, #9
    2d72:	dd02      	ble.n	2d7a <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
    2d74:	480a      	ldr	r0, [pc, #40]	; (2da0 <log_process_thread_func+0x44>)
    2d76:	f021 f8ed 	bl	23f54 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    2d7a:	4c09      	ldr	r4, [pc, #36]	; (2da0 <log_process_thread_func+0x44>)
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    2d7c:	2000      	movs	r0, #0
    2d7e:	f7ff ffa7 	bl	2cd0 <z_impl_log_process>
		if (log_process(false) == false) {
    2d82:	2800      	cmp	r0, #0
    2d84:	d1fa      	bne.n	2d7c <log_process_thread_func+0x20>
    2d86:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2d8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2d8e:	4620      	mov	r0, r4
    2d90:	f021 f906 	bl	23fa0 <z_impl_k_sem_take>
    2d94:	e7f2      	b.n	2d7c <log_process_thread_func+0x20>
    2d96:	bf00      	nop
    2d98:	20002510 	.word	0x20002510
    2d9c:	200024c8 	.word	0x200024c8
    2da0:	20000f14 	.word	0x20000f14

00002da4 <z_log_msg_post_finalize>:
{
    2da4:	b513      	push	{r0, r1, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    2da6:	4b1d      	ldr	r3, [pc, #116]	; (2e1c <z_log_msg_post_finalize+0x78>)
    2da8:	f3bf 8f5b 	dmb	ish
    2dac:	e853 2f00 	ldrex	r2, [r3]
    2db0:	1c51      	adds	r1, r2, #1
    2db2:	e843 1000 	strex	r0, r1, [r3]
    2db6:	2800      	cmp	r0, #0
    2db8:	d1f8      	bne.n	2dac <z_log_msg_post_finalize+0x8>
    2dba:	f3bf 8f5b 	dmb	ish
	if (panic_mode) {
    2dbe:	4b18      	ldr	r3, [pc, #96]	; (2e20 <z_log_msg_post_finalize+0x7c>)
    2dc0:	781b      	ldrb	r3, [r3, #0]
    2dc2:	b183      	cbz	r3, 2de6 <z_log_msg_post_finalize+0x42>
    2dc4:	f04f 0320 	mov.w	r3, #32
    2dc8:	f3ef 8411 	mrs	r4, BASEPRI
    2dcc:	f383 8812 	msr	BASEPRI_MAX, r3
    2dd0:	f3bf 8f6f 	isb	sy
    2dd4:	2000      	movs	r0, #0
    2dd6:	f7ff ff7b 	bl	2cd0 <z_impl_log_process>
	__asm__ volatile(
    2dda:	f384 8811 	msr	BASEPRI, r4
    2dde:	f3bf 8f6f 	isb	sy
}
    2de2:	b002      	add	sp, #8
    2de4:	bd10      	pop	{r4, pc}
	} else if (proc_tid != NULL && cnt == 0) {
    2de6:	4b0f      	ldr	r3, [pc, #60]	; (2e24 <z_log_msg_post_finalize+0x80>)
    2de8:	681b      	ldr	r3, [r3, #0]
    2dea:	2b00      	cmp	r3, #0
    2dec:	d0f9      	beq.n	2de2 <z_log_msg_post_finalize+0x3e>
    2dee:	b952      	cbnz	r2, 2e06 <z_log_msg_post_finalize+0x62>
	z_impl_k_timer_start(timer, duration, period);
    2df0:	2200      	movs	r2, #0
    2df2:	2300      	movs	r3, #0
    2df4:	e9cd 2300 	strd	r2, r3, [sp]
    2df8:	480b      	ldr	r0, [pc, #44]	; (2e28 <z_log_msg_post_finalize+0x84>)
    2dfa:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2dfe:	2300      	movs	r3, #0
    2e00:	f021 ffde 	bl	24dc0 <z_impl_k_timer_start>
    2e04:	e7ed      	b.n	2de2 <z_log_msg_post_finalize+0x3e>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    2e06:	2a0a      	cmp	r2, #10
    2e08:	d1eb      	bne.n	2de2 <z_log_msg_post_finalize+0x3e>
	z_impl_k_timer_stop(timer);
    2e0a:	4807      	ldr	r0, [pc, #28]	; (2e28 <z_log_msg_post_finalize+0x84>)
    2e0c:	f02a f9dd 	bl	2d1ca <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    2e10:	4806      	ldr	r0, [pc, #24]	; (2e2c <z_log_msg_post_finalize+0x88>)
}
    2e12:	b002      	add	sp, #8
    2e14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2e18:	f021 b89c 	b.w	23f54 <z_impl_k_sem_give>
    2e1c:	200024c8 	.word	0x200024c8
    2e20:	2000396e 	.word	0x2000396e
    2e24:	20002510 	.word	0x20002510
    2e28:	20001528 	.word	0x20001528
    2e2c:	20000f14 	.word	0x20000f14

00002e30 <z_log_msg2_commit>:
	msg->hdr.timestamp = timestamp_func();
    2e30:	4b06      	ldr	r3, [pc, #24]	; (2e4c <z_log_msg2_commit+0x1c>)
{
    2e32:	b510      	push	{r4, lr}
	msg->hdr.timestamp = timestamp_func();
    2e34:	681b      	ldr	r3, [r3, #0]
{
    2e36:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
    2e38:	4798      	blx	r3
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
    2e3a:	4621      	mov	r1, r4
	msg->hdr.timestamp = timestamp_func();
    2e3c:	60a0      	str	r0, [r4, #8]
	mpsc_pbuf_commit(&log_buffer, (union mpsc_pbuf_generic *)msg);
    2e3e:	4804      	ldr	r0, [pc, #16]	; (2e50 <z_log_msg2_commit+0x20>)
    2e40:	f022 fe26 	bl	25a90 <mpsc_pbuf_commit>
}
    2e44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_log_msg_post_finalize();
    2e48:	f7ff bfac 	b.w	2da4 <z_log_msg_post_finalize>
    2e4c:	20000328 	.word	0x20000328
    2e50:	200024d4 	.word	0x200024d4

00002e54 <z_impl_log_panic>:
{
    2e54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    2e56:	4f0e      	ldr	r7, [pc, #56]	; (2e90 <z_impl_log_panic+0x3c>)
    2e58:	783d      	ldrb	r5, [r7, #0]
    2e5a:	b975      	cbnz	r5, 2e7a <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
    2e5c:	4c0d      	ldr	r4, [pc, #52]	; (2e94 <z_impl_log_panic+0x40>)
    2e5e:	4e0e      	ldr	r6, [pc, #56]	; (2e98 <z_impl_log_panic+0x44>)
	log_init();
    2e60:	f7ff fe76 	bl	2b50 <log_init>
    2e64:	1b36      	subs	r6, r6, r4
    2e66:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    2e68:	42b5      	cmp	r5, r6
    2e6a:	db07      	blt.n	2e7c <z_impl_log_panic+0x28>
    2e6c:	2000      	movs	r0, #0
    2e6e:	f7ff ff2f 	bl	2cd0 <z_impl_log_process>
		while (log_process(false) == true) {
    2e72:	2800      	cmp	r0, #0
    2e74:	d1fa      	bne.n	2e6c <z_impl_log_panic+0x18>
	panic_mode = true;
    2e76:	2301      	movs	r3, #1
    2e78:	703b      	strb	r3, [r7, #0]
}
    2e7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    2e7c:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    2e7e:	795b      	ldrb	r3, [r3, #5]
    2e80:	b11b      	cbz	r3, 2e8a <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    2e82:	6823      	ldr	r3, [r4, #0]
    2e84:	4620      	mov	r0, r4
    2e86:	695b      	ldr	r3, [r3, #20]
    2e88:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    2e8a:	3501      	adds	r5, #1
    2e8c:	3410      	adds	r4, #16
    2e8e:	e7eb      	b.n	2e68 <z_impl_log_panic+0x14>
    2e90:	2000396e 	.word	0x2000396e
    2e94:	0002dc2c 	.word	0x0002dc2c
    2e98:	0002dc4c 	.word	0x0002dc4c

00002e9c <log_source_name_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
    2e9c:	4a04      	ldr	r2, [pc, #16]	; (2eb0 <log_source_name_get+0x14>)
    2e9e:	4b05      	ldr	r3, [pc, #20]	; (2eb4 <log_source_name_get+0x18>)
    2ea0:	1a9b      	subs	r3, r3, r2
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    2ea2:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    2ea6:	bf34      	ite	cc
    2ea8:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    2eac:	2000      	movcs	r0, #0
}
    2eae:	4770      	bx	lr
    2eb0:	0002d9bc 	.word	0x0002d9bc
    2eb4:	0002dc2c 	.word	0x0002dc2c

00002eb8 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
    2eb8:	4a05      	ldr	r2, [pc, #20]	; (2ed0 <log_backend_enable+0x18>)
	backend->cb->id = id;
    2eba:	6843      	ldr	r3, [r0, #4]
    2ebc:	1a80      	subs	r0, r0, r2
    2ebe:	1100      	asrs	r0, r0, #4
    2ec0:	3001      	adds	r0, #1
	backend->cb->active = true;
    2ec2:	2201      	movs	r2, #1

	if (!IS_ENABLED(CONFIG_LOG1)) {
		__ASSERT(backend->api->process, "Backend does not support v2 API");
	}

	log_backend_id_set(backend, id);
    2ec4:	7118      	strb	r0, [r3, #4]
	backend->cb->ctx = ctx;
    2ec6:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    2ec8:	715a      	strb	r2, [r3, #5]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
    2eca:	f7ff be6d 	b.w	2ba8 <z_log_notify_backend_enabled>
    2ece:	bf00      	nop
    2ed0:	0002dc2c 	.word	0x0002dc2c

00002ed4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
    2ed4:	b40e      	push	{r1, r2, r3}
    2ed6:	b503      	push	{r0, r1, lr}
    2ed8:	ab03      	add	r3, sp, #12
    2eda:	4601      	mov	r1, r0
    2edc:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
	length = cbvprintf(out_func, (void *)output, fmt, args);
    2ee0:	4804      	ldr	r0, [pc, #16]	; (2ef4 <print_formatted+0x20>)
	va_start(args, fmt);
    2ee2:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    2ee4:	f7ff fa3e 	bl	2364 <cbvprintf>
	va_end(args);

	return length;
}
    2ee8:	b002      	add	sp, #8
    2eea:	f85d eb04 	ldr.w	lr, [sp], #4
    2eee:	b003      	add	sp, #12
    2ef0:	4770      	bx	lr
    2ef2:	bf00      	nop
    2ef4:	00025c53 	.word	0x00025c53

00002ef8 <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    2ef8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2efc:	461d      	mov	r5, r3
    2efe:	9b08      	ldr	r3, [sp, #32]
    2f00:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2f02:	06da      	lsls	r2, r3, #27
{
    2f04:	4604      	mov	r4, r0
    2f06:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    2f08:	d405      	bmi.n	2f16 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    2f0a:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
    2f0c:	bf4c      	ite	mi
    2f0e:	492a      	ldrmi	r1, [pc, #168]	; (2fb8 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
    2f10:	492a      	ldrpl	r1, [pc, #168]	; (2fbc <hexdump_line_print+0xc4>)
    2f12:	f7ff ffdf 	bl	2ed4 <print_formatted>
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
    2f16:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 2fc0 <hexdump_line_print+0xc8>
{
    2f1a:	f04f 0800 	mov.w	r8, #0
	for (int i = 0; i < prefix_offset; i++) {
    2f1e:	45a8      	cmp	r8, r5
    2f20:	db2a      	blt.n	2f78 <hexdump_line_print+0x80>
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    2f22:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 2fc4 <hexdump_line_print+0xcc>
			print_formatted(output, "%02x ", data[i]);
    2f26:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 2fc8 <hexdump_line_print+0xd0>
			print_formatted(output, " ");
    2f2a:	f8df a094 	ldr.w	sl, [pc, #148]	; 2fc0 <hexdump_line_print+0xc8>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2f2e:	2500      	movs	r5, #0
		if (i < length) {
    2f30:	42bd      	cmp	r5, r7
    2f32:	d22f      	bcs.n	2f94 <hexdump_line_print+0x9c>
			print_formatted(output, "%02x ", data[i]);
    2f34:	5d72      	ldrb	r2, [r6, r5]
    2f36:	4649      	mov	r1, r9
    2f38:	4620      	mov	r0, r4
    2f3a:	f7ff ffcb 	bl	2ed4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2f3e:	3501      	adds	r5, #1
    2f40:	2d10      	cmp	r5, #16
    2f42:	d120      	bne.n	2f86 <hexdump_line_print+0x8e>
		}
	}

	print_formatted(output, "|");
    2f44:	4921      	ldr	r1, [pc, #132]	; (2fcc <hexdump_line_print+0xd4>)
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    2f46:	f8df 8078 	ldr.w	r8, [pc, #120]	; 2fc0 <hexdump_line_print+0xc8>
			print_formatted(output, "%c",
    2f4a:	f8df 9084 	ldr.w	r9, [pc, #132]	; 2fd0 <hexdump_line_print+0xd8>
	print_formatted(output, "|");
    2f4e:	4620      	mov	r0, r4
    2f50:	f7ff ffc0 	bl	2ed4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2f54:	2500      	movs	r5, #0
		if (i < length) {
    2f56:	42af      	cmp	r7, r5
    2f58:	d928      	bls.n	2fac <hexdump_line_print+0xb4>
			char c = (char)data[i];
    2f5a:	5d72      	ldrb	r2, [r6, r5]
	return (int)((((unsigned)c) >= ' ') &&
    2f5c:	f1a2 0320 	sub.w	r3, r2, #32
    2f60:	2b5f      	cmp	r3, #95	; 0x5f
			print_formatted(output, "%c",
    2f62:	bf28      	it	cs
    2f64:	222e      	movcs	r2, #46	; 0x2e
    2f66:	4649      	mov	r1, r9
    2f68:	4620      	mov	r0, r4
    2f6a:	f7ff ffb3 	bl	2ed4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2f6e:	3501      	adds	r5, #1
    2f70:	2d10      	cmp	r5, #16
    2f72:	d114      	bne.n	2f9e <hexdump_line_print+0xa6>
		}
	}
}
    2f74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, " ");
    2f78:	4649      	mov	r1, r9
    2f7a:	4620      	mov	r0, r4
    2f7c:	f7ff ffaa 	bl	2ed4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    2f80:	f108 0801 	add.w	r8, r8, #1
    2f84:	e7cb      	b.n	2f1e <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
    2f86:	076a      	lsls	r2, r5, #29
    2f88:	d1d2      	bne.n	2f30 <hexdump_line_print+0x38>
			print_formatted(output, " ");
    2f8a:	4651      	mov	r1, sl
    2f8c:	4620      	mov	r0, r4
    2f8e:	f7ff ffa1 	bl	2ed4 <print_formatted>
    2f92:	e7cd      	b.n	2f30 <hexdump_line_print+0x38>
			print_formatted(output, "   ");
    2f94:	4641      	mov	r1, r8
    2f96:	4620      	mov	r0, r4
    2f98:	f7ff ff9c 	bl	2ed4 <print_formatted>
    2f9c:	e7cf      	b.n	2f3e <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
    2f9e:	076b      	lsls	r3, r5, #29
    2fa0:	d1d9      	bne.n	2f56 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
    2fa2:	4641      	mov	r1, r8
    2fa4:	4620      	mov	r0, r4
    2fa6:	f7ff ff95 	bl	2ed4 <print_formatted>
    2faa:	e7d4      	b.n	2f56 <hexdump_line_print+0x5e>
			print_formatted(output, " ");
    2fac:	4641      	mov	r1, r8
    2fae:	4620      	mov	r0, r4
    2fb0:	f7ff ff90 	bl	2ed4 <print_formatted>
    2fb4:	e7db      	b.n	2f6e <hexdump_line_print+0x76>
    2fb6:	bf00      	nop
    2fb8:	0002ec4b 	.word	0x0002ec4b
    2fbc:	0002ec4a 	.word	0x0002ec4a
    2fc0:	0002ec55 	.word	0x0002ec55
    2fc4:	0002ec53 	.word	0x0002ec53
    2fc8:	0002ec4d 	.word	0x0002ec4d
    2fcc:	0002ec57 	.word	0x0002ec57
    2fd0:	0002ec59 	.word	0x0002ec59

00002fd4 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
    2fd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2fd8:	b087      	sub	sp, #28
    2fda:	461c      	mov	r4, r3
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    2fdc:	f001 0301 	and.w	r3, r1, #1
{
    2fe0:	9205      	str	r2, [sp, #20]
    2fe2:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
    2fe6:	f9bd a048 	ldrsh.w	sl, [sp, #72]	; 0x48
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    2fea:	9304      	str	r3, [sp, #16]
{
    2fec:	4607      	mov	r7, r0
    2fee:	4688      	mov	r8, r1
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
    2ff0:	f001 0b02 	and.w	fp, r1, #2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    2ff4:	f001 0608 	and.w	r6, r1, #8
	const char *tag = z_log_get_tag();
    2ff8:	f022 fe0f 	bl	25c1a <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
    2ffc:	4602      	mov	r2, r0
    2ffe:	2800      	cmp	r0, #0
    3000:	d044      	beq.n	308c <prefix_print+0xb8>
		length += print_formatted(output, "%s ", tag);
    3002:	493a      	ldr	r1, [pc, #232]	; (30ec <prefix_print+0x118>)
    3004:	4638      	mov	r0, r7
    3006:	f7ff ff65 	bl	2ed4 <print_formatted>
    300a:	4605      	mov	r5, r0
	}

	if (stamp) {
    300c:	f1bb 0f00 	cmp.w	fp, #0
    3010:	d008      	beq.n	3024 <prefix_print+0x50>
	if (!format) {
    3012:	f018 0f44 	tst.w	r8, #68	; 0x44
    3016:	d13b      	bne.n	3090 <prefix_print+0xbc>
		length = print_formatted(output, "[%08lu] ", timestamp);
    3018:	4935      	ldr	r1, [pc, #212]	; (30f0 <prefix_print+0x11c>)
    301a:	4622      	mov	r2, r4
    301c:	4638      	mov	r0, r7
    301e:	f7ff ff59 	bl	2ed4 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
    3022:	4405      	add	r5, r0
	if (color) {
    3024:	9b04      	ldr	r3, [sp, #16]
    3026:	b153      	cbz	r3, 303e <prefix_print+0x6a>
		const char *log_color = start && (colors[level] != NULL) ?
    3028:	4b32      	ldr	r3, [pc, #200]	; (30f4 <prefix_print+0x120>)
		print_formatted(output, "%s", log_color);
    302a:	4933      	ldr	r1, [pc, #204]	; (30f8 <prefix_print+0x124>)
		const char *log_color = start && (colors[level] != NULL) ?
    302c:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
		print_formatted(output, "%s", log_color);
    3030:	4b32      	ldr	r3, [pc, #200]	; (30fc <prefix_print+0x128>)
    3032:	4638      	mov	r0, r7
    3034:	2a00      	cmp	r2, #0
    3036:	bf08      	it	eq
    3038:	461a      	moveq	r2, r3
    303a:	f7ff ff4b 	bl	2ed4 <print_formatted>
	if (level_on) {
    303e:	b13e      	cbz	r6, 3050 <prefix_print+0x7c>
		total += print_formatted(output, "<%s> ", severity[level]);
    3040:	4b2f      	ldr	r3, [pc, #188]	; (3100 <prefix_print+0x12c>)
    3042:	4930      	ldr	r1, [pc, #192]	; (3104 <prefix_print+0x130>)
    3044:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
    3048:	4638      	mov	r0, r7
    304a:	f7ff ff43 	bl	2ed4 <print_formatted>
    304e:	4606      	mov	r6, r0
	if (source_id >= 0) {
    3050:	f1ba 0f00 	cmp.w	sl, #0
    3054:	db16      	blt.n	3084 <prefix_print+0xb0>
		total += print_formatted(output,
    3056:	9b05      	ldr	r3, [sp, #20]
    3058:	2b00      	cmp	r3, #0
    305a:	d045      	beq.n	30e8 <prefix_print+0x114>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    305c:	2301      	movs	r3, #1
    305e:	fa03 f909 	lsl.w	r9, r3, r9
		total += print_formatted(output,
    3062:	4b29      	ldr	r3, [pc, #164]	; (3108 <prefix_print+0x134>)
    3064:	4c29      	ldr	r4, [pc, #164]	; (310c <prefix_print+0x138>)
    3066:	f019 0f10 	tst.w	r9, #16
    306a:	bf18      	it	ne
    306c:	461c      	movne	r4, r3
    306e:	4651      	mov	r1, sl
    3070:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
    3074:	f7ff ff12 	bl	2e9c <log_source_name_get>
    3078:	4621      	mov	r1, r4
    307a:	4602      	mov	r2, r0
    307c:	4638      	mov	r0, r7
    307e:	f7ff ff29 	bl	2ed4 <print_formatted>
    3082:	4406      	add	r6, r0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
    3084:	1970      	adds	r0, r6, r5
    3086:	b007      	add	sp, #28
    3088:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
    308c:	4605      	mov	r5, r0
    308e:	e7bd      	b.n	300c <prefix_print+0x38>
	} else if (freq != 0U) {
    3090:	4b1f      	ldr	r3, [pc, #124]	; (3110 <prefix_print+0x13c>)
    3092:	6818      	ldr	r0, [r3, #0]
    3094:	2800      	cmp	r0, #0
    3096:	d0c4      	beq.n	3022 <prefix_print+0x4e>
		timestamp /= timestamp_div;
    3098:	4b1e      	ldr	r3, [pc, #120]	; (3114 <prefix_print+0x140>)
		ms = (remainder * 1000U) / freq;
    309a:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
		timestamp /= timestamp_div;
    309e:	681b      	ldr	r3, [r3, #0]
    30a0:	fbb4 f4f3 	udiv	r4, r4, r3
		total_seconds = timestamp / freq;
    30a4:	f44f 6161 	mov.w	r1, #3600	; 0xe10
    30a8:	fbb4 f3f0 	udiv	r3, r4, r0
		remainder = timestamp % freq;
    30ac:	fb00 4413 	mls	r4, r0, r3, r4
		ms = (remainder * 1000U) / freq;
    30b0:	fb08 f404 	mul.w	r4, r8, r4
		mins = seconds / 60U;
    30b4:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
    30b8:	fbb3 f2f1 	udiv	r2, r3, r1
    30bc:	fb01 3112 	mls	r1, r1, r2, r3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    30c0:	fbb4 fef0 	udiv	lr, r4, r0
		mins = seconds / 60U;
    30c4:	fbb1 f3fc 	udiv	r3, r1, ip
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    30c8:	fb00 441e 	mls	r4, r0, lr, r4
			length = print_formatted(output,
    30cc:	fb0c 1113 	mls	r1, ip, r3, r1
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    30d0:	fb08 f404 	mul.w	r4, r8, r4
			length = print_formatted(output,
    30d4:	9100      	str	r1, [sp, #0]
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    30d6:	fbb4 f0f0 	udiv	r0, r4, r0
			length = print_formatted(output,
    30da:	490f      	ldr	r1, [pc, #60]	; (3118 <prefix_print+0x144>)
    30dc:	e9cd e001 	strd	lr, r0, [sp, #4]
    30e0:	4638      	mov	r0, r7
    30e2:	f7ff fef7 	bl	2ed4 <print_formatted>
    30e6:	e79c      	b.n	3022 <prefix_print+0x4e>
		total += print_formatted(output,
    30e8:	4c08      	ldr	r4, [pc, #32]	; (310c <prefix_print+0x138>)
    30ea:	e7c0      	b.n	306e <prefix_print+0x9a>
    30ec:	0002ec6a 	.word	0x0002ec6a
    30f0:	0002ec6e 	.word	0x0002ec6e
    30f4:	0002de70 	.word	0x0002de70
    30f8:	00033605 	.word	0x00033605
    30fc:	0002ec5c 	.word	0x0002ec5c
    3100:	0002de84 	.word	0x0002de84
    3104:	0002ec93 	.word	0x0002ec93
    3108:	0002ec66 	.word	0x0002ec66
    310c:	0002ec61 	.word	0x0002ec61
    3110:	20002514 	.word	0x20002514
    3114:	20002518 	.word	0x20002518
    3118:	0002ec77 	.word	0x0002ec77

0000311c <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
    311c:	b538      	push	{r3, r4, r5, lr}
    311e:	460c      	mov	r4, r1
	if (color) {
    3120:	07e1      	lsls	r1, r4, #31
{
    3122:	4605      	mov	r5, r0
	if (color) {
    3124:	d503      	bpl.n	312e <postfix_print+0x12>
		print_formatted(output, "%s", log_color);
    3126:	4a08      	ldr	r2, [pc, #32]	; (3148 <postfix_print+0x2c>)
    3128:	4908      	ldr	r1, [pc, #32]	; (314c <postfix_print+0x30>)
    312a:	f7ff fed3 	bl	2ed4 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    312e:	06e2      	lsls	r2, r4, #27
    3130:	d408      	bmi.n	3144 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    3132:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    3134:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    3136:	bf4c      	ite	mi
    3138:	4905      	ldrmi	r1, [pc, #20]	; (3150 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    313a:	4906      	ldrpl	r1, [pc, #24]	; (3154 <postfix_print+0x38>)
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
    313c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    3140:	f7ff bec8 	b.w	2ed4 <print_formatted>
}
    3144:	bd38      	pop	{r3, r4, r5, pc}
    3146:	bf00      	nop
    3148:	0002ec5c 	.word	0x0002ec5c
    314c:	00033605 	.word	0x00033605
    3150:	0002ec4b 	.word	0x0002ec4b
    3154:	0002ec4a 	.word	0x0002ec4a

00003158 <log_output_msg2_process>:
	log_output_flush(output);
}

void log_output_msg2_process(const struct log_output *output,
			     struct log_msg2 *msg, uint32_t flags)
{
    3158:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @return Log level.
 */
static inline uint8_t log_msg2_get_level(struct log_msg2 *msg)
{
	return msg->hdr.desc.level;
    315c:	880b      	ldrh	r3, [r1, #0]
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYST) {
		log_output_msg2_syst_process(output, msg, flags);
		return;
	}

	if (!raw_string) {
    315e:	f413 7fe0 	tst.w	r3, #448	; 0x1c0
{
    3162:	4606      	mov	r6, r0
    3164:	460c      	mov	r4, r1
    3166:	4690      	mov	r8, r2
    3168:	f3c3 1982 	ubfx	r9, r3, #6, #3
	if (!raw_string) {
    316c:	d04d      	beq.n	320a <log_output_msg2_process+0xb2>
	return msg->hdr.desc.domain;
    316e:	780a      	ldrb	r2, [r1, #0]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg2_get_source(struct log_msg2 *msg)
{
	return msg->hdr.source;
    3170:	684b      	ldr	r3, [r1, #4]
	return msg->hdr.desc.domain;
    3172:	f3c2 02c2 	ubfx	r2, r2, #3, #3
		void *source = (void *)log_msg2_get_source(msg);
		uint8_t domain_id = log_msg2_get_domain(msg);
		int16_t source_id = source ?
    3176:	2b00      	cmp	r3, #0
    3178:	d044      	beq.n	3204 <log_output_msg2_process+0xac>
    317a:	4925      	ldr	r1, [pc, #148]	; (3210 <log_output_msg2_process+0xb8>)
    317c:	1a5b      	subs	r3, r3, r1
    317e:	f343 03cf 	sbfx	r3, r3, #3, #16
			(IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
				log_dynamic_source_id(source) :
				log_const_source_id(source)) :
			-1;

		prefix_offset = prefix_print(output, flags, 0, timestamp,
    3182:	e9cd 2301 	strd	r2, r3, [sp, #4]
    3186:	f8cd 9000 	str.w	r9, [sp]
    318a:	68a3      	ldr	r3, [r4, #8]
    318c:	2200      	movs	r2, #0
    318e:	4641      	mov	r1, r8
    3190:	4630      	mov	r0, r6
    3192:	f7ff ff1f 	bl	2fd4 <prefix_print>
    3196:	4682      	mov	sl, r0
 */
static inline uint8_t *log_msg2_get_package(struct log_msg2 *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;

	return msg->data;
    3198:	4625      	mov	r5, r4
	*len = msg->hdr.desc.package_len;
    319a:	f855 3b0c 	ldr.w	r3, [r5], #12
	}

	size_t len;
	uint8_t *data = log_msg2_get_package(msg, &len);

	if (len) {
    319e:	f3c3 2349 	ubfx	r3, r3, #9, #10
    31a2:	b153      	cbz	r3, 31ba <log_output_msg2_process+0x62>
 * returned from invoking @p out.
 */
static inline
int cbpprintf(cbprintf_cb out, void *ctx, void *packaged)
{
	return cbpprintf_external(out, cbvprintf, ctx, packaged);
    31a4:	4f1b      	ldr	r7, [pc, #108]	; (3214 <log_output_msg2_process+0xbc>)
    31a6:	481c      	ldr	r0, [pc, #112]	; (3218 <log_output_msg2_process+0xc0>)
    31a8:	491c      	ldr	r1, [pc, #112]	; (321c <log_output_msg2_process+0xc4>)
    31aa:	462b      	mov	r3, r5
    31ac:	4632      	mov	r2, r6
    31ae:	f1b9 0f00 	cmp.w	r9, #0
    31b2:	bf08      	it	eq
    31b4:	4638      	moveq	r0, r7
    31b6:	f021 ff23 	bl	25000 <cbpprintf_external>
	*len = msg->hdr.desc.data_len;
    31ba:	8867      	ldrh	r7, [r4, #2]
    31bc:	f3c7 07cb 	ubfx	r7, r7, #3, #12
		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	data = log_msg2_get_data(msg, &len);
	if (len) {
    31c0:	b197      	cbz	r7, 31e8 <log_output_msg2_process+0x90>
	return msg->data + msg->hdr.desc.package_len;
    31c2:	6823      	ldr	r3, [r4, #0]
    31c4:	f3c3 2349 	ubfx	r3, r3, #9, #10
    31c8:	441d      	add	r5, r3
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
    31ca:	2f10      	cmp	r7, #16
    31cc:	463c      	mov	r4, r7
    31ce:	bf28      	it	cs
    31d0:	2410      	movcs	r4, #16
		hexdump_line_print(output, data, length,
    31d2:	4629      	mov	r1, r5
    31d4:	f8cd 8000 	str.w	r8, [sp]
    31d8:	4653      	mov	r3, sl
    31da:	4622      	mov	r2, r4
    31dc:	4630      	mov	r0, r6
    31de:	f7ff fe8b 	bl	2ef8 <hexdump_line_print>
	} while (len);
    31e2:	1b3f      	subs	r7, r7, r4
		data += length;
    31e4:	4425      	add	r5, r4
	} while (len);
    31e6:	d1f0      	bne.n	31ca <log_output_msg2_process+0x72>
		log_msg2_hexdump(output, data, len, prefix_offset, flags);
	}

	if (!raw_string) {
    31e8:	f1b9 0f00 	cmp.w	r9, #0
    31ec:	d004      	beq.n	31f8 <log_output_msg2_process+0xa0>
		postfix_print(output, flags, level);
    31ee:	464a      	mov	r2, r9
    31f0:	4641      	mov	r1, r8
    31f2:	4630      	mov	r0, r6
    31f4:	f7ff ff92 	bl	311c <postfix_print>
	}

	log_output_flush(output);
    31f8:	4630      	mov	r0, r6
}
    31fa:	b004      	add	sp, #16
    31fc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(output);
    3200:	f022 bd1a 	b.w	25c38 <log_output_flush>
		int16_t source_id = source ?
    3204:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3208:	e7bb      	b.n	3182 <log_output_msg2_process+0x2a>
		prefix_offset = 0;
    320a:	46ca      	mov	sl, r9
    320c:	e7c4      	b.n	3198 <log_output_msg2_process+0x40>
    320e:	bf00      	nop
    3210:	0002d9bc 	.word	0x0002d9bc
    3214:	00025c89 	.word	0x00025c89
    3218:	00025c53 	.word	0x00025c53
    321c:	00002365 	.word	0x00002365

00003220 <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    3220:	b573      	push	{r0, r1, r4, r5, r6, lr}
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    3222:	f242 730f 	movw	r3, #9999	; 0x270f
    3226:	428b      	cmp	r3, r1
    3228:	bf28      	it	cs
    322a:	460b      	movcs	r3, r1
	log_output_func_t outf = output->func;
    322c:	6805      	ldr	r5, [r0, #0]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    322e:	4a0f      	ldr	r2, [pc, #60]	; (326c <log_output_dropped_process+0x4c>)
{
    3230:	4604      	mov	r4, r0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    3232:	2105      	movs	r1, #5
    3234:	4668      	mov	r0, sp
    3236:	f021 ffce 	bl	251d6 <snprintk>

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    323a:	6863      	ldr	r3, [r4, #4]
    323c:	490c      	ldr	r1, [pc, #48]	; (3270 <log_output_dropped_process+0x50>)
    323e:	685b      	ldr	r3, [r3, #4]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    3240:	4606      	mov	r6, r0
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    3242:	220b      	movs	r2, #11
    3244:	4628      	mov	r0, r5
    3246:	f022 fcea 	bl	25c1e <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
    324a:	6863      	ldr	r3, [r4, #4]
    324c:	4632      	mov	r2, r6
    324e:	4669      	mov	r1, sp
    3250:	4628      	mov	r0, r5
    3252:	685b      	ldr	r3, [r3, #4]
    3254:	f022 fce3 	bl	25c1e <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    3258:	6863      	ldr	r3, [r4, #4]
    325a:	4906      	ldr	r1, [pc, #24]	; (3274 <log_output_dropped_process+0x54>)
    325c:	685b      	ldr	r3, [r3, #4]
    325e:	221b      	movs	r2, #27
    3260:	4628      	mov	r0, r5
    3262:	f022 fcdc 	bl	25c1e <buffer_write>
		     output->control_block->ctx);
}
    3266:	b002      	add	sp, #8
    3268:	bd70      	pop	{r4, r5, r6, pc}
    326a:	bf00      	nop
    326c:	00032d9c 	.word	0x00032d9c
    3270:	0002ecd1 	.word	0x0002ecd1
    3274:	0002ecb5 	.word	0x0002ecb5

00003278 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    3278:	4a08      	ldr	r2, [pc, #32]	; (329c <log_output_timestamp_freq_set+0x24>)
{
    327a:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    327c:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    327e:	4c08      	ldr	r4, [pc, #32]	; (32a0 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    3280:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    3282:	2100      	movs	r1, #0
    3284:	42a0      	cmp	r0, r4
    3286:	d804      	bhi.n	3292 <log_output_timestamp_freq_set+0x1a>
    3288:	b101      	cbz	r1, 328c <log_output_timestamp_freq_set+0x14>
    328a:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    328c:	4b05      	ldr	r3, [pc, #20]	; (32a4 <log_output_timestamp_freq_set+0x2c>)
    328e:	6018      	str	r0, [r3, #0]
}
    3290:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    3292:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    3294:	005b      	lsls	r3, r3, #1
    3296:	2101      	movs	r1, #1
    3298:	e7f4      	b.n	3284 <log_output_timestamp_freq_set+0xc>
    329a:	bf00      	nop
    329c:	20002518 	.word	0x20002518
    32a0:	000f4240 	.word	0x000f4240
    32a4:	20002514 	.word	0x20002514

000032a8 <z_impl_z_log_msg2_runtime_vcreate>:
#endif

void z_impl_z_log_msg2_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				const char *fmt, va_list ap)
{
    32a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32ac:	b085      	sub	sp, #20
    32ae:	e9dd 6b0e 	ldrd	r6, fp, [sp, #56]	; 0x38
    32b2:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
    32b6:	4605      	mov	r5, r0
    32b8:	4688      	mov	r8, r1
    32ba:	4614      	mov	r4, r2
    32bc:	4699      	mov	r9, r3
	int plen;

	if (fmt) {
    32be:	f1bb 0f00 	cmp.w	fp, #0
    32c2:	d037      	beq.n	3334 <z_impl_z_log_msg2_runtime_vcreate+0x8c>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
    32c4:	2200      	movs	r2, #0
    32c6:	f8cd a000 	str.w	sl, [sp]
    32ca:	465b      	mov	r3, fp
    32cc:	210c      	movs	r1, #12
    32ce:	4610      	mov	r0, r2
		va_copy(ap2, ap);
    32d0:	f8cd a00c 	str.w	sl, [sp, #12]
		plen = cbvprintf_package(NULL, Z_LOG_MSG2_ALIGN_OFFSET, 0,
    32d4:	f7fe fd14 	bl	1d00 <cbvprintf_package>
    32d8:	4607      	mov	r7, r0
		plen = 0;
	}

	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
	struct log_msg2 *msg;
	struct log_msg2_desc desc =
    32da:	f004 0207 	and.w	r2, r4, #7
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    32de:	f106 0013 	add.w	r0, r6, #19
	struct log_msg2_desc desc =
    32e2:	f005 0407 	and.w	r4, r5, #7
    32e6:	4d14      	ldr	r5, [pc, #80]	; (3338 <z_impl_z_log_msg2_runtime_vcreate+0x90>)
    32e8:	4b14      	ldr	r3, [pc, #80]	; (333c <z_impl_z_log_msg2_runtime_vcreate+0x94>)
    32ea:	00e4      	lsls	r4, r4, #3
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    32ec:	4438      	add	r0, r7
	struct log_msg2_desc desc =
    32ee:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
    32f2:	ea05 2547 	and.w	r5, r5, r7, lsl #9
	size_t msg_wlen = Z_LOG_MSG2_ALIGNED_WLEN(plen, dlen);
    32f6:	f020 0007 	bic.w	r0, r0, #7
	struct log_msg2_desc desc =
    32fa:	432c      	orrs	r4, r5
    32fc:	ea03 43c6 	and.w	r3, r3, r6, lsl #19
		Z_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		msg = alloca(msg_wlen * sizeof(int));
	} else {
		msg = z_log_msg2_alloc(msg_wlen);
    3300:	0880      	lsrs	r0, r0, #2
	struct log_msg2_desc desc =
    3302:	431c      	orrs	r4, r3
		msg = z_log_msg2_alloc(msg_wlen);
    3304:	f7ff fcca 	bl	2c9c <z_log_msg2_alloc>
	}

	if (msg && fmt) {
    3308:	4605      	mov	r5, r0
    330a:	b150      	cbz	r0, 3322 <z_impl_z_log_msg2_runtime_vcreate+0x7a>
    330c:	f1bb 0f00 	cmp.w	fp, #0
    3310:	d007      	beq.n	3322 <z_impl_z_log_msg2_runtime_vcreate+0x7a>
		plen = cbvprintf_package(msg->data, (size_t)plen, 0, fmt, ap);
    3312:	f8cd a000 	str.w	sl, [sp]
    3316:	465b      	mov	r3, fp
    3318:	2200      	movs	r2, #0
    331a:	4639      	mov	r1, r7
    331c:	300c      	adds	r0, #12
    331e:	f7fe fcef 	bl	1d00 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
	}

	z_log_msg2_finalize(msg, source, desc, data);
    3322:	464b      	mov	r3, r9
    3324:	4622      	mov	r2, r4
    3326:	4641      	mov	r1, r8
    3328:	4628      	mov	r0, r5
}
    332a:	b005      	add	sp, #20
    332c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_log_msg2_finalize(msg, source, desc, data);
    3330:	f022 bcb7 	b.w	25ca2 <z_log_msg2_finalize>
		plen = 0;
    3334:	465f      	mov	r7, fp
    3336:	e7d0      	b.n	32da <z_impl_z_log_msg2_runtime_vcreate+0x32>
    3338:	0007fe00 	.word	0x0007fe00
    333c:	7ff80000 	.word	0x7ff80000

00003340 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
    3340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
			uart_poll_out(uart_dev, data[i]);
    3342:	4f07      	ldr	r7, [pc, #28]	; (3360 <char_out+0x20>)
{
    3344:	460d      	mov	r5, r1
    3346:	4604      	mov	r4, r0
    3348:	1846      	adds	r6, r0, r1
		for (size_t i = 0; i < length; i++) {
    334a:	42b4      	cmp	r4, r6
    334c:	d101      	bne.n	3352 <char_out+0x12>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
    334e:	4628      	mov	r0, r5
    3350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uart_poll_out(uart_dev, data[i]);
    3352:	6838      	ldr	r0, [r7, #0]
    3354:	f814 1b01 	ldrb.w	r1, [r4], #1
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    3358:	6883      	ldr	r3, [r0, #8]
    335a:	685b      	ldr	r3, [r3, #4]
    335c:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
    335e:	e7f4      	b.n	334a <char_out+0xa>
    3360:	20002530 	.word	0x20002530

00003364 <log_backend_uart_init>:
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    3364:	4b01      	ldr	r3, [pc, #4]	; (336c <log_backend_uart_init+0x8>)
    3366:	4a02      	ldr	r2, [pc, #8]	; (3370 <log_backend_uart_init+0xc>)
    3368:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
    336a:	4770      	bx	lr
    336c:	20002530 	.word	0x20002530
    3370:	0002d5b8 	.word	0x0002d5b8

00003374 <panic>:

static void panic(struct log_backend const *const backend)
{
	in_panic = true;
    3374:	4b02      	ldr	r3, [pc, #8]	; (3380 <panic+0xc>)
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
    3376:	4803      	ldr	r0, [pc, #12]	; (3384 <panic+0x10>)
    3378:	2201      	movs	r2, #1
    337a:	701a      	strb	r2, [r3, #0]
    337c:	f022 bc5c 	b.w	25c38 <log_output_flush>
    3380:	2000396f 	.word	0x2000396f
    3384:	0002deb4 	.word	0x0002deb4

00003388 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
    3388:	4801      	ldr	r0, [pc, #4]	; (3390 <dropped+0x8>)
    338a:	f7ff bf49 	b.w	3220 <log_output_dropped_process>
    338e:	bf00      	nop
    3390:	0002deb4 	.word	0x0002deb4

00003394 <process>:
		log_output_msg2_process(&log_output_uart, &msg->log, flags);
    3394:	4801      	ldr	r0, [pc, #4]	; (339c <process+0x8>)
    3396:	220f      	movs	r2, #15
    3398:	f7ff bede 	b.w	3158 <log_output_msg2_process>
    339c:	0002deb4 	.word	0x0002deb4

000033a0 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    33a0:	4b01      	ldr	r3, [pc, #4]	; (33a8 <log_backend_rtt_init+0x8>)
    33a2:	2201      	movs	r2, #1
    33a4:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    33a6:	4770      	bx	lr
    33a8:	20003981 	.word	0x20003981

000033ac <panic>:

static void panic(struct log_backend const *const backend)
{
	panic_mode = true;
    33ac:	4b02      	ldr	r3, [pc, #8]	; (33b8 <panic+0xc>)
	log_output_flush(output);
    33ae:	4803      	ldr	r0, [pc, #12]	; (33bc <panic+0x10>)
    33b0:	2201      	movs	r2, #1
    33b2:	701a      	strb	r2, [r3, #0]
    33b4:	f022 bc40 	b.w	25c38 <log_output_flush>
    33b8:	20003982 	.word	0x20003982
    33bc:	0002dee0 	.word	0x0002dee0

000033c0 <dropped>:
	log_output_dropped_process(output, cnt);
    33c0:	4801      	ldr	r0, [pc, #4]	; (33c8 <dropped+0x8>)
    33c2:	f7ff bf2d 	b.w	3220 <log_output_dropped_process>
    33c6:	bf00      	nop
    33c8:	0002dee0 	.word	0x0002dee0

000033cc <process>:
{
	uint32_t flags = log_backend_std_get_flags();

	flags |= IS_ENABLED(CONFIG_LOG_BACKEND_RTT_SYST_ENABLE) ? LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_output_msg2_process(&log_output_rtt, &msg->log, flags);
    33cc:	4801      	ldr	r0, [pc, #4]	; (33d4 <process+0x8>)
    33ce:	220f      	movs	r2, #15
    33d0:	f7ff bec2 	b.w	3158 <log_output_msg2_process>
    33d4:	0002dee0 	.word	0x0002dee0

000033d8 <on_failed_write.part.0>:
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
    33d8:	4b05      	ldr	r3, [pc, #20]	; (33f0 <on_failed_write.part.0+0x18>)
	} else if (is_sync_mode()) {
    33da:	781b      	ldrb	r3, [r3, #0]
    33dc:	b11b      	cbz	r3, 33e6 <on_failed_write.part.0+0xe>
	z_impl_k_busy_wait(usec_to_wait);
    33de:	f241 3088 	movw	r0, #5000	; 0x1388
    33e2:	f029 beb7 	b.w	2d154 <z_impl_k_busy_wait>
	return z_impl_k_sleep(timeout);
    33e6:	20a4      	movs	r0, #164	; 0xa4
    33e8:	2100      	movs	r1, #0
    33ea:	f021 ba97 	b.w	2491c <z_impl_k_sleep>
    33ee:	bf00      	nop
    33f0:	20003982 	.word	0x20003982

000033f4 <data_out_block_mode>:
{
    33f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE) || panic_mode;
    33f8:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3488 <data_out_block_mode+0x94>
	return z_impl_k_mutex_lock(mutex, timeout);
    33fc:	f8df a08c 	ldr.w	sl, [pc, #140]	; 348c <data_out_block_mode+0x98>
{
    3400:	4680      	mov	r8, r0
    3402:	460f      	mov	r7, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
    3404:	2404      	movs	r4, #4
		if (!is_sync_mode()) {
    3406:	f899 5000 	ldrb.w	r5, [r9]
    340a:	b9cd      	cbnz	r5, 3440 <data_out_block_mode+0x4c>
    340c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3410:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3414:	4650      	mov	r0, sl
    3416:	f020 fcaf 	bl	23d78 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    341a:	463a      	mov	r2, r7
    341c:	4641      	mov	r1, r8
    341e:	4628      	mov	r0, r5
    3420:	f020 f98a 	bl	23738 <SEGGER_RTT_WriteSkipNoLock>
    3424:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
    3426:	4650      	mov	r0, sl
    3428:	f020 fd1e 	bl	23e68 <z_impl_k_mutex_unlock>
		if (ret) {
    342c:	4d18      	ldr	r5, [pc, #96]	; (3490 <data_out_block_mode+0x9c>)
    342e:	b1fe      	cbz	r6, 3470 <data_out_block_mode+0x7c>
	host_present = true;
    3430:	2301      	movs	r3, #1
    3432:	702b      	strb	r3, [r5, #0]
	if (is_panic_mode()) {
    3434:	f899 3000 	ldrb.w	r3, [r9]
    3438:	b96b      	cbnz	r3, 3456 <data_out_block_mode+0x62>
}
    343a:	4638      	mov	r0, r7
    343c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    3440:	463a      	mov	r2, r7
    3442:	4641      	mov	r1, r8
    3444:	2000      	movs	r0, #0
    3446:	f020 f977 	bl	23738 <SEGGER_RTT_WriteSkipNoLock>
    344a:	4606      	mov	r6, r0
    344c:	e7ee      	b.n	342c <data_out_block_mode+0x38>
	if (retry_cnt == 0) {
    344e:	b95c      	cbnz	r4, 3468 <data_out_block_mode+0x74>
		host_present = false;
    3450:	702c      	strb	r4, [r5, #0]
    3452:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    3456:	2000      	movs	r0, #0
    3458:	f020 f9ba 	bl	237d0 <SEGGER_RTT_HasDataUp>
    345c:	2800      	cmp	r0, #0
    345e:	d0ec      	beq.n	343a <data_out_block_mode+0x46>
    3460:	782b      	ldrb	r3, [r5, #0]
    3462:	2b00      	cmp	r3, #0
    3464:	d1f3      	bne.n	344e <data_out_block_mode+0x5a>
    3466:	e7e8      	b.n	343a <data_out_block_mode+0x46>
			on_failed_write(retry_cnt--);
    3468:	3c01      	subs	r4, #1
    346a:	f7ff ffb5 	bl	33d8 <on_failed_write.part.0>
    346e:	e7f2      	b.n	3456 <data_out_block_mode+0x62>
		} else if (host_present) {
    3470:	782b      	ldrb	r3, [r5, #0]
    3472:	b113      	cbz	r3, 347a <data_out_block_mode+0x86>
	if (retry_cnt == 0) {
    3474:	3c01      	subs	r4, #1
    3476:	d104      	bne.n	3482 <data_out_block_mode+0x8e>
		host_present = false;
    3478:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
    347a:	782b      	ldrb	r3, [r5, #0]
    347c:	2b00      	cmp	r3, #0
    347e:	d1c2      	bne.n	3406 <data_out_block_mode+0x12>
    3480:	e7db      	b.n	343a <data_out_block_mode+0x46>
    3482:	f7ff ffa9 	bl	33d8 <on_failed_write.part.0>
    3486:	e7f8      	b.n	347a <data_out_block_mode+0x86>
    3488:	20003982 	.word	0x20003982
    348c:	20000ed4 	.word	0x20000ed4
    3490:	20003981 	.word	0x20003981

00003494 <nvs_recover_last_ate>:
 *
 * addr should point to the faulty closing ate and will be updated to the last
 * valid ate. If no valid ate is found it will be left untouched.
 */
static int nvs_recover_last_ate(struct nvs_fs *fs, uint32_t *addr)
{
    3494:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3498:	460f      	mov	r7, r1
    349a:	4606      	mov	r6, r0
	int rc;

	LOG_DBG("Recovering last ate from sector %d",
		(*addr >> ADDR_SECT_SHIFT));

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    349c:	2108      	movs	r1, #8
    349e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

	*addr -= ate_size;
	ate_end_addr = *addr;
	data_end_addr = *addr & ADDR_SECT_MASK;
    34a0:	f8df 9050 	ldr.w	r9, [pc, #80]	; 34f4 <nvs_recover_last_ate+0x60>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    34a4:	f022 fcc6 	bl	25e34 <nvs_al_size.isra.0>
	*addr -= ate_size;
    34a8:	683c      	ldr	r4, [r7, #0]
    34aa:	1a24      	subs	r4, r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    34ac:	4680      	mov	r8, r0
	*addr -= ate_size;
    34ae:	603c      	str	r4, [r7, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
    34b0:	ea04 0509 	and.w	r5, r4, r9
	while (ate_end_addr > data_end_addr) {
    34b4:	42ac      	cmp	r4, r5
    34b6:	d803      	bhi.n	34c0 <nvs_recover_last_ate+0x2c>
			*addr = ate_end_addr;
		}
		ate_end_addr -= ate_size;
	}

	return 0;
    34b8:	2000      	movs	r0, #0
}
    34ba:	b003      	add	sp, #12
    34bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    34c0:	2308      	movs	r3, #8
    34c2:	466a      	mov	r2, sp
    34c4:	4621      	mov	r1, r4
    34c6:	4630      	mov	r0, r6
    34c8:	f022 fc26 	bl	25d18 <nvs_flash_rd>
		if (rc) {
    34cc:	2800      	cmp	r0, #0
    34ce:	d1f4      	bne.n	34ba <nvs_recover_last_ate+0x26>
		if (nvs_ate_valid(fs, &end_ate)) {
    34d0:	4669      	mov	r1, sp
    34d2:	4630      	mov	r0, r6
    34d4:	f022 fcb8 	bl	25e48 <nvs_ate_valid>
    34d8:	b140      	cbz	r0, 34ec <nvs_recover_last_ate+0x58>
			data_end_addr += end_ate.offset + end_ate.len;
    34da:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    34de:	f8bd 2004 	ldrh.w	r2, [sp, #4]
			*addr = ate_end_addr;
    34e2:	603c      	str	r4, [r7, #0]
			data_end_addr &= ADDR_SECT_MASK;
    34e4:	ea05 0509 	and.w	r5, r5, r9
			data_end_addr += end_ate.offset + end_ate.len;
    34e8:	4413      	add	r3, r2
    34ea:	441d      	add	r5, r3
		ate_end_addr -= ate_size;
    34ec:	eba4 0408 	sub.w	r4, r4, r8
    34f0:	e7e0      	b.n	34b4 <nvs_recover_last_ate+0x20>
    34f2:	bf00      	nop
    34f4:	ffff0000 	.word	0xffff0000

000034f8 <nvs_init>:

	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
    34f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    34fc:	b093      	sub	sp, #76	; 0x4c
    34fe:	4604      	mov	r4, r0
    3500:	af00      	add	r7, sp, #0
    3502:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;
	size_t write_block_size;

	k_mutex_init(&fs->nvs_lock);
    3504:	f100 0814 	add.w	r8, r0, #20
	return z_impl_k_mutex_init(mutex);
    3508:	4640      	mov	r0, r8
    350a:	f029 fac4 	bl	2ca96 <z_impl_k_mutex_init>
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    350e:	4628      	mov	r0, r5
    3510:	f020 f988 	bl	23824 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
    3514:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
    3516:	b990      	cbnz	r0, 353e <nvs_init+0x46>
		LOG_ERR("No valid flash device found");
    3518:	4ba5      	ldr	r3, [pc, #660]	; (37b0 <nvs_init+0x2b8>)
    351a:	643b      	str	r3, [r7, #64]	; 0x40
    351c:	48a5      	ldr	r0, [pc, #660]	; (37b4 <nvs_init+0x2bc>)
    351e:	2302      	movs	r3, #2
    3520:	f107 023c 	add.w	r2, r7, #60	; 0x3c
    3524:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENXIO;
    3528:	f06f 0505 	mvn.w	r5, #5
		LOG_ERR("No valid flash device found");
    352c:	627b      	str	r3, [r7, #36]	; 0x24
    352e:	63fb      	str	r3, [r7, #60]	; 0x3c
    3530:	f022 fc72 	bl	25e18 <z_log_msg2_static_create.constprop.0>
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
    3534:	4628      	mov	r0, r5
    3536:	374c      	adds	r7, #76	; 0x4c
    3538:	46bd      	mov	sp, r7
    353a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline const struct flash_parameters *z_impl_flash_get_parameters(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev);
    353e:	6883      	ldr	r3, [r0, #8]
    3540:	68db      	ldr	r3, [r3, #12]
    3542:	4798      	blx	r3
	fs->flash_parameters = flash_get_parameters(fs->flash_device);
    3544:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (fs->flash_parameters == NULL) {
    3546:	b970      	cbnz	r0, 3566 <nvs_init+0x6e>
		LOG_ERR("Could not obtain flash parameters");
    3548:	4b9b      	ldr	r3, [pc, #620]	; (37b8 <nvs_init+0x2c0>)
		LOG_ERR("Unsupported write block size");
    354a:	643b      	str	r3, [r7, #64]	; 0x40
    354c:	2302      	movs	r3, #2
    354e:	627b      	str	r3, [r7, #36]	; 0x24
		LOG_ERR("Configuration error - sector count");
    3550:	4898      	ldr	r0, [pc, #608]	; (37b4 <nvs_init+0x2bc>)
    3552:	63fb      	str	r3, [r7, #60]	; 0x3c
    3554:	f107 023c 	add.w	r2, r7, #60	; 0x3c
    3558:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    355c:	f022 fc5c 	bl	25e18 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    3560:	f06f 0515 	mvn.w	r5, #21
    3564:	e7e6      	b.n	3534 <nvs_init+0x3c>
	write_block_size = flash_get_write_block_size(fs->flash_device);
    3566:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return api->get_parameters(dev)->write_block_size;
    3568:	6883      	ldr	r3, [r0, #8]
    356a:	68db      	ldr	r3, [r3, #12]
    356c:	4798      	blx	r3
	if (write_block_size > NVS_BLOCK_SIZE || write_block_size == 0) {
    356e:	6803      	ldr	r3, [r0, #0]
    3570:	3b01      	subs	r3, #1
    3572:	2b1f      	cmp	r3, #31
    3574:	d901      	bls.n	357a <nvs_init+0x82>
		LOG_ERR("Unsupported write block size");
    3576:	4b91      	ldr	r3, [pc, #580]	; (37bc <nvs_init+0x2c4>)
    3578:	e7e7      	b.n	354a <nvs_init+0x52>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
    357a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    357c:	6821      	ldr	r1, [r4, #0]
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
    357e:	f107 0224 	add.w	r2, r7, #36	; 0x24
    3582:	f029 f8ac 	bl	2c6de <z_impl_flash_get_page_info_by_offs>
	if (rc) {
    3586:	b120      	cbz	r0, 3592 <nvs_init+0x9a>
		LOG_ERR("Unable to get page info");
    3588:	4b8d      	ldr	r3, [pc, #564]	; (37c0 <nvs_init+0x2c8>)
		LOG_ERR("Configuration error - sector count");
    358a:	643b      	str	r3, [r7, #64]	; 0x40
    358c:	2302      	movs	r3, #2
    358e:	61fb      	str	r3, [r7, #28]
    3590:	e7de      	b.n	3550 <nvs_init+0x58>
	if (!fs->sector_size || fs->sector_size % info.size) {
    3592:	89a5      	ldrh	r5, [r4, #12]
    3594:	b12d      	cbz	r5, 35a2 <nvs_init+0xaa>
    3596:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3598:	fbb5 f2f3 	udiv	r2, r5, r3
    359c:	fb03 5512 	mls	r5, r3, r2, r5
    35a0:	b10d      	cbz	r5, 35a6 <nvs_init+0xae>
		LOG_ERR("Invalid sector size");
    35a2:	4b88      	ldr	r3, [pc, #544]	; (37c4 <nvs_init+0x2cc>)
    35a4:	e7f1      	b.n	358a <nvs_init+0x92>
	if (fs->sector_count < 2) {
    35a6:	89e3      	ldrh	r3, [r4, #14]
    35a8:	2b01      	cmp	r3, #1
    35aa:	d801      	bhi.n	35b0 <nvs_init+0xb8>
		LOG_ERR("Configuration error - sector count");
    35ac:	4b86      	ldr	r3, [pc, #536]	; (37c8 <nvs_init+0x2d0>)
    35ae:	e7ec      	b.n	358a <nvs_init+0x92>
	uint8_t erase_value = fs->flash_parameters->erase_value;
    35b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	uint32_t addr = 0U;
    35b2:	60fd      	str	r5, [r7, #12]
	uint8_t erase_value = fs->flash_parameters->erase_value;
    35b4:	f893 9004 	ldrb.w	r9, [r3, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
    35b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    35bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    35c0:	4640      	mov	r0, r8
    35c2:	f020 fbd9 	bl	23d78 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    35c6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    35c8:	2108      	movs	r1, #8
    35ca:	f022 fc33 	bl	25e34 <nvs_al_size.isra.0>
	uint16_t i, closed_sectors = 0;
    35ce:	46aa      	mov	sl, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    35d0:	4606      	mov	r6, r0
	for (i = 0; i < fs->sector_count; i++) {
    35d2:	89e3      	ldrh	r3, [r4, #14]
    35d4:	fa1f fb85 	uxth.w	fp, r5
    35d8:	455b      	cmp	r3, fp
    35da:	d84a      	bhi.n	3672 <nvs_init+0x17a>
	if (closed_sectors == fs->sector_count) {
    35dc:	89e3      	ldrh	r3, [r4, #14]
    35de:	4553      	cmp	r3, sl
    35e0:	f000 80f8 	beq.w	37d4 <nvs_init+0x2dc>
	if (i == fs->sector_count) {
    35e4:	455b      	cmp	r3, fp
    35e6:	d10c      	bne.n	3602 <nvs_init+0x10a>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, erase_value,
    35e8:	68f9      	ldr	r1, [r7, #12]
    35ea:	2308      	movs	r3, #8
    35ec:	464a      	mov	r2, r9
    35ee:	1b89      	subs	r1, r1, r6
    35f0:	4620      	mov	r0, r4
    35f2:	f022 fbc9 	bl	25d88 <nvs_flash_cmp_const>
		if (!rc) {
    35f6:	b920      	cbnz	r0, 3602 <nvs_init+0x10a>
			nvs_sector_advance(fs, &addr);
    35f8:	89e0      	ldrh	r0, [r4, #14]
    35fa:	f107 010c 	add.w	r1, r7, #12
    35fe:	f022 fc0e 	bl	25e1e <nvs_sector_advance.isra.0>
	rc = nvs_recover_last_ate(fs, &addr);
    3602:	f107 010c 	add.w	r1, r7, #12
    3606:	4620      	mov	r0, r4
    3608:	f7ff ff44 	bl	3494 <nvs_recover_last_ate>
	if (rc) {
    360c:	4605      	mov	r5, r0
    360e:	2800      	cmp	r0, #0
    3610:	f040 80e2 	bne.w	37d8 <nvs_init+0x2e0>
	fs->ate_wra = addr;
    3614:	68fb      	ldr	r3, [r7, #12]
	fs->data_wra = addr & ADDR_SECT_MASK;
    3616:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 37cc <nvs_init+0x2d4>
	fs->ate_wra = addr;
    361a:	6063      	str	r3, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
    361c:	ea03 030a 	and.w	r3, r3, sl
    3620:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
    3622:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
    3626:	4299      	cmp	r1, r3
    3628:	d310      	bcc.n	364c <nvs_init+0x154>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    362a:	2308      	movs	r3, #8
    362c:	f107 0214 	add.w	r2, r7, #20
    3630:	4620      	mov	r0, r4
    3632:	f022 fb71 	bl	25d18 <nvs_flash_rd>
		if (rc) {
    3636:	b9d0      	cbnz	r0, 366e <nvs_init+0x176>
    3638:	f107 0314 	add.w	r3, r7, #20
		if (data8[i] != value) {
    363c:	f813 2b01 	ldrb.w	r2, [r3], #1
    3640:	4591      	cmp	r9, r2
    3642:	f040 8129 	bne.w	3898 <nvs_init+0x3a0>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
    3646:	3001      	adds	r0, #1
    3648:	2808      	cmp	r0, #8
    364a:	d1f7      	bne.n	363c <nvs_init+0x144>
	addr = fs->ate_wra & ADDR_SECT_MASK;
    364c:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &addr);
    364e:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
    3650:	0c1b      	lsrs	r3, r3, #16
    3652:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &addr);
    3654:	f107 010c 	add.w	r1, r7, #12
	addr = fs->ate_wra & ADDR_SECT_MASK;
    3658:	60fb      	str	r3, [r7, #12]
	nvs_sector_advance(fs, &addr);
    365a:	f022 fbe0 	bl	25e1e <nvs_sector_advance.isra.0>
	rc = nvs_flash_cmp_const(fs, addr, erase_value, fs->sector_size);
    365e:	89a3      	ldrh	r3, [r4, #12]
    3660:	68f9      	ldr	r1, [r7, #12]
    3662:	464a      	mov	r2, r9
    3664:	4620      	mov	r0, r4
    3666:	f022 fb8f 	bl	25d88 <nvs_flash_cmp_const>
	if (rc < 0) {
    366a:	2800      	cmp	r0, #0
    366c:	da26      	bge.n	36bc <nvs_init+0x1c4>
    366e:	4605      	mov	r5, r0
    3670:	e0b2      	b.n	37d8 <nvs_init+0x2e0>
		       (uint16_t)(fs->sector_size - ate_size);
    3672:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
    3674:	042b      	lsls	r3, r5, #16
		       (uint16_t)(fs->sector_size - ate_size);
    3676:	1b89      	subs	r1, r1, r6
		addr = (i << ADDR_SECT_SHIFT) +
    3678:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
    367c:	464a      	mov	r2, r9
    367e:	2308      	movs	r3, #8
    3680:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
    3682:	60f9      	str	r1, [r7, #12]
		rc = nvs_flash_cmp_const(fs, addr, erase_value,
    3684:	f022 fb80 	bl	25d88 <nvs_flash_cmp_const>
		if (rc) {
    3688:	b180      	cbz	r0, 36ac <nvs_init+0x1b4>
			nvs_sector_advance(fs, &addr);
    368a:	89e0      	ldrh	r0, [r4, #14]
    368c:	f107 010c 	add.w	r1, r7, #12
    3690:	f022 fbc5 	bl	25e1e <nvs_sector_advance.isra.0>
			closed_sectors++;
    3694:	f10a 0a01 	add.w	sl, sl, #1
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
    3698:	68f9      	ldr	r1, [r7, #12]
    369a:	2308      	movs	r3, #8
    369c:	464a      	mov	r2, r9
    369e:	4620      	mov	r0, r4
			closed_sectors++;
    36a0:	fa1f fa8a 	uxth.w	sl, sl
			rc = nvs_flash_cmp_const(fs, addr, erase_value,
    36a4:	f022 fb70 	bl	25d88 <nvs_flash_cmp_const>
			if (!rc) {
    36a8:	2800      	cmp	r0, #0
    36aa:	d097      	beq.n	35dc <nvs_init+0xe4>
	for (i = 0; i < fs->sector_count; i++) {
    36ac:	3501      	adds	r5, #1
    36ae:	e790      	b.n	35d2 <nvs_init+0xda>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    36b0:	2b00      	cmp	r3, #0
    36b2:	f000 810a 	beq.w	38ca <nvs_init+0x3d2>
				rc = -ESPIPE;
    36b6:	f06f 051c 	mvn.w	r5, #28
    36ba:	e08d      	b.n	37d8 <nvs_init+0x2e0>
	if (rc) {
    36bc:	d052      	beq.n	3764 <nvs_init+0x26c>
		addr = fs->ate_wra + ate_size;
    36be:	6863      	ldr	r3, [r4, #4]
    36c0:	4433      	add	r3, r6
    36c2:	60fb      	str	r3, [r7, #12]
		while ((addr & ADDR_OFFS_MASK) < (fs->sector_size - ate_size)) {
    36c4:	f64f 79ff 	movw	r9, #65535	; 0xffff
    36c8:	68f9      	ldr	r1, [r7, #12]
    36ca:	89a3      	ldrh	r3, [r4, #12]
    36cc:	b28a      	uxth	r2, r1
    36ce:	1b9b      	subs	r3, r3, r6
    36d0:	429a      	cmp	r2, r3
    36d2:	d321      	bcc.n	3718 <nvs_init+0x220>
		LOG_INF("No GC Done marker found: restarting gc");
    36d4:	4b3e      	ldr	r3, [pc, #248]	; (37d0 <nvs_init+0x2d8>)
    36d6:	4837      	ldr	r0, [pc, #220]	; (37b4 <nvs_init+0x2bc>)
    36d8:	643b      	str	r3, [r7, #64]	; 0x40
    36da:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
    36de:	2302      	movs	r3, #2
    36e0:	f107 023c 	add.w	r2, r7, #60	; 0x3c
    36e4:	613b      	str	r3, [r7, #16]
    36e6:	63fb      	str	r3, [r7, #60]	; 0x3c
    36e8:	f022 fb96 	bl	25e18 <z_log_msg2_static_create.constprop.0>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
    36ec:	4620      	mov	r0, r4
    36ee:	6861      	ldr	r1, [r4, #4]
    36f0:	f022 fb6f 	bl	25dd2 <nvs_flash_erase_sector>
		if (rc) {
    36f4:	2800      	cmp	r0, #0
    36f6:	d1ba      	bne.n	366e <nvs_init+0x176>
		fs->ate_wra &= ADDR_SECT_MASK;
    36f8:	6863      	ldr	r3, [r4, #4]
    36fa:	4a34      	ldr	r2, [pc, #208]	; (37cc <nvs_init+0x2d4>)
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    36fc:	89a1      	ldrh	r1, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
    36fe:	4013      	ands	r3, r2
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
    3700:	440b      	add	r3, r1
    3702:	eba3 0346 	sub.w	r3, r3, r6, lsl #1
    3706:	6063      	str	r3, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
    3708:	4013      	ands	r3, r2
    370a:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
    370c:	4620      	mov	r0, r4
    370e:	f022 fc90 	bl	26032 <nvs_gc>
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
    3712:	2800      	cmp	r0, #0
    3714:	d041      	beq.n	379a <nvs_init+0x2a2>
    3716:	e7aa      	b.n	366e <nvs_init+0x176>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
    3718:	2308      	movs	r3, #8
    371a:	f107 021c 	add.w	r2, r7, #28
    371e:	4620      	mov	r0, r4
    3720:	f022 fafa 	bl	25d18 <nvs_flash_rd>
			if (rc) {
    3724:	2800      	cmp	r0, #0
    3726:	d1a2      	bne.n	366e <nvs_init+0x176>
			if (nvs_ate_valid(fs, &gc_done_ate) &&
    3728:	f107 011c 	add.w	r1, r7, #28
    372c:	4620      	mov	r0, r4
    372e:	f022 fb8b 	bl	25e48 <nvs_ate_valid>
    3732:	b130      	cbz	r0, 3742 <nvs_init+0x24a>
    3734:	8bbb      	ldrh	r3, [r7, #28]
    3736:	454b      	cmp	r3, r9
    3738:	d103      	bne.n	3742 <nvs_init+0x24a>
			    (gc_done_ate.id == 0xffff) &&
    373a:	8c3b      	ldrh	r3, [r7, #32]
    373c:	2b00      	cmp	r3, #0
    373e:	f000 8091 	beq.w	3864 <nvs_init+0x36c>
			addr += ate_size;
    3742:	68fb      	ldr	r3, [r7, #12]
    3744:	4433      	add	r3, r6
    3746:	60fb      	str	r3, [r7, #12]
    3748:	e7be      	b.n	36c8 <nvs_init+0x1d0>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, erase_value,
    374a:	1a5b      	subs	r3, r3, r1
    374c:	464a      	mov	r2, r9
    374e:	4620      	mov	r0, r4
    3750:	f022 fb1a 	bl	25d88 <nvs_flash_cmp_const>
		if (rc < 0) {
    3754:	2800      	cmp	r0, #0
    3756:	db8a      	blt.n	366e <nvs_init+0x176>
		if (!rc) {
    3758:	d008      	beq.n	376c <nvs_init+0x274>
		fs->data_wra += fs->flash_parameters->write_block_size;
    375a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    375c:	68a3      	ldr	r3, [r4, #8]
    375e:	6812      	ldr	r2, [r2, #0]
    3760:	4413      	add	r3, r2
    3762:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra > fs->data_wra) {
    3764:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    3768:	428b      	cmp	r3, r1
    376a:	d8ee      	bhi.n	374a <nvs_init+0x252>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
    376c:	6861      	ldr	r1, [r4, #4]
    376e:	89a3      	ldrh	r3, [r4, #12]
    3770:	eb01 0246 	add.w	r2, r1, r6, lsl #1
    3774:	429a      	cmp	r2, r3
    3776:	d1cc      	bne.n	3712 <nvs_init+0x21a>
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
    3778:	f8df 9050 	ldr.w	r9, [pc, #80]	; 37cc <nvs_init+0x2d4>
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
    377c:	68a3      	ldr	r3, [r4, #8]
	    (fs->data_wra != (fs->ate_wra & ADDR_SECT_MASK))) {
    377e:	ea01 0209 	and.w	r2, r1, r9
	if (((fs->ate_wra + 2 * ate_size) == fs->sector_size) &&
    3782:	4293      	cmp	r3, r2
    3784:	d0c5      	beq.n	3712 <nvs_init+0x21a>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
    3786:	4620      	mov	r0, r4
    3788:	f022 fb23 	bl	25dd2 <nvs_flash_erase_sector>
		if (rc) {
    378c:	2800      	cmp	r0, #0
    378e:	f47f af6e 	bne.w	366e <nvs_init+0x176>
		fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
    3792:	6863      	ldr	r3, [r4, #4]
    3794:	ea03 0309 	and.w	r3, r3, r9
    3798:	60a3      	str	r3, [r4, #8]
		      (fs->sector_size - 2 * ate_size))) {
    379a:	89a0      	ldrh	r0, [r4, #12]
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
    379c:	88a3      	ldrh	r3, [r4, #4]
		      (fs->sector_size - 2 * ate_size))) {
    379e:	eba0 0646 	sub.w	r6, r0, r6, lsl #1
	if ((!rc) && ((fs->ate_wra & ADDR_OFFS_MASK) ==
    37a2:	42b3      	cmp	r3, r6
    37a4:	d118      	bne.n	37d8 <nvs_init+0x2e0>
		rc = nvs_add_gc_done_ate(fs);
    37a6:	4620      	mov	r0, r4
    37a8:	f022 fc2e 	bl	26008 <nvs_add_gc_done_ate>
    37ac:	e75f      	b.n	366e <nvs_init+0x176>
    37ae:	bf00      	nop
    37b0:	0002ed1b 	.word	0x0002ed1b
    37b4:	0002dbbc 	.word	0x0002dbbc
    37b8:	0002ed37 	.word	0x0002ed37
    37bc:	0002ed59 	.word	0x0002ed59
    37c0:	0002ed76 	.word	0x0002ed76
    37c4:	0002ed8e 	.word	0x0002ed8e
    37c8:	0002eda2 	.word	0x0002eda2
    37cc:	ffff0000 	.word	0xffff0000
    37d0:	0002ee14 	.word	0x0002ee14
		rc = -EDEADLK;
    37d4:	f06f 052c 	mvn.w	r5, #44	; 0x2c
	return z_impl_k_mutex_unlock(mutex);
    37d8:	4640      	mov	r0, r8
    37da:	f020 fb45 	bl	23e68 <z_impl_k_mutex_unlock>
	if (rc) {
    37de:	2d00      	cmp	r5, #0
    37e0:	f47f aea8 	bne.w	3534 <nvs_init+0x3c>
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    37e4:	46ea      	mov	sl, sp
    37e6:	b088      	sub	sp, #32
    37e8:	466e      	mov	r6, sp
    37ea:	46b1      	mov	r9, r6
    37ec:	89e2      	ldrh	r2, [r4, #14]
    37ee:	4939      	ldr	r1, [pc, #228]	; (38d4 <nvs_init+0x3dc>)
    37f0:	4839      	ldr	r0, [pc, #228]	; (38d8 <nvs_init+0x3e0>)
	fs->ready = true;
    37f2:	2301      	movs	r3, #1
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    37f4:	f04f 0804 	mov.w	r8, #4
	fs->ready = true;
    37f8:	7423      	strb	r3, [r4, #16]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
    37fa:	89a3      	ldrh	r3, [r4, #12]
    37fc:	61b3      	str	r3, [r6, #24]
    37fe:	e9c6 1204 	strd	r1, r2, [r6, #16]
    3802:	f849 8f0c 	str.w	r8, [r9, #12]!
    3806:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
    380a:	464a      	mov	r2, r9
    380c:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
    3810:	f022 fb02 	bl	25e18 <z_log_msg2_static_create.constprop.0>
	LOG_INF("alloc wra: %d, %x",
    3814:	6863      	ldr	r3, [r4, #4]
    3816:	4a31      	ldr	r2, [pc, #196]	; (38dc <nvs_init+0x3e4>)
    3818:	6132      	str	r2, [r6, #16]
    381a:	0c1a      	lsrs	r2, r3, #16
    381c:	b29b      	uxth	r3, r3
    381e:	482e      	ldr	r0, [pc, #184]	; (38d8 <nvs_init+0x3e0>)
    3820:	6172      	str	r2, [r6, #20]
    3822:	46d5      	mov	sp, sl
    3824:	61b3      	str	r3, [r6, #24]
    3826:	46b5      	mov	sp, r6
    3828:	464a      	mov	r2, r9
    382a:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
    382e:	f8c6 800c 	str.w	r8, [r6, #12]
    3832:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
    3836:	f022 faef 	bl	25e18 <z_log_msg2_static_create.constprop.0>
	LOG_INF("data wra: %d, %x",
    383a:	68a3      	ldr	r3, [r4, #8]
    383c:	4a28      	ldr	r2, [pc, #160]	; (38e0 <nvs_init+0x3e8>)
    383e:	6132      	str	r2, [r6, #16]
    3840:	0c1a      	lsrs	r2, r3, #16
    3842:	b29b      	uxth	r3, r3
    3844:	46d5      	mov	sp, sl
    3846:	6172      	str	r2, [r6, #20]
    3848:	46b5      	mov	sp, r6
    384a:	4823      	ldr	r0, [pc, #140]	; (38d8 <nvs_init+0x3e0>)
    384c:	61b3      	str	r3, [r6, #24]
    384e:	f8c6 800c 	str.w	r8, [r6, #12]
    3852:	464a      	mov	r2, r9
    3854:	f44f 5103 	mov.w	r1, #8384	; 0x20c0
    3858:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
    385c:	f022 fadc 	bl	25e18 <z_log_msg2_static_create.constprop.0>
    3860:	46d5      	mov	sp, sl
	return 0;
    3862:	e667      	b.n	3534 <nvs_init+0x3c>
			LOG_INF("GC Done marker found");
    3864:	4b1f      	ldr	r3, [pc, #124]	; (38e4 <nvs_init+0x3ec>)
    3866:	643b      	str	r3, [r7, #64]	; 0x40
    3868:	f107 023c 	add.w	r2, r7, #60	; 0x3c
    386c:	2302      	movs	r3, #2
    386e:	481a      	ldr	r0, [pc, #104]	; (38d8 <nvs_init+0x3e0>)
    3870:	613b      	str	r3, [r7, #16]
    3872:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
    3876:	63fb      	str	r3, [r7, #60]	; 0x3c
    3878:	f022 face 	bl	25e18 <z_log_msg2_static_create.constprop.0>
			addr = fs->ate_wra & ADDR_SECT_MASK;
    387c:	6863      	ldr	r3, [r4, #4]
			nvs_sector_advance(fs, &addr);
    387e:	89e0      	ldrh	r0, [r4, #14]
			addr = fs->ate_wra & ADDR_SECT_MASK;
    3880:	0c1b      	lsrs	r3, r3, #16
    3882:	041b      	lsls	r3, r3, #16
			nvs_sector_advance(fs, &addr);
    3884:	f107 010c 	add.w	r1, r7, #12
			addr = fs->ate_wra & ADDR_SECT_MASK;
    3888:	60fb      	str	r3, [r7, #12]
			nvs_sector_advance(fs, &addr);
    388a:	f022 fac8 	bl	25e1e <nvs_sector_advance.isra.0>
			rc = nvs_flash_erase_sector(fs, addr);
    388e:	68f9      	ldr	r1, [r7, #12]
    3890:	4620      	mov	r0, r4
    3892:	f022 fa9e 	bl	25dd2 <nvs_flash_erase_sector>
			goto end;
    3896:	e73c      	b.n	3712 <nvs_init+0x21a>
		if (nvs_ate_valid(fs, &last_ate)) {
    3898:	f107 0114 	add.w	r1, r7, #20
    389c:	4620      	mov	r0, r4
    389e:	f022 fad3 	bl	25e48 <nvs_ate_valid>
    38a2:	f8d4 b004 	ldr.w	fp, [r4, #4]
    38a6:	b180      	cbz	r0, 38ca <nvs_init+0x3d2>
			fs->data_wra = addr & ADDR_SECT_MASK;
    38a8:	68fa      	ldr	r2, [r7, #12]
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
    38aa:	8b3b      	ldrh	r3, [r7, #24]
    38ac:	8af9      	ldrh	r1, [r7, #22]
    38ae:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    38b0:	607b      	str	r3, [r7, #4]
			fs->data_wra = addr & ADDR_SECT_MASK;
    38b2:	ea02 020a 	and.w	r2, r2, sl
    38b6:	60a2      	str	r2, [r4, #8]
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
    38b8:	4419      	add	r1, r3
    38ba:	f022 fabb 	bl	25e34 <nvs_al_size.isra.0>
    38be:	4402      	add	r2, r0
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    38c0:	455a      	cmp	r2, fp
    38c2:	687b      	ldr	r3, [r7, #4]
			fs->data_wra += nvs_al_size(fs, last_ate.offset + last_ate.len);
    38c4:	60a2      	str	r2, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
    38c6:	f43f aef3 	beq.w	36b0 <nvs_init+0x1b8>
		fs->ate_wra -= ate_size;
    38ca:	ebab 0306 	sub.w	r3, fp, r6
    38ce:	6063      	str	r3, [r4, #4]
    38d0:	e6a7      	b.n	3622 <nvs_init+0x12a>
    38d2:	bf00      	nop
    38d4:	0002edc5 	.word	0x0002edc5
    38d8:	0002dbbc 	.word	0x0002dbbc
    38dc:	0002eddc 	.word	0x0002eddc
    38e0:	0002edee 	.word	0x0002edee
    38e4:	0002edff 	.word	0x0002edff

000038e8 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, uint16_t id, const void *data, size_t len)
{
    38e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    38ec:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	uint32_t wlk_addr, rd_addr;
	uint16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
    38ee:	7c03      	ldrb	r3, [r0, #16]
{
    38f0:	b08d      	sub	sp, #52	; 0x34
    38f2:	4604      	mov	r4, r0
    38f4:	4689      	mov	r9, r1
    38f6:	4690      	mov	r8, r2
	if (!fs->ready) {
    38f8:	b983      	cbnz	r3, 391c <nvs_write+0x34>
		LOG_ERR("NVS not initialized");
    38fa:	4b61      	ldr	r3, [pc, #388]	; (3a80 <nvs_write+0x198>)
    38fc:	930a      	str	r3, [sp, #40]	; 0x28
    38fe:	4861      	ldr	r0, [pc, #388]	; (3a84 <nvs_write+0x19c>)
    3900:	2302      	movs	r3, #2
    3902:	aa09      	add	r2, sp, #36	; 0x24
    3904:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -EACCES;
    3908:	f06f 050c 	mvn.w	r5, #12
		LOG_ERR("NVS not initialized");
    390c:	9304      	str	r3, [sp, #16]
    390e:	9309      	str	r3, [sp, #36]	; 0x24
    3910:	f022 fa82 	bl	25e18 <z_log_msg2_static_create.constprop.0>
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
    3914:	4628      	mov	r0, r5
    3916:	b00d      	add	sp, #52	; 0x34
    3918:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    391c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    391e:	2108      	movs	r1, #8
    3920:	4610      	mov	r0, r2
    3922:	f022 fa87 	bl	25e34 <nvs_al_size.isra.0>
	data_size = nvs_al_size(fs, len);
    3926:	4631      	mov	r1, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3928:	4682      	mov	sl, r0
	data_size = nvs_al_size(fs, len);
    392a:	4610      	mov	r0, r2
    392c:	f022 fa82 	bl	25e34 <nvs_al_size.isra.0>
	if ((len > (fs->sector_size - 4 * ate_size)) ||
    3930:	89a3      	ldrh	r3, [r4, #12]
    3932:	eba3 038a 	sub.w	r3, r3, sl, lsl #2
    3936:	42b3      	cmp	r3, r6
	data_size = nvs_al_size(fs, len);
    3938:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 4 * ate_size)) ||
    393a:	f0c0 809e 	bcc.w	3a7a <nvs_write+0x192>
    393e:	b11e      	cbz	r6, 3948 <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
    3940:	f1b8 0f00 	cmp.w	r8, #0
    3944:	f000 8099 	beq.w	3a7a <nvs_write+0x192>
	wlk_addr = fs->ate_wra;
    3948:	6863      	ldr	r3, [r4, #4]
    394a:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    394c:	aa04      	add	r2, sp, #16
    394e:	a903      	add	r1, sp, #12
    3950:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    3952:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3956:	f022 faaf 	bl	25eb8 <nvs_prev_ate>
		if (rc) {
    395a:	4605      	mov	r5, r0
    395c:	2800      	cmp	r0, #0
    395e:	d1d9      	bne.n	3914 <nvs_write+0x2c>
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
    3960:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    3964:	454b      	cmp	r3, r9
    3966:	d005      	beq.n	3974 <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
    3968:	6862      	ldr	r2, [r4, #4]
    396a:	9b03      	ldr	r3, [sp, #12]
    396c:	429a      	cmp	r2, r3
    396e:	d1ed      	bne.n	394c <nvs_write+0x64>
		if (len == 0) {
    3970:	b9e6      	cbnz	r6, 39ac <nvs_write+0xc4>
    3972:	e7cf      	b.n	3914 <nvs_write+0x2c>
		if ((wlk_ate.id == id) && (nvs_ate_valid(fs, &wlk_ate))) {
    3974:	a904      	add	r1, sp, #16
    3976:	4620      	mov	r0, r4
    3978:	f022 fa66 	bl	25e48 <nvs_ate_valid>
    397c:	2800      	cmp	r0, #0
    397e:	d0f3      	beq.n	3968 <nvs_write+0x80>
			if (wlk_ate.len == 0U) {
    3980:	f8bd 3014 	ldrh.w	r3, [sp, #20]
		if (len == 0) {
    3984:	b186      	cbz	r6, 39a8 <nvs_write+0xc0>
		} else if (len == wlk_ate.len) {
    3986:	42b3      	cmp	r3, r6
    3988:	d110      	bne.n	39ac <nvs_write+0xc4>
		rd_addr += wlk_ate.offset;
    398a:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
    398e:	ea4f 411b 	mov.w	r1, fp, lsr #16
    3992:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
    3994:	4401      	add	r1, r0
    3996:	4633      	mov	r3, r6
    3998:	4642      	mov	r2, r8
    399a:	4620      	mov	r0, r4
    399c:	f022 f9ca 	bl	25d34 <nvs_flash_block_cmp>
			if (rc <= 0) {
    39a0:	2800      	cmp	r0, #0
    39a2:	dc03      	bgt.n	39ac <nvs_write+0xc4>
    39a4:	4605      	mov	r5, r0
    39a6:	e7b5      	b.n	3914 <nvs_write+0x2c>
			if (wlk_ate.len == 0U) {
    39a8:	2b00      	cmp	r3, #0
    39aa:	d0b3      	beq.n	3914 <nvs_write+0x2c>
	if (data_size) {
    39ac:	bba7      	cbnz	r7, 3a18 <nvs_write+0x130>
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
    39ae:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
    39b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    39b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    39ba:	4650      	mov	r0, sl
    39bc:	f020 f9dc 	bl	23d78 <z_impl_k_mutex_lock>
	fs->ate_wra &= ADDR_SECT_MASK;
    39c0:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 3a88 <nvs_write+0x1a0>
		if (gc_count == fs->sector_count) {
    39c4:	89e3      	ldrh	r3, [r4, #14]
    39c6:	429d      	cmp	r5, r3
    39c8:	d054      	beq.n	3a74 <nvs_write+0x18c>
		if (fs->ate_wra >= (fs->data_wra + required_space)) {
    39ca:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
    39ce:	18f9      	adds	r1, r7, r3
    39d0:	428a      	cmp	r2, r1
    39d2:	d324      	bcc.n	3a1e <nvs_write+0x136>
	entry.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
    39d4:	f8ad 301a 	strh.w	r3, [sp, #26]
	nvs_ate_crc8_update(&entry);
    39d8:	a806      	add	r0, sp, #24
	entry.part = 0xff;
    39da:	23ff      	movs	r3, #255	; 0xff
    39dc:	f88d 301e 	strb.w	r3, [sp, #30]
	entry.id = id;
    39e0:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.len = (uint16_t)len;
    39e4:	f8ad 601c 	strh.w	r6, [sp, #28]
	nvs_ate_crc8_update(&entry);
    39e8:	f022 fa0d 	bl	25e06 <nvs_ate_crc8_update>
	rc = nvs_flash_data_wrt(fs, data, len);
    39ec:	4632      	mov	r2, r6
    39ee:	4641      	mov	r1, r8
    39f0:	4620      	mov	r0, r4
    39f2:	f022 fae5 	bl	25fc0 <nvs_flash_data_wrt>
	if (rc) {
    39f6:	4603      	mov	r3, r0
    39f8:	b938      	cbnz	r0, 3a0a <nvs_write+0x122>
	rc = nvs_flash_ate_wrt(fs, &entry);
    39fa:	a906      	add	r1, sp, #24
    39fc:	4620      	mov	r0, r4
    39fe:	f022 faf2 	bl	25fe6 <nvs_flash_ate_wrt>
	rc = len;
    3a02:	2800      	cmp	r0, #0
    3a04:	bf14      	ite	ne
    3a06:	4603      	movne	r3, r0
    3a08:	4633      	moveq	r3, r6
    3a0a:	9301      	str	r3, [sp, #4]
	return z_impl_k_mutex_unlock(mutex);
    3a0c:	4650      	mov	r0, sl
    3a0e:	f020 fa2b 	bl	23e68 <z_impl_k_mutex_unlock>
	return rc;
    3a12:	9b01      	ldr	r3, [sp, #4]
    3a14:	461d      	mov	r5, r3
    3a16:	e77d      	b.n	3914 <nvs_write+0x2c>
		required_space = data_size + ate_size;
    3a18:	4457      	add	r7, sl
    3a1a:	b2bf      	uxth	r7, r7
    3a1c:	e7c7      	b.n	39ae <nvs_write+0xc6>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3a1e:	2108      	movs	r1, #8
    3a20:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    3a22:	f022 fa07 	bl	25e34 <nvs_al_size.isra.0>
	close_ate.id = 0xFFFF;
    3a26:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3a2a:	f8ad 3018 	strh.w	r3, [sp, #24]
	close_ate.len = 0U;
    3a2e:	2300      	movs	r3, #0
    3a30:	f8ad 301c 	strh.w	r3, [sp, #28]
	close_ate.offset = (uint16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
    3a34:	1813      	adds	r3, r2, r0
    3a36:	f8ad 301a 	strh.w	r3, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
    3a3a:	89a3      	ldrh	r3, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
    3a3c:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
    3a40:	441a      	add	r2, r3
    3a42:	1a12      	subs	r2, r2, r0
    3a44:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
    3a46:	a806      	add	r0, sp, #24
    3a48:	f022 f9dd 	bl	25e06 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
    3a4c:	a906      	add	r1, sp, #24
    3a4e:	4620      	mov	r0, r4
    3a50:	f022 fac9 	bl	25fe6 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
    3a54:	89e0      	ldrh	r0, [r4, #14]
    3a56:	1d21      	adds	r1, r4, #4
    3a58:	f022 f9e1 	bl	25e1e <nvs_sector_advance.isra.0>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
    3a5c:	6863      	ldr	r3, [r4, #4]
    3a5e:	ea03 030b 	and.w	r3, r3, fp
    3a62:	60a3      	str	r3, [r4, #8]
		rc = nvs_gc(fs);
    3a64:	4620      	mov	r0, r4
    3a66:	f022 fae4 	bl	26032 <nvs_gc>
		if (rc) {
    3a6a:	4603      	mov	r3, r0
    3a6c:	2800      	cmp	r0, #0
    3a6e:	d1cc      	bne.n	3a0a <nvs_write+0x122>
		gc_count++;
    3a70:	3501      	adds	r5, #1
		if (gc_count == fs->sector_count) {
    3a72:	e7a7      	b.n	39c4 <nvs_write+0xdc>
			rc = -ENOSPC;
    3a74:	f06f 031b 	mvn.w	r3, #27
    3a78:	e7c7      	b.n	3a0a <nvs_write+0x122>
		return -EINVAL;
    3a7a:	f06f 0515 	mvn.w	r5, #21
    3a7e:	e749      	b.n	3914 <nvs_write+0x2c>
    3a80:	0002ed07 	.word	0x0002ed07
    3a84:	0002dbbc 	.word	0x0002dbbc
    3a88:	ffff0000 	.word	0xffff0000

00003a8c <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, uint16_t id, void *data, size_t len,
		      uint16_t cnt)
{
    3a8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3a90:	461e      	mov	r6, r3
    3a92:	b088      	sub	sp, #32
	uint32_t wlk_addr, rd_addr;
	uint16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
    3a94:	7c03      	ldrb	r3, [r0, #16]
{
    3a96:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
    3a9a:	4604      	mov	r4, r0
    3a9c:	460f      	mov	r7, r1
    3a9e:	4690      	mov	r8, r2
	if (!fs->ready) {
    3aa0:	b97b      	cbnz	r3, 3ac2 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x2a>
		LOG_ERR("NVS not initialized");
    3aa2:	4b2c      	ldr	r3, [pc, #176]	; (3b54 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xbc>)
    3aa4:	482c      	ldr	r0, [pc, #176]	; (3b58 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc0>)
    3aa6:	9306      	str	r3, [sp, #24]
    3aa8:	aa05      	add	r2, sp, #20
    3aaa:	2302      	movs	r3, #2
    3aac:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    3ab0:	9301      	str	r3, [sp, #4]
    3ab2:	9305      	str	r3, [sp, #20]
    3ab4:	f022 f9b0 	bl	25e18 <z_log_msg2_static_create.constprop.0>
		return -EACCES;
    3ab8:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
    3abc:	b008      	add	sp, #32
    3abe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
    3ac2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    3ac4:	2108      	movs	r1, #8
    3ac6:	f022 f9b5 	bl	25e34 <nvs_al_size.isra.0>
	if (len > (fs->sector_size - 2 * ate_size)) {
    3aca:	89a3      	ldrh	r3, [r4, #12]
    3acc:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
    3ad0:	42b3      	cmp	r3, r6
    3ad2:	d33c      	bcc.n	3b4e <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xb6>
	wlk_addr = fs->ate_wra;
    3ad4:	6863      	ldr	r3, [r4, #4]
    3ad6:	9301      	str	r3, [sp, #4]
	cnt_his = 0U;
    3ad8:	f04f 0a00 	mov.w	sl, #0
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3adc:	aa02      	add	r2, sp, #8
    3ade:	a901      	add	r1, sp, #4
    3ae0:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
    3ae2:	9d01      	ldr	r5, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
    3ae4:	f022 f9e8 	bl	25eb8 <nvs_prev_ate>
		if (rc) {
    3ae8:	2800      	cmp	r0, #0
    3aea:	d1e7      	bne.n	3abc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x24>
		if ((wlk_ate.id == id) &&  (nvs_ate_valid(fs, &wlk_ate))) {
    3aec:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3af0:	42bb      	cmp	r3, r7
    3af2:	d108      	bne.n	3b06 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x6e>
    3af4:	a902      	add	r1, sp, #8
    3af6:	4620      	mov	r0, r4
    3af8:	f022 f9a6 	bl	25e48 <nvs_ate_valid>
    3afc:	b118      	cbz	r0, 3b06 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x6e>
			cnt_his++;
    3afe:	f10a 0a01 	add.w	sl, sl, #1
    3b02:	fa1f fa8a 	uxth.w	sl, sl
		if (wlk_addr == fs->ate_wra) {
    3b06:	6862      	ldr	r2, [r4, #4]
    3b08:	9b01      	ldr	r3, [sp, #4]
    3b0a:	429a      	cmp	r2, r3
    3b0c:	d018      	beq.n	3b40 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xa8>
	while (cnt_his <= cnt) {
    3b0e:	45ca      	cmp	sl, r9
    3b10:	d9e4      	bls.n	3adc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x44>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    3b12:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3b16:	b1bb      	cbz	r3, 3b48 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xb0>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
    3b18:	45ca      	cmp	sl, r9
    3b1a:	d315      	bcc.n	3b48 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xb0>
	rd_addr += wlk_ate.offset;
    3b1c:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
    3b20:	0c2d      	lsrs	r5, r5, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    3b22:	42b3      	cmp	r3, r6
	rd_addr &= ADDR_SECT_MASK;
    3b24:	ea4f 4505 	mov.w	r5, r5, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
    3b28:	bf28      	it	cs
    3b2a:	4633      	movcs	r3, r6
    3b2c:	4642      	mov	r2, r8
    3b2e:	4429      	add	r1, r5
    3b30:	4620      	mov	r0, r4
    3b32:	f022 f8f1 	bl	25d18 <nvs_flash_rd>
	if (rc) {
    3b36:	2800      	cmp	r0, #0
    3b38:	d1c0      	bne.n	3abc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x24>
	return wlk_ate.len;
    3b3a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    3b3e:	e7bd      	b.n	3abc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x24>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
    3b40:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    3b44:	42bb      	cmp	r3, r7
    3b46:	d0e4      	beq.n	3b12 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x7a>
		return -ENOENT;
    3b48:	f06f 0001 	mvn.w	r0, #1
    3b4c:	e7b6      	b.n	3abc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x24>
		return -EINVAL;
    3b4e:	f06f 0015 	mvn.w	r0, #21
    3b52:	e7b3      	b.n	3abc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x24>
    3b54:	0002ed07 	.word	0x0002ed07
    3b58:	0002dbbc 	.word	0x0002dbbc

00003b5c <flash_area_open>:

int flash_area_open(uint8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
    3b5c:	4b0c      	ldr	r3, [pc, #48]	; (3b90 <flash_area_open+0x34>)
    3b5e:	681b      	ldr	r3, [r3, #0]
{
    3b60:	b570      	push	{r4, r5, r6, lr}
	if (flash_map == NULL) {
    3b62:	b173      	cbz	r3, 3b82 <flash_area_open+0x26>
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static inline struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
    3b64:	4a0b      	ldr	r2, [pc, #44]	; (3b94 <flash_area_open+0x38>)
    3b66:	6815      	ldr	r5, [r2, #0]
    3b68:	2200      	movs	r2, #0
    3b6a:	42aa      	cmp	r2, r5
    3b6c:	db02      	blt.n	3b74 <flash_area_open+0x18>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
	if (area == NULL) {
		return -ENOENT;
    3b6e:	f06f 0001 	mvn.w	r0, #1
	}

	*fap = area;
	return 0;
}
    3b72:	bd70      	pop	{r4, r5, r6, pc}
		if (flash_map[i].fa_id == idx) {
    3b74:	461c      	mov	r4, r3
    3b76:	f813 6b10 	ldrb.w	r6, [r3], #16
    3b7a:	4286      	cmp	r6, r0
    3b7c:	d004      	beq.n	3b88 <flash_area_open+0x2c>
	for (int i = 0; i < flash_map_entries; i++) {
    3b7e:	3201      	adds	r2, #1
    3b80:	e7f3      	b.n	3b6a <flash_area_open+0xe>
		return -EACCES;
    3b82:	f06f 000c 	mvn.w	r0, #12
    3b86:	e7f4      	b.n	3b72 <flash_area_open+0x16>
	*fap = area;
    3b88:	600c      	str	r4, [r1, #0]
	return 0;
    3b8a:	2000      	movs	r0, #0
    3b8c:	e7f1      	b.n	3b72 <flash_area_open+0x16>
    3b8e:	bf00      	nop
    3b90:	2000032c 	.word	0x2000032c
    3b94:	0002df40 	.word	0x0002df40

00003b98 <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
    3b98:	b570      	push	{r4, r5, r6, lr}
    3b9a:	b088      	sub	sp, #32
    3b9c:	4605      	mov	r5, r0
    3b9e:	460c      	mov	r4, r1
	int rc = flash_area_open(idx, &fa);
    3ba0:	b2c0      	uxtb	r0, r0
    3ba2:	4669      	mov	r1, sp
{
    3ba4:	4616      	mov	r6, r2
	int rc = flash_area_open(idx, &fa);
    3ba6:	f7ff ffd9 	bl	3b5c <flash_area_open>
	if (rc < 0 || fa == NULL) {
    3baa:	2800      	cmp	r0, #0
    3bac:	db1f      	blt.n	3bee <flash_area_get_sectors+0x56>
    3bae:	9b00      	ldr	r3, [sp, #0]
    3bb0:	b1eb      	cbz	r3, 3bee <flash_area_get_sectors+0x56>
	cb_data->area_off = fa->fa_off;
    3bb2:	685a      	ldr	r2, [r3, #4]
    3bb4:	9202      	str	r2, [sp, #8]
	cb_data->area_len = fa->fa_size;
    3bb6:	689a      	ldr	r2, [r3, #8]
	cb_data->ret_len = *cnt;
    3bb8:	6821      	ldr	r1, [r4, #0]
	flash_dev = device_get_binding(fa->fa_dev_name);
    3bba:	68d8      	ldr	r0, [r3, #12]
	cb_data->area_idx = idx;
    3bbc:	9501      	str	r5, [sp, #4]
	cb_data->ret = ret;
    3bbe:	e9cd 2603 	strd	r2, r6, [sp, #12]
	cb_data->ret_idx = 0U;
    3bc2:	2200      	movs	r2, #0
	cb_data->status = 0;
    3bc4:	e9cd 1206 	strd	r1, r2, [sp, #24]
	cb_data->ret_idx = 0U;
    3bc8:	9205      	str	r2, [sp, #20]
    3bca:	f01f fe2b 	bl	23824 <z_impl_device_get_binding>
    3bce:	4605      	mov	r5, r0
	flash_area_close(fa);
    3bd0:	9800      	ldr	r0, [sp, #0]
    3bd2:	f022 faee 	bl	261b2 <flash_area_close>
	if (flash_dev == NULL) {
    3bd6:	b16d      	cbz	r5, 3bf4 <flash_area_get_sectors+0x5c>
	flash_page_foreach(flash_dev, cb, cb_data);
    3bd8:	4628      	mov	r0, r5
    3bda:	4908      	ldr	r1, [pc, #32]	; (3bfc <flash_area_get_sectors+0x64>)
    3bdc:	aa01      	add	r2, sp, #4
    3bde:	f028 fd82 	bl	2c6e6 <flash_page_foreach>
	if (cb_data->status == 0) {
    3be2:	9807      	ldr	r0, [sp, #28]
    3be4:	b908      	cbnz	r0, 3bea <flash_area_get_sectors+0x52>
		*cnt = cb_data->ret_idx;
    3be6:	9b05      	ldr	r3, [sp, #20]
    3be8:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
    3bea:	b008      	add	sp, #32
    3bec:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    3bee:	f06f 0015 	mvn.w	r0, #21
    3bf2:	e7fa      	b.n	3bea <flash_area_get_sectors+0x52>
		return -ENODEV;
    3bf4:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
    3bf8:	e7f7      	b.n	3bea <flash_area_get_sectors+0x52>
    3bfa:	bf00      	nop
    3bfc:	000261b5 	.word	0x000261b5

00003c00 <settings_save_one>:
int settings_save_one(const char *name, const void *value, size_t val_len)
{
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
    3c00:	4b10      	ldr	r3, [pc, #64]	; (3c44 <settings_save_one+0x44>)
{
    3c02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cs = settings_save_dst;
    3c06:	681c      	ldr	r4, [r3, #0]
{
    3c08:	4605      	mov	r5, r0
    3c0a:	460e      	mov	r6, r1
    3c0c:	4617      	mov	r7, r2
	if (!cs) {
    3c0e:	b1ac      	cbz	r4, 3c3c <settings_save_one+0x3c>
	return z_impl_k_mutex_lock(mutex, timeout);
    3c10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3c14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3c18:	480b      	ldr	r0, [pc, #44]	; (3c48 <settings_save_one+0x48>)
    3c1a:	f020 f8ad 	bl	23d78 <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
    3c1e:	6863      	ldr	r3, [r4, #4]
    3c20:	4632      	mov	r2, r6
    3c22:	f8d3 8008 	ldr.w	r8, [r3, #8]
    3c26:	4629      	mov	r1, r5
    3c28:	463b      	mov	r3, r7
    3c2a:	4620      	mov	r0, r4
    3c2c:	47c0      	blx	r8
    3c2e:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    3c30:	4805      	ldr	r0, [pc, #20]	; (3c48 <settings_save_one+0x48>)
    3c32:	f020 f919 	bl	23e68 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
    3c36:	4620      	mov	r0, r4
    3c38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
    3c3c:	f06f 0401 	mvn.w	r4, #1
    3c40:	e7f9      	b.n	3c36 <settings_save_one+0x36>
    3c42:	bf00      	nop
    3c44:	20002550 	.word	0x20002550
    3c48:	20000ee8 	.word	0x20000ee8

00003c4c <settings_src_register>:
	parent->next = child;
    3c4c:	2300      	movs	r3, #0
    3c4e:	6003      	str	r3, [r0, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    3c50:	4b04      	ldr	r3, [pc, #16]	; (3c64 <settings_src_register+0x18>)
    3c52:	685a      	ldr	r2, [r3, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    3c54:	b912      	cbnz	r2, 3c5c <settings_src_register+0x10>
	list->head = node;
    3c56:	e9c3 0000 	strd	r0, r0, [r3]
}
    3c5a:	4770      	bx	lr
	parent->next = child;
    3c5c:	6010      	str	r0, [r2, #0]
	list->tail = node;
    3c5e:	6058      	str	r0, [r3, #4]
}
    3c60:	4770      	bx	lr
    3c62:	bf00      	nop
    3c64:	20002548 	.word	0x20002548

00003c68 <settings_dst_register>:
	settings_save_dst = cs;
    3c68:	4b01      	ldr	r3, [pc, #4]	; (3c70 <settings_dst_register+0x8>)
    3c6a:	6018      	str	r0, [r3, #0]
}
    3c6c:	4770      	bx	lr
    3c6e:	bf00      	nop
    3c70:	20002550 	.word	0x20002550

00003c74 <settings_load_subtree>:
{
    3c74:	b530      	push	{r4, r5, lr}
    3c76:	b085      	sub	sp, #20
	const struct settings_load_arg arg = {
    3c78:	2300      	movs	r3, #0
{
    3c7a:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
    3c7c:	e9cd 3302 	strd	r3, r3, [sp, #8]
    3c80:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
    3c82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3c86:	480c      	ldr	r0, [pc, #48]	; (3cb8 <settings_load_subtree+0x44>)
    3c88:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3c8c:	f020 f874 	bl	23d78 <z_impl_k_mutex_lock>
	return list->head;
    3c90:	4b0a      	ldr	r3, [pc, #40]	; (3cbc <settings_load_subtree+0x48>)
    3c92:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    3c94:	b134      	cbz	r4, 3ca4 <settings_load_subtree+0x30>
		cs->cs_itf->csi_load(cs, &arg);
    3c96:	6863      	ldr	r3, [r4, #4]
    3c98:	4620      	mov	r0, r4
    3c9a:	681b      	ldr	r3, [r3, #0]
    3c9c:	a901      	add	r1, sp, #4
    3c9e:	4798      	blx	r3
	return node->next;
    3ca0:	6824      	ldr	r4, [r4, #0]
    3ca2:	e7f7      	b.n	3c94 <settings_load_subtree+0x20>
	rc = settings_commit_subtree(subtree);
    3ca4:	4628      	mov	r0, r5
    3ca6:	f000 f8d9 	bl	3e5c <settings_commit_subtree>
    3caa:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    3cac:	4802      	ldr	r0, [pc, #8]	; (3cb8 <settings_load_subtree+0x44>)
    3cae:	f020 f8db 	bl	23e68 <z_impl_k_mutex_unlock>
}
    3cb2:	4620      	mov	r0, r4
    3cb4:	b005      	add	sp, #20
    3cb6:	bd30      	pop	{r4, r5, pc}
    3cb8:	20000ee8 	.word	0x20000ee8
    3cbc:	20002548 	.word	0x20002548

00003cc0 <settings_load_subtree_direct>:
{
    3cc0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const struct settings_load_arg arg = {
    3cc2:	e9cd 0101 	strd	r0, r1, [sp, #4]
    3cc6:	9203      	str	r2, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
    3cc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3ccc:	480a      	ldr	r0, [pc, #40]	; (3cf8 <settings_load_subtree_direct+0x38>)
    3cce:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3cd2:	f020 f851 	bl	23d78 <z_impl_k_mutex_lock>
	return list->head;
    3cd6:	4b09      	ldr	r3, [pc, #36]	; (3cfc <settings_load_subtree_direct+0x3c>)
    3cd8:	681c      	ldr	r4, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
    3cda:	b134      	cbz	r4, 3cea <settings_load_subtree_direct+0x2a>
		cs->cs_itf->csi_load(cs, &arg);
    3cdc:	6863      	ldr	r3, [r4, #4]
    3cde:	4620      	mov	r0, r4
    3ce0:	681b      	ldr	r3, [r3, #0]
    3ce2:	a901      	add	r1, sp, #4
    3ce4:	4798      	blx	r3
	return node->next;
    3ce6:	6824      	ldr	r4, [r4, #0]
    3ce8:	e7f7      	b.n	3cda <settings_load_subtree_direct+0x1a>
	return z_impl_k_mutex_unlock(mutex);
    3cea:	4803      	ldr	r0, [pc, #12]	; (3cf8 <settings_load_subtree_direct+0x38>)
    3cec:	f020 f8bc 	bl	23e68 <z_impl_k_mutex_unlock>
}
    3cf0:	2000      	movs	r0, #0
    3cf2:	b004      	add	sp, #16
    3cf4:	bd10      	pop	{r4, pc}
    3cf6:	bf00      	nop
    3cf8:	20000ee8 	.word	0x20000ee8
    3cfc:	20002548 	.word	0x20002548

00003d00 <settings_store_init>:
	list->head = NULL;
    3d00:	4b02      	ldr	r3, [pc, #8]	; (3d0c <settings_store_init+0xc>)
    3d02:	2200      	movs	r2, #0
	list->tail = NULL;
    3d04:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
    3d08:	4770      	bx	lr
    3d0a:	bf00      	nop
    3d0c:	20002548 	.word	0x20002548

00003d10 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    3d10:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    3d12:	ab0a      	add	r3, sp, #40	; 0x28
    3d14:	9305      	str	r3, [sp, #20]
		arch_syscall_invoke6(*(uintptr_t *)&domain_id, *(uintptr_t *)&source, *(uintptr_t *)&level, *(uintptr_t *)&data, *(uintptr_t *)&dlen, (uintptr_t) &more, K_SYSCALL_Z_LOG_MSG2_RUNTIME_VCREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    3d16:	9302      	str	r3, [sp, #8]
    3d18:	4b05      	ldr	r3, [pc, #20]	; (3d30 <z_log_msg2_runtime_create.constprop.0+0x20>)
    3d1a:	9301      	str	r3, [sp, #4]
    3d1c:	2300      	movs	r3, #0
    3d1e:	9300      	str	r3, [sp, #0]
    3d20:	2201      	movs	r2, #1
    3d22:	4618      	mov	r0, r3
    3d24:	f7ff fac0 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    3d28:	b007      	add	sp, #28
    3d2a:	f85d fb04 	ldr.w	pc, [sp], #4
    3d2e:	bf00      	nop
    3d30:	0002ee55 	.word	0x0002ee55

00003d34 <settings_init>:
	list->head = NULL;
    3d34:	4b02      	ldr	r3, [pc, #8]	; (3d40 <settings_init+0xc>)
    3d36:	2200      	movs	r2, #0
	list->tail = NULL;
    3d38:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
    3d3c:	f7ff bfe0 	b.w	3d00 <settings_store_init>
    3d40:	20002554 	.word	0x20002554

00003d44 <settings_parse_and_lookup>:
	return rc;
}

struct settings_handler_static *settings_parse_and_lookup(const char *name,
							const char **next)
{
    3d44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3d48:	4607      	mov	r7, r0
	struct settings_handler_static *bestmatch;
	const char *tmpnext;

	bestmatch = NULL;
	if (next) {
    3d4a:	460e      	mov	r6, r1
    3d4c:	b109      	cbz	r1, 3d52 <settings_parse_and_lookup+0xe>
		*next = NULL;
    3d4e:	2300      	movs	r3, #0
    3d50:	600b      	str	r3, [r1, #0]
    3d52:	4c1c      	ldr	r4, [pc, #112]	; (3dc4 <settings_parse_and_lookup+0x80>)
	}

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3d54:	f8df 8070 	ldr.w	r8, [pc, #112]	; 3dc8 <settings_parse_and_lookup+0x84>
    3d58:	2500      	movs	r5, #0
    3d5a:	4544      	cmp	r4, r8
    3d5c:	d310      	bcc.n	3d80 <settings_parse_and_lookup+0x3c>
	return list->head;
    3d5e:	4b1b      	ldr	r3, [pc, #108]	; (3dcc <settings_parse_and_lookup+0x88>)
    3d60:	681c      	ldr	r4, [r3, #0]
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;

	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3d62:	b35c      	cbz	r4, 3dbc <settings_parse_and_lookup+0x78>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3d64:	aa01      	add	r2, sp, #4
    3d66:	4638      	mov	r0, r7
    3d68:	f854 1c14 	ldr.w	r1, [r4, #-20]
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3d6c:	3c14      	subs	r4, #20
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3d6e:	f022 fa46 	bl	261fe <settings_name_steq>
    3d72:	b308      	cbz	r0, 3db8 <settings_parse_and_lookup+0x74>
			continue;
		}
		if (!bestmatch) {
    3d74:	b9cd      	cbnz	r5, 3daa <settings_parse_and_lookup+0x66>
			}
			continue;
		}
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
			bestmatch = (struct settings_handler_static *)ch;
			if (next) {
    3d76:	b10e      	cbz	r6, 3d7c <settings_parse_and_lookup+0x38>
				*next = tmpnext;
    3d78:	9b01      	ldr	r3, [sp, #4]
    3d7a:	6033      	str	r3, [r6, #0]
    3d7c:	4625      	mov	r5, r4
    3d7e:	e01b      	b.n	3db8 <settings_parse_and_lookup+0x74>
		if (!settings_name_steq(name, ch->name, &tmpnext)) {
    3d80:	6821      	ldr	r1, [r4, #0]
    3d82:	aa01      	add	r2, sp, #4
    3d84:	4638      	mov	r0, r7
    3d86:	f022 fa3a 	bl	261fe <settings_name_steq>
    3d8a:	b160      	cbz	r0, 3da6 <settings_parse_and_lookup+0x62>
		if (!bestmatch) {
    3d8c:	b925      	cbnz	r5, 3d98 <settings_parse_and_lookup+0x54>
			if (next) {
    3d8e:	b10e      	cbz	r6, 3d94 <settings_parse_and_lookup+0x50>
				*next = tmpnext;
    3d90:	9b01      	ldr	r3, [sp, #4]
    3d92:	6033      	str	r3, [r6, #0]
    3d94:	4625      	mov	r5, r4
    3d96:	e006      	b.n	3da6 <settings_parse_and_lookup+0x62>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3d98:	6829      	ldr	r1, [r5, #0]
    3d9a:	6820      	ldr	r0, [r4, #0]
    3d9c:	2200      	movs	r2, #0
    3d9e:	f022 fa2e 	bl	261fe <settings_name_steq>
    3da2:	2800      	cmp	r0, #0
    3da4:	d1f3      	bne.n	3d8e <settings_parse_and_lookup+0x4a>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3da6:	3414      	adds	r4, #20
    3da8:	e7d7      	b.n	3d5a <settings_parse_and_lookup+0x16>
		if (settings_name_steq(ch->name, bestmatch->name, NULL)) {
    3daa:	6829      	ldr	r1, [r5, #0]
    3dac:	6820      	ldr	r0, [r4, #0]
    3dae:	2200      	movs	r2, #0
    3db0:	f022 fa25 	bl	261fe <settings_name_steq>
    3db4:	2800      	cmp	r0, #0
    3db6:	d1de      	bne.n	3d76 <settings_parse_and_lookup+0x32>
	return node->next;
    3db8:	6964      	ldr	r4, [r4, #20]
    3dba:	e7d2      	b.n	3d62 <settings_parse_and_lookup+0x1e>
			}
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	return bestmatch;
}
    3dbc:	4628      	mov	r0, r5
    3dbe:	b002      	add	sp, #8
    3dc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3dc4:	0002d868 	.word	0x0002d868
    3dc8:	0002d9bc 	.word	0x0002d9bc
    3dcc:	20002554 	.word	0x20002554

00003dd0 <settings_call_set_handler>:
int settings_call_set_handler(const char *name,
			      size_t len,
			      settings_read_cb read_cb,
			      void *read_cb_arg,
			      const struct settings_load_arg *load_arg)
{
    3dd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3dd4:	b087      	sub	sp, #28
    3dd6:	4604      	mov	r4, r0
    3dd8:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
	int rc;
	const char *name_key = name;
    3ddc:	9005      	str	r0, [sp, #20]
{
    3dde:	460d      	mov	r5, r1
    3de0:	4616      	mov	r6, r2
    3de2:	461f      	mov	r7, r3

	if (load_arg && load_arg->subtree &&
    3de4:	f1b8 0f00 	cmp.w	r8, #0
    3de8:	d018      	beq.n	3e1c <settings_call_set_handler+0x4c>
    3dea:	f8d8 1000 	ldr.w	r1, [r8]
    3dee:	b181      	cbz	r1, 3e12 <settings_call_set_handler+0x42>
	    !settings_name_steq(name, load_arg->subtree, &name_key)) {
    3df0:	aa05      	add	r2, sp, #20
    3df2:	f022 fa04 	bl	261fe <settings_name_steq>
	if (load_arg && load_arg->subtree &&
    3df6:	b960      	cbnz	r0, 3e12 <settings_call_set_handler+0x42>
		return 0;
    3df8:	2000      	movs	r0, #0
			LOG_DBG("set-value OK. key: %s",
				log_strdup(name));
		}
	}
	return rc;
}
    3dfa:	b007      	add	sp, #28
    3dfc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		rc = load_arg->cb(name_key, len, read_cb, read_cb_arg,
    3e00:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3e04:	9300      	str	r3, [sp, #0]
    3e06:	9805      	ldr	r0, [sp, #20]
    3e08:	463b      	mov	r3, r7
    3e0a:	4632      	mov	r2, r6
    3e0c:	4629      	mov	r1, r5
    3e0e:	47c8      	blx	r9
    3e10:	e7f3      	b.n	3dfa <settings_call_set_handler+0x2a>
	if (load_arg && load_arg->cb) {
    3e12:	f8d8 9004 	ldr.w	r9, [r8, #4]
    3e16:	f1b9 0f00 	cmp.w	r9, #0
    3e1a:	d1f1      	bne.n	3e00 <settings_call_set_handler+0x30>
		ch = settings_parse_and_lookup(name, &name_key);
    3e1c:	a905      	add	r1, sp, #20
    3e1e:	4620      	mov	r0, r4
    3e20:	f7ff ff90 	bl	3d44 <settings_parse_and_lookup>
		if (!ch) {
    3e24:	2800      	cmp	r0, #0
    3e26:	d0e7      	beq.n	3df8 <settings_call_set_handler+0x28>
		rc = ch->h_set(name_key, len, read_cb, read_cb_arg);
    3e28:	f8d0 8008 	ldr.w	r8, [r0, #8]
    3e2c:	9805      	ldr	r0, [sp, #20]
    3e2e:	463b      	mov	r3, r7
    3e30:	4632      	mov	r2, r6
    3e32:	4629      	mov	r1, r5
    3e34:	47c0      	blx	r8
		if (rc != 0) {
    3e36:	2800      	cmp	r0, #0
    3e38:	d0de      	beq.n	3df8 <settings_call_set_handler+0x28>
			LOG_ERR("set-value failure. key: %s error(%d)",
    3e3a:	e9cd 4002 	strd	r4, r0, [sp, #8]
    3e3e:	4b05      	ldr	r3, [pc, #20]	; (3e54 <settings_call_set_handler+0x84>)
    3e40:	9301      	str	r3, [sp, #4]
    3e42:	2400      	movs	r4, #0
    3e44:	4904      	ldr	r1, [pc, #16]	; (3e58 <settings_call_set_handler+0x88>)
    3e46:	9400      	str	r4, [sp, #0]
    3e48:	4623      	mov	r3, r4
    3e4a:	2201      	movs	r2, #1
    3e4c:	4620      	mov	r0, r4
    3e4e:	f7ff ff5f 	bl	3d10 <z_log_msg2_runtime_create.constprop.0>
			rc = 0;
    3e52:	e7d1      	b.n	3df8 <settings_call_set_handler+0x28>
    3e54:	0002ee55 	.word	0x0002ee55
    3e58:	0002dc0c 	.word	0x0002dc0c

00003e5c <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
    3e5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int rc;
	int rc2;

	rc = 0;

	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e5e:	4c18      	ldr	r4, [pc, #96]	; (3ec0 <settings_commit_subtree+0x64>)
    3e60:	4f18      	ldr	r7, [pc, #96]	; (3ec4 <settings_commit_subtree+0x68>)
{
    3e62:	4606      	mov	r6, r0
	rc = 0;
    3e64:	2500      	movs	r5, #0
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e66:	42bc      	cmp	r4, r7
    3e68:	d308      	bcc.n	3e7c <settings_commit_subtree+0x20>
	return list->head;
    3e6a:	4b17      	ldr	r3, [pc, #92]	; (3ec8 <settings_commit_subtree+0x6c>)
    3e6c:	681c      	ldr	r4, [r3, #0]
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
    3e6e:	b324      	cbz	r4, 3eba <settings_commit_subtree+0x5e>
    3e70:	3c14      	subs	r4, #20
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3e72:	b9ae      	cbnz	r6, 3ea0 <settings_commit_subtree+0x44>
			continue;
		}
		if (ch->h_commit) {
    3e74:	68e3      	ldr	r3, [r4, #12]
    3e76:	b9db      	cbnz	r3, 3eb0 <settings_commit_subtree+0x54>
	return node->next;
    3e78:	6964      	ldr	r4, [r4, #20]
    3e7a:	e7f8      	b.n	3e6e <settings_commit_subtree+0x12>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3e7c:	b91e      	cbnz	r6, 3e86 <settings_commit_subtree+0x2a>
		if (ch->h_commit) {
    3e7e:	68e3      	ldr	r3, [r4, #12]
    3e80:	b94b      	cbnz	r3, 3e96 <settings_commit_subtree+0x3a>
	STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
    3e82:	3414      	adds	r4, #20
    3e84:	e7ef      	b.n	3e66 <settings_commit_subtree+0xa>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3e86:	6820      	ldr	r0, [r4, #0]
    3e88:	2200      	movs	r2, #0
    3e8a:	4631      	mov	r1, r6
    3e8c:	f022 f9b7 	bl	261fe <settings_name_steq>
    3e90:	2800      	cmp	r0, #0
    3e92:	d1f4      	bne.n	3e7e <settings_commit_subtree+0x22>
    3e94:	e7f5      	b.n	3e82 <settings_commit_subtree+0x26>
			rc2 = ch->h_commit();
    3e96:	4798      	blx	r3
				rc = rc2;
    3e98:	2d00      	cmp	r5, #0
    3e9a:	bf08      	it	eq
    3e9c:	4605      	moveq	r5, r0
    3e9e:	e7f0      	b.n	3e82 <settings_commit_subtree+0x26>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
    3ea0:	6820      	ldr	r0, [r4, #0]
    3ea2:	2200      	movs	r2, #0
    3ea4:	4631      	mov	r1, r6
    3ea6:	f022 f9aa 	bl	261fe <settings_name_steq>
    3eaa:	2800      	cmp	r0, #0
    3eac:	d1e2      	bne.n	3e74 <settings_commit_subtree+0x18>
    3eae:	e7e3      	b.n	3e78 <settings_commit_subtree+0x1c>
			rc2 = ch->h_commit();
    3eb0:	4798      	blx	r3
			if (!rc) {
				rc = rc2;
    3eb2:	2d00      	cmp	r5, #0
    3eb4:	bf08      	it	eq
    3eb6:	4605      	moveq	r5, r0
    3eb8:	e7de      	b.n	3e78 <settings_commit_subtree+0x1c>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
    3eba:	4628      	mov	r0, r5
    3ebc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3ebe:	bf00      	nop
    3ec0:	0002d868 	.word	0x0002d868
    3ec4:	0002d9bc 	.word	0x0002d9bc
    3ec8:	20002554 	.word	0x20002554

00003ecc <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
    3ecc:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
    3ece:	4c06      	ldr	r4, [pc, #24]	; (3ee8 <settings_subsys_init+0x1c>)
    3ed0:	7823      	ldrb	r3, [r4, #0]
    3ed2:	b93b      	cbnz	r3, 3ee4 <settings_subsys_init+0x18>
		return 0;
	}

	settings_init();
    3ed4:	f7ff ff2e 	bl	3d34 <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
    3ed8:	f000 f864 	bl	3fa4 <settings_backend_init>

	if (!err) {
    3edc:	b908      	cbnz	r0, 3ee2 <settings_subsys_init+0x16>
		settings_subsys_initialized = true;
    3ede:	2301      	movs	r3, #1
    3ee0:	7023      	strb	r3, [r4, #0]
	}

	return err;
}
    3ee2:	bd10      	pop	{r4, pc}
		return 0;
    3ee4:	2000      	movs	r0, #0
    3ee6:	e7fc      	b.n	3ee2 <settings_subsys_init+0x16>
    3ee8:	20003983 	.word	0x20003983

00003eec <settings_nvs_load>:
	return 0;
}

static int settings_nvs_load(struct settings_store *cs,
			     const struct settings_load_arg *arg)
{
    3eec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	char name[SETTINGS_MAX_NAME_LEN + SETTINGS_EXTRA_LEN + 1];
	char buf;
	ssize_t rc1, rc2;
	uint16_t name_id = NVS_NAMECNT_ID;

	name_id = cf->last_name_id + 1;
    3ef0:	8f04      	ldrh	r4, [r0, #56]	; 0x38
		/* Found a name, this might not include a trailing \0 */
		name[rc1] = '\0';
		read_fn_arg.fs = &cf->cf_nvs;
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;

		ret = settings_call_set_handler(
    3ef2:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 3fa0 <settings_nvs_load+0xb4>
	name_id = cf->last_name_id + 1;
    3ef6:	3401      	adds	r4, #1
{
    3ef8:	b098      	sub	sp, #96	; 0x60
    3efa:	4680      	mov	r8, r0
    3efc:	4689      	mov	r9, r1
	name_id = cf->last_name_id + 1;
    3efe:	b2a4      	uxth	r4, r4
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3f00:	f100 0608 	add.w	r6, r0, #8
		name_id--;
    3f04:	1e65      	subs	r5, r4, #1
    3f06:	b2ad      	uxth	r5, r5
		if (name_id == NVS_NAMECNT_ID) {
    3f08:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    3f0c:	d045      	beq.n	3f9a <settings_nvs_load+0xae>
		rc1 = nvs_read(&cf->cf_nvs, name_id, &name, sizeof(name));
    3f0e:	234a      	movs	r3, #74	; 0x4a
    3f10:	aa05      	add	r2, sp, #20
    3f12:	4629      	mov	r1, r5
    3f14:	4630      	mov	r0, r6
    3f16:	f022 f945 	bl	261a4 <nvs_read>
    3f1a:	f504 547f 	add.w	r4, r4, #16320	; 0x3fc0
    3f1e:	343f      	adds	r4, #63	; 0x3f
    3f20:	b2a4      	uxth	r4, r4
    3f22:	4607      	mov	r7, r0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3f24:	4621      	mov	r1, r4
    3f26:	2301      	movs	r3, #1
    3f28:	f10d 020b 	add.w	r2, sp, #11
    3f2c:	4630      	mov	r0, r6
    3f2e:	f022 f939 	bl	261a4 <nvs_read>
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3f32:	2f00      	cmp	r7, #0
		rc2 = nvs_read(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET,
    3f34:	4601      	mov	r1, r0
		if ((rc1 <= 0) && (rc2 <= 0)) {
    3f36:	dc03      	bgt.n	3f40 <settings_nvs_load+0x54>
    3f38:	2800      	cmp	r0, #0
    3f3a:	dc03      	bgt.n	3f44 <settings_nvs_load+0x58>
{
    3f3c:	462c      	mov	r4, r5
    3f3e:	e7e1      	b.n	3f04 <settings_nvs_load+0x18>
		if ((rc1 <= 0) || (rc2 <= 0)) {
    3f40:	2800      	cmp	r0, #0
    3f42:	dc16      	bgt.n	3f72 <settings_nvs_load+0x86>
			if (name_id == cf->last_name_id) {
    3f44:	f8b8 3038 	ldrh.w	r3, [r8, #56]	; 0x38
    3f48:	42ab      	cmp	r3, r5
    3f4a:	d109      	bne.n	3f60 <settings_nvs_load+0x74>
				cf->last_name_id--;
    3f4c:	4642      	mov	r2, r8
    3f4e:	1e6b      	subs	r3, r5, #1
    3f50:	f822 3f38 	strh.w	r3, [r2, #56]!
				nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
    3f54:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    3f58:	2302      	movs	r3, #2
    3f5a:	4630      	mov	r0, r6
    3f5c:	f7ff fcc4 	bl	38e8 <nvs_write>
			nvs_delete(&cf->cf_nvs, name_id);
    3f60:	4629      	mov	r1, r5
    3f62:	4630      	mov	r0, r6
    3f64:	f022 f91a 	bl	2619c <nvs_delete>
			nvs_delete(&cf->cf_nvs, name_id + NVS_NAME_ID_OFFSET);
    3f68:	4621      	mov	r1, r4
    3f6a:	4630      	mov	r0, r6
    3f6c:	f022 f916 	bl	2619c <nvs_delete>
			continue;
    3f70:	e7e4      	b.n	3f3c <settings_nvs_load+0x50>
		name[rc1] = '\0';
    3f72:	ab18      	add	r3, sp, #96	; 0x60
    3f74:	441f      	add	r7, r3
    3f76:	2300      	movs	r3, #0
    3f78:	f807 3c4c 	strb.w	r3, [r7, #-76]
		ret = settings_call_set_handler(
    3f7c:	4652      	mov	r2, sl
    3f7e:	f8cd 9000 	str.w	r9, [sp]
    3f82:	ab03      	add	r3, sp, #12
    3f84:	a805      	add	r0, sp, #20
		read_fn_arg.fs = &cf->cf_nvs;
    3f86:	9603      	str	r6, [sp, #12]
		read_fn_arg.id = name_id + NVS_NAME_ID_OFFSET;
    3f88:	f8ad 4010 	strh.w	r4, [sp, #16]
		ret = settings_call_set_handler(
    3f8c:	f7ff ff20 	bl	3dd0 <settings_call_set_handler>
			name, rc2,
			settings_nvs_read_fn, &read_fn_arg,
			(void *)arg);
		if (ret) {
    3f90:	2800      	cmp	r0, #0
    3f92:	d0d3      	beq.n	3f3c <settings_nvs_load+0x50>
			break;
		}
	}
	return ret;
}
    3f94:	b018      	add	sp, #96	; 0x60
    3f96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3f9a:	2000      	movs	r0, #0
	return ret;
    3f9c:	e7fa      	b.n	3f94 <settings_nvs_load+0xa8>
    3f9e:	bf00      	nop
    3fa0:	00026271 	.word	0x00026271

00003fa4 <settings_backend_init>:
	LOG_DBG("Initialized");
	return 0;
}

int settings_backend_init(void)
{
    3fa4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc;
	uint16_t cnt = 0;
	size_t nvs_sector_size, nvs_size = 0;
	const struct flash_area *fa;
	struct flash_sector hw_flash_sector;
	uint32_t sector_cnt = 1;
    3fa6:	2301      	movs	r3, #1

	rc = flash_area_open(FLASH_AREA_ID(storage), &fa);
    3fa8:	4669      	mov	r1, sp
    3faa:	2004      	movs	r0, #4
	uint32_t sector_cnt = 1;
    3fac:	9301      	str	r3, [sp, #4]
	rc = flash_area_open(FLASH_AREA_ID(storage), &fa);
    3fae:	f7ff fdd5 	bl	3b5c <flash_area_open>
	if (rc) {
    3fb2:	4604      	mov	r4, r0
    3fb4:	2800      	cmp	r0, #0
    3fb6:	d136      	bne.n	4026 <settings_backend_init+0x82>
		return rc;
	}

	rc = flash_area_get_sectors(FLASH_AREA_ID(storage), &sector_cnt,
    3fb8:	aa02      	add	r2, sp, #8
    3fba:	a901      	add	r1, sp, #4
    3fbc:	2004      	movs	r0, #4
    3fbe:	f7ff fdeb 	bl	3b98 <flash_area_get_sectors>
				    &hw_flash_sector);
	if (rc == -ENODEV) {
    3fc2:	f110 0f13 	cmn.w	r0, #19
	rc = flash_area_get_sectors(FLASH_AREA_ID(storage), &sector_cnt,
    3fc6:	4604      	mov	r4, r0
	if (rc == -ENODEV) {
    3fc8:	d02d      	beq.n	4026 <settings_backend_init+0x82>
		return rc;
	} else if (rc != 0 && rc != -ENOMEM) {
    3fca:	b138      	cbz	r0, 3fdc <settings_backend_init+0x38>
    3fcc:	340c      	adds	r4, #12
    3fce:	d005      	beq.n	3fdc <settings_backend_init+0x38>
		k_panic();
    3fd0:	4040      	eors	r0, r0
    3fd2:	f380 8811 	msr	BASEPRI, r0
    3fd6:	f04f 0004 	mov.w	r0, #4
    3fda:	df02      	svc	2
	}

	nvs_sector_size = CONFIG_SETTINGS_NVS_SECTOR_SIZE_MULT *
    3fdc:	9903      	ldr	r1, [sp, #12]
			  hw_flash_sector.fs_size;

	if (nvs_sector_size > UINT16_MAX) {
    3fde:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    3fe2:	d223      	bcs.n	402c <settings_backend_init+0x88>
		return -EDOM;
	}

	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
		nvs_size += nvs_sector_size;
		if (nvs_size > fa->fa_size) {
    3fe4:	9a00      	ldr	r2, [sp, #0]
    3fe6:	2300      	movs	r3, #0
    3fe8:	6895      	ldr	r5, [r2, #8]
	size_t nvs_sector_size, nvs_size = 0;
    3fea:	4618      	mov	r0, r3
		nvs_size += nvs_sector_size;
    3fec:	4408      	add	r0, r1
		if (nvs_size > fa->fa_size) {
    3fee:	4285      	cmp	r5, r0
    3ff0:	b29c      	uxth	r4, r3
    3ff2:	d303      	bcc.n	3ffc <settings_backend_init+0x58>
	while (cnt < CONFIG_SETTINGS_NVS_SECTOR_COUNT) {
    3ff4:	3301      	adds	r3, #1
    3ff6:	2b08      	cmp	r3, #8
    3ff8:	d1f8      	bne.n	3fec <settings_backend_init+0x48>
    3ffa:	461c      	mov	r4, r3
		}
		cnt++;
	}

	/* define the nvs file system using the page_info */
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    3ffc:	4d0d      	ldr	r5, [pc, #52]	; (4034 <settings_backend_init+0x90>)
	default_settings_nvs.cf_nvs.sector_count = cnt;
	default_settings_nvs.cf_nvs.offset = fa->fa_off;
    3ffe:	6853      	ldr	r3, [r2, #4]
    4000:	60ab      	str	r3, [r5, #8]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;

	rc = settings_nvs_backend_init(&default_settings_nvs);
    4002:	4628      	mov	r0, r5
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    4004:	68d3      	ldr	r3, [r2, #12]
	default_settings_nvs.cf_nvs.sector_count = cnt;
    4006:	82ec      	strh	r4, [r5, #22]
	default_settings_nvs.cf_nvs.sector_size = nvs_sector_size;
    4008:	82a9      	strh	r1, [r5, #20]
	default_settings_nvs.flash_dev_name = fa->fa_dev_name;
    400a:	63eb      	str	r3, [r5, #60]	; 0x3c
	rc = settings_nvs_backend_init(&default_settings_nvs);
    400c:	f022 f9c7 	bl	2639e <settings_nvs_backend_init>
	if (rc) {
    4010:	4604      	mov	r4, r0
    4012:	b940      	cbnz	r0, 4026 <settings_backend_init+0x82>
	cf->cf_store.cs_itf = &settings_nvs_itf;
    4014:	4e08      	ldr	r6, [pc, #32]	; (4038 <settings_backend_init+0x94>)
    4016:	606e      	str	r6, [r5, #4]
	settings_src_register(&cf->cf_store);
    4018:	4628      	mov	r0, r5
    401a:	f7ff fe17 	bl	3c4c <settings_src_register>
	settings_dst_register(&cf->cf_store);
    401e:	4628      	mov	r0, r5
	cf->cf_store.cs_itf = &settings_nvs_itf;
    4020:	606e      	str	r6, [r5, #4]
	settings_dst_register(&cf->cf_store);
    4022:	f7ff fe21 	bl	3c68 <settings_dst_register>
	}

	rc = settings_nvs_dst(&default_settings_nvs);

	return rc;
}
    4026:	4620      	mov	r0, r4
    4028:	b004      	add	sp, #16
    402a:	bd70      	pop	{r4, r5, r6, pc}
		return -EDOM;
    402c:	f06f 0420 	mvn.w	r4, #32
    4030:	e7f9      	b.n	4026 <settings_backend_init+0x82>
    4032:	bf00      	nop
    4034:	2000255c 	.word	0x2000255c
    4038:	20000330 	.word	0x20000330

0000403c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    403c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4040:	4605      	mov	r5, r0
	__asm__ volatile(
    4042:	f04f 0320 	mov.w	r3, #32
    4046:	f3ef 8611 	mrs	r6, BASEPRI
    404a:	f383 8812 	msr	BASEPRI_MAX, r3
    404e:	f3bf 8f6f 	isb	sy
	return list->head;
    4052:	4b0e      	ldr	r3, [pc, #56]	; (408c <pm_state_notify+0x50>)
    4054:	681c      	ldr	r4, [r3, #0]
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    4056:	b19c      	cbz	r4, 4080 <pm_state_notify+0x44>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
    4058:	4f0d      	ldr	r7, [pc, #52]	; (4090 <pm_state_notify+0x54>)
    405a:	f8df 8038 	ldr.w	r8, [pc, #56]	; 4094 <pm_state_notify+0x58>
    405e:	f04f 090c 	mov.w	r9, #12
			callback = notifier->state_exit;
    4062:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    4066:	2d00      	cmp	r5, #0
    4068:	bf08      	it	eq
    406a:	4613      	moveq	r3, r2
		if (callback) {
    406c:	b12b      	cbz	r3, 407a <pm_state_notify+0x3e>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    406e:	f898 2014 	ldrb.w	r2, [r8, #20]
    4072:	fb09 f202 	mul.w	r2, r9, r2
    4076:	5cb8      	ldrb	r0, [r7, r2]
    4078:	4798      	blx	r3
	return node->next;
    407a:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    407c:	2c00      	cmp	r4, #0
    407e:	d1f0      	bne.n	4062 <pm_state_notify+0x26>
	__asm__ volatile(
    4080:	f386 8811 	msr	BASEPRI, r6
    4084:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    4088:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    408c:	2000259c 	.word	0x2000259c
    4090:	200025a4 	.word	0x200025a4
    4094:	2000384c 	.word	0x2000384c

00004098 <atomic_clear_bit.constprop.0>:
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    4098:	0942      	lsrs	r2, r0, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
    409a:	2301      	movs	r3, #1
    409c:	f000 001f 	and.w	r0, r0, #31
    40a0:	fa03 f000 	lsl.w	r0, r3, r0
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40a4:	4b07      	ldr	r3, [pc, #28]	; (40c4 <atomic_clear_bit.constprop.0+0x2c>)
    40a6:	f3bf 8f5b 	dmb	ish
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    40aa:	43c0      	mvns	r0, r0
    40ac:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    40b0:	e853 2f00 	ldrex	r2, [r3]
    40b4:	4002      	ands	r2, r0
    40b6:	e843 2100 	strex	r1, r2, [r3]
    40ba:	2900      	cmp	r1, #0
    40bc:	d1f8      	bne.n	40b0 <atomic_clear_bit.constprop.0+0x18>
    40be:	f3bf 8f5b 	dmb	ish
}
    40c2:	4770      	bx	lr
    40c4:	200025b0 	.word	0x200025b0

000040c8 <pm_system_resume>:

void pm_system_resume(void)
{
    40c8:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
    40ca:	4b1d      	ldr	r3, [pc, #116]	; (4140 <pm_system_resume+0x78>)
    40cc:	7d1c      	ldrb	r4, [r3, #20]
    40ce:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    40d2:	f004 031f 	and.w	r3, r4, #31
    40d6:	2201      	movs	r2, #1
    40d8:	409a      	lsls	r2, r3
    40da:	4b1a      	ldr	r3, [pc, #104]	; (4144 <pm_system_resume+0x7c>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    40dc:	0961      	lsrs	r1, r4, #5
{
    40de:	b085      	sub	sp, #20
    40e0:	43d0      	mvns	r0, r2
    40e2:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    40e6:	e853 1f00 	ldrex	r1, [r3]
    40ea:	ea01 0500 	and.w	r5, r1, r0
    40ee:	e843 5c00 	strex	ip, r5, [r3]
    40f2:	f1bc 0f00 	cmp.w	ip, #0
    40f6:	d1f6      	bne.n	40e6 <pm_system_resume+0x1e>
    40f8:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    40fc:	4211      	tst	r1, r2
    40fe:	d017      	beq.n	4130 <pm_system_resume+0x68>
		exit_pos_ops(z_cpus_pm_state[id]);
    4100:	4d11      	ldr	r5, [pc, #68]	; (4148 <pm_system_resume+0x80>)
    4102:	220c      	movs	r2, #12
    4104:	fb02 5204 	mla	r2, r2, r4, r5
    4108:	ca07      	ldmia	r2, {r0, r1, r2}
    410a:	ab01      	add	r3, sp, #4
    410c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    4110:	4a0e      	ldr	r2, [pc, #56]	; (414c <pm_system_resume+0x84>)
    4112:	b17a      	cbz	r2, 4134 <pm_system_resume+0x6c>
		pm_power_state_exit_post_ops(info);
    4114:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    4118:	f023 fbd4 	bl	278c4 <pm_power_state_exit_post_ops>
		pm_state_notify(false);
    411c:	2000      	movs	r0, #0
    411e:	f7ff ff8d 	bl	403c <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    4122:	230c      	movs	r3, #12
    4124:	435c      	muls	r4, r3
    4126:	192a      	adds	r2, r5, r4
    4128:	2300      	movs	r3, #0
    412a:	512b      	str	r3, [r5, r4]
    412c:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
    4130:	b005      	add	sp, #20
    4132:	bd30      	pop	{r4, r5, pc}
    4134:	f382 8811 	msr	BASEPRI, r2
    4138:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    413c:	e7ee      	b.n	411c <pm_system_resume+0x54>
    413e:	bf00      	nop
    4140:	2000384c 	.word	0x2000384c
    4144:	200025b4 	.word	0x200025b4
    4148:	200025a4 	.word	0x200025a4
    414c:	000278c5 	.word	0x000278c5

00004150 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
    4150:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
    4154:	4b35      	ldr	r3, [pc, #212]	; (422c <pm_system_suspend+0xdc>)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4156:	4a36      	ldr	r2, [pc, #216]	; (4230 <pm_system_suspend+0xe0>)
    4158:	7d1c      	ldrb	r4, [r3, #20]
    415a:	f3bf 8f5b 	dmb	ish
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    415e:	0963      	lsrs	r3, r4, #5
    4160:	ea4f 0983 	mov.w	r9, r3, lsl #2
    4164:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4168:	4d32      	ldr	r5, [pc, #200]	; (4234 <pm_system_suspend+0xe4>)
    416a:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    416e:	f004 081f 	and.w	r8, r4, #31
    4172:	fa43 f308 	asr.w	r3, r3, r8

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_bit(z_cpus_pm_state_forced, id)) {
    4176:	f013 0f01 	tst.w	r3, #1
{
    417a:	b085      	sub	sp, #20
    417c:	4607      	mov	r7, r0
	if (!atomic_test_bit(z_cpus_pm_state_forced, id)) {
    417e:	d10a      	bne.n	4196 <pm_system_suspend+0x46>
		const struct pm_state_info *info;

		info = pm_policy_next_state(id, ticks);
    4180:	4601      	mov	r1, r0
    4182:	4620      	mov	r0, r4
    4184:	f000 f876 	bl	4274 <pm_policy_next_state>
		if (info != NULL) {
    4188:	b128      	cbz	r0, 4196 <pm_system_suspend+0x46>
			z_cpus_pm_state[id] = *info;
    418a:	c807      	ldmia	r0, {r0, r1, r2}
    418c:	230c      	movs	r3, #12
    418e:	fb03 5304 	mla	r3, r3, r4, r5
    4192:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		}
	}

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
    4196:	230c      	movs	r3, #12
    4198:	4363      	muls	r3, r4
    419a:	18ea      	adds	r2, r5, r3
    419c:	5cee      	ldrb	r6, [r5, r3]
    419e:	b936      	cbnz	r6, 41ae <pm_system_suspend+0x5e>
		LOG_DBG("No PM operations done.");
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		ret = false;
		atomic_clear_bit(z_cpus_pm_state_forced, id);
    41a0:	4620      	mov	r0, r4
    41a2:	f7ff ff79 	bl	4098 <atomic_clear_bit.constprop.0>
		ret = false;
    41a6:	4630      	mov	r0, r6
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

end:
	return ret;
}
    41a8:	b005      	add	sp, #20
    41aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ticks != K_TICKS_FOREVER) {
    41ae:	1c7b      	adds	r3, r7, #1
    41b0:	d00f      	beq.n	41d2 <pm_system_suspend+0x82>
			return (uint32_t)((t * to_hz + off) / from_hz);
    41b2:	f8d2 c008 	ldr.w	ip, [r2, #8]
    41b6:	4820      	ldr	r0, [pc, #128]	; (4238 <pm_system_suspend+0xe8>)
    41b8:	4a20      	ldr	r2, [pc, #128]	; (423c <pm_system_suspend+0xec>)
    41ba:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    41be:	2100      	movs	r1, #0
    41c0:	2300      	movs	r3, #0
    41c2:	fbec 0106 	umlal	r0, r1, ip, r6
    41c6:	f7fb ff8b 	bl	e0 <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
    41ca:	2101      	movs	r1, #1
    41cc:	1a38      	subs	r0, r7, r0
    41ce:	f028 ffa1 	bl	2d114 <z_set_timeout_expiry>
	k_sched_lock();
    41d2:	f020 f925 	bl	24420 <k_sched_lock>
	pm_state_notify(true);
    41d6:	2001      	movs	r0, #1
    41d8:	f7ff ff30 	bl	403c <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    41dc:	f3bf 8f5b 	dmb	ish
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    41e0:	2301      	movs	r3, #1
    41e2:	fa03 f808 	lsl.w	r8, r3, r8
    41e6:	4b16      	ldr	r3, [pc, #88]	; (4240 <pm_system_suspend+0xf0>)
    41e8:	4499      	add	r9, r3
    41ea:	e859 3f00 	ldrex	r3, [r9]
    41ee:	ea43 0308 	orr.w	r3, r3, r8
    41f2:	e849 3200 	strex	r2, r3, [r9]
    41f6:	2a00      	cmp	r2, #0
    41f8:	d1f7      	bne.n	41ea <pm_system_suspend+0x9a>
    41fa:	f3bf 8f5b 	dmb	ish
	pm_state_set(z_cpus_pm_state[id]);
    41fe:	230c      	movs	r3, #12
    4200:	fb03 5504 	mla	r5, r3, r4, r5
    4204:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    4208:	ab01      	add	r3, sp, #4
    420a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    420e:	4a0d      	ldr	r2, [pc, #52]	; (4244 <pm_system_suspend+0xf4>)
    4210:	b11a      	cbz	r2, 421a <pm_system_suspend+0xca>
		pm_power_state_set(info);
    4212:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    4216:	f023 fb42 	bl	2789e <pm_power_state_set>
	pm_system_resume();
    421a:	f7ff ff55 	bl	40c8 <pm_system_resume>
	atomic_clear_bit(z_cpus_pm_state_forced, id);
    421e:	4620      	mov	r0, r4
    4220:	f7ff ff3a 	bl	4098 <atomic_clear_bit.constprop.0>
	k_sched_unlock();
    4224:	f020 faca 	bl	247bc <k_sched_unlock>
	bool ret = true;
    4228:	2001      	movs	r0, #1
    422a:	e7bd      	b.n	41a8 <pm_system_suspend+0x58>
    422c:	2000384c 	.word	0x2000384c
    4230:	200025b0 	.word	0x200025b0
    4234:	200025a4 	.word	0x200025a4
    4238:	000f423f 	.word	0x000f423f
    423c:	000f4240 	.word	0x000f4240
    4240:	200025b4 	.word	0x200025b4
    4244:	0002789f 	.word	0x0002789f

00004248 <pm_constraint_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4248:	4b05      	ldr	r3, [pc, #20]	; (4260 <pm_constraint_get+0x18>)
    424a:	f3bf 8f5b 	dmb	ish
    424e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    4252:	f3bf 8f5b 	dmb	ish
__weak bool pm_constraint_get(enum pm_state state)
{
	__ASSERT(state < PM_STATE_COUNT, "Invalid power state!");

	return (atomic_get(&power_state_disable_count[state]) == 0);
}
    4256:	fab0 f080 	clz	r0, r0
    425a:	0940      	lsrs	r0, r0, #5
    425c:	4770      	bx	lr
    425e:	bf00      	nop
    4260:	200025b8 	.word	0x200025b8

00004264 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD(DT_PATH(cpus), NUM_CPU_STATES)
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
    4264:	b908      	cbnz	r0, 426a <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
    4266:	4b02      	ldr	r3, [pc, #8]	; (4270 <pm_state_cpu_get_all+0xc>)
    4268:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
    426a:	2000      	movs	r0, #0
    426c:	4770      	bx	lr
    426e:	bf00      	nop
    4270:	0002df44 	.word	0x0002df44

00004274 <pm_policy_next_state>:

#include <logging/log.h>
LOG_MODULE_DECLARE(pm, CONFIG_PM_LOG_LEVEL);

const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
    4274:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4278:	b085      	sub	sp, #20
    427a:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    427c:	a903      	add	r1, sp, #12
    427e:	f7ff fff1 	bl	4264 <pm_state_cpu_get_all>
    4282:	f8df a074 	ldr.w	sl, [pc, #116]	; 42f8 <pm_policy_next_state+0x84>
    4286:	f8df 8074 	ldr.w	r8, [pc, #116]	; 42fc <pm_policy_next_state+0x88>

	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    428a:	1e44      	subs	r4, r0, #1
    428c:	b224      	sxth	r4, r4
    428e:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    4292:	f04f 0900 	mov.w	r9, #0
    4296:	1c63      	adds	r3, r4, #1
    4298:	d104      	bne.n	42a4 <pm_policy_next_state+0x30>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
    429a:	2500      	movs	r5, #0
}
    429c:	4628      	mov	r0, r5
    429e:	b005      	add	sp, #20
    42a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const struct pm_state_info *state = &cpu_states[i];
    42a4:	9a03      	ldr	r2, [sp, #12]
    42a6:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    42aa:	eb02 0583 	add.w	r5, r2, r3, lsl #2
		if (!pm_constraint_get(state->state)) {
    42ae:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
    42b2:	f7ff ffc9 	bl	4248 <pm_constraint_get>
    42b6:	b1e0      	cbz	r0, 42f2 <pm_policy_next_state+0x7e>
    42b8:	6868      	ldr	r0, [r5, #4]
    42ba:	f04f 0b00 	mov.w	fp, #0
    42be:	46d4      	mov	ip, sl
    42c0:	4659      	mov	r1, fp
    42c2:	fbe0 c107 	umlal	ip, r1, r0, r7
    42c6:	4642      	mov	r2, r8
    42c8:	464b      	mov	r3, r9
    42ca:	4660      	mov	r0, ip
    42cc:	f7fb ff08 	bl	e0 <__aeabi_uldivmod>
    42d0:	9001      	str	r0, [sp, #4]
    42d2:	68a8      	ldr	r0, [r5, #8]
    42d4:	46d4      	mov	ip, sl
    42d6:	4659      	mov	r1, fp
    42d8:	fbe0 c107 	umlal	ip, r1, r0, r7
    42dc:	4642      	mov	r2, r8
    42de:	464b      	mov	r3, r9
    42e0:	4660      	mov	r0, ip
    42e2:	f7fb fefd 	bl	e0 <__aeabi_uldivmod>
		if ((ticks == K_TICKS_FOREVER) ||
    42e6:	1c72      	adds	r2, r6, #1
    42e8:	d0d8      	beq.n	429c <pm_policy_next_state+0x28>
		    (ticks >= (min_residency + exit_latency))) {
    42ea:	9b01      	ldr	r3, [sp, #4]
    42ec:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
    42ee:	42b0      	cmp	r0, r6
    42f0:	d9d4      	bls.n	429c <pm_policy_next_state+0x28>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    42f2:	3c01      	subs	r4, #1
    42f4:	b224      	sxth	r4, r4
    42f6:	e7ce      	b.n	4296 <pm_policy_next_state+0x22>
    42f8:	000f423f 	.word	0x000f423f
    42fc:	000f4240 	.word	0x000f4240

00004300 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
    4300:	4b01      	ldr	r3, [pc, #4]	; (4308 <uECC_get_rng+0x8>)
    4302:	6818      	ldr	r0, [r3, #0]
    4304:	4770      	bx	lr
    4306:	bf00      	nop
    4308:	20000340 	.word	0x20000340

0000430c <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
    430c:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    430e:	2208      	movs	r2, #8
{
    4310:	b089      	sub	sp, #36	; 0x24
	uECC_vli_set(result, product, NUM_ECC_WORDS);
    4312:	f022 fa0e 	bl	26732 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
    4316:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    4318:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
    431a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    431c:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
    431e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    4320:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
    4322:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    4324:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
    4326:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    4328:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    432a:	4613      	mov	r3, r2
    432c:	466a      	mov	r2, sp
{
    432e:	460c      	mov	r4, r1
    4330:	4606      	mov	r6, r0
	tmp[0] = tmp[1] = tmp[2] = 0;
    4332:	2700      	movs	r7, #0
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4334:	4611      	mov	r1, r2
    4336:	4610      	mov	r0, r2
	tmp[0] = tmp[1] = tmp[2] = 0;
    4338:	e9cd 7701 	strd	r7, r7, [sp, #4]
    433c:	9700      	str	r7, [sp, #0]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    433e:	f022 f90e 	bl	2655e <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4342:	4631      	mov	r1, r6
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4344:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4346:	4630      	mov	r0, r6
    4348:	f022 f909 	bl	2655e <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
    434c:	6b21      	ldr	r1, [r4, #48]	; 0x30
    434e:	9103      	str	r1, [sp, #12]
	tmp[4] = product[13];
    4350:	6b61      	ldr	r1, [r4, #52]	; 0x34
    4352:	9104      	str	r1, [sp, #16]
	tmp[5] = product[14];
    4354:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    4356:	9105      	str	r1, [sp, #20]
	tmp[6] = product[15];
    4358:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    435a:	4405      	add	r5, r0
	tmp[7] = 0;
    435c:	e9cd 1706 	strd	r1, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    4360:	4610      	mov	r0, r2
    4362:	4611      	mov	r1, r2
    4364:	f022 f8fb 	bl	2655e <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4368:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
    436a:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    436c:	4630      	mov	r0, r6
    436e:	f022 f8f6 	bl	2655e <uECC_vli_add>
    4372:	4405      	add	r5, r0

	/* s3 */
	tmp[0] = product[8];
    4374:	6a20      	ldr	r0, [r4, #32]
    4376:	9000      	str	r0, [sp, #0]
	tmp[1] = product[9];
    4378:	6a60      	ldr	r0, [r4, #36]	; 0x24
    437a:	9001      	str	r0, [sp, #4]
	tmp[2] = product[10];
    437c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    437e:	9002      	str	r0, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
    4380:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    4382:	9006      	str	r0, [sp, #24]
	tmp[7] = product[15];
    4384:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    4386:	9007      	str	r0, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4388:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    438a:	e9cd 7704 	strd	r7, r7, [sp, #16]
    438e:	9703      	str	r7, [sp, #12]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    4390:	f022 f8e5 	bl	2655e <uECC_vli_add>
    4394:	4405      	add	r5, r0

	/* s4 */
	tmp[0] = product[9];
    4396:	6a60      	ldr	r0, [r4, #36]	; 0x24
    4398:	9000      	str	r0, [sp, #0]
	tmp[1] = product[10];
    439a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
    439c:	f8d4 c038 	ldr.w	ip, [r4, #56]	; 0x38
	tmp[1] = product[10];
    43a0:	9001      	str	r0, [sp, #4]
	tmp[2] = product[11];
    43a2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    43a4:	9002      	str	r0, [sp, #8]
	tmp[4] = product[14];
    43a6:	f8cd c010 	str.w	ip, [sp, #16]
	tmp[3] = product[13];
    43aa:	6b60      	ldr	r0, [r4, #52]	; 0x34
	tmp[5] = product[15];
    43ac:	f8d4 c03c 	ldr.w	ip, [r4, #60]	; 0x3c
	tmp[3] = product[13];
    43b0:	9003      	str	r0, [sp, #12]
	tmp[6] = product[13];
    43b2:	e9cd c005 	strd	ip, r0, [sp, #20]
	tmp[7] = product[8];
    43b6:	6a20      	ldr	r0, [r4, #32]
    43b8:	9007      	str	r0, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
    43ba:	4630      	mov	r0, r6
    43bc:	f022 f8cf 	bl	2655e <uECC_vli_add>
    43c0:	4405      	add	r5, r0

	/* d1 */
	tmp[0] = product[11];
    43c2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    43c4:	9000      	str	r0, [sp, #0]
	tmp[1] = product[12];
    43c6:	6b20      	ldr	r0, [r4, #48]	; 0x30
    43c8:	9001      	str	r0, [sp, #4]
	tmp[2] = product[13];
    43ca:	6b60      	ldr	r0, [r4, #52]	; 0x34
    43cc:	9002      	str	r0, [sp, #8]
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
    43ce:	6a20      	ldr	r0, [r4, #32]
    43d0:	9006      	str	r0, [sp, #24]
	tmp[7] = product[10];
    43d2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    43d4:	9007      	str	r0, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    43d6:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
    43d8:	e9cd 7704 	strd	r7, r7, [sp, #16]
    43dc:	9703      	str	r7, [sp, #12]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    43de:	f022 f9db 	bl	26798 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
    43e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    43e4:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
    43e6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    43e8:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
    43ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    43ec:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
    43ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    43f0:	9303      	str	r3, [sp, #12]
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
    43f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    43f4:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
    43f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    43f8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    43fa:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    43fc:	2308      	movs	r3, #8
    43fe:	4630      	mov	r0, r6
	tmp[4] = tmp[5] = 0;
    4400:	e9cd 7704 	strd	r7, r7, [sp, #16]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4404:	f022 f9c8 	bl	26798 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
    4408:	6b63      	ldr	r3, [r4, #52]	; 0x34
    440a:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
    440c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    440e:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
    4410:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    4412:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
    4414:	6a23      	ldr	r3, [r4, #32]
    4416:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
    4418:	6a63      	ldr	r3, [r4, #36]	; 0x24
    441a:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
    441c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
    441e:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
    4422:	6b23      	ldr	r3, [r4, #48]	; 0x30
    4424:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4426:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    4428:	2308      	movs	r3, #8
    442a:	4630      	mov	r0, r6
    442c:	f022 f9b4 	bl	26798 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
    4430:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    4432:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
    4434:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = 0;
    4436:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
    443a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    443c:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
    443e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4440:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
    4442:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
    4444:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
    4448:	6b63      	ldr	r3, [r4, #52]	; 0x34
    444a:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    444c:	1a2d      	subs	r5, r5, r0
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
    444e:	2308      	movs	r3, #8
    4450:	4630      	mov	r0, r6
    4452:	f022 f9a1 	bl	26798 <uECC_vli_sub>

	if (carry < 0) {
    4456:	1a2d      	subs	r5, r5, r0
    4458:	d410      	bmi.n	447c <vli_mmod_fast_secp256r1+0x170>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    445a:	4c0d      	ldr	r4, [pc, #52]	; (4490 <vli_mmod_fast_secp256r1+0x184>)
		while (carry || 
    445c:	b935      	cbnz	r5, 446c <vli_mmod_fast_secp256r1+0x160>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
    445e:	2208      	movs	r2, #8
    4460:	4631      	mov	r1, r6
    4462:	4620      	mov	r0, r4
    4464:	f022 f971 	bl	2674a <uECC_vli_cmp_unsafe>
		while (carry || 
    4468:	2801      	cmp	r0, #1
    446a:	d00f      	beq.n	448c <vli_mmod_fast_secp256r1+0x180>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    446c:	2308      	movs	r3, #8
    446e:	4622      	mov	r2, r4
    4470:	4631      	mov	r1, r6
    4472:	4630      	mov	r0, r6
    4474:	f022 f990 	bl	26798 <uECC_vli_sub>
    4478:	1a2d      	subs	r5, r5, r0
    447a:	e7ef      	b.n	445c <vli_mmod_fast_secp256r1+0x150>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
    447c:	4a04      	ldr	r2, [pc, #16]	; (4490 <vli_mmod_fast_secp256r1+0x184>)
    447e:	2308      	movs	r3, #8
    4480:	4631      	mov	r1, r6
    4482:	4630      	mov	r0, r6
    4484:	f022 f86b 	bl	2655e <uECC_vli_add>
		while (carry < 0);
    4488:	182d      	adds	r5, r5, r0
    448a:	d4f8      	bmi.n	447e <vli_mmod_fast_secp256r1+0x172>
		}
	}
}
    448c:	b009      	add	sp, #36	; 0x24
    448e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4490:	0002df48 	.word	0x0002df48

00004494 <sub_bytes>:
static inline void sub_bytes(uint8_t *s)
{
	unsigned int i;

	for (i = 0; i < (Nb * Nk); ++i) {
		s[i] = sbox[s[i]];
    4494:	4904      	ldr	r1, [pc, #16]	; (44a8 <sub_bytes+0x14>)
    4496:	1e43      	subs	r3, r0, #1
    4498:	300f      	adds	r0, #15
    449a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    449e:	5c8a      	ldrb	r2, [r1, r2]
    44a0:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    44a2:	4283      	cmp	r3, r0
    44a4:	d1f9      	bne.n	449a <sub_bytes+0x6>
	}
}
    44a6:	4770      	bx	lr
    44a8:	0002ee7d 	.word	0x0002ee7d

000044ac <tc_aes128_set_encrypt_key>:
{
    44ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
    44ae:	4e26      	ldr	r6, [pc, #152]	; (4548 <tc_aes128_set_encrypt_key+0x9c>)
{
    44b0:	4607      	mov	r7, r0
    44b2:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
    44b4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
    44b6:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
    44b8:	ad01      	add	r5, sp, #4
    44ba:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    44bc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    44be:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    44c0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    44c4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (s == (TCAesKeySched_t) 0) {
    44c8:	4638      	mov	r0, r7
    44ca:	2f00      	cmp	r7, #0
    44cc:	d038      	beq.n	4540 <tc_aes128_set_encrypt_key+0x94>
	} else if (k == (const uint8_t *) 0) {
    44ce:	2c00      	cmp	r4, #0
    44d0:	d038      	beq.n	4544 <tc_aes128_set_encrypt_key+0x98>
    44d2:	1f38      	subs	r0, r7, #4
    44d4:	4621      	mov	r1, r4
    44d6:	4602      	mov	r2, r0
    44d8:	3410      	adds	r4, #16
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    44da:	784b      	ldrb	r3, [r1, #1]
    44dc:	780d      	ldrb	r5, [r1, #0]
    44de:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    44e0:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    44e4:	78cd      	ldrb	r5, [r1, #3]
    44e6:	432b      	orrs	r3, r5
    44e8:	788d      	ldrb	r5, [r1, #2]
	for (i = 0; i < Nk; ++i) {
    44ea:	3104      	adds	r1, #4
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    44ec:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
    44f0:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    44f2:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
    44f6:	d1f0      	bne.n	44da <tc_aes128_set_encrypt_key+0x2e>
			t = subword(rotword(t)) ^ rconst[i/Nk];
    44f8:	4c14      	ldr	r4, [pc, #80]	; (454c <tc_aes128_set_encrypt_key+0xa0>)
    44fa:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
    44fc:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
    44fe:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
    4500:	d116      	bne.n	4530 <tc_aes128_set_encrypt_key+0x84>
			t = subword(rotword(t)) ^ rconst[i/Nk];
    4502:	f3c3 4207 	ubfx	r2, r3, #16, #8
    4506:	5ca5      	ldrb	r5, [r4, r2]
    4508:	0e1a      	lsrs	r2, r3, #24
    450a:	5ca2      	ldrb	r2, [r4, r2]
    450c:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    4510:	f3c3 2507 	ubfx	r5, r3, #8, #8
    4514:	b2db      	uxtb	r3, r3
    4516:	5d65      	ldrb	r5, [r4, r5]
    4518:	5ce3      	ldrb	r3, [r4, r3]
    451a:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    451e:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    4522:	ad0c      	add	r5, sp, #48	; 0x30
    4524:	f021 0303 	bic.w	r3, r1, #3
    4528:	442b      	add	r3, r5
    452a:	f853 3c2c 	ldr.w	r3, [r3, #-44]
    452e:	4053      	eors	r3, r2
		s->words[i] = s->words[i-Nk] ^ t;
    4530:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
    4534:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
    4536:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
    4538:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
    453a:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
    453c:	d1de      	bne.n	44fc <tc_aes128_set_encrypt_key+0x50>
	return TC_CRYPTO_SUCCESS;
    453e:	2001      	movs	r0, #1
}
    4540:	b00d      	add	sp, #52	; 0x34
    4542:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    4544:	4620      	mov	r0, r4
    4546:	e7fb      	b.n	4540 <tc_aes128_set_encrypt_key+0x94>
    4548:	0002dcc0 	.word	0x0002dcc0
    454c:	0002ee7d 	.word	0x0002ee7d

00004550 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    4550:	4901      	ldr	r1, [pc, #4]	; (4558 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    4552:	2210      	movs	r2, #16
	str	r2, [r1]
    4554:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    4556:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    4558:	e000ed10 	.word	0xe000ed10

0000455c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    455c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    455e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    4560:	f380 8811 	msr	BASEPRI, r0
	isb
    4564:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    4568:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    456c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    456e:	b662      	cpsie	i
	isb
    4570:	f3bf 8f6f 	isb	sy

	bx	lr
    4574:	4770      	bx	lr
    4576:	bf00      	nop

00004578 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    4578:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    457a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    457c:	f381 8811 	msr	BASEPRI, r1

	wfe
    4580:	bf20      	wfe

	msr	BASEPRI, r0
    4582:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    4586:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    4588:	4770      	bx	lr
    458a:	bf00      	nop

0000458c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    458c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4590:	b088      	sub	sp, #32
    4592:	4681      	mov	r9, r0
    4594:	af00      	add	r7, sp, #0

	if (esf != NULL) {
    4596:	460c      	mov	r4, r1
    4598:	2900      	cmp	r1, #0
    459a:	d04b      	beq.n	4634 <z_arm_fatal_error+0xa8>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    459c:	46ea      	mov	sl, sp
    459e:	b088      	sub	sp, #32
    45a0:	466d      	mov	r5, sp
    45a2:	e9d1 1200 	ldrd	r1, r2, [r1]
    45a6:	68a3      	ldr	r3, [r4, #8]
    45a8:	4826      	ldr	r0, [pc, #152]	; (4644 <z_arm_fatal_error+0xb8>)
    45aa:	462e      	mov	r6, r5
    45ac:	f04f 0805 	mov.w	r8, #5
    45b0:	e9c5 0104 	strd	r0, r1, [r5, #16]
    45b4:	e9c5 2306 	strd	r2, r3, [r5, #24]
    45b8:	f8c7 8008 	str.w	r8, [r7, #8]
    45bc:	f846 8f0c 	str.w	r8, [r6, #12]!
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    45c0:	4821      	ldr	r0, [pc, #132]	; (4648 <z_arm_fatal_error+0xbc>)
    45c2:	4632      	mov	r2, r6
    45c4:	2300      	movs	r3, #0
    45c6:	f44f 5121 	mov.w	r1, #10304	; 0x2840
    45ca:	f021 fb85 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    45ce:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
    45d2:	6963      	ldr	r3, [r4, #20]
    45d4:	481d      	ldr	r0, [pc, #116]	; (464c <z_arm_fatal_error+0xc0>)
    45d6:	f8c7 8008 	str.w	r8, [r7, #8]
    45da:	46d5      	mov	sp, sl
    45dc:	e9c5 0104 	strd	r0, r1, [r5, #16]
    45e0:	e9c5 2306 	strd	r2, r3, [r5, #24]
    45e4:	46ad      	mov	sp, r5
    45e6:	f8c5 800c 	str.w	r8, [r5, #12]
    45ea:	4817      	ldr	r0, [pc, #92]	; (4648 <z_arm_fatal_error+0xbc>)
    45ec:	4632      	mov	r2, r6
    45ee:	2300      	movs	r3, #0
    45f0:	f44f 5121 	mov.w	r1, #10304	; 0x2840
    45f4:	f021 fb70 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    45f8:	4a15      	ldr	r2, [pc, #84]	; (4650 <z_arm_fatal_error+0xc4>)
    45fa:	69e3      	ldr	r3, [r4, #28]
    45fc:	2503      	movs	r5, #3
    45fe:	e9c7 2306 	strd	r2, r3, [r7, #24]
    4602:	46d5      	mov	sp, sl
    4604:	607d      	str	r5, [r7, #4]
    4606:	617d      	str	r5, [r7, #20]
    4608:	480f      	ldr	r0, [pc, #60]	; (4648 <z_arm_fatal_error+0xbc>)
    460a:	f107 0214 	add.w	r2, r7, #20
    460e:	2300      	movs	r3, #0
    4610:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4614:	f021 fb60 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    4618:	4a0e      	ldr	r2, [pc, #56]	; (4654 <z_arm_fatal_error+0xc8>)
    461a:	69a3      	ldr	r3, [r4, #24]
    461c:	607d      	str	r5, [r7, #4]
    461e:	e9c7 2306 	strd	r2, r3, [r7, #24]
    4622:	617d      	str	r5, [r7, #20]
    4624:	4808      	ldr	r0, [pc, #32]	; (4648 <z_arm_fatal_error+0xbc>)
    4626:	2300      	movs	r3, #0
    4628:	f107 0214 	add.w	r2, r7, #20
    462c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4630:	f021 fb52 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    4634:	4621      	mov	r1, r4
    4636:	4648      	mov	r0, r9
    4638:	f01f f93c 	bl	238b4 <z_fatal_error>
}
    463c:	3720      	adds	r7, #32
    463e:	46bd      	mov	sp, r7
    4640:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4644:	0002ef7d 	.word	0x0002ef7d
    4648:	0002dbf4 	.word	0x0002dbf4
    464c:	0002efac 	.word	0x0002efac
    4650:	0002efdb 	.word	0x0002efdb
    4654:	0002efea 	.word	0x0002efea

00004658 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    4658:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    465a:	2b00      	cmp	r3, #0
    465c:	db08      	blt.n	4670 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    465e:	2201      	movs	r2, #1
    4660:	f000 001f 	and.w	r0, r0, #31
    4664:	fa02 f000 	lsl.w	r0, r2, r0
    4668:	095b      	lsrs	r3, r3, #5
    466a:	4a02      	ldr	r2, [pc, #8]	; (4674 <arch_irq_enable+0x1c>)
    466c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    4670:	4770      	bx	lr
    4672:	bf00      	nop
    4674:	e000e100 	.word	0xe000e100

00004678 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    4678:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    467a:	2b00      	cmp	r3, #0
    467c:	db0d      	blt.n	469a <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    467e:	2201      	movs	r2, #1
    4680:	095b      	lsrs	r3, r3, #5
    4682:	f000 001f 	and.w	r0, r0, #31
    4686:	fa02 f000 	lsl.w	r0, r2, r0
    468a:	3320      	adds	r3, #32
    468c:	4a03      	ldr	r2, [pc, #12]	; (469c <arch_irq_disable+0x24>)
    468e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4692:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4696:	f3bf 8f6f 	isb	sy
}
    469a:	4770      	bx	lr
    469c:	e000e100 	.word	0xe000e100

000046a0 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    46a0:	4b05      	ldr	r3, [pc, #20]	; (46b8 <arch_irq_is_enabled+0x18>)
    46a2:	0942      	lsrs	r2, r0, #5
    46a4:	f000 001f 	and.w	r0, r0, #31
    46a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    46ac:	2301      	movs	r3, #1
    46ae:	fa03 f000 	lsl.w	r0, r3, r0
}
    46b2:	4010      	ands	r0, r2
    46b4:	4770      	bx	lr
    46b6:	bf00      	nop
    46b8:	e000e100 	.word	0xe000e100

000046bc <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    46bc:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    46be:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46c0:	bfa8      	it	ge
    46c2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
    46c6:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46ca:	bfb8      	it	lt
    46cc:	4b06      	ldrlt	r3, [pc, #24]	; (46e8 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46ce:	ea4f 1141 	mov.w	r1, r1, lsl #5
    46d2:	bfac      	ite	ge
    46d4:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46d8:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46dc:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46de:	bfb4      	ite	lt
    46e0:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    46e2:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    46e6:	4770      	bx	lr
    46e8:	e000ed14 	.word	0xe000ed14

000046ec <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
    46ec:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    46ee:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    46f0:	4b04      	ldr	r3, [pc, #16]	; (4704 <_arch_isr_direct_pm+0x18>)
    46f2:	699a      	ldr	r2, [r3, #24]
    46f4:	b11a      	cbz	r2, 46fe <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
    46f6:	2200      	movs	r2, #0
    46f8:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
    46fa:	f028 f9bd 	bl	2ca78 <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    46fe:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    4700:	bd08      	pop	{r3, pc}
    4702:	bf00      	nop
    4704:	2000384c 	.word	0x2000384c

00004708 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    4708:	bf30      	wfi
    b z_SysNmiOnReset
    470a:	f7ff bffd 	b.w	4708 <z_SysNmiOnReset>
    470e:	bf00      	nop

00004710 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4710:	4a0f      	ldr	r2, [pc, #60]	; (4750 <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    4712:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    4714:	4b0f      	ldr	r3, [pc, #60]	; (4754 <z_arm_prep_c+0x44>)
    4716:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    471a:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    471c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4720:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    4724:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    4728:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    472c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    4730:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    4734:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    4738:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
    473c:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    4740:	f01f f962 	bl	23a08 <z_bss_zero>
	z_data_copy();
    4744:	f020 f97e 	bl	24a44 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    4748:	f000 fba8 	bl	4e9c <z_arm_interrupt_init>
	z_cstart();
    474c:	f01f f966 	bl	23a1c <z_cstart>
    4750:	00000000 	.word	0x00000000
    4754:	e000ed00 	.word	0xe000ed00

00004758 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    4758:	4a09      	ldr	r2, [pc, #36]	; (4780 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    475a:	490a      	ldr	r1, [pc, #40]	; (4784 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    475c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    475e:	6809      	ldr	r1, [r1, #0]
    4760:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    4762:	4909      	ldr	r1, [pc, #36]	; (4788 <arch_swap+0x30>)
	_current->arch.basepri = key;
    4764:	6798      	str	r0, [r3, #120]	; 0x78
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    4766:	684b      	ldr	r3, [r1, #4]
    4768:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    476c:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
    476e:	2300      	movs	r3, #0
    4770:	f383 8811 	msr	BASEPRI, r3
    4774:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    4778:	6893      	ldr	r3, [r2, #8]
}
    477a:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
    477c:	4770      	bx	lr
    477e:	bf00      	nop
    4780:	2000384c 	.word	0x2000384c
    4784:	0002ea24 	.word	0x0002ea24
    4788:	e000ed00 	.word	0xe000ed00

0000478c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    478c:	4912      	ldr	r1, [pc, #72]	; (47d8 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    478e:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    4790:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    4794:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    4796:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    479a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    479e:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    47a0:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    47a4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    47a8:	4f0c      	ldr	r7, [pc, #48]	; (47dc <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    47aa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    47ae:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    47b0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    47b2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    47b4:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
    47b6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    47b8:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    47ba:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    47be:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    47c0:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    47c2:	f000 fbad 	bl	4f20 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    47c6:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    47ca:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    47ce:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    47d2:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    47d6:	4770      	bx	lr
    ldr r1, =_kernel
    47d8:	2000384c 	.word	0x2000384c
    ldr v4, =_SCS_ICSR
    47dc:	e000ed04 	.word	0xe000ed04

000047e0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    47e0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    47e4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    47e6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    47ea:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    47ee:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    47f0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    47f4:	2902      	cmp	r1, #2
    beq _oops
    47f6:	d0ff      	beq.n	47f8 <_oops>

000047f8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    47f8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    47fa:	f022 fef2 	bl	275e2 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    47fe:	bd01      	pop	{r0, pc}

00004800 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    4800:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    4804:	9b00      	ldr	r3, [sp, #0]
    4806:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
    480a:	490a      	ldr	r1, [pc, #40]	; (4834 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
    480c:	9b01      	ldr	r3, [sp, #4]
    480e:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    4812:	9b02      	ldr	r3, [sp, #8]
    4814:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
    4818:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    481c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    4820:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
    4824:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    4828:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    482a:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    482c:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    482e:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    4830:	4770      	bx	lr
    4832:	bf00      	nop
    4834:	000253e9 	.word	0x000253e9

00004838 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    4838:	4a09      	ldr	r2, [pc, #36]	; (4860 <z_check_thread_stack_fail+0x28>)
{
    483a:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
    483c:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
    483e:	b170      	cbz	r0, 485e <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    4840:	f113 0f16 	cmn.w	r3, #22
    4844:	6e80      	ldr	r0, [r0, #104]	; 0x68
    4846:	d005      	beq.n	4854 <z_check_thread_stack_fail+0x1c>
    4848:	f1a0 0220 	sub.w	r2, r0, #32
    484c:	429a      	cmp	r2, r3
    484e:	d805      	bhi.n	485c <z_check_thread_stack_fail+0x24>
    4850:	4283      	cmp	r3, r0
    4852:	d203      	bcs.n	485c <z_check_thread_stack_fail+0x24>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    4854:	4281      	cmp	r1, r0
    4856:	bf28      	it	cs
    4858:	2000      	movcs	r0, #0
    485a:	4770      	bx	lr
    485c:	2000      	movs	r0, #0
}
    485e:	4770      	bx	lr
    4860:	2000384c 	.word	0x2000384c

00004864 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    4864:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    4866:	4b09      	ldr	r3, [pc, #36]	; (488c <arch_switch_to_main_thread+0x28>)
    4868:	6098      	str	r0, [r3, #8]
{
    486a:	460d      	mov	r5, r1
    486c:	4614      	mov	r4, r2
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    486e:	f000 fb57 	bl	4f20 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    4872:	4620      	mov	r0, r4
    4874:	f385 8809 	msr	PSP, r5
    4878:	2100      	movs	r1, #0
    487a:	b663      	cpsie	if
    487c:	f381 8811 	msr	BASEPRI, r1
    4880:	f3bf 8f6f 	isb	sy
    4884:	2200      	movs	r2, #0
    4886:	2300      	movs	r3, #0
    4888:	f020 fdae 	bl	253e8 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    488c:	2000384c 	.word	0x2000384c

00004890 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    4890:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    4892:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    4894:	4a0b      	ldr	r2, [pc, #44]	; (48c4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    4896:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    4898:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    489a:	bf1e      	ittt	ne
	movne	r1, #0
    489c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    489e:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    48a0:	f028 f8ea 	blne	2ca78 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    48a4:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    48a6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    48aa:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    48ae:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    48b2:	4905      	ldr	r1, [pc, #20]	; (48c8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    48b4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    48b6:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    48b8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    48ba:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    48be:	4903      	ldr	r1, [pc, #12]	; (48cc <_isr_wrapper+0x3c>)
	bx r1
    48c0:	4708      	bx	r1
    48c2:	0000      	.short	0x0000
	ldr r2, =_kernel
    48c4:	2000384c 	.word	0x2000384c
	ldr r1, =_sw_isr_table
    48c8:	0002d6c0 	.word	0x0002d6c0
	ldr r1, =z_arm_int_exit
    48cc:	000048d1 	.word	0x000048d1

000048d0 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    48d0:	4b04      	ldr	r3, [pc, #16]	; (48e4 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    48d2:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    48d4:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    48d6:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    48d8:	d003      	beq.n	48e2 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    48da:	4903      	ldr	r1, [pc, #12]	; (48e8 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    48dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    48e0:	600a      	str	r2, [r1, #0]

000048e2 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    48e2:	4770      	bx	lr
	ldr r3, =_kernel
    48e4:	2000384c 	.word	0x2000384c
	ldr r1, =_SCS_ICSR
    48e8:	e000ed04 	.word	0xe000ed04

000048ec <bus_fault.constprop.0>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    48ec:	b570      	push	{r4, r5, r6, lr}
    48ee:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
    48f0:	4b3c      	ldr	r3, [pc, #240]	; (49e4 <bus_fault.constprop.0+0xf8>)
    48f2:	9306      	str	r3, [sp, #24]
    48f4:	2402      	movs	r4, #2
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
    48f6:	4606      	mov	r6, r0
    48f8:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
    48fa:	483b      	ldr	r0, [pc, #236]	; (49e8 <bus_fault.constprop.0+0xfc>)
    48fc:	9401      	str	r4, [sp, #4]
    48fe:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4902:	aa05      	add	r2, sp, #20
    4904:	9405      	str	r4, [sp, #20]
    4906:	f022 fe7b 	bl	27600 <z_log_msg2_static_create.constprop.0>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    490a:	4b38      	ldr	r3, [pc, #224]	; (49ec <bus_fault.constprop.0+0x100>)
    490c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    490e:	04d9      	lsls	r1, r3, #19
    4910:	d509      	bpl.n	4926 <bus_fault.constprop.0+0x3a>
		PR_FAULT_INFO("  Stacking error");
    4912:	4b37      	ldr	r3, [pc, #220]	; (49f0 <bus_fault.constprop.0+0x104>)
    4914:	4834      	ldr	r0, [pc, #208]	; (49e8 <bus_fault.constprop.0+0xfc>)
    4916:	9306      	str	r3, [sp, #24]
    4918:	aa05      	add	r2, sp, #20
    491a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    491e:	9401      	str	r4, [sp, #4]
    4920:	9405      	str	r4, [sp, #20]
    4922:	f022 fe6d 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    4926:	4b31      	ldr	r3, [pc, #196]	; (49ec <bus_fault.constprop.0+0x100>)
    4928:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    492a:	051a      	lsls	r2, r3, #20
    492c:	d50a      	bpl.n	4944 <bus_fault.constprop.0+0x58>
		PR_FAULT_INFO("  Unstacking error");
    492e:	4b31      	ldr	r3, [pc, #196]	; (49f4 <bus_fault.constprop.0+0x108>)
    4930:	9306      	str	r3, [sp, #24]
    4932:	482d      	ldr	r0, [pc, #180]	; (49e8 <bus_fault.constprop.0+0xfc>)
    4934:	2302      	movs	r3, #2
    4936:	aa05      	add	r2, sp, #20
    4938:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    493c:	9301      	str	r3, [sp, #4]
    493e:	9305      	str	r3, [sp, #20]
    4940:	f022 fe5e 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    4944:	4c29      	ldr	r4, [pc, #164]	; (49ec <bus_fault.constprop.0+0x100>)
    4946:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4948:	059b      	lsls	r3, r3, #22
    494a:	d51f      	bpl.n	498c <bus_fault.constprop.0+0xa0>
		PR_FAULT_INFO("  Precise data bus error");
    494c:	4b2a      	ldr	r3, [pc, #168]	; (49f8 <bus_fault.constprop.0+0x10c>)
    494e:	4826      	ldr	r0, [pc, #152]	; (49e8 <bus_fault.constprop.0+0xfc>)
    4950:	9306      	str	r3, [sp, #24]
    4952:	aa05      	add	r2, sp, #20
    4954:	2302      	movs	r3, #2
    4956:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    495a:	9301      	str	r3, [sp, #4]
    495c:	9305      	str	r3, [sp, #20]
    495e:	f022 fe4f 	bl	27600 <z_log_msg2_static_create.constprop.0>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    4962:	6ba3      	ldr	r3, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    4964:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    4966:	0410      	lsls	r0, r2, #16
    4968:	d510      	bpl.n	498c <bus_fault.constprop.0+0xa0>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    496a:	4a24      	ldr	r2, [pc, #144]	; (49fc <bus_fault.constprop.0+0x110>)
    496c:	481e      	ldr	r0, [pc, #120]	; (49e8 <bus_fault.constprop.0+0xfc>)
    496e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    4972:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4976:	2303      	movs	r3, #3
    4978:	aa05      	add	r2, sp, #20
    497a:	9301      	str	r3, [sp, #4]
    497c:	9305      	str	r3, [sp, #20]
    497e:	f022 fe3f 	bl	27600 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
    4982:	b11e      	cbz	r6, 498c <bus_fault.constprop.0+0xa0>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    4984:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4986:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    498a:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    498c:	4b17      	ldr	r3, [pc, #92]	; (49ec <bus_fault.constprop.0+0x100>)
    498e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4990:	0559      	lsls	r1, r3, #21
    4992:	d50a      	bpl.n	49aa <bus_fault.constprop.0+0xbe>
		PR_FAULT_INFO("  Imprecise data bus error");
    4994:	4b1a      	ldr	r3, [pc, #104]	; (4a00 <bus_fault.constprop.0+0x114>)
    4996:	9306      	str	r3, [sp, #24]
    4998:	4813      	ldr	r0, [pc, #76]	; (49e8 <bus_fault.constprop.0+0xfc>)
    499a:	2302      	movs	r3, #2
    499c:	aa05      	add	r2, sp, #20
    499e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    49a2:	9301      	str	r3, [sp, #4]
    49a4:	9305      	str	r3, [sp, #20]
    49a6:	f022 fe2b 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    49aa:	4b10      	ldr	r3, [pc, #64]	; (49ec <bus_fault.constprop.0+0x100>)
    49ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    49ae:	05d2      	lsls	r2, r2, #23
    49b0:	d513      	bpl.n	49da <bus_fault.constprop.0+0xee>
		PR_FAULT_INFO("  Instruction bus error");
    49b2:	4b14      	ldr	r3, [pc, #80]	; (4a04 <bus_fault.constprop.0+0x118>)
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    49b4:	9306      	str	r3, [sp, #24]
    49b6:	480c      	ldr	r0, [pc, #48]	; (49e8 <bus_fault.constprop.0+0xfc>)
    49b8:	2302      	movs	r3, #2
    49ba:	aa05      	add	r2, sp, #20
    49bc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    49c0:	9301      	str	r3, [sp, #4]
    49c2:	9305      	str	r3, [sp, #20]
    49c4:	f022 fe1c 	bl	27600 <z_log_msg2_static_create.constprop.0>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    49c8:	4a08      	ldr	r2, [pc, #32]	; (49ec <bus_fault.constprop.0+0x100>)
    49ca:	6a93      	ldr	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    49cc:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    49ce:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    49d2:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    49d4:	7028      	strb	r0, [r5, #0]

	return reason;
}
    49d6:	b008      	add	sp, #32
    49d8:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    49da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    49dc:	049b      	lsls	r3, r3, #18
    49de:	d5f3      	bpl.n	49c8 <bus_fault.constprop.0+0xdc>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    49e0:	4b09      	ldr	r3, [pc, #36]	; (4a08 <bus_fault.constprop.0+0x11c>)
    49e2:	e7e7      	b.n	49b4 <bus_fault.constprop.0+0xc8>
    49e4:	0002f018 	.word	0x0002f018
    49e8:	0002dbf4 	.word	0x0002dbf4
    49ec:	e000ed00 	.word	0xe000ed00
    49f0:	0002f02e 	.word	0x0002f02e
    49f4:	0002f03f 	.word	0x0002f03f
    49f8:	0002f052 	.word	0x0002f052
    49fc:	0002f06b 	.word	0x0002f06b
    4a00:	0002f080 	.word	0x0002f080
    4a04:	0002f09b 	.word	0x0002f09b
    4a08:	0002f0b3 	.word	0x0002f0b3

00004a0c <usage_fault.constprop.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
    4a0c:	b510      	push	{r4, lr}
    4a0e:	b088      	sub	sp, #32
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    4a10:	4b36      	ldr	r3, [pc, #216]	; (4aec <usage_fault.constprop.0+0xe0>)
    4a12:	4837      	ldr	r0, [pc, #220]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4a14:	9306      	str	r3, [sp, #24]
    4a16:	2402      	movs	r4, #2
    4a18:	aa05      	add	r2, sp, #20
    4a1a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4a1e:	9401      	str	r4, [sp, #4]
    4a20:	9405      	str	r4, [sp, #20]
    4a22:	f022 fded 	bl	27600 <z_log_msg2_static_create.constprop.0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    4a26:	4b33      	ldr	r3, [pc, #204]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4a28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a2a:	019b      	lsls	r3, r3, #6
    4a2c:	d509      	bpl.n	4a42 <usage_fault.constprop.0+0x36>
		PR_FAULT_INFO("  Division by zero");
    4a2e:	4b32      	ldr	r3, [pc, #200]	; (4af8 <usage_fault.constprop.0+0xec>)
    4a30:	482f      	ldr	r0, [pc, #188]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4a32:	9306      	str	r3, [sp, #24]
    4a34:	aa05      	add	r2, sp, #20
    4a36:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4a3a:	9401      	str	r4, [sp, #4]
    4a3c:	9405      	str	r4, [sp, #20]
    4a3e:	f022 fddf 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    4a42:	4b2c      	ldr	r3, [pc, #176]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4a44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a46:	01dc      	lsls	r4, r3, #7
    4a48:	d50a      	bpl.n	4a60 <usage_fault.constprop.0+0x54>
		PR_FAULT_INFO("  Unaligned memory access");
    4a4a:	4b2c      	ldr	r3, [pc, #176]	; (4afc <usage_fault.constprop.0+0xf0>)
    4a4c:	9306      	str	r3, [sp, #24]
    4a4e:	4828      	ldr	r0, [pc, #160]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4a50:	2302      	movs	r3, #2
    4a52:	aa05      	add	r2, sp, #20
    4a54:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4a58:	9301      	str	r3, [sp, #4]
    4a5a:	9305      	str	r3, [sp, #20]
    4a5c:	f022 fdd0 	bl	27600 <z_log_msg2_static_create.constprop.0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    4a60:	4b24      	ldr	r3, [pc, #144]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4a62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a64:	0318      	lsls	r0, r3, #12
    4a66:	d50a      	bpl.n	4a7e <usage_fault.constprop.0+0x72>
		PR_FAULT_INFO("  No coprocessor instructions");
    4a68:	4b25      	ldr	r3, [pc, #148]	; (4b00 <usage_fault.constprop.0+0xf4>)
    4a6a:	9306      	str	r3, [sp, #24]
    4a6c:	4820      	ldr	r0, [pc, #128]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4a6e:	2302      	movs	r3, #2
    4a70:	aa05      	add	r2, sp, #20
    4a72:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4a76:	9301      	str	r3, [sp, #4]
    4a78:	9305      	str	r3, [sp, #20]
    4a7a:	f022 fdc1 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    4a7e:	4b1d      	ldr	r3, [pc, #116]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4a80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a82:	0359      	lsls	r1, r3, #13
    4a84:	d50a      	bpl.n	4a9c <usage_fault.constprop.0+0x90>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    4a86:	4b1f      	ldr	r3, [pc, #124]	; (4b04 <usage_fault.constprop.0+0xf8>)
    4a88:	9306      	str	r3, [sp, #24]
    4a8a:	4819      	ldr	r0, [pc, #100]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4a8c:	2302      	movs	r3, #2
    4a8e:	aa05      	add	r2, sp, #20
    4a90:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4a94:	9301      	str	r3, [sp, #4]
    4a96:	9305      	str	r3, [sp, #20]
    4a98:	f022 fdb2 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    4a9c:	4b15      	ldr	r3, [pc, #84]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4a9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4aa0:	039a      	lsls	r2, r3, #14
    4aa2:	d50a      	bpl.n	4aba <usage_fault.constprop.0+0xae>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    4aa4:	4b18      	ldr	r3, [pc, #96]	; (4b08 <usage_fault.constprop.0+0xfc>)
    4aa6:	9306      	str	r3, [sp, #24]
    4aa8:	4811      	ldr	r0, [pc, #68]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4aaa:	2302      	movs	r3, #2
    4aac:	aa05      	add	r2, sp, #20
    4aae:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4ab2:	9301      	str	r3, [sp, #4]
    4ab4:	9305      	str	r3, [sp, #20]
    4ab6:	f022 fda3 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    4aba:	4b0e      	ldr	r3, [pc, #56]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4abc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4abe:	03db      	lsls	r3, r3, #15
    4ac0:	d50a      	bpl.n	4ad8 <usage_fault.constprop.0+0xcc>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    4ac2:	4b12      	ldr	r3, [pc, #72]	; (4b0c <usage_fault.constprop.0+0x100>)
    4ac4:	9306      	str	r3, [sp, #24]
    4ac6:	480a      	ldr	r0, [pc, #40]	; (4af0 <usage_fault.constprop.0+0xe4>)
    4ac8:	2302      	movs	r3, #2
    4aca:	aa05      	add	r2, sp, #20
    4acc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4ad0:	9301      	str	r3, [sp, #4]
    4ad2:	9305      	str	r3, [sp, #20]
    4ad4:	f022 fd94 	bl	27600 <z_log_msg2_static_create.constprop.0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    4ad8:	4a06      	ldr	r2, [pc, #24]	; (4af4 <usage_fault.constprop.0+0xe8>)
    4ada:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4adc:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    4ae0:	ea6f 4313 	mvn.w	r3, r3, lsr #16

	return reason;
}
    4ae4:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    4ae6:	6293      	str	r3, [r2, #40]	; 0x28
}
    4ae8:	b008      	add	sp, #32
    4aea:	bd10      	pop	{r4, pc}
    4aec:	0002f0e2 	.word	0x0002f0e2
    4af0:	0002dbf4 	.word	0x0002dbf4
    4af4:	e000ed00 	.word	0xe000ed00
    4af8:	0002f0fa 	.word	0x0002f0fa
    4afc:	0002f10d 	.word	0x0002f10d
    4b00:	0002f127 	.word	0x0002f127
    4b04:	0002f145 	.word	0x0002f145
    4b08:	0002f16a 	.word	0x0002f16a
    4b0c:	0002f184 	.word	0x0002f184

00004b10 <mem_manage_fault>:
{
    4b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4b14:	b088      	sub	sp, #32
	PR_FAULT_INFO("***** MPU FAULT *****");
    4b16:	4b48      	ldr	r3, [pc, #288]	; (4c38 <mem_manage_fault+0x128>)
    4b18:	9306      	str	r3, [sp, #24]
    4b1a:	2402      	movs	r4, #2
{
    4b1c:	4607      	mov	r7, r0
    4b1e:	4688      	mov	r8, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
    4b20:	4846      	ldr	r0, [pc, #280]	; (4c3c <mem_manage_fault+0x12c>)
    4b22:	9401      	str	r4, [sp, #4]
{
    4b24:	4615      	mov	r5, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
    4b26:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4b2a:	aa05      	add	r2, sp, #20
    4b2c:	9405      	str	r4, [sp, #20]
    4b2e:	f022 fd67 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    4b32:	4b43      	ldr	r3, [pc, #268]	; (4c40 <mem_manage_fault+0x130>)
    4b34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4b36:	06d8      	lsls	r0, r3, #27
    4b38:	d509      	bpl.n	4b4e <mem_manage_fault+0x3e>
		PR_FAULT_INFO("  Stacking error (context area might be"
    4b3a:	4b42      	ldr	r3, [pc, #264]	; (4c44 <mem_manage_fault+0x134>)
    4b3c:	483f      	ldr	r0, [pc, #252]	; (4c3c <mem_manage_fault+0x12c>)
    4b3e:	9306      	str	r3, [sp, #24]
    4b40:	aa05      	add	r2, sp, #20
    4b42:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4b46:	9401      	str	r4, [sp, #4]
    4b48:	9405      	str	r4, [sp, #20]
    4b4a:	f022 fd59 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    4b4e:	4b3c      	ldr	r3, [pc, #240]	; (4c40 <mem_manage_fault+0x130>)
    4b50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4b52:	0719      	lsls	r1, r3, #28
    4b54:	d50a      	bpl.n	4b6c <mem_manage_fault+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    4b56:	4b3c      	ldr	r3, [pc, #240]	; (4c48 <mem_manage_fault+0x138>)
    4b58:	9306      	str	r3, [sp, #24]
    4b5a:	4838      	ldr	r0, [pc, #224]	; (4c3c <mem_manage_fault+0x12c>)
    4b5c:	2302      	movs	r3, #2
    4b5e:	aa05      	add	r2, sp, #20
    4b60:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4b64:	9301      	str	r3, [sp, #4]
    4b66:	9305      	str	r3, [sp, #20]
    4b68:	f022 fd4a 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    4b6c:	4c34      	ldr	r4, [pc, #208]	; (4c40 <mem_manage_fault+0x130>)
    4b6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4b70:	079a      	lsls	r2, r3, #30
    4b72:	d431      	bmi.n	4bd8 <mem_manage_fault+0xc8>
	uint32_t mmfar = -EINVAL;
    4b74:	f06f 0615 	mvn.w	r6, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    4b78:	4b31      	ldr	r3, [pc, #196]	; (4c40 <mem_manage_fault+0x130>)
    4b7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4b7c:	07dc      	lsls	r4, r3, #31
    4b7e:	d50a      	bpl.n	4b96 <mem_manage_fault+0x86>
		PR_FAULT_INFO("  Instruction Access Violation");
    4b80:	4b32      	ldr	r3, [pc, #200]	; (4c4c <mem_manage_fault+0x13c>)
    4b82:	9306      	str	r3, [sp, #24]
    4b84:	482d      	ldr	r0, [pc, #180]	; (4c3c <mem_manage_fault+0x12c>)
    4b86:	2302      	movs	r3, #2
    4b88:	aa05      	add	r2, sp, #20
    4b8a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4b8e:	9301      	str	r3, [sp, #4]
    4b90:	9305      	str	r3, [sp, #20]
    4b92:	f022 fd35 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    4b96:	4b2a      	ldr	r3, [pc, #168]	; (4c40 <mem_manage_fault+0x130>)
    4b98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4b9a:	0698      	lsls	r0, r3, #26
    4b9c:	d50a      	bpl.n	4bb4 <mem_manage_fault+0xa4>
		PR_FAULT_INFO(
    4b9e:	4b2c      	ldr	r3, [pc, #176]	; (4c50 <mem_manage_fault+0x140>)
    4ba0:	9306      	str	r3, [sp, #24]
    4ba2:	4826      	ldr	r0, [pc, #152]	; (4c3c <mem_manage_fault+0x12c>)
    4ba4:	2302      	movs	r3, #2
    4ba6:	aa05      	add	r2, sp, #20
    4ba8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4bac:	9301      	str	r3, [sp, #4]
    4bae:	9305      	str	r3, [sp, #20]
    4bb0:	f022 fd26 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    4bb4:	4b22      	ldr	r3, [pc, #136]	; (4c40 <mem_manage_fault+0x130>)
    4bb6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    4bb8:	06d1      	lsls	r1, r2, #27
    4bba:	d430      	bmi.n	4c1e <mem_manage_fault+0x10e>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    4bbc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    4bbe:	0792      	lsls	r2, r2, #30
    4bc0:	d42d      	bmi.n	4c1e <mem_manage_fault+0x10e>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    4bc2:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    4bc4:	4a1e      	ldr	r2, [pc, #120]	; (4c40 <mem_manage_fault+0x130>)
    4bc6:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4bc8:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    4bcc:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    4bce:	2300      	movs	r3, #0
    4bd0:	702b      	strb	r3, [r5, #0]
}
    4bd2:	b008      	add	sp, #32
    4bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Data Access Violation");
    4bd8:	4b1e      	ldr	r3, [pc, #120]	; (4c54 <mem_manage_fault+0x144>)
    4bda:	9306      	str	r3, [sp, #24]
    4bdc:	4817      	ldr	r0, [pc, #92]	; (4c3c <mem_manage_fault+0x12c>)
    4bde:	2302      	movs	r3, #2
    4be0:	aa05      	add	r2, sp, #20
    4be2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4be6:	9301      	str	r3, [sp, #4]
    4be8:	9305      	str	r3, [sp, #20]
    4bea:	f022 fd09 	bl	27600 <z_log_msg2_static_create.constprop.0>
		uint32_t temp = SCB->MMFAR;
    4bee:	6b66      	ldr	r6, [r4, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    4bf0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4bf2:	061b      	lsls	r3, r3, #24
    4bf4:	d5be      	bpl.n	4b74 <mem_manage_fault+0x64>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    4bf6:	4b18      	ldr	r3, [pc, #96]	; (4c58 <mem_manage_fault+0x148>)
    4bf8:	4810      	ldr	r0, [pc, #64]	; (4c3c <mem_manage_fault+0x12c>)
    4bfa:	e9cd 3606 	strd	r3, r6, [sp, #24]
    4bfe:	aa05      	add	r2, sp, #20
    4c00:	2303      	movs	r3, #3
    4c02:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4c06:	9301      	str	r3, [sp, #4]
    4c08:	9305      	str	r3, [sp, #20]
    4c0a:	f022 fcf9 	bl	27600 <z_log_msg2_static_create.constprop.0>
			if (from_hard_fault != 0) {
    4c0e:	f1b8 0f00 	cmp.w	r8, #0
    4c12:	d0b1      	beq.n	4b78 <mem_manage_fault+0x68>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    4c14:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4c16:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    4c1a:	62a3      	str	r3, [r4, #40]	; 0x28
    4c1c:	e7ac      	b.n	4b78 <mem_manage_fault+0x68>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    4c1e:	685b      	ldr	r3, [r3, #4]
    4c20:	051b      	lsls	r3, r3, #20
    4c22:	d5ce      	bpl.n	4bc2 <mem_manage_fault+0xb2>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    4c24:	4639      	mov	r1, r7
    4c26:	4630      	mov	r0, r6
    4c28:	f7ff fe06 	bl	4838 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    4c2c:	2800      	cmp	r0, #0
    4c2e:	d0c8      	beq.n	4bc2 <mem_manage_fault+0xb2>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    4c30:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    4c34:	2002      	movs	r0, #2
    4c36:	e7c5      	b.n	4bc4 <mem_manage_fault+0xb4>
    4c38:	0002f1af 	.word	0x0002f1af
    4c3c:	0002dbf4 	.word	0x0002dbf4
    4c40:	e000ed00 	.word	0xe000ed00
    4c44:	0002f1c5 	.word	0x0002f1c5
    4c48:	0002f03f 	.word	0x0002f03f
    4c4c:	0002f226 	.word	0x0002f226
    4c50:	0002f0b3 	.word	0x0002f0b3
    4c54:	0002f1f8 	.word	0x0002f1f8
    4c58:	0002f210 	.word	0x0002f210

00004c5c <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    4c5c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    4c5e:	ab0a      	add	r3, sp, #40	; 0x28
    4c60:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    4c62:	9302      	str	r3, [sp, #8]
    4c64:	4b05      	ldr	r3, [pc, #20]	; (4c7c <z_log_msg2_runtime_create.constprop.0+0x20>)
    4c66:	9301      	str	r3, [sp, #4]
    4c68:	2300      	movs	r3, #0
    4c6a:	9300      	str	r3, [sp, #0]
    4c6c:	2201      	movs	r2, #1
    4c6e:	4618      	mov	r0, r3
    4c70:	f7fe fb1a 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    4c74:	b007      	add	sp, #28
    4c76:	f85d fb04 	ldr.w	pc, [sp], #4
    4c7a:	bf00      	nop
    4c7c:	0002f245 	.word	0x0002f245

00004c80 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    4c80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4c84:	4b70      	ldr	r3, [pc, #448]	; (4e48 <z_arm_fault+0x1c8>)
    4c86:	685d      	ldr	r5, [r3, #4]
{
    4c88:	b08f      	sub	sp, #60	; 0x3c
    4c8a:	460f      	mov	r7, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4c8c:	f3c5 0408 	ubfx	r4, r5, #0, #9
    4c90:	f04f 0800 	mov.w	r8, #0
    4c94:	f388 8811 	msr	BASEPRI, r8
    4c98:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    4c9c:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    4ca0:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    4ca4:	d10e      	bne.n	4cc4 <z_arm_fault+0x44>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    4ca6:	f002 030c 	and.w	r3, r2, #12
    4caa:	2b08      	cmp	r3, #8
    4cac:	d10c      	bne.n	4cc8 <z_arm_fault+0x48>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    4cae:	4b67      	ldr	r3, [pc, #412]	; (4e4c <z_arm_fault+0x1cc>)
    4cb0:	930a      	str	r3, [sp, #40]	; 0x28
    4cb2:	4867      	ldr	r0, [pc, #412]	; (4e50 <z_arm_fault+0x1d0>)
    4cb4:	2302      	movs	r3, #2
    4cb6:	aa09      	add	r2, sp, #36	; 0x24
    4cb8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4cbc:	9305      	str	r3, [sp, #20]
    4cbe:	9309      	str	r3, [sp, #36]	; 0x24
    4cc0:	f022 fc9e 	bl	27600 <z_log_msg2_static_create.constprop.0>
		return NULL;
    4cc4:	4647      	mov	r7, r8
    4cc6:	e004      	b.n	4cd2 <z_arm_fault+0x52>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    4cc8:	0712      	lsls	r2, r2, #28
    4cca:	d402      	bmi.n	4cd2 <z_arm_fault+0x52>
			ptr_esf = (z_arch_esf_t *)msp;
    4ccc:	4607      	mov	r7, r0
			*nested_exc = true;
    4cce:	f04f 0801 	mov.w	r8, #1
	*recoverable = false;
    4cd2:	2300      	movs	r3, #0
    4cd4:	f88d 3013 	strb.w	r3, [sp, #19]
	switch (fault) {
    4cd8:	1ee3      	subs	r3, r4, #3
    4cda:	2b09      	cmp	r3, #9
    4cdc:	f200 809a 	bhi.w	4e14 <z_arm_fault+0x194>
    4ce0:	e8df f003 	tbb	[pc, r3]
    4ce4:	878e8a05 	.word	0x878e8a05
    4ce8:	98989898 	.word	0x98989898
    4cec:	9298      	.short	0x9298
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    4cee:	4e56      	ldr	r6, [pc, #344]	; (4e48 <z_arm_fault+0x1c8>)
	PR_FAULT_INFO("***** HARD FAULT *****");
    4cf0:	4b58      	ldr	r3, [pc, #352]	; (4e54 <z_arm_fault+0x1d4>)
    4cf2:	4857      	ldr	r0, [pc, #348]	; (4e50 <z_arm_fault+0x1d0>)
    4cf4:	930a      	str	r3, [sp, #40]	; 0x28
    4cf6:	2502      	movs	r5, #2
    4cf8:	aa09      	add	r2, sp, #36	; 0x24
    4cfa:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4cfe:	9505      	str	r5, [sp, #20]
    4d00:	9509      	str	r5, [sp, #36]	; 0x24
    4d02:	f022 fc7d 	bl	27600 <z_log_msg2_static_create.constprop.0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    4d06:	6af4      	ldr	r4, [r6, #44]	; 0x2c
	*recoverable = false;
    4d08:	f04f 0900 	mov.w	r9, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    4d0c:	402c      	ands	r4, r5
	*recoverable = false;
    4d0e:	f88d 9013 	strb.w	r9, [sp, #19]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    4d12:	d00b      	beq.n	4d2c <z_arm_fault+0xac>
		PR_EXC("  Bus fault on vector table read");
    4d14:	4b50      	ldr	r3, [pc, #320]	; (4e58 <z_arm_fault+0x1d8>)
    4d16:	930a      	str	r3, [sp, #40]	; 0x28
    4d18:	9505      	str	r5, [sp, #20]
    4d1a:	9509      	str	r5, [sp, #36]	; 0x24
	PR_FAULT_INFO(
    4d1c:	484c      	ldr	r0, [pc, #304]	; (4e50 <z_arm_fault+0x1d0>)
    4d1e:	aa09      	add	r2, sp, #36	; 0x24
    4d20:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4d24:	f022 fc6c 	bl	27600 <z_log_msg2_static_create.constprop.0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    4d28:	2400      	movs	r4, #0
}
    4d2a:	e00c      	b.n	4d46 <z_arm_fault+0xc6>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    4d2c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    4d2e:	2b00      	cmp	r3, #0
    4d30:	da24      	bge.n	4d7c <z_arm_fault+0xfc>
		PR_EXC("  Debug event");
    4d32:	4b4a      	ldr	r3, [pc, #296]	; (4e5c <z_arm_fault+0x1dc>)
    4d34:	4846      	ldr	r0, [pc, #280]	; (4e50 <z_arm_fault+0x1d0>)
    4d36:	930a      	str	r3, [sp, #40]	; 0x28
    4d38:	aa09      	add	r2, sp, #36	; 0x24
    4d3a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4d3e:	9505      	str	r5, [sp, #20]
    4d40:	9509      	str	r5, [sp, #36]	; 0x24
    4d42:	f022 fc5d 	bl	27600 <z_log_msg2_static_create.constprop.0>
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    4d46:	f89d 3013 	ldrb.w	r3, [sp, #19]
    4d4a:	b9a3      	cbnz	r3, 4d76 <z_arm_fault+0xf6>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    4d4c:	2220      	movs	r2, #32
    4d4e:	4639      	mov	r1, r7
    4d50:	a806      	add	r0, sp, #24
    4d52:	f022 fd8d 	bl	27870 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    4d56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4d58:	f1b8 0f00 	cmp.w	r8, #0
    4d5c:	d06e      	beq.n	4e3c <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    4d5e:	f3c3 0208 	ubfx	r2, r3, #0, #9
    4d62:	b922      	cbnz	r2, 4d6e <z_arm_fault+0xee>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    4d64:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    4d68:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    4d6c:	930d      	str	r3, [sp, #52]	; 0x34
	}

	z_arm_fatal_error(reason, &esf_copy);
    4d6e:	a906      	add	r1, sp, #24
    4d70:	4620      	mov	r0, r4
    4d72:	f7ff fc0b 	bl	458c <z_arm_fatal_error>
}
    4d76:	b00f      	add	sp, #60	; 0x3c
    4d78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    4d7c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    4d7e:	005b      	lsls	r3, r3, #1
    4d80:	d5e1      	bpl.n	4d46 <z_arm_fault+0xc6>
		PR_EXC("  Fault escalation (see below)");
    4d82:	4b37      	ldr	r3, [pc, #220]	; (4e60 <z_arm_fault+0x1e0>)
    4d84:	4832      	ldr	r0, [pc, #200]	; (4e50 <z_arm_fault+0x1d0>)
    4d86:	930a      	str	r3, [sp, #40]	; 0x28
    4d88:	aa09      	add	r2, sp, #36	; 0x24
    4d8a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    4d8e:	9505      	str	r5, [sp, #20]
    4d90:	9509      	str	r5, [sp, #36]	; 0x24
    4d92:	f022 fc35 	bl	27600 <z_log_msg2_static_create.constprop.0>
	uint16_t fault_insn = *(ret_addr - 1);
    4d96:	69bb      	ldr	r3, [r7, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    4d98:	f833 2c02 	ldrh.w	r2, [r3, #-2]
    4d9c:	f64d 7302 	movw	r3, #57090	; 0xdf02
    4da0:	429a      	cmp	r2, r3
    4da2:	d00a      	beq.n	4dba <z_arm_fault+0x13a>
		} else if (SCB_MMFSR != 0) {
    4da4:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
    4da8:	b1b3      	cbz	r3, 4dd8 <z_arm_fault+0x158>
			reason = mem_manage_fault(esf, 1, recoverable);
    4daa:	f10d 0213 	add.w	r2, sp, #19
    4dae:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    4db0:	4638      	mov	r0, r7
    4db2:	f7ff fead 	bl	4b10 <mem_manage_fault>
    4db6:	4604      	mov	r4, r0
		break;
    4db8:	e7c5      	b.n	4d46 <z_arm_fault+0xc6>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    4dba:	683b      	ldr	r3, [r7, #0]
    4dbc:	4a29      	ldr	r2, [pc, #164]	; (4e64 <z_arm_fault+0x1e4>)
    4dbe:	4824      	ldr	r0, [pc, #144]	; (4e50 <z_arm_fault+0x1d0>)
    4dc0:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    4dc4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4dc8:	2303      	movs	r3, #3
    4dca:	aa09      	add	r2, sp, #36	; 0x24
    4dcc:	9305      	str	r3, [sp, #20]
    4dce:	9309      	str	r3, [sp, #36]	; 0x24
    4dd0:	f022 fc16 	bl	27600 <z_log_msg2_static_create.constprop.0>
			reason = esf->basic.r0;
    4dd4:	683c      	ldr	r4, [r7, #0]
    4dd6:	e7b6      	b.n	4d46 <z_arm_fault+0xc6>
		} else if (SCB_BFSR != 0) {
    4dd8:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
    4ddc:	b12b      	cbz	r3, 4dea <z_arm_fault+0x16a>
			reason = bus_fault(esf, 1, recoverable);
    4dde:	f10d 0113 	add.w	r1, sp, #19
    4de2:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    4de4:	f7ff fd82 	bl	48ec <bus_fault.constprop.0>
    4de8:	e7e5      	b.n	4db6 <z_arm_fault+0x136>
		} else if (SCB_UFSR != 0) {
    4dea:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
    4dec:	b29b      	uxth	r3, r3
    4dee:	2b00      	cmp	r3, #0
    4df0:	d0a9      	beq.n	4d46 <z_arm_fault+0xc6>
		reason = usage_fault(esf);
    4df2:	f7ff fe0b 	bl	4a0c <usage_fault.constprop.0>
    4df6:	e7de      	b.n	4db6 <z_arm_fault+0x136>
		reason = mem_manage_fault(esf, 0, recoverable);
    4df8:	f10d 0213 	add.w	r2, sp, #19
    4dfc:	2100      	movs	r1, #0
    4dfe:	e7d7      	b.n	4db0 <z_arm_fault+0x130>
		reason = bus_fault(esf, 0, recoverable);
    4e00:	f10d 0113 	add.w	r1, sp, #19
    4e04:	2000      	movs	r0, #0
    4e06:	e7ed      	b.n	4de4 <z_arm_fault+0x164>
	PR_FAULT_INFO(
    4e08:	4b17      	ldr	r3, [pc, #92]	; (4e68 <z_arm_fault+0x1e8>)
    4e0a:	930a      	str	r3, [sp, #40]	; 0x28
    4e0c:	2302      	movs	r3, #2
    4e0e:	9305      	str	r3, [sp, #20]
    4e10:	9309      	str	r3, [sp, #36]	; 0x24
    4e12:	e783      	b.n	4d1c <z_arm_fault+0x9c>
	PR_FAULT_INFO("***** %s %d) *****",
    4e14:	4a15      	ldr	r2, [pc, #84]	; (4e6c <z_arm_fault+0x1ec>)
    4e16:	4b16      	ldr	r3, [pc, #88]	; (4e70 <z_arm_fault+0x1f0>)
    4e18:	490d      	ldr	r1, [pc, #52]	; (4e50 <z_arm_fault+0x1d0>)
    4e1a:	f415 7ff8 	tst.w	r5, #496	; 0x1f0
    4e1e:	bf18      	it	ne
    4e20:	4613      	movne	r3, r2
    4e22:	3c10      	subs	r4, #16
    4e24:	e9cd 3402 	strd	r3, r4, [sp, #8]
    4e28:	2400      	movs	r4, #0
    4e2a:	4b12      	ldr	r3, [pc, #72]	; (4e74 <z_arm_fault+0x1f4>)
    4e2c:	9301      	str	r3, [sp, #4]
    4e2e:	9400      	str	r4, [sp, #0]
    4e30:	4623      	mov	r3, r4
    4e32:	2201      	movs	r2, #1
    4e34:	4620      	mov	r0, r4
    4e36:	f7ff ff11 	bl	4c5c <z_log_msg2_runtime_create.constprop.0>
}
    4e3a:	e784      	b.n	4d46 <z_arm_fault+0xc6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    4e3c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    4e40:	f023 0301 	bic.w	r3, r3, #1
    4e44:	e792      	b.n	4d6c <z_arm_fault+0xec>
    4e46:	bf00      	nop
    4e48:	e000ed00 	.word	0xe000ed00
    4e4c:	0002f286 	.word	0x0002f286
    4e50:	0002dbf4 	.word	0x0002dbf4
    4e54:	0002f2b1 	.word	0x0002f2b1
    4e58:	0002f2c8 	.word	0x0002f2c8
    4e5c:	0002f2e9 	.word	0x0002f2e9
    4e60:	0002f2f7 	.word	0x0002f2f7
    4e64:	0002f316 	.word	0x0002f316
    4e68:	0002f332 	.word	0x0002f332
    4e6c:	0002f26d 	.word	0x0002f26d
    4e70:	0002f258 	.word	0x0002f258
    4e74:	0002f245 	.word	0x0002f245

00004e78 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    4e78:	4a02      	ldr	r2, [pc, #8]	; (4e84 <z_arm_fault_init+0xc>)
    4e7a:	6953      	ldr	r3, [r2, #20]
    4e7c:	f043 0310 	orr.w	r3, r3, #16
    4e80:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    4e82:	4770      	bx	lr
    4e84:	e000ed00 	.word	0xe000ed00

00004e88 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    4e88:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    4e8c:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    4e90:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    4e92:	4672      	mov	r2, lr
	bl z_arm_fault
    4e94:	f7ff fef4 	bl	4c80 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    4e98:	bd01      	pop	{r0, pc}
    4e9a:	bf00      	nop

00004e9c <z_arm_interrupt_init>:
    4e9c:	4804      	ldr	r0, [pc, #16]	; (4eb0 <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    4e9e:	2300      	movs	r3, #0
    4ea0:	2120      	movs	r1, #32
    4ea2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    4ea4:	3301      	adds	r3, #1
    4ea6:	2b27      	cmp	r3, #39	; 0x27
    4ea8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    4eac:	d1f9      	bne.n	4ea2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    4eae:	4770      	bx	lr
    4eb0:	e000e100 	.word	0xe000e100

00004eb4 <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    4eb4:	f028 fafa 	bl	2d4ac <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    4eb8:	2020      	movs	r0, #32
    msr BASEPRI, r0
    4eba:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    4ebe:	4808      	ldr	r0, [pc, #32]	; (4ee0 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    4ec0:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    4ec4:	1840      	adds	r0, r0, r1
    msr PSP, r0
    4ec6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    4eca:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    4ece:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    4ed0:	4308      	orrs	r0, r1
    msr CONTROL, r0
    4ed2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    4ed6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    4eda:	f7ff fc19 	bl	4710 <z_arm_prep_c>
    4ede:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    4ee0:	20005c80 	.word	0x20005c80

00004ee4 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
    4ee4:	4b06      	ldr	r3, [pc, #24]	; (4f00 <z_impl_k_thread_abort+0x1c>)
    4ee6:	689b      	ldr	r3, [r3, #8]
    4ee8:	4283      	cmp	r3, r0
    4eea:	d107      	bne.n	4efc <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    4eec:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    4ef0:	b123      	cbz	r3, 4efc <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    4ef2:	4a04      	ldr	r2, [pc, #16]	; (4f04 <z_impl_k_thread_abort+0x20>)
    4ef4:	6853      	ldr	r3, [r2, #4]
    4ef6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    4efa:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
    4efc:	f01f bd3e 	b.w	2497c <z_thread_abort>
    4f00:	2000384c 	.word	0x2000384c
    4f04:	e000ed00 	.word	0xe000ed00

00004f08 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    4f08:	4b02      	ldr	r3, [pc, #8]	; (4f14 <z_arm_configure_static_mpu_regions+0xc>)
    4f0a:	4a03      	ldr	r2, [pc, #12]	; (4f18 <z_arm_configure_static_mpu_regions+0x10>)
    4f0c:	4803      	ldr	r0, [pc, #12]	; (4f1c <z_arm_configure_static_mpu_regions+0x14>)
    4f0e:	2101      	movs	r1, #1
    4f10:	f000 b888 	b.w	5024 <arm_core_mpu_configure_static_mpu_regions>
    4f14:	20010000 	.word	0x20010000
    4f18:	20000000 	.word	0x20000000
    4f1c:	0002dff4 	.word	0x0002dff4

00004f20 <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    4f20:	6e82      	ldr	r2, [r0, #104]	; 0x68
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    4f22:	4b05      	ldr	r3, [pc, #20]	; (4f38 <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
    4f24:	3a20      	subs	r2, #32
	dynamic_regions[region_num].start = guard_start;
    4f26:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    4f28:	4a04      	ldr	r2, [pc, #16]	; (4f3c <z_arm_configure_dynamic_mpu_regions+0x1c>)
    4f2a:	2120      	movs	r1, #32
    4f2c:	e9c3 1201 	strd	r1, r2, [r3, #4]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    4f30:	4618      	mov	r0, r3
    4f32:	2101      	movs	r1, #1
    4f34:	f000 b880 	b.w	5038 <arm_core_mpu_configure_dynamic_mpu_regions>
    4f38:	200025d4 	.word	0x200025d4
    4f3c:	150b0000 	.word	0x150b0000

00004f40 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    4f40:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    4f42:	4f29      	ldr	r7, [pc, #164]	; (4fe8 <mpu_configure_regions+0xa8>)
    4f44:	b089      	sub	sp, #36	; 0x24
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    4f46:	2600      	movs	r6, #0
    4f48:	428e      	cmp	r6, r1
    4f4a:	da17      	bge.n	4f7c <mpu_configure_regions+0x3c>
		if (regions[i].size == 0U) {
    4f4c:	6844      	ldr	r4, [r0, #4]
    4f4e:	2c00      	cmp	r4, #0
    4f50:	d046      	beq.n	4fe0 <mpu_configure_regions+0xa0>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    4f52:	b1e3      	cbz	r3, 4f8e <mpu_configure_regions+0x4e>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
    4f54:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    4f58:	ea14 0f0c 	tst.w	r4, ip
    4f5c:	d011      	beq.n	4f82 <mpu_configure_regions+0x42>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    4f5e:	4b23      	ldr	r3, [pc, #140]	; (4fec <mpu_configure_regions+0xac>)
    4f60:	e9cd 3606 	strd	r3, r6, [sp, #24]
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    4f64:	2303      	movs	r3, #3
    4f66:	9301      	str	r3, [sp, #4]
    4f68:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    4f6a:	4821      	ldr	r0, [pc, #132]	; (4ff0 <mpu_configure_regions+0xb0>)
    4f6c:	aa05      	add	r2, sp, #20
    4f6e:	2300      	movs	r3, #0
    4f70:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    4f74:	f020 feb0 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
    4f78:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    4f7c:	4610      	mov	r0, r2
    4f7e:	b009      	add	sp, #36	; 0x24
    4f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
		&&
    4f82:	2c1f      	cmp	r4, #31
    4f84:	d9eb      	bls.n	4f5e <mpu_configure_regions+0x1e>
		((part->start & (part->size - 1U)) == 0U);
    4f86:	6805      	ldr	r5, [r0, #0]
		&&
    4f88:	ea1c 0f05 	tst.w	ip, r5
    4f8c:	d1e7      	bne.n	4f5e <mpu_configure_regions+0x1e>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    4f8e:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
    4f90:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    4f92:	f8d0 c008 	ldr.w	ip, [r0, #8]
		reg_index = mpu_configure_region(reg_index, &regions[i]);
    4f96:	b2d2      	uxtb	r2, r2
	if (size <= 32U) {
    4f98:	d910      	bls.n	4fbc <mpu_configure_regions+0x7c>
	if (size > (1UL << 31)) {
    4f9a:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    4f9e:	d80f      	bhi.n	4fc0 <mpu_configure_regions+0x80>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    4fa0:	3c01      	subs	r4, #1
    4fa2:	fab4 f484 	clz	r4, r4
    4fa6:	f1c4 041f 	rsb	r4, r4, #31
    4faa:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
    4fac:	2a07      	cmp	r2, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    4fae:	ea4c 0404 	orr.w	r4, ip, r4
    4fb2:	d907      	bls.n	4fc4 <mpu_configure_regions+0x84>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    4fb4:	4b0f      	ldr	r3, [pc, #60]	; (4ff4 <mpu_configure_regions+0xb4>)
    4fb6:	e9cd 3206 	strd	r3, r2, [sp, #24]
    4fba:	e7d3      	b.n	4f64 <mpu_configure_regions+0x24>
		return REGION_32B;
    4fbc:	2408      	movs	r4, #8
    4fbe:	e7f5      	b.n	4fac <mpu_configure_regions+0x6c>
		return REGION_4G;
    4fc0:	243e      	movs	r4, #62	; 0x3e
    4fc2:	e7f3      	b.n	4fac <mpu_configure_regions+0x6c>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4fc4:	f025 051f 	bic.w	r5, r5, #31
				| MPU_RBAR_VALID_Msk | index;
    4fc8:	4315      	orrs	r5, r2
    4fca:	f045 0510 	orr.w	r5, r5, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    4fce:	f044 0401 	orr.w	r4, r4, #1
    4fd2:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    4fd6:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
		reg_index++;
    4fda:	3201      	adds	r2, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    4fdc:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
    4fe0:	3601      	adds	r6, #1
    4fe2:	300c      	adds	r0, #12
    4fe4:	e7b0      	b.n	4f48 <mpu_configure_regions+0x8>
    4fe6:	bf00      	nop
    4fe8:	e000ed00 	.word	0xe000ed00
    4fec:	0002f35a 	.word	0x0002f35a
    4ff0:	0002dbe4 	.word	0x0002dbe4
    4ff4:	0002f37d 	.word	0x0002f37d

00004ff8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    4ff8:	4b04      	ldr	r3, [pc, #16]	; (500c <arm_core_mpu_enable+0x14>)
    4ffa:	2205      	movs	r2, #5
    4ffc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    5000:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    5004:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    5008:	4770      	bx	lr
    500a:	bf00      	nop
    500c:	e000ed00 	.word	0xe000ed00

00005010 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    5010:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    5014:	4b02      	ldr	r3, [pc, #8]	; (5020 <arm_core_mpu_disable+0x10>)
    5016:	2200      	movs	r2, #0
    5018:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    501c:	4770      	bx	lr
    501e:	bf00      	nop
    5020:	e000ed00 	.word	0xe000ed00

00005024 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    5024:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    5026:	4c03      	ldr	r4, [pc, #12]	; (5034 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    5028:	2301      	movs	r3, #1
    502a:	7822      	ldrb	r2, [r4, #0]
    502c:	f7ff ff88 	bl	4f40 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    5030:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
    5032:	bd10      	pop	{r4, pc}
    5034:	20003984 	.word	0x20003984

00005038 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    5038:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    503a:	4a09      	ldr	r2, [pc, #36]	; (5060 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
    503c:	2300      	movs	r3, #0
    503e:	7812      	ldrb	r2, [r2, #0]
    5040:	f7ff ff7e 	bl	4f40 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    5044:	f110 0f16 	cmn.w	r0, #22
    5048:	d003      	beq.n	5052 <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    504a:	4b06      	ldr	r3, [pc, #24]	; (5064 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)
  MPU->RASR = 0U;
    504c:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    504e:	2807      	cmp	r0, #7
    5050:	dd00      	ble.n	5054 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
    5052:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    5054:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  MPU->RASR = 0U;
    5058:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    505c:	3001      	adds	r0, #1
    505e:	e7f6      	b.n	504e <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    5060:	20003984 	.word	0x20003984
    5064:	e000ed00 	.word	0xe000ed00

00005068 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    5068:	4914      	ldr	r1, [pc, #80]	; (50bc <z_arm_mpu_init+0x54>)
    506a:	6808      	ldr	r0, [r1, #0]
    506c:	2808      	cmp	r0, #8
{
    506e:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    5070:	d821      	bhi.n	50b6 <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    5072:	f7ff ffcd 	bl	5010 <arm_core_mpu_disable>
    5076:	4c12      	ldr	r4, [pc, #72]	; (50c0 <z_arm_mpu_init+0x58>)
    5078:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    507a:	2200      	movs	r2, #0
    507c:	4290      	cmp	r0, r2
    507e:	f101 010c 	add.w	r1, r1, #12
    5082:	d105      	bne.n	5090 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    5084:	4b0f      	ldr	r3, [pc, #60]	; (50c4 <z_arm_mpu_init+0x5c>)
    5086:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    5088:	f7ff ffb6 	bl	4ff8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    508c:	2000      	movs	r0, #0
}
    508e:	bd10      	pop	{r4, pc}
    5090:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    5094:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    5098:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    509c:	4313      	orrs	r3, r2
    509e:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    50a2:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    50a6:	f851 3c04 	ldr.w	r3, [r1, #-4]
    50aa:	f043 0301 	orr.w	r3, r3, #1
    50ae:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    50b2:	3201      	adds	r2, #1
    50b4:	e7e2      	b.n	507c <z_arm_mpu_init+0x14>
		return -1;
    50b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    50ba:	e7e8      	b.n	508e <z_arm_mpu_init+0x26>
    50bc:	0002e000 	.word	0x0002e000
    50c0:	e000ed00 	.word	0xe000ed00
    50c4:	20003984 	.word	0x20003984

000050c8 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    50c8:	4b01      	ldr	r3, [pc, #4]	; (50d0 <__stdout_hook_install+0x8>)
    50ca:	6018      	str	r0, [r3, #0]
}
    50cc:	4770      	bx	lr
    50ce:	bf00      	nop
    50d0:	20000344 	.word	0x20000344

000050d4 <nordicsemi_nrf52_init>:
	__asm__ volatile(
    50d4:	f04f 0220 	mov.w	r2, #32
    50d8:	f3ef 8311 	mrs	r3, BASEPRI
    50dc:	f382 8812 	msr	BASEPRI_MAX, r2
    50e0:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    50e4:	4a04      	ldr	r2, [pc, #16]	; (50f8 <nordicsemi_nrf52_init+0x24>)
    50e6:	2101      	movs	r1, #1
    50e8:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
    50ec:	f383 8811 	msr	BASEPRI, r3
    50f0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    50f4:	2000      	movs	r0, #0
    50f6:	4770      	bx	lr
    50f8:	4001e000 	.word	0x4001e000

000050fc <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    50fc:	b120      	cbz	r0, 5108 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    50fe:	4b03      	ldr	r3, [pc, #12]	; (510c <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    5100:	0180      	lsls	r0, r0, #6
    5102:	f043 0301 	orr.w	r3, r3, #1
    5106:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    5108:	4770      	bx	lr
    510a:	bf00      	nop
    510c:	0002dd80 	.word	0x0002dd80

00005110 <pwr_ctrl_init>:
	const char *port;
	uint32_t pin;
};

static int pwr_ctrl_init(const struct device *dev)
{
    5110:	b538      	push	{r3, r4, r5, lr}
	const struct pwr_ctrl_cfg *cfg = dev->config;
    5112:	6844      	ldr	r4, [r0, #4]
	const struct device *gpio;

	gpio = device_get_binding(cfg->port);
    5114:	6820      	ldr	r0, [r4, #0]
    5116:	f01e fb85 	bl	23824 <z_impl_device_get_binding>
	if (!gpio) {
    511a:	b930      	cbnz	r0, 512a <pwr_ctrl_init+0x1a>
		printk("Could not bind device \"%s\"\n", cfg->port);
    511c:	480d      	ldr	r0, [pc, #52]	; (5154 <pwr_ctrl_init+0x44>)
    511e:	6821      	ldr	r1, [r4, #0]
    5120:	f020 f84c 	bl	251bc <printk>
		return -ENODEV;
    5124:	f06f 0012 	mvn.w	r0, #18
	gpio_pin_configure(gpio, cfg->pin, GPIO_OUTPUT_HIGH);

	k_sleep(K_MSEC(1)); /* Wait for the rail to come up and stabilize */

	return 0;
}
    5128:	bd38      	pop	{r3, r4, r5, pc}
	gpio_pin_configure(gpio, cfg->pin, GPIO_OUTPUT_HIGH);
    512a:	6861      	ldr	r1, [r4, #4]
	struct gpio_driver_data *data =
    512c:	6904      	ldr	r4, [r0, #16]
	const struct gpio_driver_api *api =
    512e:	6885      	ldr	r5, [r0, #8]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    5130:	b2c9      	uxtb	r1, r1
    5132:	2301      	movs	r3, #1
    5134:	fa03 f201 	lsl.w	r2, r3, r1
    5138:	6823      	ldr	r3, [r4, #0]
    513a:	ea23 0302 	bic.w	r3, r3, r2
    513e:	6023      	str	r3, [r4, #0]
	return api->pin_configure(port, pin, flags);
    5140:	f44f 6220 	mov.w	r2, #2560	; 0xa00
    5144:	682b      	ldr	r3, [r5, #0]
    5146:	4798      	blx	r3
	return z_impl_k_sleep(timeout);
    5148:	2021      	movs	r0, #33	; 0x21
    514a:	2100      	movs	r1, #0
    514c:	f01f fbe6 	bl	2491c <z_impl_k_sleep>
	return 0;
    5150:	2000      	movs	r0, #0
    5152:	e7e9      	b.n	5128 <pwr_ctrl_init+0x18>
    5154:	0002f3b6 	.word	0x0002f3b6

00005158 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    5158:	4b0e      	ldr	r3, [pc, #56]	; (5194 <bt_hex_real+0x3c>)
    515a:	2940      	cmp	r1, #64	; 0x40
{
    515c:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
    515e:	bf28      	it	cs
    5160:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
    5162:	4c0d      	ldr	r4, [pc, #52]	; (5198 <bt_hex_real+0x40>)
    5164:	1846      	adds	r6, r0, r1
    5166:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
    5168:	42b0      	cmp	r0, r6
    516a:	f103 0302 	add.w	r3, r3, #2
    516e:	d104      	bne.n	517a <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
    5170:	2300      	movs	r3, #0
    5172:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
    5176:	4807      	ldr	r0, [pc, #28]	; (5194 <bt_hex_real+0x3c>)
    5178:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
    517a:	7802      	ldrb	r2, [r0, #0]
    517c:	0912      	lsrs	r2, r2, #4
    517e:	5ca2      	ldrb	r2, [r4, r2]
    5180:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    5184:	f810 2b01 	ldrb.w	r2, [r0], #1
    5188:	f002 020f 	and.w	r2, r2, #15
    518c:	5ca2      	ldrb	r2, [r4, r2]
    518e:	f803 2c01 	strb.w	r2, [r3, #-1]
	for (i = 0; i < len; i++) {
    5192:	e7e9      	b.n	5168 <bt_hex_real+0x10>
    5194:	200039c8 	.word	0x200039c8
    5198:	0002f41e 	.word	0x0002f41e

0000519c <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    519c:	b530      	push	{r4, r5, lr}
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    519e:	7803      	ldrb	r3, [r0, #0]
    51a0:	b08b      	sub	sp, #44	; 0x2c
    51a2:	4604      	mov	r4, r0
    51a4:	ad07      	add	r5, sp, #28
    51a6:	2b03      	cmp	r3, #3
    51a8:	d821      	bhi.n	51ee <bt_addr_le_str_real+0x52>
    51aa:	e8df f003 	tbb	[pc, r3]
    51ae:	1a02      	.short	0x1a02
    51b0:	1e1c      	.short	0x1e1c
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    51b2:	4912      	ldr	r1, [pc, #72]	; (51fc <bt_addr_le_str_real+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    51b4:	4628      	mov	r0, r5
    51b6:	f022 fb13 	bl	277e0 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    51ba:	7863      	ldrb	r3, [r4, #1]
    51bc:	9304      	str	r3, [sp, #16]
    51be:	78a3      	ldrb	r3, [r4, #2]
    51c0:	9303      	str	r3, [sp, #12]
    51c2:	78e3      	ldrb	r3, [r4, #3]
    51c4:	9302      	str	r3, [sp, #8]
    51c6:	7923      	ldrb	r3, [r4, #4]
    51c8:	9301      	str	r3, [sp, #4]
    51ca:	7963      	ldrb	r3, [r4, #5]
    51cc:	9300      	str	r3, [sp, #0]
    51ce:	4a0c      	ldr	r2, [pc, #48]	; (5200 <bt_addr_le_str_real+0x64>)
    51d0:	79a3      	ldrb	r3, [r4, #6]
    51d2:	9505      	str	r5, [sp, #20]
    51d4:	211e      	movs	r1, #30
    51d6:	480b      	ldr	r0, [pc, #44]	; (5204 <bt_addr_le_str_real+0x68>)
    51d8:	f01f fffd 	bl	251d6 <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    51dc:	4809      	ldr	r0, [pc, #36]	; (5204 <bt_addr_le_str_real+0x68>)
    51de:	b00b      	add	sp, #44	; 0x2c
    51e0:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
    51e2:	4909      	ldr	r1, [pc, #36]	; (5208 <bt_addr_le_str_real+0x6c>)
    51e4:	e7e6      	b.n	51b4 <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
    51e6:	4909      	ldr	r1, [pc, #36]	; (520c <bt_addr_le_str_real+0x70>)
    51e8:	e7e4      	b.n	51b4 <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
    51ea:	4909      	ldr	r1, [pc, #36]	; (5210 <bt_addr_le_str_real+0x74>)
    51ec:	e7e2      	b.n	51b4 <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    51ee:	4a09      	ldr	r2, [pc, #36]	; (5214 <bt_addr_le_str_real+0x78>)
    51f0:	210a      	movs	r1, #10
    51f2:	4628      	mov	r0, r5
    51f4:	f01f ffef 	bl	251d6 <snprintk>
		break;
    51f8:	e7df      	b.n	51ba <bt_addr_le_str_real+0x1e>
    51fa:	bf00      	nop
    51fc:	0002f3d9 	.word	0x0002f3d9
    5200:	0002f3fb 	.word	0x0002f3fb
    5204:	200039aa 	.word	0x200039aa
    5208:	0002f3e0 	.word	0x0002f3e0
    520c:	0002f3e7 	.word	0x0002f3e7
    5210:	0002f3f1 	.word	0x0002f3f1
    5214:	00033773 	.word	0x00033773

00005218 <bt_uuid_str_real>:

const char *bt_uuid_str_real(const struct bt_uuid *uuid)
{
    5218:	b510      	push	{r4, lr}
	static char str[BT_UUID_STR_LEN];

	bt_uuid_to_str(uuid, str, sizeof(str));
    521a:	4c03      	ldr	r4, [pc, #12]	; (5228 <bt_uuid_str_real+0x10>)
    521c:	2225      	movs	r2, #37	; 0x25
    521e:	4621      	mov	r1, r4
    5220:	f000 fb34 	bl	588c <bt_uuid_to_str>

	return str;
}
    5224:	4620      	mov	r0, r4
    5226:	bd10      	pop	{r4, pc}
    5228:	20003985 	.word	0x20003985

0000522c <le_gen_dhkey>:
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
}

static uint8_t le_gen_dhkey(uint8_t *key, uint8_t key_type)
{
    522c:	b570      	push	{r4, r5, r6, lr}
    522e:	4c21      	ldr	r4, [pc, #132]	; (52b4 <le_gen_dhkey+0x88>)
    5230:	f3bf 8f5b 	dmb	ish
    5234:	6823      	ldr	r3, [r4, #0]
    5236:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    523a:	07da      	lsls	r2, r3, #31
{
    523c:	4606      	mov	r6, r0
    523e:	460d      	mov	r5, r1
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    5240:	d501      	bpl.n	5246 <le_gen_dhkey+0x1a>
		return BT_HCI_ERR_CMD_DISALLOWED;
    5242:	200c      	movs	r0, #12
			  key_type == BT_HCI_LE_KEY_TYPE_DEBUG);

	k_sem_give(&cmd_sem);

	return BT_HCI_ERR_SUCCESS;
}
    5244:	bd70      	pop	{r4, r5, r6, pc}
	if (key_type > BT_HCI_LE_KEY_TYPE_DEBUG) {
    5246:	2901      	cmp	r1, #1
    5248:	d831      	bhi.n	52ae <le_gen_dhkey+0x82>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    524a:	f3bf 8f5b 	dmb	ish
    524e:	e854 3f00 	ldrex	r3, [r4]
    5252:	f043 0202 	orr.w	r2, r3, #2
    5256:	e844 2100 	strex	r1, r2, [r4]
    525a:	2900      	cmp	r1, #0
    525c:	d1f7      	bne.n	524e <le_gen_dhkey+0x22>
    525e:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
    5262:	079b      	lsls	r3, r3, #30
    5264:	d4ed      	bmi.n	5242 <le_gen_dhkey+0x16>
	sys_memcpy_swap(ecc.public_key_be, key, BT_PUB_KEY_COORD_LEN);
    5266:	4814      	ldr	r0, [pc, #80]	; (52b8 <le_gen_dhkey+0x8c>)
    5268:	4631      	mov	r1, r6
    526a:	f022 fb5a 	bl	27922 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.public_key_be[BT_PUB_KEY_COORD_LEN], &key[BT_PUB_KEY_COORD_LEN],
    526e:	4813      	ldr	r0, [pc, #76]	; (52bc <le_gen_dhkey+0x90>)
    5270:	f106 0120 	add.w	r1, r6, #32
    5274:	f022 fb55 	bl	27922 <sys_memcpy_swap.constprop.0>
    5278:	f3bf 8f5b 	dmb	ish
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	if (val) {
    527c:	b175      	cbz	r5, 529c <le_gen_dhkey+0x70>
    527e:	e854 3f00 	ldrex	r3, [r4]
    5282:	f043 0304 	orr.w	r3, r3, #4
    5286:	e844 3200 	strex	r2, r3, [r4]
    528a:	2a00      	cmp	r2, #0
    528c:	d1f7      	bne.n	527e <le_gen_dhkey+0x52>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    528e:	f3bf 8f5b 	dmb	ish
	z_impl_k_sem_give(sem);
    5292:	480b      	ldr	r0, [pc, #44]	; (52c0 <le_gen_dhkey+0x94>)
    5294:	f01e fe5e 	bl	23f54 <z_impl_k_sem_give>
    5298:	2000      	movs	r0, #0
    529a:	e7d3      	b.n	5244 <le_gen_dhkey+0x18>
    529c:	e854 3f00 	ldrex	r3, [r4]
    52a0:	f023 0304 	bic.w	r3, r3, #4
    52a4:	e844 3200 	strex	r2, r3, [r4]
    52a8:	2a00      	cmp	r2, #0
    52aa:	d0f0      	beq.n	528e <le_gen_dhkey+0x62>
    52ac:	e7f6      	b.n	529c <le_gen_dhkey+0x70>
		return BT_HCI_ERR_INVALID_PARAM;
    52ae:	2012      	movs	r0, #18
    52b0:	e7c8      	b.n	5244 <le_gen_dhkey+0x18>
    52b2:	bf00      	nop
    52b4:	200025e0 	.word	0x200025e0
    52b8:	20003a69 	.word	0x20003a69
    52bc:	20003a89 	.word	0x20003a89
    52c0:	20000efc 	.word	0x20000efc

000052c4 <ecc_thread>:
{
    52c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    52c8:	4e6d      	ldr	r6, [pc, #436]	; (5480 <ecc_thread+0x1bc>)
	return z_impl_k_sem_take(sem, timeout);
    52ca:	4f6e      	ldr	r7, [pc, #440]	; (5484 <ecc_thread+0x1c0>)
    52cc:	b089      	sub	sp, #36	; 0x24
    52ce:	4635      	mov	r5, r6
    52d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    52d4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    52d8:	4638      	mov	r0, r7
    52da:	f01e fe61 	bl	23fa0 <z_impl_k_sem_take>
    52de:	f3bf 8f5b 	dmb	ish
    52e2:	6834      	ldr	r4, [r6, #0]
    52e4:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
    52e8:	f014 0401 	ands.w	r4, r4, #1
    52ec:	d062      	beq.n	53b4 <ecc_thread+0xf0>
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
    52ee:	f8df 9198 	ldr.w	r9, [pc, #408]	; 5488 <ecc_thread+0x1c4>
    52f2:	4c66      	ldr	r4, [pc, #408]	; (548c <ecc_thread+0x1c8>)
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
    52f4:	f8df 8198 	ldr.w	r8, [pc, #408]	; 5490 <ecc_thread+0x1cc>
		rc = uECC_make_key(ecc.public_key_be, ecc.private_key_be,
    52f8:	4866      	ldr	r0, [pc, #408]	; (5494 <ecc_thread+0x1d0>)
    52fa:	464a      	mov	r2, r9
    52fc:	4621      	mov	r1, r4
    52fe:	f021 f882 	bl	26406 <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
    5302:	4603      	mov	r3, r0
    5304:	2800      	cmp	r0, #0
    5306:	d142      	bne.n	538e <ecc_thread+0xca>
			BT_ERR("Failed to create ECC public/private pair");
    5308:	4a63      	ldr	r2, [pc, #396]	; (5498 <ecc_thread+0x1d4>)
    530a:	9206      	str	r2, [sp, #24]
    530c:	2202      	movs	r2, #2
    530e:	9201      	str	r2, [sp, #4]
    5310:	9205      	str	r2, [sp, #20]
    5312:	4862      	ldr	r0, [pc, #392]	; (549c <ecc_thread+0x1d8>)
    5314:	aa05      	add	r2, sp, #20
    5316:	f44f 5182 	mov.w	r1, #4160	; 0x1040
			return BT_HCI_ERR_UNSPECIFIED;
    531a:	f04f 091f 	mov.w	r9, #31
    531e:	f020 fcdb 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    5322:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5326:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    532a:	2001      	movs	r0, #1
    532c:	f000 fb0c 	bl	5948 <bt_buf_get_rx>
 *
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add(struct net_buf *buf, size_t len)
{
	return net_buf_simple_add(&buf->b, len);
    5330:	f100 0808 	add.w	r8, r0, #8
    5334:	2102      	movs	r1, #2
    5336:	4604      	mov	r4, r0
    5338:	4640      	mov	r0, r8
    533a:	f026 fcff 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    533e:	233e      	movs	r3, #62	; 0x3e
    5340:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    5342:	2342      	movs	r3, #66	; 0x42
    5344:	7043      	strb	r3, [r0, #1]
    5346:	2101      	movs	r1, #1
    5348:	4640      	mov	r0, r8
    534a:	f026 fcf7 	bl	2bd3c <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
    534e:	2308      	movs	r3, #8
    5350:	7003      	strb	r3, [r0, #0]
    5352:	2141      	movs	r1, #65	; 0x41
    5354:	4640      	mov	r0, r8
    5356:	f026 fcf1 	bl	2bd3c <net_buf_simple_add>
    535a:	4680      	mov	r8, r0
	evt->status = status;
    535c:	f800 9b01 	strb.w	r9, [r0], #1
	if (status) {
    5360:	f1b9 0f00 	cmp.w	r9, #0
    5364:	d01d      	beq.n	53a2 <ecc_thread+0xde>
		(void)memset(evt->key, 0, sizeof(evt->key));
    5366:	2240      	movs	r2, #64	; 0x40
    5368:	2100      	movs	r1, #0
    536a:	f022 fa8c 	bl	27886 <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    536e:	f3bf 8f5b 	dmb	ish
    5372:	e855 3f00 	ldrex	r3, [r5]
    5376:	f023 0301 	bic.w	r3, r3, #1
    537a:	e845 3200 	strex	r2, r3, [r5]
    537e:	2a00      	cmp	r2, #0
    5380:	d1f7      	bne.n	5372 <ecc_thread+0xae>
    5382:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    5386:	4620      	mov	r0, r4
	bt_recv(buf);
    5388:	f001 fa1e 	bl	67c8 <bt_recv>
	while (true) {
    538c:	e7a0      	b.n	52d0 <ecc_thread+0xc>
	} while (memcmp(ecc.private_key_be, debug_private_key_be, BT_PRIV_KEY_LEN) == 0);
    538e:	2220      	movs	r2, #32
    5390:	4641      	mov	r1, r8
    5392:	4620      	mov	r0, r4
    5394:	f022 fa5b 	bl	2784e <memcmp>
    5398:	2800      	cmp	r0, #0
    539a:	d0ad      	beq.n	52f8 <ecc_thread+0x34>
	return 0;
    539c:	f04f 0900 	mov.w	r9, #0
    53a0:	e7bf      	b.n	5322 <ecc_thread+0x5e>
		sys_memcpy_swap(evt->key, ecc.public_key_be, BT_PUB_KEY_COORD_LEN);
    53a2:	493c      	ldr	r1, [pc, #240]	; (5494 <ecc_thread+0x1d0>)
    53a4:	f022 fabd 	bl	27922 <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[BT_PUB_KEY_COORD_LEN],
    53a8:	3120      	adds	r1, #32
    53aa:	f108 0021 	add.w	r0, r8, #33	; 0x21
    53ae:	f022 fab8 	bl	27922 <sys_memcpy_swap.constprop.0>
    53b2:	e7dc      	b.n	536e <ecc_thread+0xaa>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    53b4:	f3bf 8f5b 	dmb	ish
    53b8:	6833      	ldr	r3, [r6, #0]
    53ba:	f3bf 8f5b 	dmb	ish
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
    53be:	079b      	lsls	r3, r3, #30
    53c0:	d586      	bpl.n	52d0 <ecc_thread+0xc>
	ret = uECC_valid_public_key(ecc.public_key_be, &curve_secp256r1);
    53c2:	4931      	ldr	r1, [pc, #196]	; (5488 <ecc_thread+0x1c4>)
    53c4:	4833      	ldr	r0, [pc, #204]	; (5494 <ecc_thread+0x1d0>)
    53c6:	f021 fed7 	bl	27178 <uECC_valid_public_key>
	if (ret < 0) {
    53ca:	2800      	cmp	r0, #0
    53cc:	da3f      	bge.n	544e <ecc_thread+0x18a>
		BT_ERR("public key is not valid (ret %d)", ret);
    53ce:	4b34      	ldr	r3, [pc, #208]	; (54a0 <ecc_thread+0x1dc>)
    53d0:	e9cd 3006 	strd	r3, r0, [sp, #24]
    53d4:	2303      	movs	r3, #3
    53d6:	9301      	str	r3, [sp, #4]
    53d8:	9305      	str	r3, [sp, #20]
    53da:	4830      	ldr	r0, [pc, #192]	; (549c <ecc_thread+0x1d8>)
    53dc:	4623      	mov	r3, r4
    53de:	aa05      	add	r2, sp, #20
    53e0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    53e4:	f020 fc78 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    53e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    53ec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    53f0:	2001      	movs	r0, #1
    53f2:	f000 faa9 	bl	5948 <bt_buf_get_rx>
    53f6:	f100 0908 	add.w	r9, r0, #8
    53fa:	2102      	movs	r1, #2
    53fc:	4680      	mov	r8, r0
    53fe:	4648      	mov	r0, r9
    5400:	f026 fc9c 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
    5404:	233e      	movs	r3, #62	; 0x3e
    5406:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
    5408:	2322      	movs	r3, #34	; 0x22
    540a:	7043      	strb	r3, [r0, #1]
    540c:	2101      	movs	r1, #1
    540e:	4648      	mov	r0, r9
    5410:	f026 fc94 	bl	2bd3c <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
    5414:	2309      	movs	r3, #9
    5416:	7003      	strb	r3, [r0, #0]
    5418:	2121      	movs	r1, #33	; 0x21
    541a:	4648      	mov	r0, r9
    541c:	f026 fc8e 	bl	2bd3c <net_buf_simple_add>
    5420:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
    5422:	3001      	adds	r0, #1
    5424:	bb34      	cbnz	r4, 5474 <ecc_thread+0x1b0>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
    5426:	221f      	movs	r2, #31
    5428:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0xff, sizeof(evt->dhkey));
    542a:	21ff      	movs	r1, #255	; 0xff
    542c:	2220      	movs	r2, #32
    542e:	f022 fa2a 	bl	27886 <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5432:	f3bf 8f5b 	dmb	ish
    5436:	e855 3f00 	ldrex	r3, [r5]
    543a:	f023 0302 	bic.w	r3, r3, #2
    543e:	e845 3200 	strex	r2, r3, [r5]
    5442:	2a00      	cmp	r2, #0
    5444:	d1f7      	bne.n	5436 <ecc_thread+0x172>
    5446:	f3bf 8f5b 	dmb	ish
	bt_recv(buf);
    544a:	4640      	mov	r0, r8
    544c:	e79c      	b.n	5388 <ecc_thread+0xc4>
		ret = uECC_shared_secret(ecc.public_key_be,
    544e:	490f      	ldr	r1, [pc, #60]	; (548c <ecc_thread+0x1c8>)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5450:	f3bf 8f5b 	dmb	ish
    5454:	6833      	ldr	r3, [r6, #0]
    5456:	480e      	ldr	r0, [pc, #56]	; (5490 <ecc_thread+0x1cc>)
    5458:	f3bf 8f5b 	dmb	ish
    545c:	f013 0f04 	tst.w	r3, #4
    5460:	f101 0220 	add.w	r2, r1, #32
    5464:	4b08      	ldr	r3, [pc, #32]	; (5488 <ecc_thread+0x1c4>)
    5466:	bf18      	it	ne
    5468:	4601      	movne	r1, r0
    546a:	4610      	mov	r0, r2
    546c:	f021 f81a 	bl	264a4 <uECC_shared_secret>
    5470:	4604      	mov	r4, r0
    5472:	e7b9      	b.n	53e8 <ecc_thread+0x124>
		evt->status = 0U;
    5474:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
    5476:	4907      	ldr	r1, [pc, #28]	; (5494 <ecc_thread+0x1d0>)
		evt->status = 0U;
    5478:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey_be, sizeof(ecc.dhkey_be));
    547a:	f022 fa52 	bl	27922 <sys_memcpy_swap.constprop.0>
    547e:	e7d8      	b.n	5432 <ecc_thread+0x16e>
    5480:	200025e0 	.word	0x200025e0
    5484:	20000efc 	.word	0x20000efc
    5488:	0002e028 	.word	0x0002e028
    548c:	20003a49 	.word	0x20003a49
    5490:	0002f48b 	.word	0x0002f48b
    5494:	20003a69 	.word	0x20003a69
    5498:	0002f42f 	.word	0x0002f42f
    549c:	0002dab4 	.word	0x0002dab4
    54a0:	0002f458 	.word	0x0002f458

000054a4 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
    54a4:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    54a6:	7d06      	ldrb	r6, [r0, #20]
    54a8:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
    54aa:	b976      	cbnz	r6, 54ca <bt_hci_ecc_send+0x26>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
    54ac:	6883      	ldr	r3, [r0, #8]

		switch (sys_le16_to_cpu(chdr->opcode)) {
    54ae:	881d      	ldrh	r5, [r3, #0]
    54b0:	f242 0226 	movw	r2, #8230	; 0x2026
    54b4:	4295      	cmp	r5, r2
    54b6:	d045      	beq.n	5544 <bt_hci_ecc_send+0xa0>
    54b8:	d80f      	bhi.n	54da <bt_hci_ecc_send+0x36>
    54ba:	f242 0201 	movw	r2, #8193	; 0x2001
    54be:	4295      	cmp	r5, r2
    54c0:	d04f      	beq.n	5562 <bt_hci_ecc_send+0xbe>
    54c2:	f242 0325 	movw	r3, #8229	; 0x2025
    54c6:	429d      	cmp	r5, r3
    54c8:	d013      	beq.n	54f2 <bt_hci_ecc_send+0x4e>
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
    54ca:	4b2a      	ldr	r3, [pc, #168]	; (5574 <bt_hci_ecc_send+0xd0>)
    54cc:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
    54d0:	4620      	mov	r0, r4
    54d2:	691b      	ldr	r3, [r3, #16]
}
    54d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
    54d8:	4718      	bx	r3
		switch (sys_le16_to_cpu(chdr->opcode)) {
    54da:	f242 035e 	movw	r3, #8286	; 0x205e
    54de:	429d      	cmp	r5, r3
    54e0:	d1f3      	bne.n	54ca <bt_hci_ecc_send+0x26>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
    54e2:	2103      	movs	r1, #3
    54e4:	3008      	adds	r0, #8
    54e6:	f026 fc99 	bl	2be1c <net_buf_simple_pull>
	cmd = (void *)buf->data;
    54ea:	68a0      	ldr	r0, [r4, #8]
	status = le_gen_dhkey(cmd->key, cmd->key_type);
    54ec:	f890 1040 	ldrb.w	r1, [r0, #64]	; 0x40
    54f0:	e02e      	b.n	5550 <bt_hci_ecc_send+0xac>
    54f2:	2103      	movs	r1, #3
    54f4:	3008      	adds	r0, #8
    54f6:	f026 fc91 	bl	2be1c <net_buf_simple_pull>
	net_buf_unref(buf);
    54fa:	4620      	mov	r0, r4
    54fc:	f01b f9ca 	bl	20894 <net_buf_unref>
    5500:	f3bf 8f5b 	dmb	ish
    5504:	4b1c      	ldr	r3, [pc, #112]	; (5578 <bt_hci_ecc_send+0xd4>)
    5506:	681a      	ldr	r2, [r3, #0]
    5508:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
    550c:	0792      	lsls	r2, r2, #30
    550e:	d507      	bpl.n	5520 <bt_hci_ecc_send+0x7c>
		status = BT_HCI_ERR_CMD_DISALLOWED;
    5510:	260c      	movs	r6, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
    5512:	4631      	mov	r1, r6
    5514:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY_V2, status);
    5518:	f022 f9df 	bl	278da <send_cmd_status>
}
    551c:	2000      	movs	r0, #0
    551e:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    5520:	f3bf 8f5b 	dmb	ish
    5524:	e853 2f00 	ldrex	r2, [r3]
    5528:	f042 0101 	orr.w	r1, r2, #1
    552c:	e843 1000 	strex	r0, r1, [r3]
    5530:	2800      	cmp	r0, #0
    5532:	d1f7      	bne.n	5524 <bt_hci_ecc_send+0x80>
    5534:	f3bf 8f5b 	dmb	ish
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
    5538:	07d3      	lsls	r3, r2, #31
    553a:	d4e9      	bmi.n	5510 <bt_hci_ecc_send+0x6c>
	z_impl_k_sem_give(sem);
    553c:	480f      	ldr	r0, [pc, #60]	; (557c <bt_hci_ecc_send+0xd8>)
    553e:	f01e fd09 	bl	23f54 <z_impl_k_sem_give>
}
    5542:	e7e6      	b.n	5512 <bt_hci_ecc_send+0x6e>
    5544:	2103      	movs	r1, #3
    5546:	3008      	adds	r0, #8
    5548:	f026 fc68 	bl	2be1c <net_buf_simple_pull>
	status = le_gen_dhkey(cmd->key, BT_HCI_LE_KEY_TYPE_GENERATED);
    554c:	68a0      	ldr	r0, [r4, #8]
    554e:	4631      	mov	r1, r6
	status = le_gen_dhkey(cmd->key, cmd->key_type);
    5550:	f7ff fe6c 	bl	522c <le_gen_dhkey>
    5554:	4606      	mov	r6, r0
	net_buf_unref(buf);
    5556:	4620      	mov	r0, r4
    5558:	f01b f99c 	bl	20894 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY_V2, status);
    555c:	4631      	mov	r1, r6
    555e:	4628      	mov	r0, r5
    5560:	e7da      	b.n	5518 <bt_hci_ecc_send+0x74>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
    5562:	78da      	ldrb	r2, [r3, #3]
    5564:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    5568:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
    556a:	791a      	ldrb	r2, [r3, #4]
    556c:	f022 0201 	bic.w	r2, r2, #1
    5570:	711a      	strb	r2, [r3, #4]
}
    5572:	e7aa      	b.n	54ca <bt_hci_ecc_send+0x26>
    5574:	20000080 	.word	0x20000080
    5578:	200025e0 	.word	0x200025e0
    557c:	20000efc 	.word	0x20000efc

00005580 <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
    5580:	b510      	push	{r4, lr}
    5582:	b088      	sub	sp, #32
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    5584:	4c0c      	ldr	r4, [pc, #48]	; (55b8 <bt_hci_ecc_init+0x38>)
    5586:	490d      	ldr	r1, [pc, #52]	; (55bc <bt_hci_ecc_init+0x3c>)
    5588:	2200      	movs	r2, #0
    558a:	2300      	movs	r3, #0
    558c:	e9cd 2306 	strd	r2, r3, [sp, #24]
    5590:	2300      	movs	r3, #0
    5592:	220a      	movs	r2, #10
    5594:	e9cd 2303 	strd	r2, r3, [sp, #12]
    5598:	e9cd 3301 	strd	r3, r3, [sp, #4]
    559c:	9300      	str	r3, [sp, #0]
    559e:	f44f 628f 	mov.w	r2, #1144	; 0x478
    55a2:	4b07      	ldr	r3, [pc, #28]	; (55c0 <bt_hci_ecc_init+0x40>)
    55a4:	4620      	mov	r0, r4
    55a6:	f01e fb43 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    55aa:	4906      	ldr	r1, [pc, #24]	; (55c4 <bt_hci_ecc_init+0x44>)
    55ac:	4620      	mov	r0, r4
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_KERNEL_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
    55ae:	b008      	add	sp, #32
    55b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    55b4:	f027 ba59 	b.w	2ca6a <z_impl_k_thread_name_set>
    55b8:	200015e0 	.word	0x200015e0
    55bc:	200042a0 	.word	0x200042a0
    55c0:	000052c5 	.word	0x000052c5
    55c4:	0002f479 	.word	0x0002f479

000055c8 <save_id>:
}

#define ID_DATA_LEN(array) (bt_dev.id_count * sizeof(array[0]))

static void save_id(struct k_work *work)
{
    55c8:	b500      	push	{lr}
    55ca:	b089      	sub	sp, #36	; 0x24
	int err;
	BT_INFO("Saving ID");
    55cc:	4b11      	ldr	r3, [pc, #68]	; (5614 <save_id+0x4c>)
    55ce:	9306      	str	r3, [sp, #24]
    55d0:	2302      	movs	r3, #2
    55d2:	9301      	str	r3, [sp, #4]
    55d4:	9305      	str	r3, [sp, #20]
    55d6:	4810      	ldr	r0, [pc, #64]	; (5618 <save_id+0x50>)
    55d8:	aa05      	add	r2, sp, #20
    55da:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
    55de:	2300      	movs	r3, #0
    55e0:	f020 fb7a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	err = settings_save_one("bt/id", &bt_dev.id_addr,
				ID_DATA_LEN(bt_dev.id_addr));
    55e4:	490d      	ldr	r1, [pc, #52]	; (561c <save_id+0x54>)
	err = settings_save_one("bt/id", &bt_dev.id_addr,
    55e6:	480e      	ldr	r0, [pc, #56]	; (5620 <save_id+0x58>)
    55e8:	79ca      	ldrb	r2, [r1, #7]
    55ea:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    55ee:	f7fe fb07 	bl	3c00 <settings_save_one>
	if (err) {
    55f2:	b160      	cbz	r0, 560e <save_id+0x46>
		BT_ERR("Failed to save ID (err %d)", err);
    55f4:	4b0b      	ldr	r3, [pc, #44]	; (5624 <save_id+0x5c>)
    55f6:	e9cd 3006 	strd	r3, r0, [sp, #24]
    55fa:	2303      	movs	r3, #3
    55fc:	9301      	str	r3, [sp, #4]
    55fe:	9305      	str	r3, [sp, #20]
    5600:	4805      	ldr	r0, [pc, #20]	; (5618 <save_id+0x50>)
    5602:	2300      	movs	r3, #0
    5604:	aa05      	add	r2, sp, #20
    5606:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    560a:	f020 fb65 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	err = settings_save_one("bt/irk", bt_dev.irk, ID_DATA_LEN(bt_dev.irk));
	if (err) {
		BT_ERR("Failed to save IRK (err %d)", err);
	}
#endif
}
    560e:	b009      	add	sp, #36	; 0x24
    5610:	f85d fb04 	ldr.w	pc, [sp], #4
    5614:	0002f4ab 	.word	0x0002f4ab
    5618:	0002db9c 	.word	0x0002db9c
    561c:	20000080 	.word	0x20000080
    5620:	0002f4b5 	.word	0x0002f4b5
    5624:	0002f4bb 	.word	0x0002f4bb

00005628 <set>:
{
    5628:	b5f0      	push	{r4, r5, r6, r7, lr}
    562a:	4616      	mov	r6, r2
    562c:	b089      	sub	sp, #36	; 0x24
    562e:	461f      	mov	r7, r3
	if (!name) {
    5630:	4604      	mov	r4, r0
    5632:	b970      	cbnz	r0, 5652 <set+0x2a>
		BT_ERR("Insufficient number of arguments");
    5634:	4b27      	ldr	r3, [pc, #156]	; (56d4 <set+0xac>)
    5636:	9306      	str	r3, [sp, #24]
    5638:	2302      	movs	r3, #2
    563a:	9301      	str	r3, [sp, #4]
    563c:	9305      	str	r3, [sp, #20]
    563e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    5642:	4603      	mov	r3, r0
    5644:	aa05      	add	r2, sp, #20
    5646:	4824      	ldr	r0, [pc, #144]	; (56d8 <set+0xb0>)
    5648:	f020 fb46 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	return -ENOENT;
    564c:	f06f 0401 	mvn.w	r4, #1
    5650:	e01e      	b.n	5690 <set+0x68>
	len = settings_name_next(name, &next);
    5652:	4669      	mov	r1, sp
    5654:	f020 fdf6 	bl	26244 <settings_name_next>
	if (!strncmp(name, "id", len)) {
    5658:	4920      	ldr	r1, [pc, #128]	; (56dc <set+0xb4>)
	len = settings_name_next(name, &next);
    565a:	4602      	mov	r2, r0
	if (!strncmp(name, "id", len)) {
    565c:	4620      	mov	r0, r4
    565e:	f022 f8e5 	bl	2782c <strncmp>
    5662:	4604      	mov	r4, r0
    5664:	2800      	cmp	r0, #0
    5666:	d1f1      	bne.n	564c <set+0x24>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5668:	f3bf 8f5b 	dmb	ish
    566c:	4d1c      	ldr	r5, [pc, #112]	; (56e0 <set+0xb8>)
    566e:	682b      	ldr	r3, [r5, #0]
    5670:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(bt_dev.flags, BT_DEV_PRESET_ID)) {
    5674:	075b      	lsls	r3, r3, #29
    5676:	d50e      	bpl.n	5696 <set+0x6e>
			BT_WARN("Ignoring identities stored in flash");
    5678:	4b1a      	ldr	r3, [pc, #104]	; (56e4 <set+0xbc>)
    567a:	9306      	str	r3, [sp, #24]
    567c:	2302      	movs	r3, #2
    567e:	9301      	str	r3, [sp, #4]
    5680:	9305      	str	r3, [sp, #20]
    5682:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    5686:	4603      	mov	r3, r0
    5688:	aa05      	add	r2, sp, #20
    568a:	4813      	ldr	r0, [pc, #76]	; (56d8 <set+0xb0>)
    568c:	f020 fb24 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
    5690:	4620      	mov	r0, r4
    5692:	b009      	add	sp, #36	; 0x24
    5694:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = read_cb(cb_arg, &bt_dev.id_addr, sizeof(bt_dev.id_addr));
    5696:	3dcc      	subs	r5, #204	; 0xcc
    5698:	2207      	movs	r2, #7
    569a:	4629      	mov	r1, r5
    569c:	4638      	mov	r0, r7
    569e:	47b0      	blx	r6
		if (len < sizeof(bt_dev.id_addr[0])) {
    56a0:	2806      	cmp	r0, #6
    56a2:	d812      	bhi.n	56ca <set+0xa2>
				BT_ERR("Invalid length ID address in storage");
    56a4:	4b10      	ldr	r3, [pc, #64]	; (56e8 <set+0xc0>)
    56a6:	9306      	str	r3, [sp, #24]
    56a8:	2302      	movs	r3, #2
    56aa:	9301      	str	r3, [sp, #4]
    56ac:	9305      	str	r3, [sp, #20]
    56ae:	480a      	ldr	r0, [pc, #40]	; (56d8 <set+0xb0>)
    56b0:	4623      	mov	r3, r4
    56b2:	aa05      	add	r2, sp, #20
    56b4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    56b8:	f020 fb0e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			(void)memset(bt_dev.id_addr, 0,
    56bc:	2207      	movs	r2, #7
    56be:	4621      	mov	r1, r4
    56c0:	4628      	mov	r0, r5
    56c2:	f022 f8e0 	bl	27886 <memset>
			bt_dev.id_count = 0U;
    56c6:	71ec      	strb	r4, [r5, #7]
    56c8:	e7e2      	b.n	5690 <set+0x68>
			bt_dev.id_count = len / sizeof(bt_dev.id_addr[0]);
    56ca:	2307      	movs	r3, #7
    56cc:	fbb0 f0f3 	udiv	r0, r0, r3
    56d0:	71e8      	strb	r0, [r5, #7]
			for (i = 0; i < bt_dev.id_count; i++) {
    56d2:	e7dd      	b.n	5690 <set+0x68>
    56d4:	0002f4d6 	.word	0x0002f4d6
    56d8:	0002db9c 	.word	0x0002db9c
    56dc:	0002f3ee 	.word	0x0002f3ee
    56e0:	2000014c 	.word	0x2000014c
    56e4:	0002f4f7 	.word	0x0002f4f7
    56e8:	0002f51b 	.word	0x0002f51b

000056ec <bt_settings_encode_key>:
{
    56ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    56f0:	b088      	sub	sp, #32
		snprintk(path, path_size,
    56f2:	799c      	ldrb	r4, [r3, #6]
{
    56f4:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		snprintk(path, path_size,
    56f8:	795d      	ldrb	r5, [r3, #5]
    56fa:	791e      	ldrb	r6, [r3, #4]
    56fc:	78df      	ldrb	r7, [r3, #3]
    56fe:	f893 c002 	ldrb.w	ip, [r3, #2]
    5702:	f893 e001 	ldrb.w	lr, [r3, #1]
    5706:	781b      	ldrb	r3, [r3, #0]
	if (key) {
    5708:	f1b8 0f00 	cmp.w	r8, #0
    570c:	d00e      	beq.n	572c <bt_settings_encode_key+0x40>
		snprintk(path, path_size,
    570e:	e9cd 3806 	strd	r3, r8, [sp, #24]
    5712:	e9cd ce04 	strd	ip, lr, [sp, #16]
    5716:	4613      	mov	r3, r2
    5718:	e9cd 6702 	strd	r6, r7, [sp, #8]
    571c:	e9cd 4500 	strd	r4, r5, [sp]
    5720:	4a08      	ldr	r2, [pc, #32]	; (5744 <bt_settings_encode_key+0x58>)
    5722:	f01f fd58 	bl	251d6 <snprintk>
}
    5726:	b008      	add	sp, #32
    5728:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		snprintk(path, path_size,
    572c:	e9cd e305 	strd	lr, r3, [sp, #20]
    5730:	e9cd 7c03 	strd	r7, ip, [sp, #12]
    5734:	4613      	mov	r3, r2
    5736:	e9cd 5601 	strd	r5, r6, [sp, #4]
    573a:	4a03      	ldr	r2, [pc, #12]	; (5748 <bt_settings_encode_key+0x5c>)
    573c:	9400      	str	r4, [sp, #0]
    573e:	f01f fd4a 	bl	251d6 <snprintk>
}
    5742:	e7f0      	b.n	5726 <bt_settings_encode_key+0x3a>
    5744:	0002f540 	.word	0x0002f540
    5748:	0002f564 	.word	0x0002f564

0000574c <bt_settings_save_id>:

K_WORK_DEFINE(save_id_work, save_id);

void bt_settings_save_id(void)
{
	k_work_submit(&save_id_work);
    574c:	4801      	ldr	r0, [pc, #4]	; (5754 <bt_settings_save_id+0x8>)
    574e:	f01e bd6d 	b.w	2422c <k_work_submit>
    5752:	bf00      	nop
    5754:	20000348 	.word	0x20000348

00005758 <commit>:
}

static int commit(void)
{
    5758:	b570      	push	{r4, r5, r6, lr}
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	if (bt_dev.name[0] == '\0') {
		bt_set_name(CONFIG_BT_DEVICE_NAME);
	}
#endif
	if (!bt_dev.id_count) {
    575a:	4d20      	ldr	r5, [pc, #128]	; (57dc <commit+0x84>)
    575c:	79ee      	ldrb	r6, [r5, #7]
{
    575e:	b088      	sub	sp, #32
	if (!bt_dev.id_count) {
    5760:	b9fe      	cbnz	r6, 57a2 <commit+0x4a>
		err = bt_setup_public_id_addr();
    5762:	f001 fdb3 	bl	72cc <bt_setup_public_id_addr>
		if (err) {
    5766:	4604      	mov	r4, r0
    5768:	b170      	cbz	r0, 5788 <commit+0x30>
			BT_ERR("Unable to setup an identity address");
    576a:	4b1d      	ldr	r3, [pc, #116]	; (57e0 <commit+0x88>)
    576c:	9306      	str	r3, [sp, #24]
    576e:	2302      	movs	r3, #2
    5770:	9301      	str	r3, [sp, #4]
    5772:	9305      	str	r3, [sp, #20]
    5774:	4633      	mov	r3, r6
    5776:	481b      	ldr	r0, [pc, #108]	; (57e4 <commit+0x8c>)
    5778:	aa05      	add	r2, sp, #20
    577a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    577e:	f020 faab 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		BT_DBG("Storing Identity Information");
		bt_settings_save_id();
	}

	return 0;
}
    5782:	4620      	mov	r0, r4
    5784:	b008      	add	sp, #32
    5786:	bd70      	pop	{r4, r5, r6, pc}
	if (!bt_dev.id_count) {
    5788:	79ed      	ldrb	r5, [r5, #7]
    578a:	b955      	cbnz	r5, 57a2 <commit+0x4a>
		err = bt_setup_random_id_addr();
    578c:	f001 fe04 	bl	7398 <bt_setup_random_id_addr>
		if (err) {
    5790:	4604      	mov	r4, r0
    5792:	b130      	cbz	r0, 57a2 <commit+0x4a>
			BT_ERR("Unable to setup an identity address");
    5794:	4b12      	ldr	r3, [pc, #72]	; (57e0 <commit+0x88>)
    5796:	9306      	str	r3, [sp, #24]
    5798:	2302      	movs	r3, #2
    579a:	9301      	str	r3, [sp, #4]
    579c:	9305      	str	r3, [sp, #20]
    579e:	462b      	mov	r3, r5
    57a0:	e7e9      	b.n	5776 <commit+0x1e>
    57a2:	4d11      	ldr	r5, [pc, #68]	; (57e8 <commit+0x90>)
    57a4:	f3bf 8f5b 	dmb	ish
    57a8:	682b      	ldr	r3, [r5, #0]
    57aa:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    57ae:	079b      	lsls	r3, r3, #30
    57b0:	d401      	bmi.n	57b6 <commit+0x5e>
		bt_finalize_init();
    57b2:	f001 f8f7 	bl	69a4 <bt_finalize_init>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    57b6:	f3bf 8f5b 	dmb	ish
    57ba:	e855 4f00 	ldrex	r4, [r5]
    57be:	f424 4380 	bic.w	r3, r4, #16384	; 0x4000
    57c2:	e845 3200 	strex	r2, r3, [r5]
    57c6:	2a00      	cmp	r2, #0
    57c8:	d1f7      	bne.n	57ba <commit+0x62>
    57ca:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_STORE_ID)) {
    57ce:	f414 4480 	ands.w	r4, r4, #16384	; 0x4000
    57d2:	d0d6      	beq.n	5782 <commit+0x2a>
		bt_settings_save_id();
    57d4:	f7ff ffba 	bl	574c <bt_settings_save_id>
	return 0;
    57d8:	2400      	movs	r4, #0
    57da:	e7d2      	b.n	5782 <commit+0x2a>
    57dc:	20000080 	.word	0x20000080
    57e0:	0002f585 	.word	0x0002f585
    57e4:	0002db9c 	.word	0x0002db9c
    57e8:	2000014c 	.word	0x2000014c

000057ec <bt_settings_init>:

SETTINGS_STATIC_HANDLER_DEFINE(bt, "bt", NULL, set, commit, NULL);

int bt_settings_init(void)
{
    57ec:	b510      	push	{r4, lr}
    57ee:	b088      	sub	sp, #32
	int err;

	BT_DBG("");

	err = settings_subsys_init();
    57f0:	f7fe fb6c 	bl	3ecc <settings_subsys_init>
	if (err) {
    57f4:	4604      	mov	r4, r0
    57f6:	b160      	cbz	r0, 5812 <bt_settings_init+0x26>
		BT_ERR("settings_subsys_init failed (err %d)", err);
    57f8:	4b07      	ldr	r3, [pc, #28]	; (5818 <bt_settings_init+0x2c>)
    57fa:	e9cd 3006 	strd	r3, r0, [sp, #24]
    57fe:	2303      	movs	r3, #3
    5800:	9301      	str	r3, [sp, #4]
    5802:	9305      	str	r3, [sp, #20]
    5804:	4805      	ldr	r0, [pc, #20]	; (581c <bt_settings_init+0x30>)
    5806:	2300      	movs	r3, #0
    5808:	aa05      	add	r2, sp, #20
    580a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    580e:	f020 fa63 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
	}

	return 0;
}
    5812:	4620      	mov	r0, r4
    5814:	b008      	add	sp, #32
    5816:	bd10      	pop	{r4, pc}
    5818:	0002f5a9 	.word	0x0002f5a9
    581c:	0002db9c 	.word	0x0002db9c

00005820 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    5820:	b430      	push	{r4, r5}
    5822:	4603      	mov	r3, r0
    5824:	4608      	mov	r0, r1
	switch (src->type) {
    5826:	781a      	ldrb	r2, [r3, #0]
    5828:	2a01      	cmp	r2, #1
    582a:	d013      	beq.n	5854 <uuid_to_uuid128+0x34>
    582c:	2a02      	cmp	r2, #2
    582e:	d026      	beq.n	587e <uuid_to_uuid128+0x5e>
    5830:	b972      	cbnz	r2, 5850 <uuid_to_uuid128+0x30>
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
    5832:	4a15      	ldr	r2, [pc, #84]	; (5888 <uuid_to_uuid128+0x68>)
    5834:	f102 0410 	add.w	r4, r2, #16
    5838:	f852 5b04 	ldr.w	r5, [r2], #4
    583c:	f841 5b04 	str.w	r5, [r1], #4
    5840:	42a2      	cmp	r2, r4
    5842:	d1f9      	bne.n	5838 <uuid_to_uuid128+0x18>
		sys_put_le16(BT_UUID_16(src)->val,
    5844:	885b      	ldrh	r3, [r3, #2]
		*dst = uuid128_base;
    5846:	7812      	ldrb	r2, [r2, #0]
    5848:	700a      	strb	r2, [r1, #0]
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    584a:	7343      	strb	r3, [r0, #13]
	dst[1] = val >> 8;
    584c:	0a1b      	lsrs	r3, r3, #8
    584e:	7383      	strb	r3, [r0, #14]
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    5850:	bc30      	pop	{r4, r5}
    5852:	4770      	bx	lr
		*dst = uuid128_base;
    5854:	4a0c      	ldr	r2, [pc, #48]	; (5888 <uuid_to_uuid128+0x68>)
    5856:	f102 0410 	add.w	r4, r2, #16
    585a:	f852 5b04 	ldr.w	r5, [r2], #4
    585e:	f841 5b04 	str.w	r5, [r1], #4
    5862:	42a2      	cmp	r2, r4
    5864:	d1f9      	bne.n	585a <uuid_to_uuid128+0x3a>
		sys_put_le32(BT_UUID_32(src)->val,
    5866:	685b      	ldr	r3, [r3, #4]
		*dst = uuid128_base;
    5868:	7812      	ldrb	r2, [r2, #0]
    586a:	700a      	strb	r2, [r1, #0]
    586c:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[0] = val;
    5870:	7343      	strb	r3, [r0, #13]
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(uint32_t val, uint8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
    5872:	0c1b      	lsrs	r3, r3, #16
	dst[0] = val;
    5874:	73c3      	strb	r3, [r0, #15]
	dst[1] = val >> 8;
    5876:	0a1b      	lsrs	r3, r3, #8
    5878:	7382      	strb	r2, [r0, #14]
    587a:	7403      	strb	r3, [r0, #16]
}
    587c:	e7e8      	b.n	5850 <uuid_to_uuid128+0x30>
}
    587e:	bc30      	pop	{r4, r5}
		memcpy(dst, src, sizeof(*dst));
    5880:	2211      	movs	r2, #17
    5882:	4619      	mov	r1, r3
    5884:	f021 bff4 	b.w	27870 <memcpy>
    5888:	0002f605 	.word	0x0002f605

0000588c <bt_uuid_to_str>:
	}
	return true;
}

void bt_uuid_to_str(const struct bt_uuid *uuid, char *str, size_t len)
{
    588c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t tmp1, tmp5;
	uint16_t tmp0, tmp2, tmp3, tmp4;

	switch (uuid->type) {
    588e:	7805      	ldrb	r5, [r0, #0]
    5890:	2d01      	cmp	r5, #1
{
    5892:	b08b      	sub	sp, #44	; 0x2c
    5894:	4604      	mov	r4, r0
    5896:	460e      	mov	r6, r1
    5898:	4617      	mov	r7, r2
	switch (uuid->type) {
    589a:	d00c      	beq.n	58b6 <bt_uuid_to_str+0x2a>
    589c:	2d02      	cmp	r5, #2
    589e:	d00d      	beq.n	58bc <bt_uuid_to_str+0x30>
    58a0:	2d00      	cmp	r5, #0
    58a2:	d144      	bne.n	592e <bt_uuid_to_str+0xa2>
	case BT_UUID_TYPE_16:
		snprintk(str, len, "%04x", BT_UUID_16(uuid)->val);
    58a4:	8843      	ldrh	r3, [r0, #2]
    58a6:	4a25      	ldr	r2, [pc, #148]	; (593c <bt_uuid_to_str+0xb0>)
		break;
	case BT_UUID_TYPE_32:
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
    58a8:	4639      	mov	r1, r7
    58aa:	4630      	mov	r0, r6
		break;
	default:
		(void)memset(str, 0, len);
		return;
	}
}
    58ac:	b00b      	add	sp, #44	; 0x2c
    58ae:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
    58b2:	f01f bc90 	b.w	251d6 <snprintk>
    58b6:	6843      	ldr	r3, [r0, #4]
    58b8:	4a21      	ldr	r2, [pc, #132]	; (5940 <bt_uuid_to_str+0xb4>)
    58ba:	e7f5      	b.n	58a8 <bt_uuid_to_str+0x1c>
		memcpy(&tmp0, &BT_UUID_128(uuid)->val[0], sizeof(tmp0));
    58bc:	462a      	mov	r2, r5
    58be:	1c41      	adds	r1, r0, #1
    58c0:	a806      	add	r0, sp, #24
    58c2:	f021 ffd5 	bl	27870 <memcpy>
		memcpy(&tmp1, &BT_UUID_128(uuid)->val[2], sizeof(tmp1));
    58c6:	1ce1      	adds	r1, r4, #3
    58c8:	2204      	movs	r2, #4
    58ca:	a808      	add	r0, sp, #32
    58cc:	f021 ffd0 	bl	27870 <memcpy>
		memcpy(&tmp2, &BT_UUID_128(uuid)->val[6], sizeof(tmp2));
    58d0:	462a      	mov	r2, r5
    58d2:	1de1      	adds	r1, r4, #7
    58d4:	f10d 001a 	add.w	r0, sp, #26
    58d8:	f021 ffca 	bl	27870 <memcpy>
		memcpy(&tmp3, &BT_UUID_128(uuid)->val[8], sizeof(tmp3));
    58dc:	462a      	mov	r2, r5
    58de:	f104 0109 	add.w	r1, r4, #9
    58e2:	a807      	add	r0, sp, #28
    58e4:	f021 ffc4 	bl	27870 <memcpy>
		memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
    58e8:	462a      	mov	r2, r5
    58ea:	f104 010b 	add.w	r1, r4, #11
    58ee:	f10d 001e 	add.w	r0, sp, #30
    58f2:	f021 ffbd 	bl	27870 <memcpy>
		memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
    58f6:	f104 010d 	add.w	r1, r4, #13
    58fa:	2204      	movs	r2, #4
    58fc:	a809      	add	r0, sp, #36	; 0x24
    58fe:	f021 ffb7 	bl	27870 <memcpy>
		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x",
    5902:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    5906:	9304      	str	r3, [sp, #16]
    5908:	9b08      	ldr	r3, [sp, #32]
    590a:	9303      	str	r3, [sp, #12]
    590c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    5910:	9302      	str	r3, [sp, #8]
    5912:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    5916:	9301      	str	r3, [sp, #4]
    5918:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    591c:	9300      	str	r3, [sp, #0]
    591e:	4a09      	ldr	r2, [pc, #36]	; (5944 <bt_uuid_to_str+0xb8>)
    5920:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5922:	4639      	mov	r1, r7
    5924:	4630      	mov	r0, r6
    5926:	f01f fc56 	bl	251d6 <snprintk>
}
    592a:	b00b      	add	sp, #44	; 0x2c
    592c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		(void)memset(str, 0, len);
    592e:	2100      	movs	r1, #0
    5930:	4630      	mov	r0, r6
}
    5932:	b00b      	add	sp, #44	; 0x2c
    5934:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		(void)memset(str, 0, len);
    5938:	f021 bfa5 	b.w	27886 <memset>
    593c:	00030782 	.word	0x00030782
    5940:	0002efa7 	.word	0x0002efa7
    5944:	0002f5e8 	.word	0x0002f5e8

00005948 <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    5948:	b538      	push	{r3, r4, r5, lr}
    594a:	4605      	mov	r5, r0
	return net_buf_alloc_fixed(pool, timeout);
    594c:	4805      	ldr	r0, [pc, #20]	; (5964 <bt_buf_get_rx+0x1c>)
    594e:	f026 f96a 	bl	2bc26 <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    5952:	4604      	mov	r4, r0
    5954:	b120      	cbz	r0, 5960 <bt_buf_get_rx+0x18>
	net_buf_simple_reserve(&buf->b, reserve);
    5956:	2100      	movs	r1, #0
    5958:	3008      	adds	r0, #8
    595a:	f026 f989 	bl	2bc70 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    595e:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    5960:	4620      	mov	r0, r4
    5962:	bd38      	pop	{r3, r4, r5, pc}
    5964:	20001094 	.word	0x20001094

00005968 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    5968:	460b      	mov	r3, r1
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
    596a:	490b      	ldr	r1, [pc, #44]	; (5998 <bt_buf_get_cmd_complete+0x30>)
{
    596c:	4602      	mov	r2, r0
	if (bt_dev.sent_cmd) {
    596e:	f8d1 0130 	ldr.w	r0, [r1, #304]	; 0x130
{
    5972:	b510      	push	{r4, lr}
	if (bt_dev.sent_cmd) {
    5974:	b920      	cbnz	r0, 5980 <bt_buf_get_cmd_complete+0x18>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    5976:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    597a:	2001      	movs	r0, #1
    597c:	f7ff bfe4 	b.w	5948 <bt_buf_get_rx>
		buf = net_buf_ref(bt_dev.sent_cmd);
    5980:	f026 f9a4 	bl	2bccc <net_buf_ref>
    5984:	2301      	movs	r3, #1
		buf->len = 0U;
    5986:	2100      	movs	r1, #0
    5988:	7503      	strb	r3, [r0, #20]
    598a:	8181      	strh	r1, [r0, #12]
		buf = net_buf_ref(bt_dev.sent_cmd);
    598c:	4604      	mov	r4, r0
    598e:	3008      	adds	r0, #8
    5990:	f026 f96e 	bl	2bc70 <net_buf_simple_reserve>
}
    5994:	4620      	mov	r0, r4
    5996:	bd10      	pop	{r4, pc}
    5998:	20000080 	.word	0x20000080

0000599c <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
    599c:	b570      	push	{r4, r5, r6, lr}
    599e:	4604      	mov	r4, r0
	switch (evt) {
    59a0:	2c0f      	cmp	r4, #15
{
    59a2:	460d      	mov	r5, r1
    59a4:	4610      	mov	r0, r2
    59a6:	4619      	mov	r1, r3
	switch (evt) {
    59a8:	d805      	bhi.n	59b6 <bt_buf_get_evt+0x1a>
    59aa:	2c0d      	cmp	r4, #13
    59ac:	d912      	bls.n	59d4 <bt_buf_get_evt+0x38>
		}
#endif /* CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    59ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
    59b2:	f7ff bfd9 	b.w	5968 <bt_buf_get_cmd_complete>
	switch (evt) {
    59b6:	2c13      	cmp	r4, #19
    59b8:	d10c      	bne.n	59d4 <bt_buf_get_evt+0x38>
	return net_buf_alloc_fixed(pool, timeout);
    59ba:	480b      	ldr	r0, [pc, #44]	; (59e8 <bt_buf_get_evt+0x4c>)
    59bc:	f026 f933 	bl	2bc26 <net_buf_alloc_fixed>
			if (buf) {
    59c0:	4604      	mov	r4, r0
    59c2:	b128      	cbz	r0, 59d0 <bt_buf_get_evt+0x34>
	net_buf_simple_reserve(&buf->b, reserve);
    59c4:	2100      	movs	r1, #0
    59c6:	3008      	adds	r0, #8
    59c8:	f026 f952 	bl	2bc70 <net_buf_simple_reserve>
    59cc:	2301      	movs	r3, #1
    59ce:	7523      	strb	r3, [r4, #20]
}
    59d0:	4620      	mov	r0, r4
    59d2:	bd70      	pop	{r4, r5, r6, pc}
	return net_buf_alloc_fixed(pool, timeout);
    59d4:	4602      	mov	r2, r0
    59d6:	460b      	mov	r3, r1
		if (discardable) {
    59d8:	b10d      	cbz	r5, 59de <bt_buf_get_evt+0x42>
    59da:	4804      	ldr	r0, [pc, #16]	; (59ec <bt_buf_get_evt+0x50>)
    59dc:	e7ee      	b.n	59bc <bt_buf_get_evt+0x20>
}
    59de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    59e2:	2001      	movs	r0, #1
    59e4:	f7ff bfb0 	b.w	5948 <bt_buf_get_rx>
    59e8:	200010c0 	.word	0x200010c0
    59ec:	20000fe4 	.word	0x20000fe4

000059f0 <ver_str>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(uint8_t ver)
{
    59f0:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
    59f2:	4d0b      	ldr	r5, [pc, #44]	; (5a20 <ver_str+0x30>)
{
    59f4:	4606      	mov	r6, r0
	const char * const str[] = {
    59f6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    59f8:	b08e      	sub	sp, #56	; 0x38
	const char * const str[] = {
    59fa:	ac01      	add	r4, sp, #4
    59fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    59fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5a00:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5a02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5a04:	c40f      	stmia	r4!, {r0, r1, r2, r3}
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1", "5.2", "5.3"
	};

	if (ver < ARRAY_SIZE(str)) {
    5a06:	2e0c      	cmp	r6, #12
	const char * const str[] = {
    5a08:	682b      	ldr	r3, [r5, #0]
    5a0a:	6023      	str	r3, [r4, #0]
		return str[ver];
    5a0c:	bf9b      	ittet	ls
    5a0e:	ab0e      	addls	r3, sp, #56	; 0x38
    5a10:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	}

	return "unknown";
    5a14:	4803      	ldrhi	r0, [pc, #12]	; (5a24 <ver_str+0x34>)
		return str[ver];
    5a16:	f856 0c34 	ldrls.w	r0, [r6, #-52]
}
    5a1a:	b00e      	add	sp, #56	; 0x38
    5a1c:	bd70      	pop	{r4, r5, r6, pc}
    5a1e:	bf00      	nop
    5a20:	0002dcec 	.word	0x0002dcec
    5a24:	0002f70c 	.word	0x0002f70c

00005a28 <hci_disconn_complete_prio>:
{
    5a28:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    5a2a:	6883      	ldr	r3, [r0, #8]
	if (evt->status) {
    5a2c:	781a      	ldrb	r2, [r3, #0]
    5a2e:	b972      	cbnz	r2, 5a4e <hci_disconn_complete_prio+0x26>
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    5a30:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
    5a34:	4620      	mov	r0, r4
    5a36:	f002 fe13 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    5a3a:	4605      	mov	r5, r0
    5a3c:	b940      	cbnz	r0, 5a50 <hci_disconn_complete_prio+0x28>
		if (!disconnected_handles[i]) {
    5a3e:	4b08      	ldr	r3, [pc, #32]	; (5a60 <hci_disconn_complete_prio+0x38>)
    5a40:	881a      	ldrh	r2, [r3, #0]
    5a42:	b922      	cbnz	r2, 5a4e <hci_disconn_complete_prio+0x26>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
    5a44:	ea6f 5004 	mvn.w	r0, r4, lsl #20
    5a48:	ea6f 5010 	mvn.w	r0, r0, lsr #20
    5a4c:	8018      	strh	r0, [r3, #0]
}
    5a4e:	bd38      	pop	{r3, r4, r5, pc}
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
    5a50:	2101      	movs	r1, #1
    5a52:	f002 fe0d 	bl	8670 <bt_conn_set_state>
	bt_conn_unref(conn);
    5a56:	4628      	mov	r0, r5
}
    5a58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
    5a5c:	f022 bc47 	b.w	282ee <bt_conn_unref>
    5a60:	2000388c 	.word	0x2000388c

00005a64 <find_pending_connect.part.0>:
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    5a64:	b513      	push	{r0, r1, r4, lr}
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
    5a66:	4c0d      	ldr	r4, [pc, #52]	; (5a9c <find_pending_connect.part.0+0x38>)
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    5a68:	4601      	mov	r1, r0
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
    5a6a:	2205      	movs	r2, #5
    5a6c:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
    5a70:	f003 f802 	bl	8a78 <bt_conn_lookup_state_le>
		if (!conn) {
    5a74:	b978      	cbnz	r0, 5a96 <find_pending_connect.part.0+0x32>
						       BT_ADDR_LE_NONE,
    5a76:	4b0a      	ldr	r3, [pc, #40]	; (5aa0 <find_pending_connect.part.0+0x3c>)
    5a78:	6b58      	ldr	r0, [r3, #52]	; 0x34
    5a7a:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
    5a7c:	9000      	str	r0, [sp, #0]
    5a7e:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    5a82:	f8ad 2004 	strh.w	r2, [sp, #4]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    5a86:	f894 0067 	ldrb.w	r0, [r4, #103]	; 0x67
						       BT_ADDR_LE_NONE,
    5a8a:	f88d 3006 	strb.w	r3, [sp, #6]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    5a8e:	2204      	movs	r2, #4
    5a90:	4669      	mov	r1, sp
    5a92:	f002 fff1 	bl	8a78 <bt_conn_lookup_state_le>
}
    5a96:	b002      	add	sp, #8
    5a98:	bd10      	pop	{r4, pc}
    5a9a:	bf00      	nop
    5a9c:	20000080 	.word	0x20000080
    5aa0:	0002dcec 	.word	0x0002dcec

00005aa4 <hci_data_buf_overflow>:
{
    5aa4:	b500      	push	{lr}
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    5aa6:	6883      	ldr	r3, [r0, #8]
    5aa8:	4a07      	ldr	r2, [pc, #28]	; (5ac8 <hci_data_buf_overflow+0x24>)
    5aaa:	781b      	ldrb	r3, [r3, #0]
    5aac:	4807      	ldr	r0, [pc, #28]	; (5acc <hci_data_buf_overflow+0x28>)
{
    5aae:	b089      	sub	sp, #36	; 0x24
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    5ab0:	e9cd 2306 	strd	r2, r3, [sp, #24]
    5ab4:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    5ab8:	2303      	movs	r3, #3
    5aba:	aa05      	add	r2, sp, #20
    5abc:	9305      	str	r3, [sp, #20]
    5abe:	f022 f99c 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    5ac2:	b009      	add	sp, #36	; 0x24
    5ac4:	f85d fb04 	ldr.w	pc, [sp], #4
    5ac8:	0002f714 	.word	0x0002f714
    5acc:	0002daac 	.word	0x0002daac

00005ad0 <le_conn_update_complete>:
{
    5ad0:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    5ad2:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    5ad4:	f8b5 6001 	ldrh.w	r6, [r5, #1]
{
    5ad8:	b088      	sub	sp, #32
	conn = bt_conn_lookup_handle(handle);
    5ada:	4630      	mov	r0, r6
    5adc:	f002 fdc0 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    5ae0:	4604      	mov	r4, r0
    5ae2:	b968      	cbnz	r0, 5b00 <le_conn_update_complete+0x30>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    5ae4:	4b25      	ldr	r3, [pc, #148]	; (5b7c <le_conn_update_complete+0xac>)
    5ae6:	4826      	ldr	r0, [pc, #152]	; (5b80 <le_conn_update_complete+0xb0>)
    5ae8:	e9cd 3606 	strd	r3, r6, [sp, #24]
    5aec:	aa05      	add	r2, sp, #20
    5aee:	2303      	movs	r3, #3
    5af0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5af4:	9301      	str	r3, [sp, #4]
    5af6:	9305      	str	r3, [sp, #20]
    5af8:	f022 f97f 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    5afc:	b008      	add	sp, #32
    5afe:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
    5b00:	782b      	ldrb	r3, [r5, #0]
    5b02:	b9cb      	cbnz	r3, 5b38 <le_conn_update_complete+0x68>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    5b04:	792a      	ldrb	r2, [r5, #4]
    5b06:	78eb      	ldrb	r3, [r5, #3]
    5b08:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5b0c:	f8a0 309e 	strh.w	r3, [r0, #158]	; 0x9e
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    5b10:	79aa      	ldrb	r2, [r5, #6]
    5b12:	796b      	ldrb	r3, [r5, #5]
    5b14:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5b18:	f8a0 30a4 	strh.w	r3, [r0, #164]	; 0xa4
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    5b1c:	79eb      	ldrb	r3, [r5, #7]
    5b1e:	7a2a      	ldrb	r2, [r5, #8]
    5b20:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    5b24:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
		notify_le_param_updated(conn);
    5b28:	f002 fec4 	bl	88b4 <notify_le_param_updated>
	bt_conn_unref(conn);
    5b2c:	4620      	mov	r0, r4
}
    5b2e:	b008      	add	sp, #32
    5b30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    5b34:	f022 bbdb 	b.w	282ee <bt_conn_unref>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    5b38:	2b1a      	cmp	r3, #26
    5b3a:	d1f7      	bne.n	5b2c <le_conn_update_complete+0x5c>
    5b3c:	78c3      	ldrb	r3, [r0, #3]
    5b3e:	2b01      	cmp	r3, #1
    5b40:	d1f4      	bne.n	5b2c <le_conn_update_complete+0x5c>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    5b42:	f44f 6180 	mov.w	r1, #1024	; 0x400
    5b46:	3004      	adds	r0, #4
    5b48:	f022 f948 	bl	27ddc <atomic_or>
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
    5b4c:	0543      	lsls	r3, r0, #21
    5b4e:	d4ed      	bmi.n	5b2c <le_conn_update_complete+0x5c>
		param.interval_min = conn->le.interval_min;
    5b50:	f8b4 30a0 	ldrh.w	r3, [r4, #160]	; 0xa0
    5b54:	f8ad 3008 	strh.w	r3, [sp, #8]
		param.interval_max = conn->le.interval_max;
    5b58:	f8b4 30a2 	ldrh.w	r3, [r4, #162]	; 0xa2
    5b5c:	f8ad 300a 	strh.w	r3, [sp, #10]
		param.latency = conn->le.pending_latency;
    5b60:	f8b4 30a8 	ldrh.w	r3, [r4, #168]	; 0xa8
    5b64:	f8ad 300c 	strh.w	r3, [sp, #12]
		bt_l2cap_update_conn_param(conn, &param);
    5b68:	a902      	add	r1, sp, #8
		param.timeout = conn->le.pending_timeout;
    5b6a:	f8b4 30aa 	ldrh.w	r3, [r4, #170]	; 0xaa
    5b6e:	f8ad 300e 	strh.w	r3, [sp, #14]
		bt_l2cap_update_conn_param(conn, &param);
    5b72:	4620      	mov	r0, r4
    5b74:	f003 faa6 	bl	90c4 <bt_l2cap_update_conn_param>
    5b78:	e7d8      	b.n	5b2c <le_conn_update_complete+0x5c>
    5b7a:	bf00      	nop
    5b7c:	0002f73c 	.word	0x0002f73c
    5b80:	0002daac 	.word	0x0002daac

00005b84 <hci_hardware_error>:
{
    5b84:	b500      	push	{lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    5b86:	2101      	movs	r1, #1
    5b88:	b089      	sub	sp, #36	; 0x24
    5b8a:	3008      	adds	r0, #8
    5b8c:	f026 f94e 	bl	2be2c <net_buf_simple_pull_mem>
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    5b90:	4a07      	ldr	r2, [pc, #28]	; (5bb0 <hci_hardware_error+0x2c>)
    5b92:	7803      	ldrb	r3, [r0, #0]
    5b94:	4807      	ldr	r0, [pc, #28]	; (5bb4 <hci_hardware_error+0x30>)
    5b96:	e9cd 2306 	strd	r2, r3, [sp, #24]
    5b9a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5b9e:	2303      	movs	r3, #3
    5ba0:	aa05      	add	r2, sp, #20
    5ba2:	9305      	str	r3, [sp, #20]
    5ba4:	f022 f929 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    5ba8:	b009      	add	sp, #36	; 0x24
    5baa:	f85d fb04 	ldr.w	pc, [sp], #4
    5bae:	bf00      	nop
    5bb0:	0002f760 	.word	0x0002f760
    5bb4:	0002daac 	.word	0x0002daac

00005bb8 <hci_disconn_complete>:
{
    5bb8:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    5bba:	6885      	ldr	r5, [r0, #8]
	if (evt->status) {
    5bbc:	782e      	ldrb	r6, [r5, #0]
{
    5bbe:	b089      	sub	sp, #36	; 0x24
	if (evt->status) {
    5bc0:	b996      	cbnz	r6, 5be8 <hci_disconn_complete+0x30>
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    5bc2:	f8b5 7001 	ldrh.w	r7, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
    5bc6:	4638      	mov	r0, r7
    5bc8:	f002 fd4a 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    5bcc:	4604      	mov	r4, r0
    5bce:	b968      	cbnz	r0, 5bec <hci_disconn_complete+0x34>
		BT_ERR("Unable to look up conn with handle %u", handle);
    5bd0:	4b0c      	ldr	r3, [pc, #48]	; (5c04 <hci_disconn_complete+0x4c>)
    5bd2:	480d      	ldr	r0, [pc, #52]	; (5c08 <hci_disconn_complete+0x50>)
    5bd4:	e9cd 3706 	strd	r3, r7, [sp, #24]
    5bd8:	aa05      	add	r2, sp, #20
    5bda:	2303      	movs	r3, #3
    5bdc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5be0:	9301      	str	r3, [sp, #4]
    5be2:	9305      	str	r3, [sp, #20]
    5be4:	f022 f909 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    5be8:	b009      	add	sp, #36	; 0x24
    5bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	conn->err = evt->reason;
    5bec:	78eb      	ldrb	r3, [r5, #3]
    5bee:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    5bf0:	4631      	mov	r1, r6
    5bf2:	f002 fd3d 	bl	8670 <bt_conn_set_state>
		bt_conn_unref(conn);
    5bf6:	4620      	mov	r0, r4
}
    5bf8:	b009      	add	sp, #36	; 0x24
    5bfa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	bt_conn_unref(conn);
    5bfe:	f022 bb76 	b.w	282ee <bt_conn_unref>
    5c02:	bf00      	nop
    5c04:	0002f782 	.word	0x0002f782
    5c08:	0002daac 	.word	0x0002daac

00005c0c <hci_vendor_event>:
{
    5c0c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
    5c0e:	8981      	ldrh	r1, [r0, #12]
    5c10:	6880      	ldr	r0, [r0, #8]
    5c12:	f7ff faa1 	bl	5158 <bt_hex_real>
    5c16:	4b06      	ldr	r3, [pc, #24]	; (5c30 <hci_vendor_event+0x24>)
    5c18:	9301      	str	r3, [sp, #4]
    5c1a:	2300      	movs	r3, #0
    5c1c:	9002      	str	r0, [sp, #8]
    5c1e:	4905      	ldr	r1, [pc, #20]	; (5c34 <hci_vendor_event+0x28>)
    5c20:	9300      	str	r3, [sp, #0]
    5c22:	2202      	movs	r2, #2
    5c24:	4618      	mov	r0, r3
    5c26:	f022 f8eb 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
}
    5c2a:	b005      	add	sp, #20
    5c2c:	f85d fb04 	ldr.w	pc, [sp], #4
    5c30:	0002f7a8 	.word	0x0002f7a8
    5c34:	0002daac 	.word	0x0002daac

00005c38 <handle_event>:
{
    5c38:	b5b0      	push	{r4, r5, r7, lr}
    5c3a:	b088      	sub	sp, #32
    5c3c:	4604      	mov	r4, r0
    5c3e:	af06      	add	r7, sp, #24
    5c40:	4608      	mov	r0, r1
	for (i = 0; i < num_handlers; i++) {
    5c42:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
		if (handler->event != event) {
    5c46:	7811      	ldrb	r1, [r2, #0]
    5c48:	42a1      	cmp	r1, r4
    5c4a:	d014      	beq.n	5c76 <handle_event+0x3e>
	for (i = 0; i < num_handlers; i++) {
    5c4c:	3208      	adds	r2, #8
    5c4e:	429a      	cmp	r2, r3
    5c50:	d1f9      	bne.n	5c46 <handle_event+0xe>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
    5c52:	8985      	ldrh	r5, [r0, #12]
    5c54:	6880      	ldr	r0, [r0, #8]
    5c56:	4629      	mov	r1, r5
    5c58:	f7ff fa7e 	bl	5158 <bt_hex_real>
    5c5c:	4b13      	ldr	r3, [pc, #76]	; (5cac <handle_event+0x74>)
    5c5e:	9301      	str	r3, [sp, #4]
    5c60:	2300      	movs	r3, #0
    5c62:	e9cd 5003 	strd	r5, r0, [sp, #12]
    5c66:	4912      	ldr	r1, [pc, #72]	; (5cb0 <handle_event+0x78>)
    5c68:	9402      	str	r4, [sp, #8]
    5c6a:	9300      	str	r3, [sp, #0]
    5c6c:	2202      	movs	r2, #2
    5c6e:	4618      	mov	r0, r3
    5c70:	f022 f8c6 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
    5c74:	e014      	b.n	5ca0 <handle_event+0x68>
		if (buf->len < handler->min_len) {
    5c76:	8983      	ldrh	r3, [r0, #12]
    5c78:	7851      	ldrb	r1, [r2, #1]
    5c7a:	4299      	cmp	r1, r3
    5c7c:	d913      	bls.n	5ca6 <handle_event+0x6e>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    5c7e:	490d      	ldr	r1, [pc, #52]	; (5cb4 <handle_event+0x7c>)
    5c80:	480b      	ldr	r0, [pc, #44]	; (5cb0 <handle_event+0x78>)
    5c82:	466d      	mov	r5, sp
    5c84:	b088      	sub	sp, #32
    5c86:	aa06      	add	r2, sp, #24
    5c88:	e9c2 1304 	strd	r1, r3, [r2, #16]
    5c8c:	2304      	movs	r3, #4
    5c8e:	6194      	str	r4, [r2, #24]
    5c90:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    5c94:	f842 3f0c 	str.w	r3, [r2, #12]!
    5c98:	607b      	str	r3, [r7, #4]
    5c9a:	f022 f8ae 	bl	27dfa <z_log_msg2_static_create.constprop.0>
    5c9e:	46ad      	mov	sp, r5
}
    5ca0:	3708      	adds	r7, #8
    5ca2:	46bd      	mov	sp, r7
    5ca4:	bdb0      	pop	{r4, r5, r7, pc}
		handler->handler(buf);
    5ca6:	6853      	ldr	r3, [r2, #4]
    5ca8:	4798      	blx	r3
		return;
    5caa:	e7f9      	b.n	5ca0 <handle_event+0x68>
    5cac:	0002f7ee 	.word	0x0002f7ee
    5cb0:	0002daac 	.word	0x0002daac
    5cb4:	0002f7cc 	.word	0x0002f7cc

00005cb8 <hci_le_meta_event>:
{
    5cb8:	b510      	push	{r4, lr}
    5cba:	2101      	movs	r1, #1
    5cbc:	4604      	mov	r4, r0
    5cbe:	3008      	adds	r0, #8
    5cc0:	f026 f8b4 	bl	2be2c <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    5cc4:	4621      	mov	r1, r4
    5cc6:	4a03      	ldr	r2, [pc, #12]	; (5cd4 <hci_le_meta_event+0x1c>)
    5cc8:	7800      	ldrb	r0, [r0, #0]
}
    5cca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    5cce:	2308      	movs	r3, #8
    5cd0:	f7ff bfb2 	b.w	5c38 <handle_event>
    5cd4:	0002e108 	.word	0x0002e108

00005cd8 <hci_cmd_done>:
{
    5cd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5cdc:	b082      	sub	sp, #8
    5cde:	4680      	mov	r8, r0
    5ce0:	af00      	add	r7, sp, #0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    5ce2:	7990      	ldrb	r0, [r2, #6]
    5ce4:	f8df 9148 	ldr.w	r9, [pc, #328]	; 5e30 <hci_cmd_done+0x158>
{
    5ce8:	460e      	mov	r6, r1
    5cea:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    5cec:	f01a fd0e 	bl	2070c <net_buf_pool_get>
    5cf0:	4581      	cmp	r9, r0
    5cf2:	d020      	beq.n	5d36 <hci_cmd_done+0x5e>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    5cf4:	79a0      	ldrb	r0, [r4, #6]
    5cf6:	f01a fd09 	bl	2070c <net_buf_pool_get>
    5cfa:	466e      	mov	r6, sp
    5cfc:	b08a      	sub	sp, #40	; 0x28
    5cfe:	466d      	mov	r5, sp
    5d00:	4b4c      	ldr	r3, [pc, #304]	; (5e34 <hci_cmd_done+0x15c>)
    5d02:	79a0      	ldrb	r0, [r4, #6]
    5d04:	61a8      	str	r0, [r5, #24]
    5d06:	e9c5 3804 	strd	r3, r8, [r5, #16]
    5d0a:	f01a fcff 	bl	2070c <net_buf_pool_get>
    5d0e:	79a0      	ldrb	r0, [r4, #6]
    5d10:	f01a fcfc 	bl	2070c <net_buf_pool_get>
    5d14:	462a      	mov	r2, r5
    5d16:	2306      	movs	r3, #6
    5d18:	e9c5 0907 	strd	r0, r9, [r5, #28]
    5d1c:	f44f 5142 	mov.w	r1, #12416	; 0x3080
    5d20:	f842 3f0c 	str.w	r3, [r2, #12]!
    5d24:	4844      	ldr	r0, [pc, #272]	; (5e38 <hci_cmd_done+0x160>)
    5d26:	607b      	str	r3, [r7, #4]
    5d28:	f022 f867 	bl	27dfa <z_log_msg2_static_create.constprop.0>
    5d2c:	46b5      	mov	sp, r6
}
    5d2e:	3708      	adds	r7, #8
    5d30:	46bd      	mov	sp, r7
    5d32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (cmd(buf)->opcode != opcode) {
    5d36:	4620      	mov	r0, r4
    5d38:	f01a fcf0 	bl	2071c <net_buf_id>
    5d3c:	4d3f      	ldr	r5, [pc, #252]	; (5e3c <hci_cmd_done+0x164>)
    5d3e:	f04f 0a0c 	mov.w	sl, #12
    5d42:	fb0a 5000 	mla	r0, sl, r0, r5
    5d46:	8843      	ldrh	r3, [r0, #2]
    5d48:	4543      	cmp	r3, r8
    5d4a:	d01e      	beq.n	5d8a <hci_cmd_done+0xb2>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    5d4c:	4620      	mov	r0, r4
    5d4e:	f01a fce5 	bl	2071c <net_buf_id>
    5d52:	46e9      	mov	r9, sp
    5d54:	4b3a      	ldr	r3, [pc, #232]	; (5e40 <hci_cmd_done+0x168>)
    5d56:	b088      	sub	sp, #32
    5d58:	466e      	mov	r6, sp
    5d5a:	e9c6 3804 	strd	r3, r8, [r6, #16]
    5d5e:	4620      	mov	r0, r4
    5d60:	f01a fcdc 	bl	2071c <net_buf_id>
    5d64:	4620      	mov	r0, r4
    5d66:	f01a fcd9 	bl	2071c <net_buf_id>
    5d6a:	fb0a 5500 	mla	r5, sl, r0, r5
    5d6e:	4632      	mov	r2, r6
    5d70:	886b      	ldrh	r3, [r5, #2]
    5d72:	61b3      	str	r3, [r6, #24]
    5d74:	2304      	movs	r3, #4
    5d76:	f842 3f0c 	str.w	r3, [r2, #12]!
    5d7a:	482f      	ldr	r0, [pc, #188]	; (5e38 <hci_cmd_done+0x160>)
    5d7c:	607b      	str	r3, [r7, #4]
    5d7e:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    5d82:	f022 f83a 	bl	27dfa <z_log_msg2_static_create.constprop.0>
    5d86:	46cd      	mov	sp, r9
		return;
    5d88:	e7d1      	b.n	5d2e <hci_cmd_done+0x56>
	if (bt_dev.sent_cmd) {
    5d8a:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 5e44 <hci_cmd_done+0x16c>
    5d8e:	f8d8 0130 	ldr.w	r0, [r8, #304]	; 0x130
    5d92:	b120      	cbz	r0, 5d9e <hci_cmd_done+0xc6>
		net_buf_unref(bt_dev.sent_cmd);
    5d94:	f01a fd7e 	bl	20894 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    5d98:	2300      	movs	r3, #0
    5d9a:	f8c8 3130 	str.w	r3, [r8, #304]	; 0x130
	if (cmd(buf)->state && !status) {
    5d9e:	4620      	mov	r0, r4
    5da0:	f01a fcbc 	bl	2071c <net_buf_id>
    5da4:	f04f 080c 	mov.w	r8, #12
    5da8:	fb08 5000 	mla	r0, r8, r0, r5
    5dac:	6843      	ldr	r3, [r0, #4]
    5dae:	b1b3      	cbz	r3, 5dde <hci_cmd_done+0x106>
    5db0:	b9ae      	cbnz	r6, 5dde <hci_cmd_done+0x106>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    5db2:	4620      	mov	r0, r4
    5db4:	f01a fcb2 	bl	2071c <net_buf_id>
    5db8:	fb08 5000 	mla	r0, r8, r0, r5
	atomic_val_t mask = ATOMIC_MASK(bit);
    5dbc:	2301      	movs	r3, #1
    5dbe:	f8d0 c004 	ldr.w	ip, [r0, #4]
    5dc2:	e9dc 2000 	ldrd	r2, r0, [ip]
    5dc6:	f000 011f 	and.w	r1, r0, #31
    5dca:	fa03 f101 	lsl.w	r1, r3, r1
	if (val) {
    5dce:	f89c 3008 	ldrb.w	r3, [ip, #8]
    5dd2:	0940      	lsrs	r0, r0, #5
    5dd4:	b1e3      	cbz	r3, 5e10 <hci_cmd_done+0x138>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    5dd6:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    5dda:	f021 ffff 	bl	27ddc <atomic_or>
	if (cmd(buf)->sync) {
    5dde:	4620      	mov	r0, r4
    5de0:	f01a fc9c 	bl	2071c <net_buf_id>
    5de4:	f04f 080c 	mov.w	r8, #12
    5de8:	fb08 5000 	mla	r0, r8, r0, r5
    5dec:	6883      	ldr	r3, [r0, #8]
    5dee:	2b00      	cmp	r3, #0
    5df0:	d09d      	beq.n	5d2e <hci_cmd_done+0x56>
		cmd(buf)->status = status;
    5df2:	4620      	mov	r0, r4
    5df4:	f01a fc92 	bl	2071c <net_buf_id>
    5df8:	fb08 f000 	mul.w	r0, r8, r0
    5dfc:	542e      	strb	r6, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    5dfe:	4620      	mov	r0, r4
    5e00:	f01a fc8c 	bl	2071c <net_buf_id>
    5e04:	fb08 5500 	mla	r5, r8, r0, r5
    5e08:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_sem_give(sem);
    5e0a:	f01e f8a3 	bl	23f54 <z_impl_k_sem_give>
}
    5e0e:	e78e      	b.n	5d2e <hci_cmd_done+0x56>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    5e10:	43cb      	mvns	r3, r1
    5e12:	eb02 0280 	add.w	r2, r2, r0, lsl #2
    5e16:	f3bf 8f5b 	dmb	ish
    5e1a:	e852 1f00 	ldrex	r1, [r2]
    5e1e:	4019      	ands	r1, r3
    5e20:	e842 1000 	strex	r0, r1, [r2]
    5e24:	2800      	cmp	r0, #0
    5e26:	d1f8      	bne.n	5e1a <hci_cmd_done+0x142>
    5e28:	f3bf 8f5b 	dmb	ish
    5e2c:	e7d7      	b.n	5dde <hci_cmd_done+0x106>
    5e2e:	bf00      	nop
    5e30:	20001068 	.word	0x20001068
    5e34:	0002f810 	.word	0x0002f810
    5e38:	0002daac 	.word	0x0002daac
    5e3c:	200025e8 	.word	0x200025e8
    5e40:	0002f845 	.word	0x0002f845
    5e44:	20000080 	.word	0x20000080

00005e48 <hci_cmd_status>:
{
    5e48:	b538      	push	{r3, r4, r5, lr}
    5e4a:	2104      	movs	r1, #4
    5e4c:	4604      	mov	r4, r0
    5e4e:	3008      	adds	r0, #8
    5e50:	f025 ffec 	bl	2be2c <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    5e54:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    5e56:	7801      	ldrb	r1, [r0, #0]
    5e58:	8840      	ldrh	r0, [r0, #2]
    5e5a:	4622      	mov	r2, r4
    5e5c:	f7ff ff3c 	bl	5cd8 <hci_cmd_done>
	if (ncmd) {
    5e60:	b125      	cbz	r5, 5e6c <hci_cmd_status+0x24>
	z_impl_k_sem_give(sem);
    5e62:	4803      	ldr	r0, [pc, #12]	; (5e70 <hci_cmd_status+0x28>)
}
    5e64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5e68:	f01e b874 	b.w	23f54 <z_impl_k_sem_give>
    5e6c:	bd38      	pop	{r3, r4, r5, pc}
    5e6e:	bf00      	nop
    5e70:	20000198 	.word	0x20000198

00005e74 <hci_cmd_complete>:
{
    5e74:	b538      	push	{r3, r4, r5, lr}
    5e76:	2103      	movs	r1, #3
    5e78:	4604      	mov	r4, r0
    5e7a:	3008      	adds	r0, #8
    5e7c:	f025 ffd6 	bl	2be2c <net_buf_simple_pull_mem>
	status = buf->data[0];
    5e80:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    5e82:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    5e84:	7819      	ldrb	r1, [r3, #0]
    5e86:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    5e8a:	4622      	mov	r2, r4
    5e8c:	f7ff ff24 	bl	5cd8 <hci_cmd_done>
	if (ncmd) {
    5e90:	b125      	cbz	r5, 5e9c <hci_cmd_complete+0x28>
    5e92:	4803      	ldr	r0, [pc, #12]	; (5ea0 <hci_cmd_complete+0x2c>)
}
    5e94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5e98:	f01e b85c 	b.w	23f54 <z_impl_k_sem_give>
    5e9c:	bd38      	pop	{r3, r4, r5, pc}
    5e9e:	bf00      	nop
    5ea0:	20000198 	.word	0x20000198

00005ea4 <hci_tx_thread>:
{
    5ea4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		events[0].state = K_POLL_STATE_NOT_READY;
    5ea8:	f8df 8158 	ldr.w	r8, [pc, #344]	; 6004 <hci_tx_thread+0x160>
		BT_ASSERT(err == 0);
    5eac:	f8df 9158 	ldr.w	r9, [pc, #344]	; 6008 <hci_tx_thread+0x164>
{
    5eb0:	b089      	sub	sp, #36	; 0x24
			ev_count += bt_conn_prepare_events(&events[1]);
    5eb2:	f108 0a14 	add.w	sl, r8, #20
		events[0].state = K_POLL_STATE_NOT_READY;
    5eb6:	f8d8 300c 	ldr.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    5eba:	4650      	mov	r0, sl
		events[0].state = K_POLL_STATE_NOT_READY;
    5ebc:	f36f 3352 	bfc	r3, #13, #6
    5ec0:	f8c8 300c 	str.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    5ec4:	f002 fb8e 	bl	85e4 <bt_conn_prepare_events>
    5ec8:	1c46      	adds	r6, r0, #1
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    5eca:	484e      	ldr	r0, [pc, #312]	; (6004 <hci_tx_thread+0x160>)
    5ecc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5ed0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5ed4:	4631      	mov	r1, r6
    5ed6:	f01e ffc5 	bl	24e64 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    5eda:	b160      	cbz	r0, 5ef6 <hci_tx_thread+0x52>
    5edc:	494b      	ldr	r1, [pc, #300]	; (600c <hci_tx_thread+0x168>)
    5ede:	484c      	ldr	r0, [pc, #304]	; (6010 <hci_tx_thread+0x16c>)
    5ee0:	f640 1393 	movw	r3, #2451	; 0x993
    5ee4:	464a      	mov	r2, r9
    5ee6:	f01f f969 	bl	251bc <printk>
    5eea:	4040      	eors	r0, r0
    5eec:	f380 8811 	msr	BASEPRI, r0
    5ef0:	f04f 0003 	mov.w	r0, #3
    5ef4:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    5ef6:	4d47      	ldr	r5, [pc, #284]	; (6014 <hci_tx_thread+0x170>)
{
    5ef8:	4f42      	ldr	r7, [pc, #264]	; (6004 <hci_tx_thread+0x160>)
    5efa:	f505 7b8c 	add.w	fp, r5, #280	; 0x118
	for (; count; ev++, count--) {
    5efe:	b916      	cbnz	r6, 5f06 <hci_tx_thread+0x62>
	z_impl_k_yield();
    5f00:	f01e fc84 	bl	2480c <z_impl_k_yield>
	while (1) {
    5f04:	e7d7      	b.n	5eb6 <hci_tx_thread+0x12>
		switch (ev->state) {
    5f06:	68fb      	ldr	r3, [r7, #12]
    5f08:	f3c3 3345 	ubfx	r3, r3, #13, #6
    5f0c:	2b01      	cmp	r3, #1
    5f0e:	d962      	bls.n	5fd6 <hci_tx_thread+0x132>
    5f10:	2b04      	cmp	r3, #4
    5f12:	d16a      	bne.n	5fea <hci_tx_thread+0x146>
			if (ev->tag == BT_EVENT_CMD_TX) {
    5f14:	7b3b      	ldrb	r3, [r7, #12]
    5f16:	2b00      	cmp	r3, #0
    5f18:	d160      	bne.n	5fdc <hci_tx_thread+0x138>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    5f1a:	483f      	ldr	r0, [pc, #252]	; (6018 <hci_tx_thread+0x174>)
    5f1c:	2200      	movs	r2, #0
    5f1e:	2300      	movs	r3, #0
    5f20:	f025 fe86 	bl	2bc30 <net_buf_get>
	BT_ASSERT(buf);
    5f24:	4604      	mov	r4, r0
    5f26:	b960      	cbnz	r0, 5f42 <hci_tx_thread+0x9e>
    5f28:	493c      	ldr	r1, [pc, #240]	; (601c <hci_tx_thread+0x178>)
    5f2a:	4839      	ldr	r0, [pc, #228]	; (6010 <hci_tx_thread+0x16c>)
    5f2c:	f640 132a 	movw	r3, #2346	; 0x92a
    5f30:	464a      	mov	r2, r9
    5f32:	f01f f943 	bl	251bc <printk>
    5f36:	4040      	eors	r0, r0
    5f38:	f380 8811 	msr	BASEPRI, r0
    5f3c:	f04f 0003 	mov.w	r0, #3
    5f40:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    5f42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5f46:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5f4a:	4658      	mov	r0, fp
    5f4c:	f01e f828 	bl	23fa0 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    5f50:	f8d5 3130 	ldr.w	r3, [r5, #304]	; 0x130
    5f54:	b18b      	cbz	r3, 5f7a <hci_tx_thread+0xd6>
		BT_ERR("Uncleared pending sent_cmd");
    5f56:	4b32      	ldr	r3, [pc, #200]	; (6020 <hci_tx_thread+0x17c>)
    5f58:	4832      	ldr	r0, [pc, #200]	; (6024 <hci_tx_thread+0x180>)
    5f5a:	9306      	str	r3, [sp, #24]
    5f5c:	aa05      	add	r2, sp, #20
    5f5e:	2302      	movs	r3, #2
    5f60:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    5f64:	9301      	str	r3, [sp, #4]
    5f66:	9305      	str	r3, [sp, #20]
    5f68:	f021 ff47 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		net_buf_unref(bt_dev.sent_cmd);
    5f6c:	f8d5 0130 	ldr.w	r0, [r5, #304]	; 0x130
    5f70:	f01a fc90 	bl	20894 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    5f74:	2300      	movs	r3, #0
    5f76:	f8c5 3130 	str.w	r3, [r5, #304]	; 0x130
	bt_dev.sent_cmd = net_buf_ref(buf);
    5f7a:	4620      	mov	r0, r4
    5f7c:	f025 fea6 	bl	2bccc <net_buf_ref>
    5f80:	f8c5 0130 	str.w	r0, [r5, #304]	; 0x130
	BT_DBG("buf %p len %u type %u", buf, buf->len, bt_buf_get_type(buf));

	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		return bt_hci_ecc_send(buf);
    5f84:	4620      	mov	r0, r4
    5f86:	f7ff fa8d 	bl	54a4 <bt_hci_ecc_send>
	if (err) {
    5f8a:	b320      	cbz	r0, 5fd6 <hci_tx_thread+0x132>
		BT_ERR("Unable to send to driver (err %d)", err);
    5f8c:	4b26      	ldr	r3, [pc, #152]	; (6028 <hci_tx_thread+0x184>)
    5f8e:	aa05      	add	r2, sp, #20
    5f90:	e9cd 3006 	strd	r3, r0, [sp, #24]
    5f94:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    5f98:	2303      	movs	r3, #3
    5f9a:	4822      	ldr	r0, [pc, #136]	; (6024 <hci_tx_thread+0x180>)
    5f9c:	9301      	str	r3, [sp, #4]
    5f9e:	9305      	str	r3, [sp, #20]
    5fa0:	f021 ff2b 	bl	27dfa <z_log_msg2_static_create.constprop.0>
	z_impl_k_sem_give(sem);
    5fa4:	4821      	ldr	r0, [pc, #132]	; (602c <hci_tx_thread+0x188>)
    5fa6:	f01d ffd5 	bl	23f54 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    5faa:	4620      	mov	r0, r4
    5fac:	f01a fbb6 	bl	2071c <net_buf_id>
    5fb0:	4b1f      	ldr	r3, [pc, #124]	; (6030 <hci_tx_thread+0x18c>)
    5fb2:	220c      	movs	r2, #12
    5fb4:	fb02 3000 	mla	r0, r2, r0, r3
    5fb8:	211f      	movs	r1, #31
    5fba:	8840      	ldrh	r0, [r0, #2]
    5fbc:	4622      	mov	r2, r4
    5fbe:	f7ff fe8b 	bl	5cd8 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    5fc2:	f8d5 0130 	ldr.w	r0, [r5, #304]	; 0x130
    5fc6:	f01a fc65 	bl	20894 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    5fca:	2300      	movs	r3, #0
		net_buf_unref(buf);
    5fcc:	4620      	mov	r0, r4
		bt_dev.sent_cmd = NULL;
    5fce:	f8c5 3130 	str.w	r3, [r5, #304]	; 0x130
		net_buf_unref(buf);
    5fd2:	f01a fc5f 	bl	20894 <net_buf_unref>
	for (; count; ev++, count--) {
    5fd6:	3714      	adds	r7, #20
    5fd8:	3e01      	subs	r6, #1
    5fda:	e790      	b.n	5efe <hci_tx_thread+0x5a>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    5fdc:	2b01      	cmp	r3, #1
    5fde:	d1fa      	bne.n	5fd6 <hci_tx_thread+0x132>
					conn = CONTAINER_OF(ev->fifo,
    5fe0:	6938      	ldr	r0, [r7, #16]
					bt_conn_process_tx(conn);
    5fe2:	3838      	subs	r0, #56	; 0x38
    5fe4:	f002 fe74 	bl	8cd0 <bt_conn_process_tx>
    5fe8:	e7f5      	b.n	5fd6 <hci_tx_thread+0x132>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    5fea:	4a12      	ldr	r2, [pc, #72]	; (6034 <hci_tx_thread+0x190>)
    5fec:	480d      	ldr	r0, [pc, #52]	; (6024 <hci_tx_thread+0x180>)
		switch (ev->state) {
    5fee:	e9cd 2306 	strd	r2, r3, [sp, #24]
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    5ff2:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    5ff6:	2303      	movs	r3, #3
    5ff8:	aa05      	add	r2, sp, #20
    5ffa:	9301      	str	r3, [sp, #4]
    5ffc:	9305      	str	r3, [sp, #20]
    5ffe:	f021 fefc 	bl	27dfa <z_log_msg2_static_create.constprop.0>
			break;
    6002:	e7e8      	b.n	5fd6 <hci_tx_thread+0x132>
    6004:	20000358 	.word	0x20000358
    6008:	0002f878 	.word	0x0002f878
    600c:	0002f8ac 	.word	0x0002f8ac
    6010:	0002f8b5 	.word	0x0002f8b5
    6014:	20000080 	.word	0x20000080
    6018:	200001b4 	.word	0x200001b4
    601c:	0002f619 	.word	0x0002f619
    6020:	0002f8d2 	.word	0x0002f8d2
    6024:	0002daac 	.word	0x0002daac
    6028:	0002f8ed 	.word	0x0002f8ed
    602c:	20000198 	.word	0x20000198
    6030:	200025e8 	.word	0x200025e8
    6034:	0002f90f 	.word	0x0002f90f

00006038 <hci_num_completed_packets>:
{
    6038:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	for (i = 0; i < evt->num_handles; i++) {
    603c:	2500      	movs	r5, #0
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    603e:	6887      	ldr	r7, [r0, #8]
				BT_ERR("packets count mismatch");
    6040:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 6130 <hci_num_completed_packets+0xf8>
{
    6044:	b088      	sub	sp, #32
			tx->pending_no_cb = 0U;
    6046:	46a8      	mov	r8, r5
	for (i = 0; i < evt->num_handles; i++) {
    6048:	783b      	ldrb	r3, [r7, #0]
    604a:	429d      	cmp	r5, r3
    604c:	db02      	blt.n	6054 <hci_num_completed_packets+0x1c>
}
    604e:	b008      	add	sp, #32
    6050:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
    6054:	eb07 0385 	add.w	r3, r7, r5, lsl #2
    6058:	f8b3 a001 	ldrh.w	sl, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    605c:	f8b3 6003 	ldrh.w	r6, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
    6060:	4650      	mov	r0, sl
    6062:	f002 fafd 	bl	8660 <bt_conn_lookup_handle>
		if (!conn) {
    6066:	4604      	mov	r4, r0
    6068:	b1d8      	cbz	r0, 60a2 <hci_num_completed_packets+0x6a>
			k_work_submit(&conn->tx_complete_work);
    606a:	f100 0a28 	add.w	sl, r0, #40	; 0x28
		while (count--) {
    606e:	2e00      	cmp	r6, #0
    6070:	d03d      	beq.n	60ee <hci_num_completed_packets+0xb6>
	__asm__ volatile(
    6072:	f04f 0320 	mov.w	r3, #32
    6076:	f3ef 8211 	mrs	r2, BASEPRI
    607a:	f383 8812 	msr	BASEPRI_MAX, r3
    607e:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    6082:	69e3      	ldr	r3, [r4, #28]
    6084:	b1db      	cbz	r3, 60be <hci_num_completed_packets+0x86>
				conn->pending_no_cb--;
    6086:	3b01      	subs	r3, #1
    6088:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    608a:	f382 8811 	msr	BASEPRI, r2
    608e:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
    6092:	4620      	mov	r0, r4
    6094:	f002 f96e 	bl	8374 <bt_conn_get_pkts>
    6098:	3e01      	subs	r6, #1
    609a:	f01d ff5b 	bl	23f54 <z_impl_k_sem_give>
    609e:	b2b6      	uxth	r6, r6
    60a0:	e7e5      	b.n	606e <hci_num_completed_packets+0x36>
			BT_ERR("No connection for handle %u", handle);
    60a2:	4b24      	ldr	r3, [pc, #144]	; (6134 <hci_num_completed_packets+0xfc>)
    60a4:	4824      	ldr	r0, [pc, #144]	; (6138 <hci_num_completed_packets+0x100>)
    60a6:	e9cd 3a06 	strd	r3, sl, [sp, #24]
    60aa:	aa05      	add	r2, sp, #20
    60ac:	2303      	movs	r3, #3
    60ae:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    60b2:	9301      	str	r3, [sp, #4]
    60b4:	9305      	str	r3, [sp, #20]
    60b6:	f021 fea0 	bl	27dfa <z_log_msg2_static_create.constprop.0>
	for (i = 0; i < evt->num_handles; i++) {
    60ba:	3501      	adds	r5, #1
    60bc:	e7c4      	b.n	6048 <hci_num_completed_packets+0x10>
	return list->head;
    60be:	6963      	ldr	r3, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    60c0:	b12b      	cbz	r3, 60ce <hci_num_completed_packets+0x96>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    60c2:	69a1      	ldr	r1, [r4, #24]
	return node->next;
    60c4:	6818      	ldr	r0, [r3, #0]
	list->head = node;
    60c6:	6160      	str	r0, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    60c8:	428b      	cmp	r3, r1
	list->tail = node;
    60ca:	bf08      	it	eq
    60cc:	61a0      	streq	r0, [r4, #24]
    60ce:	f382 8811 	msr	BASEPRI, r2
    60d2:	f3bf 8f6f 	isb	sy
			if (!node) {
    60d6:	b973      	cbnz	r3, 60f6 <hci_num_completed_packets+0xbe>
				BT_ERR("packets count mismatch");
    60d8:	2302      	movs	r3, #2
    60da:	4817      	ldr	r0, [pc, #92]	; (6138 <hci_num_completed_packets+0x100>)
    60dc:	f8cd 9018 	str.w	r9, [sp, #24]
    60e0:	aa05      	add	r2, sp, #20
    60e2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    60e6:	9301      	str	r3, [sp, #4]
    60e8:	9305      	str	r3, [sp, #20]
    60ea:	f021 fe86 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		bt_conn_unref(conn);
    60ee:	4620      	mov	r0, r4
    60f0:	f022 f8fd 	bl	282ee <bt_conn_unref>
    60f4:	e7e1      	b.n	60ba <hci_num_completed_packets+0x82>
	__asm__ volatile(
    60f6:	f04f 0220 	mov.w	r2, #32
    60fa:	f3ef 8111 	mrs	r1, BASEPRI
    60fe:	f382 8812 	msr	BASEPRI_MAX, r2
    6102:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
    6106:	68da      	ldr	r2, [r3, #12]
    6108:	61e2      	str	r2, [r4, #28]
	return list->tail;
    610a:	6a62      	ldr	r2, [r4, #36]	; 0x24
			tx->pending_no_cb = 0U;
    610c:	f8c3 800c 	str.w	r8, [r3, #12]
	parent->next = child;
    6110:	f8c3 8000 	str.w	r8, [r3]
Z_GENLIST_APPEND(slist, snode)
    6114:	b94a      	cbnz	r2, 612a <hci_num_completed_packets+0xf2>
	list->head = node;
    6116:	e9c4 3308 	strd	r3, r3, [r4, #32]
	__asm__ volatile(
    611a:	f381 8811 	msr	BASEPRI, r1
    611e:	f3bf 8f6f 	isb	sy
			k_work_submit(&conn->tx_complete_work);
    6122:	4650      	mov	r0, sl
    6124:	f01e f882 	bl	2422c <k_work_submit>
    6128:	e7b3      	b.n	6092 <hci_num_completed_packets+0x5a>
	parent->next = child;
    612a:	6013      	str	r3, [r2, #0]
	list->tail = node;
    612c:	6263      	str	r3, [r4, #36]	; 0x24
}
    612e:	e7f4      	b.n	611a <hci_num_completed_packets+0xe2>
    6130:	0002f94c 	.word	0x0002f94c
    6134:	0002f930 	.word	0x0002f930
    6138:	0002daac 	.word	0x0002daac

0000613c <bt_hci_cmd_state_set_init>:
{
    613c:	b510      	push	{r4, lr}
	state->bit = bit;
    613e:	e9c1 2300 	strd	r2, r3, [r1]
	state->val = val;
    6142:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6146:	720b      	strb	r3, [r1, #8]
{
    6148:	460c      	mov	r4, r1
	cmd(buf)->state = state;
    614a:	f01a fae7 	bl	2071c <net_buf_id>
    614e:	4b03      	ldr	r3, [pc, #12]	; (615c <bt_hci_cmd_state_set_init+0x20>)
    6150:	220c      	movs	r2, #12
    6152:	fb02 3300 	mla	r3, r2, r0, r3
    6156:	605c      	str	r4, [r3, #4]
}
    6158:	bd10      	pop	{r4, pc}
    615a:	bf00      	nop
    615c:	200025e8 	.word	0x200025e8

00006160 <bt_hci_cmd_create>:
{
    6160:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return net_buf_alloc_fixed(pool, timeout);
    6164:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6168:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    616c:	4606      	mov	r6, r0
    616e:	4817      	ldr	r0, [pc, #92]	; (61cc <bt_hci_cmd_create+0x6c>)
	cmd(buf)->opcode = opcode;
    6170:	4d17      	ldr	r5, [pc, #92]	; (61d0 <bt_hci_cmd_create+0x70>)
{
    6172:	460f      	mov	r7, r1
    6174:	f025 fd57 	bl	2bc26 <net_buf_alloc_fixed>
    6178:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
    617a:	f100 0a08 	add.w	sl, r0, #8
    617e:	2100      	movs	r1, #0
    6180:	f04f 0800 	mov.w	r8, #0
    6184:	4650      	mov	r0, sl
    6186:	f025 fd73 	bl	2bc70 <net_buf_simple_reserve>
    618a:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
    618e:	4620      	mov	r0, r4
    6190:	f01a fac4 	bl	2071c <net_buf_id>
    6194:	f04f 090c 	mov.w	r9, #12
    6198:	fb09 5000 	mla	r0, r9, r0, r5
    619c:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
    619e:	4620      	mov	r0, r4
    61a0:	f01a fabc 	bl	2071c <net_buf_id>
    61a4:	fb09 5000 	mla	r0, r9, r0, r5
    61a8:	f8c0 8008 	str.w	r8, [r0, #8]
	cmd(buf)->state = NULL;
    61ac:	4620      	mov	r0, r4
    61ae:	f01a fab5 	bl	2071c <net_buf_id>
    61b2:	fb09 5500 	mla	r5, r9, r0, r5
	return net_buf_simple_add(&buf->b, len);
    61b6:	2103      	movs	r1, #3
    61b8:	f8c5 8004 	str.w	r8, [r5, #4]
    61bc:	4650      	mov	r0, sl
    61be:	f025 fdbd 	bl	2bd3c <net_buf_simple_add>
	hdr->param_len = param_len;
    61c2:	7087      	strb	r7, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    61c4:	8006      	strh	r6, [r0, #0]
}
    61c6:	4620      	mov	r0, r4
    61c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    61cc:	20001068 	.word	0x20001068
    61d0:	200025e8 	.word	0x200025e8

000061d4 <bt_hci_cmd_send>:
{
    61d4:	b530      	push	{r4, r5, lr}
    61d6:	4605      	mov	r5, r0
    61d8:	b089      	sub	sp, #36	; 0x24
	if (!buf) {
    61da:	460c      	mov	r4, r1
    61dc:	b919      	cbnz	r1, 61e6 <bt_hci_cmd_send+0x12>
		buf = bt_hci_cmd_create(opcode, 0);
    61de:	f7ff ffbf 	bl	6160 <bt_hci_cmd_create>
		if (!buf) {
    61e2:	4604      	mov	r4, r0
    61e4:	b300      	cbz	r0, 6228 <bt_hci_cmd_send+0x54>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    61e6:	f640 4335 	movw	r3, #3125	; 0xc35
    61ea:	429d      	cmp	r5, r3
    61ec:	d116      	bne.n	621c <bt_hci_cmd_send+0x48>
		return bt_hci_ecc_send(buf);
    61ee:	4620      	mov	r0, r4
    61f0:	f7ff f958 	bl	54a4 <bt_hci_ecc_send>
		if (err) {
    61f4:	4605      	mov	r5, r0
    61f6:	b170      	cbz	r0, 6216 <bt_hci_cmd_send+0x42>
			BT_ERR("Unable to send to driver (err %d)", err);
    61f8:	4b0d      	ldr	r3, [pc, #52]	; (6230 <bt_hci_cmd_send+0x5c>)
    61fa:	aa05      	add	r2, sp, #20
    61fc:	e9cd 3006 	strd	r3, r0, [sp, #24]
    6200:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    6204:	2303      	movs	r3, #3
    6206:	480b      	ldr	r0, [pc, #44]	; (6234 <bt_hci_cmd_send+0x60>)
    6208:	9301      	str	r3, [sp, #4]
    620a:	9305      	str	r3, [sp, #20]
    620c:	f021 fdf5 	bl	27dfa <z_log_msg2_static_create.constprop.0>
			net_buf_unref(buf);
    6210:	4620      	mov	r0, r4
    6212:	f01a fb3f 	bl	20894 <net_buf_unref>
}
    6216:	4628      	mov	r0, r5
    6218:	b009      	add	sp, #36	; 0x24
    621a:	bd30      	pop	{r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    621c:	4806      	ldr	r0, [pc, #24]	; (6238 <bt_hci_cmd_send+0x64>)
    621e:	4621      	mov	r1, r4
    6220:	f025 fd47 	bl	2bcb2 <net_buf_put>
	return 0;
    6224:	2500      	movs	r5, #0
    6226:	e7f6      	b.n	6216 <bt_hci_cmd_send+0x42>
			return -ENOBUFS;
    6228:	f06f 0568 	mvn.w	r5, #104	; 0x68
    622c:	e7f3      	b.n	6216 <bt_hci_cmd_send+0x42>
    622e:	bf00      	nop
    6230:	0002f8ed 	.word	0x0002f8ed
    6234:	0002daac 	.word	0x0002daac
    6238:	200001b4 	.word	0x200001b4

0000623c <le_conn_param_neg_reply>:
{
    623c:	b570      	push	{r4, r5, r6, lr}
    623e:	4606      	mov	r6, r0
    6240:	b088      	sub	sp, #32
    6242:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    6244:	f242 0021 	movw	r0, #8225	; 0x2021
    6248:	2103      	movs	r1, #3
    624a:	f7ff ff89 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    624e:	4604      	mov	r4, r0
    6250:	b960      	cbnz	r0, 626c <le_conn_param_neg_reply+0x30>
		BT_ERR("Unable to allocate buffer");
    6252:	4b0d      	ldr	r3, [pc, #52]	; (6288 <le_conn_param_neg_reply+0x4c>)
    6254:	9306      	str	r3, [sp, #24]
    6256:	480d      	ldr	r0, [pc, #52]	; (628c <le_conn_param_neg_reply+0x50>)
    6258:	2302      	movs	r3, #2
    625a:	aa05      	add	r2, sp, #20
    625c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    6260:	9301      	str	r3, [sp, #4]
    6262:	9305      	str	r3, [sp, #20]
    6264:	f021 fdc9 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    6268:	b008      	add	sp, #32
    626a:	bd70      	pop	{r4, r5, r6, pc}
    626c:	2103      	movs	r1, #3
    626e:	3008      	adds	r0, #8
    6270:	f025 fd64 	bl	2bd3c <net_buf_simple_add>
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    6274:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(handle);
    6276:	8006      	strh	r6, [r0, #0]
	cp->reason = sys_cpu_to_le16(reason);
    6278:	7085      	strb	r5, [r0, #2]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    627a:	f242 0021 	movw	r0, #8225	; 0x2021
}
    627e:	b008      	add	sp, #32
    6280:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    6284:	f7ff bfa6 	b.w	61d4 <bt_hci_cmd_send>
    6288:	0002f963 	.word	0x0002f963
    628c:	0002daac 	.word	0x0002daac

00006290 <le_conn_param_req>:
{
    6290:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    6292:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    6294:	78d9      	ldrb	r1, [r3, #3]
    6296:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
    6298:	881f      	ldrh	r7, [r3, #0]
{
    629a:	b08b      	sub	sp, #44	; 0x2c
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    629c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    62a0:	f8ad 2008 	strh.w	r2, [sp, #8]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    62a4:	7959      	ldrb	r1, [r3, #5]
    62a6:	791a      	ldrb	r2, [r3, #4]
    62a8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    62ac:	f8ad 200a 	strh.w	r2, [sp, #10]
	param.latency = sys_le16_to_cpu(evt->latency);
    62b0:	799a      	ldrb	r2, [r3, #6]
    62b2:	79d9      	ldrb	r1, [r3, #7]
    62b4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    62b8:	f8ad 200c 	strh.w	r2, [sp, #12]
	param.timeout = sys_le16_to_cpu(evt->timeout);
    62bc:	7a1a      	ldrb	r2, [r3, #8]
    62be:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
    62c0:	b2bc      	uxth	r4, r7
	param.timeout = sys_le16_to_cpu(evt->timeout);
    62c2:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
    62c6:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
    62c8:	f8ad 300e 	strh.w	r3, [sp, #14]
	conn = bt_conn_lookup_handle(handle);
    62cc:	f002 f9c8 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    62d0:	4606      	mov	r6, r0
    62d2:	b988      	cbnz	r0, 62f8 <le_conn_param_req+0x68>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    62d4:	4b20      	ldr	r3, [pc, #128]	; (6358 <le_conn_param_req+0xc8>)
    62d6:	4821      	ldr	r0, [pc, #132]	; (635c <le_conn_param_req+0xcc>)
    62d8:	e9cd 3408 	strd	r3, r4, [sp, #32]
    62dc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    62e0:	2303      	movs	r3, #3
    62e2:	aa07      	add	r2, sp, #28
    62e4:	9301      	str	r3, [sp, #4]
    62e6:	9307      	str	r3, [sp, #28]
    62e8:	f021 fd87 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    62ec:	2102      	movs	r1, #2
    62ee:	4620      	mov	r0, r4
    62f0:	f7ff ffa4 	bl	623c <le_conn_param_neg_reply>
}
    62f4:	b00b      	add	sp, #44	; 0x2c
    62f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
    62f8:	a902      	add	r1, sp, #8
    62fa:	f002 fb27 	bl	894c <le_param_req>
    62fe:	b938      	cbnz	r0, 6310 <le_conn_param_req+0x80>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    6300:	211e      	movs	r1, #30
    6302:	4620      	mov	r0, r4
    6304:	f7ff ff9a 	bl	623c <le_conn_param_neg_reply>
	bt_conn_unref(conn);
    6308:	4630      	mov	r0, r6
    630a:	f021 fff0 	bl	282ee <bt_conn_unref>
    630e:	e7f1      	b.n	62f4 <le_conn_param_req+0x64>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
    6310:	210e      	movs	r1, #14
    6312:	f242 0020 	movw	r0, #8224	; 0x2020
    6316:	f7ff ff23 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    631a:	4605      	mov	r5, r0
    631c:	2800      	cmp	r0, #0
    631e:	d0f3      	beq.n	6308 <le_conn_param_req+0x78>
    6320:	210e      	movs	r1, #14
    6322:	3008      	adds	r0, #8
    6324:	f025 fd0a 	bl	2bd3c <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
    6328:	220e      	movs	r2, #14
    632a:	4604      	mov	r4, r0
    632c:	2100      	movs	r1, #0
    632e:	f021 faaa 	bl	27886 <memset>
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
    6332:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6336:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
    6338:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    633c:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
    633e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    6342:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    6344:	f8bd 300e 	ldrh.w	r3, [sp, #14]
	cp->handle = sys_cpu_to_le16(handle);
    6348:	8027      	strh	r7, [r4, #0]
	cp->timeout = sys_cpu_to_le16(param->timeout);
    634a:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
    634c:	4629      	mov	r1, r5
    634e:	f242 0020 	movw	r0, #8224	; 0x2020
    6352:	f7ff ff3f 	bl	61d4 <bt_hci_cmd_send>
    6356:	e7d7      	b.n	6308 <le_conn_param_req+0x78>
    6358:	0002f73c 	.word	0x0002f73c
    635c:	0002daac 	.word	0x0002daac

00006360 <conn_auto_initiate>:
{
    6360:	b538      	push	{r3, r4, r5, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    6362:	7a83      	ldrb	r3, [r0, #10]
    6364:	2b07      	cmp	r3, #7
{
    6366:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    6368:	d121      	bne.n	63ae <conn_auto_initiate+0x4e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    636a:	f3bf 8f5b 	dmb	ish
    636e:	6843      	ldr	r3, [r0, #4]
    6370:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    6374:	049a      	lsls	r2, r3, #18
    6376:	d41a      	bmi.n	63ae <conn_auto_initiate+0x4e>
    6378:	78c3      	ldrb	r3, [r0, #3]
    637a:	b123      	cbz	r3, 6386 <conn_auto_initiate+0x26>
	     BT_FEAT_LE_PER_INIT_FEAT_XCHG(bt_dev.le.features))) {
    637c:	4b0c      	ldr	r3, [pc, #48]	; (63b0 <conn_auto_initiate+0x50>)
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
    637e:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
    6382:	071b      	lsls	r3, r3, #28
    6384:	d513      	bpl.n	63ae <conn_auto_initiate+0x4e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    6386:	2102      	movs	r1, #2
    6388:	f242 0016 	movw	r0, #8214	; 0x2016
    638c:	f7ff fee8 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    6390:	4605      	mov	r5, r0
    6392:	b160      	cbz	r0, 63ae <conn_auto_initiate+0x4e>
    6394:	2102      	movs	r1, #2
    6396:	3008      	adds	r0, #8
    6398:	f025 fcd0 	bl	2bd3c <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    639c:	8823      	ldrh	r3, [r4, #0]
    639e:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    63a0:	4629      	mov	r1, r5
    63a2:	f242 0016 	movw	r0, #8214	; 0x2016
}
    63a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    63aa:	f7ff bf13 	b.w	61d4 <bt_hci_cmd_send>
}
    63ae:	bd38      	pop	{r3, r4, r5, pc}
    63b0:	20000080 	.word	0x20000080

000063b4 <le_remote_feat_complete>:
{
    63b4:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    63b6:	6885      	ldr	r5, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    63b8:	f8b5 6001 	ldrh.w	r6, [r5, #1]
{
    63bc:	b088      	sub	sp, #32
	conn = bt_conn_lookup_handle(handle);
    63be:	4630      	mov	r0, r6
    63c0:	f002 f94e 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    63c4:	4604      	mov	r4, r0
    63c6:	b968      	cbnz	r0, 63e4 <le_remote_feat_complete+0x30>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    63c8:	4b11      	ldr	r3, [pc, #68]	; (6410 <le_remote_feat_complete+0x5c>)
    63ca:	4812      	ldr	r0, [pc, #72]	; (6414 <le_remote_feat_complete+0x60>)
    63cc:	e9cd 3606 	strd	r3, r6, [sp, #24]
    63d0:	aa05      	add	r2, sp, #20
    63d2:	2303      	movs	r3, #3
    63d4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    63d8:	9301      	str	r3, [sp, #4]
    63da:	9305      	str	r3, [sp, #20]
    63dc:	f021 fd0d 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    63e0:	b008      	add	sp, #32
    63e2:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
    63e4:	782b      	ldrb	r3, [r5, #0]
    63e6:	b923      	cbnz	r3, 63f2 <le_remote_feat_complete+0x3e>
		memcpy(conn->le.features, evt->features,
    63e8:	2208      	movs	r2, #8
    63ea:	1ce9      	adds	r1, r5, #3
    63ec:	30ac      	adds	r0, #172	; 0xac
    63ee:	f021 fa3f 	bl	27870 <memcpy>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    63f2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    63f6:	1d20      	adds	r0, r4, #4
    63f8:	f021 fcf0 	bl	27ddc <atomic_or>
	conn_auto_initiate(conn);
    63fc:	4620      	mov	r0, r4
    63fe:	f7ff ffaf 	bl	6360 <conn_auto_initiate>
	bt_conn_unref(conn);
    6402:	4620      	mov	r0, r4
}
    6404:	b008      	add	sp, #32
    6406:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
    640a:	f021 bf70 	b.w	282ee <bt_conn_unref>
    640e:	bf00      	nop
    6410:	0002f73c 	.word	0x0002f73c
    6414:	0002daac 	.word	0x0002daac

00006418 <bt_hci_cmd_send_sync>:
{
    6418:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    641c:	b089      	sub	sp, #36	; 0x24
    641e:	4680      	mov	r8, r0
    6420:	af00      	add	r7, sp, #0
    6422:	4615      	mov	r5, r2
	if (!buf) {
    6424:	460c      	mov	r4, r1
    6426:	b921      	cbnz	r1, 6432 <bt_hci_cmd_send_sync+0x1a>
		buf = bt_hci_cmd_create(opcode, 0);
    6428:	f7ff fe9a 	bl	6160 <bt_hci_cmd_create>
		if (!buf) {
    642c:	4604      	mov	r4, r0
    642e:	2800      	cmp	r0, #0
    6430:	d05e      	beq.n	64f0 <bt_hci_cmd_send_sync+0xd8>
	return z_impl_k_sem_init(sem, initial_count, limit);
    6432:	f107 0608 	add.w	r6, r7, #8
    6436:	2201      	movs	r2, #1
    6438:	2100      	movs	r1, #0
    643a:	4630      	mov	r0, r6
    643c:	f026 fc1f 	bl	2cc7e <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    6440:	4620      	mov	r0, r4
    6442:	f01a f96b 	bl	2071c <net_buf_id>
    6446:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 64f8 <bt_hci_cmd_send_sync+0xe0>
    644a:	230c      	movs	r3, #12
    644c:	fb03 9000 	mla	r0, r3, r0, r9
    6450:	6086      	str	r6, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
    6452:	4620      	mov	r0, r4
    6454:	f025 fc3a 	bl	2bccc <net_buf_ref>
    6458:	4601      	mov	r1, r0
    645a:	4828      	ldr	r0, [pc, #160]	; (64fc <bt_hci_cmd_send_sync+0xe4>)
    645c:	f025 fc29 	bl	2bcb2 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    6460:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    6464:	4630      	mov	r0, r6
    6466:	2300      	movs	r3, #0
    6468:	f01d fd9a 	bl	23fa0 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    646c:	4606      	mov	r6, r0
    646e:	b180      	cbz	r0, 6492 <bt_hci_cmd_send_sync+0x7a>
    6470:	4a23      	ldr	r2, [pc, #140]	; (6500 <bt_hci_cmd_send_sync+0xe8>)
    6472:	4924      	ldr	r1, [pc, #144]	; (6504 <bt_hci_cmd_send_sync+0xec>)
    6474:	4824      	ldr	r0, [pc, #144]	; (6508 <bt_hci_cmd_send_sync+0xf0>)
    6476:	f240 1331 	movw	r3, #305	; 0x131
    647a:	f01e fe9f 	bl	251bc <printk>
    647e:	4823      	ldr	r0, [pc, #140]	; (650c <bt_hci_cmd_send_sync+0xf4>)
    6480:	4631      	mov	r1, r6
    6482:	f01e fe9b 	bl	251bc <printk>
    6486:	4040      	eors	r0, r0
    6488:	f380 8811 	msr	BASEPRI, r0
    648c:	f04f 0003 	mov.w	r0, #3
    6490:	df02      	svc	2
	status = cmd(buf)->status;
    6492:	4620      	mov	r0, r4
    6494:	f01a f942 	bl	2071c <net_buf_id>
    6498:	230c      	movs	r3, #12
    649a:	4358      	muls	r0, r3
    649c:	f819 6000 	ldrb.w	r6, [r9, r0]
	if (status) {
    64a0:	b1ee      	cbz	r6, 64de <bt_hci_cmd_send_sync+0xc6>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    64a2:	4b1b      	ldr	r3, [pc, #108]	; (6510 <bt_hci_cmd_send_sync+0xf8>)
    64a4:	481b      	ldr	r0, [pc, #108]	; (6514 <bt_hci_cmd_send_sync+0xfc>)
    64a6:	466d      	mov	r5, sp
    64a8:	b088      	sub	sp, #32
    64aa:	466a      	mov	r2, sp
    64ac:	e9c2 3804 	strd	r3, r8, [r2, #16]
    64b0:	2304      	movs	r3, #4
    64b2:	6196      	str	r6, [r2, #24]
    64b4:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    64b8:	f842 3f0c 	str.w	r3, [r2, #12]!
    64bc:	607b      	str	r3, [r7, #4]
    64be:	f021 fc9c 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    64c2:	4620      	mov	r0, r4
    64c4:	46ad      	mov	sp, r5
    64c6:	f01a f9e5 	bl	20894 <net_buf_unref>
			return -EIO;
    64ca:	2e09      	cmp	r6, #9
    64cc:	bf0c      	ite	eq
    64ce:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
    64d2:	f06f 0004 	mvnne.w	r0, #4
}
    64d6:	3724      	adds	r7, #36	; 0x24
    64d8:	46bd      	mov	sp, r7
    64da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (rsp) {
    64de:	b115      	cbz	r5, 64e6 <bt_hci_cmd_send_sync+0xce>
		*rsp = buf;
    64e0:	602c      	str	r4, [r5, #0]
	return 0;
    64e2:	4630      	mov	r0, r6
    64e4:	e7f7      	b.n	64d6 <bt_hci_cmd_send_sync+0xbe>
		net_buf_unref(buf);
    64e6:	4620      	mov	r0, r4
    64e8:	f01a f9d4 	bl	20894 <net_buf_unref>
	return 0;
    64ec:	4628      	mov	r0, r5
    64ee:	e7f2      	b.n	64d6 <bt_hci_cmd_send_sync+0xbe>
			return -ENOBUFS;
    64f0:	f06f 0068 	mvn.w	r0, #104	; 0x68
    64f4:	e7ef      	b.n	64d6 <bt_hci_cmd_send_sync+0xbe>
    64f6:	bf00      	nop
    64f8:	200025e8 	.word	0x200025e8
    64fc:	200001b4 	.word	0x200001b4
    6500:	0002f878 	.word	0x0002f878
    6504:	0002f8ac 	.word	0x0002f8ac
    6508:	0002f8b5 	.word	0x0002f8b5
    650c:	0002f97d 	.word	0x0002f97d
    6510:	0002f99d 	.word	0x0002f99d
    6514:	0002daac 	.word	0x0002daac

00006518 <bt_hci_le_enh_conn_complete>:
{
    6518:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    651c:	f8b0 7001 	ldrh.w	r7, [r0, #1]
		if (disconnected_handles[i] == handle) {
    6520:	4a7a      	ldr	r2, [pc, #488]	; (670c <bt_hci_le_enh_conn_complete+0x1f4>)
	if (evt->status) {
    6522:	7804      	ldrb	r4, [r0, #0]
		if (disconnected_handles[i] == handle) {
    6524:	8811      	ldrh	r1, [r2, #0]
	handle |= ~BT_ACL_HANDLE_MASK;
    6526:	ea6f 5307 	mvn.w	r3, r7, lsl #20
    652a:	ea6f 5313 	mvn.w	r3, r3, lsr #20
		if (disconnected_handles[i] == handle) {
    652e:	b29b      	uxth	r3, r3
    6530:	4299      	cmp	r1, r3
    6532:	f04f 0600 	mov.w	r6, #0
			disconnected_handles[i] = 0;
    6536:	bf08      	it	eq
    6538:	8016      	strheq	r6, [r2, #0]
{
    653a:	b08d      	sub	sp, #52	; 0x34
    653c:	4605      	mov	r5, r0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    653e:	fa1f f887 	uxth.w	r8, r7
			return true;
    6542:	bf08      	it	eq
    6544:	2601      	moveq	r6, #1
	if (evt->status) {
    6546:	2c00      	cmp	r4, #0
    6548:	d037      	beq.n	65ba <bt_hci_le_enh_conn_complete+0xa2>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    654a:	2c3c      	cmp	r4, #60	; 0x3c
    654c:	d12b      	bne.n	65a6 <bt_hci_le_enh_conn_complete+0x8e>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    654e:	f001 f8e1 	bl	7714 <bt_le_adv_lookup_legacy>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    6552:	f3bf 8f5b 	dmb	ish
    6556:	3010      	adds	r0, #16
    6558:	e850 3f00 	ldrex	r3, [r0]
    655c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    6560:	e840 3200 	strex	r2, r3, [r0]
    6564:	2a00      	cmp	r2, #0
    6566:	d1f7      	bne.n	6558 <bt_hci_le_enh_conn_complete+0x40>
    6568:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
    656c:	2000      	movs	r0, #0
    656e:	f7ff fa79 	bl	5a64 <find_pending_connect.part.0>
		if (!conn) {
    6572:	4605      	mov	r5, r0
    6574:	b968      	cbnz	r0, 6592 <bt_hci_le_enh_conn_complete+0x7a>
			BT_ERR("No pending peripheral connection");
    6576:	4b66      	ldr	r3, [pc, #408]	; (6710 <bt_hci_le_enh_conn_complete+0x1f8>)
    6578:	930a      	str	r3, [sp, #40]	; 0x28
    657a:	2302      	movs	r3, #2
    657c:	9304      	str	r3, [sp, #16]
    657e:	9309      	str	r3, [sp, #36]	; 0x24
    6580:	aa09      	add	r2, sp, #36	; 0x24
    6582:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_WARN("Unexpected status 0x%02x", evt->status);
    6586:	4863      	ldr	r0, [pc, #396]	; (6714 <bt_hci_le_enh_conn_complete+0x1fc>)
    6588:	f021 fc37 	bl	27dfa <z_log_msg2_static_create.constprop.0>
}
    658c:	b00d      	add	sp, #52	; 0x34
    658e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
    6592:	7244      	strb	r4, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    6594:	2100      	movs	r1, #0
    6596:	f002 f86b 	bl	8670 <bt_conn_set_state>
		bt_conn_unref(conn);
    659a:	4628      	mov	r0, r5
}
    659c:	b00d      	add	sp, #52	; 0x34
    659e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		bt_conn_unref(conn);
    65a2:	f021 bea4 	b.w	282ee <bt_conn_unref>
		BT_WARN("Unexpected status 0x%02x", evt->status);
    65a6:	4b5c      	ldr	r3, [pc, #368]	; (6718 <bt_hci_le_enh_conn_complete+0x200>)
    65a8:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    65ac:	2303      	movs	r3, #3
    65ae:	9304      	str	r3, [sp, #16]
    65b0:	9309      	str	r3, [sp, #36]	; 0x24
    65b2:	aa09      	add	r2, sp, #36	; 0x24
    65b4:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    65b8:	e7e5      	b.n	6586 <bt_hci_le_enh_conn_complete+0x6e>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    65ba:	7903      	ldrb	r3, [r0, #4]
    65bc:	3b02      	subs	r3, #2
    65be:	2b01      	cmp	r3, #1
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
    65c0:	f100 0904 	add.w	r9, r0, #4
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    65c4:	d842      	bhi.n	664c <bt_hci_le_enh_conn_complete+0x134>
	memcpy(dst, src, sizeof(*dst));
    65c6:	2207      	movs	r2, #7
    65c8:	4649      	mov	r1, r9
    65ca:	a806      	add	r0, sp, #24
    65cc:	f021 f950 	bl	27870 <memcpy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    65d0:	f89d 3018 	ldrb.w	r3, [sp, #24]
	memcpy(dst, src, sizeof(*dst));
    65d4:	2206      	movs	r2, #6
    65d6:	3b02      	subs	r3, #2
    65d8:	f105 0111 	add.w	r1, r5, #17
    65dc:	f10d 0011 	add.w	r0, sp, #17
    65e0:	f88d 3018 	strb.w	r3, [sp, #24]
    65e4:	f021 f944 	bl	27870 <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    65e8:	2301      	movs	r3, #1
    65ea:	f88d 3010 	strb.w	r3, [sp, #16]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
    65ee:	78eb      	ldrb	r3, [r5, #3]
    65f0:	2b01      	cmp	r3, #1
    65f2:	d119      	bne.n	6628 <bt_hci_le_enh_conn_complete+0x110>
    65f4:	a806      	add	r0, sp, #24
    65f6:	f7ff fa35 	bl	5a64 <find_pending_connect.part.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    65fa:	78eb      	ldrb	r3, [r5, #3]
    65fc:	2b01      	cmp	r3, #1
    65fe:	4604      	mov	r4, r0
    6600:	d111      	bne.n	6626 <bt_hci_le_enh_conn_complete+0x10e>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    6602:	f001 f887 	bl	7714 <bt_le_adv_lookup_legacy>
    6606:	f3bf 8f5b 	dmb	ish
    660a:	f100 0310 	add.w	r3, r0, #16
    660e:	e853 2f00 	ldrex	r2, [r3]
    6612:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    6616:	e843 2100 	strex	r1, r2, [r3]
    661a:	2900      	cmp	r1, #0
    661c:	d1f7      	bne.n	660e <bt_hci_le_enh_conn_complete+0xf6>
    661e:	f3bf 8f5b 	dmb	ish
		(void)bt_le_lim_adv_cancel_timeout(adv);
    6622:	f021 fdd6 	bl	281d2 <bt_le_lim_adv_cancel_timeout>
	if (!conn) {
    6626:	bb34      	cbnz	r4, 6676 <bt_hci_le_enh_conn_complete+0x15e>
		BT_ERR("No pending conn for peer %s",
    6628:	4648      	mov	r0, r9
    662a:	f7fe fdb7 	bl	519c <bt_addr_le_str_real>
    662e:	4b3b      	ldr	r3, [pc, #236]	; (671c <bt_hci_le_enh_conn_complete+0x204>)
    6630:	9301      	str	r3, [sp, #4]
    6632:	2300      	movs	r3, #0
    6634:	9002      	str	r0, [sp, #8]
    6636:	4937      	ldr	r1, [pc, #220]	; (6714 <bt_hci_le_enh_conn_complete+0x1fc>)
    6638:	9300      	str	r3, [sp, #0]
    663a:	4618      	mov	r0, r3
    663c:	2201      	movs	r2, #1
    663e:	f021 fbdf 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
    6642:	211f      	movs	r1, #31
    6644:	4640      	mov	r0, r8
    6646:	f021 fbe9 	bl	27e1c <bt_hci_disconnect>
		return;
    664a:	e79f      	b.n	658c <bt_hci_le_enh_conn_complete+0x74>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
    664c:	78c3      	ldrb	r3, [r0, #3]
    664e:	2b01      	cmp	r3, #1
    6650:	bf04      	itt	eq
    6652:	4b33      	ldreq	r3, [pc, #204]	; (6720 <bt_hci_le_enh_conn_complete+0x208>)
    6654:	f893 4067 	ldrbeq.w	r4, [r3, #103]	; 0x67
		bt_addr_le_copy(&id_addr,
    6658:	4649      	mov	r1, r9
    665a:	4620      	mov	r0, r4
    665c:	f021 fca1 	bl	27fa2 <bt_lookup_id_addr>
	memcpy(dst, src, sizeof(*dst));
    6660:	2207      	movs	r2, #7
    6662:	4601      	mov	r1, r0
    6664:	a806      	add	r0, sp, #24
    6666:	f021 f903 	bl	27870 <memcpy>
    666a:	2207      	movs	r2, #7
    666c:	4649      	mov	r1, r9
    666e:	a804      	add	r0, sp, #16
    6670:	f021 f8fe 	bl	27870 <memcpy>
}
    6674:	e7bb      	b.n	65ee <bt_hci_le_enh_conn_complete+0xd6>
	conn->handle = handle;
    6676:	4620      	mov	r0, r4
	memcpy(dst, src, sizeof(*dst));
    6678:	2207      	movs	r2, #7
    667a:	f820 7b88 	strh.w	r7, [r0], #136
    667e:	a906      	add	r1, sp, #24
    6680:	f021 f8f6 	bl	27870 <memcpy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    6684:	7e2a      	ldrb	r2, [r5, #24]
    6686:	7deb      	ldrb	r3, [r5, #23]
    6688:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    668c:	f8a4 309e 	strh.w	r3, [r4, #158]	; 0x9e
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    6690:	7eaa      	ldrb	r2, [r5, #26]
    6692:	7e6b      	ldrb	r3, [r5, #25]
    6694:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    6698:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    669c:	7f2a      	ldrb	r2, [r5, #28]
    669e:	7eeb      	ldrb	r3, [r5, #27]
    66a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    66a4:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
	conn->role = evt->role;
    66a8:	78eb      	ldrb	r3, [r5, #3]
    66aa:	70e3      	strb	r3, [r4, #3]
	conn->err = 0U;
    66ac:	2200      	movs	r2, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    66ae:	2b01      	cmp	r3, #1
	conn->err = 0U;
    66b0:	7262      	strb	r2, [r4, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    66b2:	d117      	bne.n	66e4 <bt_hci_le_enh_conn_complete+0x1cc>
    66b4:	2207      	movs	r2, #7
    66b6:	a904      	add	r1, sp, #16
    66b8:	f104 008f 	add.w	r0, r4, #143	; 0x8f
    66bc:	f021 f8d8 	bl	27870 <memcpy>
			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    66c0:	f001 f828 	bl	7714 <bt_le_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
    66c4:	7a21      	ldrb	r1, [r4, #8]
    66c6:	4d16      	ldr	r5, [pc, #88]	; (6720 <bt_hci_le_enh_conn_complete+0x208>)
    66c8:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    66cc:	2207      	movs	r2, #7
    66ce:	4429      	add	r1, r5
    66d0:	f104 0096 	add.w	r0, r4, #150	; 0x96
    66d4:	f021 f8cc 	bl	27870 <memcpy>
		if (BT_LE_STATES_PER_CONN_ADV(bt_dev.le.states)) {
    66d8:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
    66dc:	065b      	lsls	r3, r3, #25
    66de:	d501      	bpl.n	66e4 <bt_hci_le_enh_conn_complete+0x1cc>
			bt_le_adv_resume();
    66e0:	f001 f9fa 	bl	7ad8 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    66e4:	2107      	movs	r1, #7
    66e6:	4620      	mov	r0, r4
    66e8:	f001 ffc2 	bl	8670 <bt_conn_set_state>
	if (is_disconnected) {
    66ec:	b11e      	cbz	r6, 66f6 <bt_hci_le_enh_conn_complete+0x1de>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
    66ee:	2101      	movs	r1, #1
    66f0:	4620      	mov	r0, r4
    66f2:	f001 ffbd 	bl	8670 <bt_conn_set_state>
	bt_conn_connected(conn);
    66f6:	4620      	mov	r0, r4
    66f8:	f021 fe35 	bl	28366 <bt_conn_connected>
	conn_auto_initiate(conn);
    66fc:	4620      	mov	r0, r4
    66fe:	f7ff fe2f 	bl	6360 <conn_auto_initiate>
	bt_conn_unref(conn);
    6702:	4620      	mov	r0, r4
    6704:	f021 fdf3 	bl	282ee <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
    6708:	e740      	b.n	658c <bt_hci_le_enh_conn_complete+0x74>
    670a:	bf00      	nop
    670c:	2000388c 	.word	0x2000388c
    6710:	0002f9b9 	.word	0x0002f9b9
    6714:	0002daac 	.word	0x0002daac
    6718:	0002f9da 	.word	0x0002f9da
    671c:	0002f9f3 	.word	0x0002f9f3
    6720:	20000080 	.word	0x20000080

00006724 <hci_event_prio>:
		      sizeof(struct bt_hci_evt_num_completed_packets)),
#endif /* CONFIG_BT_CONN_TX */
};

void hci_event_prio(struct net_buf *buf)
{
    6724:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6728:	4604      	mov	r4, r0
	struct net_buf_simple_state state;
	struct bt_hci_evt_hdr *hdr;
	uint8_t evt_flags;

	net_buf_simple_save(&buf->b, &state);
    672a:	f100 0608 	add.w	r6, r0, #8
	state->offset = net_buf_simple_headroom(buf);
    672e:	4630      	mov	r0, r6
    6730:	f025 fba7 	bl	2be82 <net_buf_simple_headroom>
	state->len = buf->len;
    6734:	f8b4 800c 	ldrh.w	r8, [r4, #12]

	BT_ASSERT(buf->len >= sizeof(*hdr));
    6738:	f1b8 0f01 	cmp.w	r8, #1
	state->offset = net_buf_simple_headroom(buf);
    673c:	4605      	mov	r5, r0
    673e:	d80c      	bhi.n	675a <hci_event_prio+0x36>
    6740:	4a1c      	ldr	r2, [pc, #112]	; (67b4 <hci_event_prio+0x90>)
    6742:	491d      	ldr	r1, [pc, #116]	; (67b8 <hci_event_prio+0x94>)
    6744:	481d      	ldr	r0, [pc, #116]	; (67bc <hci_event_prio+0x98>)
    6746:	f640 532f 	movw	r3, #3375	; 0xd2f
    674a:	f01e fd37 	bl	251bc <printk>
    674e:	4040      	eors	r0, r0
    6750:	f380 8811 	msr	BASEPRI, r0
    6754:	f04f 0003 	mov.w	r0, #3
    6758:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    675a:	4630      	mov	r0, r6
    675c:	2102      	movs	r1, #2
    675e:	f025 fb65 	bl	2be2c <net_buf_simple_pull_mem>
    6762:	4607      	mov	r7, r0

	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    6764:	7800      	ldrb	r0, [r0, #0]
    6766:	f021 fb27 	bl	27db8 <bt_hci_evt_get_flags>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    676a:	07c2      	lsls	r2, r0, #31
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    676c:	4606      	mov	r6, r0
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    676e:	d40c      	bmi.n	678a <hci_event_prio+0x66>
    6770:	4a10      	ldr	r2, [pc, #64]	; (67b4 <hci_event_prio+0x90>)
    6772:	4913      	ldr	r1, [pc, #76]	; (67c0 <hci_event_prio+0x9c>)
    6774:	4811      	ldr	r0, [pc, #68]	; (67bc <hci_event_prio+0x98>)
    6776:	f640 5333 	movw	r3, #3379	; 0xd33
    677a:	f01e fd1f 	bl	251bc <printk>
    677e:	4040      	eors	r0, r0
    6780:	f380 8811 	msr	BASEPRI, r0
    6784:	f04f 0003 	mov.w	r0, #3
    6788:	df02      	svc	2

	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    678a:	2305      	movs	r3, #5
    678c:	4a0d      	ldr	r2, [pc, #52]	; (67c4 <hci_event_prio+0xa0>)
    678e:	7838      	ldrb	r0, [r7, #0]
    6790:	4621      	mov	r1, r4
    6792:	f7ff fa51 	bl	5c38 <handle_event>

	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    6796:	07b3      	lsls	r3, r6, #30
    6798:	d507      	bpl.n	67aa <hci_event_prio+0x86>
	buf->data = buf->__buf + state->offset;
    679a:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    679c:	f8a4 800c 	strh.w	r8, [r4, #12]
	buf->data = buf->__buf + state->offset;
    67a0:	fa10 f585 	uxtah	r5, r0, r5
    67a4:	60a5      	str	r5, [r4, #8]
		net_buf_simple_restore(&buf->b, &state);
	} else {
		net_buf_unref(buf);
	}
}
    67a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
    67aa:	4620      	mov	r0, r4
}
    67ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
    67b0:	f01a b870 	b.w	20894 <net_buf_unref>
    67b4:	0002f878 	.word	0x0002f878
    67b8:	0002fa0f 	.word	0x0002fa0f
    67bc:	0002f8b5 	.word	0x0002f8b5
    67c0:	0002fa28 	.word	0x0002fa28
    67c4:	0002e198 	.word	0x0002e198

000067c8 <bt_recv>:

k_tid_t bt_recv_thread_id;

int bt_recv(struct net_buf *buf)
{
    67c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (bt_recv_thread_id == NULL) {
    67ca:	4d53      	ldr	r5, [pc, #332]	; (6918 <bt_recv+0x150>)
{
    67cc:	b089      	sub	sp, #36	; 0x24
	if (bt_recv_thread_id == NULL) {
    67ce:	682b      	ldr	r3, [r5, #0]
{
    67d0:	af00      	add	r7, sp, #0
    67d2:	4604      	mov	r4, r0
	if (bt_recv_thread_id == NULL) {
    67d4:	b913      	cbnz	r3, 67dc <bt_recv+0x14>
	return z_impl_z_current_get();
    67d6:	f01e f8bb 	bl	24950 <z_impl_z_current_get>
		bt_recv_thread_id = k_current_get();
    67da:	6028      	str	r0, [r5, #0]
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    67dc:	7d23      	ldrb	r3, [r4, #20]

	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_DBG("buf %p len %u", buf, buf->len);

	switch (bt_buf_get_type(buf)) {
    67de:	2b01      	cmp	r3, #1
    67e0:	d058      	beq.n	6894 <bt_recv+0xcc>
    67e2:	2b03      	cmp	r3, #3
    67e4:	f040 8085 	bne.w	68f2 <bt_recv+0x12a>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    67e8:	89a3      	ldrh	r3, [r4, #12]
    67ea:	2b03      	cmp	r3, #3
    67ec:	d80c      	bhi.n	6808 <bt_recv+0x40>
    67ee:	4a4b      	ldr	r2, [pc, #300]	; (691c <bt_recv+0x154>)
    67f0:	494b      	ldr	r1, [pc, #300]	; (6920 <bt_recv+0x158>)
    67f2:	484c      	ldr	r0, [pc, #304]	; (6924 <bt_recv+0x15c>)
    67f4:	f240 13b5 	movw	r3, #437	; 0x1b5
    67f8:	f01e fce0 	bl	251bc <printk>
    67fc:	4040      	eors	r0, r0
    67fe:	f380 8811 	msr	BASEPRI, r0
    6802:	f04f 0003 	mov.w	r0, #3
    6806:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    6808:	2104      	movs	r1, #4
    680a:	f104 0008 	add.w	r0, r4, #8
    680e:	f025 fb0d 	bl	2be2c <net_buf_simple_pull_mem>
	if (buf->len != len) {
    6812:	89a1      	ldrh	r1, [r4, #12]
	len = sys_le16_to_cpu(hdr->len);
    6814:	8843      	ldrh	r3, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    6816:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    6818:	22ff      	movs	r2, #255	; 0xff
	acl(buf)->handle = bt_acl_handle(handle);
    681a:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
    681e:	428b      	cmp	r3, r1
	acl(buf)->handle = bt_acl_handle(handle);
    6820:	82e0      	strh	r0, [r4, #22]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    6822:	7562      	strb	r2, [r4, #21]
	if (buf->len != len) {
    6824:	d014      	beq.n	6850 <bt_recv+0x88>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    6826:	466d      	mov	r5, sp
    6828:	b088      	sub	sp, #32
    682a:	466a      	mov	r2, sp
    682c:	483e      	ldr	r0, [pc, #248]	; (6928 <bt_recv+0x160>)
    682e:	6193      	str	r3, [r2, #24]
    6830:	2304      	movs	r3, #4
    6832:	e9c2 0104 	strd	r0, r1, [r2, #16]
    6836:	f842 3f0c 	str.w	r3, [r2, #12]!
    683a:	483c      	ldr	r0, [pc, #240]	; (692c <bt_recv+0x164>)
    683c:	60bb      	str	r3, [r7, #8]
    683e:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    6842:	f021 fada 	bl	27dfa <z_log_msg2_static_create.constprop.0>
    6846:	46ad      	mov	sp, r5
	net_buf_unref(buf);
    6848:	4620      	mov	r0, r4
    684a:	f01a f823 	bl	20894 <net_buf_unref>
    684e:	e01d      	b.n	688c <bt_recv+0xc4>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    6850:	f001 ff06 	bl	8660 <bt_conn_lookup_handle>
	if (!conn) {
    6854:	4605      	mov	r5, r0
    6856:	b970      	cbnz	r0, 6876 <bt_recv+0xae>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    6858:	8ae3      	ldrh	r3, [r4, #22]
    685a:	4a35      	ldr	r2, [pc, #212]	; (6930 <bt_recv+0x168>)
    685c:	4833      	ldr	r0, [pc, #204]	; (692c <bt_recv+0x164>)
    685e:	e9c7 2306 	strd	r2, r3, [r7, #24]
    6862:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    6866:	2303      	movs	r3, #3
    6868:	f107 0214 	add.w	r2, r7, #20
    686c:	607b      	str	r3, [r7, #4]
    686e:	617b      	str	r3, [r7, #20]
    6870:	f021 fac3 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    6874:	e7e8      	b.n	6848 <bt_recv+0x80>
	acl(buf)->index = bt_conn_index(conn);
    6876:	f001 ffed 	bl	8854 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    687a:	0b32      	lsrs	r2, r6, #12
	acl(buf)->index = bt_conn_index(conn);
    687c:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    687e:	4621      	mov	r1, r4
    6880:	4628      	mov	r0, r5
    6882:	f001 fdaf 	bl	83e4 <bt_conn_recv>
	bt_conn_unref(conn);
    6886:	4628      	mov	r0, r5
    6888:	f021 fd31 	bl	282ee <bt_conn_unref>

		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
			net_buf_put(&bt_dev.rx_queue, buf);
		}
#endif
		return 0;
    688c:	2000      	movs	r0, #0
	default:
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
		net_buf_unref(buf);
		return -EINVAL;
	}
}
    688e:	3724      	adds	r7, #36	; 0x24
    6890:	46bd      	mov	sp, r7
    6892:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6894:	89a3      	ldrh	r3, [r4, #12]
    6896:	2b01      	cmp	r3, #1
    6898:	d80c      	bhi.n	68b4 <bt_recv+0xec>
    689a:	4a20      	ldr	r2, [pc, #128]	; (691c <bt_recv+0x154>)
    689c:	4920      	ldr	r1, [pc, #128]	; (6920 <bt_recv+0x158>)
    689e:	4821      	ldr	r0, [pc, #132]	; (6924 <bt_recv+0x15c>)
    68a0:	f640 1317 	movw	r3, #2327	; 0x917
    68a4:	f01e fc8a 	bl	251bc <printk>
    68a8:	4040      	eors	r0, r0
    68aa:	f380 8811 	msr	BASEPRI, r0
    68ae:	f04f 0003 	mov.w	r0, #3
    68b2:	df02      	svc	2
    68b4:	2102      	movs	r1, #2
    68b6:	f104 0008 	add.w	r0, r4, #8
    68ba:	f025 fab7 	bl	2be2c <net_buf_simple_pull_mem>
    68be:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    68c0:	7800      	ldrb	r0, [r0, #0]
    68c2:	f021 fa79 	bl	27db8 <bt_hci_evt_get_flags>
    68c6:	0783      	lsls	r3, r0, #30
    68c8:	d40c      	bmi.n	68e4 <bt_recv+0x11c>
    68ca:	4a14      	ldr	r2, [pc, #80]	; (691c <bt_recv+0x154>)
    68cc:	4919      	ldr	r1, [pc, #100]	; (6934 <bt_recv+0x16c>)
    68ce:	4815      	ldr	r0, [pc, #84]	; (6924 <bt_recv+0x15c>)
    68d0:	f640 131b 	movw	r3, #2331	; 0x91b
    68d4:	f01e fc72 	bl	251bc <printk>
    68d8:	4040      	eors	r0, r0
    68da:	f380 8811 	msr	BASEPRI, r0
    68de:	f04f 0003 	mov.w	r0, #3
    68e2:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    68e4:	4a14      	ldr	r2, [pc, #80]	; (6938 <bt_recv+0x170>)
    68e6:	7828      	ldrb	r0, [r5, #0]
    68e8:	2304      	movs	r3, #4
    68ea:	4621      	mov	r1, r4
    68ec:	f7ff f9a4 	bl	5c38 <handle_event>
    68f0:	e7aa      	b.n	6848 <bt_recv+0x80>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    68f2:	4a12      	ldr	r2, [pc, #72]	; (693c <bt_recv+0x174>)
    68f4:	480d      	ldr	r0, [pc, #52]	; (692c <bt_recv+0x164>)
	switch (bt_buf_get_type(buf)) {
    68f6:	e9c7 2306 	strd	r2, r3, [r7, #24]
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    68fa:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    68fe:	2303      	movs	r3, #3
    6900:	f107 0214 	add.w	r2, r7, #20
    6904:	607b      	str	r3, [r7, #4]
    6906:	617b      	str	r3, [r7, #20]
    6908:	f021 fa77 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    690c:	4620      	mov	r0, r4
    690e:	f019 ffc1 	bl	20894 <net_buf_unref>
		return -EINVAL;
    6912:	f06f 0015 	mvn.w	r0, #21
    6916:	e7ba      	b.n	688e <bt_recv+0xc6>
    6918:	200025e4 	.word	0x200025e4
    691c:	0002f878 	.word	0x0002f878
    6920:	0002fa0f 	.word	0x0002fa0f
    6924:	0002f8b5 	.word	0x0002f8b5
    6928:	0002fa41 	.word	0x0002fa41
    692c:	0002daac 	.word	0x0002daac
    6930:	0002fa65 	.word	0x0002fa65
    6934:	0002fa87 	.word	0x0002fa87
    6938:	0002e168 	.word	0x0002e168
    693c:	0002fab5 	.word	0x0002fab5

00006940 <bt_recv_prio>:

#if defined(CONFIG_BT_RECV_IS_RX_THREAD)
int bt_recv_prio(struct net_buf *buf)
{
    6940:	b510      	push	{r4, lr}
	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    6942:	7d03      	ldrb	r3, [r0, #20]
    6944:	2b01      	cmp	r3, #1
{
    6946:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    6948:	d00c      	beq.n	6964 <bt_recv_prio+0x24>
    694a:	4a09      	ldr	r2, [pc, #36]	; (6970 <bt_recv_prio+0x30>)
    694c:	4909      	ldr	r1, [pc, #36]	; (6974 <bt_recv_prio+0x34>)
    694e:	480a      	ldr	r0, [pc, #40]	; (6978 <bt_recv_prio+0x38>)
    6950:	f640 537c 	movw	r3, #3452	; 0xd7c
    6954:	f01e fc32 	bl	251bc <printk>
    6958:	4040      	eors	r0, r0
    695a:	f380 8811 	msr	BASEPRI, r0
    695e:	f04f 0003 	mov.w	r0, #3
    6962:	df02      	svc	2

	hci_event_prio(buf);
    6964:	4620      	mov	r0, r4
    6966:	f7ff fedd 	bl	6724 <hci_event_prio>

	return 0;
}
    696a:	2000      	movs	r0, #0
    696c:	bd10      	pop	{r4, pc}
    696e:	bf00      	nop
    6970:	0002f878 	.word	0x0002f878
    6974:	0002fac9 	.word	0x0002fac9
    6978:	0002f8b5 	.word	0x0002f8b5

0000697c <bt_hci_driver_register>:
#endif /* defined(CONFIG_BT_RECV_IS_RX_THREAD) */

int bt_hci_driver_register(const struct bt_hci_driver *drv)
{
	if (bt_dev.drv) {
    697c:	4a08      	ldr	r2, [pc, #32]	; (69a0 <bt_hci_driver_register+0x24>)
{
    697e:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    6980:	f8d2 014c 	ldr.w	r0, [r2, #332]	; 0x14c
    6984:	b930      	cbnz	r0, 6994 <bt_hci_driver_register+0x18>
		return -EALREADY;
	}

	if (!drv->open || !drv->send) {
    6986:	68d9      	ldr	r1, [r3, #12]
    6988:	b139      	cbz	r1, 699a <bt_hci_driver_register+0x1e>
    698a:	6919      	ldr	r1, [r3, #16]
    698c:	b129      	cbz	r1, 699a <bt_hci_driver_register+0x1e>
		return -EINVAL;
	}

	bt_dev.drv = drv;
    698e:	f8c2 314c 	str.w	r3, [r2, #332]	; 0x14c
	BT_DBG("Registered %s", drv->name ? drv->name : "");

	bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
			     BT_ADDR_ANY, drv->name ? drv->name : "bt0");

	return 0;
    6992:	4770      	bx	lr
		return -EALREADY;
    6994:	f06f 0077 	mvn.w	r0, #119	; 0x77
    6998:	4770      	bx	lr
		return -EINVAL;
    699a:	f06f 0015 	mvn.w	r0, #21
}
    699e:	4770      	bx	lr
    69a0:	20000080 	.word	0x20000080

000069a4 <bt_finalize_init>:

void bt_finalize_init(void)
{
    69a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    69a8:	4c32      	ldr	r4, [pc, #200]	; (6a74 <bt_finalize_init+0xd0>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    69aa:	4d33      	ldr	r5, [pc, #204]	; (6a78 <bt_finalize_init+0xd4>)
		BT_INFO("Identity[%d]: %s",
    69ac:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 6a7c <bt_finalize_init+0xd8>
    69b0:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 6a80 <bt_finalize_init+0xdc>
{
    69b4:	b087      	sub	sp, #28
    69b6:	2102      	movs	r1, #2
    69b8:	f104 00cc 	add.w	r0, r4, #204	; 0xcc
    69bc:	f021 fa0e 	bl	27ddc <atomic_or>
	atomic_set_bit(bt_dev.flags, BT_DEV_READY);

	if (IS_ENABLED(CONFIG_BT_OBSERVER)) {
		bt_le_scan_update(false);
    69c0:	2000      	movs	r0, #0
    69c2:	f001 f903 	bl	7bcc <bt_le_scan_update>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    69c6:	79e2      	ldrb	r2, [r4, #7]
    69c8:	4b2e      	ldr	r3, [pc, #184]	; (6a84 <bt_finalize_init+0xe0>)
    69ca:	4620      	mov	r0, r4
    69cc:	2a01      	cmp	r2, #1
    69ce:	bf98      	it	ls
    69d0:	461d      	movls	r5, r3
    69d2:	f7fe fbe3 	bl	519c <bt_addr_le_str_real>
    69d6:	2600      	movs	r6, #0
    69d8:	4b2b      	ldr	r3, [pc, #172]	; (6a88 <bt_finalize_init+0xe4>)
    69da:	9301      	str	r3, [sp, #4]
    69dc:	e9cd 5002 	strd	r5, r0, [sp, #8]
    69e0:	4927      	ldr	r1, [pc, #156]	; (6a80 <bt_finalize_init+0xdc>)
    69e2:	9600      	str	r6, [sp, #0]
    69e4:	4633      	mov	r3, r6
    69e6:	2203      	movs	r2, #3
    69e8:	4630      	mov	r0, r6
    69ea:	f021 fa09 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	for (i = 1; i < bt_dev.id_count; i++) {
    69ee:	4627      	mov	r7, r4
    69f0:	2501      	movs	r5, #1
    69f2:	79e3      	ldrb	r3, [r4, #7]
    69f4:	429d      	cmp	r5, r3
    69f6:	f107 0707 	add.w	r7, r7, #7
    69fa:	db2c      	blt.n	6a56 <bt_finalize_init+0xb2>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    69fc:	f894 5068 	ldrb.w	r5, [r4, #104]	; 0x68
    6a00:	4628      	mov	r0, r5
    6a02:	f7fe fff5 	bl	59f0 <ver_str>
    6a06:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    6a0a:	9305      	str	r3, [sp, #20]
    6a0c:	f8b4 306a 	ldrh.w	r3, [r4, #106]	; 0x6a
    6a10:	491b      	ldr	r1, [pc, #108]	; (6a80 <bt_finalize_init+0xdc>)
    6a12:	9002      	str	r0, [sp, #8]
    6a14:	e9cd 5303 	strd	r5, r3, [sp, #12]
    6a18:	2500      	movs	r5, #0
    6a1a:	4b1c      	ldr	r3, [pc, #112]	; (6a8c <bt_finalize_init+0xe8>)
    6a1c:	9301      	str	r3, [sp, #4]
    6a1e:	2203      	movs	r2, #3
    6a20:	462b      	mov	r3, r5
    6a22:	4628      	mov	r0, r5
    6a24:	9500      	str	r5, [sp, #0]
    6a26:	f021 f9eb 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    6a2a:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
    6a2e:	4630      	mov	r0, r6
    6a30:	f7fe ffde 	bl	59f0 <ver_str>
    6a34:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
    6a38:	9002      	str	r0, [sp, #8]
    6a3a:	e9cd 6303 	strd	r6, r3, [sp, #12]
    6a3e:	4b14      	ldr	r3, [pc, #80]	; (6a90 <bt_finalize_init+0xec>)
    6a40:	490f      	ldr	r1, [pc, #60]	; (6a80 <bt_finalize_init+0xdc>)
    6a42:	e9cd 5300 	strd	r5, r3, [sp]
    6a46:	2203      	movs	r2, #3
    6a48:	462b      	mov	r3, r5
    6a4a:	4628      	mov	r0, r5
    6a4c:	f021 f9d8 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	}

	bt_dev_show_info();
}
    6a50:	b007      	add	sp, #28
    6a52:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
    6a56:	4638      	mov	r0, r7
    6a58:	f7fe fba0 	bl	519c <bt_addr_le_str_real>
    6a5c:	2300      	movs	r3, #0
    6a5e:	e9cd 5002 	strd	r5, r0, [sp, #8]
    6a62:	e9cd 6800 	strd	r6, r8, [sp]
    6a66:	2203      	movs	r2, #3
    6a68:	4649      	mov	r1, r9
    6a6a:	4618      	mov	r0, r3
    6a6c:	f021 f9c8 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	for (i = 1; i < bt_dev.id_count; i++) {
    6a70:	3501      	adds	r5, #1
    6a72:	e7be      	b.n	69f2 <bt_finalize_init+0x4e>
    6a74:	20000080 	.word	0x20000080
    6a78:	0002faec 	.word	0x0002faec
    6a7c:	0002faff 	.word	0x0002faff
    6a80:	0002daac 	.word	0x0002daac
    6a84:	0003175b 	.word	0x0003175b
    6a88:	0002faf0 	.word	0x0002faf0
    6a8c:	0002fb10 	.word	0x0002fb10
    6a90:	0002fb4e 	.word	0x0002fb4e

00006a94 <bt_init>:

static int bt_init(void)
{
    6a94:	b570      	push	{r4, r5, r6, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    6a96:	4db7      	ldr	r5, [pc, #732]	; (6d74 <bt_init+0x2e0>)
    6a98:	f8d5 314c 	ldr.w	r3, [r5, #332]	; 0x14c
    6a9c:	6899      	ldr	r1, [r3, #8]
    6a9e:	f011 0101 	ands.w	r1, r1, #1
{
    6aa2:	b090      	sub	sp, #64	; 0x40
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    6aa4:	d123      	bne.n	6aee <bt_init+0x5a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    6aa6:	aa0a      	add	r2, sp, #40	; 0x28
    6aa8:	f640 4003 	movw	r0, #3075	; 0xc03
    6aac:	f7ff fcb4 	bl	6418 <bt_hci_cmd_send_sync>
		if (err) {
    6ab0:	4604      	mov	r4, r0
    6ab2:	2800      	cmp	r0, #0
    6ab4:	d179      	bne.n	6baa <bt_init+0x116>
	uint8_t status = buf->data[0];
    6ab6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6ab8:	689b      	ldr	r3, [r3, #8]
	if (status) {
    6aba:	781b      	ldrb	r3, [r3, #0]
    6abc:	b9a3      	cbnz	r3, 6ae8 <bt_init+0x54>
		bt_scan_reset();
    6abe:	f001 f87f 	bl	7bc0 <bt_scan_reset>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    6ac2:	f3bf 8f5b 	dmb	ish
    6ac6:	462b      	mov	r3, r5
    6ac8:	f853 2fcc 	ldr.w	r2, [r3, #204]!
    6acc:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    6ad0:	f002 0205 	and.w	r2, r2, #5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6ad4:	f3bf 8f5b 	dmb	ish
    6ad8:	e853 1f00 	ldrex	r1, [r3]
    6adc:	e843 2000 	strex	r0, r2, [r3]
    6ae0:	2800      	cmp	r0, #0
    6ae2:	d1f9      	bne.n	6ad8 <bt_init+0x44>
    6ae4:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    6ae8:	980a      	ldr	r0, [sp, #40]	; 0x28
    6aea:	f019 fed3 	bl	20894 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    6aee:	aa0a      	add	r2, sp, #40	; 0x28
    6af0:	2100      	movs	r1, #0
    6af2:	f241 0003 	movw	r0, #4099	; 0x1003
    6af6:	f7ff fc8f 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6afa:	4604      	mov	r4, r0
    6afc:	2800      	cmp	r0, #0
    6afe:	d154      	bne.n	6baa <bt_init+0x116>
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
    6b00:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    6b02:	489d      	ldr	r0, [pc, #628]	; (6d78 <bt_init+0x2e4>)
    6b04:	6899      	ldr	r1, [r3, #8]
    6b06:	2208      	movs	r2, #8
    6b08:	3101      	adds	r1, #1
    6b0a:	f020 feb1 	bl	27870 <memcpy>
	net_buf_unref(rsp);
    6b0e:	980a      	ldr	r0, [sp, #40]	; 0x28
    6b10:	f019 fec0 	bl	20894 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    6b14:	4621      	mov	r1, r4
    6b16:	aa0a      	add	r2, sp, #40	; 0x28
    6b18:	f241 0001 	movw	r0, #4097	; 0x1001
    6b1c:	f7ff fc7c 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6b20:	4604      	mov	r4, r0
    6b22:	2800      	cmp	r0, #0
    6b24:	d141      	bne.n	6baa <bt_init+0x116>
	read_local_ver_complete(rsp);
    6b26:	980a      	ldr	r0, [sp, #40]	; 0x28
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
    6b28:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    6b2a:	785a      	ldrb	r2, [r3, #1]
    6b2c:	f885 2068 	strb.w	r2, [r5, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    6b30:	78d9      	ldrb	r1, [r3, #3]
    6b32:	789a      	ldrb	r2, [r3, #2]
    6b34:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    6b38:	f8a5 206a 	strh.w	r2, [r5, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
    6b3c:	791a      	ldrb	r2, [r3, #4]
    6b3e:	f885 2069 	strb.w	r2, [r5, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    6b42:	7a19      	ldrb	r1, [r3, #8]
    6b44:	79da      	ldrb	r2, [r3, #7]
    6b46:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    6b4a:	f8a5 206c 	strh.w	r2, [r5, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    6b4e:	795a      	ldrb	r2, [r3, #5]
    6b50:	799b      	ldrb	r3, [r3, #6]
    6b52:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    6b56:	f8a5 306e 	strh.w	r3, [r5, #110]	; 0x6e
	net_buf_unref(rsp);
    6b5a:	f019 fe9b 	bl	20894 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    6b5e:	4621      	mov	r1, r4
    6b60:	aa0a      	add	r2, sp, #40	; 0x28
    6b62:	f241 0002 	movw	r0, #4098	; 0x1002
    6b66:	f7ff fc57 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6b6a:	4604      	mov	r4, r0
    6b6c:	b9e8      	cbnz	r0, 6baa <bt_init+0x116>
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
    6b6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.supported_commands, rp->commands,
    6b70:	4882      	ldr	r0, [pc, #520]	; (6d7c <bt_init+0x2e8>)
    6b72:	6899      	ldr	r1, [r3, #8]
    6b74:	2240      	movs	r2, #64	; 0x40
    6b76:	3101      	adds	r1, #1
    6b78:	f020 fe7a 	bl	27870 <memcpy>
		bt_hci_ecc_supported_commands(bt_dev.supported_commands);
    6b7c:	487f      	ldr	r0, [pc, #508]	; (6d7c <bt_init+0x2e8>)
    6b7e:	f020 feda 	bl	27936 <bt_hci_ecc_supported_commands>
	net_buf_unref(rsp);
    6b82:	980a      	ldr	r0, [sp, #40]	; 0x28
    6b84:	f019 fe86 	bl	20894 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    6b88:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
    6b8c:	0658      	lsls	r0, r3, #25
    6b8e:	d40f      	bmi.n	6bb0 <bt_init+0x11c>
		BT_ERR("Non-LE capable controller detected!");
    6b90:	4b7b      	ldr	r3, [pc, #492]	; (6d80 <bt_init+0x2ec>)
    6b92:	930e      	str	r3, [sp, #56]	; 0x38
    6b94:	487b      	ldr	r0, [pc, #492]	; (6d84 <bt_init+0x2f0>)
    6b96:	2302      	movs	r3, #2
    6b98:	aa0d      	add	r2, sp, #52	; 0x34
    6b9a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENODEV;
    6b9e:	f06f 0412 	mvn.w	r4, #18
		BT_ERR("Non-LE capable controller detected!");
    6ba2:	9309      	str	r3, [sp, #36]	; 0x24
    6ba4:	930d      	str	r3, [sp, #52]	; 0x34
    6ba6:	f021 f928 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		atomic_set_bit(bt_dev.flags, BT_DEV_PRESET_ID);
	}

	bt_finalize_init();
	return 0;
}
    6baa:	4620      	mov	r0, r4
    6bac:	b010      	add	sp, #64	; 0x40
    6bae:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    6bb0:	4621      	mov	r1, r4
    6bb2:	aa0a      	add	r2, sp, #40	; 0x28
    6bb4:	f242 0003 	movw	r0, #8195	; 0x2003
    6bb8:	f7ff fc2e 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6bbc:	4604      	mov	r4, r0
    6bbe:	2800      	cmp	r0, #0
    6bc0:	d1f3      	bne.n	6baa <bt_init+0x116>
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
    6bc2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    6bc4:	4870      	ldr	r0, [pc, #448]	; (6d88 <bt_init+0x2f4>)
    6bc6:	6899      	ldr	r1, [r3, #8]
    6bc8:	2208      	movs	r2, #8
    6bca:	3101      	adds	r1, #1
    6bcc:	f020 fe50 	bl	27870 <memcpy>
	net_buf_unref(rsp);
    6bd0:	980a      	ldr	r0, [sp, #40]	; 0x28
    6bd2:	f019 fe5f 	bl	20894 <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    6bd6:	4621      	mov	r1, r4
    6bd8:	aa0a      	add	r2, sp, #40	; 0x28
    6bda:	f242 0002 	movw	r0, #8194	; 0x2002
    6bde:	f7ff fc1b 	bl	6418 <bt_hci_cmd_send_sync>
		if (err) {
    6be2:	4604      	mov	r4, r0
    6be4:	2800      	cmp	r0, #0
    6be6:	d1e0      	bne.n	6baa <bt_init+0x116>
	struct bt_hci_rp_le_read_buffer_size *rp = (void *)buf->data;
    6be8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6bea:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
    6bec:	f8b3 2001 	ldrh.w	r2, [r3, #1]
    6bf0:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
    6bf4:	b291      	uxth	r1, r2
	if (!bt_dev.le.acl_mtu) {
    6bf6:	b121      	cbz	r1, 6c02 <bt_init+0x16e>
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
    6bf8:	78da      	ldrb	r2, [r3, #3]
	return z_impl_k_sem_init(sem, initial_count, limit);
    6bfa:	4864      	ldr	r0, [pc, #400]	; (6d8c <bt_init+0x2f8>)
    6bfc:	4611      	mov	r1, r2
    6bfe:	f026 f83e 	bl	2cc7e <z_impl_k_sem_init>
		net_buf_unref(rsp);
    6c02:	980a      	ldr	r0, [sp, #40]	; 0x28
    6c04:	f019 fe46 	bl	20894 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    6c08:	f895 6074 	ldrb.w	r6, [r5, #116]	; 0x74
    6c0c:	f016 0620 	ands.w	r6, r6, #32
    6c10:	f000 80a6 	beq.w	6d60 <bt_init+0x2cc>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    6c14:	f895 3094 	ldrb.w	r3, [r5, #148]	; 0x94
    6c18:	0719      	lsls	r1, r3, #28
    6c1a:	f100 80cf 	bmi.w	6dbc <bt_init+0x328>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    6c1e:	2108      	movs	r1, #8
    6c20:	f242 0001 	movw	r0, #8193	; 0x2001
    6c24:	f7ff fa9c 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    6c28:	4604      	mov	r4, r0
    6c2a:	2800      	cmp	r0, #0
    6c2c:	f000 809f 	beq.w	6d6e <bt_init+0x2da>
	return net_buf_simple_add(&buf->b, len);
    6c30:	2108      	movs	r1, #8
    6c32:	4408      	add	r0, r1
    6c34:	f025 f882 	bl	2bd3c <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    6c38:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    6c3c:	f895 209a 	ldrb.w	r2, [r5, #154]	; 0x9a
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    6c40:	f013 0f02 	tst.w	r3, #2
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    6c44:	f002 0206 	and.w	r2, r2, #6
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    6c48:	bf0c      	ite	eq
    6c4a:	230f      	moveq	r3, #15
    6c4c:	232f      	movne	r3, #47	; 0x2f
	if (IS_ENABLED(CONFIG_BT_ECC) &&
    6c4e:	2a06      	cmp	r2, #6
		mask |= BT_EVT_MASK_LE_GENERATE_DHKEY_COMPLETE;
    6c50:	bf08      	it	eq
    6c52:	f443 73c0 	orreq.w	r3, r3, #384	; 0x180
	dst[0] = val;
    6c56:	2200      	movs	r2, #0
    6c58:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    6c5a:	0a1b      	lsrs	r3, r3, #8
    6c5c:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
    6c5e:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    6c60:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    6c62:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    6c64:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    6c66:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    6c68:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    6c6a:	4621      	mov	r1, r4
    6c6c:	f242 0001 	movw	r0, #8193	; 0x2001
    6c70:	f7ff fbd2 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6c74:	4604      	mov	r4, r0
    6c76:	2800      	cmp	r0, #0
    6c78:	d197      	bne.n	6baa <bt_init+0x116>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    6c7a:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
	if (bt_dev.le.acl_mtu) {
    6c7e:	f8b5 10fc 	ldrh.w	r1, [r5, #252]	; 0xfc
	if (BT_FEAT_BREDR(bt_dev.features)) {
    6c82:	069a      	lsls	r2, r3, #26
    6c84:	f100 80af 	bmi.w	6de6 <bt_init+0x352>
	if (bt_dev.le.acl_mtu) {
    6c88:	b9d1      	cbnz	r1, 6cc0 <bt_init+0x22c>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    6c8a:	aa0a      	add	r2, sp, #40	; 0x28
    6c8c:	f241 0005 	movw	r0, #4101	; 0x1005
    6c90:	f7ff fbc2 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6c94:	4604      	mov	r4, r0
    6c96:	2800      	cmp	r0, #0
    6c98:	d187      	bne.n	6baa <bt_init+0x116>
	if (bt_dev.le.acl_mtu) {
    6c9a:	f8b5 30fc 	ldrh.w	r3, [r5, #252]	; 0xfc
    6c9e:	b963      	cbnz	r3, 6cba <bt_init+0x226>
	struct bt_hci_rp_read_buffer_size *rp = (void *)buf->data;
    6ca0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6ca2:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
    6ca4:	785a      	ldrb	r2, [r3, #1]
    6ca6:	7899      	ldrb	r1, [r3, #2]
    6ca8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    6cac:	f8a5 20fc 	strh.w	r2, [r5, #252]	; 0xfc
	k_sem_init(&bt_dev.le.acl_pkts, pkts, pkts);
    6cb0:	889a      	ldrh	r2, [r3, #4]
    6cb2:	4836      	ldr	r0, [pc, #216]	; (6d8c <bt_init+0x2f8>)
    6cb4:	4611      	mov	r1, r2
    6cb6:	f025 ffe2 	bl	2cc7e <z_impl_k_sem_init>
	net_buf_unref(rsp);
    6cba:	980a      	ldr	r0, [sp, #40]	; 0x28
    6cbc:	f019 fdea 	bl	20894 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    6cc0:	2108      	movs	r1, #8
    6cc2:	f640 4001 	movw	r0, #3073	; 0xc01
    6cc6:	f7ff fa4b 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    6cca:	4604      	mov	r4, r0
    6ccc:	2800      	cmp	r0, #0
    6cce:	d04e      	beq.n	6d6e <bt_init+0x2da>
    6cd0:	2108      	movs	r1, #8
    6cd2:	4408      	add	r0, r1
    6cd4:	f025 f832 	bl	2bd3c <net_buf_simple_add>
	dst[0] = val;
    6cd8:	2310      	movs	r3, #16
    6cda:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    6cdc:	2388      	movs	r3, #136	; 0x88
	dst[0] = val;
    6cde:	2200      	movs	r2, #0
	dst[1] = val >> 8;
    6ce0:	7043      	strb	r3, [r0, #1]
    6ce2:	2602      	movs	r6, #2
    6ce4:	2320      	movs	r3, #32
	dst[0] = val;
    6ce6:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    6ce8:	70c6      	strb	r6, [r0, #3]
	dst[0] = val;
    6cea:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    6cec:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    6cee:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    6cf0:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    6cf2:	4621      	mov	r1, r4
    6cf4:	f640 4001 	movw	r0, #3073	; 0xc01
    6cf8:	f7ff fb8e 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6cfc:	4604      	mov	r4, r0
    6cfe:	2800      	cmp	r0, #0
    6d00:	f47f af53 	bne.w	6baa <bt_init+0x116>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    6d04:	4601      	mov	r1, r0
    6d06:	aa08      	add	r2, sp, #32
    6d08:	f64f 4001 	movw	r0, #64513	; 0xfc01
    6d0c:	f7ff fb84 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6d10:	2800      	cmp	r0, #0
    6d12:	d079      	beq.n	6e08 <bt_init+0x374>
		BT_WARN("Vendor HCI extensions not available");
    6d14:	4b1e      	ldr	r3, [pc, #120]	; (6d90 <bt_init+0x2fc>)
    6d16:	930e      	str	r3, [sp, #56]	; 0x38
    6d18:	9609      	str	r6, [sp, #36]	; 0x24
    6d1a:	960d      	str	r6, [sp, #52]	; 0x34
			BT_WARN("Failed to read supported vendor features");
    6d1c:	4819      	ldr	r0, [pc, #100]	; (6d84 <bt_init+0x2f0>)
    6d1e:	aa0d      	add	r2, sp, #52	; 0x34
    6d20:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    6d24:	f021 f869 	bl	27dfa <z_log_msg2_static_create.constprop.0>
	err = bt_id_init();
    6d28:	f021 f96a 	bl	28000 <bt_id_init>
	if (err) {
    6d2c:	4604      	mov	r4, r0
    6d2e:	2800      	cmp	r0, #0
    6d30:	f47f af3b 	bne.w	6baa <bt_init+0x116>
		err = bt_conn_init();
    6d34:	f002 f832 	bl	8d9c <bt_conn_init>
		if (err) {
    6d38:	4604      	mov	r4, r0
    6d3a:	2800      	cmp	r0, #0
    6d3c:	f47f af35 	bne.w	6baa <bt_init+0x116>
		if (!bt_dev.id_count) {
    6d40:	79eb      	ldrb	r3, [r5, #7]
    6d42:	2b00      	cmp	r3, #0
    6d44:	f040 80dc 	bne.w	6f00 <bt_init+0x46c>
			BT_INFO("No ID address. App must call settings_load()");
    6d48:	4b12      	ldr	r3, [pc, #72]	; (6d94 <bt_init+0x300>)
    6d4a:	930e      	str	r3, [sp, #56]	; 0x38
    6d4c:	480d      	ldr	r0, [pc, #52]	; (6d84 <bt_init+0x2f0>)
    6d4e:	2302      	movs	r3, #2
    6d50:	aa0d      	add	r2, sp, #52	; 0x34
    6d52:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
    6d56:	9309      	str	r3, [sp, #36]	; 0x24
    6d58:	930d      	str	r3, [sp, #52]	; 0x34
    6d5a:	f021 f84e 	bl	27dfa <z_log_msg2_static_create.constprop.0>
			return 0;
    6d5e:	e724      	b.n	6baa <bt_init+0x116>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    6d60:	2102      	movs	r1, #2
    6d62:	f640 406d 	movw	r0, #3181	; 0xc6d
    6d66:	f7ff f9fb 	bl	6160 <bt_hci_cmd_create>
		if (!buf) {
    6d6a:	4604      	mov	r4, r0
    6d6c:	b9a0      	cbnz	r0, 6d98 <bt_init+0x304>
		return -ENOBUFS;
    6d6e:	f06f 0468 	mvn.w	r4, #104	; 0x68
    6d72:	e71a      	b.n	6baa <bt_init+0x116>
    6d74:	20000080 	.word	0x20000080
    6d78:	200000f0 	.word	0x200000f0
    6d7c:	200000f8 	.word	0x200000f8
    6d80:	0002fb75 	.word	0x0002fb75
    6d84:	0002daac 	.word	0x0002daac
    6d88:	20000150 	.word	0x20000150
    6d8c:	20000180 	.word	0x20000180
    6d90:	0002fbbc 	.word	0x0002fbbc
    6d94:	0002fc90 	.word	0x0002fc90
    6d98:	2102      	movs	r1, #2
    6d9a:	3008      	adds	r0, #8
    6d9c:	f024 ffce 	bl	2bd3c <net_buf_simple_add>
		cp_le->le = 0x01;
    6da0:	2301      	movs	r3, #1
    6da2:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
    6da4:	7046      	strb	r6, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    6da6:	4621      	mov	r1, r4
    6da8:	4632      	mov	r2, r6
    6daa:	f640 406d 	movw	r0, #3181	; 0xc6d
    6dae:	f7ff fb33 	bl	6418 <bt_hci_cmd_send_sync>
		if (err) {
    6db2:	4604      	mov	r4, r0
    6db4:	2800      	cmp	r0, #0
    6db6:	f43f af2d 	beq.w	6c14 <bt_init+0x180>
    6dba:	e6f6      	b.n	6baa <bt_init+0x116>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    6dbc:	aa0a      	add	r2, sp, #40	; 0x28
    6dbe:	2100      	movs	r1, #0
    6dc0:	f242 001c 	movw	r0, #8220	; 0x201c
    6dc4:	f7ff fb28 	bl	6418 <bt_hci_cmd_send_sync>
		if (err) {
    6dc8:	4604      	mov	r4, r0
    6dca:	2800      	cmp	r0, #0
    6dcc:	f47f aeed 	bne.w	6baa <bt_init+0x116>
		le_read_supp_states_complete(rsp);
    6dd0:	980a      	ldr	r0, [sp, #40]	; 0x28
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    6dd2:	6883      	ldr	r3, [r0, #8]
    6dd4:	f8d3 2001 	ldr.w	r2, [r3, #1]
    6dd8:	f8d3 3005 	ldr.w	r3, [r3, #5]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    6ddc:	e9c5 2336 	strd	r2, r3, [r5, #216]	; 0xd8
		net_buf_unref(rsp);
    6de0:	f019 fd58 	bl	20894 <net_buf_unref>
    6de4:	e71b      	b.n	6c1e <bt_init+0x18a>
	else if (!bt_dev.le.acl_mtu) {
    6de6:	2900      	cmp	r1, #0
    6de8:	f47f af6a 	bne.w	6cc0 <bt_init+0x22c>
		BT_ERR("ACL BR/EDR buffers not initialized");
    6dec:	4b48      	ldr	r3, [pc, #288]	; (6f10 <bt_init+0x47c>)
    6dee:	930e      	str	r3, [sp, #56]	; 0x38
    6df0:	4848      	ldr	r0, [pc, #288]	; (6f14 <bt_init+0x480>)
    6df2:	2302      	movs	r3, #2
    6df4:	aa0d      	add	r2, sp, #52	; 0x34
    6df6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    6dfa:	9309      	str	r3, [sp, #36]	; 0x24
    6dfc:	930d      	str	r3, [sp, #52]	; 0x34
		return -EIO;
    6dfe:	f06f 0404 	mvn.w	r4, #4
		BT_ERR("ACL BR/EDR buffers not initialized");
    6e02:	f020 fffa 	bl	27dfa <z_log_msg2_static_create.constprop.0>
	if (err) {
    6e06:	e6d0      	b.n	6baa <bt_init+0x116>
	rp.info = (void *)rsp->data;
    6e08:	9b08      	ldr	r3, [sp, #32]
	BT_INFO("HW Platform: %s (0x%04x)",
    6e0a:	4942      	ldr	r1, [pc, #264]	; (6f14 <bt_init+0x480>)
	rp.info = (void *)rsp->data;
    6e0c:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    6e0e:	f8b4 3001 	ldrh.w	r3, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
    6e12:	2b03      	cmp	r3, #3
		return plat_str[platform];
    6e14:	bf96      	itet	ls
    6e16:	4a40      	ldrls	r2, [pc, #256]	; (6f18 <bt_init+0x484>)
	return "unknown";
    6e18:	4a40      	ldrhi	r2, [pc, #256]	; (6f1c <bt_init+0x488>)
		return plat_str[platform];
    6e1a:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
    6e1e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    6e22:	4b3f      	ldr	r3, [pc, #252]	; (6f20 <bt_init+0x48c>)
    6e24:	9301      	str	r3, [sp, #4]
    6e26:	2300      	movs	r3, #0
    6e28:	9300      	str	r3, [sp, #0]
    6e2a:	2203      	movs	r2, #3
    6e2c:	4618      	mov	r0, r3
    6e2e:	f020 ffe7 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    6e32:	f8b4 3001 	ldrh.w	r3, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
    6e36:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    6e3a:	2b02      	cmp	r3, #2
    6e3c:	d13b      	bne.n	6eb6 <bt_init+0x422>
	if (variant < ARRAY_SIZE(nordic_str)) {
    6e3e:	2a03      	cmp	r2, #3
    6e40:	d839      	bhi.n	6eb6 <bt_init+0x422>
		return nordic_str[variant];
    6e42:	4b38      	ldr	r3, [pc, #224]	; (6f24 <bt_init+0x490>)
    6e44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
    6e48:	4932      	ldr	r1, [pc, #200]	; (6f14 <bt_init+0x480>)
    6e4a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    6e4e:	4b36      	ldr	r3, [pc, #216]	; (6f28 <bt_init+0x494>)
    6e50:	9301      	str	r3, [sp, #4]
    6e52:	2300      	movs	r3, #0
    6e54:	2203      	movs	r2, #3
    6e56:	4618      	mov	r0, r3
    6e58:	9300      	str	r3, [sp, #0]
    6e5a:	f020 ffd1 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    6e5e:	f8d4 1009 	ldr.w	r1, [r4, #9]
    6e62:	7963      	ldrb	r3, [r4, #5]
    6e64:	9106      	str	r1, [sp, #24]
    6e66:	f8b4 1007 	ldrh.w	r1, [r4, #7]
    6e6a:	9105      	str	r1, [sp, #20]
	if (variant < ARRAY_SIZE(var_str)) {
    6e6c:	2b03      	cmp	r3, #3
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    6e6e:	79a1      	ldrb	r1, [r4, #6]
		return var_str[variant];
    6e70:	bf96      	itet	ls
    6e72:	4a2e      	ldrls	r2, [pc, #184]	; (6f2c <bt_init+0x498>)
	return "unknown";
    6e74:	4a29      	ldrhi	r2, [pc, #164]	; (6f1c <bt_init+0x488>)
		return var_str[variant];
    6e76:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    6e7a:	9202      	str	r2, [sp, #8]
    6e7c:	2400      	movs	r4, #0
    6e7e:	e9cd 3103 	strd	r3, r1, [sp, #12]
    6e82:	4b2b      	ldr	r3, [pc, #172]	; (6f30 <bt_init+0x49c>)
    6e84:	4923      	ldr	r1, [pc, #140]	; (6f14 <bt_init+0x480>)
    6e86:	9301      	str	r3, [sp, #4]
    6e88:	2203      	movs	r2, #3
    6e8a:	4623      	mov	r3, r4
    6e8c:	4620      	mov	r0, r4
    6e8e:	9400      	str	r4, [sp, #0]
    6e90:	f020 ffb6 	bl	27e00 <z_log_msg2_runtime_create.constprop.0>
	net_buf_unref(rsp);
    6e94:	9808      	ldr	r0, [sp, #32]
    6e96:	f019 fcfd 	bl	20894 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    6e9a:	4621      	mov	r1, r4
    6e9c:	aa08      	add	r2, sp, #32
    6e9e:	f64f 4002 	movw	r0, #64514	; 0xfc02
    6ea2:	f7ff fab9 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    6ea6:	4604      	mov	r4, r0
    6ea8:	b138      	cbz	r0, 6eba <bt_init+0x426>
		BT_WARN("Failed to read supported vendor commands");
    6eaa:	4b22      	ldr	r3, [pc, #136]	; (6f34 <bt_init+0x4a0>)
			BT_WARN("Failed to read supported vendor features");
    6eac:	930e      	str	r3, [sp, #56]	; 0x38
    6eae:	2302      	movs	r3, #2
    6eb0:	9309      	str	r3, [sp, #36]	; 0x24
    6eb2:	930d      	str	r3, [sp, #52]	; 0x34
    6eb4:	e732      	b.n	6d1c <bt_init+0x288>
		return "unknown";
    6eb6:	4b19      	ldr	r3, [pc, #100]	; (6f1c <bt_init+0x488>)
    6eb8:	e7c6      	b.n	6e48 <bt_init+0x3b4>
	rp.cmds = (void *)rsp->data;
    6eba:	9b08      	ldr	r3, [sp, #32]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    6ebc:	481e      	ldr	r0, [pc, #120]	; (6f38 <bt_init+0x4a4>)
    6ebe:	6899      	ldr	r1, [r3, #8]
    6ec0:	2202      	movs	r2, #2
    6ec2:	3101      	adds	r1, #1
    6ec4:	f020 fcd4 	bl	27870 <memcpy>
	net_buf_unref(rsp);
    6ec8:	9808      	ldr	r0, [sp, #32]
    6eca:	f019 fce3 	bl	20894 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    6ece:	f895 30b9 	ldrb.w	r3, [r5, #185]	; 0xb9
    6ed2:	075b      	lsls	r3, r3, #29
    6ed4:	f57f af28 	bpl.w	6d28 <bt_init+0x294>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    6ed8:	aa08      	add	r2, sp, #32
    6eda:	4621      	mov	r1, r4
    6edc:	f64f 4003 	movw	r0, #64515	; 0xfc03
    6ee0:	f7ff fa9a 	bl	6418 <bt_hci_cmd_send_sync>
		if (err) {
    6ee4:	b108      	cbz	r0, 6eea <bt_init+0x456>
			BT_WARN("Failed to read supported vendor features");
    6ee6:	4b15      	ldr	r3, [pc, #84]	; (6f3c <bt_init+0x4a8>)
    6ee8:	e7e0      	b.n	6eac <bt_init+0x418>
		rp.feat = (void *)rsp->data;
    6eea:	9b08      	ldr	r3, [sp, #32]
		memcpy(bt_dev.vs_features, rp.feat->features,
    6eec:	4814      	ldr	r0, [pc, #80]	; (6f40 <bt_init+0x4ac>)
    6eee:	6899      	ldr	r1, [r3, #8]
    6ef0:	2201      	movs	r2, #1
    6ef2:	4411      	add	r1, r2
    6ef4:	f020 fcbc 	bl	27870 <memcpy>
		net_buf_unref(rsp);
    6ef8:	9808      	ldr	r0, [sp, #32]
    6efa:	f019 fccb 	bl	20894 <net_buf_unref>
    6efe:	e713      	b.n	6d28 <bt_init+0x294>
    6f00:	2104      	movs	r1, #4
    6f02:	4810      	ldr	r0, [pc, #64]	; (6f44 <bt_init+0x4b0>)
    6f04:	f020 ff6a 	bl	27ddc <atomic_or>
	bt_finalize_init();
    6f08:	f7ff fd4c 	bl	69a4 <bt_finalize_init>
	return 0;
    6f0c:	e64d      	b.n	6baa <bt_init+0x116>
    6f0e:	bf00      	nop
    6f10:	0002fb99 	.word	0x0002fb99
    6f14:	0002daac 	.word	0x0002daac
    6f18:	0002e188 	.word	0x0002e188
    6f1c:	0002f70c 	.word	0x0002f70c
    6f20:	0002fbe0 	.word	0x0002fbe0
    6f24:	0002e158 	.word	0x0002e158
    6f28:	0002fbf9 	.word	0x0002fbf9
    6f2c:	0002e1c0 	.word	0x0002e1c0
    6f30:	0002fc11 	.word	0x0002fc11
    6f34:	0002fc3e 	.word	0x0002fc3e
    6f38:	20000139 	.word	0x20000139
    6f3c:	0002fc67 	.word	0x0002fc67
    6f40:	20000138 	.word	0x20000138
    6f44:	2000014c 	.word	0x2000014c

00006f48 <init_work>:

static void init_work(struct k_work *work)
{
    6f48:	b510      	push	{r4, lr}
	int err;

	err = bt_init();
    6f4a:	f7ff fda3 	bl	6a94 <bt_init>
	if (ready_cb) {
    6f4e:	4b03      	ldr	r3, [pc, #12]	; (6f5c <init_work+0x14>)
    6f50:	681b      	ldr	r3, [r3, #0]
    6f52:	b113      	cbz	r3, 6f5a <init_work+0x12>
		ready_cb(err);
	}
}
    6f54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    6f58:	4718      	bx	r3
}
    6f5a:	bd10      	pop	{r4, pc}
    6f5c:	20002600 	.word	0x20002600

00006f60 <bt_enable>:
	}
}
#endif /* !CONFIG_BT_RECV_IS_RX_THREAD */

int bt_enable(bt_ready_cb_t cb)
{
    6f60:	b570      	push	{r4, r5, r6, lr}
	int err;

	if (!bt_dev.drv) {
    6f62:	4d2e      	ldr	r5, [pc, #184]	; (701c <bt_enable+0xbc>)
    6f64:	f8d5 314c 	ldr.w	r3, [r5, #332]	; 0x14c
{
    6f68:	b090      	sub	sp, #64	; 0x40
    6f6a:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    6f6c:	b97b      	cbnz	r3, 6f8e <bt_enable+0x2e>
		BT_ERR("No HCI driver registered");
    6f6e:	4b2c      	ldr	r3, [pc, #176]	; (7020 <bt_enable+0xc0>)
    6f70:	930e      	str	r3, [sp, #56]	; 0x38
    6f72:	482c      	ldr	r0, [pc, #176]	; (7024 <bt_enable+0xc4>)
    6f74:	2302      	movs	r3, #2
    6f76:	aa0d      	add	r2, sp, #52	; 0x34
    6f78:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENODEV;
    6f7c:	f06f 0412 	mvn.w	r4, #18
		BT_ERR("No HCI driver registered");
    6f80:	9309      	str	r3, [sp, #36]	; 0x24
    6f82:	930d      	str	r3, [sp, #52]	; 0x34
    6f84:	f020 ff39 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
	return 0;
}
    6f88:	4620      	mov	r0, r4
    6f8a:	b010      	add	sp, #64	; 0x40
    6f8c:	bd70      	pop	{r4, r5, r6, pc}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    6f8e:	2101      	movs	r1, #1
    6f90:	f105 00cc 	add.w	r0, r5, #204	; 0xcc
    6f94:	f020 ff22 	bl	27ddc <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    6f98:	07c3      	lsls	r3, r0, #31
    6f9a:	d43c      	bmi.n	7016 <bt_enable+0xb6>
		err = bt_settings_init();
    6f9c:	f7fe fc26 	bl	57ec <bt_settings_init>
		if (err) {
    6fa0:	4604      	mov	r4, r0
    6fa2:	2800      	cmp	r0, #0
    6fa4:	d1f0      	bne.n	6f88 <bt_enable+0x28>
	ready_cb = cb;
    6fa6:	4b20      	ldr	r3, [pc, #128]	; (7028 <bt_enable+0xc8>)
    6fa8:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    6faa:	2200      	movs	r2, #0
    6fac:	2300      	movs	r3, #0
    6fae:	e9cd 2306 	strd	r2, r3, [sp, #24]
    6fb2:	f06f 0308 	mvn.w	r3, #8
    6fb6:	e9cd 0302 	strd	r0, r3, [sp, #8]
    6fba:	e9cd 0000 	strd	r0, r0, [sp]
    6fbe:	9004      	str	r0, [sp, #16]
    6fc0:	4b1a      	ldr	r3, [pc, #104]	; (702c <bt_enable+0xcc>)
    6fc2:	491b      	ldr	r1, [pc, #108]	; (7030 <bt_enable+0xd0>)
    6fc4:	481b      	ldr	r0, [pc, #108]	; (7034 <bt_enable+0xd4>)
    6fc6:	f44f 7220 	mov.w	r2, #640	; 0x280
    6fca:	f01c fe31 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    6fce:	491a      	ldr	r1, [pc, #104]	; (7038 <bt_enable+0xd8>)
    6fd0:	4818      	ldr	r0, [pc, #96]	; (7034 <bt_enable+0xd4>)
    6fd2:	f025 fd4a 	bl	2ca6a <z_impl_k_thread_name_set>
		bt_hci_ecc_init();
    6fd6:	f7fe fad3 	bl	5580 <bt_hci_ecc_init>
	err = bt_dev.drv->open();
    6fda:	f8d5 314c 	ldr.w	r3, [r5, #332]	; 0x14c
    6fde:	68db      	ldr	r3, [r3, #12]
    6fe0:	4798      	blx	r3
	if (err) {
    6fe2:	4604      	mov	r4, r0
    6fe4:	b160      	cbz	r0, 7000 <bt_enable+0xa0>
		BT_ERR("HCI driver open failed (%d)", err);
    6fe6:	4b15      	ldr	r3, [pc, #84]	; (703c <bt_enable+0xdc>)
    6fe8:	aa0d      	add	r2, sp, #52	; 0x34
    6fea:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
    6fee:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    6ff2:	2303      	movs	r3, #3
    6ff4:	480b      	ldr	r0, [pc, #44]	; (7024 <bt_enable+0xc4>)
    6ff6:	9309      	str	r3, [sp, #36]	; 0x24
    6ff8:	930d      	str	r3, [sp, #52]	; 0x34
    6ffa:	f020 fefe 	bl	27dfa <z_log_msg2_static_create.constprop.0>
		return err;
    6ffe:	e7c3      	b.n	6f88 <bt_enable+0x28>
	if (!cb) {
    7000:	b926      	cbnz	r6, 700c <bt_enable+0xac>
}
    7002:	b010      	add	sp, #64	; 0x40
    7004:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_init();
    7008:	f7ff bd44 	b.w	6a94 <bt_init>
	k_work_submit(&bt_dev.init);
    700c:	f105 00bc 	add.w	r0, r5, #188	; 0xbc
    7010:	f01d f90c 	bl	2422c <k_work_submit>
	return 0;
    7014:	e7b8      	b.n	6f88 <bt_enable+0x28>
		return -EALREADY;
    7016:	f06f 0477 	mvn.w	r4, #119	; 0x77
    701a:	e7b5      	b.n	6f88 <bt_enable+0x28>
    701c:	20000080 	.word	0x20000080
    7020:	0002fcbd 	.word	0x0002fcbd
    7024:	0002daac 	.word	0x0002daac
    7028:	20002600 	.word	0x20002600
    702c:	00005ea5 	.word	0x00005ea5
    7030:	20004740 	.word	0x20004740
    7034:	20001660 	.word	0x20001660
    7038:	0002fcd6 	.word	0x0002fcd6
    703c:	0002fcdc 	.word	0x0002fcdc

00007040 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
    7040:	4800      	ldr	r0, [pc, #0]	; (7044 <bt_get_name+0x4>)
    7042:	4770      	bx	lr
    7044:	0002fcf8 	.word	0x0002fcf8

00007048 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
    7048:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    704a:	4f0b      	ldr	r7, [pc, #44]	; (7078 <id_find+0x30>)
{
    704c:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    704e:	2500      	movs	r5, #0
    7050:	79fb      	ldrb	r3, [r7, #7]
    7052:	b2ec      	uxtb	r4, r5
    7054:	42a3      	cmp	r3, r4
    7056:	d802      	bhi.n	705e <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    7058:	f06f 0401 	mvn.w	r4, #1
    705c:	e009      	b.n	7072 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    705e:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
    7062:	2207      	movs	r2, #7
    7064:	4439      	add	r1, r7
    7066:	4630      	mov	r0, r6
    7068:	f020 fbf1 	bl	2784e <memcmp>
    706c:	3501      	adds	r5, #1
    706e:	2800      	cmp	r0, #0
    7070:	d1ee      	bne.n	7050 <id_find+0x8>
}
    7072:	4620      	mov	r0, r4
    7074:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7076:	bf00      	nop
    7078:	20000080 	.word	0x20000080

0000707c <set_random_address>:
{
    707c:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
    707e:	4914      	ldr	r1, [pc, #80]	; (70d0 <set_random_address+0x54>)
    7080:	2206      	movs	r2, #6
    7082:	4605      	mov	r5, r0
    7084:	f020 fbe3 	bl	2784e <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    7088:	4604      	mov	r4, r0
    708a:	b1e0      	cbz	r0, 70c6 <set_random_address+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    708c:	2106      	movs	r1, #6
    708e:	f242 0005 	movw	r0, #8197	; 0x2005
    7092:	f7ff f865 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    7096:	4604      	mov	r4, r0
    7098:	b1b8      	cbz	r0, 70ca <set_random_address+0x4e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    709a:	2206      	movs	r2, #6
    709c:	4629      	mov	r1, r5
    709e:	3008      	adds	r0, #8
    70a0:	f024 fe52 	bl	2bd48 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    70a4:	4621      	mov	r1, r4
    70a6:	2200      	movs	r2, #0
    70a8:	f242 0005 	movw	r0, #8197	; 0x2005
    70ac:	f7ff f9b4 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    70b0:	4604      	mov	r4, r0
    70b2:	b940      	cbnz	r0, 70c6 <set_random_address+0x4a>
	memcpy(dst, src, sizeof(*dst));
    70b4:	2206      	movs	r2, #6
    70b6:	4806      	ldr	r0, [pc, #24]	; (70d0 <set_random_address+0x54>)
    70b8:	4629      	mov	r1, r5
    70ba:	f020 fbd9 	bl	27870 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    70be:	4b05      	ldr	r3, [pc, #20]	; (70d4 <set_random_address+0x58>)
    70c0:	2201      	movs	r2, #1
    70c2:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
}
    70c6:	4620      	mov	r0, r4
    70c8:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
    70ca:	f06f 0468 	mvn.w	r4, #104	; 0x68
    70ce:	e7fa      	b.n	70c6 <set_random_address+0x4a>
    70d0:	200000e1 	.word	0x200000e1
    70d4:	20000080 	.word	0x20000080

000070d8 <id_create.constprop.0>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    70d8:	b530      	push	{r4, r5, lr}
    70da:	4604      	mov	r4, r0
    70dc:	b085      	sub	sp, #20
{
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    70de:	460d      	mov	r5, r1
    70e0:	b1e9      	cbz	r1, 711e <id_create.constprop.0+0x46>
    70e2:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    70e4:	2207      	movs	r2, #7
    70e6:	a902      	add	r1, sp, #8
    70e8:	4628      	mov	r0, r5
    70ea:	9302      	str	r3, [sp, #8]
    70ec:	f8cd 300b 	str.w	r3, [sp, #11]
    70f0:	f020 fbad 	bl	2784e <memcmp>
    70f4:	b198      	cbz	r0, 711e <id_create.constprop.0+0x46>
	memcpy(dst, src, sizeof(*dst));
    70f6:	4817      	ldr	r0, [pc, #92]	; (7154 <id_create.constprop.0+0x7c>)
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    70f8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    70fc:	2207      	movs	r2, #7
    70fe:	4629      	mov	r1, r5
    7100:	4420      	add	r0, r4
    7102:	f020 fbb5 	bl	27870 <memcpy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    7106:	4814      	ldr	r0, [pc, #80]	; (7158 <id_create.constprop.0+0x80>)
    7108:	f020 ff3b 	bl	27f82 <atomic_get>
#endif
	/* Only store if stack was already initialized. Before initialization
	 * we don't know the flash content, so it's potentially harmful to
	 * try to write anything there.
	 */
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    710c:	0782      	lsls	r2, r0, #30
    710e:	f3c0 0340 	ubfx	r3, r0, #1, #1
    7112:	d51d      	bpl.n	7150 <id_create.constprop.0+0x78>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
    7114:	f7fe fb1a 	bl	574c <bt_settings_save_id>
	}

	return 0;
    7118:	2000      	movs	r0, #0
}
    711a:	b005      	add	sp, #20
    711c:	bd30      	pop	{r4, r5, pc}
			err = bt_addr_le_create_static(&new_addr);
    711e:	4668      	mov	r0, sp
    7120:	f020 fe3c 	bl	27d9c <bt_addr_le_create_static>
			if (err) {
    7124:	2800      	cmp	r0, #0
    7126:	d1f8      	bne.n	711a <id_create.constprop.0+0x42>
		} while (id_find(&new_addr) >= 0);
    7128:	4668      	mov	r0, sp
    712a:	f7ff ff8d 	bl	7048 <id_find>
    712e:	2800      	cmp	r0, #0
    7130:	daf5      	bge.n	711e <id_create.constprop.0+0x46>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    7132:	4808      	ldr	r0, [pc, #32]	; (7154 <id_create.constprop.0+0x7c>)
    7134:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    7138:	4404      	add	r4, r0
    713a:	2207      	movs	r2, #7
    713c:	4669      	mov	r1, sp
    713e:	4620      	mov	r0, r4
    7140:	f020 fb96 	bl	27870 <memcpy>
		if (addr) {
    7144:	2d00      	cmp	r5, #0
    7146:	d0de      	beq.n	7106 <id_create.constprop.0+0x2e>
    7148:	2207      	movs	r2, #7
    714a:	4621      	mov	r1, r4
    714c:	4628      	mov	r0, r5
    714e:	e7d8      	b.n	7102 <id_create.constprop.0+0x2a>
	return 0;
    7150:	4618      	mov	r0, r3
    7152:	e7e2      	b.n	711a <id_create.constprop.0+0x42>
    7154:	20000080 	.word	0x20000080
    7158:	2000014c 	.word	0x2000014c

0000715c <bt_id_adv_random_addr_check>:
{
    715c:	b508      	push	{r3, lr}
    715e:	4805      	ldr	r0, [pc, #20]	; (7174 <bt_id_adv_random_addr_check+0x18>)
    7160:	f020 ff0f 	bl	27f82 <atomic_get>
	if (!(atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING) ||
    7164:	0503      	lsls	r3, r0, #20
    7166:	d402      	bmi.n	716e <bt_id_adv_random_addr_check+0x12>
    7168:	4802      	ldr	r0, [pc, #8]	; (7174 <bt_id_adv_random_addr_check+0x18>)
    716a:	f020 ff0a 	bl	27f82 <atomic_get>
}
    716e:	2001      	movs	r0, #1
    7170:	bd08      	pop	{r3, pc}
    7172:	bf00      	nop
    7174:	2000014c 	.word	0x2000014c

00007178 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
    7178:	b570      	push	{r4, r5, r6, lr}
    717a:	460c      	mov	r4, r1
    717c:	b08a      	sub	sp, #40	; 0x28
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    717e:	4605      	mov	r5, r0
    7180:	b918      	cbnz	r0, 718a <bt_id_create+0x12>
		if (id_find(addr) >= 0) {
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    7182:	b354      	cbz	r4, 71da <bt_id_create+0x62>
		return -EINVAL;
    7184:	f06f 0015 	mvn.w	r0, #21
    7188:	e025      	b.n	71d6 <bt_id_create+0x5e>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    718a:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    718c:	2207      	movs	r2, #7
    718e:	a902      	add	r1, sp, #8
    7190:	9302      	str	r3, [sp, #8]
    7192:	f8cd 300b 	str.w	r3, [sp, #11]
    7196:	f020 fb5a 	bl	2784e <memcmp>
    719a:	2800      	cmp	r0, #0
    719c:	d0f1      	beq.n	7182 <bt_id_create+0xa>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    719e:	782b      	ldrb	r3, [r5, #0]
    71a0:	2b01      	cmp	r3, #1
    71a2:	d104      	bne.n	71ae <bt_id_create+0x36>
    71a4:	79ab      	ldrb	r3, [r5, #6]
    71a6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    71aa:	2bc0      	cmp	r3, #192	; 0xc0
    71ac:	d00c      	beq.n	71c8 <bt_id_create+0x50>
			BT_ERR("Only static random identity address supported");
    71ae:	4b1d      	ldr	r3, [pc, #116]	; (7224 <bt_id_create+0xac>)
    71b0:	9308      	str	r3, [sp, #32]
    71b2:	2302      	movs	r3, #2
    71b4:	9301      	str	r3, [sp, #4]
    71b6:	9307      	str	r3, [sp, #28]
    71b8:	481b      	ldr	r0, [pc, #108]	; (7228 <bt_id_create+0xb0>)
    71ba:	2300      	movs	r3, #0
    71bc:	aa07      	add	r2, sp, #28
    71be:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    71c2:	f01e fd89 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return -EINVAL;
    71c6:	e7dd      	b.n	7184 <bt_id_create+0xc>
		if (id_find(addr) >= 0) {
    71c8:	4628      	mov	r0, r5
    71ca:	f7ff ff3d 	bl	7048 <id_find>
    71ce:	2800      	cmp	r0, #0
    71d0:	dbd7      	blt.n	7182 <bt_id_create+0xa>
			return -EALREADY;
    71d2:	f06f 0077 	mvn.w	r0, #119	; 0x77
	if (err) {
		return err;
	}

	return new_id;
}
    71d6:	b00a      	add	sp, #40	; 0x28
    71d8:	bd70      	pop	{r4, r5, r6, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    71da:	4e14      	ldr	r6, [pc, #80]	; (722c <bt_id_create+0xb4>)
    71dc:	79f3      	ldrb	r3, [r6, #7]
    71de:	2b01      	cmp	r3, #1
    71e0:	d01c      	beq.n	721c <bt_id_create+0xa4>
    71e2:	f106 00cc 	add.w	r0, r6, #204	; 0xcc
    71e6:	f020 fecc 	bl	27f82 <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    71ea:	07c3      	lsls	r3, r0, #31
    71ec:	d40b      	bmi.n	7206 <bt_id_create+0x8e>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
    71ee:	2d00      	cmp	r5, #0
    71f0:	d0c8      	beq.n	7184 <bt_id_create+0xc>
    71f2:	2207      	movs	r2, #7
    71f4:	a904      	add	r1, sp, #16
    71f6:	4628      	mov	r0, r5
    71f8:	9404      	str	r4, [sp, #16]
    71fa:	f8cd 4013 	str.w	r4, [sp, #19]
    71fe:	f020 fb26 	bl	2784e <memcmp>
    7202:	2800      	cmp	r0, #0
    7204:	d0be      	beq.n	7184 <bt_id_create+0xc>
	new_id = bt_dev.id_count++;
    7206:	79f4      	ldrb	r4, [r6, #7]
	err = id_create(new_id, addr, irk);
    7208:	4629      	mov	r1, r5
	new_id = bt_dev.id_count++;
    720a:	1c63      	adds	r3, r4, #1
	err = id_create(new_id, addr, irk);
    720c:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    720e:	71f3      	strb	r3, [r6, #7]
	err = id_create(new_id, addr, irk);
    7210:	f7ff ff62 	bl	70d8 <id_create.constprop.0>
	new_id = bt_dev.id_count++;
    7214:	2800      	cmp	r0, #0
    7216:	bf08      	it	eq
    7218:	4620      	moveq	r0, r4
    721a:	e7dc      	b.n	71d6 <bt_id_create+0x5e>
		return -ENOMEM;
    721c:	f06f 000b 	mvn.w	r0, #11
    7220:	e7d9      	b.n	71d6 <bt_id_create+0x5e>
    7222:	bf00      	nop
    7224:	0002fcff 	.word	0x0002fcff
    7228:	0002dabc 	.word	0x0002dabc
    722c:	20000080 	.word	0x20000080

00007230 <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
    7230:	b570      	push	{r4, r5, r6, lr}
    7232:	b08a      	sub	sp, #40	; 0x28
    7234:	4606      	mov	r6, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    7236:	aa01      	add	r2, sp, #4
    7238:	2100      	movs	r1, #0
    723a:	f241 0009 	movw	r0, #4105	; 0x1009
    723e:	f7ff f8eb 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    7242:	4604      	mov	r4, r0
    7244:	b170      	cbz	r0, 7264 <bt_id_read_public_addr+0x34>
		BT_WARN("Failed to read public address");
    7246:	4b1f      	ldr	r3, [pc, #124]	; (72c4 <bt_id_read_public_addr+0x94>)
    7248:	9308      	str	r3, [sp, #32]
    724a:	2302      	movs	r3, #2
    724c:	9302      	str	r3, [sp, #8]
    724e:	9307      	str	r3, [sp, #28]
    7250:	481d      	ldr	r0, [pc, #116]	; (72c8 <bt_id_read_public_addr+0x98>)
    7252:	2300      	movs	r3, #0
    7254:	aa07      	add	r2, sp, #28
    7256:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    725a:	f01e fd3d 	bl	25cd8 <z_impl_z_log_msg2_static_create>

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
		return 0U;
    725e:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
    7260:	b00a      	add	sp, #40	; 0x28
    7262:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    7264:	9b01      	ldr	r3, [sp, #4]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    7266:	689d      	ldr	r5, [r3, #8]
    7268:	9002      	str	r0, [sp, #8]
    726a:	3501      	adds	r5, #1
    726c:	f8ad 000c 	strh.w	r0, [sp, #12]
	return memcmp(a, b, sizeof(*a));
    7270:	2206      	movs	r2, #6
    7272:	a902      	add	r1, sp, #8
    7274:	4628      	mov	r0, r5
    7276:	f020 faea 	bl	2784e <memcmp>
    727a:	b918      	cbnz	r0, 7284 <bt_id_read_public_addr+0x54>
		net_buf_unref(rsp);
    727c:	9801      	ldr	r0, [sp, #4]
    727e:	f019 fb09 	bl	20894 <net_buf_unref>
    7282:	e7ec      	b.n	725e <bt_id_read_public_addr+0x2e>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    7284:	23ff      	movs	r3, #255	; 0xff
    7286:	2206      	movs	r2, #6
    7288:	a904      	add	r1, sp, #16
    728a:	4628      	mov	r0, r5
    728c:	f88d 3010 	strb.w	r3, [sp, #16]
    7290:	f88d 3011 	strb.w	r3, [sp, #17]
    7294:	f88d 3012 	strb.w	r3, [sp, #18]
    7298:	f88d 3013 	strb.w	r3, [sp, #19]
    729c:	f88d 3014 	strb.w	r3, [sp, #20]
    72a0:	f88d 3015 	strb.w	r3, [sp, #21]
    72a4:	f020 fad3 	bl	2784e <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    72a8:	2800      	cmp	r0, #0
    72aa:	d0e7      	beq.n	727c <bt_id_read_public_addr+0x4c>
	memcpy(dst, src, sizeof(*dst));
    72ac:	2206      	movs	r2, #6
    72ae:	4629      	mov	r1, r5
    72b0:	1c70      	adds	r0, r6, #1
    72b2:	f020 fadd 	bl	27870 <memcpy>
	net_buf_unref(rsp);
    72b6:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    72b8:	7034      	strb	r4, [r6, #0]
	net_buf_unref(rsp);
    72ba:	f019 faeb 	bl	20894 <net_buf_unref>
	return 1U;
    72be:	2001      	movs	r0, #1
    72c0:	e7ce      	b.n	7260 <bt_id_read_public_addr+0x30>
    72c2:	bf00      	nop
    72c4:	0002fd2d 	.word	0x0002fd2d
    72c8:	0002dabc 	.word	0x0002dabc

000072cc <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
    72cc:	b507      	push	{r0, r1, r2, lr}
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
    72ce:	4668      	mov	r0, sp
    72d0:	f7ff ffae 	bl	7230 <bt_id_read_public_addr>
    72d4:	4b04      	ldr	r3, [pc, #16]	; (72e8 <bt_setup_public_id_addr+0x1c>)
    72d6:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
    72d8:	b118      	cbz	r0, 72e2 <bt_setup_public_id_addr+0x16>
	} else if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	return id_create(BT_ID_DEFAULT, &addr, irk);
    72da:	4669      	mov	r1, sp
    72dc:	2000      	movs	r0, #0
    72de:	f7ff fefb 	bl	70d8 <id_create.constprop.0>
}
    72e2:	b003      	add	sp, #12
    72e4:	f85d fb04 	ldr.w	pc, [sp], #4
    72e8:	20000080 	.word	0x20000080

000072ec <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
    72ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    72f0:	4b24      	ldr	r3, [pc, #144]	; (7384 <bt_read_static_addr+0x98>)
    72f2:	f893 40ba 	ldrb.w	r4, [r3, #186]	; 0xba
    72f6:	f014 0401 	ands.w	r4, r4, #1
{
    72fa:	b088      	sub	sp, #32
    72fc:	4607      	mov	r7, r0
    72fe:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    7300:	d10c      	bne.n	731c <bt_read_static_addr+0x30>
		BT_WARN("Read Static Addresses command not available");
    7302:	4b21      	ldr	r3, [pc, #132]	; (7388 <bt_read_static_addr+0x9c>)
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
	}

	net_buf_unref(rsp);
	if (!cnt) {
		BT_WARN("No static addresses stored in controller");
    7304:	9306      	str	r3, [sp, #24]
    7306:	2302      	movs	r3, #2
    7308:	9301      	str	r3, [sp, #4]
    730a:	9305      	str	r3, [sp, #20]
    730c:	481f      	ldr	r0, [pc, #124]	; (738c <bt_read_static_addr+0xa0>)
    730e:	4623      	mov	r3, r4
    7310:	aa05      	add	r2, sp, #20
    7312:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    7316:	f01e fcdf 	bl	25cd8 <z_impl_z_log_msg2_static_create>
    731a:	e014      	b.n	7346 <bt_read_static_addr+0x5a>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    731c:	466a      	mov	r2, sp
    731e:	2100      	movs	r1, #0
    7320:	f64f 4009 	movw	r0, #64521	; 0xfc09
    7324:	f7ff f878 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    7328:	4605      	mov	r5, r0
    732a:	b180      	cbz	r0, 734e <bt_read_static_addr+0x62>
		BT_WARN("Failed to read static addresses");
    732c:	4b18      	ldr	r3, [pc, #96]	; (7390 <bt_read_static_addr+0xa4>)
    732e:	9306      	str	r3, [sp, #24]
    7330:	2302      	movs	r3, #2
    7332:	9301      	str	r3, [sp, #4]
    7334:	9305      	str	r3, [sp, #20]
    7336:	4815      	ldr	r0, [pc, #84]	; (738c <bt_read_static_addr+0xa0>)
    7338:	2300      	movs	r3, #0
    733a:	aa05      	add	r2, sp, #20
    733c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return 0;
    7340:	2400      	movs	r4, #0
    7342:	f01e fcc9 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	}

	return cnt;
}
    7346:	4620      	mov	r0, r4
    7348:	b008      	add	sp, #32
    734a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	rp = (void *)rsp->data;
    734e:	9b00      	ldr	r3, [sp, #0]
    7350:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    7352:	785c      	ldrb	r4, [r3, #1]
    7354:	42b4      	cmp	r4, r6
    7356:	bf28      	it	cs
    7358:	4634      	movcs	r4, r6
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    735a:	f04f 0816 	mov.w	r8, #22
    735e:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
    7360:	42ac      	cmp	r4, r5
    7362:	dc06      	bgt.n	7372 <bt_read_static_addr+0x86>
	net_buf_unref(rsp);
    7364:	9800      	ldr	r0, [sp, #0]
    7366:	f019 fa95 	bl	20894 <net_buf_unref>
	if (!cnt) {
    736a:	2c00      	cmp	r4, #0
    736c:	d1eb      	bne.n	7346 <bt_read_static_addr+0x5a>
		BT_WARN("No static addresses stored in controller");
    736e:	4b09      	ldr	r3, [pc, #36]	; (7394 <bt_read_static_addr+0xa8>)
    7370:	e7c8      	b.n	7304 <bt_read_static_addr+0x18>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    7372:	fb08 7005 	mla	r0, r8, r5, r7
    7376:	2216      	movs	r2, #22
    7378:	4631      	mov	r1, r6
    737a:	f020 fa79 	bl	27870 <memcpy>
	for (i = 0; i < cnt; i++) {
    737e:	3501      	adds	r5, #1
    7380:	e7ee      	b.n	7360 <bt_read_static_addr+0x74>
    7382:	bf00      	nop
    7384:	20000080 	.word	0x20000080
    7388:	0002fd4b 	.word	0x0002fd4b
    738c:	0002dabc 	.word	0x0002dabc
    7390:	0002fd77 	.word	0x0002fd77
    7394:	0002fd97 	.word	0x0002fd97

00007398 <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
    7398:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
    739a:	4e15      	ldr	r6, [pc, #84]	; (73f0 <bt_setup_random_id_addr+0x58>)
    739c:	79f4      	ldrb	r4, [r6, #7]
{
    739e:	b089      	sub	sp, #36	; 0x24
	if (!bt_dev.id_count) {
    73a0:	b9f4      	cbnz	r4, 73e0 <bt_setup_random_id_addr+0x48>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    73a2:	2101      	movs	r1, #1
    73a4:	a802      	add	r0, sp, #8
    73a6:	f7ff ffa1 	bl	72ec <bt_read_static_addr>
    73aa:	71f0      	strb	r0, [r6, #7]

		if (bt_dev.id_count) {
    73ac:	b1c0      	cbz	r0, 73e0 <bt_setup_random_id_addr+0x48>
					atomic_set_bit(bt_dev.flags,
						       BT_DEV_STORE_ID);
				}
#endif /* CONFIG_BT_PRIVACY */

				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    73ae:	2716      	movs	r7, #22
    73b0:	ab02      	add	r3, sp, #8
    73b2:	b2e5      	uxtb	r5, r4
    73b4:	fb07 3105 	mla	r1, r7, r5, r3
    73b8:	2206      	movs	r2, #6
    73ba:	f10d 0001 	add.w	r0, sp, #1
    73be:	f020 fa57 	bl	27870 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    73c2:	2301      	movs	r3, #1

				err = id_create(i, &addr, irk);
    73c4:	4669      	mov	r1, sp
    73c6:	4628      	mov	r0, r5
				addr.type = BT_ADDR_LE_RANDOM;
    73c8:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
    73cc:	f7ff fe84 	bl	70d8 <id_create.constprop.0>
				if (err) {
    73d0:	b920      	cbnz	r0, 73dc <bt_setup_random_id_addr+0x44>
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
    73d2:	79f2      	ldrb	r2, [r6, #7]
    73d4:	3401      	adds	r4, #1
    73d6:	b2e3      	uxtb	r3, r4
    73d8:	429a      	cmp	r2, r3
    73da:	d8e9      	bhi.n	73b0 <bt_setup_random_id_addr+0x18>
	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
}
    73dc:	b009      	add	sp, #36	; 0x24
    73de:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return bt_id_create(NULL, NULL);
    73e0:	2100      	movs	r1, #0
    73e2:	4608      	mov	r0, r1
}
    73e4:	b009      	add	sp, #36	; 0x24
    73e6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_id_create(NULL, NULL);
    73ea:	f7ff bec5 	b.w	7178 <bt_id_create>
    73ee:	bf00      	nop
    73f0:	20000080 	.word	0x20000080

000073f4 <bt_id_set_scan_own_addr>:

	return adv && atomic_test_bit(adv->flags, BT_ADV_ENABLED);
}

int bt_id_set_scan_own_addr(bool active_scan, uint8_t *own_addr_type)
{
    73f4:	b570      	push	{r4, r5, r6, lr}
			*own_addr_type = BT_HCI_OWN_ADDR_RPA_OR_RANDOM;
		} else {
			*own_addr_type = BT_ADDR_LE_RANDOM;
		}
	} else {
		*own_addr_type = bt_dev.id_addr[0].type;
    73f6:	4b12      	ldr	r3, [pc, #72]	; (7440 <bt_id_set_scan_own_addr+0x4c>)
    73f8:	781b      	ldrb	r3, [r3, #0]
    73fa:	700b      	strb	r3, [r1, #0]
{
    73fc:	b088      	sub	sp, #32
    73fe:	4606      	mov	r6, r0
    7400:	460d      	mov	r5, r1
		/* Use NRPA unless identity has been explicitly requested
		 * (through Kconfig).
		 * Use same RPA as legacy advertiser if advertising.
		 */
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
		    !is_adv_using_rand_addr()) {
    7402:	f020 fdc4 	bl	27f8e <is_adv_using_rand_addr>
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
    7406:	b9b0      	cbnz	r0, 7436 <bt_id_set_scan_own_addr+0x42>
			err = bt_id_set_private_addr(BT_ID_DEFAULT);
    7408:	f020 fdcd 	bl	27fa6 <bt_id_set_private_addr>
			if (err) {
    740c:	4604      	mov	r4, r0
    740e:	b180      	cbz	r0, 7432 <bt_id_set_scan_own_addr+0x3e>
				if (active_scan || !is_adv_using_rand_addr()) {
    7410:	b996      	cbnz	r6, 7438 <bt_id_set_scan_own_addr+0x44>
    7412:	f020 fdbc 	bl	27f8e <is_adv_using_rand_addr>
    7416:	b178      	cbz	r0, 7438 <bt_id_set_scan_own_addr+0x44>
					return err;
				}

				BT_WARN("Ignoring failure to set address for passive scan (%d)",
    7418:	4b0a      	ldr	r3, [pc, #40]	; (7444 <bt_id_set_scan_own_addr+0x50>)
    741a:	e9cd 3406 	strd	r3, r4, [sp, #24]
    741e:	2303      	movs	r3, #3
    7420:	9301      	str	r3, [sp, #4]
    7422:	9305      	str	r3, [sp, #20]
    7424:	4808      	ldr	r0, [pc, #32]	; (7448 <bt_id_set_scan_own_addr+0x54>)
    7426:	4633      	mov	r3, r6
    7428:	aa05      	add	r2, sp, #20
    742a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    742e:	f01e fc53 	bl	25cd8 <z_impl_z_log_msg2_static_create>
					err);
			}

			*own_addr_type = BT_ADDR_LE_RANDOM;
    7432:	2301      	movs	r3, #1
    7434:	702b      	strb	r3, [r5, #0]
				return err;
			}
		}
	}

	return 0;
    7436:	2400      	movs	r4, #0
}
    7438:	4620      	mov	r0, r4
    743a:	b008      	add	sp, #32
    743c:	bd70      	pop	{r4, r5, r6, pc}
    743e:	bf00      	nop
    7440:	20000080 	.word	0x20000080
    7444:	0002fdc0 	.word	0x0002fdc0
    7448:	0002dabc 	.word	0x0002dabc

0000744c <bt_id_set_adv_own_addr>:
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
    744c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    7450:	f011 0401 	ands.w	r4, r1, #1
	id_addr = &bt_dev.id_addr[adv->id];
    7454:	7806      	ldrb	r6, [r0, #0]
{
    7456:	4680      	mov	r8, r0
    7458:	460d      	mov	r5, r1
    745a:	4691      	mov	r9, r2
    745c:	461f      	mov	r7, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    745e:	d02b      	beq.n	74b8 <bt_id_set_adv_own_addr+0x6c>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    7460:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 7518 <bt_id_set_adv_own_addr+0xcc>
    7464:	b12a      	cbz	r2, 7472 <bt_id_set_adv_own_addr+0x26>
    7466:	0688      	lsls	r0, r1, #26
    7468:	d503      	bpl.n	7472 <bt_id_set_adv_own_addr+0x26>
    746a:	f898 30d0 	ldrb.w	r3, [r8, #208]	; 0xd0
    746e:	0659      	lsls	r1, r3, #25
    7470:	d54f      	bpl.n	7512 <bt_id_set_adv_own_addr+0xc6>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    7472:	ebc6 03c6 	rsb	r3, r6, r6, lsl #3
    7476:	ea4f 0ac6 	mov.w	sl, r6, lsl #3
    747a:	f818 3003 	ldrb.w	r3, [r8, r3]
    747e:	2b01      	cmp	r3, #1
    7480:	d009      	beq.n	7496 <bt_id_set_adv_own_addr+0x4a>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    7482:	ebaa 0606 	sub.w	r6, sl, r6
    7486:	f818 3006 	ldrb.w	r3, [r8, r6]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    748a:	f1b9 0f00 	cmp.w	r9, #0
    748e:	d10e      	bne.n	74ae <bt_id_set_adv_own_addr+0x62>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    7490:	703b      	strb	r3, [r7, #0]
		if (err) {
			return err;
		}
	}

	return 0;
    7492:	2400      	movs	r4, #0
    7494:	e008      	b.n	74a8 <bt_id_set_adv_own_addr+0x5c>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    7496:	2007      	movs	r0, #7
    7498:	fb10 3006 	smlabb	r0, r0, r6, r3
		return set_random_address(addr);
    749c:	4440      	add	r0, r8
    749e:	f7ff fded 	bl	707c <set_random_address>
				if (err) {
    74a2:	4604      	mov	r4, r0
    74a4:	2800      	cmp	r0, #0
    74a6:	d0ec      	beq.n	7482 <bt_id_set_adv_own_addr+0x36>
}
    74a8:	4620      	mov	r0, r4
    74aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    74ae:	06aa      	lsls	r2, r5, #26
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    74b0:	bf48      	it	mi
    74b2:	f043 0302 	orrmi.w	r3, r3, #2
    74b6:	e7eb      	b.n	7490 <bt_id_set_adv_own_addr+0x44>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    74b8:	f011 0504 	ands.w	r5, r1, #4
    74bc:	d014      	beq.n	74e8 <bt_id_set_adv_own_addr+0x9c>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    74be:	f8df 8058 	ldr.w	r8, [pc, #88]	; 7518 <bt_id_set_adv_own_addr+0xcc>
    74c2:	ebc6 03c6 	rsb	r3, r6, r6, lsl #3
    74c6:	00f5      	lsls	r5, r6, #3
    74c8:	f818 3003 	ldrb.w	r3, [r8, r3]
    74cc:	2b01      	cmp	r3, #1
    74ce:	d106      	bne.n	74de <bt_id_set_adv_own_addr+0x92>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    74d0:	2007      	movs	r0, #7
    74d2:	fb10 3006 	smlabb	r0, r0, r6, r3
		return set_random_address(addr);
    74d6:	4440      	add	r0, r8
    74d8:	f7ff fdd0 	bl	707c <set_random_address>
    74dc:	4604      	mov	r4, r0
			*own_addr_type = id_addr->type;
    74de:	1bad      	subs	r5, r5, r6
    74e0:	f818 3005 	ldrb.w	r3, [r8, r5]
    74e4:	703b      	strb	r3, [r7, #0]
    74e6:	e7df      	b.n	74a8 <bt_id_set_adv_own_addr+0x5c>
    74e8:	480c      	ldr	r0, [pc, #48]	; (751c <bt_id_set_adv_own_addr+0xd0>)
    74ea:	f020 fd4a 	bl	27f82 <atomic_get>
			if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    74ee:	0683      	lsls	r3, r0, #26
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    74f0:	f3c0 1640 	ubfx	r6, r0, #5, #1
    74f4:	d502      	bpl.n	74fc <bt_id_set_adv_own_addr+0xb0>
				bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
    74f6:	4628      	mov	r0, r5
    74f8:	f020 fe7d 	bl	281f6 <bt_le_scan_set_enable>
			err = bt_id_set_adv_private_addr(adv);
    74fc:	4640      	mov	r0, r8
    74fe:	f020 fd64 	bl	27fca <bt_id_set_adv_private_addr>
    7502:	4604      	mov	r4, r0
			*own_addr_type = BT_ADDR_LE_RANDOM;
    7504:	2001      	movs	r0, #1
    7506:	7038      	strb	r0, [r7, #0]
			if (scan_enabled) {
    7508:	2e00      	cmp	r6, #0
    750a:	d0cd      	beq.n	74a8 <bt_id_set_adv_own_addr+0x5c>
				bt_le_scan_set_enable(BT_HCI_LE_SCAN_ENABLE);
    750c:	f020 fe73 	bl	281f6 <bt_le_scan_set_enable>
		if (err) {
    7510:	e7ca      	b.n	74a8 <bt_id_set_adv_own_addr+0x5c>
			return -ENOTSUP;
    7512:	f06f 0485 	mvn.w	r4, #133	; 0x85
    7516:	e7c7      	b.n	74a8 <bt_id_set_adv_own_addr+0x5c>
    7518:	20000080 	.word	0x20000080
    751c:	2000014c 	.word	0x2000014c

00007520 <valid_adv_param>:
	return true;
}

static bool valid_adv_param(const struct bt_le_adv_param *param)
{
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    7520:	6843      	ldr	r3, [r0, #4]
{
    7522:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7524:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    7526:	0558      	lsls	r0, r3, #21
    7528:	d502      	bpl.n	7530 <valid_adv_param+0x10>
		return false;
    752a:	2000      	movs	r0, #0
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
		return false;
	}

	return valid_adv_ext_param(param);
}
    752c:	b003      	add	sp, #12
    752e:	bd30      	pop	{r4, r5, pc}
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    7530:	6922      	ldr	r2, [r4, #16]
    7532:	b10a      	cbz	r2, 7538 <valid_adv_param+0x18>
    7534:	07d9      	lsls	r1, r3, #31
    7536:	d5f8      	bpl.n	752a <valid_adv_param+0xa>
	if (param->id >= bt_dev.id_count ||
    7538:	4d1a      	ldr	r5, [pc, #104]	; (75a4 <valid_adv_param+0x84>)
    753a:	7820      	ldrb	r0, [r4, #0]
    753c:	79eb      	ldrb	r3, [r5, #7]
    753e:	4283      	cmp	r3, r0
    7540:	d9f3      	bls.n	752a <valid_adv_param+0xa>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    7542:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    7546:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    7548:	2207      	movs	r2, #7
    754a:	4669      	mov	r1, sp
    754c:	4428      	add	r0, r5
    754e:	9300      	str	r3, [sp, #0]
    7550:	f8cd 3003 	str.w	r3, [sp, #3]
    7554:	f020 f97b 	bl	2784e <memcmp>
	if (param->id >= bt_dev.id_count ||
    7558:	2800      	cmp	r0, #0
    755a:	d0e6      	beq.n	752a <valid_adv_param+0xa>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    755c:	6860      	ldr	r0, [r4, #4]
    755e:	07c2      	lsls	r2, r0, #31
    7560:	d406      	bmi.n	7570 <valid_adv_param+0x50>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    7562:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
    7566:	2b08      	cmp	r3, #8
    7568:	d802      	bhi.n	7570 <valid_adv_param+0x50>
    756a:	68a3      	ldr	r3, [r4, #8]
    756c:	2b9f      	cmp	r3, #159	; 0x9f
    756e:	d9dc      	bls.n	752a <valid_adv_param+0xa>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
    7570:	f010 0f30 	tst.w	r0, #48	; 0x30
    7574:	d002      	beq.n	757c <valid_adv_param+0x5c>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    7576:	6923      	ldr	r3, [r4, #16]
    7578:	2b00      	cmp	r3, #0
    757a:	d0d6      	beq.n	752a <valid_adv_param+0xa>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    757c:	06c3      	lsls	r3, r0, #27
    757e:	d401      	bmi.n	7584 <valid_adv_param+0x64>
    7580:	6923      	ldr	r3, [r4, #16]
    7582:	b943      	cbnz	r3, 7596 <valid_adv_param+0x76>
		if (param->interval_min > param->interval_max ||
    7584:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    7588:	429a      	cmp	r2, r3
    758a:	d8ce      	bhi.n	752a <valid_adv_param+0xa>
    758c:	2a1f      	cmp	r2, #31
    758e:	d9cc      	bls.n	752a <valid_adv_param+0xa>
		    param->interval_min < 0x0020 ||
    7590:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    7594:	d8c9      	bhi.n	752a <valid_adv_param+0xa>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    7596:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    759a:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
    759e:	bf18      	it	ne
    75a0:	2001      	movne	r0, #1
    75a2:	e7c3      	b.n	752c <valid_adv_param+0xc>
    75a4:	20000080 	.word	0x20000080

000075a8 <hci_set_ad>:
	*data_len = set_data_len;
	return 0;
}

static int hci_set_ad(uint16_t hci_op, const struct bt_ad *ad, size_t ad_len)
{
    75a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    75ac:	460c      	mov	r4, r1
    75ae:	b08b      	sub	sp, #44	; 0x2c
	struct bt_hci_cp_le_set_adv_data *set_data;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    75b0:	2120      	movs	r1, #32
{
    75b2:	4682      	mov	sl, r0
    75b4:	4616      	mov	r6, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    75b6:	f7fe fdd3 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    75ba:	4605      	mov	r5, r0
    75bc:	2800      	cmp	r0, #0
    75be:	d05e      	beq.n	767e <hci_set_ad+0xd6>
	return net_buf_simple_add(&buf->b, len);
    75c0:	2120      	movs	r1, #32
    75c2:	3008      	adds	r0, #8
    75c4:	f024 fbba 	bl	2bd3c <net_buf_simple_add>
		return -ENOBUFS;
	}

	set_data = net_buf_add(buf, sizeof(*set_data));
	(void)memset(set_data, 0, sizeof(*set_data));
    75c8:	2220      	movs	r2, #32
    75ca:	2100      	movs	r1, #0
    75cc:	4681      	mov	r9, r0
    75ce:	f020 f95a 	bl	27886 <memset>

	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
    75d2:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
    75d6:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
    75da:	9300      	str	r3, [sp, #0]
	uint8_t set_data_len = 0;
    75dc:	2600      	movs	r6, #0
		for (size_t j = 0; j < ad[i].len; j++) {
    75de:	f8d4 8000 	ldr.w	r8, [r4]
    75e2:	2300      	movs	r3, #0
    75e4:	6862      	ldr	r2, [r4, #4]
    75e6:	4293      	cmp	r3, r2
    75e8:	d30d      	bcc.n	7606 <hci_set_ad+0x5e>
	for (size_t i = 0; i < ad_len; i++) {
    75ea:	9b00      	ldr	r3, [sp, #0]
    75ec:	3408      	adds	r4, #8
    75ee:	42a3      	cmp	r3, r4
    75f0:	d1f5      	bne.n	75de <hci_set_ad+0x36>
	if (err) {
		net_buf_unref(buf);
		return err;
	}

	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    75f2:	2200      	movs	r2, #0
    75f4:	4629      	mov	r1, r5
    75f6:	4650      	mov	r0, sl
	*data_len = set_data_len;
    75f8:	f889 6000 	strb.w	r6, [r9]
}
    75fc:	b00b      	add	sp, #44	; 0x2c
    75fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
    7602:	f7fe bf09 	b.w	6418 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
    7606:	f898 2001 	ldrb.w	r2, [r8, #1]
			uint8_t type = data[j].type;
    760a:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
    760e:	1cb0      	adds	r0, r6, #2
    7610:	1881      	adds	r1, r0, r2
    7612:	291f      	cmp	r1, #31
    7614:	d91c      	bls.n	7650 <hci_set_ad+0xa8>
				if (!(type == BT_DATA_NAME_COMPLETE &&
    7616:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
    761a:	f1c0 021f 	rsb	r2, r0, #31
				if (!(type == BT_DATA_NAME_COMPLETE &&
    761e:	d101      	bne.n	7624 <hci_set_ad+0x7c>
    7620:	2a00      	cmp	r2, #0
    7622:	dc13      	bgt.n	764c <hci_set_ad+0xa4>
					BT_ERR("Too big advertising data");
    7624:	4b17      	ldr	r3, [pc, #92]	; (7684 <hci_set_ad+0xdc>)
    7626:	9308      	str	r3, [sp, #32]
    7628:	2302      	movs	r3, #2
    762a:	9303      	str	r3, [sp, #12]
    762c:	9307      	str	r3, [sp, #28]
    762e:	4816      	ldr	r0, [pc, #88]	; (7688 <hci_set_ad+0xe0>)
    7630:	2300      	movs	r3, #0
    7632:	aa07      	add	r2, sp, #28
    7634:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    7638:	f01e fb4e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		net_buf_unref(buf);
    763c:	4628      	mov	r0, r5
    763e:	f019 f929 	bl	20894 <net_buf_unref>
					return -EINVAL;
    7642:	f06f 0015 	mvn.w	r0, #21
}
    7646:	b00b      	add	sp, #44	; 0x2c
    7648:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				type = BT_DATA_NAME_SHORTENED;
    764c:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
    7650:	b2d7      	uxtb	r7, r2
    7652:	1c79      	adds	r1, r7, #1
    7654:	f80b 1006 	strb.w	r1, [fp, r6]
    7658:	1c71      	adds	r1, r6, #1
			set_data[set_data_len++] = type;
    765a:	b2c9      	uxtb	r1, r1
			memcpy(&set_data[set_data_len], data[j].data, len);
    765c:	fa5b f080 	uxtab	r0, fp, r0
			set_data[set_data_len++] = type;
    7660:	f80b c001 	strb.w	ip, [fp, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
    7664:	f8d8 1004 	ldr.w	r1, [r8, #4]
    7668:	9301      	str	r3, [sp, #4]
			set_data_len += len;
    766a:	3702      	adds	r7, #2
			memcpy(&set_data[set_data_len], data[j].data, len);
    766c:	f020 f900 	bl	27870 <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
    7670:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
    7672:	443e      	add	r6, r7
    7674:	b2f6      	uxtb	r6, r6
		for (size_t j = 0; j < ad[i].len; j++) {
    7676:	3301      	adds	r3, #1
    7678:	f108 0808 	add.w	r8, r8, #8
    767c:	e7b2      	b.n	75e4 <hci_set_ad+0x3c>
		return -ENOBUFS;
    767e:	f06f 0068 	mvn.w	r0, #104	; 0x68
    7682:	e7e0      	b.n	7646 <hci_set_ad+0x9e>
    7684:	0002fdfc 	.word	0x0002fdfc
    7688:	0002d9bc 	.word	0x0002d9bc

0000768c <le_adv_start_add_conn>:
	return channel_map;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
    768c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_conn *conn;

	bt_dev.adv_conn_id = adv->id;
    768e:	4606      	mov	r6, r0
    7690:	4b1e      	ldr	r3, [pc, #120]	; (770c <le_adv_start_add_conn+0x80>)
    7692:	f816 2b09 	ldrb.w	r2, [r6], #9
    7696:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
{
    769a:	b085      	sub	sp, #20

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    769c:	2300      	movs	r3, #0
{
    769e:	4605      	mov	r5, r0
    76a0:	2207      	movs	r2, #7
    76a2:	460f      	mov	r7, r1
    76a4:	4630      	mov	r0, r6
    76a6:	4669      	mov	r1, sp
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    76a8:	9300      	str	r3, [sp, #0]
    76aa:	f8cd 3003 	str.w	r3, [sp, #3]
    76ae:	f020 f8ce 	bl	2784e <memcmp>
    76b2:	782a      	ldrb	r2, [r5, #0]
    76b4:	4604      	mov	r4, r0
    76b6:	b9a8      	cbnz	r0, 76e4 <le_adv_start_add_conn+0x58>
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    76b8:	4b15      	ldr	r3, [pc, #84]	; (7710 <le_adv_start_add_conn+0x84>)
    76ba:	6818      	ldr	r0, [r3, #0]
    76bc:	8899      	ldrh	r1, [r3, #4]
    76be:	9002      	str	r0, [sp, #8]
    76c0:	799b      	ldrb	r3, [r3, #6]
    76c2:	f8ad 100c 	strh.w	r1, [sp, #12]
    76c6:	4610      	mov	r0, r2
    76c8:	a902      	add	r1, sp, #8
    76ca:	f88d 300e 	strb.w	r3, [sp, #14]
    76ce:	f001 f977 	bl	89c0 <bt_conn_add_le>
		if (!conn) {
    76d2:	4605      	mov	r5, r0
    76d4:	b1b8      	cbz	r0, 7706 <le_adv_start_add_conn+0x7a>
			return -ENOMEM;
		}

		bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    76d6:	2104      	movs	r1, #4
	conn = bt_conn_add_le(adv->id, &adv->target_addr);
	if (!conn) {
		return -ENOMEM;
	}

	bt_conn_set_state(conn, BT_CONN_CONNECT_DIR_ADV);
    76d8:	f000 ffca 	bl	8670 <bt_conn_set_state>
	*out_conn = conn;
    76dc:	603d      	str	r5, [r7, #0]
	return 0;
}
    76de:	4620      	mov	r0, r4
    76e0:	b005      	add	sp, #20
    76e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
    76e4:	4631      	mov	r1, r6
    76e6:	4610      	mov	r0, r2
    76e8:	f001 f9a2 	bl	8a30 <bt_conn_exists_le>
    76ec:	4604      	mov	r4, r0
    76ee:	b938      	cbnz	r0, 7700 <le_adv_start_add_conn+0x74>
	conn = bt_conn_add_le(adv->id, &adv->target_addr);
    76f0:	7828      	ldrb	r0, [r5, #0]
    76f2:	4631      	mov	r1, r6
    76f4:	f001 f964 	bl	89c0 <bt_conn_add_le>
	if (!conn) {
    76f8:	4605      	mov	r5, r0
    76fa:	b120      	cbz	r0, 7706 <le_adv_start_add_conn+0x7a>
	bt_conn_set_state(conn, BT_CONN_CONNECT_DIR_ADV);
    76fc:	2105      	movs	r1, #5
    76fe:	e7eb      	b.n	76d8 <le_adv_start_add_conn+0x4c>
		return -EINVAL;
    7700:	f06f 0415 	mvn.w	r4, #21
    7704:	e7eb      	b.n	76de <le_adv_start_add_conn+0x52>
		return -ENOMEM;
    7706:	f06f 040b 	mvn.w	r4, #11
    770a:	e7e8      	b.n	76de <le_adv_start_add_conn+0x52>
    770c:	20000080 	.word	0x20000080
    7710:	0002dd50 	.word	0x0002dd50

00007714 <bt_le_adv_lookup_legacy>:
}
    7714:	4800      	ldr	r0, [pc, #0]	; (7718 <bt_le_adv_lookup_legacy+0x4>)
    7716:	4770      	bx	lr
    7718:	20000098 	.word	0x20000098

0000771c <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
    771c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7720:	b093      	sub	sp, #76	; 0x4c
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
    7722:	690f      	ldr	r7, [r1, #16]
{
    7724:	9305      	str	r3, [sp, #20]
	struct bt_conn *conn = NULL;
    7726:	2300      	movs	r3, #0
	bool dir_adv = (param->peer != NULL), scannable = false;
    7728:	1afc      	subs	r4, r7, r3
{
    772a:	4606      	mov	r6, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    772c:	4891      	ldr	r0, [pc, #580]	; (7974 <bt_le_adv_start_legacy+0x258>)
	struct bt_conn *conn = NULL;
    772e:	9306      	str	r3, [sp, #24]
	bool dir_adv = (param->peer != NULL), scannable = false;
    7730:	bf18      	it	ne
    7732:	2401      	movne	r4, #1
    7734:	f020 fc75 	bl	28022 <atomic_get>
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7738:	0780      	lsls	r0, r0, #30
{
    773a:	460d      	mov	r5, r1
    773c:	4693      	mov	fp, r2
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    773e:	f140 810e 	bpl.w	795e <bt_le_adv_start_legacy+0x242>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
    7742:	4608      	mov	r0, r1
    7744:	f7ff feec 	bl	7520 <valid_adv_param>
    7748:	b928      	cbnz	r0, 7756 <bt_le_adv_start_legacy+0x3a>
		return -EINVAL;
    774a:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
    774e:	4620      	mov	r0, r4
    7750:	b013      	add	sp, #76	; 0x4c
    7752:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!bt_id_adv_random_addr_check(param)) {
    7756:	4628      	mov	r0, r5
    7758:	f7ff fd00 	bl	715c <bt_id_adv_random_addr_check>
    775c:	4681      	mov	r9, r0
    775e:	2800      	cmp	r0, #0
    7760:	d0f3      	beq.n	774a <bt_le_adv_start_legacy+0x2e>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    7762:	f106 0810 	add.w	r8, r6, #16
    7766:	4640      	mov	r0, r8
    7768:	f020 fc5b 	bl	28022 <atomic_get>
    776c:	0641      	lsls	r1, r0, #25
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    776e:	f3c0 1a80 	ubfx	sl, r0, #6, #1
    7772:	f100 80f7 	bmi.w	7964 <bt_le_adv_start_legacy+0x248>
	(void)memset(&set_param, 0, sizeof(set_param));
    7776:	220f      	movs	r2, #15
    7778:	4651      	mov	r1, sl
    777a:	a808      	add	r0, sp, #32
    777c:	f020 f883 	bl	27886 <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    7780:	68ab      	ldr	r3, [r5, #8]
    7782:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.channel_map  = get_adv_channel_map(param->options);
    7786:	6868      	ldr	r0, [r5, #4]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    7788:	68eb      	ldr	r3, [r5, #12]
    778a:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
    778e:	f020 fc39 	bl	28004 <get_adv_channel_map>
	if (adv->id != param->id) {
    7792:	7832      	ldrb	r2, [r6, #0]
    7794:	782b      	ldrb	r3, [r5, #0]
	set_param.channel_map  = get_adv_channel_map(param->options);
    7796:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	if (adv->id != param->id) {
    779a:	429a      	cmp	r2, r3
	set_param.filter_policy = get_filter_policy(param->options);
    779c:	f88d a02e 	strb.w	sl, [sp, #46]	; 0x2e
	if (adv->id != param->id) {
    77a0:	d004      	beq.n	77ac <bt_le_adv_start_legacy+0x90>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    77a2:	4874      	ldr	r0, [pc, #464]	; (7974 <bt_le_adv_start_legacy+0x258>)
    77a4:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    77a8:	f020 fc41 	bl	2802e <atomic_and>
	bt_dev.adv_conn_id = adv->id;
    77ac:	4a72      	ldr	r2, [pc, #456]	; (7978 <bt_le_adv_start_legacy+0x25c>)
	adv->id = param->id;
    77ae:	782b      	ldrb	r3, [r5, #0]
    77b0:	7033      	strb	r3, [r6, #0]
	bt_dev.adv_conn_id = adv->id;
    77b2:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67
	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
    77b6:	6869      	ldr	r1, [r5, #4]
    77b8:	4622      	mov	r2, r4
    77ba:	f10d 0325 	add.w	r3, sp, #37	; 0x25
    77be:	4630      	mov	r0, r6
    77c0:	f7ff fe44 	bl	744c <bt_id_set_adv_own_addr>
	if (err) {
    77c4:	4604      	mov	r4, r0
    77c6:	2800      	cmp	r0, #0
    77c8:	d1c1      	bne.n	774e <bt_le_adv_start_legacy+0x32>
		bt_addr_le_copy(&adv->target_addr, param->peer);
    77ca:	f106 0009 	add.w	r0, r6, #9
	if (dir_adv) {
    77ce:	2f00      	cmp	r7, #0
    77d0:	d055      	beq.n	787e <bt_le_adv_start_legacy+0x162>
	memcpy(dst, src, sizeof(*dst));
    77d2:	6929      	ldr	r1, [r5, #16]
    77d4:	2207      	movs	r2, #7
    77d6:	f020 f84b 	bl	27870 <memcpy>
	name_type = get_adv_name_type_param(param);
    77da:	4628      	mov	r0, r5
    77dc:	f020 fcc4 	bl	28168 <get_adv_name_type_param>
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    77e0:	686b      	ldr	r3, [r5, #4]
    77e2:	07da      	lsls	r2, r3, #31
	name_type = get_adv_name_type_param(param);
    77e4:	4682      	mov	sl, r0
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    77e6:	d553      	bpl.n	7890 <bt_le_adv_start_legacy+0x174>
		if (dir_adv) {
    77e8:	2f00      	cmp	r7, #0
    77ea:	d04e      	beq.n	788a <bt_le_adv_start_legacy+0x16e>
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    77ec:	f013 0f10 	tst.w	r3, #16
    77f0:	bf14      	ite	ne
    77f2:	2304      	movne	r3, #4
    77f4:	2301      	moveq	r3, #1
    77f6:	6929      	ldr	r1, [r5, #16]
    77f8:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    77fc:	2207      	movs	r2, #7
    77fe:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    7802:	f020 f835 	bl	27870 <memcpy>
	bool dir_adv = (param->peer != NULL), scannable = false;
    7806:	f04f 0900 	mov.w	r9, #0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    780a:	210f      	movs	r1, #15
    780c:	f242 0006 	movw	r0, #8198	; 0x2006
    7810:	f7fe fca6 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    7814:	4604      	mov	r4, r0
    7816:	2800      	cmp	r0, #0
    7818:	f000 80a7 	beq.w	796a <bt_le_adv_start_legacy+0x24e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    781c:	220f      	movs	r2, #15
    781e:	a908      	add	r1, sp, #32
    7820:	3008      	adds	r0, #8
    7822:	f024 fa91 	bl	2bd48 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    7826:	2200      	movs	r2, #0
    7828:	4621      	mov	r1, r4
    782a:	f242 0006 	movw	r0, #8198	; 0x2006
    782e:	f7fe fdf3 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    7832:	2800      	cmp	r0, #0
    7834:	f040 809c 	bne.w	7970 <bt_le_adv_start_legacy+0x254>
	if (!dir_adv) {
    7838:	2f00      	cmp	r7, #0
    783a:	d039      	beq.n	78b0 <bt_le_adv_start_legacy+0x194>
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    783c:	686b      	ldr	r3, [r5, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    783e:	07dc      	lsls	r4, r3, #31
    7840:	d444      	bmi.n	78cc <bt_le_adv_start_legacy+0x1b0>
	return bt_le_adv_set_enable_legacy(adv, enable);
    7842:	2101      	movs	r1, #1
    7844:	4630      	mov	r0, r6
    7846:	f020 fc9f 	bl	28188 <bt_le_adv_set_enable_legacy>
	if (err) {
    784a:	4604      	mov	r4, r0
    784c:	2800      	cmp	r0, #0
    784e:	d07f      	beq.n	7950 <bt_le_adv_start_legacy+0x234>
		BT_ERR("Failed to start advertiser");
    7850:	4b4a      	ldr	r3, [pc, #296]	; (797c <bt_le_adv_start_legacy+0x260>)
    7852:	9310      	str	r3, [sp, #64]	; 0x40
    7854:	2302      	movs	r3, #2
    7856:	9307      	str	r3, [sp, #28]
    7858:	930f      	str	r3, [sp, #60]	; 0x3c
    785a:	4849      	ldr	r0, [pc, #292]	; (7980 <bt_le_adv_start_legacy+0x264>)
    785c:	2300      	movs	r3, #0
    785e:	aa0f      	add	r2, sp, #60	; 0x3c
    7860:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    7864:	f01e fa38 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    7868:	9806      	ldr	r0, [sp, #24]
    786a:	2800      	cmp	r0, #0
    786c:	f43f af6f 	beq.w	774e <bt_le_adv_start_legacy+0x32>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7870:	2100      	movs	r1, #0
    7872:	f000 fefd 	bl	8670 <bt_conn_set_state>
			bt_conn_unref(conn);
    7876:	9806      	ldr	r0, [sp, #24]
    7878:	f020 fd39 	bl	282ee <bt_conn_unref>
    787c:	e767      	b.n	774e <bt_le_adv_start_legacy+0x32>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    787e:	970c      	str	r7, [sp, #48]	; 0x30
    7880:	2207      	movs	r2, #7
    7882:	f8cd 7033 	str.w	r7, [sp, #51]	; 0x33
    7886:	a90c      	add	r1, sp, #48	; 0x30
    7888:	e7a5      	b.n	77d6 <bt_le_adv_start_legacy+0xba>
			set_param.type = BT_HCI_ADV_IND;
    788a:	f88d 7024 	strb.w	r7, [sp, #36]	; 0x24
    788e:	e7bc      	b.n	780a <bt_le_adv_start_legacy+0xee>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
    7890:	059b      	lsls	r3, r3, #22
    7892:	d403      	bmi.n	789c <bt_le_adv_start_legacy+0x180>
    7894:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    7896:	b90b      	cbnz	r3, 789c <bt_le_adv_start_legacy+0x180>
    7898:	2802      	cmp	r0, #2
    789a:	d103      	bne.n	78a4 <bt_le_adv_start_legacy+0x188>
		set_param.type = BT_HCI_ADV_SCAN_IND;
    789c:	2302      	movs	r3, #2
    789e:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    78a2:	e7b2      	b.n	780a <bt_le_adv_start_legacy+0xee>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
    78a4:	2303      	movs	r3, #3
	bool dir_adv = (param->peer != NULL), scannable = false;
    78a6:	f8dd 9070 	ldr.w	r9, [sp, #112]	; 0x70
		set_param.type = BT_HCI_ADV_NONCONN_IND;
    78aa:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    78ae:	e7ac      	b.n	780a <bt_le_adv_start_legacy+0xee>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
    78b0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    78b2:	9300      	str	r3, [sp, #0]
    78b4:	e9cd 9a01 	strd	r9, sl, [sp, #4]
    78b8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    78ba:	9a05      	ldr	r2, [sp, #20]
    78bc:	4659      	mov	r1, fp
    78be:	4630      	mov	r0, r6
    78c0:	f020 fbdb 	bl	2807a <le_adv_update.constprop.0>
		if (err) {
    78c4:	4604      	mov	r4, r0
    78c6:	2800      	cmp	r0, #0
    78c8:	d0b8      	beq.n	783c <bt_le_adv_start_legacy+0x120>
    78ca:	e740      	b.n	774e <bt_le_adv_start_legacy+0x32>
		err = le_adv_start_add_conn(adv, &conn);
    78cc:	a906      	add	r1, sp, #24
    78ce:	4630      	mov	r0, r6
    78d0:	f7ff fedc 	bl	768c <le_adv_start_add_conn>
		if (err) {
    78d4:	4604      	mov	r4, r0
    78d6:	2800      	cmp	r0, #0
    78d8:	d0b3      	beq.n	7842 <bt_le_adv_start_legacy+0x126>
			if (err == -ENOMEM && !dir_adv &&
    78da:	f110 0f0c 	cmn.w	r0, #12
    78de:	f47f af36 	bne.w	774e <bt_le_adv_start_legacy+0x32>
    78e2:	2f00      	cmp	r7, #0
    78e4:	f47f af33 	bne.w	774e <bt_le_adv_start_legacy+0x32>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
    78e8:	686b      	ldr	r3, [r5, #4]
			if (err == -ENOMEM && !dir_adv &&
    78ea:	0798      	lsls	r0, r3, #30
    78ec:	f53f af2f 	bmi.w	774e <bt_le_adv_start_legacy+0x32>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    78f0:	686c      	ldr	r4, [r5, #4]
    78f2:	f084 0402 	eor.w	r4, r4, #2
    78f6:	f3c4 0440 	ubfx	r4, r4, #1, #1
    78fa:	f004 0201 	and.w	r2, r4, #1
    78fe:	210d      	movs	r1, #13
    7900:	4640      	mov	r0, r8
    7902:	f020 fba3 	bl	2804c <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
    7906:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
    790a:	425a      	negs	r2, r3
    790c:	415a      	adcs	r2, r3
    790e:	2107      	movs	r1, #7
    7910:	4640      	mov	r0, r8
    7912:	f020 fb9b 	bl	2804c <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
    7916:	f1aa 0102 	sub.w	r1, sl, #2
    791a:	424a      	negs	r2, r1
    791c:	414a      	adcs	r2, r1
    791e:	4640      	mov	r0, r8
    7920:	2108      	movs	r1, #8
    7922:	f020 fb93 	bl	2804c <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
    7926:	686a      	ldr	r2, [r5, #4]
    7928:	2109      	movs	r1, #9
    792a:	f002 0201 	and.w	r2, r2, #1
    792e:	4640      	mov	r0, r8
    7930:	f020 fb8c 	bl	2804c <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
    7934:	464a      	mov	r2, r9
    7936:	210a      	movs	r1, #10
    7938:	4640      	mov	r0, r8
    793a:	f020 fb87 	bl	2804c <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
    793e:	686a      	ldr	r2, [r5, #4]
    7940:	210c      	movs	r1, #12
    7942:	f3c2 0280 	ubfx	r2, r2, #2, #1
    7946:	4640      	mov	r0, r8
    7948:	f020 fb80 	bl	2804c <atomic_set_bit_to>
	return 0;
    794c:	2400      	movs	r4, #0
    794e:	e6fe      	b.n	774e <bt_le_adv_start_legacy+0x32>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    7950:	9806      	ldr	r0, [sp, #24]
    7952:	b108      	cbz	r0, 7958 <bt_le_adv_start_legacy+0x23c>
		bt_conn_unref(conn);
    7954:	f020 fccb 	bl	282ee <bt_conn_unref>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    7958:	2f00      	cmp	r7, #0
    795a:	d1ce      	bne.n	78fa <bt_le_adv_start_legacy+0x1de>
    795c:	e7c8      	b.n	78f0 <bt_le_adv_start_legacy+0x1d4>
		return -EAGAIN;
    795e:	f06f 040a 	mvn.w	r4, #10
    7962:	e6f4      	b.n	774e <bt_le_adv_start_legacy+0x32>
		return -EALREADY;
    7964:	f06f 0477 	mvn.w	r4, #119	; 0x77
    7968:	e6f1      	b.n	774e <bt_le_adv_start_legacy+0x32>
		return -ENOBUFS;
    796a:	f06f 0468 	mvn.w	r4, #104	; 0x68
    796e:	e6ee      	b.n	774e <bt_le_adv_start_legacy+0x32>
    7970:	4604      	mov	r4, r0
    7972:	e6ec      	b.n	774e <bt_le_adv_start_legacy+0x32>
    7974:	2000014c 	.word	0x2000014c
    7978:	20000080 	.word	0x20000080
    797c:	0002fe15 	.word	0x0002fe15
    7980:	0002d9bc 	.word	0x0002d9bc

00007984 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
    7984:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7986:	4615      	mov	r5, r2

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    7988:	9a06      	ldr	r2, [sp, #24]
{
    798a:	460c      	mov	r4, r1
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    798c:	e9cd 3200 	strd	r3, r2, [sp]
    7990:	462b      	mov	r3, r5
    7992:	460a      	mov	r2, r1
    7994:	4601      	mov	r1, r0
    7996:	4811      	ldr	r0, [pc, #68]	; (79dc <bt_le_adv_start+0x58>)
    7998:	f7ff fec0 	bl	771c <bt_le_adv_start_legacy>
    799c:	4621      	mov	r1, r4
    799e:	4606      	mov	r6, r0
	for (i = 0; i < ad_len; i++) {
    79a0:	2300      	movs	r3, #0
		if (ad[i].type == BT_DATA_FLAGS &&
    79a2:	f240 1001 	movw	r0, #257	; 0x101
	for (i = 0; i < ad_len; i++) {
    79a6:	429d      	cmp	r5, r3
    79a8:	d102      	bne.n	79b0 <bt_le_adv_start+0x2c>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
    79aa:	4630      	mov	r0, r6
    79ac:	b002      	add	sp, #8
    79ae:	bd70      	pop	{r4, r5, r6, pc}
		if (ad[i].type == BT_DATA_FLAGS &&
    79b0:	880a      	ldrh	r2, [r1, #0]
    79b2:	4282      	cmp	r2, r0
    79b4:	d104      	bne.n	79c0 <bt_le_adv_start+0x3c>
		    ad[i].data != NULL) {
    79b6:	684a      	ldr	r2, [r1, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
    79b8:	b112      	cbz	r2, 79c0 <bt_le_adv_start+0x3c>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
    79ba:	7812      	ldrb	r2, [r2, #0]
    79bc:	07d2      	lsls	r2, r2, #31
    79be:	d402      	bmi.n	79c6 <bt_le_adv_start+0x42>
	for (i = 0; i < ad_len; i++) {
    79c0:	3301      	adds	r3, #1
    79c2:	3108      	adds	r1, #8
    79c4:	e7ef      	b.n	79a6 <bt_le_adv_start+0x22>
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
    79c6:	4906      	ldr	r1, [pc, #24]	; (79e0 <bt_le_adv_start+0x5c>)
    79c8:	4806      	ldr	r0, [pc, #24]	; (79e4 <bt_le_adv_start+0x60>)
    79ca:	f025 fa0e 	bl	2cdea <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
    79ce:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    79d2:	2300      	movs	r3, #0
    79d4:	4803      	ldr	r0, [pc, #12]	; (79e4 <bt_le_adv_start+0x60>)
    79d6:	f01c fcc5 	bl	24364 <k_work_reschedule>
    79da:	e7e6      	b.n	79aa <bt_le_adv_start+0x26>
    79dc:	20000098 	.word	0x20000098
    79e0:	00007aa9 	.word	0x00007aa9
    79e4:	200000b0 	.word	0x200000b0

000079e8 <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
    79e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
	int err;

	(void)bt_le_lim_adv_cancel_timeout(adv);
    79ea:	4829      	ldr	r0, [pc, #164]	; (7a90 <bt_le_adv_stop+0xa8>)
    79ec:	f020 fbf1 	bl	281d2 <bt_le_lim_adv_cancel_timeout>
    79f0:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
    79f4:	4827      	ldr	r0, [pc, #156]	; (7a94 <bt_le_adv_stop+0xac>)
    79f6:	f020 fb1a 	bl	2802e <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    79fa:	4826      	ldr	r0, [pc, #152]	; (7a94 <bt_le_adv_stop+0xac>)
    79fc:	f020 fb11 	bl	28022 <atomic_get>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    7a00:	0641      	lsls	r1, r0, #25
    7a02:	d403      	bmi.n	7a0c <bt_le_adv_stop+0x24>
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		bt_le_adv_delete_legacy();
		return 0;
    7a04:	2400      	movs	r4, #0
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    7a06:	4620      	mov	r0, r4
    7a08:	b004      	add	sp, #16
    7a0a:	bd10      	pop	{r4, pc}
    7a0c:	4821      	ldr	r0, [pc, #132]	; (7a94 <bt_le_adv_stop+0xac>)
    7a0e:	f020 fb08 	bl	28022 <atomic_get>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7a12:	0582      	lsls	r2, r0, #22
    7a14:	d521      	bpl.n	7a5a <bt_le_adv_stop+0x72>
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    7a16:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    7a18:	481f      	ldr	r0, [pc, #124]	; (7a98 <bt_le_adv_stop+0xb0>)
    7a1a:	9300      	str	r3, [sp, #0]
    7a1c:	2207      	movs	r2, #7
    7a1e:	4669      	mov	r1, sp
    7a20:	f8cd 3003 	str.w	r3, [sp, #3]
    7a24:	f01f ff13 	bl	2784e <memcmp>
    7a28:	4b1c      	ldr	r3, [pc, #112]	; (7a9c <bt_le_adv_stop+0xb4>)
    7a2a:	bb60      	cbnz	r0, 7a86 <bt_le_adv_stop+0x9e>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
    7a2c:	4a1c      	ldr	r2, [pc, #112]	; (7aa0 <bt_le_adv_stop+0xb8>)
    7a2e:	8891      	ldrh	r1, [r2, #4]
    7a30:	6810      	ldr	r0, [r2, #0]
    7a32:	7992      	ldrb	r2, [r2, #6]
    7a34:	f8ad 100c 	strh.w	r1, [sp, #12]
    7a38:	f88d 200e 	strb.w	r2, [sp, #14]
    7a3c:	9002      	str	r0, [sp, #8]
    7a3e:	2204      	movs	r2, #4
    7a40:	a902      	add	r1, sp, #8
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
    7a42:	7e18      	ldrb	r0, [r3, #24]
    7a44:	f001 f818 	bl	8a78 <bt_conn_lookup_state_le>
    7a48:	4604      	mov	r4, r0
	if (conn) {
    7a4a:	b130      	cbz	r0, 7a5a <bt_le_adv_stop+0x72>
		conn->err = status;
    7a4c:	2100      	movs	r1, #0
    7a4e:	7241      	strb	r1, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7a50:	f000 fe0e 	bl	8670 <bt_conn_set_state>
		bt_conn_unref(conn);
    7a54:	4620      	mov	r0, r4
    7a56:	f020 fc4a 	bl	282ee <bt_conn_unref>
		err = bt_le_adv_set_enable_legacy(adv, false);
    7a5a:	480d      	ldr	r0, [pc, #52]	; (7a90 <bt_le_adv_stop+0xa8>)
    7a5c:	2100      	movs	r1, #0
    7a5e:	f020 fb93 	bl	28188 <bt_le_adv_set_enable_legacy>
		if (err) {
    7a62:	4604      	mov	r4, r0
    7a64:	2800      	cmp	r0, #0
    7a66:	d1ce      	bne.n	7a06 <bt_le_adv_stop+0x1e>
    7a68:	480e      	ldr	r0, [pc, #56]	; (7aa4 <bt_le_adv_stop+0xbc>)
    7a6a:	f020 fada 	bl	28022 <atomic_get>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    7a6e:	0683      	lsls	r3, r0, #26
    7a70:	d5c8      	bpl.n	7a04 <bt_le_adv_stop+0x1c>
			bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
    7a72:	4620      	mov	r0, r4
    7a74:	f020 fbbf 	bl	281f6 <bt_le_scan_set_enable>
			bt_id_set_private_addr(BT_ID_DEFAULT);
    7a78:	4620      	mov	r0, r4
    7a7a:	f020 fa94 	bl	27fa6 <bt_id_set_private_addr>
			bt_le_scan_set_enable(BT_HCI_LE_SCAN_ENABLE);
    7a7e:	2001      	movs	r0, #1
    7a80:	f020 fbb9 	bl	281f6 <bt_le_scan_set_enable>
    7a84:	e7bf      	b.n	7a06 <bt_le_adv_stop+0x1e>
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
    7a86:	2205      	movs	r2, #5
    7a88:	f103 0121 	add.w	r1, r3, #33	; 0x21
    7a8c:	e7d9      	b.n	7a42 <bt_le_adv_stop+0x5a>
    7a8e:	bf00      	nop
    7a90:	20000098 	.word	0x20000098
    7a94:	200000a8 	.word	0x200000a8
    7a98:	200000a1 	.word	0x200000a1
    7a9c:	20000080 	.word	0x20000080
    7aa0:	0002dd50 	.word	0x0002dd50
    7aa4:	2000014c 	.word	0x2000014c

00007aa8 <adv_timeout>:
}
#endif /* defined(CONFIG_BT_EXT_ADV) */


static void adv_timeout(struct k_work *work)
{
    7aa8:	b500      	push	{lr}
    7aaa:	b089      	sub	sp, #36	; 0x24
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
    7aac:	f7ff ff9c 	bl	79e8 <bt_le_adv_stop>
#endif
	BT_WARN("Failed to stop advertising: %d", err);
    7ab0:	4b07      	ldr	r3, [pc, #28]	; (7ad0 <adv_timeout+0x28>)
    7ab2:	e9cd 3006 	strd	r3, r0, [sp, #24]
    7ab6:	2303      	movs	r3, #3
    7ab8:	9301      	str	r3, [sp, #4]
    7aba:	9305      	str	r3, [sp, #20]
    7abc:	4805      	ldr	r0, [pc, #20]	; (7ad4 <adv_timeout+0x2c>)
    7abe:	2300      	movs	r3, #0
    7ac0:	aa05      	add	r2, sp, #20
    7ac2:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    7ac6:	f01e f907 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
    7aca:	b009      	add	sp, #36	; 0x24
    7acc:	f85d fb04 	ldr.w	pc, [sp], #4
    7ad0:	0002fe30 	.word	0x0002fe30
    7ad4:	0002d9bc 	.word	0x0002d9bc

00007ad8 <bt_le_adv_resume>:
{
    7ad8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7ada:	481e      	ldr	r0, [pc, #120]	; (7b54 <bt_le_adv_resume+0x7c>)
    7adc:	4c1d      	ldr	r4, [pc, #116]	; (7b54 <bt_le_adv_resume+0x7c>)
    7ade:	f020 faa0 	bl	28022 <atomic_get>
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
    7ae2:	f410 5f00 	tst.w	r0, #8192	; 0x2000
    7ae6:	d032      	beq.n	7b4e <bt_le_adv_resume+0x76>
    7ae8:	4620      	mov	r0, r4
    7aea:	f020 fa9a 	bl	28022 <atomic_get>
    7aee:	0642      	lsls	r2, r0, #25
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7af0:	f3c0 1580 	ubfx	r5, r0, #6, #1
    7af4:	d42b      	bmi.n	7b4e <bt_le_adv_resume+0x76>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    7af6:	4620      	mov	r0, r4
    7af8:	f020 fa93 	bl	28022 <atomic_get>
	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
    7afc:	0583      	lsls	r3, r0, #22
    7afe:	d526      	bpl.n	7b4e <bt_le_adv_resume+0x76>
	err = le_adv_start_add_conn(adv, &conn);
    7b00:	a901      	add	r1, sp, #4
    7b02:	f1a4 0010 	sub.w	r0, r4, #16
    7b06:	f7ff fdc1 	bl	768c <le_adv_start_add_conn>
	if (err) {
    7b0a:	bb00      	cbnz	r0, 7b4e <bt_le_adv_resume+0x76>
	return bt_le_adv_set_enable_legacy(adv, enable);
    7b0c:	2101      	movs	r1, #1
    7b0e:	f1a4 0010 	sub.w	r0, r4, #16
    7b12:	f020 fb39 	bl	28188 <bt_le_adv_set_enable_legacy>
	if (err) {
    7b16:	b150      	cbz	r0, 7b2e <bt_le_adv_resume+0x56>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    7b18:	4629      	mov	r1, r5
    7b1a:	9801      	ldr	r0, [sp, #4]
    7b1c:	f000 fda8 	bl	8670 <bt_conn_set_state>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7b20:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
    7b24:	4620      	mov	r0, r4
    7b26:	f020 fa82 	bl	2802e <atomic_and>
	return (old & mask) != 0;
    7b2a:	f3c0 3540 	ubfx	r5, r0, #13, #1
	bt_conn_unref(conn);
    7b2e:	9801      	ldr	r0, [sp, #4]
    7b30:	f020 fbdd 	bl	282ee <bt_conn_unref>
	if (persist_paused) {
    7b34:	b15d      	cbz	r5, 7b4e <bt_le_adv_resume+0x76>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7b36:	f3bf 8f5b 	dmb	ish
    7b3a:	e854 3f00 	ldrex	r3, [r4]
    7b3e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    7b42:	e844 3200 	strex	r2, r3, [r4]
    7b46:	2a00      	cmp	r2, #0
    7b48:	d1f7      	bne.n	7b3a <bt_le_adv_resume+0x62>
    7b4a:	f3bf 8f5b 	dmb	ish
}
    7b4e:	b003      	add	sp, #12
    7b50:	bd30      	pop	{r4, r5, pc}
    7b52:	bf00      	nop
    7b54:	200000a8 	.word	0x200000a8

00007b58 <bt_le_scan_set_enable_legacy>:

	return 0;
}

static int bt_le_scan_set_enable_legacy(uint8_t enable)
{
    7b58:	b530      	push	{r4, r5, lr}
	struct bt_hci_cp_le_set_scan_enable *cp;
	struct bt_hci_cmd_state_set state;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    7b5a:	2102      	movs	r1, #2
{
    7b5c:	b087      	sub	sp, #28
    7b5e:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
    7b60:	f242 000c 	movw	r0, #8204	; 0x200c
    7b64:	f7fe fafc 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    7b68:	4605      	mov	r5, r0
    7b6a:	b318      	cbz	r0, 7bb4 <bt_le_scan_set_enable_legacy+0x5c>
	return net_buf_simple_add(&buf->b, len);
    7b6c:	2102      	movs	r1, #2
    7b6e:	3008      	adds	r0, #8
    7b70:	f024 f8e4 	bl	2bd3c <net_buf_simple_add>
		return -ENOBUFS;
	}

	cp = net_buf_add(buf, sizeof(*cp));

	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    7b74:	2c01      	cmp	r4, #1
    7b76:	d11b      	bne.n	7bb0 <bt_le_scan_set_enable_legacy+0x58>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7b78:	f3bf 8f5b 	dmb	ish
    7b7c:	4b0f      	ldr	r3, [pc, #60]	; (7bbc <bt_le_scan_set_enable_legacy+0x64>)
    7b7e:	681b      	ldr	r3, [r3, #0]
    7b80:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    7b84:	f3c3 2300 	ubfx	r3, r3, #8, #1
		cp->filter_dup = atomic_test_bit(bt_dev.flags,
						 BT_DEV_SCAN_FILTER_DUP);
	} else {
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    7b88:	7043      	strb	r3, [r0, #1]
	}

	cp->enable = enable;

	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_SCANNING,
    7b8a:	1e63      	subs	r3, r4, #1
	cp->enable = enable;
    7b8c:	7004      	strb	r4, [r0, #0]
	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_SCANNING,
    7b8e:	425c      	negs	r4, r3
    7b90:	415c      	adcs	r4, r3
    7b92:	4a0a      	ldr	r2, [pc, #40]	; (7bbc <bt_le_scan_set_enable_legacy+0x64>)
    7b94:	9400      	str	r4, [sp, #0]
    7b96:	a903      	add	r1, sp, #12
    7b98:	4628      	mov	r0, r5
    7b9a:	2305      	movs	r3, #5
    7b9c:	f7fe face 	bl	613c <bt_hci_cmd_state_set_init>
				  enable == BT_HCI_LE_SCAN_ENABLE);

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
    7ba0:	2200      	movs	r2, #0
    7ba2:	4629      	mov	r1, r5
    7ba4:	f242 000c 	movw	r0, #8204	; 0x200c
    7ba8:	f7fe fc36 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
		return err;
	}

	return 0;
}
    7bac:	b007      	add	sp, #28
    7bae:	bd30      	pop	{r4, r5, pc}
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    7bb0:	2300      	movs	r3, #0
    7bb2:	e7e9      	b.n	7b88 <bt_le_scan_set_enable_legacy+0x30>
		return -ENOBUFS;
    7bb4:	f06f 0068 	mvn.w	r0, #104	; 0x68
    7bb8:	e7f8      	b.n	7bac <bt_le_scan_set_enable_legacy+0x54>
    7bba:	bf00      	nop
    7bbc:	2000014c 	.word	0x2000014c

00007bc0 <bt_scan_reset>:
	scan_dev_found_cb = NULL;
    7bc0:	4b01      	ldr	r3, [pc, #4]	; (7bc8 <bt_scan_reset+0x8>)
    7bc2:	2200      	movs	r2, #0
    7bc4:	601a      	str	r2, [r3, #0]
}
    7bc6:	4770      	bx	lr
    7bc8:	2000260c 	.word	0x2000260c

00007bcc <bt_le_scan_update>:
    7bcc:	4b0a      	ldr	r3, [pc, #40]	; (7bf8 <bt_le_scan_update+0x2c>)
    7bce:	f3bf 8f5b 	dmb	ish
    7bd2:	681a      	ldr	r2, [r3, #0]
    7bd4:	f3bf 8f5b 	dmb	ish
	return start_le_scan_legacy(BT_HCI_LE_SCAN_PASSIVE, interval, window);
}

int bt_le_scan_update(bool fast_scan)
{
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    7bd8:	f3c2 1080 	ubfx	r0, r2, #6, #1
    7bdc:	0652      	lsls	r2, r2, #25
    7bde:	d408      	bmi.n	7bf2 <bt_le_scan_update+0x26>
    7be0:	f3bf 8f5b 	dmb	ish
    7be4:	681b      	ldr	r3, [r3, #0]
    7be6:	f3bf 8f5b 	dmb	ish
		return 0;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    7bea:	069b      	lsls	r3, r3, #26
    7bec:	d501      	bpl.n	7bf2 <bt_le_scan_update+0x26>
	return bt_le_scan_set_enable_legacy(enable);
    7bee:	f7ff bfb3 	b.w	7b58 <bt_le_scan_set_enable_legacy>
		return start_passive_scan(fast_scan);
	}
#endif

	return 0;
}
    7bf2:	2000      	movs	r0, #0
    7bf4:	4770      	bx	lr
    7bf6:	bf00      	nop
    7bf8:	2000014c 	.word	0x2000014c

00007bfc <bt_hci_le_adv_report>:
#endif /* CONFIG_BT_DF_CONNECTIONLESS_CTE_RX */
#endif /* defined(CONFIG_BT_PER_ADV_SYNC) */
#endif /* defined(CONFIG_BT_EXT_ADV) */

void bt_hci_le_adv_report(struct net_buf *buf)
{
    7bfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @return The 8-bit removed value
 */
static inline uint8_t net_buf_pull_u8(struct net_buf *buf)
{
	return net_buf_simple_pull_u8(&buf->b);
    7c00:	f100 0808 	add.w	r8, r0, #8
    7c04:	b08d      	sub	sp, #52	; 0x34
    7c06:	4604      	mov	r4, r0
    7c08:	4640      	mov	r0, r8
    7c0a:	f024 f917 	bl	2be3c <net_buf_simple_pull_u8>
	if (scan_dev_found_cb) {
    7c0e:	f8df b15c 	ldr.w	fp, [pc, #348]	; 7d6c <bt_hci_le_adv_report+0x170>
    7c12:	4606      	mov	r6, r0
	uint8_t num_reports = net_buf_pull_u8(buf);
	struct bt_hci_evt_le_advertising_info *evt;

	BT_DBG("Adv number of reports %u",  num_reports);

	while (num_reports--) {
    7c14:	b176      	cbz	r6, 7c34 <bt_hci_le_adv_report+0x38>
		struct bt_le_scan_recv_info adv_info;

		if (buf->len < sizeof(*evt)) {
    7c16:	89a3      	ldrh	r3, [r4, #12]
    7c18:	2b08      	cmp	r3, #8
    7c1a:	d80e      	bhi.n	7c3a <bt_hci_le_adv_report+0x3e>
			BT_ERR("Unexpected end of buffer");
    7c1c:	4b54      	ldr	r3, [pc, #336]	; (7d70 <bt_hci_le_adv_report+0x174>)
    7c1e:	930a      	str	r3, [sp, #40]	; 0x28
    7c20:	2302      	movs	r3, #2
    7c22:	9304      	str	r3, [sp, #16]
    7c24:	9309      	str	r3, [sp, #36]	; 0x24
    7c26:	4853      	ldr	r0, [pc, #332]	; (7d74 <bt_hci_le_adv_report+0x178>)
    7c28:	2300      	movs	r3, #0
    7c2a:	aa09      	add	r2, sp, #36	; 0x24
    7c2c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    7c30:	f01e f852 	bl	25cd8 <z_impl_z_log_msg2_static_create>

		le_adv_recv(&evt->addr, &adv_info, &buf->b, evt->length);

		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
	}
}
    7c34:	b00d      	add	sp, #52	; 0x34
    7c36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
    7c3a:	2109      	movs	r1, #9
    7c3c:	4640      	mov	r0, r8
    7c3e:	f024 f8f5 	bl	2be2c <net_buf_simple_pull_mem>
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    7c42:	237f      	movs	r3, #127	; 0x7f
    7c44:	f88d 301e 	strb.w	r3, [sp, #30]
		adv_info.rssi = evt->data[evt->length];
    7c48:	f890 9008 	ldrb.w	r9, [r0, #8]
    7c4c:	eb00 0309 	add.w	r3, r0, r9
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    7c50:	2201      	movs	r2, #1
		adv_info.rssi = evt->data[evt->length];
    7c52:	7a5b      	ldrb	r3, [r3, #9]
    7c54:	f88d 301d 	strb.w	r3, [sp, #29]
		adv_info.sid = BT_GAP_SID_INVALID;
    7c58:	23ff      	movs	r3, #255	; 0xff
    7c5a:	f88d 301c 	strb.w	r3, [sp, #28]
		adv_info.interval = 0U;
    7c5e:	2300      	movs	r3, #0
    7c60:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    7c64:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
		adv_info.adv_type = evt->evt_type;
    7c68:	7802      	ldrb	r2, [r0, #0]
    7c6a:	f88d 201f 	strb.w	r2, [sp, #31]
    7c6e:	2a04      	cmp	r2, #4
    7c70:	bf9c      	itt	ls
    7c72:	4b41      	ldrls	r3, [pc, #260]	; (7d78 <bt_hci_le_adv_report+0x17c>)
    7c74:	5c9b      	ldrbls	r3, [r3, r2]
		adv_info.adv_props = get_adv_props_legacy(evt->evt_type);
    7c76:	f8ad 3020 	strh.w	r3, [sp, #32]
    7c7a:	4b40      	ldr	r3, [pc, #256]	; (7d7c <bt_hci_le_adv_report+0x180>)
    7c7c:	f3bf 8f5b 	dmb	ish
    7c80:	681b      	ldr	r3, [r3, #0]
    7c82:	f3bf 8f5b 	dmb	ish
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    7c86:	065a      	lsls	r2, r3, #25
    7c88:	4605      	mov	r5, r0
		le_adv_recv(&evt->addr, &adv_info, &buf->b, evt->length);
    7c8a:	f100 0101 	add.w	r1, r0, #1
    7c8e:	fa1f f989 	uxth.w	r9, r9
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) &&
    7c92:	d50b      	bpl.n	7cac <bt_hci_le_adv_report+0xb0>
	    atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN) &&
    7c94:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    7c98:	075b      	lsls	r3, r3, #29
    7c9a:	d507      	bpl.n	7cac <bt_hci_le_adv_report+0xb0>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
    7c9c:	7a29      	ldrb	r1, [r5, #8]
	return net_buf_simple_pull(&buf->b, len);
    7c9e:	4640      	mov	r0, r8
    7ca0:	3101      	adds	r1, #1
    7ca2:	3e01      	subs	r6, #1
    7ca4:	f024 f8ba 	bl	2be1c <net_buf_simple_pull>
    7ca8:	b2f6      	uxtb	r6, r6
    7caa:	e7b3      	b.n	7c14 <bt_hci_le_adv_report+0x18>
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    7cac:	786b      	ldrb	r3, [r5, #1]
    7cae:	1e9a      	subs	r2, r3, #2
    7cb0:	2a01      	cmp	r2, #1
    7cb2:	d848      	bhi.n	7d46 <bt_hci_le_adv_report+0x14a>
	memcpy(dst, src, sizeof(*dst));
    7cb4:	2207      	movs	r2, #7
    7cb6:	a802      	add	r0, sp, #8
    7cb8:	f01f fdda 	bl	27870 <memcpy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    7cbc:	f89d 3008 	ldrb.w	r3, [sp, #8]
    7cc0:	3b02      	subs	r3, #2
    7cc2:	f88d 3008 	strb.w	r3, [sp, #8]
	info->addr = &id_addr;
    7cc6:	ab02      	add	r3, sp, #8
    7cc8:	9306      	str	r3, [sp, #24]
	if (scan_dev_found_cb) {
    7cca:	f8db 3000 	ldr.w	r3, [fp]
    7cce:	b1a3      	cbz	r3, 7cfa <bt_hci_le_adv_report+0xfe>
	state->offset = net_buf_simple_headroom(buf);
    7cd0:	4640      	mov	r0, r8
    7cd2:	f024 f8d6 	bl	2be82 <net_buf_simple_headroom>
	state->len = buf->len;
    7cd6:	89a7      	ldrh	r7, [r4, #12]
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type, buf);
    7cd8:	f89d 201f 	ldrb.w	r2, [sp, #31]
    7cdc:	f99d 101d 	ldrsb.w	r1, [sp, #29]
    7ce0:	f8db c000 	ldr.w	ip, [fp]
		buf->len = len;
    7ce4:	f8a4 900c 	strh.w	r9, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    7ce8:	4682      	mov	sl, r0
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type, buf);
    7cea:	4643      	mov	r3, r8
    7cec:	a802      	add	r0, sp, #8
    7cee:	47e0      	blx	ip
	buf->data = buf->__buf + state->offset;
    7cf0:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    7cf2:	81a7      	strh	r7, [r4, #12]
	buf->data = buf->__buf + state->offset;
    7cf4:	fa10 f08a 	uxtah	r0, r0, sl
    7cf8:	60a0      	str	r0, [r4, #8]
	return list->head;
    7cfa:	4b21      	ldr	r3, [pc, #132]	; (7d80 <bt_hci_le_adv_report+0x184>)
    7cfc:	681a      	ldr	r2, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    7cfe:	2a00      	cmp	r2, #0
    7d00:	d0cc      	beq.n	7c9c <bt_hci_le_adv_report+0xa0>
	return node->next;
    7d02:	f852 7908 	ldr.w	r7, [r2], #-8
    7d06:	b107      	cbz	r7, 7d0a <bt_hci_le_adv_report+0x10e>
    7d08:	3f08      	subs	r7, #8
		if (listener->recv) {
    7d0a:	6813      	ldr	r3, [r2, #0]
    7d0c:	9201      	str	r2, [sp, #4]
    7d0e:	b193      	cbz	r3, 7d36 <bt_hci_le_adv_report+0x13a>
	state->offset = net_buf_simple_headroom(buf);
    7d10:	4640      	mov	r0, r8
    7d12:	f024 f8b6 	bl	2be82 <net_buf_simple_headroom>
			listener->recv(info, buf);
    7d16:	9a01      	ldr	r2, [sp, #4]
	state->len = buf->len;
    7d18:	89a3      	ldrh	r3, [r4, #12]
    7d1a:	6812      	ldr	r2, [r2, #0]
			buf->len = len;
    7d1c:	f8a4 900c 	strh.w	r9, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    7d20:	4682      	mov	sl, r0
			listener->recv(info, buf);
    7d22:	4641      	mov	r1, r8
    7d24:	a806      	add	r0, sp, #24
	state->len = buf->len;
    7d26:	9300      	str	r3, [sp, #0]
    7d28:	4790      	blx	r2
	buf->data = buf->__buf + state->offset;
    7d2a:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    7d2c:	9b00      	ldr	r3, [sp, #0]
    7d2e:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf + state->offset;
    7d30:	fa10 f08a 	uxtah	r0, r0, sl
    7d34:	60a0      	str	r0, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    7d36:	2f00      	cmp	r7, #0
    7d38:	d0b0      	beq.n	7c9c <bt_hci_le_adv_report+0xa0>
    7d3a:	68bb      	ldr	r3, [r7, #8]
    7d3c:	b103      	cbz	r3, 7d40 <bt_hci_le_adv_report+0x144>
    7d3e:	3b08      	subs	r3, #8
		adv_info.adv_type = evt->evt_type;
    7d40:	463a      	mov	r2, r7
    7d42:	461f      	mov	r7, r3
    7d44:	e7e1      	b.n	7d0a <bt_hci_le_adv_report+0x10e>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
    7d46:	2bff      	cmp	r3, #255	; 0xff
    7d48:	d109      	bne.n	7d5e <bt_hci_le_adv_report+0x162>
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    7d4a:	2300      	movs	r3, #0
    7d4c:	9304      	str	r3, [sp, #16]
    7d4e:	2207      	movs	r2, #7
    7d50:	f8cd 3013 	str.w	r3, [sp, #19]
    7d54:	a904      	add	r1, sp, #16
    7d56:	a802      	add	r0, sp, #8
    7d58:	f01f fd8a 	bl	27870 <memcpy>
}
    7d5c:	e7b3      	b.n	7cc6 <bt_hci_le_adv_report+0xca>
		bt_addr_le_copy(&id_addr,
    7d5e:	2000      	movs	r0, #0
    7d60:	f020 f91f 	bl	27fa2 <bt_lookup_id_addr>
	memcpy(dst, src, sizeof(*dst));
    7d64:	2207      	movs	r2, #7
    7d66:	4601      	mov	r1, r0
    7d68:	e7f5      	b.n	7d56 <bt_hci_le_adv_report+0x15a>
    7d6a:	bf00      	nop
    7d6c:	2000260c 	.word	0x2000260c
    7d70:	0002fe56 	.word	0x0002fe56
    7d74:	0002db94 	.word	0x0002db94
    7d78:	0002fe77 	.word	0x0002fe77
    7d7c:	2000014c 	.word	0x2000014c
    7d80:	20002604 	.word	0x20002604

00007d84 <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
    7d84:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7d88:	4c62      	ldr	r4, [pc, #392]	; (7f14 <bt_le_scan_start+0x190>)
    7d8a:	f3bf 8f5b 	dmb	ish
    7d8e:	6823      	ldr	r3, [r4, #0]
    7d90:	f3bf 8f5b 	dmb	ish
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7d94:	f013 0f02 	tst.w	r3, #2
{
    7d98:	4605      	mov	r5, r0
    7d9a:	460f      	mov	r7, r1
    7d9c:	4626      	mov	r6, r4
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    7d9e:	f000 80b6 	beq.w	7f0e <bt_le_scan_start+0x18a>
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
    7da2:	7802      	ldrb	r2, [r0, #0]
    7da4:	2a01      	cmp	r2, #1
    7da6:	d905      	bls.n	7db4 <bt_le_scan_start+0x30>
		return -EAGAIN;
	}

	/* Check that the parameters have valid values */
	if (!valid_le_scan_param(param)) {
		return -EINVAL;
    7da8:	f06f 0415 	mvn.w	r4, #21
	}

	scan_dev_found_cb = cb;

	return 0;
}
    7dac:	4620      	mov	r0, r4
    7dae:	b003      	add	sp, #12
    7db0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (param->options & ~(BT_LE_SCAN_OPT_FILTER_DUPLICATE |
    7db4:	6843      	ldr	r3, [r0, #4]
    7db6:	f033 030f 	bics.w	r3, r3, #15
    7dba:	d1f5      	bne.n	7da8 <bt_le_scan_start+0x24>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
    7dbc:	8900      	ldrh	r0, [r0, #8]
    7dbe:	1f03      	subs	r3, r0, #4
    7dc0:	b29b      	uxth	r3, r3
    7dc2:	f643 7cfc 	movw	ip, #16380	; 0x3ffc
    7dc6:	4563      	cmp	r3, ip
    7dc8:	d8ee      	bhi.n	7da8 <bt_le_scan_start+0x24>
	if (param->window < 0x0004 || param->window > 0x4000) {
    7dca:	8969      	ldrh	r1, [r5, #10]
    7dcc:	1f0b      	subs	r3, r1, #4
    7dce:	b29b      	uxth	r3, r3
    7dd0:	4563      	cmp	r3, ip
    7dd2:	d8e9      	bhi.n	7da8 <bt_le_scan_start+0x24>
	if (param->window > param->interval) {
    7dd4:	4288      	cmp	r0, r1
    7dd6:	d3e7      	bcc.n	7da8 <bt_le_scan_start+0x24>
	if (param->type && !bt_id_scan_random_addr_check()) {
    7dd8:	b98a      	cbnz	r2, 7dfe <bt_le_scan_start+0x7a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7dda:	f3bf 8f5b 	dmb	ish
    7dde:	e856 0f00 	ldrex	r0, [r6]
    7de2:	f040 0340 	orr.w	r3, r0, #64	; 0x40
    7de6:	e846 3200 	strex	r2, r3, [r6]
    7dea:	2a00      	cmp	r2, #0
    7dec:	d1f7      	bne.n	7dde <bt_le_scan_start+0x5a>
    7dee:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    7df2:	f010 0040 	ands.w	r0, r0, #64	; 0x40
    7df6:	d007      	beq.n	7e08 <bt_le_scan_start+0x84>
		return -EALREADY;
    7df8:	f06f 0477 	mvn.w	r4, #119	; 0x77
    7dfc:	e7d6      	b.n	7dac <bt_le_scan_start+0x28>
	if (param->type && !bt_id_scan_random_addr_check()) {
    7dfe:	f020 f8f6 	bl	27fee <bt_id_scan_random_addr_check>
    7e02:	2800      	cmp	r0, #0
    7e04:	d1e9      	bne.n	7dda <bt_le_scan_start+0x56>
    7e06:	e7cf      	b.n	7da8 <bt_le_scan_start+0x24>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    7e08:	f3bf 8f5b 	dmb	ish
    7e0c:	6823      	ldr	r3, [r4, #0]
    7e0e:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    7e12:	0699      	lsls	r1, r3, #26
    7e14:	d509      	bpl.n	7e2a <bt_le_scan_start+0xa6>
	return bt_le_scan_set_enable_legacy(enable);
    7e16:	f7ff fe9f 	bl	7b58 <bt_le_scan_set_enable_legacy>
		if (err) {
    7e1a:	4604      	mov	r4, r0
    7e1c:	b128      	cbz	r0, 7e2a <bt_le_scan_start+0xa6>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7e1e:	f06f 0140 	mvn.w	r1, #64	; 0x40
    7e22:	483c      	ldr	r0, [pc, #240]	; (7f14 <bt_le_scan_start+0x190>)
    7e24:	f020 f9d8 	bl	281d8 <atomic_and>
		return err;
    7e28:	e7c0      	b.n	7dac <bt_le_scan_start+0x28>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
    7e2a:	686b      	ldr	r3, [r5, #4]
	if (val) {
    7e2c:	07da      	lsls	r2, r3, #31
    7e2e:	d515      	bpl.n	7e5c <bt_le_scan_start+0xd8>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7e30:	f3bf 8f5b 	dmb	ish
    7e34:	e856 3f00 	ldrex	r3, [r6]
    7e38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    7e3c:	e846 3200 	strex	r2, r3, [r6]
    7e40:	2a00      	cmp	r2, #0
    7e42:	d1f7      	bne.n	7e34 <bt_le_scan_start+0xb0>
    7e44:	f3bf 8f5b 	dmb	ish
		if (param->timeout) {
    7e48:	89ac      	ldrh	r4, [r5, #12]
    7e4a:	b16c      	cbz	r4, 7e68 <bt_le_scan_start+0xe4>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7e4c:	4831      	ldr	r0, [pc, #196]	; (7f14 <bt_le_scan_start+0x190>)
    7e4e:	f06f 0140 	mvn.w	r1, #64	; 0x40
    7e52:	f020 f9c1 	bl	281d8 <atomic_and>
			return -ENOTSUP;
    7e56:	f06f 0485 	mvn.w	r4, #133	; 0x85
    7e5a:	e7a7      	b.n	7dac <bt_le_scan_start+0x28>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7e5c:	f46f 7180 	mvn.w	r1, #256	; 0x100
    7e60:	482c      	ldr	r0, [pc, #176]	; (7f14 <bt_le_scan_start+0x190>)
    7e62:	f020 f9b9 	bl	281d8 <atomic_and>
    7e66:	e7ef      	b.n	7e48 <bt_le_scan_start+0xc4>
		err = start_le_scan_legacy(param->type, param->interval,
    7e68:	f895 8000 	ldrb.w	r8, [r5]
    7e6c:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    7e70:	896d      	ldrh	r5, [r5, #10]
	(void)memset(&set_param, 0, sizeof(set_param));
    7e72:	4621      	mov	r1, r4
    7e74:	2207      	movs	r2, #7
    7e76:	4668      	mov	r0, sp
    7e78:	f01f fd05 	bl	27886 <memset>
	err = bt_id_set_scan_own_addr(active_scan, &set_param.addr_type);
    7e7c:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    7e80:	4258      	negs	r0, r3
    7e82:	f10d 0105 	add.w	r1, sp, #5
    7e86:	4158      	adcs	r0, r3
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_BASIC_NO_FILTER;
    7e88:	f88d 4006 	strb.w	r4, [sp, #6]
	set_param.scan_type = scan_type;
    7e8c:	f88d 8000 	strb.w	r8, [sp]
	set_param.interval = sys_cpu_to_le16(interval);
    7e90:	f8ad 9001 	strh.w	r9, [sp, #1]
	set_param.window = sys_cpu_to_le16(window);
    7e94:	f8ad 5003 	strh.w	r5, [sp, #3]
	err = bt_id_set_scan_own_addr(active_scan, &set_param.addr_type);
    7e98:	f7ff faac 	bl	73f4 <bt_id_set_scan_own_addr>
	if (err) {
    7e9c:	4604      	mov	r4, r0
    7e9e:	2800      	cmp	r0, #0
    7ea0:	d1bd      	bne.n	7e1e <bt_le_scan_start+0x9a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
    7ea2:	2107      	movs	r1, #7
    7ea4:	f242 000b 	movw	r0, #8203	; 0x200b
    7ea8:	f7fe f95a 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    7eac:	4605      	mov	r5, r0
    7eae:	b358      	cbz	r0, 7f08 <bt_le_scan_start+0x184>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    7eb0:	2207      	movs	r2, #7
    7eb2:	4669      	mov	r1, sp
    7eb4:	3008      	adds	r0, #8
    7eb6:	f023 ff47 	bl	2bd48 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_PARAM, buf, NULL);
    7eba:	4622      	mov	r2, r4
    7ebc:	4629      	mov	r1, r5
    7ebe:	f242 000b 	movw	r0, #8203	; 0x200b
    7ec2:	f7fe faa9 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    7ec6:	4604      	mov	r4, r0
    7ec8:	2800      	cmp	r0, #0
    7eca:	d1a8      	bne.n	7e1e <bt_le_scan_start+0x9a>
	return bt_le_scan_set_enable_legacy(enable);
    7ecc:	2001      	movs	r0, #1
    7ece:	f7ff fe43 	bl	7b58 <bt_le_scan_set_enable_legacy>
	if (err) {
    7ed2:	4604      	mov	r4, r0
    7ed4:	2800      	cmp	r0, #0
    7ed6:	d1a2      	bne.n	7e1e <bt_le_scan_start+0x9a>
	if (val) {
    7ed8:	f1b8 0f01 	cmp.w	r8, #1
    7edc:	d10e      	bne.n	7efc <bt_le_scan_start+0x178>
    7ede:	f3bf 8f5b 	dmb	ish
    7ee2:	e856 3f00 	ldrex	r3, [r6]
    7ee6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7eea:	e846 3200 	strex	r2, r3, [r6]
    7eee:	2a00      	cmp	r2, #0
    7ef0:	d1f7      	bne.n	7ee2 <bt_le_scan_start+0x15e>
    7ef2:	f3bf 8f5b 	dmb	ish
	scan_dev_found_cb = cb;
    7ef6:	4b08      	ldr	r3, [pc, #32]	; (7f18 <bt_le_scan_start+0x194>)
    7ef8:	601f      	str	r7, [r3, #0]
	return 0;
    7efa:	e757      	b.n	7dac <bt_le_scan_start+0x28>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7efc:	f06f 0180 	mvn.w	r1, #128	; 0x80
    7f00:	4804      	ldr	r0, [pc, #16]	; (7f14 <bt_le_scan_start+0x190>)
    7f02:	f020 f969 	bl	281d8 <atomic_and>
	if (err) {
    7f06:	e7f6      	b.n	7ef6 <bt_le_scan_start+0x172>
		return -ENOBUFS;
    7f08:	f06f 0468 	mvn.w	r4, #104	; 0x68
    7f0c:	e787      	b.n	7e1e <bt_le_scan_start+0x9a>
		return -EAGAIN;
    7f0e:	f06f 040a 	mvn.w	r4, #10
    7f12:	e74b      	b.n	7dac <bt_le_scan_start+0x28>
    7f14:	2000014c 	.word	0x2000014c
    7f18:	2000260c 	.word	0x2000260c

00007f1c <bt_le_scan_stop>:

int bt_le_scan_stop(void)
{
    7f1c:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    7f1e:	4808      	ldr	r0, [pc, #32]	; (7f40 <bt_le_scan_stop+0x24>)
    7f20:	f06f 0140 	mvn.w	r1, #64	; 0x40
    7f24:	f020 f958 	bl	281d8 <atomic_and>
	/* Return if active scanning is already disabled */
	if (!atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    7f28:	0643      	lsls	r3, r0, #25
    7f2a:	d506      	bpl.n	7f3a <bt_le_scan_stop+0x1e>
	scan_dev_found_cb = NULL;
    7f2c:	4b05      	ldr	r3, [pc, #20]	; (7f44 <bt_le_scan_stop+0x28>)
    7f2e:	2000      	movs	r0, #0
    7f30:	6018      	str	r0, [r3, #0]
		bt_id_pending_keys_update();
#endif
	}

	return bt_le_scan_update(false);
}
    7f32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_le_scan_update(false);
    7f36:	f7ff be49 	b.w	7bcc <bt_le_scan_update>
}
    7f3a:	f06f 0077 	mvn.w	r0, #119	; 0x77
    7f3e:	bd08      	pop	{r3, pc}
    7f40:	2000014c 	.word	0x2000014c
    7f44:	2000260c 	.word	0x2000260c

00007f48 <bt_pub_key_gen>:
{
	return memcmp(pub_key, debug_public_key, BT_PUB_KEY_LEN) == 0;
}

int bt_pub_key_gen(struct bt_pub_key_cb *new_cb)
{
    7f48:	b5f0      	push	{r4, r5, r6, r7, lr}
	 * We check for both "LE Read Local P-256 Public Key" and
	 * "LE Generate DH Key" support here since both commands are needed for
	 * ECC support. If "LE Generate DH Key" is not supported then there
	 * is no point in reading local public key.
	 */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
    7f4a:	4b45      	ldr	r3, [pc, #276]	; (8060 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x60>)
    7f4c:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
    7f50:	f003 0306 	and.w	r3, r3, #6
    7f54:	2b06      	cmp	r3, #6
{
    7f56:	b089      	sub	sp, #36	; 0x24
	if (!BT_CMD_TEST(bt_dev.supported_commands, 34, 1) ||
    7f58:	d010      	beq.n	7f7c <bt_pub_key_gen+0x34>
	    !BT_CMD_TEST(bt_dev.supported_commands, 34, 2)) {
		BT_WARN("ECC HCI commands not available");
    7f5a:	4b42      	ldr	r3, [pc, #264]	; (8064 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x64>)
    7f5c:	9306      	str	r3, [sp, #24]
    7f5e:	2302      	movs	r3, #2
    7f60:	9301      	str	r3, [sp, #4]
    7f62:	9305      	str	r3, [sp, #20]
    7f64:	4840      	ldr	r0, [pc, #256]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    7f66:	2300      	movs	r3, #0
    7f68:	aa05      	add	r2, sp, #20
    7f6a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return -ENOTSUP;
    7f6e:	f06f 0585 	mvn.w	r5, #133	; 0x85
    7f72:	f01d feb1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		sys_slist_init(&pub_key_cb_slist);
		return err;
	}

	return 0;
}
    7f76:	4628      	mov	r0, r5
    7f78:	b009      	add	sp, #36	; 0x24
    7f7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!new_cb) {
    7f7c:	2800      	cmp	r0, #0
    7f7e:	d06b      	beq.n	8058 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x58>
	return list->head;
    7f80:	4e3a      	ldr	r6, [pc, #232]	; (806c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x6c>)
    7f82:	6832      	ldr	r2, [r6, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    7f84:	b1aa      	cbz	r2, 7fb2 <bt_pub_key_gen+0x6a>
    7f86:	1f13      	subs	r3, r2, #4
		if (cb == new_cb) {
    7f88:	4298      	cmp	r0, r3
    7f8a:	d10e      	bne.n	7faa <bt_pub_key_gen+0x62>
			BT_WARN("Callback already registered");
    7f8c:	4b38      	ldr	r3, [pc, #224]	; (8070 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x70>)
    7f8e:	9306      	str	r3, [sp, #24]
    7f90:	2302      	movs	r3, #2
    7f92:	9301      	str	r3, [sp, #4]
    7f94:	9305      	str	r3, [sp, #20]
    7f96:	4834      	ldr	r0, [pc, #208]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    7f98:	2300      	movs	r3, #0
    7f9a:	aa05      	add	r2, sp, #20
    7f9c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    7fa0:	f01d fe9a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return -EALREADY;
    7fa4:	f06f 0577 	mvn.w	r5, #119	; 0x77
    7fa8:	e7e5      	b.n	7f76 <bt_pub_key_gen+0x2e>
	return node->next;
    7faa:	685b      	ldr	r3, [r3, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    7fac:	b10b      	cbz	r3, 7fb2 <bt_pub_key_gen+0x6a>
    7fae:	3b04      	subs	r3, #4
    7fb0:	e7ea      	b.n	7f88 <bt_pub_key_gen+0x40>
	parent->next = child;
    7fb2:	6042      	str	r2, [r0, #4]
Z_GENLIST_PREPEND(slist, snode)
    7fb4:	6872      	ldr	r2, [r6, #4]
	sys_slist_prepend(&pub_key_cb_slist, &new_cb->node);
    7fb6:	1d03      	adds	r3, r0, #4
	list->head = node;
    7fb8:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
    7fba:	b902      	cbnz	r2, 7fbe <bt_pub_key_gen+0x76>
	list->tail = node;
    7fbc:	6073      	str	r3, [r6, #4]
    7fbe:	4c2d      	ldr	r4, [pc, #180]	; (8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>)
    7fc0:	f3bf 8f5b 	dmb	ish
    7fc4:	e854 7f00 	ldrex	r7, [r4]
    7fc8:	f047 0310 	orr.w	r3, r7, #16
    7fcc:	e844 3200 	strex	r2, r3, [r4]
    7fd0:	2a00      	cmp	r2, #0
    7fd2:	d1f7      	bne.n	7fc4 <bt_pub_key_gen+0x7c>
    7fd4:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    7fd8:	f017 0710 	ands.w	r7, r7, #16
    7fdc:	d001      	beq.n	7fe2 <bt_pub_key_gen+0x9a>
		return 0;
    7fde:	2500      	movs	r5, #0
    7fe0:	e7c9      	b.n	7f76 <bt_pub_key_gen+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    7fe2:	f3bf 8f5b 	dmb	ish
    7fe6:	e854 3f00 	ldrex	r3, [r4]
    7fea:	f023 0308 	bic.w	r3, r3, #8
    7fee:	e844 3200 	strex	r2, r3, [r4]
    7ff2:	2a00      	cmp	r2, #0
    7ff4:	d1f7      	bne.n	7fe6 <bt_pub_key_gen+0x9e>
    7ff6:	f3bf 8f5b 	dmb	ish
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_P256_PUBLIC_KEY, NULL, NULL);
    7ffa:	463a      	mov	r2, r7
    7ffc:	4639      	mov	r1, r7
    7ffe:	f242 0025 	movw	r0, #8229	; 0x2025
    8002:	f7fe fa09 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    8006:	4605      	mov	r5, r0
    8008:	2800      	cmp	r0, #0
    800a:	d0e8      	beq.n	7fde <bt_pub_key_gen+0x96>
		BT_ERR("Sending LE P256 Public Key command failed");
    800c:	4b1a      	ldr	r3, [pc, #104]	; (8078 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x78>)
    800e:	9306      	str	r3, [sp, #24]
    8010:	2302      	movs	r3, #2
    8012:	9301      	str	r3, [sp, #4]
    8014:	9305      	str	r3, [sp, #20]
    8016:	4814      	ldr	r0, [pc, #80]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    8018:	463b      	mov	r3, r7
    801a:	aa05      	add	r2, sp, #20
    801c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    8020:	f01d fe5a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
    8024:	f3bf 8f5b 	dmb	ish
    8028:	e854 3f00 	ldrex	r3, [r4]
    802c:	f023 0310 	bic.w	r3, r3, #16
    8030:	e844 3200 	strex	r2, r3, [r4]
    8034:	2a00      	cmp	r2, #0
    8036:	d1f7      	bne.n	8028 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28>
    8038:	f3bf 8f5b 	dmb	ish
	return list->head;
    803c:	6834      	ldr	r4, [r6, #0]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    803e:	b13c      	cbz	r4, 8050 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x50>
			if (cb->func) {
    8040:	f854 3c04 	ldr.w	r3, [r4, #-4]
		SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    8044:	3c04      	subs	r4, #4
			if (cb->func) {
    8046:	b10b      	cbz	r3, 804c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4c>
				cb->func(NULL);
    8048:	2000      	movs	r0, #0
    804a:	4798      	blx	r3
	return node->next;
    804c:	6864      	ldr	r4, [r4, #4]
    804e:	e7f6      	b.n	803e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3e>
	list->head = NULL;
    8050:	2300      	movs	r3, #0
	list->tail = NULL;
    8052:	e9c6 3300 	strd	r3, r3, [r6]
		return err;
    8056:	e78e      	b.n	7f76 <bt_pub_key_gen+0x2e>
		return -EINVAL;
    8058:	f06f 0515 	mvn.w	r5, #21
    805c:	e78b      	b.n	7f76 <bt_pub_key_gen+0x2e>
    805e:	bf00      	nop
    8060:	20000080 	.word	0x20000080
    8064:	0002fe7c 	.word	0x0002fe7c
    8068:	0002da9c 	.word	0x0002da9c
    806c:	20002614 	.word	0x20002614
    8070:	0002fe9b 	.word	0x0002fe9b
    8074:	2000014c 	.word	0x2000014c
    8078:	0002feb7 	.word	0x0002feb7

0000807c <bt_pub_key_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    807c:	4b05      	ldr	r3, [pc, #20]	; (8094 <bt_pub_key_get+0x18>)
    807e:	f3bf 8f5b 	dmb	ish
    8082:	681b      	ldr	r3, [r3, #0]
	if (atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
		return pub_key;
	}

	return NULL;
}
    8084:	4804      	ldr	r0, [pc, #16]	; (8098 <bt_pub_key_get+0x1c>)
    8086:	f3bf 8f5b 	dmb	ish
		return pub_key;
    808a:	f013 0f08 	tst.w	r3, #8
}
    808e:	bf08      	it	eq
    8090:	2000      	moveq	r0, #0
    8092:	4770      	bx	lr
    8094:	2000014c 	.word	0x2000014c
    8098:	20003aa9 	.word	0x20003aa9

0000809c <bt_dh_key_gen>:

	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY_V2, buf, NULL);
}

int bt_dh_key_gen(const uint8_t remote_pk[BT_PUB_KEY_LEN], bt_dh_key_cb_t cb)
{
    809c:	b5f0      	push	{r4, r5, r6, r7, lr}
	int err;

	if (dh_key_cb == cb) {
    809e:	4d27      	ldr	r5, [pc, #156]	; (813c <bt_dh_key_gen+0xa0>)
    80a0:	682b      	ldr	r3, [r5, #0]
    80a2:	428b      	cmp	r3, r1
{
    80a4:	b089      	sub	sp, #36	; 0x24
    80a6:	4606      	mov	r6, r0
	if (dh_key_cb == cb) {
    80a8:	d041      	beq.n	812e <bt_dh_key_gen+0x92>
		return -EALREADY;
	}

	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    80aa:	b123      	cbz	r3, 80b6 <bt_dh_key_gen+0x1a>
		return -EBUSY;
    80ac:	f06f 040f 	mvn.w	r4, #15
		BT_WARN("Failed to generate DHKey (err %d)", err);
		return err;
	}

	return 0;
}
    80b0:	4620      	mov	r0, r4
    80b2:	b009      	add	sp, #36	; 0x24
    80b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    80b6:	4b22      	ldr	r3, [pc, #136]	; (8140 <bt_dh_key_gen+0xa4>)
    80b8:	f3bf 8f5b 	dmb	ish
    80bc:	681a      	ldr	r2, [r3, #0]
    80be:	f3bf 8f5b 	dmb	ish
	if (dh_key_cb || atomic_test_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY)) {
    80c2:	f3c2 1700 	ubfx	r7, r2, #4, #1
    80c6:	06d2      	lsls	r2, r2, #27
    80c8:	d4f0      	bmi.n	80ac <bt_dh_key_gen+0x10>
    80ca:	f3bf 8f5b 	dmb	ish
    80ce:	681b      	ldr	r3, [r3, #0]
    80d0:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY)) {
    80d4:	071b      	lsls	r3, r3, #28
    80d6:	d52d      	bpl.n	8134 <bt_dh_key_gen+0x98>
	dh_key_cb = cb;
    80d8:	6029      	str	r1, [r5, #0]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_GENERATE_DHKEY, sizeof(*cp));
    80da:	f242 0026 	movw	r0, #8230	; 0x2026
    80de:	2140      	movs	r1, #64	; 0x40
    80e0:	f7fe f83e 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
    80e4:	4604      	mov	r4, r0
    80e6:	b1f8      	cbz	r0, 8128 <bt_dh_key_gen+0x8c>
	return net_buf_simple_add(&buf->b, len);
    80e8:	2140      	movs	r1, #64	; 0x40
    80ea:	3008      	adds	r0, #8
    80ec:	f023 fe26 	bl	2bd3c <net_buf_simple_add>
	memcpy(cp->key, remote_pk, sizeof(cp->key));
    80f0:	2240      	movs	r2, #64	; 0x40
    80f2:	4631      	mov	r1, r6
    80f4:	f01f fbbc 	bl	27870 <memcpy>
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
    80f8:	4621      	mov	r1, r4
    80fa:	463a      	mov	r2, r7
    80fc:	f242 0026 	movw	r0, #8230	; 0x2026
    8100:	f7fe f98a 	bl	6418 <bt_hci_cmd_send_sync>
	if (err) {
    8104:	4604      	mov	r4, r0
    8106:	2800      	cmp	r0, #0
    8108:	d0d2      	beq.n	80b0 <bt_dh_key_gen+0x14>
		BT_WARN("Failed to generate DHKey (err %d)", err);
    810a:	4a0e      	ldr	r2, [pc, #56]	; (8144 <bt_dh_key_gen+0xa8>)
		dh_key_cb = NULL;
    810c:	2300      	movs	r3, #0
		BT_WARN("Failed to generate DHKey (err %d)", err);
    810e:	e9cd 2406 	strd	r2, r4, [sp, #24]
    8112:	2203      	movs	r2, #3
		dh_key_cb = NULL;
    8114:	602b      	str	r3, [r5, #0]
		BT_WARN("Failed to generate DHKey (err %d)", err);
    8116:	9201      	str	r2, [sp, #4]
    8118:	9205      	str	r2, [sp, #20]
    811a:	480b      	ldr	r0, [pc, #44]	; (8148 <bt_dh_key_gen+0xac>)
    811c:	aa05      	add	r2, sp, #20
    811e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    8122:	f01d fdd9 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
    8126:	e7c3      	b.n	80b0 <bt_dh_key_gen+0x14>
		return -ENOBUFS;
    8128:	f06f 0468 	mvn.w	r4, #104	; 0x68
    812c:	e7ed      	b.n	810a <bt_dh_key_gen+0x6e>
		return -EALREADY;
    812e:	f06f 0477 	mvn.w	r4, #119	; 0x77
    8132:	e7bd      	b.n	80b0 <bt_dh_key_gen+0x14>
		return -EADDRNOTAVAIL;
    8134:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    8138:	e7ba      	b.n	80b0 <bt_dh_key_gen+0x14>
    813a:	bf00      	nop
    813c:	20002610 	.word	0x20002610
    8140:	2000014c 	.word	0x2000014c
    8144:	0002fee1 	.word	0x0002fee1
    8148:	0002da9c 	.word	0x0002da9c

0000814c <bt_hci_evt_le_pkey_complete>:

void bt_hci_evt_le_pkey_complete(struct net_buf *buf)
{
    814c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    814e:	4c1b      	ldr	r4, [pc, #108]	; (81bc <bt_hci_evt_le_pkey_complete+0x70>)
	struct bt_hci_evt_le_p256_public_key_complete *evt = (void *)buf->data;
    8150:	6886      	ldr	r6, [r0, #8]
    8152:	f3bf 8f5b 	dmb	ish
    8156:	e854 3f00 	ldrex	r3, [r4]
    815a:	f023 0310 	bic.w	r3, r3, #16
    815e:	e844 3200 	strex	r2, r3, [r4]
    8162:	2a00      	cmp	r2, #0
    8164:	d1f7      	bne.n	8156 <bt_hci_evt_le_pkey_complete+0xa>
    8166:	f3bf 8f5b 	dmb	ish

	BT_DBG("status: 0x%02x", evt->status);

	atomic_clear_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY);

	if (!evt->status) {
    816a:	7833      	ldrb	r3, [r6, #0]
    816c:	b983      	cbnz	r3, 8190 <bt_hci_evt_le_pkey_complete+0x44>
		memcpy(pub_key, evt->key, BT_PUB_KEY_LEN);
    816e:	4814      	ldr	r0, [pc, #80]	; (81c0 <bt_hci_evt_le_pkey_complete+0x74>)
    8170:	2240      	movs	r2, #64	; 0x40
    8172:	1c71      	adds	r1, r6, #1
    8174:	f01f fb7c 	bl	27870 <memcpy>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8178:	f3bf 8f5b 	dmb	ish
    817c:	e854 3f00 	ldrex	r3, [r4]
    8180:	f043 0308 	orr.w	r3, r3, #8
    8184:	e844 3200 	strex	r2, r3, [r4]
    8188:	2a00      	cmp	r2, #0
    818a:	d1f7      	bne.n	817c <bt_hci_evt_le_pkey_complete+0x30>
    818c:	f3bf 8f5b 	dmb	ish
	return list->head;
    8190:	4d0c      	ldr	r5, [pc, #48]	; (81c4 <bt_hci_evt_le_pkey_complete+0x78>)
    8192:	682c      	ldr	r4, [r5, #0]
		atomic_set_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY);
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    8194:	b16c      	cbz	r4, 81b2 <bt_hci_evt_le_pkey_complete+0x66>
		if (cb->func) {
			cb->func(evt->status ? NULL : pub_key);
    8196:	4f0a      	ldr	r7, [pc, #40]	; (81c0 <bt_hci_evt_le_pkey_complete+0x74>)
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    8198:	3c04      	subs	r4, #4
		if (cb->func) {
    819a:	6823      	ldr	r3, [r4, #0]
    819c:	b12b      	cbz	r3, 81aa <bt_hci_evt_le_pkey_complete+0x5e>
			cb->func(evt->status ? NULL : pub_key);
    819e:	7832      	ldrb	r2, [r6, #0]
    81a0:	2a00      	cmp	r2, #0
    81a2:	bf0c      	ite	eq
    81a4:	4638      	moveq	r0, r7
    81a6:	2000      	movne	r0, #0
    81a8:	4798      	blx	r3
	return node->next;
    81aa:	6864      	ldr	r4, [r4, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&pub_key_cb_slist, cb, node) {
    81ac:	b10c      	cbz	r4, 81b2 <bt_hci_evt_le_pkey_complete+0x66>
    81ae:	3c04      	subs	r4, #4
    81b0:	e7f3      	b.n	819a <bt_hci_evt_le_pkey_complete+0x4e>
	list->head = NULL;
    81b2:	2300      	movs	r3, #0
	list->tail = NULL;
    81b4:	e9c5 3300 	strd	r3, r3, [r5]
		}
	}

	sys_slist_init(&pub_key_cb_slist);
}
    81b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    81ba:	bf00      	nop
    81bc:	2000014c 	.word	0x2000014c
    81c0:	20003aa9 	.word	0x20003aa9
    81c4:	20002614 	.word	0x20002614

000081c8 <bt_hci_evt_le_dhkey_complete>:
{
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;

	BT_DBG("status: 0x%02x", evt->status);

	if (dh_key_cb) {
    81c8:	4905      	ldr	r1, [pc, #20]	; (81e0 <bt_hci_evt_le_dhkey_complete+0x18>)
    81ca:	680b      	ldr	r3, [r1, #0]
    81cc:	b133      	cbz	r3, 81dc <bt_hci_evt_le_dhkey_complete+0x14>
	struct bt_hci_evt_le_generate_dhkey_complete *evt = (void *)buf->data;
    81ce:	6882      	ldr	r2, [r0, #8]
		bt_dh_key_cb_t cb = dh_key_cb;

		dh_key_cb = NULL;
    81d0:	2000      	movs	r0, #0
    81d2:	6008      	str	r0, [r1, #0]
		cb(evt->status ? NULL : evt->dhkey);
    81d4:	7811      	ldrb	r1, [r2, #0]
    81d6:	b901      	cbnz	r1, 81da <bt_hci_evt_le_dhkey_complete+0x12>
    81d8:	1c50      	adds	r0, r2, #1
    81da:	4718      	bx	r3
	}
}
    81dc:	4770      	bx	lr
    81de:	bf00      	nop
    81e0:	20002610 	.word	0x20002610

000081e4 <tx_free>:
	}
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
    81e4:	2300      	movs	r3, #0
	tx->user_data = NULL;
    81e6:	e9c0 3301 	strd	r3, r3, [r0, #4]
{
    81ea:	4601      	mov	r1, r0
	tx->pending_no_cb = 0U;
    81ec:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    81ee:	4801      	ldr	r0, [pc, #4]	; (81f4 <tx_free+0x10>)
    81f0:	f024 bcf4 	b.w	2cbdc <k_queue_append>
    81f4:	20000f5c 	.word	0x20000f5c

000081f8 <notify_connected>:

static void notify_connected(struct bt_conn *conn)
{
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
    81f8:	4b0e      	ldr	r3, [pc, #56]	; (8234 <notify_connected+0x3c>)
{
    81fa:	b570      	push	{r4, r5, r6, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
    81fc:	681d      	ldr	r5, [r3, #0]
{
    81fe:	4604      	mov	r4, r0
	for (cb = callback_list; cb; cb = cb->_next) {
    8200:	b955      	cbnz	r5, 8218 <notify_connected+0x20>
		if (cb->connected) {
			cb->connected(conn, conn->err);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    8202:	4d0d      	ldr	r5, [pc, #52]	; (8238 <notify_connected+0x40>)
    8204:	4e0d      	ldr	r6, [pc, #52]	; (823c <notify_connected+0x44>)
		if (cb->connected) {
			cb->connected(conn, conn->err);
    8206:	7a61      	ldrb	r1, [r4, #9]
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    8208:	42b5      	cmp	r5, r6
    820a:	d30c      	bcc.n	8226 <notify_connected+0x2e>
		}
	}

	if (!conn->err) {
    820c:	b989      	cbnz	r1, 8232 <notify_connected+0x3a>
		bt_gatt_connected(conn);
    820e:	4620      	mov	r0, r4
	}
}
    8210:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_gatt_connected(conn);
    8214:	f003 b994 	b.w	b540 <bt_gatt_connected>
		if (cb->connected) {
    8218:	682b      	ldr	r3, [r5, #0]
    821a:	b113      	cbz	r3, 8222 <notify_connected+0x2a>
			cb->connected(conn, conn->err);
    821c:	7a61      	ldrb	r1, [r4, #9]
    821e:	4620      	mov	r0, r4
    8220:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    8222:	692d      	ldr	r5, [r5, #16]
    8224:	e7ec      	b.n	8200 <notify_connected+0x8>
		if (cb->connected) {
    8226:	682b      	ldr	r3, [r5, #0]
    8228:	b10b      	cbz	r3, 822e <notify_connected+0x36>
			cb->connected(conn, conn->err);
    822a:	4620      	mov	r0, r4
    822c:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    822e:	3514      	adds	r5, #20
    8230:	e7e9      	b.n	8206 <notify_connected+0xe>
}
    8232:	bd70      	pop	{r4, r5, r6, pc}
    8234:	2000261c 	.word	0x2000261c
    8238:	0002d81c 	.word	0x0002d81c
    823c:	0002d844 	.word	0x0002d844

00008240 <send_frag>:
{
    8240:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    8244:	694d      	ldr	r5, [r1, #20]
{
    8246:	b089      	sub	sp, #36	; 0x24
    8248:	4604      	mov	r4, r0
    824a:	460e      	mov	r6, r1
    824c:	4690      	mov	r8, r2
    824e:	461f      	mov	r7, r3
	return z_impl_k_sem_take(sem, timeout);
    8250:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8254:	4844      	ldr	r0, [pc, #272]	; (8368 <send_frag+0x128>)
    8256:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    825a:	f01b fea1 	bl	23fa0 <z_impl_k_sem_take>
	if (conn->state != BT_CONN_CONNECTED) {
    825e:	7aa3      	ldrb	r3, [r4, #10]
    8260:	2b07      	cmp	r3, #7
    8262:	d152      	bne.n	830a <send_frag+0xca>
	__asm__ volatile(
    8264:	f04f 0320 	mov.w	r3, #32
    8268:	f3ef 8211 	mrs	r2, BASEPRI
    826c:	f383 8812 	msr	BASEPRI_MAX, r3
    8270:	f3bf 8f6f 	isb	sy
	if (tx) {
    8274:	69a3      	ldr	r3, [r4, #24]
    8276:	2d00      	cmp	r5, #0
    8278:	d05a      	beq.n	8330 <send_frag+0xf0>
	parent->next = child;
    827a:	2100      	movs	r1, #0
    827c:	6029      	str	r1, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
    827e:	2b00      	cmp	r3, #0
    8280:	d153      	bne.n	832a <send_frag+0xea>
	list->head = node;
    8282:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
    8286:	f382 8811 	msr	BASEPRI, r2
    828a:	f3bf 8f6f 	isb	sy
	return net_buf_simple_push(&buf->b, len);
    828e:	2104      	movs	r1, #4
    8290:	f106 0008 	add.w	r0, r6, #8
    8294:	f023 fd95 	bl	2bdc2 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    8298:	8823      	ldrh	r3, [r4, #0]
    829a:	f008 08fd 	and.w	r8, r8, #253	; 0xfd
    829e:	ea43 3808 	orr.w	r8, r3, r8, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    82a2:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    82a4:	f8a0 8000 	strh.w	r8, [r0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    82a8:	3b04      	subs	r3, #4
    82aa:	8043      	strh	r3, [r0, #2]
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    82ac:	2302      	movs	r3, #2
    82ae:	7533      	strb	r3, [r6, #20]
	return bt_send(buf);
    82b0:	4630      	mov	r0, r6
    82b2:	f01f fe2b 	bl	27f0c <bt_send>
	if (err) {
    82b6:	2800      	cmp	r0, #0
    82b8:	d054      	beq.n	8364 <send_frag+0x124>
		BT_ERR("Unable to send to driver (err %d)", err);
    82ba:	4b2c      	ldr	r3, [pc, #176]	; (836c <send_frag+0x12c>)
    82bc:	aa05      	add	r2, sp, #20
    82be:	e9cd 3006 	strd	r3, r0, [sp, #24]
    82c2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    82c6:	2303      	movs	r3, #3
    82c8:	4829      	ldr	r0, [pc, #164]	; (8370 <send_frag+0x130>)
    82ca:	9301      	str	r3, [sp, #4]
    82cc:	9305      	str	r3, [sp, #20]
    82ce:	f01f ff94 	bl	281fa <z_log_msg2_static_create.constprop.0>
	__asm__ volatile(
    82d2:	f04f 0320 	mov.w	r3, #32
    82d6:	f3ef 8011 	mrs	r0, BASEPRI
    82da:	f383 8812 	msr	BASEPRI_MAX, r3
    82de:	f3bf 8f6f 	isb	sy
		if (tx) {
    82e2:	2d00      	cmp	r5, #0
    82e4:	d038      	beq.n	8358 <send_frag+0x118>
	return list->head;
    82e6:	6963      	ldr	r3, [r4, #20]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    82e8:	2200      	movs	r2, #0
    82ea:	b153      	cbz	r3, 8302 <send_frag+0xc2>
    82ec:	429d      	cmp	r5, r3
    82ee:	d130      	bne.n	8352 <send_frag+0x112>
	return node->next;
    82f0:	682b      	ldr	r3, [r5, #0]
	return list->tail;
    82f2:	69a1      	ldr	r1, [r4, #24]
Z_GENLIST_REMOVE(slist, snode)
    82f4:	bb42      	cbnz	r2, 8348 <send_frag+0x108>
    82f6:	428d      	cmp	r5, r1
	list->head = node;
    82f8:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
    82fa:	d100      	bne.n	82fe <send_frag+0xbe>
	list->tail = node;
    82fc:	61a3      	str	r3, [r4, #24]
	parent->next = child;
    82fe:	2300      	movs	r3, #0
    8300:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
    8302:	f380 8811 	msr	BASEPRI, r0
    8306:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    830a:	4817      	ldr	r0, [pc, #92]	; (8368 <send_frag+0x128>)
    830c:	f01b fe22 	bl	23f54 <z_impl_k_sem_give>
	if (tx) {
    8310:	b115      	cbz	r5, 8318 <send_frag+0xd8>
		tx_free(tx);
    8312:	4628      	mov	r0, r5
    8314:	f7ff ff66 	bl	81e4 <tx_free>
	if (always_consume) {
    8318:	b11f      	cbz	r7, 8322 <send_frag+0xe2>
		net_buf_unref(buf);
    831a:	4630      	mov	r0, r6
    831c:	f018 faba 	bl	20894 <net_buf_unref>
	return false;
    8320:	2700      	movs	r7, #0
}
    8322:	4638      	mov	r0, r7
    8324:	b009      	add	sp, #36	; 0x24
    8326:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    832a:	601d      	str	r5, [r3, #0]
	list->tail = node;
    832c:	61a5      	str	r5, [r4, #24]
}
    832e:	e7aa      	b.n	8286 <send_frag+0x46>
		if (tail_tx) {
    8330:	b133      	cbz	r3, 8340 <send_frag+0x100>
			pending_no_cb = &tail_tx->pending_no_cb;
    8332:	f103 090c 	add.w	r9, r3, #12
    8336:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
    8338:	3301      	adds	r3, #1
    833a:	f8c9 3000 	str.w	r3, [r9]
    833e:	e7a2      	b.n	8286 <send_frag+0x46>
			pending_no_cb = &conn->pending_no_cb;
    8340:	69e3      	ldr	r3, [r4, #28]
    8342:	f104 091c 	add.w	r9, r4, #28
    8346:	e7f7      	b.n	8338 <send_frag+0xf8>
Z_GENLIST_REMOVE(slist, snode)
    8348:	428d      	cmp	r5, r1
	parent->next = child;
    834a:	6013      	str	r3, [r2, #0]
	list->tail = node;
    834c:	bf08      	it	eq
    834e:	61a2      	streq	r2, [r4, #24]
}
    8350:	e7d5      	b.n	82fe <send_frag+0xbe>
	return node->next;
    8352:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8354:	681b      	ldr	r3, [r3, #0]
    8356:	e7c8      	b.n	82ea <send_frag+0xaa>
			(*pending_no_cb)--;
    8358:	f8d9 3000 	ldr.w	r3, [r9]
    835c:	3b01      	subs	r3, #1
    835e:	f8c9 3000 	str.w	r3, [r9]
    8362:	e7ce      	b.n	8302 <send_frag+0xc2>
	return true;
    8364:	2701      	movs	r7, #1
    8366:	e7dc      	b.n	8322 <send_frag+0xe2>
    8368:	20000180 	.word	0x20000180
    836c:	0002f8ed 	.word	0x0002f8ed
    8370:	0002d9dc 	.word	0x0002d9dc

00008374 <bt_conn_get_pkts>:
}
    8374:	4800      	ldr	r0, [pc, #0]	; (8378 <bt_conn_get_pkts+0x4>)
    8376:	4770      	bx	lr
    8378:	20000180 	.word	0x20000180

0000837c <bt_conn_new>:
{
    837c:	b538      	push	{r3, r4, r5, lr}
    837e:	4604      	mov	r4, r0
	for (i = 0; i < size; i++) {
    8380:	2300      	movs	r3, #0
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    8382:	2501      	movs	r5, #1
    8384:	428b      	cmp	r3, r1
    8386:	d102      	bne.n	838e <bt_conn_new+0x12>
		return NULL;
    8388:	2400      	movs	r4, #0
}
    838a:	4620      	mov	r0, r4
    838c:	bd38      	pop	{r3, r4, r5, pc}
    838e:	f104 02b8 	add.w	r2, r4, #184	; 0xb8
    8392:	f3bf 8f5b 	dmb	ish
    8396:	e852 0f00 	ldrex	r0, [r2]
    839a:	2800      	cmp	r0, #0
    839c:	d104      	bne.n	83a8 <bt_conn_new+0x2c>
    839e:	e842 5c00 	strex	ip, r5, [r2]
    83a2:	f1bc 0f00 	cmp.w	ip, #0
    83a6:	d1f6      	bne.n	8396 <bt_conn_new+0x1a>
    83a8:	f3bf 8f5b 	dmb	ish
		if (atomic_cas(&conns[i].ref, 0, 1)) {
    83ac:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
    83b0:	d002      	beq.n	83b8 <bt_conn_new+0x3c>
	for (i = 0; i < size; i++) {
    83b2:	3301      	adds	r3, #1
    83b4:	4604      	mov	r4, r0
    83b6:	e7e5      	b.n	8384 <bt_conn_new+0x8>
	if (!conn) {
    83b8:	2c00      	cmp	r4, #0
    83ba:	d0e6      	beq.n	838a <bt_conn_new+0xe>
	(void)memset(conn, 0, offsetof(struct bt_conn, ref));
    83bc:	22b8      	movs	r2, #184	; 0xb8
    83be:	2100      	movs	r1, #0
    83c0:	4620      	mov	r0, r4
    83c2:	f01f fa60 	bl	27886 <memset>
	k_work_init_delayable(&conn->deferred_work, deferred_work);
    83c6:	f104 0058 	add.w	r0, r4, #88	; 0x58
    83ca:	4904      	ldr	r1, [pc, #16]	; (83dc <bt_conn_new+0x60>)
    83cc:	f024 fd0d 	bl	2cdea <k_work_init_delayable>
	k_work_init(&conn->tx_complete_work, tx_complete_work);
    83d0:	4903      	ldr	r1, [pc, #12]	; (83e0 <bt_conn_new+0x64>)
    83d2:	f104 0028 	add.w	r0, r4, #40	; 0x28
    83d6:	f024 fcd2 	bl	2cd7e <k_work_init>
	return conn;
    83da:	e7d6      	b.n	838a <bt_conn_new+0xe>
    83dc:	00008b81 	.word	0x00008b81
    83e0:	00028265 	.word	0x00028265

000083e4 <bt_conn_recv>:
{
    83e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    83e6:	b089      	sub	sp, #36	; 0x24
    83e8:	4616      	mov	r6, r2
    83ea:	af00      	add	r7, sp, #0
    83ec:	4604      	mov	r4, r0
    83ee:	460d      	mov	r5, r1
	tx_notify(conn);
    83f0:	f01f ff15 	bl	2821e <tx_notify>
	switch (flags) {
    83f4:	2e01      	cmp	r6, #1
    83f6:	d033      	beq.n	8460 <bt_conn_recv+0x7c>
    83f8:	2e02      	cmp	r6, #2
    83fa:	d16e      	bne.n	84da <bt_conn_recv+0xf6>
		if (conn->rx) {
    83fc:	6923      	ldr	r3, [r4, #16]
    83fe:	b16b      	cbz	r3, 841c <bt_conn_recv+0x38>
			BT_ERR("Unexpected first L2CAP frame");
    8400:	4b3f      	ldr	r3, [pc, #252]	; (8500 <bt_conn_recv+0x11c>)
    8402:	4840      	ldr	r0, [pc, #256]	; (8504 <bt_conn_recv+0x120>)
    8404:	61bb      	str	r3, [r7, #24]
    8406:	f107 0214 	add.w	r2, r7, #20
    840a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    840e:	607e      	str	r6, [r7, #4]
    8410:	617e      	str	r6, [r7, #20]
    8412:	f01f fef2 	bl	281fa <z_log_msg2_static_create.constprop.0>
			bt_conn_reset_rx_state(conn);
    8416:	4620      	mov	r0, r4
    8418:	f01f ff27 	bl	2826a <bt_conn_reset_rx_state>
		conn->rx = buf;
    841c:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
    841e:	6921      	ldr	r1, [r4, #16]
    8420:	898a      	ldrh	r2, [r1, #12]
    8422:	2a01      	cmp	r2, #1
    8424:	d933      	bls.n	848e <bt_conn_recv+0xaa>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
    8426:	688b      	ldr	r3, [r1, #8]
    8428:	881b      	ldrh	r3, [r3, #0]
    842a:	3304      	adds	r3, #4
    842c:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
    842e:	429a      	cmp	r2, r3
    8430:	d32d      	bcc.n	848e <bt_conn_recv+0xaa>
	if (conn->rx->len > acl_total_len) {
    8432:	d95d      	bls.n	84f0 <bt_conn_recv+0x10c>
		BT_ERR("ACL len mismatch (%u > %u)",
    8434:	466d      	mov	r5, sp
    8436:	b088      	sub	sp, #32
    8438:	466a      	mov	r2, sp
    843a:	4833      	ldr	r0, [pc, #204]	; (8508 <bt_conn_recv+0x124>)
    843c:	6110      	str	r0, [r2, #16]
    843e:	8989      	ldrh	r1, [r1, #12]
    8440:	4830      	ldr	r0, [pc, #192]	; (8504 <bt_conn_recv+0x120>)
    8442:	e9c2 1305 	strd	r1, r3, [r2, #20]
    8446:	2304      	movs	r3, #4
    8448:	f842 3f0c 	str.w	r3, [r2, #12]!
    844c:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    8450:	60bb      	str	r3, [r7, #8]
    8452:	f01f fed2 	bl	281fa <z_log_msg2_static_create.constprop.0>
		bt_conn_reset_rx_state(conn);
    8456:	4620      	mov	r0, r4
    8458:	46ad      	mov	sp, r5
    845a:	f01f ff06 	bl	2826a <bt_conn_reset_rx_state>
		return;
    845e:	e016      	b.n	848e <bt_conn_recv+0xaa>
		if (!conn->rx) {
    8460:	6920      	ldr	r0, [r4, #16]
    8462:	b978      	cbnz	r0, 8484 <bt_conn_recv+0xa0>
			BT_ERR("Unexpected L2CAP continuation");
    8464:	4b29      	ldr	r3, [pc, #164]	; (850c <bt_conn_recv+0x128>)
    8466:	61bb      	str	r3, [r7, #24]
    8468:	2302      	movs	r3, #2
    846a:	607b      	str	r3, [r7, #4]
    846c:	617b      	str	r3, [r7, #20]
    846e:	f107 0214 	add.w	r2, r7, #20
    8472:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    8476:	4823      	ldr	r0, [pc, #140]	; (8504 <bt_conn_recv+0x120>)
    8478:	f01f febf 	bl	281fa <z_log_msg2_static_create.constprop.0>
		bt_conn_reset_rx_state(conn);
    847c:	4620      	mov	r0, r4
    847e:	f01f fef4 	bl	2826a <bt_conn_reset_rx_state>
    8482:	e001      	b.n	8488 <bt_conn_recv+0xa4>
		if (!buf->len) {
    8484:	89ae      	ldrh	r6, [r5, #12]
    8486:	b92e      	cbnz	r6, 8494 <bt_conn_recv+0xb0>
		net_buf_unref(buf);
    8488:	4628      	mov	r0, r5
    848a:	f018 fa03 	bl	20894 <net_buf_unref>
}
    848e:	3724      	adds	r7, #36	; 0x24
    8490:	46bd      	mov	sp, r7
    8492:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
    8494:	3008      	adds	r0, #8
    8496:	f023 fcf8 	bl	2be8a <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
    849a:	4286      	cmp	r6, r0
    849c:	d913      	bls.n	84c6 <bt_conn_recv+0xe2>
			BT_ERR("Not enough buffer space for L2CAP data");
    849e:	4b1c      	ldr	r3, [pc, #112]	; (8510 <bt_conn_recv+0x12c>)
    84a0:	4818      	ldr	r0, [pc, #96]	; (8504 <bt_conn_recv+0x120>)
    84a2:	61bb      	str	r3, [r7, #24]
    84a4:	f107 0214 	add.w	r2, r7, #20
    84a8:	2302      	movs	r3, #2
    84aa:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    84ae:	607b      	str	r3, [r7, #4]
    84b0:	617b      	str	r3, [r7, #20]
    84b2:	f01f fea2 	bl	281fa <z_log_msg2_static_create.constprop.0>
			bt_l2cap_recv(conn, conn->rx, false);
    84b6:	2200      	movs	r2, #0
    84b8:	6921      	ldr	r1, [r4, #16]
    84ba:	4620      	mov	r0, r4
    84bc:	f000 fdca 	bl	9054 <bt_l2cap_recv>
			conn->rx = NULL;
    84c0:	2300      	movs	r3, #0
    84c2:	6123      	str	r3, [r4, #16]
			net_buf_unref(buf);
    84c4:	e7e0      	b.n	8488 <bt_conn_recv+0xa4>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    84c6:	6920      	ldr	r0, [r4, #16]
    84c8:	89aa      	ldrh	r2, [r5, #12]
    84ca:	68a9      	ldr	r1, [r5, #8]
    84cc:	3008      	adds	r0, #8
    84ce:	f023 fc3b 	bl	2bd48 <net_buf_simple_add_mem>
		net_buf_unref(buf);
    84d2:	4628      	mov	r0, r5
    84d4:	f018 f9de 	bl	20894 <net_buf_unref>
		break;
    84d8:	e7a1      	b.n	841e <bt_conn_recv+0x3a>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    84da:	4b0e      	ldr	r3, [pc, #56]	; (8514 <bt_conn_recv+0x130>)
	switch (flags) {
    84dc:	e9c7 3606 	strd	r3, r6, [r7, #24]
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    84e0:	2303      	movs	r3, #3
    84e2:	607b      	str	r3, [r7, #4]
    84e4:	617b      	str	r3, [r7, #20]
    84e6:	f107 0214 	add.w	r2, r7, #20
    84ea:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    84ee:	e7c2      	b.n	8476 <bt_conn_recv+0x92>
	conn->rx = NULL;
    84f0:	2300      	movs	r3, #0
    84f2:	6123      	str	r3, [r4, #16]
	bt_l2cap_recv(conn, buf, true);
    84f4:	2201      	movs	r2, #1
    84f6:	4620      	mov	r0, r4
    84f8:	f000 fdac 	bl	9054 <bt_l2cap_recv>
		__ASSERT(false, "Invalid connection type %u", conn->type);
    84fc:	e7c7      	b.n	848e <bt_conn_recv+0xaa>
    84fe:	bf00      	nop
    8500:	0002ff0a 	.word	0x0002ff0a
    8504:	0002d9dc 	.word	0x0002d9dc
    8508:	0002ff8a 	.word	0x0002ff8a
    850c:	0002ff27 	.word	0x0002ff27
    8510:	0002ff45 	.word	0x0002ff45
    8514:	0002ff6c 	.word	0x0002ff6c

00008518 <bt_conn_send_cb>:
{
    8518:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    851c:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
    851e:	7a83      	ldrb	r3, [r0, #10]
    8520:	2b07      	cmp	r3, #7
{
    8522:	b088      	sub	sp, #32
    8524:	4605      	mov	r5, r0
    8526:	460e      	mov	r6, r1
    8528:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
    852a:	d00d      	beq.n	8548 <bt_conn_send_cb+0x30>
		BT_ERR("not connected!");
    852c:	4b27      	ldr	r3, [pc, #156]	; (85cc <bt_conn_send_cb+0xb4>)
    852e:	9306      	str	r3, [sp, #24]
    8530:	4827      	ldr	r0, [pc, #156]	; (85d0 <bt_conn_send_cb+0xb8>)
    8532:	2302      	movs	r3, #2
    8534:	aa05      	add	r2, sp, #20
    8536:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    853a:	9301      	str	r3, [sp, #4]
    853c:	9305      	str	r3, [sp, #20]
    853e:	f01f fe5c 	bl	281fa <z_log_msg2_static_create.constprop.0>
			return -ENOTCONN;
    8542:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    8546:	e01e      	b.n	8586 <bt_conn_send_cb+0x6e>
	if (cb) {
    8548:	2a00      	cmp	r2, #0
    854a:	d03d      	beq.n	85c8 <bt_conn_send_cb+0xb0>
	return z_impl_z_current_get();
    854c:	f01c fa00 	bl	24950 <z_impl_z_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    8550:	4b20      	ldr	r3, [pc, #128]	; (85d4 <bt_conn_send_cb+0xbc>)
    8552:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
    8554:	4820      	ldr	r0, [pc, #128]	; (85d8 <bt_conn_send_cb+0xc0>)
    8556:	bf07      	ittee	eq
    8558:	2200      	moveq	r2, #0
    855a:	2300      	moveq	r3, #0
    855c:	f04f 32ff 	movne.w	r2, #4294967295	; 0xffffffff
    8560:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    8564:	f01b fcc2 	bl	23eec <z_impl_k_queue_get>
    8568:	4604      	mov	r4, r0
		if (!tx) {
    856a:	b978      	cbnz	r0, 858c <bt_conn_send_cb+0x74>
			BT_ERR("Unable to allocate TX context");
    856c:	4b1b      	ldr	r3, [pc, #108]	; (85dc <bt_conn_send_cb+0xc4>)
    856e:	4818      	ldr	r0, [pc, #96]	; (85d0 <bt_conn_send_cb+0xb8>)
    8570:	9306      	str	r3, [sp, #24]
    8572:	aa05      	add	r2, sp, #20
    8574:	2302      	movs	r3, #2
    8576:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    857a:	9301      	str	r3, [sp, #4]
    857c:	9305      	str	r3, [sp, #20]
    857e:	f01f fe3c 	bl	281fa <z_log_msg2_static_create.constprop.0>
			return -ENOBUFS;
    8582:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
    8586:	b008      	add	sp, #32
    8588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
    858c:	7aab      	ldrb	r3, [r5, #10]
    858e:	2b07      	cmp	r3, #7
    8590:	d00e      	beq.n	85b0 <bt_conn_send_cb+0x98>
			BT_WARN("Disconnected while allocating context");
    8592:	4b13      	ldr	r3, [pc, #76]	; (85e0 <bt_conn_send_cb+0xc8>)
    8594:	9306      	str	r3, [sp, #24]
    8596:	480e      	ldr	r0, [pc, #56]	; (85d0 <bt_conn_send_cb+0xb8>)
    8598:	2302      	movs	r3, #2
    859a:	aa05      	add	r2, sp, #20
    859c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    85a0:	9301      	str	r3, [sp, #4]
    85a2:	9305      	str	r3, [sp, #20]
    85a4:	f01f fe29 	bl	281fa <z_log_msg2_static_create.constprop.0>
			tx_free(tx);
    85a8:	4620      	mov	r0, r4
    85aa:	f7ff fe1b 	bl	81e4 <tx_free>
    85ae:	e7c8      	b.n	8542 <bt_conn_send_cb+0x2a>
		tx->pending_no_cb = 0U;
    85b0:	2300      	movs	r3, #0
		tx->user_data = user_data;
    85b2:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
    85b6:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    85b8:	6170      	str	r0, [r6, #20]
	net_buf_put(&conn->tx_queue, buf);
    85ba:	f105 0038 	add.w	r0, r5, #56	; 0x38
    85be:	4631      	mov	r1, r6
    85c0:	f023 fb77 	bl	2bcb2 <net_buf_put>
	return 0;
    85c4:	2000      	movs	r0, #0
    85c6:	e7de      	b.n	8586 <bt_conn_send_cb+0x6e>
		tx_data(buf)->tx = NULL;
    85c8:	614a      	str	r2, [r1, #20]
    85ca:	e7f6      	b.n	85ba <bt_conn_send_cb+0xa2>
    85cc:	0002ffa5 	.word	0x0002ffa5
    85d0:	0002d9dc 	.word	0x0002d9dc
    85d4:	20002400 	.word	0x20002400
    85d8:	20000f5c 	.word	0x20000f5c
    85dc:	0002ffb4 	.word	0x0002ffb4
    85e0:	0002ffd2 	.word	0x0002ffd2

000085e4 <bt_conn_prepare_events>:
	conn_change.signaled = 0U;
    85e4:	4b1b      	ldr	r3, [pc, #108]	; (8654 <bt_conn_prepare_events+0x70>)
{
    85e6:	b510      	push	{r4, lr}
	conn_change.signaled = 0U;
    85e8:	2200      	movs	r2, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    85ea:	2101      	movs	r1, #1
	conn_change.signaled = 0U;
    85ec:	609a      	str	r2, [r3, #8]
{
    85ee:	4604      	mov	r4, r0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    85f0:	f024 ff37 	bl	2d462 <k_poll_event_init>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    85f4:	f3bf 8f5b 	dmb	ish
    85f8:	4b17      	ldr	r3, [pc, #92]	; (8658 <bt_conn_prepare_events+0x74>)
    85fa:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
    85fe:	f3bf 8f5b 	dmb	ish
		if (!conn_prepare_events(conn, &events[ev_count])) {
    8602:	f104 0014 	add.w	r0, r4, #20
	if (!atomic_get(&conn->ref)) {
    8606:	b90a      	cbnz	r2, 860c <bt_conn_prepare_events+0x28>
		conn_cleanup(conn);
    8608:	2001      	movs	r0, #1
}
    860a:	bd10      	pop	{r4, pc}
	if (conn->state == BT_CONN_DISCONNECTED &&
    860c:	7a9a      	ldrb	r2, [r3, #10]
    860e:	b99a      	cbnz	r2, 8638 <bt_conn_prepare_events+0x54>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8610:	f3bf 8f5b 	dmb	ish
    8614:	1d1a      	adds	r2, r3, #4
    8616:	e852 1f00 	ldrex	r1, [r2]
    861a:	f021 0c40 	bic.w	ip, r1, #64	; 0x40
    861e:	e842 ce00 	strex	lr, ip, [r2]
    8622:	f1be 0f00 	cmp.w	lr, #0
    8626:	d1f6      	bne.n	8616 <bt_conn_prepare_events+0x32>
    8628:	f3bf 8f5b 	dmb	ish
    862c:	064a      	lsls	r2, r1, #25
    862e:	d503      	bpl.n	8638 <bt_conn_prepare_events+0x54>
		conn_cleanup(conn);
    8630:	4618      	mov	r0, r3
    8632:	f01f fe23 	bl	2827c <conn_cleanup>
    8636:	e7e7      	b.n	8608 <bt_conn_prepare_events+0x24>
	if (conn->state != BT_CONN_CONNECTED) {
    8638:	7a9b      	ldrb	r3, [r3, #10]
    863a:	2b07      	cmp	r3, #7
    863c:	d1e4      	bne.n	8608 <bt_conn_prepare_events+0x24>
	k_poll_event_init(&events[0],
    863e:	4b07      	ldr	r3, [pc, #28]	; (865c <bt_conn_prepare_events+0x78>)
    8640:	2200      	movs	r2, #0
    8642:	2104      	movs	r1, #4
    8644:	f024 ff0d 	bl	2d462 <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
    8648:	2301      	movs	r3, #1
    864a:	f884 3020 	strb.w	r3, [r4, #32]
			ev_count++;
    864e:	2002      	movs	r0, #2
	return ev_count;
    8650:	e7db      	b.n	860a <bt_conn_prepare_events+0x26>
    8652:	bf00      	nop
    8654:	20000394 	.word	0x20000394
    8658:	200016e0 	.word	0x200016e0
    865c:	20001718 	.word	0x20001718

00008660 <bt_conn_lookup_handle>:
{
    8660:	4602      	mov	r2, r0
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
    8662:	2101      	movs	r1, #1
    8664:	4801      	ldr	r0, [pc, #4]	; (866c <bt_conn_lookup_handle+0xc>)
    8666:	f01f be5c 	b.w	28322 <conn_lookup_handle>
    866a:	bf00      	nop
    866c:	200016e0 	.word	0x200016e0

00008670 <bt_conn_set_state>:
{
    8670:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == state) {
    8672:	7a86      	ldrb	r6, [r0, #10]
    8674:	42b1      	cmp	r1, r6
{
    8676:	b08c      	sub	sp, #48	; 0x30
    8678:	4604      	mov	r4, r0
    867a:	460d      	mov	r5, r1
	if (conn->state == state) {
    867c:	d111      	bne.n	86a2 <bt_conn_set_state+0x32>
	switch (state) {
    867e:	2908      	cmp	r1, #8
    8680:	bf96      	itet	ls
    8682:	4b6c      	ldrls	r3, [pc, #432]	; (8834 <bt_conn_set_state+0x1c4>)
	if (conn->state == state) {
    8684:	4b6c      	ldrhi	r3, [pc, #432]	; (8838 <bt_conn_set_state+0x1c8>)
    8686:	f853 3021 	ldrls.w	r3, [r3, r1, lsl #2]
		BT_WARN("no transition %s", state2str(state));
    868a:	9302      	str	r3, [sp, #8]
    868c:	4b6b      	ldr	r3, [pc, #428]	; (883c <bt_conn_set_state+0x1cc>)
    868e:	9301      	str	r3, [sp, #4]
    8690:	2300      	movs	r3, #0
    8692:	496b      	ldr	r1, [pc, #428]	; (8840 <bt_conn_set_state+0x1d0>)
    8694:	9300      	str	r3, [sp, #0]
    8696:	2202      	movs	r2, #2
    8698:	4618      	mov	r0, r3
    869a:	f01f fdb1 	bl	28200 <z_log_msg2_runtime_create.constprop.0>
}
    869e:	b00c      	add	sp, #48	; 0x30
    86a0:	bd70      	pop	{r4, r5, r6, pc}
	conn->state = state;
    86a2:	7281      	strb	r1, [r0, #10]
	switch (old_state) {
    86a4:	b926      	cbnz	r6, 86b0 <bt_conn_set_state+0x40>
		if (conn->type != BT_CONN_TYPE_ISO) {
    86a6:	7883      	ldrb	r3, [r0, #2]
    86a8:	2b08      	cmp	r3, #8
    86aa:	d001      	beq.n	86b0 <bt_conn_set_state+0x40>
			bt_conn_ref(conn);
    86ac:	f01f fe04 	bl	282b8 <bt_conn_ref>
	switch (conn->state) {
    86b0:	7aa3      	ldrb	r3, [r4, #10]
    86b2:	2b08      	cmp	r3, #8
    86b4:	f200 80bb 	bhi.w	882e <bt_conn_set_state+0x1be>
    86b8:	a201      	add	r2, pc, #4	; (adr r2, 86c0 <bt_conn_set_state+0x50>)
    86ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    86be:	bf00      	nop
    86c0:	00008749 	.word	0x00008749
    86c4:	000086e5 	.word	0x000086e5
    86c8:	0000869f 	.word	0x0000869f
    86cc:	0000869f 	.word	0x0000869f
    86d0:	0000869f 	.word	0x0000869f
    86d4:	0000869f 	.word	0x0000869f
    86d8:	0000869f 	.word	0x0000869f
    86dc:	00008713 	.word	0x00008713
    86e0:	0000869f 	.word	0x0000869f
	z_impl_k_sem_give(sem);
    86e4:	4d57      	ldr	r5, [pc, #348]	; (8844 <bt_conn_set_state+0x1d4>)
		tx->pending_no_cb = 0U;
    86e6:	2600      	movs	r6, #0
	__asm__ volatile(
    86e8:	f04f 0320 	mov.w	r3, #32
    86ec:	f3ef 8211 	mrs	r2, BASEPRI
    86f0:	f383 8812 	msr	BASEPRI_MAX, r3
    86f4:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
    86f8:	69e3      	ldr	r3, [r4, #28]
    86fa:	2b00      	cmp	r3, #0
    86fc:	d076      	beq.n	87ec <bt_conn_set_state+0x17c>
			conn->pending_no_cb--;
    86fe:	3b01      	subs	r3, #1
    8700:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    8702:	f382 8811 	msr	BASEPRI, r2
    8706:	f3bf 8f6f 	isb	sy
    870a:	4628      	mov	r0, r5
    870c:	f01b fc22 	bl	23f54 <z_impl_k_sem_give>
}
    8710:	e7ea      	b.n	86e8 <bt_conn_set_state+0x78>
		if (conn->type == BT_CONN_TYPE_SCO) {
    8712:	78a3      	ldrb	r3, [r4, #2]
    8714:	2b04      	cmp	r3, #4
    8716:	d0c2      	beq.n	869e <bt_conn_set_state+0x2e>
	z_impl_k_queue_init(queue);
    8718:	f104 0038 	add.w	r0, r4, #56	; 0x38
    871c:	f024 fa32 	bl	2cb84 <z_impl_k_queue_init>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    8720:	4849      	ldr	r0, [pc, #292]	; (8848 <bt_conn_set_state+0x1d8>)
    8722:	2100      	movs	r1, #0
    8724:	f01c fbfa 	bl	24f1c <z_impl_k_poll_signal_raise>
	list->head = NULL;
    8728:	2300      	movs	r3, #0
	list->tail = NULL;
    872a:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    872e:	78e3      	ldrb	r3, [r4, #3]
    8730:	2b01      	cmp	r3, #1
    8732:	d1b4      	bne.n	869e <bt_conn_set_state+0x2e>
			k_work_schedule(&conn->deferred_work,
    8734:	f44f 3220 	mov.w	r2, #163840	; 0x28000
    8738:	2300      	movs	r3, #0
    873a:	f104 0058 	add.w	r0, r4, #88	; 0x58
}
    873e:	b00c      	add	sp, #48	; 0x30
    8740:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			k_work_schedule(&conn->deferred_work,
    8744:	f01b bdda 	b.w	242fc <k_work_schedule>
		if (conn->type == BT_CONN_TYPE_SCO) {
    8748:	78a3      	ldrb	r3, [r4, #2]
    874a:	2b04      	cmp	r3, #4
    874c:	d105      	bne.n	875a <bt_conn_set_state+0xea>
			bt_conn_unref(conn);
    874e:	4620      	mov	r0, r4
}
    8750:	b00c      	add	sp, #48	; 0x30
    8752:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			bt_conn_unref(conn);
    8756:	f01f bdca 	b.w	282ee <bt_conn_unref>
		switch (old_state) {
    875a:	2e08      	cmp	r6, #8
    875c:	d89f      	bhi.n	869e <bt_conn_set_state+0x2e>
    875e:	a301      	add	r3, pc, #4	; (adr r3, 8764 <bt_conn_set_state+0xf4>)
    8760:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
    8764:	000087d3 	.word	0x000087d3
    8768:	00008789 	.word	0x00008789
    876c:	000087c5 	.word	0x000087c5
    8770:	0000874f 	.word	0x0000874f
    8774:	0000874f 	.word	0x0000874f
    8778:	000087c5 	.word	0x000087c5
    877c:	000087c5 	.word	0x000087c5
    8780:	000087d3 	.word	0x000087d3
    8784:	000087d3 	.word	0x000087d3
			tx_notify(conn);
    8788:	4620      	mov	r0, r4
    878a:	f01f fd48 	bl	2821e <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
    878e:	78a3      	ldrb	r3, [r4, #2]
    8790:	2b01      	cmp	r3, #1
    8792:	d103      	bne.n	879c <bt_conn_set_state+0x12c>
				k_work_cancel_delayable(&conn->deferred_work);
    8794:	f104 0058 	add.w	r0, r4, #88	; 0x58
    8798:	f024 fb35 	bl	2ce06 <k_work_cancel_delayable>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    879c:	f3bf 8f5b 	dmb	ish
    87a0:	3404      	adds	r4, #4
    87a2:	e854 3f00 	ldrex	r3, [r4]
    87a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    87aa:	e844 3200 	strex	r2, r3, [r4]
    87ae:	2a00      	cmp	r2, #0
    87b0:	d1f7      	bne.n	87a2 <bt_conn_set_state+0x132>
    87b2:	f3bf 8f5b 	dmb	ish
    87b6:	4824      	ldr	r0, [pc, #144]	; (8848 <bt_conn_set_state+0x1d8>)
    87b8:	2100      	movs	r1, #0
}
    87ba:	b00c      	add	sp, #48	; 0x30
    87bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    87c0:	f01c bbac 	b.w	24f1c <z_impl_k_poll_signal_raise>
			if (conn->err) {
    87c4:	7a63      	ldrb	r3, [r4, #9]
    87c6:	2b00      	cmp	r3, #0
    87c8:	d0c1      	beq.n	874e <bt_conn_set_state+0xde>
				notify_connected(conn);
    87ca:	4620      	mov	r0, r4
    87cc:	f7ff fd14 	bl	81f8 <notify_connected>
    87d0:	e7bd      	b.n	874e <bt_conn_set_state+0xde>
			BT_WARN("Invalid (%u) old state", state);
    87d2:	4b1e      	ldr	r3, [pc, #120]	; (884c <bt_conn_set_state+0x1dc>)
		BT_WARN("no valid (%u) state was set", state);
    87d4:	481a      	ldr	r0, [pc, #104]	; (8840 <bt_conn_set_state+0x1d0>)
    87d6:	e9cd 350a 	strd	r3, r5, [sp, #40]	; 0x28
    87da:	aa09      	add	r2, sp, #36	; 0x24
    87dc:	2303      	movs	r3, #3
    87de:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    87e2:	9305      	str	r3, [sp, #20]
    87e4:	9309      	str	r3, [sp, #36]	; 0x24
    87e6:	f01f fd08 	bl	281fa <z_log_msg2_static_create.constprop.0>
		break;
    87ea:	e758      	b.n	869e <bt_conn_set_state+0x2e>
	return list->head;
    87ec:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
    87ee:	b128      	cbz	r0, 87fc <bt_conn_set_state+0x18c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    87f0:	69a1      	ldr	r1, [r4, #24]
	return node->next;
    87f2:	6803      	ldr	r3, [r0, #0]
	list->head = node;
    87f4:	6163      	str	r3, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    87f6:	4288      	cmp	r0, r1
	list->tail = node;
    87f8:	bf08      	it	eq
    87fa:	61a3      	streq	r3, [r4, #24]
    87fc:	f382 8811 	msr	BASEPRI, r2
    8800:	f3bf 8f6f 	isb	sy
		if (!node) {
    8804:	2800      	cmp	r0, #0
    8806:	f43f af4a 	beq.w	869e <bt_conn_set_state+0x2e>
	__asm__ volatile(
    880a:	f04f 0220 	mov.w	r2, #32
    880e:	f3ef 8311 	mrs	r3, BASEPRI
    8812:	f382 8812 	msr	BASEPRI_MAX, r2
    8816:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
    881a:	68c2      	ldr	r2, [r0, #12]
    881c:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
    881e:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
    8820:	f383 8811 	msr	BASEPRI, r3
    8824:	f3bf 8f6f 	isb	sy
		tx_free(tx);
    8828:	f7ff fcdc 	bl	81e4 <tx_free>
    882c:	e76d      	b.n	870a <bt_conn_set_state+0x9a>
		BT_WARN("no valid (%u) state was set", state);
    882e:	4b08      	ldr	r3, [pc, #32]	; (8850 <bt_conn_set_state+0x1e0>)
    8830:	e7d0      	b.n	87d4 <bt_conn_set_state+0x164>
    8832:	bf00      	nop
    8834:	0002e1d0 	.word	0x0002e1d0
    8838:	0002fff8 	.word	0x0002fff8
    883c:	00030002 	.word	0x00030002
    8840:	0002d9dc 	.word	0x0002d9dc
    8844:	20000180 	.word	0x20000180
    8848:	20000394 	.word	0x20000394
    884c:	00030013 	.word	0x00030013
    8850:	0003002a 	.word	0x0003002a

00008854 <bt_conn_index>:
		index = conn - acl_conns;
    8854:	4b03      	ldr	r3, [pc, #12]	; (8864 <bt_conn_index+0x10>)
    8856:	1ac0      	subs	r0, r0, r3
    8858:	4b03      	ldr	r3, [pc, #12]	; (8868 <bt_conn_index+0x14>)
    885a:	1180      	asrs	r0, r0, #6
    885c:	4358      	muls	r0, r3
}
    885e:	b2c0      	uxtb	r0, r0
    8860:	4770      	bx	lr
    8862:	bf00      	nop
    8864:	200016e0 	.word	0x200016e0
    8868:	aaaaaaab 	.word	0xaaaaaaab

0000886c <bt_conn_create_pdu_timeout>:
{
    886c:	b530      	push	{r4, r5, lr}
    886e:	460d      	mov	r5, r1
	return net_buf_alloc_fixed(pool, timeout);
    8870:	490d      	ldr	r1, [pc, #52]	; (88a8 <bt_conn_create_pdu_timeout+0x3c>)
    8872:	b089      	sub	sp, #36	; 0x24
    8874:	2800      	cmp	r0, #0
    8876:	bf08      	it	eq
    8878:	4608      	moveq	r0, r1
    887a:	f023 f9d4 	bl	2bc26 <net_buf_alloc_fixed>
	if (!buf) {
    887e:	4604      	mov	r4, r0
    8880:	b968      	cbnz	r0, 889e <bt_conn_create_pdu_timeout+0x32>
		BT_WARN("Unable to allocate buffer within timeout");
    8882:	4b0a      	ldr	r3, [pc, #40]	; (88ac <bt_conn_create_pdu_timeout+0x40>)
    8884:	9306      	str	r3, [sp, #24]
    8886:	480a      	ldr	r0, [pc, #40]	; (88b0 <bt_conn_create_pdu_timeout+0x44>)
    8888:	2302      	movs	r3, #2
    888a:	aa05      	add	r2, sp, #20
    888c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    8890:	9301      	str	r3, [sp, #4]
    8892:	9305      	str	r3, [sp, #20]
    8894:	f01f fcb1 	bl	281fa <z_log_msg2_static_create.constprop.0>
}
    8898:	4620      	mov	r0, r4
    889a:	b009      	add	sp, #36	; 0x24
    889c:	bd30      	pop	{r4, r5, pc}
	net_buf_simple_reserve(&buf->b, reserve);
    889e:	1d29      	adds	r1, r5, #4
    88a0:	3008      	adds	r0, #8
    88a2:	f023 f9e5 	bl	2bc70 <net_buf_simple_reserve>
	return buf;
    88a6:	e7f7      	b.n	8898 <bt_conn_create_pdu_timeout+0x2c>
    88a8:	20000f8c 	.word	0x20000f8c
    88ac:	00030046 	.word	0x00030046
    88b0:	0002d9dc 	.word	0x0002d9dc

000088b4 <notify_le_param_updated>:
	}
}
#endif /* defined(CONFIG_BT_REMOTE_INFO) */

void notify_le_param_updated(struct bt_conn *conn)
{
    88b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    88b6:	f3bf 8f5b 	dmb	ish
    88ba:	6842      	ldr	r2, [r0, #4]
    88bc:	f3bf 8f5b 	dmb	ish
	struct bt_conn_cb *cb;

	/* If new connection parameters meet requirement of pending
	 * parameters don't send peripheral conn param request anymore on timeout
	 */
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
    88c0:	0592      	lsls	r2, r2, #22
{
    88c2:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
    88c4:	f100 0304 	add.w	r3, r0, #4
    88c8:	d519      	bpl.n	88fe <notify_le_param_updated+0x4a>
	    conn->le.interval >= conn->le.interval_min &&
    88ca:	f8b0 209e 	ldrh.w	r2, [r0, #158]	; 0x9e
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
    88ce:	f8b0 10a0 	ldrh.w	r1, [r0, #160]	; 0xa0
    88d2:	4291      	cmp	r1, r2
    88d4:	d813      	bhi.n	88fe <notify_le_param_updated+0x4a>
	    conn->le.interval >= conn->le.interval_min &&
    88d6:	f8b0 10a2 	ldrh.w	r1, [r0, #162]	; 0xa2
    88da:	4291      	cmp	r1, r2
    88dc:	d30f      	bcc.n	88fe <notify_le_param_updated+0x4a>
	    conn->le.interval <= conn->le.interval_max &&
	    conn->le.latency == conn->le.pending_latency &&
    88de:	e9d0 1229 	ldrd	r1, r2, [r0, #164]	; 0xa4
    88e2:	4291      	cmp	r1, r2
    88e4:	d10b      	bne.n	88fe <notify_le_param_updated+0x4a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    88e6:	f3bf 8f5b 	dmb	ish
    88ea:	e853 2f00 	ldrex	r2, [r3]
    88ee:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    88f2:	e843 2100 	strex	r1, r2, [r3]
    88f6:	2900      	cmp	r1, #0
    88f8:	d1f7      	bne.n	88ea <notify_le_param_updated+0x36>
    88fa:	f3bf 8f5b 	dmb	ish
	    conn->le.timeout == conn->le.pending_timeout) {
		atomic_clear_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET);
	}

	for (cb = callback_list; cb; cb = cb->_next) {
    88fe:	4b10      	ldr	r3, [pc, #64]	; (8940 <notify_le_param_updated+0x8c>)
    8900:	681d      	ldr	r5, [r3, #0]
    8902:	b925      	cbnz	r5, 890e <notify_le_param_updated+0x5a>
					     conn->le.latency,
					     conn->le.timeout);
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    8904:	4d0f      	ldr	r5, [pc, #60]	; (8944 <notify_le_param_updated+0x90>)
    8906:	4f10      	ldr	r7, [pc, #64]	; (8948 <notify_le_param_updated+0x94>)
    8908:	42bd      	cmp	r5, r7
    890a:	d30c      	bcc.n	8926 <notify_le_param_updated+0x72>
			cb->le_param_updated(conn, conn->le.interval,
					     conn->le.latency,
					     conn->le.timeout);
		}
	}
}
    890c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (cb->le_param_updated) {
    890e:	68ee      	ldr	r6, [r5, #12]
    8910:	b13e      	cbz	r6, 8922 <notify_le_param_updated+0x6e>
			cb->le_param_updated(conn, conn->le.interval,
    8912:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    8916:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
    891a:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
    891e:	4620      	mov	r0, r4
    8920:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    8922:	692d      	ldr	r5, [r5, #16]
    8924:	e7ed      	b.n	8902 <notify_le_param_updated+0x4e>
		if (cb->le_param_updated) {
    8926:	68ee      	ldr	r6, [r5, #12]
    8928:	b13e      	cbz	r6, 893a <notify_le_param_updated+0x86>
			cb->le_param_updated(conn, conn->le.interval,
    892a:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    892e:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
    8932:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
    8936:	4620      	mov	r0, r4
    8938:	47b0      	blx	r6
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    893a:	3514      	adds	r5, #20
    893c:	e7e4      	b.n	8908 <notify_le_param_updated+0x54>
    893e:	bf00      	nop
    8940:	2000261c 	.word	0x2000261c
    8944:	0002d81c 	.word	0x0002d81c
    8948:	0002d844 	.word	0x0002d844

0000894c <le_param_req>:
	}
}
#endif

bool le_param_req(struct bt_conn *conn, struct bt_le_conn_param *param)
{
    894c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8950:	4607      	mov	r7, r0
	struct bt_conn_cb *cb;

	if (!bt_le_conn_params_valid(param)) {
    8952:	4608      	mov	r0, r1
{
    8954:	460c      	mov	r4, r1
	if (!bt_le_conn_params_valid(param)) {
    8956:	f01f fab8 	bl	27eca <bt_le_conn_params_valid>
    895a:	4605      	mov	r5, r0
    895c:	b918      	cbnz	r0, 8966 <le_param_req+0x1a>
		return false;
    895e:	2500      	movs	r5, #0
		}
	}

	/* Default to accepting if there's no app callback */
	return true;
}
    8960:	4628      	mov	r0, r5
    8962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
    8966:	4b13      	ldr	r3, [pc, #76]	; (89b4 <le_param_req+0x68>)
    8968:	681e      	ldr	r6, [r3, #0]
    896a:	b946      	cbnz	r6, 897e <le_param_req+0x32>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    896c:	4e12      	ldr	r6, [pc, #72]	; (89b8 <le_param_req+0x6c>)
    896e:	f8df 804c 	ldr.w	r8, [pc, #76]	; 89bc <le_param_req+0x70>
    8972:	4546      	cmp	r6, r8
    8974:	d2f4      	bcs.n	8960 <le_param_req+0x14>
		if (!cb->le_param_req) {
    8976:	68b3      	ldr	r3, [r6, #8]
    8978:	b983      	cbnz	r3, 899c <le_param_req+0x50>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    897a:	3614      	adds	r6, #20
    897c:	e7f9      	b.n	8972 <le_param_req+0x26>
		if (!cb->le_param_req) {
    897e:	68b3      	ldr	r3, [r6, #8]
    8980:	b90b      	cbnz	r3, 8986 <le_param_req+0x3a>
	for (cb = callback_list; cb; cb = cb->_next) {
    8982:	6936      	ldr	r6, [r6, #16]
    8984:	e7f1      	b.n	896a <le_param_req+0x1e>
		if (!cb->le_param_req(conn, param)) {
    8986:	4621      	mov	r1, r4
    8988:	4638      	mov	r0, r7
    898a:	4798      	blx	r3
    898c:	2800      	cmp	r0, #0
    898e:	d0e6      	beq.n	895e <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
    8990:	4620      	mov	r0, r4
    8992:	f01f fa9a 	bl	27eca <bt_le_conn_params_valid>
    8996:	2800      	cmp	r0, #0
    8998:	d1f3      	bne.n	8982 <le_param_req+0x36>
    899a:	e7e0      	b.n	895e <le_param_req+0x12>
		if (!cb->le_param_req(conn, param)) {
    899c:	4621      	mov	r1, r4
    899e:	4638      	mov	r0, r7
    89a0:	4798      	blx	r3
    89a2:	2800      	cmp	r0, #0
    89a4:	d0db      	beq.n	895e <le_param_req+0x12>
		if (!bt_le_conn_params_valid(param)) {
    89a6:	4620      	mov	r0, r4
    89a8:	f01f fa8f 	bl	27eca <bt_le_conn_params_valid>
    89ac:	2800      	cmp	r0, #0
    89ae:	d1e4      	bne.n	897a <le_param_req+0x2e>
    89b0:	e7d5      	b.n	895e <le_param_req+0x12>
    89b2:	bf00      	nop
    89b4:	2000261c 	.word	0x2000261c
    89b8:	0002d81c 	.word	0x0002d81c
    89bc:	0002d844 	.word	0x0002d844

000089c0 <bt_conn_add_le>:

	return false;
}

struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
{
    89c0:	b570      	push	{r4, r5, r6, lr}
    89c2:	4606      	mov	r6, r0
    89c4:	460d      	mov	r5, r1
	return bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
    89c6:	4809      	ldr	r0, [pc, #36]	; (89ec <bt_conn_add_le+0x2c>)
    89c8:	2101      	movs	r1, #1
    89ca:	f7ff fcd7 	bl	837c <bt_conn_new>
	struct bt_conn *conn = acl_conn_new();

	if (!conn) {
    89ce:	4604      	mov	r4, r0
    89d0:	b150      	cbz	r0, 89e8 <bt_conn_add_le+0x28>
		return NULL;
	}

	conn->id = id;
    89d2:	7206      	strb	r6, [r0, #8]
    89d4:	2207      	movs	r2, #7
    89d6:	4629      	mov	r1, r5
    89d8:	3088      	adds	r0, #136	; 0x88
    89da:	f01e ff49 	bl	27870 <memcpy>
	bt_addr_le_copy(&conn->le.dst, peer);
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
	conn->required_sec_level = BT_SECURITY_L1;
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
    89de:	2301      	movs	r3, #1
    89e0:	70a3      	strb	r3, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    89e2:	4b03      	ldr	r3, [pc, #12]	; (89f0 <bt_conn_add_le+0x30>)
    89e4:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
    89e8:	4620      	mov	r0, r4
    89ea:	bd70      	pop	{r4, r5, r6, pc}
    89ec:	200016e0 	.word	0x200016e0
    89f0:	00280018 	.word	0x00280018

000089f4 <bt_conn_lookup_addr_le>:

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
    89f4:	b570      	push	{r4, r5, r6, lr}
    89f6:	4605      	mov	r5, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    89f8:	480c      	ldr	r0, [pc, #48]	; (8a2c <bt_conn_lookup_addr_le+0x38>)
{
    89fa:	460e      	mov	r6, r1
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    89fc:	f01f fc5c 	bl	282b8 <bt_conn_ref>

		if (!conn) {
    8a00:	4604      	mov	r4, r0
    8a02:	b128      	cbz	r0, 8a10 <bt_conn_lookup_addr_le+0x1c>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
    8a04:	7883      	ldrb	r3, [r0, #2]
    8a06:	2b01      	cmp	r3, #1
    8a08:	d004      	beq.n	8a14 <bt_conn_lookup_addr_le+0x20>
			bt_conn_unref(conn);
    8a0a:	f01f fc70 	bl	282ee <bt_conn_unref>
		}

		return conn;
	}

	return NULL;
    8a0e:	2400      	movs	r4, #0
}
    8a10:	4620      	mov	r0, r4
    8a12:	bd70      	pop	{r4, r5, r6, pc}
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
    8a14:	4629      	mov	r1, r5
    8a16:	4632      	mov	r2, r6
    8a18:	f01f fcd4 	bl	283c4 <bt_conn_is_peer_addr_le>
    8a1c:	4605      	mov	r5, r0
    8a1e:	2800      	cmp	r0, #0
    8a20:	d1f6      	bne.n	8a10 <bt_conn_lookup_addr_le+0x1c>
			bt_conn_unref(conn);
    8a22:	4620      	mov	r0, r4
    8a24:	f01f fc63 	bl	282ee <bt_conn_unref>
	return NULL;
    8a28:	462c      	mov	r4, r5
			continue;
    8a2a:	e7f1      	b.n	8a10 <bt_conn_lookup_addr_le+0x1c>
    8a2c:	200016e0 	.word	0x200016e0

00008a30 <bt_conn_exists_le>:
{
    8a30:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
    8a32:	f7ff ffdf 	bl	89f4 <bt_conn_lookup_addr_le>
	if (conn) {
    8a36:	4604      	mov	r4, r0
    8a38:	b1a0      	cbz	r0, 8a64 <bt_conn_exists_le+0x34>
		BT_WARN("Found valid connection in %s state",
    8a3a:	7a83      	ldrb	r3, [r0, #10]
    8a3c:	490a      	ldr	r1, [pc, #40]	; (8a68 <bt_conn_exists_le+0x38>)
    8a3e:	2b08      	cmp	r3, #8
    8a40:	bf96      	itet	ls
    8a42:	4a0a      	ldrls	r2, [pc, #40]	; (8a6c <bt_conn_exists_le+0x3c>)
    8a44:	4b0a      	ldrhi	r3, [pc, #40]	; (8a70 <bt_conn_exists_le+0x40>)
    8a46:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    8a4a:	9302      	str	r3, [sp, #8]
    8a4c:	4b09      	ldr	r3, [pc, #36]	; (8a74 <bt_conn_exists_le+0x44>)
    8a4e:	9301      	str	r3, [sp, #4]
    8a50:	2300      	movs	r3, #0
    8a52:	4618      	mov	r0, r3
    8a54:	9300      	str	r3, [sp, #0]
    8a56:	2202      	movs	r2, #2
    8a58:	f01f fbd2 	bl	28200 <z_log_msg2_runtime_create.constprop.0>
		bt_conn_unref(conn);
    8a5c:	4620      	mov	r0, r4
    8a5e:	f01f fc46 	bl	282ee <bt_conn_unref>
		return true;
    8a62:	2001      	movs	r0, #1
}
    8a64:	b004      	add	sp, #16
    8a66:	bd10      	pop	{r4, pc}
    8a68:	0002d9dc 	.word	0x0002d9dc
    8a6c:	0002e1d0 	.word	0x0002e1d0
    8a70:	0002fff8 	.word	0x0002fff8
    8a74:	0003006f 	.word	0x0003006f

00008a78 <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
    8a78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8a7a:	4605      	mov	r5, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    8a7c:	480e      	ldr	r0, [pc, #56]	; (8ab8 <bt_conn_lookup_state_le+0x40>)
{
    8a7e:	460e      	mov	r6, r1
    8a80:	4617      	mov	r7, r2
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    8a82:	f01f fc19 	bl	282b8 <bt_conn_ref>

		if (!conn) {
    8a86:	4604      	mov	r4, r0
    8a88:	b1a0      	cbz	r0, 8ab4 <bt_conn_lookup_state_le+0x3c>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
    8a8a:	7883      	ldrb	r3, [r0, #2]
    8a8c:	2b01      	cmp	r3, #1
    8a8e:	d003      	beq.n	8a98 <bt_conn_lookup_state_le+0x20>
			bt_conn_unref(conn);
			continue;
		}

		if (!(conn->state == state && conn->id == id)) {
			bt_conn_unref(conn);
    8a90:	f01f fc2d 	bl	282ee <bt_conn_unref>
		}

		return conn;
	}

	return NULL;
    8a94:	2400      	movs	r4, #0
			continue;
    8a96:	e00d      	b.n	8ab4 <bt_conn_lookup_state_le+0x3c>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
    8a98:	b136      	cbz	r6, 8aa8 <bt_conn_lookup_state_le+0x30>
    8a9a:	4632      	mov	r2, r6
    8a9c:	4629      	mov	r1, r5
    8a9e:	f01f fc91 	bl	283c4 <bt_conn_is_peer_addr_le>
    8aa2:	b908      	cbnz	r0, 8aa8 <bt_conn_lookup_state_le+0x30>
			bt_conn_unref(conn);
    8aa4:	4620      	mov	r0, r4
    8aa6:	e7f3      	b.n	8a90 <bt_conn_lookup_state_le+0x18>
		if (!(conn->state == state && conn->id == id)) {
    8aa8:	7aa3      	ldrb	r3, [r4, #10]
    8aaa:	42bb      	cmp	r3, r7
    8aac:	d1fa      	bne.n	8aa4 <bt_conn_lookup_state_le+0x2c>
    8aae:	7a23      	ldrb	r3, [r4, #8]
    8ab0:	42ab      	cmp	r3, r5
    8ab2:	d1f7      	bne.n	8aa4 <bt_conn_lookup_state_le+0x2c>
}
    8ab4:	4620      	mov	r0, r4
    8ab6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8ab8:	200016e0 	.word	0x200016e0

00008abc <bt_conn_get_info>:
{
	return &conn->le.dst;
}

int bt_conn_get_info(const struct bt_conn *conn, struct bt_conn_info *info)
{
    8abc:	b510      	push	{r4, lr}
	info->type = conn->type;
    8abe:	7882      	ldrb	r2, [r0, #2]
    8ac0:	700a      	strb	r2, [r1, #0]
	info->role = conn->role;
    8ac2:	78c4      	ldrb	r4, [r0, #3]
    8ac4:	704c      	strb	r4, [r1, #1]
	info->id = conn->id;
    8ac6:	7a03      	ldrb	r3, [r0, #8]
    8ac8:	708b      	strb	r3, [r1, #2]

	switch (conn->type) {
    8aca:	2a01      	cmp	r2, #1
    8acc:	d11c      	bne.n	8b08 <bt_conn_get_info+0x4c>
	case BT_CONN_TYPE_LE:
		info->le.dst = &conn->le.dst;
    8ace:	f100 0288 	add.w	r2, r0, #136	; 0x88
    8ad2:	608a      	str	r2, [r1, #8]
		info->le.src = &bt_dev.id_addr[conn->id];
    8ad4:	4a0e      	ldr	r2, [pc, #56]	; (8b10 <bt_conn_get_info+0x54>)
    8ad6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    8ada:	4413      	add	r3, r2
    8adc:	604b      	str	r3, [r1, #4]
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
			info->le.local = &conn->le.init_addr;
			info->le.remote = &conn->le.resp_addr;
    8ade:	f100 0296 	add.w	r2, r0, #150	; 0x96
			info->le.local = &conn->le.init_addr;
    8ae2:	f100 038f 	add.w	r3, r0, #143	; 0x8f
		if (conn->role == BT_HCI_ROLE_CENTRAL) {
    8ae6:	b964      	cbnz	r4, 8b02 <bt_conn_get_info+0x46>
			info->le.remote = &conn->le.resp_addr;
    8ae8:	e9c1 3203 	strd	r3, r2, [r1, #12]
		} else {
			info->le.local = &conn->le.resp_addr;
			info->le.remote = &conn->le.init_addr;
		}
		info->le.interval = conn->le.interval;
    8aec:	f8b0 309e 	ldrh.w	r3, [r0, #158]	; 0x9e
    8af0:	828b      	strh	r3, [r1, #20]
		info->le.latency = conn->le.latency;
    8af2:	f8b0 30a4 	ldrh.w	r3, [r0, #164]	; 0xa4
    8af6:	82cb      	strh	r3, [r1, #22]
		info->le.timeout = conn->le.timeout;
    8af8:	f8b0 30a6 	ldrh.w	r3, [r0, #166]	; 0xa6
    8afc:	830b      	strh	r3, [r1, #24]
		info->le.phy = &conn->le.phy;
#endif
#if defined(CONFIG_BT_USER_DATA_LEN_UPDATE)
		info->le.data_len = &conn->le.data_len;
#endif
		return 0;
    8afe:	2000      	movs	r0, #0
		return 0;
#endif
	}

	return -EINVAL;
}
    8b00:	bd10      	pop	{r4, pc}
			info->le.remote = &conn->le.init_addr;
    8b02:	e9c1 2303 	strd	r2, r3, [r1, #12]
    8b06:	e7f1      	b.n	8aec <bt_conn_get_info+0x30>
	return -EINVAL;
    8b08:	f06f 0015 	mvn.w	r0, #21
    8b0c:	e7f8      	b.n	8b00 <bt_conn_get_info+0x44>
    8b0e:	bf00      	nop
    8b10:	20000080 	.word	0x20000080

00008b14 <send_conn_le_param_update>:
{
    8b14:	b538      	push	{r3, r4, r5, lr}
    8b16:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
    8b18:	4608      	mov	r0, r1
{
    8b1a:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    8b1c:	f01f f9d5 	bl	27eca <bt_le_conn_params_valid>
    8b20:	b348      	cbz	r0, 8b76 <send_conn_le_param_update+0x62>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    8b22:	4b16      	ldr	r3, [pc, #88]	; (8b7c <send_conn_le_param_update+0x68>)
    8b24:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
    8b28:	0799      	lsls	r1, r3, #30
    8b2a:	d407      	bmi.n	8b3c <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
    8b2c:	78e3      	ldrb	r3, [r4, #3]
    8b2e:	b183      	cbz	r3, 8b52 <send_conn_le_param_update+0x3e>
	return bt_l2cap_update_conn_param(conn, param);
    8b30:	4629      	mov	r1, r5
    8b32:	4620      	mov	r0, r4
}
    8b34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
    8b38:	f000 bac4 	b.w	90c4 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    8b3c:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    8b40:	079a      	lsls	r2, r3, #30
    8b42:	d5f3      	bpl.n	8b2c <send_conn_le_param_update+0x18>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    8b44:	f3bf 8f5b 	dmb	ish
    8b48:	6863      	ldr	r3, [r4, #4]
    8b4a:	f3bf 8f5b 	dmb	ish
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    8b4e:	055b      	lsls	r3, r3, #21
    8b50:	d4ec      	bmi.n	8b2c <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
    8b52:	4629      	mov	r1, r5
    8b54:	4620      	mov	r0, r4
    8b56:	f01f fc55 	bl	28404 <bt_conn_le_conn_update>
		if (rc == 0) {
    8b5a:	b958      	cbnz	r0, 8b74 <send_conn_le_param_update+0x60>
			conn->le.interval_min = param->interval_min;
    8b5c:	882b      	ldrh	r3, [r5, #0]
    8b5e:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
			conn->le.interval_max = param->interval_max;
    8b62:	886b      	ldrh	r3, [r5, #2]
    8b64:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
			conn->le.pending_latency = param->latency;
    8b68:	88ab      	ldrh	r3, [r5, #4]
    8b6a:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.pending_timeout = param->timeout;
    8b6e:	88eb      	ldrh	r3, [r5, #6]
    8b70:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
}
    8b74:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    8b76:	f06f 0015 	mvn.w	r0, #21
    8b7a:	e7fb      	b.n	8b74 <send_conn_le_param_update+0x60>
    8b7c:	20000080 	.word	0x20000080

00008b80 <deferred_work>:
{
    8b80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
    8b82:	f810 3c4e 	ldrb.w	r3, [r0, #-78]
{
    8b86:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(dwork, struct bt_conn, deferred_work);
    8b88:	f1a0 0558 	sub.w	r5, r0, #88	; 0x58
	if (conn->state == BT_CONN_DISCONNECTED) {
    8b8c:	b9fb      	cbnz	r3, 8bce <deferred_work+0x4e>
		bt_l2cap_disconnected(conn);
    8b8e:	4628      	mov	r0, r5
    8b90:	f01f fc9a 	bl	284c8 <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
    8b94:	4b2c      	ldr	r3, [pc, #176]	; (8c48 <deferred_work+0xc8>)
    8b96:	681e      	ldr	r6, [r3, #0]
    8b98:	b94e      	cbnz	r6, 8bae <deferred_work+0x2e>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    8b9a:	4e2c      	ldr	r6, [pc, #176]	; (8c4c <deferred_work+0xcc>)
    8b9c:	4f2c      	ldr	r7, [pc, #176]	; (8c50 <deferred_work+0xd0>)
    8b9e:	42be      	cmp	r6, r7
    8ba0:	d30d      	bcc.n	8bbe <deferred_work+0x3e>
		bt_conn_unref(conn);
    8ba2:	4628      	mov	r0, r5
}
    8ba4:	b003      	add	sp, #12
    8ba6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
    8baa:	f01f bba0 	b.w	282ee <bt_conn_unref>
		if (cb->disconnected) {
    8bae:	6873      	ldr	r3, [r6, #4]
    8bb0:	b11b      	cbz	r3, 8bba <deferred_work+0x3a>
			cb->disconnected(conn, conn->err);
    8bb2:	f814 1c4f 	ldrb.w	r1, [r4, #-79]
    8bb6:	4628      	mov	r0, r5
    8bb8:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    8bba:	6936      	ldr	r6, [r6, #16]
    8bbc:	e7ec      	b.n	8b98 <deferred_work+0x18>
		if (cb->disconnected) {
    8bbe:	6873      	ldr	r3, [r6, #4]
    8bc0:	b11b      	cbz	r3, 8bca <deferred_work+0x4a>
			cb->disconnected(conn, conn->err);
    8bc2:	f814 1c4f 	ldrb.w	r1, [r4, #-79]
    8bc6:	4628      	mov	r0, r5
    8bc8:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    8bca:	3614      	adds	r6, #20
    8bcc:	e7e7      	b.n	8b9e <deferred_work+0x1e>
	if (conn->type != BT_CONN_TYPE_LE) {
    8bce:	f810 3c56 	ldrb.w	r3, [r0, #-86]
    8bd2:	2b01      	cmp	r3, #1
    8bd4:	d12f      	bne.n	8c36 <deferred_work+0xb6>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8bd6:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(conn->flags,
    8bda:	f1a0 0654 	sub.w	r6, r0, #84	; 0x54
    8bde:	e856 3f00 	ldrex	r3, [r6]
    8be2:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    8be6:	e846 2100 	strex	r1, r2, [r6]
    8bea:	2900      	cmp	r1, #0
    8bec:	d1f7      	bne.n	8bde <deferred_work+0x5e>
    8bee:	f3bf 8f5b 	dmb	ish
    8bf2:	059b      	lsls	r3, r3, #22
    8bf4:	d521      	bpl.n	8c3a <deferred_work+0xba>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
    8bf6:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
    8bfa:	f8ad 3000 	strh.w	r3, [sp]
    8bfe:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
    8c02:	f8ad 3002 	strh.w	r3, [sp, #2]
    8c06:	f8b4 3050 	ldrh.w	r3, [r4, #80]	; 0x50
    8c0a:	f8ad 3004 	strh.w	r3, [sp, #4]
    8c0e:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
    8c12:	f8ad 3006 	strh.w	r3, [sp, #6]
		send_conn_le_param_update(conn, param);
    8c16:	4669      	mov	r1, sp
    8c18:	4628      	mov	r0, r5
    8c1a:	f7ff ff7b 	bl	8b14 <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8c1e:	f3bf 8f5b 	dmb	ish
    8c22:	e856 3f00 	ldrex	r3, [r6]
    8c26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    8c2a:	e846 3200 	strex	r2, r3, [r6]
    8c2e:	2a00      	cmp	r2, #0
    8c30:	d1f7      	bne.n	8c22 <deferred_work+0xa2>
    8c32:	f3bf 8f5b 	dmb	ish
}
    8c36:	b003      	add	sp, #12
    8c38:	bdf0      	pop	{r4, r5, r6, r7, pc}
		param = BT_LE_CONN_PARAM(
    8c3a:	4a06      	ldr	r2, [pc, #24]	; (8c54 <deferred_work+0xd4>)
    8c3c:	6810      	ldr	r0, [r2, #0]
    8c3e:	6851      	ldr	r1, [r2, #4]
    8c40:	466b      	mov	r3, sp
    8c42:	c303      	stmia	r3!, {r0, r1}
    8c44:	e7e7      	b.n	8c16 <deferred_work+0x96>
    8c46:	bf00      	nop
    8c48:	2000261c 	.word	0x2000261c
    8c4c:	0002d81c 	.word	0x0002d81c
    8c50:	0002d844 	.word	0x0002d844
    8c54:	0002dd48 	.word	0x0002dd48

00008c58 <bt_conn_create_frag_timeout>:
						  k_timeout_t timeout,
						  const char *func, int line)
#else
struct net_buf *bt_conn_create_frag_timeout(size_t reserve, k_timeout_t timeout)
#endif
{
    8c58:	4601      	mov	r1, r0

#if defined(CONFIG_NET_BUF_LOG)
	return bt_conn_create_pdu_timeout_debug(pool, reserve, timeout,
						func, line);
#else
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    8c5a:	4801      	ldr	r0, [pc, #4]	; (8c60 <bt_conn_create_frag_timeout+0x8>)
    8c5c:	f7ff be06 	b.w	886c <bt_conn_create_pdu_timeout>
    8c60:	20001010 	.word	0x20001010

00008c64 <create_frag>:
{
    8c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8c68:	4606      	mov	r6, r0
		frag = bt_conn_create_frag(0);
    8c6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8c6e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8c72:	2000      	movs	r0, #0
{
    8c74:	460c      	mov	r4, r1
		frag = bt_conn_create_frag(0);
    8c76:	f7ff ffef 	bl	8c58 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
    8c7a:	7ab3      	ldrb	r3, [r6, #10]
    8c7c:	2b07      	cmp	r3, #7
		frag = bt_conn_create_frag(0);
    8c7e:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
    8c80:	f04f 0600 	mov.w	r6, #0
    8c84:	d005      	beq.n	8c92 <create_frag+0x2e>
		net_buf_unref(frag);
    8c86:	f017 fe05 	bl	20894 <net_buf_unref>
		return NULL;
    8c8a:	4635      	mov	r5, r6
}
    8c8c:	4628      	mov	r0, r5
    8c8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
    8c92:	6146      	str	r6, [r0, #20]
	return net_buf_simple_tailroom(&buf->b);
    8c94:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.acl_mtu;
    8c98:	4e0c      	ldr	r6, [pc, #48]	; (8ccc <create_frag+0x68>)
    8c9a:	4638      	mov	r0, r7
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    8c9c:	f8b6 80fc 	ldrh.w	r8, [r6, #252]	; 0xfc
    8ca0:	f023 f8f3 	bl	2be8a <net_buf_simple_tailroom>
    8ca4:	4580      	cmp	r8, r0
    8ca6:	d20c      	bcs.n	8cc2 <create_frag+0x5e>
	return bt_dev.le.acl_mtu;
    8ca8:	f8b6 60fc 	ldrh.w	r6, [r6, #252]	; 0xfc
	return net_buf_simple_add_mem(&buf->b, mem, len);
    8cac:	f854 1f08 	ldr.w	r1, [r4, #8]!
    8cb0:	4632      	mov	r2, r6
    8cb2:	4638      	mov	r0, r7
    8cb4:	f023 f848 	bl	2bd48 <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
    8cb8:	4631      	mov	r1, r6
    8cba:	4620      	mov	r0, r4
    8cbc:	f023 f8ae 	bl	2be1c <net_buf_simple_pull>
    8cc0:	e7e4      	b.n	8c8c <create_frag+0x28>
	return net_buf_simple_tailroom(&buf->b);
    8cc2:	4638      	mov	r0, r7
    8cc4:	f023 f8e1 	bl	2be8a <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    8cc8:	b286      	uxth	r6, r0
    8cca:	e7ef      	b.n	8cac <create_frag+0x48>
    8ccc:	20000080 	.word	0x20000080

00008cd0 <bt_conn_process_tx>:
{
    8cd0:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
    8cd2:	7a83      	ldrb	r3, [r0, #10]
{
    8cd4:	4604      	mov	r4, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    8cd6:	b993      	cbnz	r3, 8cfe <bt_conn_process_tx+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    8cd8:	f3bf 8f5b 	dmb	ish
    8cdc:	1d03      	adds	r3, r0, #4
    8cde:	e853 2f00 	ldrex	r2, [r3]
    8ce2:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    8ce6:	e843 1500 	strex	r5, r1, [r3]
    8cea:	2d00      	cmp	r5, #0
    8cec:	d1f7      	bne.n	8cde <bt_conn_process_tx+0xe>
    8cee:	f3bf 8f5b 	dmb	ish
    8cf2:	0653      	lsls	r3, r2, #25
    8cf4:	d503      	bpl.n	8cfe <bt_conn_process_tx+0x2e>
}
    8cf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		conn_cleanup(conn);
    8cfa:	f01f babf 	b.w	2827c <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    8cfe:	2200      	movs	r2, #0
    8d00:	2300      	movs	r3, #0
    8d02:	f104 0038 	add.w	r0, r4, #56	; 0x38
    8d06:	f022 ff93 	bl	2bc30 <net_buf_get>
	BT_ASSERT(buf);
    8d0a:	4605      	mov	r5, r0
    8d0c:	b960      	cbnz	r0, 8d28 <bt_conn_process_tx+0x58>
    8d0e:	4a1f      	ldr	r2, [pc, #124]	; (8d8c <bt_conn_process_tx+0xbc>)
    8d10:	491f      	ldr	r1, [pc, #124]	; (8d90 <bt_conn_process_tx+0xc0>)
    8d12:	4820      	ldr	r0, [pc, #128]	; (8d94 <bt_conn_process_tx+0xc4>)
    8d14:	f240 23e7 	movw	r3, #743	; 0x2e7
    8d18:	f01c fa50 	bl	251bc <printk>
    8d1c:	4040      	eors	r0, r0
    8d1e:	f380 8811 	msr	BASEPRI, r0
    8d22:	f04f 0003 	mov.w	r0, #3
    8d26:	df02      	svc	2
	return bt_dev.le.acl_mtu;
    8d28:	4e1b      	ldr	r6, [pc, #108]	; (8d98 <bt_conn_process_tx+0xc8>)
	if (buf->len <= conn_mtu(conn)) {
    8d2a:	89aa      	ldrh	r2, [r5, #12]
    8d2c:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
    8d30:	429a      	cmp	r2, r3
    8d32:	d807      	bhi.n	8d44 <bt_conn_process_tx+0x74>
		return send_frag(conn, buf, FRAG_SINGLE, false);
    8d34:	2300      	movs	r3, #0
    8d36:	2202      	movs	r2, #2
	return send_frag(conn, buf, FRAG_END, false);
    8d38:	4629      	mov	r1, r5
    8d3a:	4620      	mov	r0, r4
    8d3c:	f7ff fa80 	bl	8240 <send_frag>
	if (!send_buf(conn, buf)) {
    8d40:	b130      	cbz	r0, 8d50 <bt_conn_process_tx+0x80>
}
    8d42:	bd70      	pop	{r4, r5, r6, pc}
	frag = create_frag(conn, buf);
    8d44:	4629      	mov	r1, r5
    8d46:	4620      	mov	r0, r4
    8d48:	f7ff ff8c 	bl	8c64 <create_frag>
	if (!frag) {
    8d4c:	4601      	mov	r1, r0
    8d4e:	b920      	cbnz	r0, 8d5a <bt_conn_process_tx+0x8a>
		net_buf_unref(buf);
    8d50:	4628      	mov	r0, r5
}
    8d52:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		net_buf_unref(buf);
    8d56:	f017 bd9d 	b.w	20894 <net_buf_unref>
	if (!send_frag(conn, frag, FRAG_START, true)) {
    8d5a:	2301      	movs	r3, #1
    8d5c:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
    8d5e:	4620      	mov	r0, r4
    8d60:	f7ff fa6e 	bl	8240 <send_frag>
    8d64:	2800      	cmp	r0, #0
    8d66:	d0f3      	beq.n	8d50 <bt_conn_process_tx+0x80>
	while (buf->len > conn_mtu(conn)) {
    8d68:	89aa      	ldrh	r2, [r5, #12]
    8d6a:	f8b6 30fc 	ldrh.w	r3, [r6, #252]	; 0xfc
    8d6e:	429a      	cmp	r2, r3
    8d70:	d802      	bhi.n	8d78 <bt_conn_process_tx+0xa8>
	return send_frag(conn, buf, FRAG_END, false);
    8d72:	2300      	movs	r3, #0
    8d74:	2203      	movs	r2, #3
    8d76:	e7df      	b.n	8d38 <bt_conn_process_tx+0x68>
		frag = create_frag(conn, buf);
    8d78:	4629      	mov	r1, r5
    8d7a:	4620      	mov	r0, r4
    8d7c:	f7ff ff72 	bl	8c64 <create_frag>
		if (!frag) {
    8d80:	4601      	mov	r1, r0
    8d82:	2800      	cmp	r0, #0
    8d84:	d0e4      	beq.n	8d50 <bt_conn_process_tx+0x80>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
    8d86:	2301      	movs	r3, #1
    8d88:	461a      	mov	r2, r3
    8d8a:	e7e8      	b.n	8d5e <bt_conn_process_tx+0x8e>
    8d8c:	00030092 	.word	0x00030092
    8d90:	0002f619 	.word	0x0002f619
    8d94:	0002f8b5 	.word	0x0002f8b5
    8d98:	20000080 	.word	0x20000080

00008d9c <bt_conn_init>:

	return bt_conn_ref(&acl_conns[index]);
}

int bt_conn_init(void)
{
    8d9c:	b570      	push	{r4, r5, r6, lr}
    8d9e:	4d0b      	ldr	r5, [pc, #44]	; (8dcc <bt_conn_init+0x30>)
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
    8da0:	4e0b      	ldr	r6, [pc, #44]	; (8dd0 <bt_conn_init+0x34>)
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
    8da2:	2400      	movs	r4, #0
		k_fifo_put(&free_tx, &conn_tx[i]);
    8da4:	4629      	mov	r1, r5
    8da6:	4630      	mov	r0, r6
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
    8da8:	3401      	adds	r4, #1
		k_fifo_put(&free_tx, &conn_tx[i]);
    8daa:	f023 ff17 	bl	2cbdc <k_queue_append>
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
    8dae:	2c05      	cmp	r4, #5
    8db0:	f105 0510 	add.w	r5, r5, #16
    8db4:	d1f6      	bne.n	8da4 <bt_conn_init+0x8>
	}

	bt_att_init();
    8db6:	f01f ff39 	bl	28c2c <bt_att_init>

	err = bt_smp_init();
    8dba:	f020 fab3 	bl	29324 <bt_smp_init>
	if (err) {
    8dbe:	4604      	mov	r4, r0
    8dc0:	b908      	cbnz	r0, 8dc6 <bt_conn_init+0x2a>
		return err;
	}

	bt_l2cap_init();
    8dc2:	f01f fbc4 	bl	2854e <bt_l2cap_init>
			bt_conn_unref(conn);
		}
	}

	return 0;
}
    8dc6:	4620      	mov	r0, r4
    8dc8:	bd70      	pop	{r4, r5, r6, pc}
    8dca:	bf00      	nop
    8dcc:	20002620 	.word	0x20002620
    8dd0:	20000f5c 	.word	0x20000f5c

00008dd4 <l2cap_create_le_sig_pdu.constprop.0>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
		bt_l2cap_chan_del(chan);
	}
}

static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
    8dd4:	b5f0      	push	{r4, r5, r6, r7, lr}

struct net_buf *bt_l2cap_create_pdu_timeout(struct net_buf_pool *pool,
					    size_t reserve,
					    k_timeout_t timeout)
{
	return bt_conn_create_pdu_timeout(pool,
    8dd6:	2300      	movs	r3, #0
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
    8dd8:	b089      	sub	sp, #36	; 0x24
    8dda:	4605      	mov	r5, r0
    8ddc:	460f      	mov	r7, r1
    8dde:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
    8de0:	2104      	movs	r1, #4
    8de2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    8de6:	2000      	movs	r0, #0
    8de8:	f7ff fd40 	bl	886c <bt_conn_create_pdu_timeout>
	if (!buf) {
    8dec:	4604      	mov	r4, r0
    8dee:	b970      	cbnz	r0, 8e0e <l2cap_create_le_sig_pdu.constprop.0+0x3a>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    8df0:	4b0b      	ldr	r3, [pc, #44]	; (8e20 <l2cap_create_le_sig_pdu.constprop.0+0x4c>)
    8df2:	480c      	ldr	r0, [pc, #48]	; (8e24 <l2cap_create_le_sig_pdu.constprop.0+0x50>)
    8df4:	e9cd 3506 	strd	r3, r5, [sp, #24]
    8df8:	aa05      	add	r2, sp, #20
    8dfa:	2303      	movs	r3, #3
    8dfc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    8e00:	9301      	str	r3, [sp, #4]
    8e02:	9305      	str	r3, [sp, #20]
    8e04:	f01f fb2a 	bl	2845c <z_log_msg2_static_create.constprop.0>
}
    8e08:	4620      	mov	r0, r4
    8e0a:	b009      	add	sp, #36	; 0x24
    8e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return net_buf_simple_add(&buf->b, len);
    8e0e:	2104      	movs	r1, #4
    8e10:	3008      	adds	r0, #8
    8e12:	f022 ff93 	bl	2bd3c <net_buf_simple_add>
	hdr->code = code;
    8e16:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
    8e18:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
    8e1a:	8046      	strh	r6, [r0, #2]
	return buf;
    8e1c:	e7f4      	b.n	8e08 <l2cap_create_le_sig_pdu.constprop.0+0x34>
    8e1e:	bf00      	nop
    8e20:	0003011f 	.word	0x0003011f
    8e24:	0002dac4 	.word	0x0002dac4

00008e28 <l2cap_accept>:
	 */
	(void)k_work_cancel_delayable(&chan->rtx_work);
}

static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    8e28:	b500      	push	{lr}
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
    8e2a:	4a0d      	ldr	r2, [pc, #52]	; (8e60 <l2cap_accept+0x38>)
{
    8e2c:	4603      	mov	r3, r0
		if (l2cap->chan.chan.conn) {
    8e2e:	6810      	ldr	r0, [r2, #0]
{
    8e30:	b089      	sub	sp, #36	; 0x24
		if (l2cap->chan.chan.conn) {
    8e32:	b928      	cbnz	r0, 8e40 <l2cap_accept+0x18>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
    8e34:	4b0b      	ldr	r3, [pc, #44]	; (8e64 <l2cap_accept+0x3c>)
    8e36:	6053      	str	r3, [r2, #4]
		*chan = &l2cap->chan.chan;
    8e38:	600a      	str	r2, [r1, #0]
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
}
    8e3a:	b009      	add	sp, #36	; 0x24
    8e3c:	f85d fb04 	ldr.w	pc, [sp], #4
	BT_ERR("No available L2CAP context for conn %p", conn);
    8e40:	4a09      	ldr	r2, [pc, #36]	; (8e68 <l2cap_accept+0x40>)
    8e42:	480a      	ldr	r0, [pc, #40]	; (8e6c <l2cap_accept+0x44>)
    8e44:	e9cd 2306 	strd	r2, r3, [sp, #24]
    8e48:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    8e4c:	2303      	movs	r3, #3
    8e4e:	aa05      	add	r2, sp, #20
    8e50:	9301      	str	r3, [sp, #4]
    8e52:	9305      	str	r3, [sp, #20]
    8e54:	f01f fb02 	bl	2845c <z_log_msg2_static_create.constprop.0>
	return -ENOMEM;
    8e58:	f06f 000b 	mvn.w	r0, #11
    8e5c:	e7ed      	b.n	8e3a <l2cap_accept+0x12>
    8e5e:	bf00      	nop
    8e60:	200017a0 	.word	0x200017a0
    8e64:	0002e214 	.word	0x0002e214
    8e68:	00030147 	.word	0x00030147
    8e6c:	0002dac4 	.word	0x0002dac4

00008e70 <l2cap_rtx_timeout>:
{
    8e70:	b530      	push	{r4, r5, lr}
	struct bt_conn *conn = chan->chan.conn;
    8e72:	4604      	mov	r4, r0
	BT_ERR("chan %p timeout", chan);
    8e74:	4b0c      	ldr	r3, [pc, #48]	; (8ea8 <l2cap_rtx_timeout+0x38>)
	struct bt_conn *conn = chan->chan.conn;
    8e76:	f854 5d10 	ldr.w	r5, [r4, #-16]!
	BT_ERR("chan %p timeout", chan);
    8e7a:	480c      	ldr	r0, [pc, #48]	; (8eac <l2cap_rtx_timeout+0x3c>)
{
    8e7c:	b089      	sub	sp, #36	; 0x24
	BT_ERR("chan %p timeout", chan);
    8e7e:	e9cd 3406 	strd	r3, r4, [sp, #24]
    8e82:	aa05      	add	r2, sp, #20
    8e84:	2303      	movs	r3, #3
    8e86:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    8e8a:	9301      	str	r3, [sp, #4]
    8e8c:	9305      	str	r3, [sp, #20]
    8e8e:	f01f fae5 	bl	2845c <z_log_msg2_static_create.constprop.0>
	bt_l2cap_chan_remove(conn, &chan->chan);
    8e92:	4628      	mov	r0, r5
    8e94:	4621      	mov	r1, r4
    8e96:	f01f fae4 	bl	28462 <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
    8e9a:	4620      	mov	r0, r4
}
    8e9c:	b009      	add	sp, #36	; 0x24
    8e9e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	bt_l2cap_chan_del(&chan->chan);
    8ea2:	f01f bafc 	b.w	2849e <bt_l2cap_chan_del>
    8ea6:	bf00      	nop
    8ea8:	0003016e 	.word	0x0003016e
    8eac:	0002dac4 	.word	0x0002dac4

00008eb0 <bt_l2cap_connected>:
{
    8eb0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    8eb4:	4e29      	ldr	r6, [pc, #164]	; (8f5c <bt_l2cap_connected+0xac>)
    8eb6:	4f2a      	ldr	r7, [pc, #168]	; (8f60 <bt_l2cap_connected+0xb0>)
	k_work_init_delayable(&chan->rtx_work, l2cap_rtx_timeout);
    8eb8:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8f64 <bt_l2cap_connected+0xb4>
{
    8ebc:	4604      	mov	r4, r0
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    8ebe:	42be      	cmp	r6, r7
    8ec0:	d302      	bcc.n	8ec8 <bt_l2cap_connected+0x18>
}
    8ec2:	b003      	add	sp, #12
    8ec4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fchan->accept(conn, &chan) < 0) {
    8ec8:	6873      	ldr	r3, [r6, #4]
    8eca:	a901      	add	r1, sp, #4
    8ecc:	4620      	mov	r0, r4
    8ece:	4798      	blx	r3
    8ed0:	2800      	cmp	r0, #0
    8ed2:	db3d      	blt.n	8f50 <bt_l2cap_connected+0xa0>
		ch = BT_L2CAP_LE_CHAN(chan);
    8ed4:	9d01      	ldr	r5, [sp, #4]
		ch->rx.cid = fchan->cid;
    8ed6:	8833      	ldrh	r3, [r6, #0]
    8ed8:	f8a5 3070 	strh.w	r3, [r5, #112]	; 0x70
		ch->tx.cid = fchan->cid;
    8edc:	f8a5 3080 	strh.w	r3, [r5, #128]	; 0x80
	k_work_init_delayable(&chan->rtx_work, l2cap_rtx_timeout);
    8ee0:	4641      	mov	r1, r8
    8ee2:	f105 0010 	add.w	r0, r5, #16
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
    8ee6:	f8d6 9008 	ldr.w	r9, [r6, #8]
	k_work_init_delayable(&chan->rtx_work, l2cap_rtx_timeout);
    8eea:	f023 ff7e 	bl	2cdea <k_work_init_delayable>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    8eee:	f3bf 8f5b 	dmb	ish
    8ef2:	f105 0368 	add.w	r3, r5, #104	; 0x68
    8ef6:	2200      	movs	r2, #0
    8ef8:	e853 1f00 	ldrex	r1, [r3]
    8efc:	e843 2000 	strex	r0, r2, [r3]
    8f00:	2800      	cmp	r0, #0
    8f02:	d1f9      	bne.n	8ef8 <bt_l2cap_connected+0x48>
    8f04:	f3bf 8f5b 	dmb	ish
	parent->next = child;
    8f08:	60aa      	str	r2, [r5, #8]
	return list->tail;
    8f0a:	6d62      	ldr	r2, [r4, #84]	; 0x54
	sys_slist_append(&conn->channels, &chan->node);
    8f0c:	f105 0308 	add.w	r3, r5, #8
Z_GENLIST_APPEND(slist, snode)
    8f10:	bb02      	cbnz	r2, 8f54 <bt_l2cap_connected+0xa4>
	list->head = node;
    8f12:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
		if (chan->ops->connected) {
    8f16:	9801      	ldr	r0, [sp, #4]
	chan->conn = conn;
    8f18:	602c      	str	r4, [r5, #0]
		if (chan->ops->connected) {
    8f1a:	6843      	ldr	r3, [r0, #4]
	chan->destroy = destroy;
    8f1c:	f8c5 900c 	str.w	r9, [r5, #12]
		if (chan->ops->connected) {
    8f20:	681b      	ldr	r3, [r3, #0]
    8f22:	b103      	cbz	r3, 8f26 <bt_l2cap_connected+0x76>
			chan->ops->connected(chan);
    8f24:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8f26:	9b01      	ldr	r3, [sp, #4]
    8f28:	f3bf 8f5b 	dmb	ish
    8f2c:	3368      	adds	r3, #104	; 0x68
    8f2e:	e853 2f00 	ldrex	r2, [r3]
    8f32:	f042 0201 	orr.w	r2, r2, #1
    8f36:	e843 2100 	strex	r1, r2, [r3]
    8f3a:	2900      	cmp	r1, #0
    8f3c:	d1f7      	bne.n	8f2e <bt_l2cap_connected+0x7e>
    8f3e:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
    8f42:	9801      	ldr	r0, [sp, #4]
    8f44:	6843      	ldr	r3, [r0, #4]
    8f46:	699b      	ldr	r3, [r3, #24]
    8f48:	b113      	cbz	r3, 8f50 <bt_l2cap_connected+0xa0>
			chan->ops->status(chan, chan->status);
    8f4a:	f100 0168 	add.w	r1, r0, #104	; 0x68
    8f4e:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    8f50:	360c      	adds	r6, #12
    8f52:	e7b4      	b.n	8ebe <bt_l2cap_connected+0xe>
	parent->next = child;
    8f54:	6013      	str	r3, [r2, #0]
	list->tail = node;
    8f56:	6563      	str	r3, [r4, #84]	; 0x54
}
    8f58:	e7dd      	b.n	8f16 <bt_l2cap_connected+0x66>
    8f5a:	bf00      	nop
    8f5c:	0002d7f8 	.word	0x0002d7f8
    8f60:	0002d81c 	.word	0x0002d81c
    8f64:	00008e71 	.word	0x00008e71

00008f68 <l2cap_recv>:
{
    8f68:	b5f0      	push	{r4, r5, r6, r7, lr}
    8f6a:	b08b      	sub	sp, #44	; 0x2c
	if (buf->len < sizeof(*hdr)) {
    8f6c:	898b      	ldrh	r3, [r1, #12]
    8f6e:	2b03      	cmp	r3, #3
{
    8f70:	af02      	add	r7, sp, #8
    8f72:	4606      	mov	r6, r0
    8f74:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
    8f76:	d80c      	bhi.n	8f92 <l2cap_recv+0x2a>
		BT_ERR("Too small L2CAP signaling PDU");
    8f78:	4b30      	ldr	r3, [pc, #192]	; (903c <l2cap_recv+0xd4>)
		BT_ERR("Invalid ident value in L2CAP PDU");
    8f7a:	61bb      	str	r3, [r7, #24]
    8f7c:	4830      	ldr	r0, [pc, #192]	; (9040 <l2cap_recv+0xd8>)
    8f7e:	2302      	movs	r3, #2
    8f80:	f107 0214 	add.w	r2, r7, #20
    8f84:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    8f88:	607b      	str	r3, [r7, #4]
    8f8a:	617b      	str	r3, [r7, #20]
    8f8c:	f01f fa66 	bl	2845c <z_log_msg2_static_create.constprop.0>
		return 0;
    8f90:	e01a      	b.n	8fc8 <l2cap_recv+0x60>
	return net_buf_simple_pull_mem(&buf->b, len);
    8f92:	2104      	movs	r1, #4
    8f94:	f105 0008 	add.w	r0, r5, #8
    8f98:	f022 ff48 	bl	2be2c <net_buf_simple_pull_mem>
	if (buf->len != len) {
    8f9c:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(hdr->len);
    8f9e:	8841      	ldrh	r1, [r0, #2]
	if (buf->len != len) {
    8fa0:	4299      	cmp	r1, r3
    8fa2:	4604      	mov	r4, r0
    8fa4:	d014      	beq.n	8fd0 <l2cap_recv+0x68>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    8fa6:	4827      	ldr	r0, [pc, #156]	; (9044 <l2cap_recv+0xdc>)
    8fa8:	466c      	mov	r4, sp
    8faa:	b088      	sub	sp, #32
    8fac:	aa02      	add	r2, sp, #8
    8fae:	e9c2 0304 	strd	r0, r3, [r2, #16]
    8fb2:	2304      	movs	r3, #4
    8fb4:	6191      	str	r1, [r2, #24]
    8fb6:	4822      	ldr	r0, [pc, #136]	; (9040 <l2cap_recv+0xd8>)
    8fb8:	f842 3f0c 	str.w	r3, [r2, #12]!
    8fbc:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    8fc0:	60bb      	str	r3, [r7, #8]
    8fc2:	f01f fa4b 	bl	2845c <z_log_msg2_static_create.constprop.0>
    8fc6:	46a5      	mov	sp, r4
}
    8fc8:	2000      	movs	r0, #0
    8fca:	3724      	adds	r7, #36	; 0x24
    8fcc:	46bd      	mov	sp, r7
    8fce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!hdr->ident) {
    8fd0:	7843      	ldrb	r3, [r0, #1]
    8fd2:	b90b      	cbnz	r3, 8fd8 <l2cap_recv+0x70>
		BT_ERR("Invalid ident value in L2CAP PDU");
    8fd4:	4b1c      	ldr	r3, [pc, #112]	; (9048 <l2cap_recv+0xe0>)
    8fd6:	e7d0      	b.n	8f7a <l2cap_recv+0x12>
	switch (hdr->code) {
    8fd8:	7803      	ldrb	r3, [r0, #0]
    8fda:	2b01      	cmp	r3, #1
    8fdc:	d0f4      	beq.n	8fc8 <l2cap_recv+0x60>
    8fde:	2b13      	cmp	r3, #19
    8fe0:	d103      	bne.n	8fea <l2cap_recv+0x82>
	if (buf->len < sizeof(*rsp)) {
    8fe2:	2901      	cmp	r1, #1
    8fe4:	d8f0      	bhi.n	8fc8 <l2cap_recv+0x60>
		BT_ERR("Too small LE conn param rsp");
    8fe6:	4b19      	ldr	r3, [pc, #100]	; (904c <l2cap_recv+0xe4>)
    8fe8:	e7c7      	b.n	8f7a <l2cap_recv+0x12>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    8fea:	4a19      	ldr	r2, [pc, #100]	; (9050 <l2cap_recv+0xe8>)
    8fec:	4814      	ldr	r0, [pc, #80]	; (9040 <l2cap_recv+0xd8>)
	switch (hdr->code) {
    8fee:	e9c7 2306 	strd	r2, r3, [r7, #24]
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    8ff2:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    8ff6:	2303      	movs	r3, #3
    8ff8:	f107 0214 	add.w	r2, r7, #20
    8ffc:	607b      	str	r3, [r7, #4]
    8ffe:	617b      	str	r3, [r7, #20]
    9000:	f01f fa2c 	bl	2845c <z_log_msg2_static_create.constprop.0>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    9004:	2202      	movs	r2, #2
    9006:	7861      	ldrb	r1, [r4, #1]
		l2cap_send_reject(chan->conn, hdr->ident,
    9008:	6835      	ldr	r5, [r6, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
    900a:	2001      	movs	r0, #1
    900c:	f7ff fee2 	bl	8dd4 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
    9010:	4604      	mov	r4, r0
    9012:	2800      	cmp	r0, #0
    9014:	d0d8      	beq.n	8fc8 <l2cap_recv+0x60>
	return net_buf_simple_add(&buf->b, len);
    9016:	2102      	movs	r1, #2
    9018:	3008      	adds	r0, #8
    901a:	f022 fe8f 	bl	2bd3c <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
    901e:	2300      	movs	r3, #0
    9020:	7003      	strb	r3, [r0, #0]
    9022:	7043      	strb	r3, [r0, #1]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline int bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				struct net_buf *buf)
{
	return bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    9024:	4622      	mov	r2, r4
    9026:	9300      	str	r3, [sp, #0]
    9028:	2105      	movs	r1, #5
    902a:	4628      	mov	r0, r5
    902c:	f01f fa60 	bl	284f0 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
    9030:	2800      	cmp	r0, #0
    9032:	d0c9      	beq.n	8fc8 <l2cap_recv+0x60>
		net_buf_unref(buf);
    9034:	4620      	mov	r0, r4
    9036:	f017 fc2d 	bl	20894 <net_buf_unref>
    903a:	e7c5      	b.n	8fc8 <l2cap_recv+0x60>
    903c:	0003017e 	.word	0x0003017e
    9040:	0002dac4 	.word	0x0002dac4
    9044:	0003019c 	.word	0x0003019c
    9048:	000301bd 	.word	0x000301bd
    904c:	000301de 	.word	0x000301de
    9050:	000301fa 	.word	0x000301fa

00009054 <bt_l2cap_recv>:
{
    9054:	b530      	push	{r4, r5, lr}
	if (buf->len < sizeof(*hdr)) {
    9056:	898b      	ldrh	r3, [r1, #12]
    9058:	2b03      	cmp	r3, #3
{
    905a:	b089      	sub	sp, #36	; 0x24
    905c:	4605      	mov	r5, r0
    905e:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
    9060:	d810      	bhi.n	9084 <bt_l2cap_recv+0x30>
		BT_ERR("Too small L2CAP PDU received");
    9062:	4b15      	ldr	r3, [pc, #84]	; (90b8 <bt_l2cap_recv+0x64>)
    9064:	9306      	str	r3, [sp, #24]
    9066:	2302      	movs	r3, #2
    9068:	9301      	str	r3, [sp, #4]
    906a:	9305      	str	r3, [sp, #20]
    906c:	aa05      	add	r2, sp, #20
    906e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
    9072:	4812      	ldr	r0, [pc, #72]	; (90bc <bt_l2cap_recv+0x68>)
    9074:	f01f f9f2 	bl	2845c <z_log_msg2_static_create.constprop.0>
	net_buf_unref(buf);
    9078:	4620      	mov	r0, r4
}
    907a:	b009      	add	sp, #36	; 0x24
    907c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	net_buf_unref(buf);
    9080:	f017 bc08 	b.w	20894 <net_buf_unref>
	return net_buf_simple_pull_mem(&buf->b, len);
    9084:	2104      	movs	r1, #4
    9086:	f104 0008 	add.w	r0, r4, #8
    908a:	f022 fecf 	bl	2be2c <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
    908e:	8841      	ldrh	r1, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
    9090:	4628      	mov	r0, r5
    9092:	f01f fa51 	bl	28538 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    9096:	b948      	cbnz	r0, 90ac <bt_l2cap_recv+0x58>
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
    9098:	4b09      	ldr	r3, [pc, #36]	; (90c0 <bt_l2cap_recv+0x6c>)
    909a:	e9cd 3106 	strd	r3, r1, [sp, #24]
    909e:	2303      	movs	r3, #3
    90a0:	9301      	str	r3, [sp, #4]
    90a2:	9305      	str	r3, [sp, #20]
    90a4:	aa05      	add	r2, sp, #20
    90a6:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    90aa:	e7e2      	b.n	9072 <bt_l2cap_recv+0x1e>
	chan->ops->recv(chan, buf);
    90ac:	6843      	ldr	r3, [r0, #4]
    90ae:	4621      	mov	r1, r4
    90b0:	691b      	ldr	r3, [r3, #16]
    90b2:	4798      	blx	r3
    90b4:	e7e0      	b.n	9078 <bt_l2cap_recv+0x24>
    90b6:	bf00      	nop
    90b8:	00030218 	.word	0x00030218
    90bc:	0002dac4 	.word	0x0002dac4
    90c0:	00030235 	.word	0x00030235

000090c4 <bt_l2cap_update_conn_param>:
{
    90c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    90c6:	460d      	mov	r5, r1
	ident++;
    90c8:	4916      	ldr	r1, [pc, #88]	; (9124 <bt_l2cap_update_conn_param+0x60>)
    90ca:	780b      	ldrb	r3, [r1, #0]
    90cc:	3301      	adds	r3, #1
	if (!ident) {
    90ce:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
		ident++;
    90d2:	bf08      	it	eq
    90d4:	2301      	moveq	r3, #1
    90d6:	700b      	strb	r3, [r1, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    90d8:	7809      	ldrb	r1, [r1, #0]
{
    90da:	4606      	mov	r6, r0
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    90dc:	2208      	movs	r2, #8
    90de:	2012      	movs	r0, #18
    90e0:	f7ff fe78 	bl	8dd4 <l2cap_create_le_sig_pdu.constprop.0>
	if (!buf) {
    90e4:	4604      	mov	r4, r0
    90e6:	b1d0      	cbz	r0, 911e <bt_l2cap_update_conn_param+0x5a>
	return net_buf_simple_add(&buf->b, len);
    90e8:	2108      	movs	r1, #8
    90ea:	4408      	add	r0, r1
    90ec:	f022 fe26 	bl	2bd3c <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
    90f0:	882b      	ldrh	r3, [r5, #0]
    90f2:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
    90f4:	886b      	ldrh	r3, [r5, #2]
    90f6:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
    90f8:	88ab      	ldrh	r3, [r5, #4]
    90fa:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
    90fc:	88eb      	ldrh	r3, [r5, #6]
    90fe:	80c3      	strh	r3, [r0, #6]
    9100:	2300      	movs	r3, #0
    9102:	9300      	str	r3, [sp, #0]
    9104:	4622      	mov	r2, r4
    9106:	2105      	movs	r1, #5
    9108:	4630      	mov	r0, r6
    910a:	f01f f9f1 	bl	284f0 <bt_l2cap_send_cb>
	if (err) {
    910e:	4605      	mov	r5, r0
    9110:	b110      	cbz	r0, 9118 <bt_l2cap_update_conn_param+0x54>
		net_buf_unref(buf);
    9112:	4620      	mov	r0, r4
    9114:	f017 fbbe 	bl	20894 <net_buf_unref>
}
    9118:	4628      	mov	r0, r5
    911a:	b002      	add	sp, #8
    911c:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    911e:	f06f 050b 	mvn.w	r5, #11
    9122:	e7f9      	b.n	9118 <bt_l2cap_update_conn_param+0x54>
    9124:	20003ae9 	.word	0x20003ae9

00009128 <att_cfm_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_cfm_sent;
    9128:	4b02      	ldr	r3, [pc, #8]	; (9134 <att_cfm_sent+0xc>)
    912a:	f8c1 3138 	str.w	r3, [r1, #312]	; 0x138

	att_sent(conn, user_data);
    912e:	f01f ba21 	b.w	28574 <att_sent>
    9132:	bf00      	nop
    9134:	0002898b 	.word	0x0002898b

00009138 <att_rsp_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_rsp_sent;
    9138:	4b02      	ldr	r3, [pc, #8]	; (9144 <att_rsp_sent+0xc>)
    913a:	f8c1 3138 	str.w	r3, [r1, #312]	; 0x138

	att_sent(conn, user_data);
    913e:	f01f ba19 	b.w	28574 <att_sent>
    9142:	bf00      	nop
    9144:	0002896f 	.word	0x0002896f

00009148 <att_req_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_req_sent;
    9148:	4b02      	ldr	r3, [pc, #8]	; (9154 <att_req_sent+0xc>)
    914a:	f8c1 3138 	str.w	r3, [r1, #312]	; 0x138

	att_sent(conn, user_data);
    914e:	f01f ba11 	b.w	28574 <att_sent>
    9152:	bf00      	nop
    9154:	00028739 	.word	0x00028739

00009158 <bt_att_released>:
	/* Prepend back to the list as it could not be sent */
	sys_slist_prepend(&chan->att->reqs, node);
}

static void bt_att_released(struct bt_l2cap_chan *ch)
{
    9158:	b507      	push	{r0, r1, r2, lr}
	struct bt_att_chan *chan = ATT_CHAN(ch);
    915a:	3808      	subs	r0, #8
    915c:	9001      	str	r0, [sp, #4]

	BT_DBG("chan %p", chan);

	k_mem_slab_free(&chan_slab, (void **)&chan);
    915e:	a901      	add	r1, sp, #4
    9160:	4802      	ldr	r0, [pc, #8]	; (916c <bt_att_released+0x14>)
    9162:	f023 fc53 	bl	2ca0c <k_mem_slab_free>
}
    9166:	b003      	add	sp, #12
    9168:	f85d fb04 	ldr.w	pc, [sp], #4
    916c:	20000e64 	.word	0x20000e64

00009170 <find_type_cb>:
{
    9170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_att_chan *chan = data->chan;
    9174:	f8d2 9000 	ldr.w	r9, [r2]
{
    9178:	b099      	sub	sp, #100	; 0x64
    917a:	4606      	mov	r6, r0
    917c:	460f      	mov	r7, r1
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    917e:	2500      	movs	r5, #0
    9180:	f642 0301 	movw	r3, #10241	; 0x2801
    9184:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
    9186:	f8d9 8008 	ldr.w	r8, [r9, #8]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    918a:	f88d 5048 	strb.w	r5, [sp, #72]	; 0x48
    918e:	a912      	add	r1, sp, #72	; 0x48
{
    9190:	4614      	mov	r4, r2
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    9192:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
    9196:	f01e fdb8 	bl	27d0a <bt_uuid_cmp>
    919a:	2800      	cmp	r0, #0
    919c:	d069      	beq.n	9272 <find_type_cb+0x102>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
    919e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    91a2:	6830      	ldr	r0, [r6, #0]
    91a4:	f88d 5048 	strb.w	r5, [sp, #72]	; 0x48
    91a8:	a912      	add	r1, sp, #72	; 0x48
    91aa:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
    91ae:	f01e fdac 	bl	27d0a <bt_uuid_cmp>
    91b2:	b138      	cbz	r0, 91c4 <find_type_cb+0x54>
		if (data->group &&
    91b4:	68a3      	ldr	r3, [r4, #8]
    91b6:	b11b      	cbz	r3, 91c0 <find_type_cb+0x50>
    91b8:	885a      	ldrh	r2, [r3, #2]
    91ba:	42ba      	cmp	r2, r7
    91bc:	d200      	bcs.n	91c0 <find_type_cb+0x50>
			data->group->end_handle = sys_cpu_to_le16(handle);
    91be:	805f      	strh	r7, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
    91c0:	2001      	movs	r0, #1
    91c2:	e009      	b.n	91d8 <find_type_cb+0x68>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
    91c4:	6861      	ldr	r1, [r4, #4]
    91c6:	4608      	mov	r0, r1
    91c8:	f01f f9cc 	bl	28564 <net_buf_frags_len>
    91cc:	f8b9 308a 	ldrh.w	r3, [r9, #138]	; 0x8a
    91d0:	1a1b      	subs	r3, r3, r0
    91d2:	2b03      	cmp	r3, #3
    91d4:	d803      	bhi.n	91de <find_type_cb+0x6e>
		return BT_GATT_ITER_STOP;
    91d6:	2000      	movs	r0, #0
}
    91d8:	b019      	add	sp, #100	; 0x64
    91da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(data->buf);
    91de:	4608      	mov	r0, r1
    91e0:	f022 fd78 	bl	2bcd4 <net_buf_frag_last>
    91e4:	4605      	mov	r5, r0
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
    91e6:	6860      	ldr	r0, [r4, #4]
    91e8:	f01f f9bc 	bl	28564 <net_buf_frags_len>
    91ec:	f8b9 a08a 	ldrh.w	sl, [r9, #138]	; 0x8a
	return net_buf_simple_tailroom(&buf->b);
    91f0:	f105 0b08 	add.w	fp, r5, #8
    91f4:	ebaa 0a00 	sub.w	sl, sl, r0
    91f8:	4658      	mov	r0, fp
    91fa:	f022 fe46 	bl	2be8a <net_buf_simple_tailroom>
    91fe:	4550      	cmp	r0, sl
    9200:	d93a      	bls.n	9278 <find_type_cb+0x108>
    9202:	6860      	ldr	r0, [r4, #4]
    9204:	f01f f9ae 	bl	28564 <net_buf_frags_len>
    9208:	f8b9 308a 	ldrh.w	r3, [r9, #138]	; 0x8a
    920c:	1a18      	subs	r0, r3, r0
	if (!len) {
    920e:	b970      	cbnz	r0, 922e <find_type_cb+0xbe>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
    9210:	6863      	ldr	r3, [r4, #4]
    9212:	7998      	ldrb	r0, [r3, #6]
    9214:	f017 fa7a 	bl	2070c <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
    9218:	2200      	movs	r2, #0
    921a:	2300      	movs	r3, #0
    921c:	f022 fd03 	bl	2bc26 <net_buf_alloc_fixed>
		if (!frag) {
    9220:	4605      	mov	r5, r0
    9222:	2800      	cmp	r0, #0
    9224:	d0d7      	beq.n	91d6 <find_type_cb+0x66>
		net_buf_frag_add(data->buf, frag);
    9226:	4601      	mov	r1, r0
    9228:	6860      	ldr	r0, [r4, #4]
    922a:	f022 fd64 	bl	2bcf6 <net_buf_frag_add>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
    922e:	2300      	movs	r3, #0
    9230:	9300      	str	r3, [sp, #0]
    9232:	2310      	movs	r3, #16
    9234:	f8d6 9004 	ldr.w	r9, [r6, #4]
    9238:	4631      	mov	r1, r6
    923a:	eb0d 0203 	add.w	r2, sp, r3
    923e:	4640      	mov	r0, r8
    9240:	47c8      	blx	r9
	if (read < 0) {
    9242:	1e06      	subs	r6, r0, #0
    9244:	db15      	blt.n	9272 <find_type_cb+0x102>
	if (read != data->value_len) {
    9246:	7c22      	ldrb	r2, [r4, #16]
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    9248:	68e0      	ldr	r0, [r4, #12]
	if (read != data->value_len) {
    924a:	4296      	cmp	r6, r2
    924c:	d035      	beq.n	92ba <find_type_cb+0x14a>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    924e:	4601      	mov	r1, r0
    9250:	a80d      	add	r0, sp, #52	; 0x34
    9252:	f01e fd88 	bl	27d66 <bt_uuid_create>
    9256:	b998      	cbnz	r0, 9280 <find_type_cb+0x110>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    9258:	7c23      	ldrb	r3, [r4, #16]
    925a:	4a1a      	ldr	r2, [pc, #104]	; (92c4 <find_type_cb+0x154>)
    925c:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
    9260:	2303      	movs	r3, #3
    9262:	9308      	str	r3, [sp, #32]
			BT_WARN("Unable to create UUID: size %d", read);
    9264:	4818      	ldr	r0, [pc, #96]	; (92c8 <find_type_cb+0x158>)
    9266:	9315      	str	r3, [sp, #84]	; 0x54
    9268:	aa15      	add	r2, sp, #84	; 0x54
    926a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    926e:	f01f faa0 	bl	287b2 <z_log_msg2_static_create.constprop.0>
	data->group = NULL;
    9272:	2300      	movs	r3, #0
    9274:	60a3      	str	r3, [r4, #8]
    9276:	e7a3      	b.n	91c0 <find_type_cb+0x50>
	return net_buf_simple_tailroom(&buf->b);
    9278:	4658      	mov	r0, fp
    927a:	f022 fe06 	bl	2be8a <net_buf_simple_tailroom>
    927e:	e7c6      	b.n	920e <find_type_cb+0x9e>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
    9280:	b2f2      	uxtb	r2, r6
    9282:	a904      	add	r1, sp, #16
    9284:	a808      	add	r0, sp, #32
    9286:	f01e fd6e 	bl	27d66 <bt_uuid_create>
    928a:	b928      	cbnz	r0, 9298 <find_type_cb+0x128>
			BT_WARN("Unable to create UUID: size %d", read);
    928c:	4b0f      	ldr	r3, [pc, #60]	; (92cc <find_type_cb+0x15c>)
    928e:	e9cd 3616 	strd	r3, r6, [sp, #88]	; 0x58
    9292:	2303      	movs	r3, #3
    9294:	9303      	str	r3, [sp, #12]
    9296:	e7e5      	b.n	9264 <find_type_cb+0xf4>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
    9298:	a908      	add	r1, sp, #32
    929a:	a80d      	add	r0, sp, #52	; 0x34
    929c:	f01e fd35 	bl	27d0a <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
    92a0:	2800      	cmp	r0, #0
    92a2:	d1e6      	bne.n	9272 <find_type_cb+0x102>
	data->err = 0x00;
    92a4:	2300      	movs	r3, #0
    92a6:	7463      	strb	r3, [r4, #17]
	return net_buf_simple_add(&buf->b, len);
    92a8:	2104      	movs	r1, #4
    92aa:	f105 0008 	add.w	r0, r5, #8
    92ae:	f022 fd45 	bl	2bd3c <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
    92b2:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
    92b4:	8007      	strh	r7, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
    92b6:	8047      	strh	r7, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
    92b8:	e782      	b.n	91c0 <find_type_cb+0x50>
	} else if (memcmp(data->value, uuid, read)) {
    92ba:	4632      	mov	r2, r6
    92bc:	a904      	add	r1, sp, #16
    92be:	f01e fac6 	bl	2784e <memcmp>
    92c2:	e7ed      	b.n	92a0 <find_type_cb+0x130>
    92c4:	00030271 	.word	0x00030271
    92c8:	0002d9cc 	.word	0x0002d9cc
    92cc:	00030290 	.word	0x00030290

000092d0 <att_get>:
{
    92d0:	b510      	push	{r4, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    92d2:	7a83      	ldrb	r3, [r0, #10]
    92d4:	2b07      	cmp	r3, #7
{
    92d6:	b088      	sub	sp, #32
	if (conn->state != BT_CONN_CONNECTED) {
    92d8:	d00c      	beq.n	92f4 <att_get+0x24>
		BT_WARN("Not connected");
    92da:	4b16      	ldr	r3, [pc, #88]	; (9334 <att_get+0x64>)
		BT_WARN("ATT channel flagged as disconnected");
    92dc:	9306      	str	r3, [sp, #24]
    92de:	4816      	ldr	r0, [pc, #88]	; (9338 <att_get+0x68>)
    92e0:	2302      	movs	r3, #2
    92e2:	aa05      	add	r2, sp, #20
    92e4:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    92e8:	9301      	str	r3, [sp, #4]
    92ea:	9305      	str	r3, [sp, #20]
		return NULL;
    92ec:	2400      	movs	r4, #0
		BT_WARN("ATT channel flagged as disconnected");
    92ee:	f01f fa60 	bl	287b2 <z_log_msg2_static_create.constprop.0>
		return NULL;
    92f2:	e00f      	b.n	9314 <att_get+0x44>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
    92f4:	2104      	movs	r1, #4
    92f6:	f01f f91f 	bl	28538 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    92fa:	4604      	mov	r4, r0
    92fc:	b968      	cbnz	r0, 931a <att_get+0x4a>
		BT_ERR("Unable to find ATT channel");
    92fe:	4b0f      	ldr	r3, [pc, #60]	; (933c <att_get+0x6c>)
    9300:	9306      	str	r3, [sp, #24]
    9302:	480d      	ldr	r0, [pc, #52]	; (9338 <att_get+0x68>)
    9304:	2302      	movs	r3, #2
    9306:	aa05      	add	r2, sp, #20
    9308:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    930c:	9301      	str	r3, [sp, #4]
    930e:	9305      	str	r3, [sp, #20]
    9310:	f01f fa4f 	bl	287b2 <z_log_msg2_static_create.constprop.0>
}
    9314:	4620      	mov	r0, r4
    9316:	b008      	add	sp, #32
    9318:	bd10      	pop	{r4, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    931a:	f3bf 8f5b 	dmb	ish
    931e:	f8d0 30e8 	ldr.w	r3, [r0, #232]	; 0xe8
    9322:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(att_chan->flags, ATT_DISCONNECTED)) {
    9326:	075b      	lsls	r3, r3, #29
    9328:	d501      	bpl.n	932e <att_get+0x5e>
		BT_WARN("ATT channel flagged as disconnected");
    932a:	4b05      	ldr	r3, [pc, #20]	; (9340 <att_get+0x70>)
    932c:	e7d6      	b.n	92dc <att_get+0xc>
	return att_chan->att;
    932e:	f850 4c08 	ldr.w	r4, [r0, #-8]
    9332:	e7ef      	b.n	9314 <att_get+0x44>
    9334:	000302af 	.word	0x000302af
    9338:	0002d9cc 	.word	0x0002d9cc
    933c:	000302bd 	.word	0x000302bd
    9340:	000302d8 	.word	0x000302d8

00009344 <bt_att_accept>:

	return chan;
}

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
    9344:	b5f0      	push	{r4, r5, r6, r7, lr}
    9346:	b08b      	sub	sp, #44	; 0x2c
    9348:	4607      	mov	r7, r0
    934a:	460e      	mov	r6, r1
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    934c:	4827      	ldr	r0, [pc, #156]	; (93ec <bt_att_accept+0xa8>)
    934e:	2200      	movs	r2, #0
    9350:	2300      	movs	r3, #0
    9352:	a901      	add	r1, sp, #4
    9354:	f01a fc0c 	bl	23b70 <k_mem_slab_alloc>
    9358:	4604      	mov	r4, r0
    935a:	b180      	cbz	r0, 937e <bt_att_accept+0x3a>
		BT_ERR("No available ATT context for conn %p", conn);
    935c:	4b24      	ldr	r3, [pc, #144]	; (93f0 <bt_att_accept+0xac>)
    935e:	e9cd 3708 	strd	r3, r7, [sp, #32]
		BT_ERR("No available ATT channel for conn %p", att->conn);
    9362:	2303      	movs	r3, #3
    9364:	4823      	ldr	r0, [pc, #140]	; (93f4 <bt_att_accept+0xb0>)
    9366:	9303      	str	r3, [sp, #12]
    9368:	aa07      	add	r2, sp, #28
    936a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
	sys_slist_init(&att->reqs);
	sys_slist_init(&att->chans);

	chan = att_chan_new(att, 0);
	if (!chan) {
		return -ENOMEM;
    936e:	f06f 040b 	mvn.w	r4, #11
		BT_ERR("No available ATT channel for conn %p", att->conn);
    9372:	9307      	str	r3, [sp, #28]
    9374:	f01f fa1d 	bl	287b2 <z_log_msg2_static_create.constprop.0>
	}

	*ch = &chan->chan.chan;

	return 0;
}
    9378:	4620      	mov	r0, r4
    937a:	b00b      	add	sp, #44	; 0x2c
    937c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	(void)memset(att, 0, sizeof(*att));
    937e:	4601      	mov	r1, r0
    9380:	222c      	movs	r2, #44	; 0x2c
    9382:	9801      	ldr	r0, [sp, #4]
    9384:	f01e fa7f 	bl	27886 <memset>
	att->conn = conn;
    9388:	9d01      	ldr	r5, [sp, #4]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
    938a:	481b      	ldr	r0, [pc, #108]	; (93f8 <bt_att_accept+0xb4>)
	list->tail = NULL;
    938c:	60ac      	str	r4, [r5, #8]
	list->head = NULL;
    938e:	e9c5 7400 	strd	r7, r4, [r5]
	list->tail = NULL;
    9392:	e9c5 4409 	strd	r4, r4, [r5, #36]	; 0x24
    9396:	2200      	movs	r2, #0
    9398:	2300      	movs	r3, #0
    939a:	a902      	add	r1, sp, #8
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    939c:	9402      	str	r4, [sp, #8]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
    939e:	f01a fbe7 	bl	23b70 <k_mem_slab_alloc>
    93a2:	4604      	mov	r4, r0
    93a4:	b120      	cbz	r0, 93b0 <bt_att_accept+0x6c>
		BT_ERR("No available ATT channel for conn %p", att->conn);
    93a6:	682b      	ldr	r3, [r5, #0]
    93a8:	4a14      	ldr	r2, [pc, #80]	; (93fc <bt_att_accept+0xb8>)
    93aa:	e9cd 2308 	strd	r2, r3, [sp, #32]
    93ae:	e7d8      	b.n	9362 <bt_att_accept+0x1e>
	(void)memset(chan, 0, sizeof(*chan));
    93b0:	4601      	mov	r1, r0
    93b2:	f44f 72a4 	mov.w	r2, #328	; 0x148
    93b6:	9802      	ldr	r0, [sp, #8]
    93b8:	f01e fa65 	bl	27886 <memset>
	chan->chan.chan.ops = &ops;
    93bc:	9802      	ldr	r0, [sp, #8]
    93be:	4b10      	ldr	r3, [pc, #64]	; (9400 <bt_att_accept+0xbc>)
    93c0:	60c3      	str	r3, [r0, #12]
	z_impl_k_queue_init(queue);
    93c2:	30f8      	adds	r0, #248	; 0xf8
    93c4:	f023 fbde 	bl	2cb84 <z_impl_k_queue_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    93c8:	9b02      	ldr	r3, [sp, #8]
    93ca:	f3bf 8f5b 	dmb	ish
    93ce:	33f0      	adds	r3, #240	; 0xf0
    93d0:	e853 2f00 	ldrex	r2, [r3]
    93d4:	e843 4100 	strex	r1, r4, [r3]
    93d8:	2900      	cmp	r1, #0
    93da:	d1f9      	bne.n	93d0 <bt_att_accept+0x8c>
    93dc:	f3bf 8f5b 	dmb	ish
	chan->att = att;
    93e0:	9b02      	ldr	r3, [sp, #8]
    93e2:	f843 5b08 	str.w	r5, [r3], #8
	*ch = &chan->chan.chan;
    93e6:	6033      	str	r3, [r6, #0]
	return 0;
    93e8:	e7c6      	b.n	9378 <bt_att_accept+0x34>
    93ea:	bf00      	nop
    93ec:	20000e48 	.word	0x20000e48
    93f0:	000302fc 	.word	0x000302fc
    93f4:	0002d9cc 	.word	0x0002d9cc
    93f8:	20000e64 	.word	0x20000e64
    93fc:	00030321 	.word	0x00030321
    9400:	200003a4 	.word	0x200003a4

00009404 <read_group_cb>:
{
    9404:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    9408:	4605      	mov	r5, r0
    940a:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    940c:	f04f 0800 	mov.w	r8, #0
    9410:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9414:	6800      	ldr	r0, [r0, #0]
	struct bt_att_chan *chan = data->chan;
    9416:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    9418:	f88d 8008 	strb.w	r8, [sp, #8]
    941c:	a902      	add	r1, sp, #8
{
    941e:	4614      	mov	r4, r2
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    9420:	f8ad 300a 	strh.w	r3, [sp, #10]
    9424:	f01e fc71 	bl	27d0a <bt_uuid_cmp>
    9428:	b1a0      	cbz	r0, 9454 <read_group_cb+0x50>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    942a:	f642 0301 	movw	r3, #10241	; 0x2801
    942e:	6828      	ldr	r0, [r5, #0]
    9430:	f88d 800c 	strb.w	r8, [sp, #12]
    9434:	a903      	add	r1, sp, #12
    9436:	f8ad 300e 	strh.w	r3, [sp, #14]
    943a:	f01e fc66 	bl	27d0a <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    943e:	b148      	cbz	r0, 9454 <read_group_cb+0x50>
		if (data->group &&
    9440:	6923      	ldr	r3, [r4, #16]
    9442:	b11b      	cbz	r3, 944c <read_group_cb+0x48>
    9444:	885a      	ldrh	r2, [r3, #2]
    9446:	42b2      	cmp	r2, r6
    9448:	d200      	bcs.n	944c <read_group_cb+0x48>
			data->group->end_handle = sys_cpu_to_le16(handle);
    944a:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
    944c:	2001      	movs	r0, #1
}
    944e:	b004      	add	sp, #16
    9450:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    9454:	6861      	ldr	r1, [r4, #4]
    9456:	6828      	ldr	r0, [r5, #0]
    9458:	f01e fc57 	bl	27d0a <bt_uuid_cmp>
    945c:	b110      	cbz	r0, 9464 <read_group_cb+0x60>
		data->group = NULL;
    945e:	2300      	movs	r3, #0
    9460:	6123      	str	r3, [r4, #16]
    9462:	e7f3      	b.n	944c <read_group_cb+0x48>
	if (data->rsp->len &&
    9464:	68e3      	ldr	r3, [r4, #12]
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
    9466:	68a0      	ldr	r0, [r4, #8]
	if (data->rsp->len &&
    9468:	781a      	ldrb	r2, [r3, #0]
    946a:	b13a      	cbz	r2, 947c <read_group_cb+0x78>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
    946c:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
    9470:	8981      	ldrh	r1, [r0, #12]
    9472:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
    9474:	4293      	cmp	r3, r2
    9476:	da01      	bge.n	947c <read_group_cb+0x78>
		return BT_GATT_ITER_STOP;
    9478:	2000      	movs	r0, #0
    947a:	e7e8      	b.n	944e <read_group_cb+0x4a>
    947c:	2104      	movs	r1, #4
    947e:	3008      	adds	r0, #8
    9480:	f022 fc5c 	bl	2bd3c <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    9484:	4b09      	ldr	r3, [pc, #36]	; (94ac <read_group_cb+0xa8>)
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    9486:	6120      	str	r0, [r4, #16]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    9488:	68a2      	ldr	r2, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
    948a:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
    948c:	8046      	strh	r6, [r0, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    948e:	4629      	mov	r1, r5
    9490:	9300      	str	r3, [sp, #0]
    9492:	9401      	str	r4, [sp, #4]
    9494:	2300      	movs	r3, #0
    9496:	4638      	mov	r0, r7
    9498:	f01f f98e 	bl	287b8 <att_chan_read>
	if (read < 0) {
    949c:	2800      	cmp	r0, #0
    949e:	dbeb      	blt.n	9478 <read_group_cb+0x74>
	if (!data->group) {
    94a0:	6920      	ldr	r0, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
    94a2:	3800      	subs	r0, #0
    94a4:	bf18      	it	ne
    94a6:	2001      	movne	r0, #1
    94a8:	e7d1      	b.n	944e <read_group_cb+0x4a>
    94aa:	bf00      	nop
    94ac:	00028719 	.word	0x00028719

000094b0 <chan_send>:
{
    94b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    94b4:	688b      	ldr	r3, [r1, #8]
    94b6:	781b      	ldrb	r3, [r3, #0]
    94b8:	2bd2      	cmp	r3, #210	; 0xd2
{
    94ba:	b08b      	sub	sp, #44	; 0x2c
    94bc:	4606      	mov	r6, r0
    94be:	460c      	mov	r4, r1
    94c0:	4617      	mov	r7, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    94c2:	d117      	bne.n	94f4 <chan_send+0x44>
		err = bt_smp_sign(chan->att->conn, buf);
    94c4:	6803      	ldr	r3, [r0, #0]
    94c6:	6818      	ldr	r0, [r3, #0]
    94c8:	f01f ff29 	bl	2931e <bt_smp_sign>
		if (err) {
    94cc:	4605      	mov	r5, r0
    94ce:	b188      	cbz	r0, 94f4 <chan_send+0x44>
			BT_ERR("Error signing data");
    94d0:	4b24      	ldr	r3, [pc, #144]	; (9564 <chan_send+0xb4>)
    94d2:	4825      	ldr	r0, [pc, #148]	; (9568 <chan_send+0xb8>)
    94d4:	9308      	str	r3, [sp, #32]
    94d6:	aa07      	add	r2, sp, #28
    94d8:	2302      	movs	r3, #2
    94da:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    94de:	9303      	str	r3, [sp, #12]
    94e0:	9307      	str	r3, [sp, #28]
    94e2:	f01f f966 	bl	287b2 <z_log_msg2_static_create.constprop.0>
			net_buf_unref(buf);
    94e6:	4620      	mov	r0, r4
    94e8:	f017 f9d4 	bl	20894 <net_buf_unref>
}
    94ec:	4628      	mov	r0, r5
    94ee:	b00b      	add	sp, #44	; 0x2c
    94f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	state->offset = net_buf_simple_headroom(buf);
    94f4:	f104 0008 	add.w	r0, r4, #8
    94f8:	f022 fcc3 	bl	2be82 <net_buf_simple_headroom>
	state->len = buf->len;
    94fc:	f8b4 900c 	ldrh.w	r9, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    9500:	4680      	mov	r8, r0
	chan->sent = cb ? cb : chan_cb(buf);
    9502:	b957      	cbnz	r7, 951a <chan_send+0x6a>
	switch (att_op_get_type(buf->data[0])) {
    9504:	68a3      	ldr	r3, [r4, #8]
    9506:	7818      	ldrb	r0, [r3, #0]
    9508:	f01f f84c 	bl	285a4 <att_op_get_type>
    950c:	1e43      	subs	r3, r0, #1
    950e:	b2db      	uxtb	r3, r3
    9510:	2b04      	cmp	r3, #4
    9512:	bf9c      	itt	ls
    9514:	4a15      	ldrls	r2, [pc, #84]	; (956c <chan_send+0xbc>)
    9516:	f852 7023 	ldrls.w	r7, [r2, r3, lsl #2]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    951a:	6833      	ldr	r3, [r6, #0]
	chan->sent = cb ? cb : chan_cb(buf);
    951c:	f8c6 7140 	str.w	r7, [r6, #320]	; 0x140
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    9520:	6818      	ldr	r0, [r3, #0]
	if (cb == chan_rsp_sent) {
    9522:	4b13      	ldr	r3, [pc, #76]	; (9570 <chan_send+0xc0>)
    9524:	429f      	cmp	r7, r3
    9526:	d018      	beq.n	955a <chan_send+0xaa>
	} else if (cb == chan_cfm_sent) {
    9528:	4b12      	ldr	r3, [pc, #72]	; (9574 <chan_send+0xc4>)
    952a:	429f      	cmp	r7, r3
    952c:	d017      	beq.n	955e <chan_send+0xae>
		return att_sent;
    952e:	4912      	ldr	r1, [pc, #72]	; (9578 <chan_send+0xc8>)
    9530:	4b12      	ldr	r3, [pc, #72]	; (957c <chan_send+0xcc>)
    9532:	4a13      	ldr	r2, [pc, #76]	; (9580 <chan_send+0xd0>)
    9534:	428f      	cmp	r7, r1
    9536:	bf18      	it	ne
    9538:	4613      	movne	r3, r2
			       &chan->chan.chan);
    953a:	3608      	adds	r6, #8
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    953c:	9600      	str	r6, [sp, #0]
    953e:	4622      	mov	r2, r4
    9540:	2104      	movs	r1, #4
    9542:	f01e ffd5 	bl	284f0 <bt_l2cap_send_cb>
	if (err) {
    9546:	4605      	mov	r5, r0
    9548:	2800      	cmp	r0, #0
    954a:	d0cf      	beq.n	94ec <chan_send+0x3c>
	buf->data = buf->__buf + state->offset;
    954c:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    954e:	f8a4 900c 	strh.w	r9, [r4, #12]
	buf->data = buf->__buf + state->offset;
    9552:	fa10 f088 	uxtah	r0, r0, r8
    9556:	60a0      	str	r0, [r4, #8]
}
    9558:	e7c8      	b.n	94ec <chan_send+0x3c>
		return att_rsp_sent;
    955a:	4b0a      	ldr	r3, [pc, #40]	; (9584 <chan_send+0xd4>)
    955c:	e7ed      	b.n	953a <chan_send+0x8a>
		return att_cfm_sent;
    955e:	4b0a      	ldr	r3, [pc, #40]	; (9588 <chan_send+0xd8>)
    9560:	e7eb      	b.n	953a <chan_send+0x8a>
    9562:	bf00      	nop
    9564:	00030346 	.word	0x00030346
    9568:	0002d9cc 	.word	0x0002d9cc
    956c:	0002e238 	.word	0x0002e238
    9570:	0002896f 	.word	0x0002896f
    9574:	0002898b 	.word	0x0002898b
    9578:	00028739 	.word	0x00028739
    957c:	00009149 	.word	0x00009149
    9580:	00028575 	.word	0x00028575
    9584:	00009139 	.word	0x00009139
    9588:	00009129 	.word	0x00009129

0000958c <bt_att_chan_send_rsp.constprop.0>:
static void bt_att_chan_send_rsp(struct bt_att_chan *chan, struct net_buf *buf,
    958c:	b538      	push	{r3, r4, r5, lr}
	return chan_send(chan, buf, cb);
    958e:	4a07      	ldr	r2, [pc, #28]	; (95ac <bt_att_chan_send_rsp.constprop.0+0x20>)
static void bt_att_chan_send_rsp(struct bt_att_chan *chan, struct net_buf *buf,
    9590:	4604      	mov	r4, r0
    9592:	460d      	mov	r5, r1
	return chan_send(chan, buf, cb);
    9594:	f7ff ff8c 	bl	94b0 <chan_send>
	if (err) {
    9598:	b130      	cbz	r0, 95a8 <bt_att_chan_send_rsp.constprop.0+0x1c>
		net_buf_put(&chan->tx_queue, buf);
    959a:	4629      	mov	r1, r5
    959c:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
}
    95a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_put(&chan->tx_queue, buf);
    95a4:	f022 bb85 	b.w	2bcb2 <net_buf_put>
}
    95a8:	bd38      	pop	{r3, r4, r5, pc}
    95aa:	bf00      	nop
    95ac:	0002896f 	.word	0x0002896f

000095b0 <read_type_cb>:
{
    95b0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att_chan *chan = data->chan;
    95b4:	f8d2 8000 	ldr.w	r8, [r2]
{
    95b8:	4606      	mov	r6, r0
    95ba:	4689      	mov	r9, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    95bc:	6800      	ldr	r0, [r0, #0]
    95be:	6851      	ldr	r1, [r2, #4]
	struct bt_conn *conn = chan->chan.chan.conn;
    95c0:	f8d8 5008 	ldr.w	r5, [r8, #8]
{
    95c4:	4614      	mov	r4, r2
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    95c6:	f01e fba0 	bl	27d0a <bt_uuid_cmp>
    95ca:	4607      	mov	r7, r0
    95cc:	2800      	cmp	r0, #0
    95ce:	d13e      	bne.n	964e <read_type_cb+0x9e>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    95d0:	4628      	mov	r0, r5
    95d2:	2215      	movs	r2, #21
    95d4:	4631      	mov	r1, r6
    95d6:	f01f fe19 	bl	2920c <bt_gatt_check_perm>
    95da:	4605      	mov	r5, r0
    95dc:	7520      	strb	r0, [r4, #20]
	if (data->err) {
    95de:	b148      	cbz	r0, 95f4 <read_type_cb+0x44>
		if (data->rsp->len) {
    95e0:	68e3      	ldr	r3, [r4, #12]
    95e2:	781b      	ldrb	r3, [r3, #0]
    95e4:	b923      	cbnz	r3, 95f0 <read_type_cb+0x40>
		return BT_GATT_ITER_STOP;
    95e6:	2500      	movs	r5, #0
}
    95e8:	4628      	mov	r0, r5
    95ea:	b003      	add	sp, #12
    95ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			data->err = 0x00;
    95f0:	7527      	strb	r7, [r4, #20]
    95f2:	e7f8      	b.n	95e6 <read_type_cb+0x36>
	data->item = net_buf_add(net_buf_frag_last(data->buf),
    95f4:	68a0      	ldr	r0, [r4, #8]
    95f6:	f022 fb6d 	bl	2bcd4 <net_buf_frag_last>
	return net_buf_simple_add(&buf->b, len);
    95fa:	2102      	movs	r1, #2
    95fc:	3008      	adds	r0, #8
    95fe:	f022 fb9d 	bl	2bd3c <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    9602:	4b14      	ldr	r3, [pc, #80]	; (9654 <read_type_cb+0xa4>)
	data->item = net_buf_add(net_buf_frag_last(data->buf),
    9604:	6120      	str	r0, [r4, #16]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    9606:	68a2      	ldr	r2, [r4, #8]
	data->item->handle = sys_cpu_to_le16(handle);
    9608:	f8a0 9000 	strh.w	r9, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    960c:	4631      	mov	r1, r6
    960e:	9300      	str	r3, [sp, #0]
    9610:	9401      	str	r4, [sp, #4]
    9612:	462b      	mov	r3, r5
    9614:	4640      	mov	r0, r8
    9616:	f01f f8cf 	bl	287b8 <att_chan_read>
	if (read < 0) {
    961a:	2800      	cmp	r0, #0
    961c:	da07      	bge.n	962e <read_type_cb+0x7e>
	if (err < 0 && err >= -0xff) {
    961e:	f110 0fff 	cmn.w	r0, #255	; 0xff
		return -err;
    9622:	bf26      	itte	cs
    9624:	4240      	negcs	r0, r0
    9626:	b2c0      	uxtbcs	r0, r0
	return BT_ATT_ERR_UNLIKELY;
    9628:	200e      	movcc	r0, #14
		data->err = err_to_att(read);
    962a:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
    962c:	e7dc      	b.n	95e8 <read_type_cb+0x38>
	if (!data->item) {
    962e:	6923      	ldr	r3, [r4, #16]
    9630:	2b00      	cmp	r3, #0
    9632:	d0d8      	beq.n	95e6 <read_type_cb+0x36>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    9634:	68a0      	ldr	r0, [r4, #8]
    9636:	f01e ff95 	bl	28564 <net_buf_frags_len>
    963a:	f8b8 508a 	ldrh.w	r5, [r8, #138]	; 0x8a
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    963e:	68e3      	ldr	r3, [r4, #12]
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    9640:	1a2d      	subs	r5, r5, r0
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    9642:	7818      	ldrb	r0, [r3, #0]
    9644:	4285      	cmp	r5, r0
    9646:	bf94      	ite	ls
    9648:	2500      	movls	r5, #0
    964a:	2501      	movhi	r5, #1
    964c:	e7cc      	b.n	95e8 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
    964e:	2501      	movs	r5, #1
    9650:	e7ca      	b.n	95e8 <read_type_cb+0x38>
    9652:	bf00      	nop
    9654:	00028581 	.word	0x00028581

00009658 <bt_att_connected>:
{
    9658:	b570      	push	{r4, r5, r6, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    965a:	4606      	mov	r6, r0
{
    965c:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    965e:	2104      	movs	r1, #4
    9660:	f856 0908 	ldr.w	r0, [r6], #-8
    9664:	f01e ff5d 	bl	28522 <bt_l2cap_le_lookup_tx_cid>
	struct bt_att *att = att_chan->att;
    9668:	f850 5c08 	ldr.w	r5, [r0, #-8]
	if (sys_slist_is_empty(&att->chans)) {
    966c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    966e:	b91b      	cbnz	r3, 9678 <bt_att_connected+0x20>
    9670:	f105 000c 	add.w	r0, r5, #12
    9674:	f023 fa86 	bl	2cb84 <z_impl_k_queue_init>
	parent->next = child;
    9678:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    967a:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
Z_GENLIST_PREPEND(slist, snode)
    967e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
	sys_slist_prepend(&att->chans, &chan->node);
    9680:	f504 739e 	add.w	r3, r4, #316	; 0x13c
	list->head = node;
    9684:	626b      	str	r3, [r5, #36]	; 0x24
Z_GENLIST_PREPEND(slist, snode)
    9686:	b902      	cbnz	r2, 968a <bt_att_connected+0x32>
	list->tail = node;
    9688:	62ab      	str	r3, [r5, #40]	; 0x28
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    968a:	f3bf 8f5b 	dmb	ish
    968e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    9692:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(att_chan->flags, ATT_ENHANCED)) {
    9696:	071b      	lsls	r3, r3, #28
		ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    9698:	bf58      	it	pl
    969a:	2317      	movpl	r3, #23
	att_chan_mtu_updated(att_chan);
    969c:	4630      	mov	r0, r6
		ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    969e:	bf5c      	itt	pl
    96a0:	f8a4 3082 	strhpl.w	r3, [r4, #130]	; 0x82
		ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    96a4:	f8a4 3072 	strhpl.w	r3, [r4, #114]	; 0x72
	att_chan_mtu_updated(att_chan);
    96a8:	f01f f800 	bl	286ac <att_chan_mtu_updated>
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
    96ac:	f504 7084 	add.w	r0, r4, #264	; 0x108
    96b0:	4902      	ldr	r1, [pc, #8]	; (96bc <bt_att_connected+0x64>)
}
    96b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
    96b6:	f023 bb98 	b.w	2cdea <k_work_init_delayable>
    96ba:	bf00      	nop
    96bc:	00009fe1 	.word	0x00009fe1

000096c0 <bt_att_chan_create_pdu>:
{
    96c0:	b5b0      	push	{r4, r5, r7, lr}
    96c2:	b088      	sub	sp, #32
    96c4:	460d      	mov	r5, r1
	if (len + sizeof(op) > chan->chan.tx.mtu) {
    96c6:	f8b0 108a 	ldrh.w	r1, [r0, #138]	; 0x8a
    96ca:	1c53      	adds	r3, r2, #1
    96cc:	428b      	cmp	r3, r1
{
    96ce:	af00      	add	r7, sp, #0
	if (len + sizeof(op) > chan->chan.tx.mtu) {
    96d0:	d915      	bls.n	96fe <bt_att_chan_create_pdu+0x3e>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    96d2:	466c      	mov	r4, sp
    96d4:	b088      	sub	sp, #32
    96d6:	466a      	mov	r2, sp
    96d8:	481d      	ldr	r0, [pc, #116]	; (9750 <bt_att_chan_create_pdu+0x90>)
    96da:	6193      	str	r3, [r2, #24]
    96dc:	2304      	movs	r3, #4
    96de:	e9c2 0104 	strd	r0, r1, [r2, #16]
    96e2:	f842 3f0c 	str.w	r3, [r2, #12]!
    96e6:	481b      	ldr	r0, [pc, #108]	; (9754 <bt_att_chan_create_pdu+0x94>)
    96e8:	60bb      	str	r3, [r7, #8]
    96ea:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    96ee:	f01f f860 	bl	287b2 <z_log_msg2_static_create.constprop.0>
    96f2:	46a5      	mov	sp, r4
		return NULL;
    96f4:	2400      	movs	r4, #0
}
    96f6:	4620      	mov	r0, r4
    96f8:	3720      	adds	r7, #32
    96fa:	46bd      	mov	sp, r7
    96fc:	bdb0      	pop	{r4, r5, r7, pc}
	switch (att_op_get_type(op)) {
    96fe:	4628      	mov	r0, r5
    9700:	f01e ff50 	bl	285a4 <att_op_get_type>
    9704:	2802      	cmp	r0, #2
    9706:	d001      	beq.n	970c <bt_att_chan_create_pdu+0x4c>
    9708:	2804      	cmp	r0, #4
    970a:	d116      	bne.n	973a <bt_att_chan_create_pdu+0x7a>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
    970c:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    9710:	2300      	movs	r3, #0
		buf = bt_l2cap_create_pdu(NULL, 0);
    9712:	2100      	movs	r1, #0
    9714:	4608      	mov	r0, r1
    9716:	f01e fee8 	bl	284ea <bt_l2cap_create_pdu_timeout>
    971a:	4604      	mov	r4, r0
	if (!buf) {
    971c:	b990      	cbnz	r0, 9744 <bt_att_chan_create_pdu+0x84>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    971e:	4b0e      	ldr	r3, [pc, #56]	; (9758 <bt_att_chan_create_pdu+0x98>)
    9720:	480c      	ldr	r0, [pc, #48]	; (9754 <bt_att_chan_create_pdu+0x94>)
    9722:	e9c7 3506 	strd	r3, r5, [r7, #24]
    9726:	f107 0214 	add.w	r2, r7, #20
    972a:	2303      	movs	r3, #3
    972c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    9730:	607b      	str	r3, [r7, #4]
    9732:	617b      	str	r3, [r7, #20]
    9734:	f01f f83d 	bl	287b2 <z_log_msg2_static_create.constprop.0>
		return NULL;
    9738:	e7dd      	b.n	96f6 <bt_att_chan_create_pdu+0x36>
		buf = bt_l2cap_create_pdu(NULL, 0);
    973a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    973e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9742:	e7e6      	b.n	9712 <bt_att_chan_create_pdu+0x52>
    9744:	2101      	movs	r1, #1
    9746:	3008      	adds	r0, #8
    9748:	f022 faf8 	bl	2bd3c <net_buf_simple_add>
	hdr->code = op;
    974c:	7005      	strb	r5, [r0, #0]
	return buf;
    974e:	e7d2      	b.n	96f6 <bt_att_chan_create_pdu+0x36>
    9750:	00030359 	.word	0x00030359
    9754:	0002d9cc 	.word	0x0002d9cc
    9758:	0003011f 	.word	0x0003011f

0000975c <bt_att_recv>:
{
    975c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9760:	b089      	sub	sp, #36	; 0x24
	if (buf->len < sizeof(*hdr)) {
    9762:	898b      	ldrh	r3, [r1, #12]
{
    9764:	af00      	add	r7, sp, #0
    9766:	4604      	mov	r4, r0
    9768:	4689      	mov	r9, r1
	if (buf->len < sizeof(*hdr)) {
    976a:	b983      	cbnz	r3, 978e <bt_att_recv+0x32>
		BT_ERR("Too small ATT PDU received");
    976c:	4b54      	ldr	r3, [pc, #336]	; (98c0 <bt_att_recv+0x164>)
    976e:	61bb      	str	r3, [r7, #24]
    9770:	2302      	movs	r3, #2
    9772:	607b      	str	r3, [r7, #4]
    9774:	617b      	str	r3, [r7, #20]
    9776:	f107 0214 	add.w	r2, r7, #20
    977a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
			BT_WARN("Ignoring unexpected indication");
    977e:	4851      	ldr	r0, [pc, #324]	; (98c4 <bt_att_recv+0x168>)
    9780:	f01f f817 	bl	287b2 <z_log_msg2_static_create.constprop.0>
}
    9784:	2000      	movs	r0, #0
    9786:	3724      	adds	r7, #36	; 0x24
    9788:	46bd      	mov	sp, r7
    978a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
    978e:	2101      	movs	r1, #1
    9790:	f109 0008 	add.w	r0, r9, #8
    9794:	f022 fb4a 	bl	2be2c <net_buf_simple_pull_mem>
	if (!att_chan->att) {
    9798:	f854 3c08 	ldr.w	r3, [r4, #-8]
    979c:	4605      	mov	r5, r0
    979e:	2b00      	cmp	r3, #0
    97a0:	d0f0      	beq.n	9784 <bt_att_recv+0x28>
		if (hdr->code == handlers[i].op) {
    97a2:	7801      	ldrb	r1, [r0, #0]
    97a4:	4a48      	ldr	r2, [pc, #288]	; (98c8 <bt_att_recv+0x16c>)
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
    97a6:	f1a4 0608 	sub.w	r6, r4, #8
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    97aa:	2300      	movs	r3, #0
		if (hdr->code == handlers[i].op) {
    97ac:	f812 0033 	ldrb.w	r0, [r2, r3, lsl #3]
    97b0:	4288      	cmp	r0, r1
    97b2:	d121      	bne.n	97f8 <bt_att_recv+0x9c>
		if (handler->type == ATT_REQUEST &&
    97b4:	00d9      	lsls	r1, r3, #3
    97b6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    97ba:	f893 8002 	ldrb.w	r8, [r3, #2]
    97be:	f1b8 0f01 	cmp.w	r8, #1
    97c2:	d139      	bne.n	9838 <bt_att_recv+0xdc>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    97c4:	f3bf 8f5b 	dmb	ish
    97c8:	34e8      	adds	r4, #232	; 0xe8
    97ca:	e854 3f00 	ldrex	r3, [r4]
    97ce:	f043 0001 	orr.w	r0, r3, #1
    97d2:	e844 0c00 	strex	ip, r0, [r4]
    97d6:	f1bc 0f00 	cmp.w	ip, #0
    97da:	d1f6      	bne.n	97ca <bt_att_recv+0x6e>
    97dc:	f3bf 8f5b 	dmb	ish
    97e0:	07d8      	lsls	r0, r3, #31
    97e2:	d53e      	bpl.n	9862 <bt_att_recv+0x106>
			BT_WARN("Ignoring unexpected request");
    97e4:	4b39      	ldr	r3, [pc, #228]	; (98cc <bt_att_recv+0x170>)
			BT_WARN("Ignoring unexpected indication");
    97e6:	61bb      	str	r3, [r7, #24]
    97e8:	2302      	movs	r3, #2
    97ea:	607b      	str	r3, [r7, #4]
    97ec:	617b      	str	r3, [r7, #20]
    97ee:	f107 0214 	add.w	r2, r7, #20
    97f2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    97f6:	e7c2      	b.n	977e <bt_att_recv+0x22>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    97f8:	3301      	adds	r3, #1
    97fa:	2b0d      	cmp	r3, #13
    97fc:	d1d6      	bne.n	97ac <bt_att_recv+0x50>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    97fe:	4b34      	ldr	r3, [pc, #208]	; (98d0 <bt_att_recv+0x174>)
    9800:	4830      	ldr	r0, [pc, #192]	; (98c4 <bt_att_recv+0x168>)
    9802:	e9c7 3106 	strd	r3, r1, [r7, #24]
    9806:	f107 0214 	add.w	r2, r7, #20
    980a:	2303      	movs	r3, #3
    980c:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    9810:	607b      	str	r3, [r7, #4]
    9812:	617b      	str	r3, [r7, #20]
    9814:	f01e ffcd 	bl	287b2 <z_log_msg2_static_create.constprop.0>
		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
    9818:	7829      	ldrb	r1, [r5, #0]
    981a:	4608      	mov	r0, r1
    981c:	f01e fec2 	bl	285a4 <att_op_get_type>
    9820:	2800      	cmp	r0, #0
    9822:	d0af      	beq.n	9784 <bt_att_recv+0x28>
    9824:	2805      	cmp	r0, #5
    9826:	d0ad      	beq.n	9784 <bt_att_recv+0x28>
	if (!req) {
    9828:	2900      	cmp	r1, #0
    982a:	d0ab      	beq.n	9784 <bt_att_recv+0x28>
    982c:	2306      	movs	r3, #6
    982e:	2200      	movs	r2, #0
    9830:	4630      	mov	r0, r6
    9832:	f01f f96b 	bl	28b0c <send_err_rsp.part.0>
    9836:	e7a5      	b.n	9784 <bt_att_recv+0x28>
		} else if (handler->type == ATT_INDICATION &&
    9838:	f1b8 0f05 	cmp.w	r8, #5
    983c:	d111      	bne.n	9862 <bt_att_recv+0x106>
    983e:	f3bf 8f5b 	dmb	ish
    9842:	34e8      	adds	r4, #232	; 0xe8
    9844:	e854 3f00 	ldrex	r3, [r4]
    9848:	f043 0002 	orr.w	r0, r3, #2
    984c:	e844 0c00 	strex	ip, r0, [r4]
    9850:	f1bc 0f00 	cmp.w	ip, #0
    9854:	d1f6      	bne.n	9844 <bt_att_recv+0xe8>
    9856:	f3bf 8f5b 	dmb	ish
    985a:	079b      	lsls	r3, r3, #30
    985c:	d501      	bpl.n	9862 <bt_att_recv+0x106>
			BT_WARN("Ignoring unexpected indication");
    985e:	4b1d      	ldr	r3, [pc, #116]	; (98d4 <bt_att_recv+0x178>)
    9860:	e7c1      	b.n	97e6 <bt_att_recv+0x8a>
	if (buf->len < handler->expect_len) {
    9862:	440a      	add	r2, r1
    9864:	f8b9 300c 	ldrh.w	r3, [r9, #12]
    9868:	7851      	ldrb	r1, [r2, #1]
    986a:	4299      	cmp	r1, r3
    986c:	d917      	bls.n	989e <bt_att_recv+0x142>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    986e:	46e9      	mov	r9, sp
    9870:	b088      	sub	sp, #32
    9872:	466a      	mov	r2, sp
    9874:	4818      	ldr	r0, [pc, #96]	; (98d8 <bt_att_recv+0x17c>)
    9876:	7829      	ldrb	r1, [r5, #0]
    9878:	6191      	str	r1, [r2, #24]
    987a:	2404      	movs	r4, #4
    987c:	e9c2 0304 	strd	r0, r3, [r2, #16]
    9880:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    9884:	f842 4f0c 	str.w	r4, [r2, #12]!
    9888:	480e      	ldr	r0, [pc, #56]	; (98c4 <bt_att_recv+0x168>)
    988a:	60bc      	str	r4, [r7, #8]
    988c:	f01e ff91 	bl	287b2 <z_log_msg2_static_create.constprop.0>
	if (handler->type == ATT_REQUEST && err) {
    9890:	f1b8 0f01 	cmp.w	r8, #1
    9894:	46cd      	mov	sp, r9
    9896:	f47f af75 	bne.w	9784 <bt_att_recv+0x28>
		err = BT_ATT_ERR_INVALID_PDU;
    989a:	4623      	mov	r3, r4
    989c:	e00b      	b.n	98b6 <bt_att_recv+0x15a>
		err = handler->func(att_chan, buf);
    989e:	6853      	ldr	r3, [r2, #4]
    98a0:	4649      	mov	r1, r9
    98a2:	4630      	mov	r0, r6
    98a4:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
    98a6:	f1b8 0f01 	cmp.w	r8, #1
		err = handler->func(att_chan, buf);
    98aa:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
    98ac:	f47f af6a 	bne.w	9784 <bt_att_recv+0x28>
    98b0:	2800      	cmp	r0, #0
    98b2:	f43f af67 	beq.w	9784 <bt_att_recv+0x28>
		send_err_rsp(att_chan, hdr->code, 0, err);
    98b6:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
    98b8:	2900      	cmp	r1, #0
    98ba:	f43f af63 	beq.w	9784 <bt_att_recv+0x28>
    98be:	e7b6      	b.n	982e <bt_att_recv+0xd2>
    98c0:	0003037e 	.word	0x0003037e
    98c4:	0002d9cc 	.word	0x0002d9cc
    98c8:	0002e24c 	.word	0x0002e24c
    98cc:	00030399 	.word	0x00030399
    98d0:	000303f3 	.word	0x000303f3
    98d4:	000303b5 	.word	0x000303b5
    98d8:	000303d4 	.word	0x000303d4

000098dc <att_write_rsp.constprop.0>:
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
    98dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    98e0:	461f      	mov	r7, r3
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    98e2:	6803      	ldr	r3, [r0, #0]
    98e4:	460e      	mov	r6, r1
    98e6:	3900      	subs	r1, #0
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
    98e8:	b087      	sub	sp, #28
    98ea:	4605      	mov	r5, r0
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    98ec:	bf18      	it	ne
    98ee:	2101      	movne	r1, #1
    98f0:	6818      	ldr	r0, [r3, #0]
static uint8_t att_write_rsp(struct bt_att_chan *chan, uint8_t req, uint8_t rsp,
    98f2:	4690      	mov	r8, r2
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    98f4:	f01f fcad 	bl	29252 <bt_gatt_change_aware>
    98f8:	2800      	cmp	r0, #0
    98fa:	d04a      	beq.n	9992 <att_write_rsp.constprop.0+0xb6>
	if (!handle) {
    98fc:	2f00      	cmp	r7, #0
    98fe:	d04a      	beq.n	9996 <att_write_rsp.constprop.0+0xba>
	(void)memset(&data, 0, sizeof(data));
    9900:	2218      	movs	r2, #24
    9902:	2100      	movs	r1, #0
    9904:	4668      	mov	r0, sp
    9906:	f01d ffbe 	bl	27886 <memset>
	if (rsp) {
    990a:	f1b8 0f00 	cmp.w	r8, #0
    990e:	d122      	bne.n	9956 <att_write_rsp.constprop.0+0x7a>
	data.conn = chan->att->conn;
    9910:	682b      	ldr	r3, [r5, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    9912:	4a22      	ldr	r2, [pc, #136]	; (999c <att_write_rsp.constprop.0+0xc0>)
	data.conn = chan->att->conn;
    9914:	681b      	ldr	r3, [r3, #0]
    9916:	9300      	str	r3, [sp, #0]
	data.value = value;
    9918:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    991a:	9303      	str	r3, [sp, #12]
	data.len = len;
    991c:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
    9920:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    9924:	2301      	movs	r3, #1
    9926:	f88d 3014 	strb.w	r3, [sp, #20]
	data.offset = offset;
    992a:	f04f 0900 	mov.w	r9, #0
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    992e:	466b      	mov	r3, sp
    9930:	4639      	mov	r1, r7
    9932:	4638      	mov	r0, r7
	data.req = req;
    9934:	f88d 6008 	strb.w	r6, [sp, #8]
	data.offset = offset;
    9938:	f8ad 9012 	strh.w	r9, [sp, #18]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    993c:	f01e fe5f 	bl	285fe <bt_gatt_foreach_attr>
	if (data.err) {
    9940:	f89d 4014 	ldrb.w	r4, [sp, #20]
    9944:	b1f4      	cbz	r4, 9984 <att_write_rsp.constprop.0+0xa8>
		if (rsp) {
    9946:	f1b8 0f00 	cmp.w	r8, #0
    994a:	d10e      	bne.n	996a <att_write_rsp.constprop.0+0x8e>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    994c:	2400      	movs	r4, #0
}
    994e:	4620      	mov	r0, r4
    9950:	b007      	add	sp, #28
    9952:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
    9956:	2200      	movs	r2, #0
    9958:	4641      	mov	r1, r8
    995a:	4628      	mov	r0, r5
    995c:	f7ff feb0 	bl	96c0 <bt_att_chan_create_pdu>
    9960:	9001      	str	r0, [sp, #4]
		if (!data.buf) {
    9962:	2800      	cmp	r0, #0
    9964:	d1d4      	bne.n	9910 <att_write_rsp.constprop.0+0x34>
			return BT_ATT_ERR_UNLIKELY;
    9966:	240e      	movs	r4, #14
    9968:	e7f1      	b.n	994e <att_write_rsp.constprop.0+0x72>
			net_buf_unref(data.buf);
    996a:	9801      	ldr	r0, [sp, #4]
    996c:	f016 ff92 	bl	20894 <net_buf_unref>
	if (!req) {
    9970:	2e00      	cmp	r6, #0
    9972:	d0eb      	beq.n	994c <att_write_rsp.constprop.0+0x70>
    9974:	f89d 3014 	ldrb.w	r3, [sp, #20]
    9978:	463a      	mov	r2, r7
    997a:	4631      	mov	r1, r6
    997c:	4628      	mov	r0, r5
    997e:	f01f f8c5 	bl	28b0c <send_err_rsp.part.0>
    9982:	e7e3      	b.n	994c <att_write_rsp.constprop.0+0x70>
	if (data.buf) {
    9984:	9901      	ldr	r1, [sp, #4]
    9986:	2900      	cmp	r1, #0
    9988:	d0e0      	beq.n	994c <att_write_rsp.constprop.0+0x70>
		bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    998a:	4628      	mov	r0, r5
    998c:	f7ff fdfe 	bl	958c <bt_att_chan_send_rsp.constprop.0>
    9990:	e7dd      	b.n	994e <att_write_rsp.constprop.0+0x72>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    9992:	2412      	movs	r4, #18
    9994:	e7db      	b.n	994e <att_write_rsp.constprop.0+0x72>
		return BT_ATT_ERR_INVALID_HANDLE;
    9996:	2401      	movs	r4, #1
    9998:	e7d9      	b.n	994e <att_write_rsp.constprop.0+0x72>
    999a:	bf00      	nop
    999c:	0002874f 	.word	0x0002874f

000099a0 <bt_att_create_pdu>:
{
    99a0:	b570      	push	{r4, r5, r6, lr}
    99a2:	b088      	sub	sp, #32
    99a4:	460e      	mov	r6, r1
    99a6:	4615      	mov	r5, r2
	att = att_get(conn);
    99a8:	f7ff fc92 	bl	92d0 <att_get>
	if (!att) {
    99ac:	b1c8      	cbz	r0, 99e2 <bt_att_create_pdu+0x42>
	return list->head;
    99ae:	6a43      	ldr	r3, [r0, #36]	; 0x24
    99b0:	1c6a      	adds	r2, r5, #1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    99b2:	b153      	cbz	r3, 99ca <bt_att_create_pdu+0x2a>
    99b4:	f5a3 70a2 	sub.w	r0, r3, #324	; 0x144
	return node->next;
    99b8:	681b      	ldr	r3, [r3, #0]
    99ba:	b10b      	cbz	r3, 99c0 <bt_att_create_pdu+0x20>
    99bc:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
		if (len + sizeof(op) > chan->chan.tx.mtu) {
    99c0:	f8b0 108a 	ldrh.w	r1, [r0, #138]	; 0x8a
    99c4:	428a      	cmp	r2, r1
    99c6:	d90f      	bls.n	99e8 <bt_att_create_pdu+0x48>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    99c8:	b9ab      	cbnz	r3, 99f6 <bt_att_create_pdu+0x56>
	BT_WARN("No ATT channel for MTU %zu", len + sizeof(op));
    99ca:	4b0f      	ldr	r3, [pc, #60]	; (9a08 <bt_att_create_pdu+0x68>)
    99cc:	480f      	ldr	r0, [pc, #60]	; (9a0c <bt_att_create_pdu+0x6c>)
    99ce:	e9cd 3206 	strd	r3, r2, [sp, #24]
    99d2:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    99d6:	2303      	movs	r3, #3
    99d8:	aa05      	add	r2, sp, #20
    99da:	9301      	str	r3, [sp, #4]
    99dc:	9305      	str	r3, [sp, #20]
    99de:	f01e fee8 	bl	287b2 <z_log_msg2_static_create.constprop.0>
}
    99e2:	2000      	movs	r0, #0
    99e4:	b008      	add	sp, #32
    99e6:	bd70      	pop	{r4, r5, r6, pc}
		return bt_att_chan_create_pdu(chan, op, len);
    99e8:	462a      	mov	r2, r5
    99ea:	4631      	mov	r1, r6
}
    99ec:	b008      	add	sp, #32
    99ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_att_chan_create_pdu(chan, op, len);
    99f2:	f7ff be65 	b.w	96c0 <bt_att_chan_create_pdu>
    99f6:	f8d3 4144 	ldr.w	r4, [r3, #324]	; 0x144
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    99fa:	b10c      	cbz	r4, 9a00 <bt_att_create_pdu+0x60>
    99fc:	f5a4 74a2 	sub.w	r4, r4, #324	; 0x144
{
    9a00:	4618      	mov	r0, r3
    9a02:	4623      	mov	r3, r4
    9a04:	e7dc      	b.n	99c0 <bt_att_create_pdu+0x20>
    9a06:	bf00      	nop
    9a08:	0003040d 	.word	0x0003040d
    9a0c:	0002d9cc 	.word	0x0002d9cc

00009a10 <att_read_group_req>:
{
    9a10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
    9a14:	898c      	ldrh	r4, [r1, #12]
    9a16:	3c04      	subs	r4, #4
    9a18:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    9a1a:	2c02      	cmp	r4, #2
{
    9a1c:	4605      	mov	r5, r0
    9a1e:	b08c      	sub	sp, #48	; 0x30
    9a20:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    9a22:	d001      	beq.n	9a28 <att_read_group_req+0x18>
    9a24:	2c10      	cmp	r4, #16
    9a26:	d16e      	bne.n	9b06 <att_read_group_req+0xf6>
    9a28:	2104      	movs	r1, #4
    9a2a:	3008      	adds	r0, #8
    9a2c:	f022 f9fe 	bl	2be2c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9a30:	f10d 0808 	add.w	r8, sp, #8
	start_handle = sys_le16_to_cpu(req->start_handle);
    9a34:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    9a36:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9a38:	1d01      	adds	r1, r0, #4
    9a3a:	4622      	mov	r2, r4
    9a3c:	4640      	mov	r0, r8
    9a3e:	f01e f992 	bl	27d66 <bt_uuid_create>
    9a42:	2800      	cmp	r0, #0
    9a44:	d061      	beq.n	9b0a <att_read_group_req+0xfa>
	if (!start || !end) {
    9a46:	2e00      	cmp	r6, #0
    9a48:	d03a      	beq.n	9ac0 <att_read_group_req+0xb0>
    9a4a:	2400      	movs	r4, #0
    9a4c:	2f00      	cmp	r7, #0
    9a4e:	d036      	beq.n	9abe <att_read_group_req+0xae>
	if (start > end) {
    9a50:	42b7      	cmp	r7, r6
    9a52:	d335      	bcc.n	9ac0 <att_read_group_req+0xb0>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    9a54:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9a58:	a901      	add	r1, sp, #4
    9a5a:	4640      	mov	r0, r8
    9a5c:	f88d 4004 	strb.w	r4, [sp, #4]
    9a60:	f8ad 3006 	strh.w	r3, [sp, #6]
    9a64:	f01e f951 	bl	27d0a <bt_uuid_cmp>
    9a68:	2800      	cmp	r0, #0
    9a6a:	d134      	bne.n	9ad6 <att_read_group_req+0xc6>
	struct bt_conn *conn = chan->chan.chan.conn;
    9a6c:	68ac      	ldr	r4, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    9a6e:	2214      	movs	r2, #20
    9a70:	2100      	movs	r1, #0
    9a72:	a807      	add	r0, sp, #28
    9a74:	f01d ff07 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    9a78:	2201      	movs	r2, #1
    9a7a:	2111      	movs	r1, #17
    9a7c:	4620      	mov	r0, r4
    9a7e:	f7ff ff8f 	bl	99a0 <bt_att_create_pdu>
    9a82:	9009      	str	r0, [sp, #36]	; 0x24
	if (!data.buf) {
    9a84:	2800      	cmp	r0, #0
    9a86:	d040      	beq.n	9b0a <att_read_group_req+0xfa>
	return net_buf_simple_add(&buf->b, len);
    9a88:	2101      	movs	r1, #1
    9a8a:	3008      	adds	r0, #8
	data.uuid = uuid;
    9a8c:	e9cd 5807 	strd	r5, r8, [sp, #28]
    9a90:	f022 f954 	bl	2bd3c <net_buf_simple_add>
	data.rsp->len = 0U;
    9a94:	f04f 0800 	mov.w	r8, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9a98:	900a      	str	r0, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    9a9a:	ab07      	add	r3, sp, #28
	data.rsp->len = 0U;
    9a9c:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    9aa0:	4a1b      	ldr	r2, [pc, #108]	; (9b10 <att_read_group_req+0x100>)
	data.group = NULL;
    9aa2:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    9aa6:	4639      	mov	r1, r7
    9aa8:	4630      	mov	r0, r6
    9aaa:	f01e fda8 	bl	285fe <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
    9aae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9ab0:	781c      	ldrb	r4, [r3, #0]
    9ab2:	bb1c      	cbnz	r4, 9afc <att_read_group_req+0xec>
		net_buf_unref(data.buf);
    9ab4:	9809      	ldr	r0, [sp, #36]	; 0x24
    9ab6:	f016 feed 	bl	20894 <net_buf_unref>
	if (!req) {
    9aba:	230a      	movs	r3, #10
    9abc:	e018      	b.n	9af0 <att_read_group_req+0xe0>
			*err = 0U;
    9abe:	463e      	mov	r6, r7
	if (!req) {
    9ac0:	2301      	movs	r3, #1
    9ac2:	4632      	mov	r2, r6
    9ac4:	2110      	movs	r1, #16
    9ac6:	4628      	mov	r0, r5
    9ac8:	f01f f820 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9acc:	2400      	movs	r4, #0
}
    9ace:	4620      	mov	r0, r4
    9ad0:	b00c      	add	sp, #48	; 0x30
    9ad2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
    9ad6:	f642 0301 	movw	r3, #10241	; 0x2801
    9ada:	a907      	add	r1, sp, #28
    9adc:	4640      	mov	r0, r8
    9ade:	f88d 401c 	strb.w	r4, [sp, #28]
    9ae2:	f8ad 301e 	strh.w	r3, [sp, #30]
    9ae6:	f01e f910 	bl	27d0a <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    9aea:	2800      	cmp	r0, #0
    9aec:	d0be      	beq.n	9a6c <att_read_group_req+0x5c>
	if (!req) {
    9aee:	2310      	movs	r3, #16
    9af0:	4632      	mov	r2, r6
    9af2:	2110      	movs	r1, #16
    9af4:	4628      	mov	r0, r5
    9af6:	f01f f809 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9afa:	e7e8      	b.n	9ace <att_read_group_req+0xbe>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9afc:	9909      	ldr	r1, [sp, #36]	; 0x24
    9afe:	4628      	mov	r0, r5
    9b00:	f7ff fd44 	bl	958c <bt_att_chan_send_rsp.constprop.0>
	return 0;
    9b04:	e7e2      	b.n	9acc <att_read_group_req+0xbc>
		return BT_ATT_ERR_INVALID_PDU;
    9b06:	2404      	movs	r4, #4
    9b08:	e7e1      	b.n	9ace <att_read_group_req+0xbe>
		return BT_ATT_ERR_UNLIKELY;
    9b0a:	240e      	movs	r4, #14
    9b0c:	e7df      	b.n	9ace <att_read_group_req+0xbe>
    9b0e:	bf00      	nop
    9b10:	00009405 	.word	0x00009405

00009b14 <att_read_mult_req>:
{
    9b14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
    9b18:	6886      	ldr	r6, [r0, #8]
{
    9b1a:	b085      	sub	sp, #20
    9b1c:	4604      	mov	r4, r0
    9b1e:	460d      	mov	r5, r1
	if (!bt_gatt_change_aware(conn, true)) {
    9b20:	4630      	mov	r0, r6
    9b22:	2101      	movs	r1, #1
    9b24:	f01f fb95 	bl	29252 <bt_gatt_change_aware>
    9b28:	b3b8      	cbz	r0, 9b9a <att_read_mult_req+0x86>
	(void)memset(&data, 0, sizeof(data));
    9b2a:	2210      	movs	r2, #16
    9b2c:	2100      	movs	r1, #0
    9b2e:	4668      	mov	r0, sp
    9b30:	f01d fea9 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    9b34:	2200      	movs	r2, #0
    9b36:	210f      	movs	r1, #15
    9b38:	4630      	mov	r0, r6
    9b3a:	f7ff ff31 	bl	99a0 <bt_att_create_pdu>
    9b3e:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    9b40:	b368      	cbz	r0, 9b9e <att_read_mult_req+0x8a>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9b42:	f8df 9060 	ldr.w	r9, [pc, #96]	; 9ba4 <att_read_mult_req+0x90>
	data.chan = chan;
    9b46:	9400      	str	r4, [sp, #0]
	return net_buf_simple_pull_le16(&buf->b);
    9b48:	f105 0708 	add.w	r7, r5, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    9b4c:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(uint16_t)) {
    9b50:	89ab      	ldrh	r3, [r5, #12]
    9b52:	2b01      	cmp	r3, #1
    9b54:	d804      	bhi.n	9b60 <att_read_mult_req+0x4c>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9b56:	9902      	ldr	r1, [sp, #8]
    9b58:	4620      	mov	r0, r4
    9b5a:	f7ff fd17 	bl	958c <bt_att_chan_send_rsp.constprop.0>
    9b5e:	e018      	b.n	9b92 <att_read_mult_req+0x7e>
    9b60:	4638      	mov	r0, r7
    9b62:	f022 f973 	bl	2be4c <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9b66:	466b      	mov	r3, sp
    9b68:	464a      	mov	r2, r9
    9b6a:	4601      	mov	r1, r0
    9b6c:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    9b6e:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9b72:	f01e fd44 	bl	285fe <bt_gatt_foreach_attr>
		if (data.err) {
    9b76:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9b7a:	2b00      	cmp	r3, #0
    9b7c:	d0e8      	beq.n	9b50 <att_read_mult_req+0x3c>
			net_buf_unref(data.buf);
    9b7e:	9802      	ldr	r0, [sp, #8]
    9b80:	f016 fe88 	bl	20894 <net_buf_unref>
	if (!req) {
    9b84:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9b88:	4632      	mov	r2, r6
    9b8a:	210e      	movs	r1, #14
    9b8c:	4620      	mov	r0, r4
    9b8e:	f01e ffbd 	bl	28b0c <send_err_rsp.part.0>
	return 0;
    9b92:	2000      	movs	r0, #0
}
    9b94:	b005      	add	sp, #20
    9b96:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    9b9a:	2012      	movs	r0, #18
    9b9c:	e7fa      	b.n	9b94 <att_read_mult_req+0x80>
		return BT_ATT_ERR_UNLIKELY;
    9b9e:	200e      	movs	r0, #14
    9ba0:	e7f8      	b.n	9b94 <att_read_mult_req+0x80>
    9ba2:	bf00      	nop
    9ba4:	000289a7 	.word	0x000289a7

00009ba8 <att_read_rsp>:
{
    9ba8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
    9bac:	f8d0 8008 	ldr.w	r8, [r0, #8]
{
    9bb0:	4605      	mov	r5, r0
    9bb2:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
    9bb4:	4640      	mov	r0, r8
    9bb6:	2101      	movs	r1, #1
{
    9bb8:	4614      	mov	r4, r2
    9bba:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(conn, true)) {
    9bbc:	f01f fb49 	bl	29252 <bt_gatt_change_aware>
    9bc0:	b388      	cbz	r0, 9c26 <att_read_rsp+0x7e>
	if (!handle) {
    9bc2:	b396      	cbz	r6, 9c2a <att_read_rsp+0x82>
	(void)memset(&data, 0, sizeof(data));
    9bc4:	2210      	movs	r2, #16
    9bc6:	2100      	movs	r1, #0
    9bc8:	4668      	mov	r0, sp
    9bca:	f01d fe5c 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    9bce:	2200      	movs	r2, #0
    9bd0:	4621      	mov	r1, r4
    9bd2:	4640      	mov	r0, r8
    9bd4:	f7ff fee4 	bl	99a0 <bt_att_create_pdu>
    9bd8:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    9bda:	b340      	cbz	r0, 9c2e <att_read_rsp+0x86>
	data.offset = offset;
    9bdc:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    9be0:	f8ad 3004 	strh.w	r3, [sp, #4]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    9be4:	2301      	movs	r3, #1
    9be6:	f88d 300c 	strb.w	r3, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9bea:	4a12      	ldr	r2, [pc, #72]	; (9c34 <att_read_rsp+0x8c>)
	data.chan = chan;
    9bec:	9500      	str	r5, [sp, #0]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    9bee:	466b      	mov	r3, sp
    9bf0:	4631      	mov	r1, r6
    9bf2:	4630      	mov	r0, r6
    9bf4:	f01e fd03 	bl	285fe <bt_gatt_foreach_attr>
	if (data.err) {
    9bf8:	f89d 400c 	ldrb.w	r4, [sp, #12]
    9bfc:	b174      	cbz	r4, 9c1c <att_read_rsp+0x74>
		net_buf_unref(data.buf);
    9bfe:	9802      	ldr	r0, [sp, #8]
    9c00:	f016 fe48 	bl	20894 <net_buf_unref>
	if (!req) {
    9c04:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9c08:	4632      	mov	r2, r6
    9c0a:	4639      	mov	r1, r7
    9c0c:	4628      	mov	r0, r5
    9c0e:	f01e ff7d 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9c12:	2400      	movs	r4, #0
}
    9c14:	4620      	mov	r0, r4
    9c16:	b004      	add	sp, #16
    9c18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9c1c:	9902      	ldr	r1, [sp, #8]
    9c1e:	4628      	mov	r0, r5
    9c20:	f7ff fcb4 	bl	958c <bt_att_chan_send_rsp.constprop.0>
	return 0;
    9c24:	e7f6      	b.n	9c14 <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    9c26:	2412      	movs	r4, #18
    9c28:	e7f4      	b.n	9c14 <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
    9c2a:	2401      	movs	r4, #1
    9c2c:	e7f2      	b.n	9c14 <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    9c2e:	240e      	movs	r4, #14
    9c30:	e7f0      	b.n	9c14 <att_read_rsp+0x6c>
    9c32:	bf00      	nop
    9c34:	000289a7 	.word	0x000289a7

00009c38 <att_read_type_req>:
{
    9c38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
    9c3c:	898c      	ldrh	r4, [r1, #12]
    9c3e:	3c04      	subs	r4, #4
    9c40:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    9c42:	2c02      	cmp	r4, #2
{
    9c44:	4605      	mov	r5, r0
    9c46:	b08c      	sub	sp, #48	; 0x30
    9c48:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
    9c4a:	d001      	beq.n	9c50 <att_read_type_req+0x18>
    9c4c:	2c10      	cmp	r4, #16
    9c4e:	d14f      	bne.n	9cf0 <att_read_type_req+0xb8>
	return net_buf_simple_pull_mem(&buf->b, len);
    9c50:	2104      	movs	r1, #4
    9c52:	3008      	adds	r0, #8
    9c54:	f022 f8ea 	bl	2be2c <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9c58:	f10d 0804 	add.w	r8, sp, #4
	start_handle = sys_le16_to_cpu(req->start_handle);
    9c5c:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    9c5e:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    9c60:	1d01      	adds	r1, r0, #4
    9c62:	4622      	mov	r2, r4
    9c64:	4640      	mov	r0, r8
    9c66:	f01e f87e 	bl	27d66 <bt_uuid_create>
    9c6a:	b188      	cbz	r0, 9c90 <att_read_type_req+0x58>
	if (!start || !end) {
    9c6c:	b19e      	cbz	r6, 9c96 <att_read_type_req+0x5e>
    9c6e:	b18f      	cbz	r7, 9c94 <att_read_type_req+0x5c>
	if (start > end) {
    9c70:	42be      	cmp	r6, r7
    9c72:	d810      	bhi.n	9c96 <att_read_type_req+0x5e>
	(void)memset(&data, 0, sizeof(data));
    9c74:	2218      	movs	r2, #24
	struct bt_conn *conn = chan->chan.chan.conn;
    9c76:	68ac      	ldr	r4, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    9c78:	2100      	movs	r1, #0
    9c7a:	eb0d 0002 	add.w	r0, sp, r2
    9c7e:	f01d fe02 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    9c82:	2201      	movs	r2, #1
    9c84:	2109      	movs	r1, #9
    9c86:	4620      	mov	r0, r4
    9c88:	f7ff fe8a 	bl	99a0 <bt_att_create_pdu>
    9c8c:	9008      	str	r0, [sp, #32]
	if (!data.buf) {
    9c8e:	b968      	cbnz	r0, 9cac <att_read_type_req+0x74>
		return BT_ATT_ERR_UNLIKELY;
    9c90:	240e      	movs	r4, #14
    9c92:	e007      	b.n	9ca4 <att_read_type_req+0x6c>
			*err = 0U;
    9c94:	463e      	mov	r6, r7
	if (!req) {
    9c96:	2301      	movs	r3, #1
    9c98:	4632      	mov	r2, r6
    9c9a:	2108      	movs	r1, #8
    9c9c:	4628      	mov	r0, r5
    9c9e:	f01e ff35 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9ca2:	2400      	movs	r4, #0
}
    9ca4:	4620      	mov	r0, r4
    9ca6:	b00c      	add	sp, #48	; 0x30
    9ca8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return net_buf_simple_add(&buf->b, len);
    9cac:	2101      	movs	r1, #1
    9cae:	3008      	adds	r0, #8
	data.uuid = uuid;
    9cb0:	e9cd 5806 	strd	r5, r8, [sp, #24]
    9cb4:	f022 f842 	bl	2bd3c <net_buf_simple_add>
	data.rsp->len = 0U;
    9cb8:	f04f 0800 	mov.w	r8, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    9cbc:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    9cbe:	9009      	str	r0, [sp, #36]	; 0x24
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    9cc0:	4a0c      	ldr	r2, [pc, #48]	; (9cf4 <att_read_type_req+0xbc>)
	data.rsp->len = 0U;
    9cc2:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    9cc6:	4639      	mov	r1, r7
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    9cc8:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    9ccc:	4630      	mov	r0, r6
    9cce:	ab06      	add	r3, sp, #24
    9cd0:	f01e fc95 	bl	285fe <bt_gatt_foreach_attr>
	if (data.err) {
    9cd4:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
    9cd8:	b12c      	cbz	r4, 9ce6 <att_read_type_req+0xae>
		net_buf_unref(data.buf);
    9cda:	9808      	ldr	r0, [sp, #32]
    9cdc:	f016 fdda 	bl	20894 <net_buf_unref>
	if (!req) {
    9ce0:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    9ce4:	e7d8      	b.n	9c98 <att_read_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9ce6:	9908      	ldr	r1, [sp, #32]
    9ce8:	4628      	mov	r0, r5
    9cea:	f7ff fc4f 	bl	958c <bt_att_chan_send_rsp.constprop.0>
	return 0;
    9cee:	e7d9      	b.n	9ca4 <att_read_type_req+0x6c>
		return BT_ATT_ERR_INVALID_PDU;
    9cf0:	2404      	movs	r4, #4
    9cf2:	e7d7      	b.n	9ca4 <att_read_type_req+0x6c>
    9cf4:	000095b1 	.word	0x000095b1

00009cf8 <att_find_type_req>:
{
    9cf8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9cfc:	4688      	mov	r8, r1
    9cfe:	b086      	sub	sp, #24
    9d00:	4605      	mov	r5, r0
	return net_buf_simple_pull_mem(&buf->b, len);
    9d02:	2106      	movs	r1, #6
    9d04:	f108 0008 	add.w	r0, r8, #8
    9d08:	f022 f890 	bl	2be2c <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
    9d0c:	8807      	ldrh	r7, [r0, #0]
	if (!start || !end) {
    9d0e:	b317      	cbz	r7, 9d56 <att_find_type_req+0x5e>
	end_handle = sys_le16_to_cpu(req->end_handle);
    9d10:	f8b0 9002 	ldrh.w	r9, [r0, #2]
	if (!start || !end) {
    9d14:	f1b9 0f00 	cmp.w	r9, #0
    9d18:	d01c      	beq.n	9d54 <att_find_type_req+0x5c>
	if (start > end) {
    9d1a:	45b9      	cmp	r9, r7
    9d1c:	d31b      	bcc.n	9d56 <att_find_type_req+0x5e>
	type = sys_le16_to_cpu(req->type);
    9d1e:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    9d20:	f8ad 3002 	strh.w	r3, [sp, #2]
    9d24:	2400      	movs	r4, #0
    9d26:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    9d2a:	a901      	add	r1, sp, #4
    9d2c:	4668      	mov	r0, sp
	value = buf->data;
    9d2e:	f8d8 a008 	ldr.w	sl, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    9d32:	f88d 4000 	strb.w	r4, [sp]
    9d36:	f88d 4004 	strb.w	r4, [sp, #4]
    9d3a:	f8ad 3006 	strh.w	r3, [sp, #6]
    9d3e:	f01d ffe4 	bl	27d0a <bt_uuid_cmp>
    9d42:	4606      	mov	r6, r0
    9d44:	b190      	cbz	r0, 9d6c <att_find_type_req+0x74>
	if (!req) {
    9d46:	230a      	movs	r3, #10
    9d48:	463a      	mov	r2, r7
    9d4a:	2106      	movs	r1, #6
    9d4c:	4628      	mov	r0, r5
    9d4e:	f01e fedd 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9d52:	e007      	b.n	9d64 <att_find_type_req+0x6c>
			*err = 0U;
    9d54:	464f      	mov	r7, r9
	if (!req) {
    9d56:	2301      	movs	r3, #1
    9d58:	463a      	mov	r2, r7
    9d5a:	2106      	movs	r1, #6
    9d5c:	4628      	mov	r0, r5
    9d5e:	f01e fed5 	bl	28b0c <send_err_rsp.part.0>
		return 0;
    9d62:	2400      	movs	r4, #0
}
    9d64:	4620      	mov	r0, r4
    9d66:	b006      	add	sp, #24
    9d68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return att_find_type_rsp(chan, start_handle, end_handle, value,
    9d6c:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = chan->chan.chan.conn;
    9d70:	f8d5 8008 	ldr.w	r8, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    9d74:	4601      	mov	r1, r0
    9d76:	2214      	movs	r2, #20
    9d78:	a801      	add	r0, sp, #4
    9d7a:	f01d fd84 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    9d7e:	4632      	mov	r2, r6
    9d80:	2107      	movs	r1, #7
    9d82:	4640      	mov	r0, r8
    9d84:	f7ff fe0c 	bl	99a0 <bt_att_create_pdu>
    9d88:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    9d8a:	b1d8      	cbz	r0, 9dc4 <att_find_type_req+0xcc>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    9d8c:	230a      	movs	r3, #10
    9d8e:	f88d 3015 	strb.w	r3, [sp, #21]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    9d92:	4a0d      	ldr	r2, [pc, #52]	; (9dc8 <att_find_type_req+0xd0>)
	data.value_len = value_len;
    9d94:	f88d 4014 	strb.w	r4, [sp, #20]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    9d98:	ab01      	add	r3, sp, #4
    9d9a:	4649      	mov	r1, r9
    9d9c:	4638      	mov	r0, r7
	data.value = value;
    9d9e:	e9cd 6a03 	strd	r6, sl, [sp, #12]
	data.chan = chan;
    9da2:	9501      	str	r5, [sp, #4]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    9da4:	f01e fc2b 	bl	285fe <bt_gatt_foreach_attr>
	if (data.err) {
    9da8:	f89d 4015 	ldrb.w	r4, [sp, #21]
    9dac:	b12c      	cbz	r4, 9dba <att_find_type_req+0xc2>
		net_buf_unref(data.buf);
    9dae:	9802      	ldr	r0, [sp, #8]
    9db0:	f016 fd70 	bl	20894 <net_buf_unref>
	if (!req) {
    9db4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    9db8:	e7ce      	b.n	9d58 <att_find_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9dba:	9902      	ldr	r1, [sp, #8]
    9dbc:	4628      	mov	r0, r5
    9dbe:	f7ff fbe5 	bl	958c <bt_att_chan_send_rsp.constprop.0>
	return 0;
    9dc2:	e7cf      	b.n	9d64 <att_find_type_req+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    9dc4:	240e      	movs	r4, #14
	return att_find_type_rsp(chan, start_handle, end_handle, value,
    9dc6:	e7cd      	b.n	9d64 <att_find_type_req+0x6c>
    9dc8:	00009171 	.word	0x00009171

00009dcc <att_find_info_req>:
{
    9dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
    9dce:	688b      	ldr	r3, [r1, #8]
	start_handle = sys_le16_to_cpu(req->start_handle);
    9dd0:	881e      	ldrh	r6, [r3, #0]
{
    9dd2:	b085      	sub	sp, #20
    9dd4:	4605      	mov	r5, r0
	if (!start || !end) {
    9dd6:	b19e      	cbz	r6, 9e00 <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
    9dd8:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
    9dda:	b184      	cbz	r4, 9dfe <att_find_info_req+0x32>
	if (start > end) {
    9ddc:	42a6      	cmp	r6, r4
    9dde:	d80f      	bhi.n	9e00 <att_find_info_req+0x34>
	struct bt_conn *conn = chan->chan.chan.conn;
    9de0:	6887      	ldr	r7, [r0, #8]
	(void)memset(&data, 0, sizeof(data));
    9de2:	2210      	movs	r2, #16
    9de4:	2100      	movs	r1, #0
    9de6:	4668      	mov	r0, sp
    9de8:	f01d fd4d 	bl	27886 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    9dec:	2200      	movs	r2, #0
    9dee:	2105      	movs	r1, #5
    9df0:	4638      	mov	r0, r7
    9df2:	f7ff fdd5 	bl	99a0 <bt_att_create_pdu>
    9df6:	9001      	str	r0, [sp, #4]
	if (!data.buf) {
    9df8:	b958      	cbnz	r0, 9e12 <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
    9dfa:	200e      	movs	r0, #14
	return att_find_info_rsp(chan, start_handle, end_handle);
    9dfc:	e007      	b.n	9e0e <att_find_info_req+0x42>
			*err = 0U;
    9dfe:	4626      	mov	r6, r4
	if (!req) {
    9e00:	2301      	movs	r3, #1
    9e02:	4632      	mov	r2, r6
    9e04:	2104      	movs	r1, #4
    9e06:	4628      	mov	r0, r5
    9e08:	f01e fe80 	bl	28b0c <send_err_rsp.part.0>
	return 0;
    9e0c:	2000      	movs	r0, #0
}
    9e0e:	b005      	add	sp, #20
    9e10:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    9e12:	4621      	mov	r1, r4
    9e14:	4a08      	ldr	r2, [pc, #32]	; (9e38 <att_find_info_req+0x6c>)
	data.chan = chan;
    9e16:	9500      	str	r5, [sp, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    9e18:	466b      	mov	r3, sp
    9e1a:	4630      	mov	r0, r6
    9e1c:	f01e fbef 	bl	285fe <bt_gatt_foreach_attr>
	if (!data.rsp) {
    9e20:	9c02      	ldr	r4, [sp, #8]
    9e22:	b924      	cbnz	r4, 9e2e <att_find_info_req+0x62>
		net_buf_unref(data.buf);
    9e24:	9801      	ldr	r0, [sp, #4]
    9e26:	f016 fd35 	bl	20894 <net_buf_unref>
	if (!req) {
    9e2a:	230a      	movs	r3, #10
    9e2c:	e7e9      	b.n	9e02 <att_find_info_req+0x36>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    9e2e:	9901      	ldr	r1, [sp, #4]
    9e30:	4628      	mov	r0, r5
    9e32:	f7ff fbab 	bl	958c <bt_att_chan_send_rsp.constprop.0>
    9e36:	e7e9      	b.n	9e0c <att_find_info_req+0x40>
    9e38:	00028615 	.word	0x00028615

00009e3c <bt_att_req_alloc>:
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
	}
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
    9e3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_att_req *req = NULL;
    9e3e:	2300      	movs	r3, #0
{
    9e40:	4605      	mov	r5, r0
    9e42:	460c      	mov	r4, r1
	struct bt_att_req *req = NULL;
    9e44:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
    9e46:	f01a fd83 	bl	24950 <z_impl_z_current_get>

	if (k_current_get() == bt_recv_thread_id) {
    9e4a:	4b0b      	ldr	r3, [pc, #44]	; (9e78 <bt_att_req_alloc+0x3c>)
    9e4c:	681b      	ldr	r3, [r3, #0]
    9e4e:	4283      	cmp	r3, r0
		/* No req will be fulfilled while blocking on the bt_recv thread.
		 * Blocking would cause deadlock.
		 */
		timeout = K_NO_WAIT;
    9e50:	bf04      	itt	eq
    9e52:	2500      	moveq	r5, #0
    9e54:	462c      	moveq	r4, r5
	}

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    9e56:	a901      	add	r1, sp, #4
    9e58:	4808      	ldr	r0, [pc, #32]	; (9e7c <bt_att_req_alloc+0x40>)
    9e5a:	462a      	mov	r2, r5
    9e5c:	4623      	mov	r3, r4
    9e5e:	f019 fe87 	bl	23b70 <k_mem_slab_alloc>
    9e62:	4601      	mov	r1, r0
    9e64:	b930      	cbnz	r0, 9e74 <bt_att_req_alloc+0x38>
		return NULL;
	}

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
    9e66:	9801      	ldr	r0, [sp, #4]
    9e68:	2210      	movs	r2, #16
    9e6a:	f01d fd0c 	bl	27886 <memset>

	return req;
    9e6e:	9801      	ldr	r0, [sp, #4]
}
    9e70:	b003      	add	sp, #12
    9e72:	bd30      	pop	{r4, r5, pc}
		return NULL;
    9e74:	2000      	movs	r0, #0
    9e76:	e7fb      	b.n	9e70 <bt_att_req_alloc+0x34>
    9e78:	200025e4 	.word	0x200025e4
    9e7c:	20000e9c 	.word	0x20000e9c

00009e80 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    9e80:	b507      	push	{r0, r1, r2, lr}
    9e82:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	if (req->buf) {
    9e84:	6880      	ldr	r0, [r0, #8]
    9e86:	b120      	cbz	r0, 9e92 <bt_att_req_free+0x12>
		net_buf_unref(req->buf);
    9e88:	f016 fd04 	bl	20894 <net_buf_unref>
		req->buf = NULL;
    9e8c:	9b01      	ldr	r3, [sp, #4]
    9e8e:	2200      	movs	r2, #0
    9e90:	609a      	str	r2, [r3, #8]
	}

	k_mem_slab_free(&req_slab, (void **)&req);
    9e92:	4803      	ldr	r0, [pc, #12]	; (9ea0 <bt_att_req_free+0x20>)
    9e94:	a901      	add	r1, sp, #4
    9e96:	f022 fdb9 	bl	2ca0c <k_mem_slab_free>
}
    9e9a:	b003      	add	sp, #12
    9e9c:	f85d fb04 	ldr.w	pc, [sp], #4
    9ea0:	20000e9c 	.word	0x20000e9c

00009ea4 <att_handle_rsp>:
{
    9ea4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9ea8:	4604      	mov	r4, r0
    9eaa:	b08b      	sub	sp, #44	; 0x2c
	k_work_cancel_delayable(&chan->timeout_work);
    9eac:	f500 7088 	add.w	r0, r0, #272	; 0x110
{
    9eb0:	4689      	mov	r9, r1
    9eb2:	4692      	mov	sl, r2
    9eb4:	4698      	mov	r8, r3
	k_work_cancel_delayable(&chan->timeout_work);
    9eb6:	f022 ffa6 	bl	2ce06 <k_work_cancel_delayable>
	if (!chan->req) {
    9eba:	f8d4 50f4 	ldr.w	r5, [r4, #244]	; 0xf4
    9ebe:	b9dd      	cbnz	r5, 9ef8 <att_handle_rsp+0x54>
		BT_WARN("No pending ATT request");
    9ec0:	4b17      	ldr	r3, [pc, #92]	; (9f20 <att_handle_rsp+0x7c>)
    9ec2:	9308      	str	r3, [sp, #32]
    9ec4:	4817      	ldr	r0, [pc, #92]	; (9f24 <att_handle_rsp+0x80>)
    9ec6:	2302      	movs	r3, #2
    9ec8:	aa07      	add	r2, sp, #28
    9eca:	f44f 5184 	mov.w	r1, #4224	; 0x1080
	bt_att_func_t func = NULL;
    9ece:	462e      	mov	r6, r5
		BT_WARN("No pending ATT request");
    9ed0:	9303      	str	r3, [sp, #12]
    9ed2:	9307      	str	r3, [sp, #28]
    9ed4:	f01e fc6d 	bl	287b2 <z_log_msg2_static_create.constprop.0>
	att_req_send_process(chan->att);
    9ed8:	6820      	ldr	r0, [r4, #0]
    9eda:	f01e fdcb 	bl	28a74 <att_req_send_process>
	if (func) {
    9ede:	b13e      	cbz	r6, 9ef0 <att_handle_rsp+0x4c>
		func(chan->att->conn, err, pdu, len, params);
    9ee0:	6820      	ldr	r0, [r4, #0]
    9ee2:	f8cd b000 	str.w	fp, [sp]
    9ee6:	6800      	ldr	r0, [r0, #0]
    9ee8:	4653      	mov	r3, sl
    9eea:	464a      	mov	r2, r9
    9eec:	4641      	mov	r1, r8
    9eee:	47b0      	blx	r6
}
    9ef0:	2000      	movs	r0, #0
    9ef2:	b00b      	add	sp, #44	; 0x2c
    9ef4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (chan->req == &cancel) {
    9ef8:	4b0b      	ldr	r3, [pc, #44]	; (9f28 <att_handle_rsp+0x84>)
    9efa:	429d      	cmp	r5, r3
    9efc:	f04f 0700 	mov.w	r7, #0
    9f00:	d103      	bne.n	9f0a <att_handle_rsp+0x66>
		chan->req = NULL;
    9f02:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
	bt_att_func_t func = NULL;
    9f06:	463e      	mov	r6, r7
		goto process;
    9f08:	e7e6      	b.n	9ed8 <att_handle_rsp+0x34>
	func = chan->req->func;
    9f0a:	686e      	ldr	r6, [r5, #4]
	chan->req->func = NULL;
    9f0c:	606f      	str	r7, [r5, #4]
	bt_att_req_free(chan->req);
    9f0e:	4628      	mov	r0, r5
	params = chan->req->user_data;
    9f10:	f8d5 b00c 	ldr.w	fp, [r5, #12]
	bt_att_req_free(chan->req);
    9f14:	f7ff ffb4 	bl	9e80 <bt_att_req_free>
	chan->req = NULL;
    9f18:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
    9f1c:	e7dc      	b.n	9ed8 <att_handle_rsp+0x34>
    9f1e:	bf00      	nop
    9f20:	00030428 	.word	0x00030428
    9f24:	0002d9cc 	.word	0x0002d9cc
    9f28:	20002670 	.word	0x20002670

00009f2c <bt_att_disconnected>:
{
    9f2c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_att *att = att_chan->att;
    9f2e:	f850 5c08 	ldr.w	r5, [r0, #-8]
{
    9f32:	b085      	sub	sp, #20
    9f34:	4604      	mov	r4, r0
	if (!att_chan->att) {
    9f36:	2d00      	cmp	r5, #0
    9f38:	d04d      	beq.n	9fd6 <bt_att_disconnected+0xaa>
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
    9f3a:	f500 719e 	add.w	r1, r0, #316	; 0x13c
    9f3e:	f105 0024 	add.w	r0, r5, #36	; 0x24
    9f42:	f01e fcfa 	bl	2893a <sys_slist_find_and_remove.isra.0>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
    9f46:	f1a4 0608 	sub.w	r6, r4, #8
    9f4a:	f104 07f0 	add.w	r7, r4, #240	; 0xf0
    9f4e:	2200      	movs	r2, #0
    9f50:	2300      	movs	r3, #0
    9f52:	4638      	mov	r0, r7
    9f54:	f021 fe6c 	bl	2bc30 <net_buf_get>
    9f58:	4602      	mov	r2, r0
    9f5a:	bb18      	cbnz	r0, 9fa4 <bt_att_disconnected+0x78>
	if (chan->req) {
    9f5c:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    9f60:	b123      	cbz	r3, 9f6c <bt_att_disconnected+0x40>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
    9f62:	4601      	mov	r1, r0
    9f64:	230e      	movs	r3, #14
    9f66:	4630      	mov	r0, r6
    9f68:	f7ff ff9c 	bl	9ea4 <att_handle_rsp>
	chan->att = NULL;
    9f6c:	2300      	movs	r3, #0
    9f6e:	f844 3c08 	str.w	r3, [r4, #-8]
	if (!sys_slist_is_empty(&att->chans)) {
    9f72:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    9f74:	2b00      	cmp	r3, #0
    9f76:	d12e      	bne.n	9fd6 <bt_att_disconnected+0xaa>
	att_reset(att);
    9f78:	9503      	str	r5, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
    9f7a:	9803      	ldr	r0, [sp, #12]
    9f7c:	2200      	movs	r2, #0
    9f7e:	2300      	movs	r3, #0
    9f80:	300c      	adds	r0, #12
    9f82:	f021 fe55 	bl	2bc30 <net_buf_get>
    9f86:	b980      	cbnz	r0, 9faa <bt_att_disconnected+0x7e>
	while (!sys_slist_is_empty(&att->reqs)) {
    9f88:	9803      	ldr	r0, [sp, #12]
	return list->head;
    9f8a:	6845      	ldr	r5, [r0, #4]
    9f8c:	b985      	cbnz	r5, 9fb0 <bt_att_disconnected+0x84>
	att->conn = NULL;
    9f8e:	6005      	str	r5, [r0, #0]
	k_mem_slab_free(&att_slab, (void **)&att);
    9f90:	a903      	add	r1, sp, #12
    9f92:	4812      	ldr	r0, [pc, #72]	; (9fdc <bt_att_disconnected+0xb0>)
    9f94:	f022 fd3a 	bl	2ca0c <k_mem_slab_free>
	bt_gatt_disconnected(ch->chan.conn);
    9f98:	6820      	ldr	r0, [r4, #0]
}
    9f9a:	b005      	add	sp, #20
    9f9c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	bt_gatt_disconnected(ch->chan.conn);
    9fa0:	f001 bc0e 	b.w	b7c0 <bt_gatt_disconnected>
		net_buf_unref(buf);
    9fa4:	f016 fc76 	bl	20894 <net_buf_unref>
    9fa8:	e7d1      	b.n	9f4e <bt_att_disconnected+0x22>
		net_buf_unref(buf);
    9faa:	f016 fc73 	bl	20894 <net_buf_unref>
    9fae:	e7e4      	b.n	9f7a <bt_att_disconnected+0x4e>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    9fb0:	6882      	ldr	r2, [r0, #8]
		if (req->func) {
    9fb2:	686e      	ldr	r6, [r5, #4]
	return node->next;
    9fb4:	682b      	ldr	r3, [r5, #0]
	list->head = node;
    9fb6:	6043      	str	r3, [r0, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    9fb8:	4295      	cmp	r5, r2
	list->tail = node;
    9fba:	bf08      	it	eq
    9fbc:	6083      	streq	r3, [r0, #8]
    9fbe:	b136      	cbz	r6, 9fce <bt_att_disconnected+0xa2>
			req->func(att->conn, BT_ATT_ERR_UNLIKELY, NULL, 0,
    9fc0:	68eb      	ldr	r3, [r5, #12]
    9fc2:	9300      	str	r3, [sp, #0]
    9fc4:	2300      	movs	r3, #0
    9fc6:	6800      	ldr	r0, [r0, #0]
    9fc8:	461a      	mov	r2, r3
    9fca:	210e      	movs	r1, #14
    9fcc:	47b0      	blx	r6
		bt_att_req_free(req);
    9fce:	4628      	mov	r0, r5
    9fd0:	f7ff ff56 	bl	9e80 <bt_att_req_free>
    9fd4:	e7d8      	b.n	9f88 <bt_att_disconnected+0x5c>
}
    9fd6:	b005      	add	sp, #20
    9fd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9fda:	bf00      	nop
    9fdc:	20000e48 	.word	0x20000e48

00009fe0 <att_timeout>:
{
    9fe0:	b510      	push	{r4, lr}
    9fe2:	b088      	sub	sp, #32
	BT_ERR("ATT Timeout");
    9fe4:	4b09      	ldr	r3, [pc, #36]	; (a00c <att_timeout+0x2c>)
    9fe6:	9306      	str	r3, [sp, #24]
{
    9fe8:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
    9fea:	2302      	movs	r3, #2
    9fec:	4808      	ldr	r0, [pc, #32]	; (a010 <att_timeout+0x30>)
    9fee:	9301      	str	r3, [sp, #4]
    9ff0:	aa05      	add	r2, sp, #20
    9ff2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    9ff6:	9305      	str	r3, [sp, #20]
    9ff8:	f01e fbdb 	bl	287b2 <z_log_msg2_static_create.constprop.0>
	bt_att_disconnected(&chan->chan.chan);
    9ffc:	f5a4 7084 	sub.w	r0, r4, #264	; 0x108
}
    a000:	b008      	add	sp, #32
    a002:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_disconnected(&chan->chan.chan);
    a006:	f7ff bf91 	b.w	9f2c <bt_att_disconnected>
    a00a:	bf00      	nop
    a00c:	0003043f 	.word	0x0003043f
    a010:	0002d9cc 	.word	0x0002d9cc

0000a014 <find_cf_cfg>:
	atomic_set(cfg->flags, 0);
}

#if defined(CONFIG_BT_GATT_CACHING)
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
{
    a014:	b537      	push	{r0, r1, r2, r4, r5, lr}
    a016:	4d0d      	ldr	r5, [pc, #52]	; (a04c <find_cf_cfg+0x38>)
	int i;

	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
		struct gatt_cf_cfg *cfg = &cf_cfg[i];

		if (!conn) {
    a018:	4604      	mov	r4, r0
    a01a:	b960      	cbnz	r0, a036 <find_cf_cfg+0x22>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    a01c:	9000      	str	r0, [sp, #0]
    a01e:	4669      	mov	r1, sp
    a020:	f8cd 0003 	str.w	r0, [sp, #3]
    a024:	1c68      	adds	r0, r5, #1
    a026:	f01e ff10 	bl	28e4a <bt_addr_le_cmp>
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
    a02a:	2800      	cmp	r0, #0
    a02c:	bf08      	it	eq
    a02e:	462c      	moveq	r4, r5
			return cfg;
		}
	}

	return NULL;
}
    a030:	4620      	mov	r0, r4
    a032:	b003      	add	sp, #12
    a034:	bd30      	pop	{r4, r5, pc}
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    a036:	462a      	mov	r2, r5
    a038:	f812 1b01 	ldrb.w	r1, [r2], #1
    a03c:	f01e f9c2 	bl	283c4 <bt_conn_is_peer_addr_le>
	return NULL;
    a040:	2800      	cmp	r0, #0
    a042:	bf14      	ite	ne
    a044:	462c      	movne	r4, r5
    a046:	2400      	moveq	r4, #0
    a048:	e7f2      	b.n	a030 <find_cf_cfg+0x1c>
    a04a:	bf00      	nop
    a04c:	20002688 	.word	0x20002688

0000a050 <find_sc_cfg>:
{
    a050:	b510      	push	{r4, lr}
		if (id == sc_cfg[i].id &&
    a052:	4c06      	ldr	r4, [pc, #24]	; (a06c <find_sc_cfg+0x1c>)
    a054:	7823      	ldrb	r3, [r4, #0]
    a056:	4283      	cmp	r3, r0
    a058:	d103      	bne.n	a062 <find_sc_cfg+0x12>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
    a05a:	1c60      	adds	r0, r4, #1
    a05c:	f01e fef5 	bl	28e4a <bt_addr_le_cmp>
		if (id == sc_cfg[i].id &&
    a060:	b108      	cbz	r0, a066 <find_sc_cfg+0x16>
	return NULL;
    a062:	2000      	movs	r0, #0
}
    a064:	bd10      	pop	{r4, pc}
			return &sc_cfg[i];
    a066:	4620      	mov	r0, r4
    a068:	e7fc      	b.n	a064 <find_sc_cfg+0x14>
    a06a:	bf00      	nop
    a06c:	20003890 	.word	0x20003890

0000a070 <db_hash_commit>:

	return 0;
}

static int db_hash_commit(void)
{
    a070:	b508      	push	{r3, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    a072:	2108      	movs	r1, #8
    a074:	4804      	ldr	r0, [pc, #16]	; (a088 <db_hash_commit+0x18>)
    a076:	f01e fed9 	bl	28e2c <atomic_or>
	atomic_set_bit(gatt_sc.flags, DB_HASH_LOAD);
	/* Reschedule work to calculate and compare against the Hash value
	 * loaded from flash.
	 */
	k_work_reschedule(&db_hash.work, K_NO_WAIT);
    a07a:	2200      	movs	r2, #0
    a07c:	2300      	movs	r3, #0
    a07e:	4803      	ldr	r0, [pc, #12]	; (a08c <db_hash_commit+0x1c>)
    a080:	f01a f970 	bl	24364 <k_work_reschedule>

	return 0;
}
    a084:	2000      	movs	r0, #0
    a086:	bd08      	pop	{r3, pc}
    a088:	20001988 	.word	0x20001988
    a08c:	200018a8 	.word	0x200018a8

0000a090 <bt_gatt_service_init.part.0>:
static void bt_gatt_service_init(void)
    a090:	4908      	ldr	r1, [pc, #32]	; (a0b4 <bt_gatt_service_init.part.0+0x24>)
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a092:	4a09      	ldr	r2, [pc, #36]	; (a0b8 <bt_gatt_service_init.part.0+0x28>)
    a094:	880b      	ldrh	r3, [r1, #0]
static void bt_gatt_service_init(void)
    a096:	b510      	push	{r4, lr}
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a098:	4c08      	ldr	r4, [pc, #32]	; (a0bc <bt_gatt_service_init.part.0+0x2c>)
    a09a:	2000      	movs	r0, #0
    a09c:	42a2      	cmp	r2, r4
    a09e:	d302      	bcc.n	a0a6 <bt_gatt_service_init.part.0+0x16>
    a0a0:	b100      	cbz	r0, a0a4 <bt_gatt_service_init.part.0+0x14>
    a0a2:	800b      	strh	r3, [r1, #0]
}
    a0a4:	bd10      	pop	{r4, pc}
		last_static_handle += svc->attr_count;
    a0a6:	6850      	ldr	r0, [r2, #4]
    a0a8:	4403      	add	r3, r0
    a0aa:	b29b      	uxth	r3, r3
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    a0ac:	3208      	adds	r2, #8
    a0ae:	2001      	movs	r0, #1
    a0b0:	e7f4      	b.n	a09c <bt_gatt_service_init.part.0+0xc>
    a0b2:	bf00      	nop
    a0b4:	2000388e 	.word	0x2000388e
    a0b8:	0002d844 	.word	0x0002d844
    a0bc:	0002d854 	.word	0x0002d854

0000a0c0 <gatt_ccc_conn_enqueue>:
{
    a0c0:	b570      	push	{r4, r5, r6, lr}
    a0c2:	4604      	mov	r4, r0
	return (conn == gatt_ccc_store.conn_list[bt_conn_index(conn)]);
    a0c4:	f7fe fbc6 	bl	8854 <bt_conn_index>
    a0c8:	4d0e      	ldr	r5, [pc, #56]	; (a104 <gatt_ccc_conn_enqueue+0x44>)
	if ((!gatt_ccc_conn_is_queued(conn)) &&
    a0ca:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
    a0ce:	429c      	cmp	r4, r3
    a0d0:	d017      	beq.n	a102 <gatt_ccc_conn_enqueue+0x42>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a0d2:	7a20      	ldrb	r0, [r4, #8]
    a0d4:	f104 0188 	add.w	r1, r4, #136	; 0x88
    a0d8:	f01d ff1a 	bl	27f10 <bt_addr_le_is_bonded>
	if ((!gatt_ccc_conn_is_queued(conn)) &&
    a0dc:	b188      	cbz	r0, a102 <gatt_ccc_conn_enqueue+0x42>
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
    a0de:	4620      	mov	r0, r4
    a0e0:	f7fe fbb8 	bl	8854 <bt_conn_index>
    a0e4:	4606      	mov	r6, r0
			bt_conn_ref(conn);
    a0e6:	4620      	mov	r0, r4
    a0e8:	f01e f8e6 	bl	282b8 <bt_conn_ref>
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
    a0ec:	f44f 4200 	mov.w	r2, #32768	; 0x8000
		gatt_ccc_store.conn_list[bt_conn_index(conn)] =
    a0f0:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
    a0f4:	2300      	movs	r3, #0
    a0f6:	f105 0008 	add.w	r0, r5, #8
}
    a0fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_reschedule(&gatt_ccc_store.work, CCC_STORE_DELAY);
    a0fe:	f01a b931 	b.w	24364 <k_work_reschedule>
}
    a102:	bd70      	pop	{r4, r5, r6, pc}
    a104:	20001900 	.word	0x20001900

0000a108 <bt_gatt_attr_write_ccc>:
{
    a108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a10c:	b088      	sub	sp, #32
    a10e:	4698      	mov	r8, r3
    a110:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
	struct _bt_gatt_ccc *ccc = attr->user_data;
    a114:	f8d1 a00c 	ldr.w	sl, [r1, #12]
{
    a118:	4607      	mov	r7, r0
    a11a:	4689      	mov	r9, r1
	if (offset) {
    a11c:	2b00      	cmp	r3, #0
    a11e:	d151      	bne.n	a1c4 <bt_gatt_attr_write_ccc+0xbc>
	if (!len || len > sizeof(uint16_t)) {
    a120:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    a124:	2b01      	cmp	r3, #1
    a126:	d850      	bhi.n	a1ca <bt_gatt_attr_write_ccc+0xc2>
		value = *(uint8_t *)buf;
    a128:	7816      	ldrb	r6, [r2, #0]
	if (len < sizeof(uint16_t)) {
    a12a:	f1b8 0f01 	cmp.w	r8, #1
	cfg = find_ccc_cfg(conn, ccc);
    a12e:	4651      	mov	r1, sl
    a130:	bf14      	ite	ne
    a132:	8816      	ldrhne	r6, [r2, #0]
		value = *(uint8_t *)buf;
    a134:	b2b6      	uxtheq	r6, r6
	cfg = find_ccc_cfg(conn, ccc);
    a136:	f01e fe8b 	bl	28e50 <find_ccc_cfg>
	if (!cfg) {
    a13a:	4605      	mov	r5, r0
    a13c:	b9f0      	cbnz	r0, a17c <bt_gatt_attr_write_ccc+0x74>
		if (!value) {
    a13e:	b91e      	cbnz	r6, a148 <bt_gatt_attr_write_ccc+0x40>
			return len;
    a140:	4640      	mov	r0, r8
}
    a142:	b008      	add	sp, #32
    a144:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cfg = find_ccc_cfg(NULL, ccc);
    a148:	4651      	mov	r1, sl
    a14a:	f01e fe81 	bl	28e50 <find_ccc_cfg>
		if (!cfg) {
    a14e:	4605      	mov	r5, r0
    a150:	b968      	cbnz	r0, a16e <bt_gatt_attr_write_ccc+0x66>
			BT_WARN("No space to store CCC cfg");
    a152:	4b1f      	ldr	r3, [pc, #124]	; (a1d0 <bt_gatt_attr_write_ccc+0xc8>)
    a154:	481f      	ldr	r0, [pc, #124]	; (a1d4 <bt_gatt_attr_write_ccc+0xcc>)
    a156:	9306      	str	r3, [sp, #24]
    a158:	aa05      	add	r2, sp, #20
    a15a:	2302      	movs	r3, #2
    a15c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    a160:	9301      	str	r3, [sp, #4]
    a162:	9305      	str	r3, [sp, #20]
    a164:	f01e fedf 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    a168:	f06f 0010 	mvn.w	r0, #16
    a16c:	e7e9      	b.n	a142 <bt_gatt_attr_write_ccc+0x3a>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    a16e:	f107 0188 	add.w	r1, r7, #136	; 0x88
    a172:	3001      	adds	r0, #1
    a174:	f01e fe92 	bl	28e9c <bt_addr_le_copy>
		cfg->id = conn->id;
    a178:	7a3b      	ldrb	r3, [r7, #8]
    a17a:	702b      	strb	r3, [r5, #0]
	if (ccc->cfg_write) {
    a17c:	f8da 3010 	ldr.w	r3, [sl, #16]
    a180:	b9a3      	cbnz	r3, a1ac <bt_gatt_attr_write_ccc+0xa4>
	if (cfg->value != ccc->value) {
    a182:	f8ba 300a 	ldrh.w	r3, [sl, #10]
	value_changed = cfg->value != value;
    a186:	892c      	ldrh	r4, [r5, #8]
	cfg->value = value;
    a188:	812e      	strh	r6, [r5, #8]
	if (cfg->value != ccc->value) {
    a18a:	42b3      	cmp	r3, r6
    a18c:	d003      	beq.n	a196 <bt_gatt_attr_write_ccc+0x8e>
		gatt_ccc_changed(attr, ccc);
    a18e:	4651      	mov	r1, sl
    a190:	4648      	mov	r0, r9
    a192:	f01e fdcd 	bl	28d30 <gatt_ccc_changed>
	if (value_changed) {
    a196:	42b4      	cmp	r4, r6
    a198:	d002      	beq.n	a1a0 <bt_gatt_attr_write_ccc+0x98>
		gatt_ccc_conn_enqueue(conn);
    a19a:	4638      	mov	r0, r7
    a19c:	f7ff ff90 	bl	a0c0 <gatt_ccc_conn_enqueue>
	if (!value) {
    a1a0:	2e00      	cmp	r6, #0
    a1a2:	d1cd      	bne.n	a140 <bt_gatt_attr_write_ccc+0x38>
		clear_ccc_cfg(cfg);
    a1a4:	4628      	mov	r0, r5
    a1a6:	f01e fe7c 	bl	28ea2 <clear_ccc_cfg>
    a1aa:	e7c9      	b.n	a140 <bt_gatt_attr_write_ccc+0x38>
		ssize_t write = ccc->cfg_write(conn, attr, value);
    a1ac:	4632      	mov	r2, r6
    a1ae:	4649      	mov	r1, r9
    a1b0:	4638      	mov	r0, r7
    a1b2:	4798      	blx	r3
		if (write < 0) {
    a1b4:	2800      	cmp	r0, #0
    a1b6:	dbc4      	blt.n	a142 <bt_gatt_attr_write_ccc+0x3a>
		if (write != sizeof(value) && write != 1) {
    a1b8:	1e44      	subs	r4, r0, #1
    a1ba:	2c01      	cmp	r4, #1
    a1bc:	d9e1      	bls.n	a182 <bt_gatt_attr_write_ccc+0x7a>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
    a1be:	f06f 000d 	mvn.w	r0, #13
    a1c2:	e7be      	b.n	a142 <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    a1c4:	f06f 0006 	mvn.w	r0, #6
    a1c8:	e7bb      	b.n	a142 <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    a1ca:	f06f 000c 	mvn.w	r0, #12
    a1ce:	e7b8      	b.n	a142 <bt_gatt_attr_write_ccc+0x3a>
    a1d0:	00030452 	.word	0x00030452
    a1d4:	0002daa4 	.word	0x0002daa4

0000a1d8 <sc_store>:
{
    a1d8:	b570      	push	{r4, r5, r6, lr}
	if (cfg->id) {
    a1da:	4605      	mov	r5, r0
{
    a1dc:	b094      	sub	sp, #80	; 0x50
	if (cfg->id) {
    a1de:	f815 2b01 	ldrb.w	r2, [r5], #1
{
    a1e2:	4604      	mov	r4, r0
	if (cfg->id) {
    a1e4:	b302      	cbz	r2, a228 <sc_store+0x50>
		u8_to_dec(id_str, sizeof(id_str), cfg->id);
    a1e6:	ae04      	add	r6, sp, #16
    a1e8:	2104      	movs	r1, #4
    a1ea:	4630      	mov	r0, r6
    a1ec:	f01a ff33 	bl	25056 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "sc",
    a1f0:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "sc",
    a1f2:	4a0e      	ldr	r2, [pc, #56]	; (a22c <sc_store+0x54>)
    a1f4:	2124      	movs	r1, #36	; 0x24
    a1f6:	a80b      	add	r0, sp, #44	; 0x2c
    a1f8:	462b      	mov	r3, r5
    a1fa:	f7fb fa77 	bl	56ec <bt_settings_encode_key>
	err = settings_save_one(key, (char *)&cfg->data, sizeof(cfg->data));
    a1fe:	2204      	movs	r2, #4
    a200:	f104 0108 	add.w	r1, r4, #8
    a204:	a80b      	add	r0, sp, #44	; 0x2c
    a206:	f7f9 fcfb 	bl	3c00 <settings_save_one>
	if (err) {
    a20a:	b158      	cbz	r0, a224 <sc_store+0x4c>
		BT_ERR("failed to store SC (err %d)", err);
    a20c:	4b08      	ldr	r3, [pc, #32]	; (a230 <sc_store+0x58>)
    a20e:	aa07      	add	r2, sp, #28
    a210:	e9cd 3008 	strd	r3, r0, [sp, #32]
    a214:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a218:	2303      	movs	r3, #3
    a21a:	4806      	ldr	r0, [pc, #24]	; (a234 <sc_store+0x5c>)
    a21c:	9303      	str	r3, [sp, #12]
    a21e:	9307      	str	r3, [sp, #28]
    a220:	f01e fe81 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a224:	b014      	add	sp, #80	; 0x50
    a226:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "sc",
    a228:	9200      	str	r2, [sp, #0]
    a22a:	e7e2      	b.n	a1f2 <sc_store+0x1a>
    a22c:	0003071d 	.word	0x0003071d
    a230:	0003046c 	.word	0x0003046c
    a234:	0002daa4 	.word	0x0002daa4

0000a238 <sc_save>:
{
    a238:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a23c:	b08a      	sub	sp, #40	; 0x28
    a23e:	4680      	mov	r8, r0
    a240:	460f      	mov	r7, r1
    a242:	4616      	mov	r6, r2
    a244:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
    a246:	f7ff ff03 	bl	a050 <find_sc_cfg>
	if (!cfg) {
    a24a:	4604      	mov	r4, r0
    a24c:	b9d0      	cbnz	r0, a284 <sc_save+0x4c>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    a24e:	a902      	add	r1, sp, #8
    a250:	9002      	str	r0, [sp, #8]
    a252:	f8cd 000b 	str.w	r0, [sp, #11]
    a256:	f7ff fefb 	bl	a050 <find_sc_cfg>
		if (!cfg) {
    a25a:	4604      	mov	r4, r0
    a25c:	b968      	cbnz	r0, a27a <sc_save+0x42>
			BT_ERR("unable to save SC: no cfg left");
    a25e:	4b17      	ldr	r3, [pc, #92]	; (a2bc <sc_save+0x84>)
    a260:	9308      	str	r3, [sp, #32]
    a262:	4817      	ldr	r0, [pc, #92]	; (a2c0 <sc_save+0x88>)
    a264:	2302      	movs	r3, #2
    a266:	aa07      	add	r2, sp, #28
    a268:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    a26c:	9301      	str	r3, [sp, #4]
    a26e:	9307      	str	r3, [sp, #28]
    a270:	f01e fe59 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a274:	b00a      	add	sp, #40	; 0x28
    a276:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg->id = id;
    a27a:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
    a27e:	4639      	mov	r1, r7
    a280:	f01e fe0c 	bl	28e9c <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
    a284:	8922      	ldrh	r2, [r4, #8]
    a286:	8963      	ldrh	r3, [r4, #10]
    a288:	b97a      	cbnz	r2, a2aa <sc_save+0x72>
    a28a:	b983      	cbnz	r3, a2ae <sc_save+0x76>
		cfg->data.start = start;
    a28c:	8126      	strh	r6, [r4, #8]
		*end = new_end;
    a28e:	8165      	strh	r5, [r4, #10]
	    modified && bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    a290:	4621      	mov	r1, r4
    a292:	f811 0b01 	ldrb.w	r0, [r1], #1
    a296:	f01d fe3b 	bl	27f10 <bt_addr_le_is_bonded>
    a29a:	2800      	cmp	r0, #0
    a29c:	d0ea      	beq.n	a274 <sc_save+0x3c>
		sc_store(cfg);
    a29e:	4620      	mov	r0, r4
}
    a2a0:	b00a      	add	sp, #40	; 0x28
    a2a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sc_store(cfg);
    a2a6:	f7ff bf97 	b.w	a1d8 <sc_store>
	if (new_start >= *start && new_end <= *end) {
    a2aa:	4296      	cmp	r6, r2
    a2ac:	d302      	bcc.n	a2b4 <sc_save+0x7c>
    a2ae:	429d      	cmp	r5, r3
    a2b0:	d8ed      	bhi.n	a28e <sc_save+0x56>
    a2b2:	e7df      	b.n	a274 <sc_save+0x3c>
	if (*end < new_end) {
    a2b4:	429d      	cmp	r5, r3
		*start = new_start;
    a2b6:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
    a2b8:	d9ea      	bls.n	a290 <sc_save+0x58>
    a2ba:	e7e8      	b.n	a28e <sc_save+0x56>
    a2bc:	00030488 	.word	0x00030488
    a2c0:	0002daa4 	.word	0x0002daa4

0000a2c4 <cf_write>:
{
    a2c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a2c8:	b088      	sub	sp, #32
    a2ca:	4698      	mov	r8, r3
    a2cc:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
	if (offset > sizeof(cfg->data)) {
    a2d0:	2b01      	cmp	r3, #1
{
    a2d2:	4606      	mov	r6, r0
    a2d4:	4617      	mov	r7, r2
	if (offset > sizeof(cfg->data)) {
    a2d6:	d83f      	bhi.n	a358 <cf_write+0x94>
	if (offset + len > sizeof(cfg->data)) {
    a2d8:	4443      	add	r3, r8
    a2da:	2b01      	cmp	r3, #1
    a2dc:	4645      	mov	r5, r8
    a2de:	dc3e      	bgt.n	a35e <cf_write+0x9a>
	cfg = find_cf_cfg(conn);
    a2e0:	f7ff fe98 	bl	a014 <find_cf_cfg>
	if (!cfg) {
    a2e4:	4604      	mov	r4, r0
    a2e6:	b918      	cbnz	r0, a2f0 <cf_write+0x2c>
		cfg = find_cf_cfg(NULL);
    a2e8:	f7ff fe94 	bl	a014 <find_cf_cfg>
	if (!cfg) {
    a2ec:	4604      	mov	r4, r0
    a2ee:	b180      	cbz	r0, a312 <cf_write+0x4e>
{
    a2f0:	2100      	movs	r1, #0
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
    a2f2:	f1b8 0f00 	cmp.w	r8, #0
    a2f6:	d11d      	bne.n	a334 <cf_write+0x70>
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    a2f8:	f106 0188 	add.w	r1, r6, #136	; 0x88
    a2fc:	1c60      	adds	r0, r4, #1
    a2fe:	f01e fdcd 	bl	28e9c <bt_addr_le_copy>
	cfg->id = conn->id;
    a302:	4620      	mov	r0, r4
    a304:	7a33      	ldrb	r3, [r6, #8]
    a306:	f800 3b0c 	strb.w	r3, [r0], #12
    a30a:	2101      	movs	r1, #1
    a30c:	f01e fd8e 	bl	28e2c <atomic_or>
}
    a310:	e00c      	b.n	a32c <cf_write+0x68>
		BT_WARN("No space to store Client Supported Features");
    a312:	4b16      	ldr	r3, [pc, #88]	; (a36c <cf_write+0xa8>)
    a314:	9306      	str	r3, [sp, #24]
    a316:	4816      	ldr	r0, [pc, #88]	; (a370 <cf_write+0xac>)
    a318:	2302      	movs	r3, #2
    a31a:	aa05      	add	r2, sp, #20
    a31c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    a320:	f06f 0510 	mvn.w	r5, #16
		BT_WARN("No space to store Client Supported Features");
    a324:	9301      	str	r3, [sp, #4]
    a326:	9305      	str	r3, [sp, #20]
    a328:	f01e fdfd 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a32c:	4628      	mov	r0, r5
    a32e:	b008      	add	sp, #32
    a330:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
    a334:	7a20      	ldrb	r0, [r4, #8]
    a336:	fa20 f301 	lsr.w	r3, r0, r1
    a33a:	07da      	lsls	r2, r3, #31
    a33c:	d503      	bpl.n	a346 <cf_write+0x82>
		    !(value[i / 8] & BIT(i % 8))) {
    a33e:	783b      	ldrb	r3, [r7, #0]
    a340:	40cb      	lsrs	r3, r1
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
    a342:	07db      	lsls	r3, r3, #31
    a344:	d50e      	bpl.n	a364 <cf_write+0xa0>
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
    a346:	3101      	adds	r1, #1
    a348:	2903      	cmp	r1, #3
    a34a:	d1d2      	bne.n	a2f2 <cf_write+0x2e>
			cfg->data[i] |= value[i] & BIT_MASK(CF_NUM_BITS % 8);
    a34c:	783b      	ldrb	r3, [r7, #0]
    a34e:	f003 0307 	and.w	r3, r3, #7
    a352:	4318      	orrs	r0, r3
    a354:	7220      	strb	r0, [r4, #8]
	for (i = 0U; i < len && i < CF_NUM_BYTES; i++) {
    a356:	e7cf      	b.n	a2f8 <cf_write+0x34>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    a358:	f06f 0506 	mvn.w	r5, #6
    a35c:	e7e6      	b.n	a32c <cf_write+0x68>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    a35e:	f06f 050c 	mvn.w	r5, #12
    a362:	e7e3      	b.n	a32c <cf_write+0x68>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
    a364:	f06f 0512 	mvn.w	r5, #18
    a368:	e7e0      	b.n	a32c <cf_write+0x68>
    a36a:	bf00      	nop
    a36c:	000304a7 	.word	0x000304a7
    a370:	0002daa4 	.word	0x0002daa4

0000a374 <db_hash_store>:
{
    a374:	b500      	push	{lr}
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
    a376:	490b      	ldr	r1, [pc, #44]	; (a3a4 <db_hash_store+0x30>)
    a378:	480b      	ldr	r0, [pc, #44]	; (a3a8 <db_hash_store+0x34>)
{
    a37a:	b089      	sub	sp, #36	; 0x24
	err = settings_save_one("bt/hash", &db_hash.hash, sizeof(db_hash.hash));
    a37c:	2210      	movs	r2, #16
    a37e:	f7f9 fc3f 	bl	3c00 <settings_save_one>
	if (err) {
    a382:	b158      	cbz	r0, a39c <db_hash_store+0x28>
		BT_ERR("Failed to save Database Hash (err %d)", err);
    a384:	4b09      	ldr	r3, [pc, #36]	; (a3ac <db_hash_store+0x38>)
    a386:	aa05      	add	r2, sp, #20
    a388:	e9cd 3006 	strd	r3, r0, [sp, #24]
    a38c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a390:	2303      	movs	r3, #3
    a392:	4807      	ldr	r0, [pc, #28]	; (a3b0 <db_hash_store+0x3c>)
    a394:	9301      	str	r3, [sp, #4]
    a396:	9305      	str	r3, [sp, #20]
    a398:	f01e fdc5 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a39c:	b009      	add	sp, #36	; 0x24
    a39e:	f85d fb04 	ldr.w	pc, [sp], #4
    a3a2:	bf00      	nop
    a3a4:	20001888 	.word	0x20001888
    a3a8:	000304d3 	.word	0x000304d3
    a3ac:	000304db 	.word	0x000304db
    a3b0:	0002daa4 	.word	0x0002daa4

0000a3b4 <db_hash_set>:
{
    a3b4:	b510      	push	{r4, lr}
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
    a3b6:	490c      	ldr	r1, [pc, #48]	; (a3e8 <db_hash_set+0x34>)
{
    a3b8:	4614      	mov	r4, r2
    a3ba:	b088      	sub	sp, #32
	len = read_cb(cb_arg, db_hash.stored_hash, sizeof(db_hash.stored_hash));
    a3bc:	2210      	movs	r2, #16
    a3be:	4618      	mov	r0, r3
    a3c0:	47a0      	blx	r4
	if (len < 0) {
    a3c2:	1e04      	subs	r4, r0, #0
    a3c4:	da0e      	bge.n	a3e4 <db_hash_set+0x30>
		BT_ERR("Failed to decode value (err %zd)", len);
    a3c6:	4b09      	ldr	r3, [pc, #36]	; (a3ec <db_hash_set+0x38>)
    a3c8:	4809      	ldr	r0, [pc, #36]	; (a3f0 <db_hash_set+0x3c>)
    a3ca:	e9cd 3406 	strd	r3, r4, [sp, #24]
    a3ce:	aa05      	add	r2, sp, #20
    a3d0:	2303      	movs	r3, #3
    a3d2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a3d6:	9301      	str	r3, [sp, #4]
    a3d8:	9305      	str	r3, [sp, #20]
    a3da:	f01e fda4 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a3de:	4620      	mov	r0, r4
    a3e0:	b008      	add	sp, #32
    a3e2:	bd10      	pop	{r4, pc}
	return 0;
    a3e4:	2400      	movs	r4, #0
    a3e6:	e7fa      	b.n	a3de <db_hash_set+0x2a>
    a3e8:	20001898 	.word	0x20001898
    a3ec:	00030501 	.word	0x00030501
    a3f0:	0002daa4 	.word	0x0002daa4

0000a3f4 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    a3f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    a3f6:	ab0a      	add	r3, sp, #40	; 0x28
    a3f8:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    a3fa:	9302      	str	r3, [sp, #8]
    a3fc:	4b05      	ldr	r3, [pc, #20]	; (a414 <z_log_msg2_runtime_create.constprop.0+0x20>)
    a3fe:	9301      	str	r3, [sp, #4]
    a400:	2300      	movs	r3, #0
    a402:	9300      	str	r3, [sp, #0]
    a404:	2201      	movs	r2, #1
    a406:	4618      	mov	r0, r3
    a408:	f7f8 ff4e 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    a40c:	b007      	add	sp, #28
    a40e:	f85d fb04 	ldr.w	pc, [sp], #4
    a412:	bf00      	nop
    a414:	00030522 	.word	0x00030522

0000a418 <sc_set>:
{
    a418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a41c:	460e      	mov	r6, r1
    a41e:	b090      	sub	sp, #64	; 0x40
    a420:	4617      	mov	r7, r2
    a422:	4698      	mov	r8, r3
	if (!name) {
    a424:	4605      	mov	r5, r0
    a426:	b958      	cbnz	r0, a440 <sc_set+0x28>
		BT_ERR("Insufficient number of arguments");
    a428:	4b3b      	ldr	r3, [pc, #236]	; (a518 <sc_set+0x100>)
    a42a:	930e      	str	r3, [sp, #56]	; 0x38
    a42c:	2302      	movs	r3, #2
    a42e:	9308      	str	r3, [sp, #32]
    a430:	930d      	str	r3, [sp, #52]	; 0x34
    a432:	aa0d      	add	r2, sp, #52	; 0x34
    a434:	f44f 5182 	mov.w	r1, #4160	; 0x1040
			BT_ERR("Invalid local identity %lu", next_id);
    a438:	4838      	ldr	r0, [pc, #224]	; (a51c <sc_set+0x104>)
    a43a:	f01e fd74 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -EINVAL;
    a43e:	e00e      	b.n	a45e <sc_set+0x46>
	err = bt_settings_decode_key(name, &addr);
    a440:	a906      	add	r1, sp, #24
    a442:	f01d fa8c 	bl	2795e <bt_settings_decode_key>
	if (err) {
    a446:	4604      	mov	r4, r0
    a448:	b178      	cbz	r0, a46a <sc_set+0x52>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    a44a:	4b35      	ldr	r3, [pc, #212]	; (a520 <sc_set+0x108>)
    a44c:	9301      	str	r3, [sp, #4]
    a44e:	2300      	movs	r3, #0
    a450:	4932      	ldr	r1, [pc, #200]	; (a51c <sc_set+0x104>)
    a452:	9502      	str	r5, [sp, #8]
    a454:	9300      	str	r3, [sp, #0]
    a456:	2201      	movs	r2, #1
    a458:	4618      	mov	r0, r3
    a45a:	f7ff ffcb 	bl	a3f4 <z_log_msg2_runtime_create.constprop.0>
		return -EINVAL;
    a45e:	f06f 0415 	mvn.w	r4, #21
}
    a462:	4620      	mov	r0, r4
    a464:	b010      	add	sp, #64	; 0x40
    a466:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	settings_name_next(name, &next);
    a46a:	a904      	add	r1, sp, #16
    a46c:	4628      	mov	r0, r5
    a46e:	f01b fee9 	bl	26244 <settings_name_next>
	if (!next) {
    a472:	9804      	ldr	r0, [sp, #16]
    a474:	b170      	cbz	r0, a494 <sc_set+0x7c>
		unsigned long next_id = strtoul(next, NULL, 10);
    a476:	220a      	movs	r2, #10
    a478:	4621      	mov	r1, r4
    a47a:	f01d f938 	bl	276ee <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
    a47e:	b148      	cbz	r0, a494 <sc_set+0x7c>
			BT_ERR("Invalid local identity %lu", next_id);
    a480:	4b28      	ldr	r3, [pc, #160]	; (a524 <sc_set+0x10c>)
    a482:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
    a486:	2303      	movs	r3, #3
    a488:	9308      	str	r3, [sp, #32]
    a48a:	930d      	str	r3, [sp, #52]	; 0x34
    a48c:	aa0d      	add	r2, sp, #52	; 0x34
    a48e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a492:	e7d1      	b.n	a438 <sc_set+0x20>
	cfg = find_sc_cfg(id, &addr);
    a494:	a906      	add	r1, sp, #24
    a496:	2000      	movs	r0, #0
    a498:	f7ff fdda 	bl	a050 <find_sc_cfg>
	if (!cfg && len_rd) {
    a49c:	4605      	mov	r5, r0
    a49e:	2800      	cmp	r0, #0
    a4a0:	d132      	bne.n	a508 <sc_set+0xf0>
    a4a2:	2e00      	cmp	r6, #0
    a4a4:	d0dd      	beq.n	a462 <sc_set+0x4a>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    a4a6:	a908      	add	r1, sp, #32
    a4a8:	9008      	str	r0, [sp, #32]
    a4aa:	4606      	mov	r6, r0
    a4ac:	f8cd 0023 	str.w	r0, [sp, #35]	; 0x23
    a4b0:	f7ff fdce 	bl	a050 <find_sc_cfg>
		if (!cfg) {
    a4b4:	4605      	mov	r5, r0
    a4b6:	b968      	cbnz	r0, a4d4 <sc_set+0xbc>
			BT_ERR("Unable to restore SC: no cfg left");
    a4b8:	4b1b      	ldr	r3, [pc, #108]	; (a528 <sc_set+0x110>)
    a4ba:	930e      	str	r3, [sp, #56]	; 0x38
    a4bc:	4817      	ldr	r0, [pc, #92]	; (a51c <sc_set+0x104>)
    a4be:	2302      	movs	r3, #2
    a4c0:	aa0d      	add	r2, sp, #52	; 0x34
    a4c2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    a4c6:	9305      	str	r3, [sp, #20]
    a4c8:	930d      	str	r3, [sp, #52]	; 0x34
			return -ENOMEM;
    a4ca:	f06f 040b 	mvn.w	r4, #11
			BT_ERR("Unable to restore SC: no cfg left");
    a4ce:	f01e fd2a 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -ENOMEM;
    a4d2:	e7c6      	b.n	a462 <sc_set+0x4a>
		cfg->id = id;
    a4d4:	f800 6b01 	strb.w	r6, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
    a4d8:	a906      	add	r1, sp, #24
    a4da:	f01e fcdf 	bl	28e9c <bt_addr_le_copy>
		len = read_cb(cb_arg, &cfg->data, sizeof(cfg->data));
    a4de:	f105 0108 	add.w	r1, r5, #8
    a4e2:	2204      	movs	r2, #4
    a4e4:	4640      	mov	r0, r8
    a4e6:	47b8      	blx	r7
		if (len < 0) {
    a4e8:	1e05      	subs	r5, r0, #0
    a4ea:	daba      	bge.n	a462 <sc_set+0x4a>
			BT_ERR("Failed to decode value (err %zd)", len);
    a4ec:	4b0f      	ldr	r3, [pc, #60]	; (a52c <sc_set+0x114>)
    a4ee:	480b      	ldr	r0, [pc, #44]	; (a51c <sc_set+0x104>)
    a4f0:	e9cd 350e 	strd	r3, r5, [sp, #56]	; 0x38
    a4f4:	aa0d      	add	r2, sp, #52	; 0x34
    a4f6:	2303      	movs	r3, #3
    a4f8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a4fc:	9308      	str	r3, [sp, #32]
    a4fe:	930d      	str	r3, [sp, #52]	; 0x34
			return len;
    a500:	462c      	mov	r4, r5
			BT_ERR("Failed to decode value (err %zd)", len);
    a502:	f01e fd10 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return len;
    a506:	e7ac      	b.n	a462 <sc_set+0x4a>
	if (len_rd) {
    a508:	2e00      	cmp	r6, #0
    a50a:	d1e8      	bne.n	a4de <sc_set+0xc6>
		memset(cfg, 0, sizeof(*cfg));
    a50c:	220c      	movs	r2, #12
    a50e:	4631      	mov	r1, r6
    a510:	f01d f9b9 	bl	27886 <memset>
		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
    a514:	e7a5      	b.n	a462 <sc_set+0x4a>
    a516:	bf00      	nop
    a518:	0002f4d6 	.word	0x0002f4d6
    a51c:	0002daa4 	.word	0x0002daa4
    a520:	00030522 	.word	0x00030522
    a524:	0003053e 	.word	0x0003053e
    a528:	00030559 	.word	0x00030559
    a52c:	00030501 	.word	0x00030501

0000a530 <cf_set>:
{
    a530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a534:	460e      	mov	r6, r1
    a536:	b08e      	sub	sp, #56	; 0x38
    a538:	4617      	mov	r7, r2
    a53a:	4698      	mov	r8, r3
	if (!name) {
    a53c:	4604      	mov	r4, r0
    a53e:	b958      	cbnz	r0, a558 <cf_set+0x28>
		BT_ERR("Insufficient number of arguments");
    a540:	4b3a      	ldr	r3, [pc, #232]	; (a62c <cf_set+0xfc>)
    a542:	930c      	str	r3, [sp, #48]	; 0x30
    a544:	2302      	movs	r3, #2
    a546:	9306      	str	r3, [sp, #24]
    a548:	930b      	str	r3, [sp, #44]	; 0x2c
    a54a:	aa0b      	add	r2, sp, #44	; 0x2c
    a54c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
			BT_ERR("Invalid local identity %lu", next_id);
    a550:	4837      	ldr	r0, [pc, #220]	; (a630 <cf_set+0x100>)
    a552:	f01e fce8 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -EINVAL;
    a556:	e00e      	b.n	a576 <cf_set+0x46>
	err = bt_settings_decode_key(name, &addr);
    a558:	a906      	add	r1, sp, #24
    a55a:	f01d fa00 	bl	2795e <bt_settings_decode_key>
	if (err) {
    a55e:	4605      	mov	r5, r0
    a560:	b178      	cbz	r0, a582 <cf_set+0x52>
		BT_ERR("Unable to decode address %s", log_strdup(name));
    a562:	4b34      	ldr	r3, [pc, #208]	; (a634 <cf_set+0x104>)
    a564:	9301      	str	r3, [sp, #4]
    a566:	2300      	movs	r3, #0
    a568:	4931      	ldr	r1, [pc, #196]	; (a630 <cf_set+0x100>)
    a56a:	9402      	str	r4, [sp, #8]
    a56c:	9300      	str	r3, [sp, #0]
    a56e:	2201      	movs	r2, #1
    a570:	4618      	mov	r0, r3
    a572:	f7ff ff3f 	bl	a3f4 <z_log_msg2_runtime_create.constprop.0>
		return -EINVAL;
    a576:	f06f 0515 	mvn.w	r5, #21
}
    a57a:	4628      	mov	r0, r5
    a57c:	b00e      	add	sp, #56	; 0x38
    a57e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	settings_name_next(name, &next);
    a582:	a904      	add	r1, sp, #16
    a584:	4620      	mov	r0, r4
    a586:	f01b fe5d 	bl	26244 <settings_name_next>
	if (!next) {
    a58a:	9804      	ldr	r0, [sp, #16]
    a58c:	b350      	cbz	r0, a5e4 <cf_set+0xb4>
		unsigned long next_id = strtoul(next, NULL, 10);
    a58e:	220a      	movs	r2, #10
    a590:	4629      	mov	r1, r5
    a592:	f01d f8ac 	bl	276ee <strtoul>
		if (next_id >= CONFIG_BT_ID_MAX) {
    a596:	b328      	cbz	r0, a5e4 <cf_set+0xb4>
			BT_ERR("Invalid local identity %lu", next_id);
    a598:	4b27      	ldr	r3, [pc, #156]	; (a638 <cf_set+0x108>)
    a59a:	e9cd 300c 	strd	r3, r0, [sp, #48]	; 0x30
    a59e:	2303      	movs	r3, #3
    a5a0:	9305      	str	r3, [sp, #20]
    a5a2:	930b      	str	r3, [sp, #44]	; 0x2c
    a5a4:	aa0b      	add	r2, sp, #44	; 0x2c
    a5a6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a5aa:	e7d1      	b.n	a550 <cf_set+0x20>
			    !bt_addr_le_cmp(addr, &cf_cfg[i].peer)) {
    a5ac:	1c61      	adds	r1, r4, #1
    a5ae:	a806      	add	r0, sp, #24
    a5b0:	f01e fc4b 	bl	28e4a <bt_addr_le_cmp>
			if (id == cf_cfg[i].id &&
    a5b4:	b9d0      	cbnz	r0, a5ec <cf_set+0xbc>
	if (len_rd) {
    a5b6:	2e00      	cmp	r6, #0
    a5b8:	d033      	beq.n	a622 <cf_set+0xf2>
		len = read_cb(cb_arg, cfg->data, sizeof(cfg->data));
    a5ba:	f104 0108 	add.w	r1, r4, #8
    a5be:	2201      	movs	r2, #1
    a5c0:	4640      	mov	r0, r8
    a5c2:	47b8      	blx	r7
		if (len < 0) {
    a5c4:	1e04      	subs	r4, r0, #0
    a5c6:	dad8      	bge.n	a57a <cf_set+0x4a>
			BT_ERR("Failed to decode value (err %zd)", len);
    a5c8:	4b1c      	ldr	r3, [pc, #112]	; (a63c <cf_set+0x10c>)
    a5ca:	4819      	ldr	r0, [pc, #100]	; (a630 <cf_set+0x100>)
    a5cc:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
    a5d0:	aa0b      	add	r2, sp, #44	; 0x2c
    a5d2:	2303      	movs	r3, #3
    a5d4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a5d8:	9305      	str	r3, [sp, #20]
    a5da:	930b      	str	r3, [sp, #44]	; 0x2c
			return len;
    a5dc:	4625      	mov	r5, r4
			BT_ERR("Failed to decode value (err %zd)", len);
    a5de:	f01e fca2 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return len;
    a5e2:	e7ca      	b.n	a57a <cf_set+0x4a>
			if (id == cf_cfg[i].id &&
    a5e4:	4c16      	ldr	r4, [pc, #88]	; (a640 <cf_set+0x110>)
    a5e6:	7823      	ldrb	r3, [r4, #0]
    a5e8:	2b00      	cmp	r3, #0
    a5ea:	d0df      	beq.n	a5ac <cf_set+0x7c>
		cfg = find_cf_cfg(NULL);
    a5ec:	2000      	movs	r0, #0
    a5ee:	f7ff fd11 	bl	a014 <find_cf_cfg>
		if (!cfg) {
    a5f2:	4604      	mov	r4, r0
    a5f4:	b968      	cbnz	r0, a612 <cf_set+0xe2>
			BT_ERR("Unable to restore CF: no cfg left");
    a5f6:	4b13      	ldr	r3, [pc, #76]	; (a644 <cf_set+0x114>)
    a5f8:	930c      	str	r3, [sp, #48]	; 0x30
    a5fa:	480d      	ldr	r0, [pc, #52]	; (a630 <cf_set+0x100>)
    a5fc:	2302      	movs	r3, #2
    a5fe:	aa0b      	add	r2, sp, #44	; 0x2c
    a600:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    a604:	9305      	str	r3, [sp, #20]
    a606:	930b      	str	r3, [sp, #44]	; 0x2c
			return -ENOMEM;
    a608:	f06f 050b 	mvn.w	r5, #11
			BT_ERR("Unable to restore CF: no cfg left");
    a60c:	f01e fc8b 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -ENOMEM;
    a610:	e7b3      	b.n	a57a <cf_set+0x4a>
		cfg->id = id;
    a612:	4620      	mov	r0, r4
    a614:	2300      	movs	r3, #0
    a616:	f800 3b01 	strb.w	r3, [r0], #1
		bt_addr_le_copy(&cfg->peer, &addr);
    a61a:	a906      	add	r1, sp, #24
    a61c:	f01e fc3e 	bl	28e9c <bt_addr_le_copy>
    a620:	e7c9      	b.n	a5b6 <cf_set+0x86>
		clear_cf_cfg(cfg);
    a622:	4620      	mov	r0, r4
    a624:	f01e fc82 	bl	28f2c <clear_cf_cfg>
    a628:	e7a7      	b.n	a57a <cf_set+0x4a>
    a62a:	bf00      	nop
    a62c:	0002f4d6 	.word	0x0002f4d6
    a630:	0002daa4 	.word	0x0002daa4
    a634:	00030522 	.word	0x00030522
    a638:	0003053e 	.word	0x0003053e
    a63c:	00030501 	.word	0x00030501
    a640:	20002688 	.word	0x20002688
    a644:	0003057b 	.word	0x0003057b

0000a648 <remove_peer_from_attr>:
#endif /*CONFIG_BT_GATT_CACHING */
#endif /* CONFIG_BT_SETTINGS */

static uint8_t remove_peer_from_attr(const struct bt_gatt_attr *attr,
				     uint16_t handle, void *user_data)
{
    a648:	b508      	push	{r3, lr}
	const struct addr_with_id *addr_with_id = user_data;
	struct _bt_gatt_ccc *ccc;
	struct bt_gatt_ccc_cfg *cfg;

	/* Check if attribute is a CCC */
	if (attr->write != bt_gatt_attr_write_ccc) {
    a64a:	6881      	ldr	r1, [r0, #8]
{
    a64c:	4613      	mov	r3, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    a64e:	4a07      	ldr	r2, [pc, #28]	; (a66c <remove_peer_from_attr+0x24>)
    a650:	4291      	cmp	r1, r2
    a652:	d109      	bne.n	a668 <remove_peer_from_attr+0x20>
	}

	ccc = attr->user_data;

	/* Check if there is a cfg for the peer */
	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
    a654:	791a      	ldrb	r2, [r3, #4]
    a656:	6819      	ldr	r1, [r3, #0]
    a658:	68c0      	ldr	r0, [r0, #12]
    a65a:	f01e fc11 	bl	28e80 <ccc_find_cfg>
	if (cfg) {
    a65e:	b118      	cbz	r0, a668 <remove_peer_from_attr+0x20>
		memset(cfg, 0, sizeof(*cfg));
    a660:	220a      	movs	r2, #10
    a662:	2100      	movs	r1, #0
    a664:	f01d f90f 	bl	27886 <memset>
	}

	return BT_GATT_ITER_CONTINUE;
}
    a668:	2001      	movs	r0, #1
    a66a:	bd08      	pop	{r3, pc}
    a66c:	0000a109 	.word	0x0000a109

0000a670 <ccc_load>:
{
    a670:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    a672:	4b21      	ldr	r3, [pc, #132]	; (a6f8 <ccc_load+0x88>)
{
    a674:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    a676:	6882      	ldr	r2, [r0, #8]
    a678:	429a      	cmp	r2, r3
    a67a:	d002      	beq.n	a682 <ccc_load+0x12>
		return BT_GATT_ITER_CONTINUE;
    a67c:	2001      	movs	r0, #1
}
    a67e:	b002      	add	sp, #8
    a680:	bd70      	pop	{r4, r5, r6, pc}
	if (!load->entry) {
    a682:	68a3      	ldr	r3, [r4, #8]
    a684:	68c6      	ldr	r6, [r0, #12]
    a686:	b94b      	cbnz	r3, a69c <ccc_load+0x2c>
	cfg = ccc_find_cfg(ccc, addr, id);
    a688:	7922      	ldrb	r2, [r4, #4]
    a68a:	6821      	ldr	r1, [r4, #0]
    a68c:	4630      	mov	r0, r6
    a68e:	f01e fbf7 	bl	28e80 <ccc_find_cfg>
	if (!cfg) {
    a692:	2800      	cmp	r0, #0
    a694:	d0f2      	beq.n	a67c <ccc_load+0xc>
	clear_ccc_cfg(cfg);
    a696:	f01e fc04 	bl	28ea2 <clear_ccc_cfg>
    a69a:	e7ef      	b.n	a67c <ccc_load+0xc>
	} else if (!load->count) {
    a69c:	68e0      	ldr	r0, [r4, #12]
    a69e:	2800      	cmp	r0, #0
    a6a0:	d0ed      	beq.n	a67e <ccc_load+0xe>
	if (load->entry->handle != handle) {
    a6a2:	881b      	ldrh	r3, [r3, #0]
    a6a4:	4299      	cmp	r1, r3
    a6a6:	d00a      	beq.n	a6be <ccc_load+0x4e>
		if (load->entry->handle < handle) {
    a6a8:	d9e8      	bls.n	a67c <ccc_load+0xc>
	load->count--;
    a6aa:	68e0      	ldr	r0, [r4, #12]
	load->entry++;
    a6ac:	68a3      	ldr	r3, [r4, #8]
	load->count--;
    a6ae:	3801      	subs	r0, #1
	load->entry++;
    a6b0:	3304      	adds	r3, #4
	load->count--;
    a6b2:	60e0      	str	r0, [r4, #12]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    a6b4:	3800      	subs	r0, #0
	load->entry++;
    a6b6:	60a3      	str	r3, [r4, #8]
	return load->count ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    a6b8:	bf18      	it	ne
    a6ba:	2001      	movne	r0, #1
    a6bc:	e7df      	b.n	a67e <ccc_load+0xe>
	cfg = ccc_find_cfg(ccc, load->addr_with_id.addr, load->addr_with_id.id);
    a6be:	7922      	ldrb	r2, [r4, #4]
    a6c0:	6821      	ldr	r1, [r4, #0]
    a6c2:	4630      	mov	r0, r6
    a6c4:	f01e fbdc 	bl	28e80 <ccc_find_cfg>
	if (!cfg) {
    a6c8:	4605      	mov	r5, r0
    a6ca:	b980      	cbnz	r0, a6ee <ccc_load+0x7e>
		cfg = ccc_find_cfg(ccc, BT_ADDR_LE_ANY, 0);
    a6cc:	9000      	str	r0, [sp, #0]
    a6ce:	4602      	mov	r2, r0
    a6d0:	f8cd 0003 	str.w	r0, [sp, #3]
    a6d4:	4669      	mov	r1, sp
    a6d6:	4630      	mov	r0, r6
    a6d8:	f01e fbd2 	bl	28e80 <ccc_find_cfg>
		if (!cfg) {
    a6dc:	4605      	mov	r5, r0
    a6de:	2800      	cmp	r0, #0
    a6e0:	d0e3      	beq.n	a6aa <ccc_load+0x3a>
		bt_addr_le_copy(&cfg->peer, load->addr_with_id.addr);
    a6e2:	6821      	ldr	r1, [r4, #0]
    a6e4:	3001      	adds	r0, #1
    a6e6:	f01e fbd9 	bl	28e9c <bt_addr_le_copy>
		cfg->id = load->addr_with_id.id;
    a6ea:	7923      	ldrb	r3, [r4, #4]
    a6ec:	702b      	strb	r3, [r5, #0]
	cfg->value = load->entry->value;
    a6ee:	68a3      	ldr	r3, [r4, #8]
    a6f0:	885b      	ldrh	r3, [r3, #2]
    a6f2:	812b      	strh	r3, [r5, #8]
    a6f4:	e7d9      	b.n	a6aa <ccc_load+0x3a>
    a6f6:	bf00      	nop
    a6f8:	0000a109 	.word	0x0000a109

0000a6fc <ccc_save>:
{
    a6fc:	b538      	push	{r3, r4, r5, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    a6fe:	4b0c      	ldr	r3, [pc, #48]	; (a730 <ccc_save+0x34>)
{
    a700:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    a702:	6882      	ldr	r2, [r0, #8]
    a704:	429a      	cmp	r2, r3
{
    a706:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
    a708:	d10f      	bne.n	a72a <ccc_save+0x2e>
	cfg = ccc_find_cfg(ccc, save->addr_with_id.addr, save->addr_with_id.id);
    a70a:	7922      	ldrb	r2, [r4, #4]
    a70c:	6821      	ldr	r1, [r4, #0]
    a70e:	68c0      	ldr	r0, [r0, #12]
    a710:	f01e fbb6 	bl	28e80 <ccc_find_cfg>
	if (!cfg) {
    a714:	b148      	cbz	r0, a72a <ccc_save+0x2e>
	save->store[save->count].handle = handle;
    a716:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
	save->store[save->count].value = cfg->value;
    a71a:	8901      	ldrh	r1, [r0, #8]
    a71c:	eb04 0283 	add.w	r2, r4, r3, lsl #2
	save->count++;
    a720:	3301      	adds	r3, #1
	save->store[save->count].handle = handle;
    a722:	8115      	strh	r5, [r2, #8]
	save->store[save->count].value = cfg->value;
    a724:	8151      	strh	r1, [r2, #10]
	save->count++;
    a726:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
}
    a72a:	2001      	movs	r0, #1
    a72c:	bd38      	pop	{r3, r4, r5, pc}
    a72e:	bf00      	nop
    a730:	0000a109 	.word	0x0000a109

0000a734 <db_changed>:
{
    a734:	b513      	push	{r0, r1, r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a736:	f06f 0104 	mvn.w	r1, #4
    a73a:	4813      	ldr	r0, [pc, #76]	; (a788 <db_changed+0x54>)
		if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    a73c:	4c13      	ldr	r4, [pc, #76]	; (a78c <db_changed+0x58>)
    a73e:	f01e fbbe 	bl	28ebe <atomic_and>
	k_work_reschedule(&db_hash.work, DB_HASH_TIMEOUT);
    a742:	2300      	movs	r3, #0
    a744:	4812      	ldr	r0, [pc, #72]	; (a790 <db_changed+0x5c>)
    a746:	f44f 72a4 	mov.w	r2, #328	; 0x148
    a74a:	f019 fe0b 	bl	24364 <k_work_reschedule>
		if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    a74e:	2300      	movs	r3, #0
    a750:	4669      	mov	r1, sp
    a752:	1c60      	adds	r0, r4, #1
    a754:	9300      	str	r3, [sp, #0]
    a756:	f8cd 3003 	str.w	r3, [sp, #3]
    a75a:	f01e fb76 	bl	28e4a <bt_addr_le_cmp>
    a75e:	b188      	cbz	r0, a784 <db_changed+0x50>
		if (CF_ROBUST_CACHING(cfg)) {
    a760:	7a23      	ldrb	r3, [r4, #8]
    a762:	07db      	lsls	r3, r3, #31
    a764:	d50e      	bpl.n	a784 <db_changed+0x50>
    a766:	f06f 0102 	mvn.w	r1, #2
    a76a:	f104 000c 	add.w	r0, r4, #12
    a76e:	f01e fba6 	bl	28ebe <atomic_and>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a772:	f06f 0101 	mvn.w	r1, #1
    a776:	f104 000c 	add.w	r0, r4, #12
}
    a77a:	b002      	add	sp, #8
    a77c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a780:	f01e bb9d 	b.w	28ebe <atomic_and>
    a784:	b002      	add	sp, #8
    a786:	bd10      	pop	{r4, pc}
    a788:	20001988 	.word	0x20001988
    a78c:	20002688 	.word	0x20002688
    a790:	200018a8 	.word	0x200018a8

0000a794 <bt_gatt_clear_sc>:
{
    a794:	b570      	push	{r4, r5, r6, lr}
    a796:	b094      	sub	sp, #80	; 0x50
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
    a798:	f7ff fc5a 	bl	a050 <find_sc_cfg>
	if (!cfg) {
    a79c:	4604      	mov	r4, r0
    a79e:	b320      	cbz	r0, a7ea <bt_gatt_clear_sc+0x56>
		if (cfg->id) {
    a7a0:	4605      	mov	r5, r0
    a7a2:	f815 2b01 	ldrb.w	r2, [r5], #1
    a7a6:	b31a      	cbz	r2, a7f0 <bt_gatt_clear_sc+0x5c>
			u8_to_dec(id_str, sizeof(id_str), cfg->id);
    a7a8:	ae04      	add	r6, sp, #16
    a7aa:	2104      	movs	r1, #4
    a7ac:	4630      	mov	r0, r6
    a7ae:	f01a fc52 	bl	25056 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "sc",
    a7b2:	9600      	str	r6, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "sc",
    a7b4:	a80b      	add	r0, sp, #44	; 0x2c
    a7b6:	4a0f      	ldr	r2, [pc, #60]	; (a7f4 <bt_gatt_clear_sc+0x60>)
    a7b8:	462b      	mov	r3, r5
    a7ba:	2124      	movs	r1, #36	; 0x24
    a7bc:	f7fa ff96 	bl	56ec <bt_settings_encode_key>
		err = settings_delete(key);
    a7c0:	a80b      	add	r0, sp, #44	; 0x2c
    a7c2:	f01b fd18 	bl	261f6 <settings_delete>
		if (err) {
    a7c6:	b158      	cbz	r0, a7e0 <bt_gatt_clear_sc+0x4c>
			BT_ERR("failed to delete SC (err %d)", err);
    a7c8:	4b0b      	ldr	r3, [pc, #44]	; (a7f8 <bt_gatt_clear_sc+0x64>)
    a7ca:	aa07      	add	r2, sp, #28
    a7cc:	e9cd 3008 	strd	r3, r0, [sp, #32]
    a7d0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a7d4:	2303      	movs	r3, #3
    a7d6:	4809      	ldr	r0, [pc, #36]	; (a7fc <bt_gatt_clear_sc+0x68>)
    a7d8:	9303      	str	r3, [sp, #12]
    a7da:	9307      	str	r3, [sp, #28]
    a7dc:	f01e fba3 	bl	28f26 <z_log_msg2_static_create.constprop.0>
	memset(cfg, 0, sizeof(*cfg));
    a7e0:	220c      	movs	r2, #12
    a7e2:	2100      	movs	r1, #0
    a7e4:	4620      	mov	r0, r4
    a7e6:	f01d f84e 	bl	27886 <memset>
}
    a7ea:	2000      	movs	r0, #0
    a7ec:	b014      	add	sp, #80	; 0x50
    a7ee:	bd70      	pop	{r4, r5, r6, pc}
			bt_settings_encode_key(key, sizeof(key), "sc",
    a7f0:	9200      	str	r2, [sp, #0]
    a7f2:	e7df      	b.n	a7b4 <bt_gatt_clear_sc+0x20>
    a7f4:	0003071d 	.word	0x0003071d
    a7f8:	0003059d 	.word	0x0003059d
    a7fc:	0002daa4 	.word	0x0002daa4

0000a800 <sc_clear>:
{
    a800:	b570      	push	{r4, r5, r6, lr}
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a802:	f100 0688 	add.w	r6, r0, #136	; 0x88
{
    a806:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a808:	4631      	mov	r1, r6
    a80a:	7a00      	ldrb	r0, [r0, #8]
{
    a80c:	b088      	sub	sp, #32
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a80e:	f01d fb7f 	bl	27f10 <bt_addr_le_is_bonded>
    a812:	4605      	mov	r5, r0
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
    a814:	4631      	mov	r1, r6
    a816:	7a20      	ldrb	r0, [r4, #8]
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a818:	b185      	cbz	r5, a83c <sc_clear+0x3c>
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
    a81a:	f7ff ffbb 	bl	a794 <bt_gatt_clear_sc>
		if (err) {
    a81e:	b158      	cbz	r0, a838 <sc_clear+0x38>
			BT_ERR("Failed to clear SC %d", err);
    a820:	4b0c      	ldr	r3, [pc, #48]	; (a854 <sc_clear+0x54>)
    a822:	aa05      	add	r2, sp, #20
    a824:	e9cd 3006 	strd	r3, r0, [sp, #24]
    a828:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    a82c:	2303      	movs	r3, #3
    a82e:	480a      	ldr	r0, [pc, #40]	; (a858 <sc_clear+0x58>)
    a830:	9301      	str	r3, [sp, #4]
    a832:	9305      	str	r3, [sp, #20]
    a834:	f01e fb77 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    a838:	b008      	add	sp, #32
    a83a:	bd70      	pop	{r4, r5, r6, pc}
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
    a83c:	f7ff fc08 	bl	a050 <find_sc_cfg>
		if (cfg) {
    a840:	2800      	cmp	r0, #0
    a842:	d0f9      	beq.n	a838 <sc_clear+0x38>
	memset(cfg, 0, sizeof(*cfg));
    a844:	220c      	movs	r2, #12
    a846:	4629      	mov	r1, r5
}
    a848:	b008      	add	sp, #32
    a84a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	memset(cfg, 0, sizeof(*cfg));
    a84e:	f01d b81a 	b.w	27886 <memset>
    a852:	bf00      	nop
    a854:	000305ba 	.word	0x000305ba
    a858:	0002daa4 	.word	0x0002daa4

0000a85c <disconnected_cb>:
{
    a85c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    a860:	4b1f      	ldr	r3, [pc, #124]	; (a8e0 <disconnected_cb+0x84>)
{
    a862:	4615      	mov	r5, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    a864:	6882      	ldr	r2, [r0, #8]
    a866:	429a      	cmp	r2, r3
{
    a868:	4606      	mov	r6, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    a86a:	d102      	bne.n	a872 <disconnected_cb+0x16>
	ccc = attr->user_data;
    a86c:	68c4      	ldr	r4, [r0, #12]
	if (!ccc->value) {
    a86e:	8963      	ldrh	r3, [r4, #10]
    a870:	b9c3      	cbnz	r3, a8a4 <disconnected_cb+0x48>
}
    a872:	2001      	movs	r0, #1
    a874:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    a878:	f105 0888 	add.w	r8, r5, #136	; 0x88
    a87c:	7a28      	ldrb	r0, [r5, #8]
    a87e:	4641      	mov	r1, r8
    a880:	f01d fb46 	bl	27f10 <bt_addr_le_is_bonded>
    a884:	b948      	cbnz	r0, a89a <disconnected_cb+0x3e>
				if (ccc == &sc_ccc) {
    a886:	4b17      	ldr	r3, [pc, #92]	; (a8e4 <disconnected_cb+0x88>)
    a888:	429c      	cmp	r4, r3
    a88a:	d102      	bne.n	a892 <disconnected_cb+0x36>
					sc_clear(conn);
    a88c:	4628      	mov	r0, r5
    a88e:	f7ff ffb7 	bl	a800 <sc_clear>
				clear_ccc_cfg(cfg);
    a892:	4620      	mov	r0, r4
    a894:	f01e fb05 	bl	28ea2 <clear_ccc_cfg>
	if (!value_used) {
    a898:	e019      	b.n	a8ce <disconnected_cb+0x72>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    a89a:	4641      	mov	r1, r8
    a89c:	4638      	mov	r0, r7
    a89e:	f01e fafd 	bl	28e9c <bt_addr_le_copy>
	if (!value_used) {
    a8a2:	e014      	b.n	a8ce <disconnected_cb+0x72>
		if (!cfg->value) {
    a8a4:	8923      	ldrh	r3, [r4, #8]
    a8a6:	b193      	cbz	r3, a8ce <disconnected_cb+0x72>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    a8a8:	4627      	mov	r7, r4
    a8aa:	4628      	mov	r0, r5
    a8ac:	f817 1b01 	ldrb.w	r1, [r7], #1
    a8b0:	463a      	mov	r2, r7
    a8b2:	f01d fd87 	bl	283c4 <bt_conn_is_peer_addr_le>
    a8b6:	2800      	cmp	r0, #0
    a8b8:	d1de      	bne.n	a878 <disconnected_cb+0x1c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    a8ba:	7820      	ldrb	r0, [r4, #0]
    a8bc:	4639      	mov	r1, r7
    a8be:	f7fe f899 	bl	89f4 <bt_conn_lookup_addr_le>
			if (tmp) {
    a8c2:	b120      	cbz	r0, a8ce <disconnected_cb+0x72>
				if (tmp->state == BT_CONN_CONNECTED) {
    a8c4:	7a85      	ldrb	r5, [r0, #10]
				bt_conn_unref(tmp);
    a8c6:	f01d fd12 	bl	282ee <bt_conn_unref>
	if (!value_used) {
    a8ca:	2d07      	cmp	r5, #7
    a8cc:	d0d1      	beq.n	a872 <disconnected_cb+0x16>
		if (ccc->cfg_changed) {
    a8ce:	68e3      	ldr	r3, [r4, #12]
		ccc->value = 0U;
    a8d0:	2100      	movs	r1, #0
    a8d2:	8161      	strh	r1, [r4, #10]
		if (ccc->cfg_changed) {
    a8d4:	2b00      	cmp	r3, #0
    a8d6:	d0cc      	beq.n	a872 <disconnected_cb+0x16>
			ccc->cfg_changed(attr, ccc->value);
    a8d8:	4630      	mov	r0, r6
    a8da:	4798      	blx	r3
    a8dc:	e7c9      	b.n	a872 <disconnected_cb+0x16>
    a8de:	bf00      	nop
    a8e0:	0000a109 	.word	0x0000a109
    a8e4:	200003f8 	.word	0x200003f8

0000a8e8 <sc_indicate>:
{
    a8e8:	b570      	push	{r4, r5, r6, lr}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    a8ea:	4c12      	ldr	r4, [pc, #72]	; (a934 <sc_indicate+0x4c>)
    a8ec:	4606      	mov	r6, r0
    a8ee:	460d      	mov	r5, r1
    a8f0:	f104 0050 	add.w	r0, r4, #80	; 0x50
    a8f4:	2101      	movs	r1, #1
    a8f6:	f01e fa99 	bl	28e2c <atomic_or>
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a8fa:	07c2      	lsls	r2, r0, #31
    a8fc:	d40e      	bmi.n	a91c <sc_indicate+0x34>
		gatt_sc.start = start;
    a8fe:	8326      	strh	r6, [r4, #24]
		*end = new_end;
    a900:	8365      	strh	r5, [r4, #26]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    a902:	480d      	ldr	r0, [pc, #52]	; (a938 <sc_indicate+0x50>)
    a904:	f01e fa37 	bl	28d76 <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
    a908:	0783      	lsls	r3, r0, #30
    a90a:	d40d      	bmi.n	a928 <sc_indicate+0x40>
}
    a90c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_reschedule(&gatt_sc.work, timeout);
    a910:	480a      	ldr	r0, [pc, #40]	; (a93c <sc_indicate+0x54>)
    a912:	f44f 72a4 	mov.w	r2, #328	; 0x148
    a916:	2300      	movs	r3, #0
    a918:	f019 bd24 	b.w	24364 <k_work_reschedule>
	if (new_start >= *start && new_end <= *end) {
    a91c:	8b22      	ldrh	r2, [r4, #24]
    a91e:	8b63      	ldrh	r3, [r4, #26]
    a920:	42b2      	cmp	r2, r6
    a922:	d802      	bhi.n	a92a <sc_indicate+0x42>
    a924:	42ab      	cmp	r3, r5
    a926:	d3eb      	bcc.n	a900 <sc_indicate+0x18>
}
    a928:	bd70      	pop	{r4, r5, r6, pc}
	if (*end < new_end) {
    a92a:	42ab      	cmp	r3, r5
		*start = new_start;
    a92c:	8326      	strh	r6, [r4, #24]
	if (*end < new_end) {
    a92e:	d2e8      	bcs.n	a902 <sc_indicate+0x1a>
    a930:	e7e6      	b.n	a900 <sc_indicate+0x18>
    a932:	bf00      	nop
    a934:	20001938 	.word	0x20001938
    a938:	20001988 	.word	0x20001988
    a93c:	20001958 	.word	0x20001958

0000a940 <sc_commit>:
{
    a940:	b508      	push	{r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a942:	4809      	ldr	r0, [pc, #36]	; (a968 <sc_commit+0x28>)
    a944:	f06f 0102 	mvn.w	r1, #2
    a948:	f01e fab9 	bl	28ebe <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    a94c:	4806      	ldr	r0, [pc, #24]	; (a968 <sc_commit+0x28>)
    a94e:	f01e fa12 	bl	28d76 <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a952:	07c3      	lsls	r3, r0, #31
    a954:	d505      	bpl.n	a962 <sc_commit+0x22>
	k_work_reschedule(&gatt_sc.work, timeout);
    a956:	4805      	ldr	r0, [pc, #20]	; (a96c <sc_commit+0x2c>)
    a958:	f44f 72a4 	mov.w	r2, #328	; 0x148
    a95c:	2300      	movs	r3, #0
    a95e:	f019 fd01 	bl	24364 <k_work_reschedule>
}
    a962:	2000      	movs	r0, #0
    a964:	bd08      	pop	{r3, pc}
    a966:	bf00      	nop
    a968:	20001988 	.word	0x20001988
    a96c:	20001958 	.word	0x20001958

0000a970 <sc_indicate_rsp>:
{
    a970:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a972:	f06f 0102 	mvn.w	r1, #2
    a976:	4604      	mov	r4, r0
    a978:	480d      	ldr	r0, [pc, #52]	; (a9b0 <sc_indicate_rsp+0x40>)
    a97a:	f01e faa0 	bl	28ebe <atomic_and>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    a97e:	480c      	ldr	r0, [pc, #48]	; (a9b0 <sc_indicate_rsp+0x40>)
    a980:	f01e f9f9 	bl	28d76 <atomic_get>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    a984:	07c2      	lsls	r2, r0, #31
    a986:	d504      	bpl.n	a992 <sc_indicate_rsp+0x22>
	k_work_reschedule(&gatt_sc.work, timeout);
    a988:	480a      	ldr	r0, [pc, #40]	; (a9b4 <sc_indicate_rsp+0x44>)
    a98a:	2200      	movs	r2, #0
    a98c:	2300      	movs	r3, #0
    a98e:	f019 fce9 	bl	24364 <k_work_reschedule>
	cfg = find_cf_cfg(conn);
    a992:	4620      	mov	r0, r4
    a994:	f7ff fb3e 	bl	a014 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
    a998:	b140      	cbz	r0, a9ac <sc_indicate_rsp+0x3c>
    a99a:	7a03      	ldrb	r3, [r0, #8]
    a99c:	07db      	lsls	r3, r3, #31
    a99e:	d505      	bpl.n	a9ac <sc_indicate_rsp+0x3c>
}
    a9a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    a9a4:	2101      	movs	r1, #1
    a9a6:	300c      	adds	r0, #12
    a9a8:	f01e ba40 	b.w	28e2c <atomic_or>
    a9ac:	bd10      	pop	{r4, pc}
    a9ae:	bf00      	nop
    a9b0:	20001988 	.word	0x20001988
    a9b4:	20001958 	.word	0x20001958

0000a9b8 <bt_gatt_init>:
{
    a9b8:	b508      	push	{r3, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    a9ba:	4b1e      	ldr	r3, [pc, #120]	; (aa34 <bt_gatt_init+0x7c>)
    a9bc:	f3bf 8f5b 	dmb	ish
    a9c0:	2201      	movs	r2, #1
    a9c2:	e853 1f00 	ldrex	r1, [r3]
    a9c6:	2900      	cmp	r1, #0
    a9c8:	d103      	bne.n	a9d2 <bt_gatt_init+0x1a>
    a9ca:	e843 2000 	strex	r0, r2, [r3]
    a9ce:	2800      	cmp	r0, #0
    a9d0:	d1f7      	bne.n	a9c2 <bt_gatt_init+0xa>
    a9d2:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
    a9d6:	d12b      	bne.n	aa30 <bt_gatt_init+0x78>
    a9d8:	f3bf 8f5b 	dmb	ish
    a9dc:	4b16      	ldr	r3, [pc, #88]	; (aa38 <bt_gatt_init+0x80>)
    a9de:	e853 1f00 	ldrex	r1, [r3]
    a9e2:	2900      	cmp	r1, #0
    a9e4:	d103      	bne.n	a9ee <bt_gatt_init+0x36>
    a9e6:	e843 2000 	strex	r0, r2, [r3]
    a9ea:	2800      	cmp	r0, #0
    a9ec:	d1f7      	bne.n	a9de <bt_gatt_init+0x26>
    a9ee:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&service_init, 0, 1)) {
    a9f2:	d101      	bne.n	a9f8 <bt_gatt_init+0x40>
    a9f4:	f7ff fb4c 	bl	a090 <bt_gatt_service_init.part.0>
	list->head = NULL;
    a9f8:	4b10      	ldr	r3, [pc, #64]	; (aa3c <bt_gatt_init+0x84>)
	k_work_init_delayable(&db_hash.work, db_hash_process);
    a9fa:	4911      	ldr	r1, [pc, #68]	; (aa40 <bt_gatt_init+0x88>)
    a9fc:	4811      	ldr	r0, [pc, #68]	; (aa44 <bt_gatt_init+0x8c>)
    a9fe:	2200      	movs	r2, #0
	list->tail = NULL;
    aa00:	e9c3 2200 	strd	r2, r2, [r3]
    aa04:	f022 f9f1 	bl	2cdea <k_work_init_delayable>
	k_work_schedule(&db_hash.work, DB_HASH_TIMEOUT);
    aa08:	2300      	movs	r3, #0
    aa0a:	f44f 72a4 	mov.w	r2, #328	; 0x148
    aa0e:	480d      	ldr	r0, [pc, #52]	; (aa44 <bt_gatt_init+0x8c>)
    aa10:	f019 fc74 	bl	242fc <k_work_schedule>
	k_work_init_delayable(&gatt_sc.work, sc_process);
    aa14:	490c      	ldr	r1, [pc, #48]	; (aa48 <bt_gatt_init+0x90>)
    aa16:	480d      	ldr	r0, [pc, #52]	; (aa4c <bt_gatt_init+0x94>)
    aa18:	f022 f9e7 	bl	2cdea <k_work_init_delayable>
    aa1c:	2102      	movs	r1, #2
    aa1e:	480c      	ldr	r0, [pc, #48]	; (aa50 <bt_gatt_init+0x98>)
    aa20:	f01e fa04 	bl	28e2c <atomic_or>
}
    aa24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_work_init_delayable(&gatt_ccc_store.work, ccc_delayed_store);
    aa28:	490a      	ldr	r1, [pc, #40]	; (aa54 <bt_gatt_init+0x9c>)
    aa2a:	480b      	ldr	r0, [pc, #44]	; (aa58 <bt_gatt_init+0xa0>)
    aa2c:	f022 b9dd 	b.w	2cdea <k_work_init_delayable>
}
    aa30:	bd08      	pop	{r3, pc}
    aa32:	bf00      	nop
    aa34:	200026a0 	.word	0x200026a0
    aa38:	200026bc 	.word	0x200026bc
    aa3c:	20002680 	.word	0x20002680
    aa40:	0000ac45 	.word	0x0000ac45
    aa44:	200018a8 	.word	0x200018a8
    aa48:	0000b179 	.word	0x0000b179
    aa4c:	20001958 	.word	0x20001958
    aa50:	20001988 	.word	0x20001988
    aa54:	000292a1 	.word	0x000292a1
    aa58:	20001908 	.word	0x20001908

0000aa5c <bt_gatt_attr_get_handle>:
{
    aa5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!attr) {
    aa60:	4603      	mov	r3, r0
    aa62:	b148      	cbz	r0, aa78 <bt_gatt_attr_get_handle+0x1c>
	if (attr->handle) {
    aa64:	8a00      	ldrh	r0, [r0, #16]
    aa66:	b938      	cbnz	r0, aa78 <bt_gatt_attr_get_handle+0x1c>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    aa68:	4912      	ldr	r1, [pc, #72]	; (aab4 <bt_gatt_attr_get_handle+0x58>)
    aa6a:	f8df e04c 	ldr.w	lr, [pc, #76]	; aab8 <bt_gatt_attr_get_handle+0x5c>
	uint16_t handle = 1;
    aa6e:	2401      	movs	r4, #1
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    aa70:	f04f 0c14 	mov.w	ip, #20
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    aa74:	4571      	cmp	r1, lr
    aa76:	d301      	bcc.n	aa7c <bt_gatt_attr_get_handle+0x20>
}
    aa78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    aa7c:	e9d1 7600 	ldrd	r7, r6, [r1]
		if ((attr < &static_svc->attrs[0]) ||
    aa80:	42bb      	cmp	r3, r7
    aa82:	d304      	bcc.n	aa8e <bt_gatt_attr_get_handle+0x32>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    aa84:	fb0c 7206 	mla	r2, ip, r6, r7
    aa88:	3a14      	subs	r2, #20
		if ((attr < &static_svc->attrs[0]) ||
    aa8a:	4293      	cmp	r3, r2
    aa8c:	d90e      	bls.n	aaac <bt_gatt_attr_get_handle+0x50>
			handle += static_svc->attr_count;
    aa8e:	19a2      	adds	r2, r4, r6
    aa90:	b292      	uxth	r2, r2
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    aa92:	3108      	adds	r1, #8
    aa94:	4614      	mov	r4, r2
    aa96:	e7ed      	b.n	aa74 <bt_gatt_attr_get_handle+0x18>
			if (attr == &static_svc->attrs[i]) {
    aa98:	fb0c 7805 	mla	r8, ip, r5, r7
    aa9c:	4543      	cmp	r3, r8
    aa9e:	d007      	beq.n	aab0 <bt_gatt_attr_get_handle+0x54>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
    aaa0:	3501      	adds	r5, #1
    aaa2:	1962      	adds	r2, r4, r5
    aaa4:	42b5      	cmp	r5, r6
    aaa6:	b292      	uxth	r2, r2
    aaa8:	d1f6      	bne.n	aa98 <bt_gatt_attr_get_handle+0x3c>
    aaaa:	e7f2      	b.n	aa92 <bt_gatt_attr_get_handle+0x36>
    aaac:	2500      	movs	r5, #0
    aaae:	e7f8      	b.n	aaa2 <bt_gatt_attr_get_handle+0x46>
    aab0:	4610      	mov	r0, r2
    aab2:	e7e1      	b.n	aa78 <bt_gatt_attr_get_handle+0x1c>
    aab4:	0002d844 	.word	0x0002d844
    aab8:	0002d854 	.word	0x0002d854

0000aabc <bt_gatt_foreach_attr_type>:
{
    aabc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aac0:	b089      	sub	sp, #36	; 0x24
    aac2:	4699      	mov	r9, r3
	if (!num_matches) {
    aac4:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
{
    aac8:	4604      	mov	r4, r0
    aaca:	460f      	mov	r7, r1
    aacc:	4690      	mov	r8, r2
	if (!num_matches) {
    aace:	b91b      	cbnz	r3, aad8 <bt_gatt_foreach_attr_type+0x1c>
		num_matches = UINT16_MAX;
    aad0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    aad4:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
	if (start_handle <= last_static_handle) {
    aad8:	4b31      	ldr	r3, [pc, #196]	; (aba0 <bt_gatt_foreach_attr_type+0xe4>)
    aada:	881b      	ldrh	r3, [r3, #0]
    aadc:	42a3      	cmp	r3, r4
    aade:	d230      	bcs.n	ab42 <bt_gatt_foreach_attr_type+0x86>
	foreach_attr_type_dyndb(start_handle, end_handle, uuid, attr_data,
    aae0:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
    aae4:	f8ad 301e 	strh.w	r3, [sp, #30]
	return list->head;
    aae8:	4b2e      	ldr	r3, [pc, #184]	; (aba4 <bt_gatt_foreach_attr_type+0xe8>)
    aaea:	681d      	ldr	r5, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    aaec:	bb7d      	cbnz	r5, ab4e <bt_gatt_foreach_attr_type+0x92>
}
    aaee:	b009      	add	sp, #36	; 0x24
    aaf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (handle + static_svc->attr_count < start_handle) {
    aaf4:	6869      	ldr	r1, [r5, #4]
    aaf6:	4451      	add	r1, sl
    aaf8:	42a1      	cmp	r1, r4
    aafa:	d220      	bcs.n	ab3e <bt_gatt_foreach_attr_type+0x82>
				handle += static_svc->attr_count;
    aafc:	b289      	uxth	r1, r1
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    aafe:	3508      	adds	r5, #8
    ab00:	468a      	mov	sl, r1
    ab02:	4b29      	ldr	r3, [pc, #164]	; (aba8 <bt_gatt_foreach_attr_type+0xec>)
    ab04:	429d      	cmp	r5, r3
    ab06:	d3f5      	bcc.n	aaf4 <bt_gatt_foreach_attr_type+0x38>
    ab08:	e7ea      	b.n	aae0 <bt_gatt_foreach_attr_type+0x24>
				if (gatt_foreach_iter(&static_svc->attrs[i],
    ab0a:	9b14      	ldr	r3, [sp, #80]	; 0x50
    ab0c:	6828      	ldr	r0, [r5, #0]
    ab0e:	9304      	str	r3, [sp, #16]
    ab10:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    ab12:	9303      	str	r3, [sp, #12]
    ab14:	ab12      	add	r3, sp, #72	; 0x48
    ab16:	e9cd 9301 	strd	r9, r3, [sp, #4]
    ab1a:	f8cd 8000 	str.w	r8, [sp]
    ab1e:	463b      	mov	r3, r7
    ab20:	4622      	mov	r2, r4
    ab22:	fb0b 0006 	mla	r0, fp, r6, r0
    ab26:	f01e f9d9 	bl	28edc <gatt_foreach_iter>
    ab2a:	2800      	cmp	r0, #0
    ab2c:	d0df      	beq.n	aaee <bt_gatt_foreach_attr_type+0x32>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    ab2e:	3601      	adds	r6, #1
    ab30:	686b      	ldr	r3, [r5, #4]
    ab32:	eb0a 0106 	add.w	r1, sl, r6
    ab36:	42b3      	cmp	r3, r6
    ab38:	b289      	uxth	r1, r1
    ab3a:	d8e6      	bhi.n	ab0a <bt_gatt_foreach_attr_type+0x4e>
    ab3c:	e7df      	b.n	aafe <bt_gatt_foreach_attr_type+0x42>
    ab3e:	2600      	movs	r6, #0
    ab40:	e7f6      	b.n	ab30 <bt_gatt_foreach_attr_type+0x74>
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    ab42:	4d1a      	ldr	r5, [pc, #104]	; (abac <bt_gatt_foreach_attr_type+0xf0>)
		uint16_t handle = 1;
    ab44:	f04f 0a01 	mov.w	sl, #1
				if (gatt_foreach_iter(&static_svc->attrs[i],
    ab48:	f04f 0b14 	mov.w	fp, #20
    ab4c:	e7d9      	b.n	ab02 <bt_gatt_foreach_attr_type+0x46>
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    ab4e:	3d08      	subs	r5, #8
			struct bt_gatt_attr *attr = &svc->attrs[i];
    ab50:	f04f 0a14 	mov.w	sl, #20
			if (gatt_foreach_iter(attr, attr->handle,
    ab54:	f10d 0b1e 	add.w	fp, sp, #30
	return node->next;
    ab58:	68ae      	ldr	r6, [r5, #8]
		next = SYS_SLIST_PEEK_NEXT_CONTAINER(svc, node);
    ab5a:	b1de      	cbz	r6, ab94 <bt_gatt_foreach_attr_type+0xd8>
			if (next->attrs[0].handle <= start_handle) {
    ab5c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    ab60:	8a1b      	ldrh	r3, [r3, #16]
    ab62:	42a3      	cmp	r3, r4
    ab64:	d81a      	bhi.n	ab9c <bt_gatt_foreach_attr_type+0xe0>
    ab66:	68ad      	ldr	r5, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
    ab68:	2d00      	cmp	r5, #0
    ab6a:	d0c0      	beq.n	aaee <bt_gatt_foreach_attr_type+0x32>
    ab6c:	3d08      	subs	r5, #8
    ab6e:	e7f3      	b.n	ab58 <bt_gatt_foreach_attr_type+0x9c>
			struct bt_gatt_attr *attr = &svc->attrs[i];
    ab70:	6828      	ldr	r0, [r5, #0]
			if (gatt_foreach_iter(attr, attr->handle,
    ab72:	9b14      	ldr	r3, [sp, #80]	; 0x50
			struct bt_gatt_attr *attr = &svc->attrs[i];
    ab74:	fb0a 0006 	mla	r0, sl, r6, r0
			if (gatt_foreach_iter(attr, attr->handle,
    ab78:	4622      	mov	r2, r4
    ab7a:	8a01      	ldrh	r1, [r0, #16]
    ab7c:	9304      	str	r3, [sp, #16]
    ab7e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    ab80:	e9cd 8900 	strd	r8, r9, [sp]
    ab84:	e9cd b302 	strd	fp, r3, [sp, #8]
    ab88:	463b      	mov	r3, r7
    ab8a:	f01e f9a7 	bl	28edc <gatt_foreach_iter>
    ab8e:	2800      	cmp	r0, #0
    ab90:	d0ad      	beq.n	aaee <bt_gatt_foreach_attr_type+0x32>
		for (i = 0; i < svc->attr_count; i++) {
    ab92:	3601      	adds	r6, #1
    ab94:	686b      	ldr	r3, [r5, #4]
    ab96:	429e      	cmp	r6, r3
    ab98:	d3ea      	bcc.n	ab70 <bt_gatt_foreach_attr_type+0xb4>
    ab9a:	e7e4      	b.n	ab66 <bt_gatt_foreach_attr_type+0xaa>
    ab9c:	2600      	movs	r6, #0
    ab9e:	e7f9      	b.n	ab94 <bt_gatt_foreach_attr_type+0xd8>
    aba0:	2000388e 	.word	0x2000388e
    aba4:	20002698 	.word	0x20002698
    aba8:	0002d854 	.word	0x0002d854
    abac:	0002d844 	.word	0x0002d844

0000abb0 <db_hash_gen>:
{
    abb0:	b530      	push	{r4, r5, lr}
    abb2:	b0d1      	sub	sp, #324	; 0x144
	uint8_t key[16] = {};
    abb4:	2300      	movs	r3, #0
{
    abb6:	4604      	mov	r4, r0
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    abb8:	aa24      	add	r2, sp, #144	; 0x90
    abba:	a902      	add	r1, sp, #8
    abbc:	a80c      	add	r0, sp, #48	; 0x30
	uint8_t key[16] = {};
    abbe:	e9cd 3302 	strd	r3, r3, [sp, #8]
    abc2:	e9cd 3304 	strd	r3, r3, [sp, #16]
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    abc6:	f01c fc41 	bl	2744c <tc_cmac_setup>
    abca:	b960      	cbnz	r0, abe6 <db_hash_gen+0x36>
		BT_ERR("Unable to setup AES CMAC");
    abcc:	4b17      	ldr	r3, [pc, #92]	; (ac2c <db_hash_gen+0x7c>)
		BT_ERR("Unable to calculate hash");
    abce:	930a      	str	r3, [sp, #40]	; 0x28
    abd0:	4817      	ldr	r0, [pc, #92]	; (ac30 <db_hash_gen+0x80>)
    abd2:	2302      	movs	r3, #2
    abd4:	aa09      	add	r2, sp, #36	; 0x24
    abd6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    abda:	9301      	str	r3, [sp, #4]
    abdc:	9309      	str	r3, [sp, #36]	; 0x24
    abde:	f01e f9a2 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    abe2:	b051      	add	sp, #324	; 0x144
    abe4:	bd30      	pop	{r4, r5, pc}
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
    abe6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    abea:	2001      	movs	r0, #1
    abec:	4a11      	ldr	r2, [pc, #68]	; (ac34 <db_hash_gen+0x84>)
    abee:	ab0c      	add	r3, sp, #48	; 0x30
    abf0:	f01e faff 	bl	291f2 <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
    abf4:	4810      	ldr	r0, [pc, #64]	; (ac38 <db_hash_gen+0x88>)
    abf6:	a90c      	add	r1, sp, #48	; 0x30
    abf8:	f01c fcbe 	bl	27578 <tc_cmac_final>
    abfc:	b908      	cbnz	r0, ac02 <db_hash_gen+0x52>
		BT_ERR("Unable to calculate hash");
    abfe:	4b0f      	ldr	r3, [pc, #60]	; (ac3c <db_hash_gen+0x8c>)
    ac00:	e7e5      	b.n	abce <db_hash_gen+0x1e>
    ac02:	4b0d      	ldr	r3, [pc, #52]	; (ac38 <db_hash_gen+0x88>)
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
    ac04:	2208      	movs	r2, #8
    ac06:	f103 010f 	add.w	r1, r3, #15
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
		uint8_t tmp = ((uint8_t *)buf)[i];
    ac0a:	7818      	ldrb	r0, [r3, #0]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
    ac0c:	780d      	ldrb	r5, [r1, #0]
    ac0e:	f803 5b01 	strb.w	r5, [r3], #1
	for (i = 0; i < (length/2); i++) {
    ac12:	3a01      	subs	r2, #1
		((uint8_t *)buf)[length - 1 - i] = tmp;
    ac14:	f801 0901 	strb.w	r0, [r1], #-1
	for (i = 0; i < (length/2); i++) {
    ac18:	d1f7      	bne.n	ac0a <db_hash_gen+0x5a>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) && store) {
    ac1a:	b10c      	cbz	r4, ac20 <db_hash_gen+0x70>
		db_hash_store();
    ac1c:	f7ff fbaa 	bl	a374 <db_hash_store>
    ac20:	2104      	movs	r1, #4
    ac22:	4807      	ldr	r0, [pc, #28]	; (ac40 <db_hash_gen+0x90>)
    ac24:	f01e f902 	bl	28e2c <atomic_or>
    ac28:	e7db      	b.n	abe2 <db_hash_gen+0x32>
    ac2a:	bf00      	nop
    ac2c:	000305d0 	.word	0x000305d0
    ac30:	0002daa4 	.word	0x0002daa4
    ac34:	00028d83 	.word	0x00028d83
    ac38:	20001888 	.word	0x20001888
    ac3c:	000305e9 	.word	0x000305e9
    ac40:	20001988 	.word	0x20001988

0000ac44 <db_hash_process>:
{
    ac44:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    ac46:	4817      	ldr	r0, [pc, #92]	; (aca4 <db_hash_process+0x60>)
    ac48:	f06f 0108 	mvn.w	r1, #8
    ac4c:	f01e f937 	bl	28ebe <atomic_and>
	if (atomic_test_and_clear_bit(gatt_sc.flags, DB_HASH_LOAD)) {
    ac50:	0702      	lsls	r2, r0, #28
    ac52:	d522      	bpl.n	ac9a <db_hash_process+0x56>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    ac54:	4813      	ldr	r0, [pc, #76]	; (aca4 <db_hash_process+0x60>)
    ac56:	f01e f88e 	bl	28d76 <atomic_get>
    ac5a:	4603      	mov	r3, r0
		if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
    ac5c:	075b      	lsls	r3, r3, #29
    ac5e:	f3c0 0080 	ubfx	r0, r0, #2, #1
    ac62:	d401      	bmi.n	ac68 <db_hash_process+0x24>
			db_hash_gen(false);
    ac64:	f7ff ffa4 	bl	abb0 <db_hash_gen>
		if (!memcmp(db_hash.stored_hash, db_hash.hash,
    ac68:	490f      	ldr	r1, [pc, #60]	; (aca8 <db_hash_process+0x64>)
    ac6a:	2210      	movs	r2, #16
    ac6c:	1888      	adds	r0, r1, r2
    ac6e:	f01c fdee 	bl	2784e <memcmp>
    ac72:	b948      	cbnz	r0, ac88 <db_hash_process+0x44>
			k_work_cancel_delayable(&gatt_sc.work);
    ac74:	480d      	ldr	r0, [pc, #52]	; (acac <db_hash_process+0x68>)
    ac76:	f022 f8c6 	bl	2ce06 <k_work_cancel_delayable>
}
    ac7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    ac7e:	4809      	ldr	r0, [pc, #36]	; (aca4 <db_hash_process+0x60>)
    ac80:	f06f 0101 	mvn.w	r1, #1
    ac84:	f01e b91b 	b.w	28ebe <atomic_and>
		sc_indicate(0x0001, 0xffff);
    ac88:	f64f 71ff 	movw	r1, #65535	; 0xffff
    ac8c:	2001      	movs	r0, #1
    ac8e:	f7ff fe2b 	bl	a8e8 <sc_indicate>
}
    ac92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		db_hash_store();
    ac96:	f7ff bb6d 	b.w	a374 <db_hash_store>
}
    ac9a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	db_hash_gen(true);
    ac9e:	2001      	movs	r0, #1
    aca0:	f7ff bf86 	b.w	abb0 <db_hash_gen>
    aca4:	20001988 	.word	0x20001988
    aca8:	20001888 	.word	0x20001888
    acac:	20001958 	.word	0x20001958

0000acb0 <bt_gatt_service_register>:
{
    acb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    acb4:	4b67      	ldr	r3, [pc, #412]	; (ae54 <bt_gatt_service_register+0x1a4>)
    acb6:	f3bf 8f5b 	dmb	ish
    acba:	b089      	sub	sp, #36	; 0x24
    acbc:	4604      	mov	r4, r0
    acbe:	2201      	movs	r2, #1
    acc0:	e853 1f00 	ldrex	r1, [r3]
    acc4:	2900      	cmp	r1, #0
    acc6:	d103      	bne.n	acd0 <bt_gatt_service_register+0x20>
    acc8:	e843 2000 	strex	r0, r2, [r3]
    accc:	2800      	cmp	r0, #0
    acce:	d1f7      	bne.n	acc0 <bt_gatt_service_register+0x10>
    acd0:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&service_init, 0, 1)) {
    acd4:	d101      	bne.n	acda <bt_gatt_service_register+0x2a>
    acd6:	f7ff f9db 	bl	a090 <bt_gatt_service_init.part.0>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
    acda:	6823      	ldr	r3, [r4, #0]
    acdc:	2500      	movs	r5, #0
    acde:	6818      	ldr	r0, [r3, #0]
    ace0:	f88d 5004 	strb.w	r5, [sp, #4]
    ace4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    ace8:	a901      	add	r1, sp, #4
    acea:	f8ad 3006 	strh.w	r3, [sp, #6]
    acee:	f01d f80c 	bl	27d0a <bt_uuid_cmp>
    acf2:	b928      	cbnz	r0, ad00 <bt_gatt_service_register+0x50>
		return -EALREADY;
    acf4:	f06f 0577 	mvn.w	r5, #119	; 0x77
}
    acf8:	4628      	mov	r0, r5
    acfa:	b009      	add	sp, #36	; 0x24
    acfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GATT)) {
    ad00:	6823      	ldr	r3, [r4, #0]
    ad02:	a902      	add	r1, sp, #8
    ad04:	6818      	ldr	r0, [r3, #0]
    ad06:	f88d 5008 	strb.w	r5, [sp, #8]
    ad0a:	f641 0301 	movw	r3, #6145	; 0x1801
    ad0e:	f8ad 300a 	strh.w	r3, [sp, #10]
    ad12:	f01c fffa 	bl	27d0a <bt_uuid_cmp>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
    ad16:	2800      	cmp	r0, #0
    ad18:	d0ec      	beq.n	acf4 <bt_gatt_service_register+0x44>
	return list->head;
    ad1a:	4d4f      	ldr	r5, [pc, #316]	; (ae58 <bt_gatt_service_register+0x1a8>)
	k_sched_lock();
    ad1c:	f019 fb80 	bl	24420 <k_sched_lock>
	if (sys_slist_is_empty(&db)) {
    ad20:	682e      	ldr	r6, [r5, #0]
	struct bt_gatt_attr *attrs = svc->attrs;
    ad22:	f8d4 8000 	ldr.w	r8, [r4]
	uint16_t count = svc->attr_count;
    ad26:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	if (sys_slist_is_empty(&db)) {
    ad2a:	b936      	cbnz	r6, ad3a <bt_gatt_service_register+0x8a>
		handle = last_static_handle;
    ad2c:	4b4b      	ldr	r3, [pc, #300]	; (ae5c <bt_gatt_service_register+0x1ac>)
    ad2e:	881f      	ldrh	r7, [r3, #0]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    ad30:	f8df b12c 	ldr.w	fp, [pc, #300]	; ae60 <bt_gatt_service_register+0x1b0>
	const struct bt_gatt_attr *attr = NULL;
    ad34:	f04f 0a00 	mov.w	sl, #0
    ad38:	e01a      	b.n	ad70 <bt_gatt_service_register+0xc0>
	return list->tail;
    ad3a:	686b      	ldr	r3, [r5, #4]
	last = SYS_SLIST_PEEK_TAIL_CONTAINER(&db, last, node);
    ad3c:	2b00      	cmp	r3, #0
    ad3e:	f000 8087 	beq.w	ae50 <bt_gatt_service_register+0x1a0>
	handle = last->attrs[last->attr_count - 1].handle;
    ad42:	e953 3202 	ldrd	r3, r2, [r3, #-8]
    ad46:	2114      	movs	r1, #20
    ad48:	fb01 3302 	mla	r3, r1, r2, r3
    ad4c:	f833 7c04 	ldrh.w	r7, [r3, #-4]
    ad50:	463e      	mov	r6, r7
    ad52:	e7ed      	b.n	ad30 <bt_gatt_service_register+0x80>
		if (!attrs->handle) {
    ad54:	f8b8 1010 	ldrh.w	r1, [r8, #16]
    ad58:	bb39      	cbnz	r1, adaa <bt_gatt_service_register+0xfa>
			attrs->handle = ++handle;
    ad5a:	1c79      	adds	r1, r7, #1
    ad5c:	b289      	uxth	r1, r1
    ad5e:	f8a8 1010 	strh.w	r1, [r8, #16]
	for (; attrs && count; attrs++, count--) {
    ad62:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    ad66:	f108 0814 	add.w	r8, r8, #20
    ad6a:	fa1f f989 	uxth.w	r9, r9
    ad6e:	460f      	mov	r7, r1
    ad70:	f1b8 0f00 	cmp.w	r8, #0
    ad74:	d002      	beq.n	ad7c <bt_gatt_service_register+0xcc>
    ad76:	f1b9 0f00 	cmp.w	r9, #0
    ad7a:	d1eb      	bne.n	ad54 <bt_gatt_service_register+0xa4>
	if (last_handle == 0 || svc->attrs[0].handle > last_handle) {
    ad7c:	b11e      	cbz	r6, ad86 <bt_gatt_service_register+0xd6>
    ad7e:	6823      	ldr	r3, [r4, #0]
    ad80:	8a1f      	ldrh	r7, [r3, #16]
    ad82:	42be      	cmp	r6, r7
    ad84:	d231      	bcs.n	adea <bt_gatt_service_register+0x13a>
	parent->next = child;
    ad86:	2200      	movs	r2, #0
		sys_slist_append(&db, &svc->node);
    ad88:	f104 0308 	add.w	r3, r4, #8
    ad8c:	60a2      	str	r2, [r4, #8]
	return list->tail;
    ad8e:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
    ad90:	2a00      	cmp	r2, #0
    ad92:	d13d      	bne.n	ae10 <bt_gatt_service_register+0x160>
	list->head = node;
    ad94:	e9c5 3300 	strd	r3, r3, [r5]
	if (!atomic_get(&init)) {
    ad98:	4832      	ldr	r0, [pc, #200]	; (ae64 <bt_gatt_service_register+0x1b4>)
    ad9a:	f01d ffec 	bl	28d76 <atomic_get>
    ad9e:	4605      	mov	r5, r0
    ada0:	2800      	cmp	r0, #0
    ada2:	d145      	bne.n	ae30 <bt_gatt_service_register+0x180>
		k_sched_unlock();
    ada4:	f019 fd0a 	bl	247bc <k_sched_unlock>
		return 0;
    ada8:	e7a6      	b.n	acf8 <bt_gatt_service_register+0x48>
		} else if (attrs->handle > handle) {
    adaa:	42b9      	cmp	r1, r7
    adac:	d8d9      	bhi.n	ad62 <bt_gatt_service_register+0xb2>
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    adae:	ab02      	add	r3, sp, #8
    adb0:	465a      	mov	r2, fp
    adb2:	4608      	mov	r0, r1
	const struct bt_gatt_attr *attr = NULL;
    adb4:	f8cd a008 	str.w	sl, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
    adb8:	f01e fa1b 	bl	291f2 <bt_gatt_foreach_attr>
	return attr;
    adbc:	9b02      	ldr	r3, [sp, #8]
		} else if (find_attr(attrs->handle)) {
    adbe:	b193      	cbz	r3, ade6 <bt_gatt_service_register+0x136>
			BT_ERR("Unable to register handle 0x%04x",
    adc0:	f8b8 3010 	ldrh.w	r3, [r8, #16]
    adc4:	4a28      	ldr	r2, [pc, #160]	; (ae68 <bt_gatt_service_register+0x1b8>)
    adc6:	4829      	ldr	r0, [pc, #164]	; (ae6c <bt_gatt_service_register+0x1bc>)
    adc8:	e9cd 2306 	strd	r2, r3, [sp, #24]
    adcc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    add0:	2303      	movs	r3, #3
    add2:	aa05      	add	r2, sp, #20
    add4:	9301      	str	r3, [sp, #4]
    add6:	9305      	str	r3, [sp, #20]
    add8:	f01e f8a5 	bl	28f26 <z_log_msg2_static_create.constprop.0>
		return err;
    addc:	f06f 0515 	mvn.w	r5, #21
		k_sched_unlock();
    ade0:	f019 fcec 	bl	247bc <k_sched_unlock>
		return err;
    ade4:	e788      	b.n	acf8 <bt_gatt_service_register+0x48>
    ade6:	4639      	mov	r1, r7
    ade8:	e7bb      	b.n	ad62 <bt_gatt_service_register+0xb2>
	return list->head;
    adea:	6829      	ldr	r1, [r5, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
    adec:	2900      	cmp	r1, #0
    adee:	d0d3      	beq.n	ad98 <bt_gatt_service_register+0xe8>
    adf0:	f1a1 0308 	sub.w	r3, r1, #8
    adf4:	2200      	movs	r2, #0
		if (tmp->attrs[0].handle > svc->attrs[0].handle) {
    adf6:	6818      	ldr	r0, [r3, #0]
    adf8:	8a00      	ldrh	r0, [r0, #16]
    adfa:	42b8      	cmp	r0, r7
    adfc:	d911      	bls.n	ae22 <bt_gatt_service_register+0x172>
				sys_slist_insert(&db, &prev->node, &svc->node);
    adfe:	f104 0308 	add.w	r3, r4, #8
			if (prev) {
    ae02:	b142      	cbz	r2, ae16 <bt_gatt_service_register+0x166>
	return node->next;
    ae04:	6891      	ldr	r1, [r2, #8]
	parent->next = child;
    ae06:	60a1      	str	r1, [r4, #8]
Z_GENLIST_INSERT(slist, snode)
    ae08:	2900      	cmp	r1, #0
    ae0a:	d0c0      	beq.n	ad8e <bt_gatt_service_register+0xde>
	parent->next = child;
    ae0c:	6093      	str	r3, [r2, #8]
	if (err < 0) {
    ae0e:	e7c3      	b.n	ad98 <bt_gatt_service_register+0xe8>
    ae10:	6013      	str	r3, [r2, #0]
	list->tail = node;
    ae12:	606b      	str	r3, [r5, #4]
    ae14:	e7c0      	b.n	ad98 <bt_gatt_service_register+0xe8>
Z_GENLIST_PREPEND(slist, snode)
    ae16:	686a      	ldr	r2, [r5, #4]
	parent->next = child;
    ae18:	60a1      	str	r1, [r4, #8]
	list->head = node;
    ae1a:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
    ae1c:	2a00      	cmp	r2, #0
    ae1e:	d1bb      	bne.n	ad98 <bt_gatt_service_register+0xe8>
    ae20:	e7f7      	b.n	ae12 <bt_gatt_service_register+0x162>
	return node->next;
    ae22:	6898      	ldr	r0, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
    ae24:	2800      	cmp	r0, #0
    ae26:	d0b7      	beq.n	ad98 <bt_gatt_service_register+0xe8>
    ae28:	461a      	mov	r2, r3
    ae2a:	f1a0 0308 	sub.w	r3, r0, #8
    ae2e:	e7e2      	b.n	adf6 <bt_gatt_service_register+0x146>
		    svc->attrs[svc->attr_count - 1].handle);
    ae30:	e9d4 2300 	ldrd	r2, r3, [r4]
	sc_indicate(svc->attrs[0].handle,
    ae34:	2114      	movs	r1, #20
    ae36:	fb01 2303 	mla	r3, r1, r3, r2
    ae3a:	8a10      	ldrh	r0, [r2, #16]
    ae3c:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    ae40:	f7ff fd52 	bl	a8e8 <sc_indicate>
	return 0;
    ae44:	2500      	movs	r5, #0
	db_changed();
    ae46:	f7ff fc75 	bl	a734 <db_changed>
	k_sched_unlock();
    ae4a:	f019 fcb7 	bl	247bc <k_sched_unlock>
	return 0;
    ae4e:	e753      	b.n	acf8 <bt_gatt_service_register+0x48>
	handle = last->attrs[last->attr_count - 1].handle;
    ae50:	681b      	ldr	r3, [r3, #0]
    ae52:	deff      	udf	#255	; 0xff
    ae54:	200026bc 	.word	0x200026bc
    ae58:	20002698 	.word	0x20002698
    ae5c:	2000388e 	.word	0x2000388e
    ae60:	00028d2b 	.word	0x00028d2b
    ae64:	200026a0 	.word	0x200026a0
    ae68:	00030602 	.word	0x00030602
    ae6c:	0002daa4 	.word	0x0002daa4

0000ae70 <ccc_set>:
{
    ae70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ae74:	b0c2      	sub	sp, #264	; 0x108
    ae76:	4604      	mov	r4, r0
    ae78:	4688      	mov	r8, r1
		settings_name_next(name, &next);
    ae7a:	a904      	add	r1, sp, #16
{
    ae7c:	4616      	mov	r6, r2
    ae7e:	461f      	mov	r7, r3
		settings_name_next(name, &next);
    ae80:	f01b f9e0 	bl	26244 <settings_name_next>
		if (!name) {
    ae84:	b974      	cbnz	r4, aea4 <ccc_set+0x34>
			BT_ERR("Insufficient number of arguments");
    ae86:	4b32      	ldr	r3, [pc, #200]	; (af50 <ccc_set+0xe0>)
    ae88:	9316      	str	r3, [sp, #88]	; 0x58
    ae8a:	2302      	movs	r3, #2
    ae8c:	930c      	str	r3, [sp, #48]	; 0x30
    ae8e:	9315      	str	r3, [sp, #84]	; 0x54
    ae90:	aa15      	add	r2, sp, #84	; 0x54
    ae92:	f44f 5182 	mov.w	r1, #4160	; 0x1040
				BT_ERR("Invalid local identity %lu", next_id);
    ae96:	482f      	ldr	r0, [pc, #188]	; (af54 <ccc_set+0xe4>)
    ae98:	f01e f845 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -EINVAL;
    ae9c:	f06f 0415 	mvn.w	r4, #21
			return -EINVAL;
    aea0:	4625      	mov	r5, r4
    aea2:	e04d      	b.n	af40 <ccc_set+0xd0>
		} else if (!next) {
    aea4:	9804      	ldr	r0, [sp, #16]
    aea6:	b9b0      	cbnz	r0, aed6 <ccc_set+0x66>
		err = bt_settings_decode_key(name, &addr);
    aea8:	f10d 0a18 	add.w	sl, sp, #24
			load.addr_with_id.id = BT_ID_DEFAULT;
    aeac:	f04f 0900 	mov.w	r9, #0
		err = bt_settings_decode_key(name, &addr);
    aeb0:	4651      	mov	r1, sl
    aeb2:	4620      	mov	r0, r4
			load.addr_with_id.id = BT_ID_DEFAULT;
    aeb4:	f88d 9024 	strb.w	r9, [sp, #36]	; 0x24
		err = bt_settings_decode_key(name, &addr);
    aeb8:	f01c fd51 	bl	2795e <bt_settings_decode_key>
		if (err) {
    aebc:	4605      	mov	r5, r0
    aebe:	b1d0      	cbz	r0, aef6 <ccc_set+0x86>
			BT_ERR("Unable to decode address %s", log_strdup(name));
    aec0:	4b25      	ldr	r3, [pc, #148]	; (af58 <ccc_set+0xe8>)
    aec2:	4924      	ldr	r1, [pc, #144]	; (af54 <ccc_set+0xe4>)
    aec4:	9402      	str	r4, [sp, #8]
    aec6:	e9cd 9300 	strd	r9, r3, [sp]
    aeca:	2201      	movs	r2, #1
    aecc:	464b      	mov	r3, r9
    aece:	4648      	mov	r0, r9
    aed0:	f7ff fa90 	bl	a3f4 <z_log_msg2_runtime_create.constprop.0>
    aed4:	e7e2      	b.n	ae9c <ccc_set+0x2c>
			unsigned long next_id = strtoul(next, NULL, 10);
    aed6:	220a      	movs	r2, #10
    aed8:	2100      	movs	r1, #0
    aeda:	f01c fc08 	bl	276ee <strtoul>
			if (next_id >= CONFIG_BT_ID_MAX) {
    aede:	2800      	cmp	r0, #0
    aee0:	d0e2      	beq.n	aea8 <ccc_set+0x38>
				BT_ERR("Invalid local identity %lu", next_id);
    aee2:	4b1e      	ldr	r3, [pc, #120]	; (af5c <ccc_set+0xec>)
    aee4:	e9cd 3016 	strd	r3, r0, [sp, #88]	; 0x58
    aee8:	2303      	movs	r3, #3
    aeea:	930c      	str	r3, [sp, #48]	; 0x30
    aeec:	9315      	str	r3, [sp, #84]	; 0x54
    aeee:	aa15      	add	r2, sp, #84	; 0x54
    aef0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    aef4:	e7cf      	b.n	ae96 <ccc_set+0x26>
		load.addr_with_id.addr = &addr;
    aef6:	f8cd a020 	str.w	sl, [sp, #32]
		if (len_rd) {
    aefa:	f1b8 0f00 	cmp.w	r8, #0
    aefe:	d023      	beq.n	af48 <ccc_set+0xd8>
			len = read_cb(cb_arg, ccc_store, sizeof(ccc_store));
    af00:	f10d 0848 	add.w	r8, sp, #72	; 0x48
    af04:	22c0      	movs	r2, #192	; 0xc0
    af06:	4641      	mov	r1, r8
    af08:	4638      	mov	r0, r7
    af0a:	47b0      	blx	r6
			if (len < 0) {
    af0c:	1e04      	subs	r4, r0, #0
    af0e:	da0c      	bge.n	af2a <ccc_set+0xba>
				BT_ERR("Failed to decode value (err %zd)", len);
    af10:	4b13      	ldr	r3, [pc, #76]	; (af60 <ccc_set+0xf0>)
    af12:	4810      	ldr	r0, [pc, #64]	; (af54 <ccc_set+0xe4>)
    af14:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    af18:	aa0f      	add	r2, sp, #60	; 0x3c
    af1a:	2303      	movs	r3, #3
    af1c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    af20:	9305      	str	r3, [sp, #20]
    af22:	930f      	str	r3, [sp, #60]	; 0x3c
    af24:	f01d ffff 	bl	28f26 <z_log_msg2_static_create.constprop.0>
				return len;
    af28:	e7ba      	b.n	aea0 <ccc_set+0x30>
			load.count = len / sizeof(*ccc_store);
    af2a:	08a4      	lsrs	r4, r4, #2
			load.entry = ccc_store;
    af2c:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			load.count = len / sizeof(*ccc_store);
    af30:	940b      	str	r4, [sp, #44]	; 0x2c
		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &load);
    af32:	4a0c      	ldr	r2, [pc, #48]	; (af64 <ccc_set+0xf4>)
    af34:	ab08      	add	r3, sp, #32
    af36:	f64f 71ff 	movw	r1, #65535	; 0xffff
    af3a:	2001      	movs	r0, #1
    af3c:	f01e f959 	bl	291f2 <bt_gatt_foreach_attr>
}
    af40:	4628      	mov	r0, r5
    af42:	b042      	add	sp, #264	; 0x108
    af44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			load.count = 0;
    af48:	e9cd 000a 	strd	r0, r0, [sp, #40]	; 0x28
    af4c:	e7f1      	b.n	af32 <ccc_set+0xc2>
    af4e:	bf00      	nop
    af50:	0002f4d6 	.word	0x0002f4d6
    af54:	0002daa4 	.word	0x0002daa4
    af58:	00030522 	.word	0x00030522
    af5c:	0003053e 	.word	0x0003053e
    af60:	00030501 	.word	0x00030501
    af64:	0000a671 	.word	0x0000a671

0000af68 <ccc_set_direct>:
{
    af68:	b570      	push	{r4, r5, r6, lr}
    af6a:	b088      	sub	sp, #32
    af6c:	460c      	mov	r4, r1
    af6e:	4615      	mov	r5, r2
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    af70:	490e      	ldr	r1, [pc, #56]	; (afac <ccc_set_direct+0x44>)
    af72:	980c      	ldr	r0, [sp, #48]	; 0x30
    af74:	466a      	mov	r2, sp
{
    af76:	461e      	mov	r6, r3
		if (!settings_name_steq((const char *)param, "bt/ccc", &name)) {
    af78:	f01b f941 	bl	261fe <settings_name_steq>
    af7c:	b970      	cbnz	r0, af9c <ccc_set_direct+0x34>
			BT_ERR("Invalid key");
    af7e:	4b0c      	ldr	r3, [pc, #48]	; (afb0 <ccc_set_direct+0x48>)
    af80:	480c      	ldr	r0, [pc, #48]	; (afb4 <ccc_set_direct+0x4c>)
    af82:	9306      	str	r3, [sp, #24]
    af84:	aa05      	add	r2, sp, #20
    af86:	2302      	movs	r3, #2
    af88:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    af8c:	9301      	str	r3, [sp, #4]
    af8e:	9305      	str	r3, [sp, #20]
    af90:	f01d ffc9 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			return -EINVAL;
    af94:	f06f 0015 	mvn.w	r0, #21
}
    af98:	b008      	add	sp, #32
    af9a:	bd70      	pop	{r4, r5, r6, pc}
		return ccc_set(name, len, read_cb, cb_arg);
    af9c:	9800      	ldr	r0, [sp, #0]
    af9e:	4633      	mov	r3, r6
    afa0:	462a      	mov	r2, r5
    afa2:	4621      	mov	r1, r4
    afa4:	f7ff ff64 	bl	ae70 <ccc_set>
    afa8:	e7f6      	b.n	af98 <ccc_set_direct+0x30>
    afaa:	bf00      	nop
    afac:	00030623 	.word	0x00030623
    afb0:	0003062a 	.word	0x0003062a
    afb4:	0002daa4 	.word	0x0002daa4

0000afb8 <gatt_indicate>:
{
    afb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    afbc:	4615      	mov	r5, r2
    afbe:	b088      	sub	sp, #32
    afc0:	4689      	mov	r9, r1
	if (bt_gatt_check_perm(conn, params->attr,
    afc2:	2214      	movs	r2, #20
    afc4:	6869      	ldr	r1, [r5, #4]
{
    afc6:	4680      	mov	r8, r0
	if (bt_gatt_check_perm(conn, params->attr,
    afc8:	f01e f920 	bl	2920c <bt_gatt_check_perm>
    afcc:	b180      	cbz	r0, aff0 <gatt_indicate+0x38>
		BT_WARN("Link is not encrypted");
    afce:	4b2a      	ldr	r3, [pc, #168]	; (b078 <gatt_indicate+0xc0>)
    afd0:	9306      	str	r3, [sp, #24]
    afd2:	482a      	ldr	r0, [pc, #168]	; (b07c <gatt_indicate+0xc4>)
    afd4:	2302      	movs	r3, #2
    afd6:	aa05      	add	r2, sp, #20
    afd8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return -EPERM;
    afdc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		BT_WARN("Link is not encrypted");
    afe0:	9301      	str	r3, [sp, #4]
    afe2:	9305      	str	r3, [sp, #20]
    afe4:	f01d ff9f 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    afe8:	4628      	mov	r0, r5
    afea:	b008      	add	sp, #32
    afec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    aff0:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
    aff4:	2100      	movs	r1, #0
	len = sizeof(*ind) + params->len;
    aff6:	8aae      	ldrh	r6, [r5, #20]
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    aff8:	f7fe ff20 	bl	9e3c <bt_att_req_alloc>
	len = sizeof(*ind) + params->len;
    affc:	3602      	adds	r6, #2
	if (!req) {
    affe:	4604      	mov	r4, r0
    b000:	b910      	cbnz	r0, b008 <gatt_indicate+0x50>
		return -ENOMEM;
    b002:	f06f 050b 	mvn.w	r5, #11
    b006:	e7ef      	b.n	afe8 <gatt_indicate+0x30>
	req->func = func;
    b008:	4b1d      	ldr	r3, [pc, #116]	; (b080 <gatt_indicate+0xc8>)
    b00a:	6043      	str	r3, [r0, #4]
	req->user_data = params;
    b00c:	60c5      	str	r5, [r0, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
    b00e:	4632      	mov	r2, r6
    b010:	211d      	movs	r1, #29
    b012:	4640      	mov	r0, r8
    b014:	f7fe fcc4 	bl	99a0 <bt_att_create_pdu>
	if (!buf) {
    b018:	4606      	mov	r6, r0
    b01a:	b970      	cbnz	r0, b03a <gatt_indicate+0x82>
		BT_WARN("No buffer available to send indication");
    b01c:	4b19      	ldr	r3, [pc, #100]	; (b084 <gatt_indicate+0xcc>)
    b01e:	9306      	str	r3, [sp, #24]
    b020:	4816      	ldr	r0, [pc, #88]	; (b07c <gatt_indicate+0xc4>)
    b022:	2302      	movs	r3, #2
    b024:	aa05      	add	r2, sp, #20
    b026:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    b02a:	9301      	str	r3, [sp, #4]
    b02c:	9305      	str	r3, [sp, #20]
    b02e:	f01d ff7a 	bl	28f26 <z_log_msg2_static_create.constprop.0>
		bt_att_req_free(req);
    b032:	4620      	mov	r0, r4
    b034:	f7fe ff24 	bl	9e80 <bt_att_req_free>
    b038:	e7e3      	b.n	b002 <gatt_indicate+0x4a>
	return net_buf_simple_add(&buf->b, len);
    b03a:	f100 0a08 	add.w	sl, r0, #8
    b03e:	2102      	movs	r1, #2
    b040:	4650      	mov	r0, sl
    b042:	f020 fe7b 	bl	2bd3c <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
    b046:	4607      	mov	r7, r0
    b048:	8aa9      	ldrh	r1, [r5, #20]
    b04a:	f827 9b02 	strh.w	r9, [r7], #2
    b04e:	4650      	mov	r0, sl
    b050:	f020 fe74 	bl	2bd3c <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
    b054:	8aaa      	ldrh	r2, [r5, #20]
    b056:	6929      	ldr	r1, [r5, #16]
    b058:	4638      	mov	r0, r7
    b05a:	f01c fc09 	bl	27870 <memcpy>
	req->buf = buf;
    b05e:	60a6      	str	r6, [r4, #8]
	err = bt_att_req_send(conn, req);
    b060:	4621      	mov	r1, r4
    b062:	4640      	mov	r0, r8
    b064:	f01d fe4c 	bl	28d00 <bt_att_req_send>
	if (err) {
    b068:	4605      	mov	r5, r0
    b06a:	2800      	cmp	r0, #0
    b06c:	d0bc      	beq.n	afe8 <gatt_indicate+0x30>
		bt_att_req_free(req);
    b06e:	4620      	mov	r0, r4
    b070:	f7fe ff06 	bl	9e80 <bt_att_req_free>
    b074:	e7b8      	b.n	afe8 <gatt_indicate+0x30>
    b076:	bf00      	nop
    b078:	00030636 	.word	0x00030636
    b07c:	0002daa4 	.word	0x0002daa4
    b080:	00028d45 	.word	0x00028d45
    b084:	0003064c 	.word	0x0003064c

0000b088 <bt_gatt_indicate>:
{
    b088:	b530      	push	{r4, r5, lr}
    b08a:	4604      	mov	r4, r0
    b08c:	b08b      	sub	sp, #44	; 0x2c
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    b08e:	4837      	ldr	r0, [pc, #220]	; (b16c <bt_gatt_indicate+0xe4>)
    b090:	f01d fe71 	bl	28d76 <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b094:	0782      	lsls	r2, r0, #30
{
    b096:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b098:	d561      	bpl.n	b15e <bt_gatt_indicate+0xd6>
	if (conn && conn->state != BT_CONN_CONNECTED) {
    b09a:	b114      	cbz	r4, b0a2 <bt_gatt_indicate+0x1a>
    b09c:	7aa3      	ldrb	r3, [r4, #10]
    b09e:	2b07      	cmp	r3, #7
    b0a0:	d160      	bne.n	b164 <bt_gatt_indicate+0xdc>
	data.attr = params->attr;
    b0a2:	6868      	ldr	r0, [r5, #4]
    b0a4:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
    b0a6:	f7ff fcd9 	bl	aa5c <bt_gatt_attr_get_handle>
	if (params->uuid) {
    b0aa:	682a      	ldr	r2, [r5, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
    b0ac:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
    b0b0:	b33a      	cbz	r2, b102 <bt_gatt_indicate+0x7a>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b0b2:	a905      	add	r1, sp, #20
    b0b4:	9102      	str	r1, [sp, #8]
    b0b6:	492e      	ldr	r1, [pc, #184]	; (b170 <bt_gatt_indicate+0xe8>)
    b0b8:	9101      	str	r1, [sp, #4]
    b0ba:	2101      	movs	r1, #1
	found->attr = NULL;
    b0bc:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b0be:	9100      	str	r1, [sp, #0]
    b0c0:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
    b0c4:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b0c6:	f7ff fcf9 	bl	aabc <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
    b0ca:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
    b0cc:	b91b      	cbnz	r3, b0d6 <bt_gatt_indicate+0x4e>
			return -ENOENT;
    b0ce:	f06f 0001 	mvn.w	r0, #1
}
    b0d2:	b00b      	add	sp, #44	; 0x2c
    b0d4:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
    b0d6:	606b      	str	r3, [r5, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
    b0d8:	9b05      	ldr	r3, [sp, #20]
    b0da:	6818      	ldr	r0, [r3, #0]
    b0dc:	2300      	movs	r3, #0
    b0de:	f88d 3010 	strb.w	r3, [sp, #16]
    b0e2:	a904      	add	r1, sp, #16
    b0e4:	f642 0303 	movw	r3, #10243	; 0x2803
    b0e8:	f8ad 3012 	strh.w	r3, [sp, #18]
    b0ec:	f01c fe0d 	bl	27d0a <bt_uuid_cmp>
    b0f0:	b970      	cbnz	r0, b110 <bt_gatt_indicate+0x88>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
    b0f2:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    b0f4:	68c3      	ldr	r3, [r0, #12]
    b0f6:	799b      	ldrb	r3, [r3, #6]
    b0f8:	069b      	lsls	r3, r3, #26
    b0fa:	d405      	bmi.n	b108 <bt_gatt_indicate+0x80>
			return -EINVAL;
    b0fc:	f06f 0015 	mvn.w	r0, #21
    b100:	e7e7      	b.n	b0d2 <bt_gatt_indicate+0x4a>
		if (!data.handle) {
    b102:	2800      	cmp	r0, #0
    b104:	d1e8      	bne.n	b0d8 <bt_gatt_indicate+0x50>
    b106:	e7e2      	b.n	b0ce <bt_gatt_indicate+0x46>
		data.handle = bt_gatt_attr_value_handle(data.attr);
    b108:	f01e f825 	bl	29156 <bt_gatt_attr_value_handle>
    b10c:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_indicate(conn, data.handle, params);
    b110:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
    b114:	b13c      	cbz	r4, b126 <bt_gatt_indicate+0x9e>
		params->_ref = 1;
    b116:	2301      	movs	r3, #1
		return gatt_indicate(conn, data.handle, params);
    b118:	4601      	mov	r1, r0
		params->_ref = 1;
    b11a:	75ab      	strb	r3, [r5, #22]
		return gatt_indicate(conn, data.handle, params);
    b11c:	462a      	mov	r2, r5
    b11e:	4620      	mov	r0, r4
    b120:	f7ff ff4a 	bl	afb8 <gatt_indicate>
    b124:	e7d5      	b.n	b0d2 <bt_gatt_indicate+0x4a>
	data.err = -ENOTCONN;
    b126:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    b12a:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    b12c:	2302      	movs	r3, #2
    b12e:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b132:	f642 1302 	movw	r3, #10498	; 0x2902
    b136:	f8ad 3012 	strh.w	r3, [sp, #18]
    b13a:	ab05      	add	r3, sp, #20
    b13c:	9302      	str	r3, [sp, #8]
    b13e:	4b0d      	ldr	r3, [pc, #52]	; (b174 <bt_gatt_indicate+0xec>)
    b140:	9301      	str	r3, [sp, #4]
    b142:	2301      	movs	r3, #1
    b144:	9300      	str	r3, [sp, #0]
	params->_ref = 0;
    b146:	75ac      	strb	r4, [r5, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b148:	4623      	mov	r3, r4
    b14a:	aa04      	add	r2, sp, #16
    b14c:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
    b150:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b152:	f88d 4010 	strb.w	r4, [sp, #16]
    b156:	f7ff fcb1 	bl	aabc <bt_gatt_foreach_attr_type>
	return data.err;
    b15a:	9807      	ldr	r0, [sp, #28]
    b15c:	e7b9      	b.n	b0d2 <bt_gatt_indicate+0x4a>
		return -EAGAIN;
    b15e:	f06f 000a 	mvn.w	r0, #10
    b162:	e7b6      	b.n	b0d2 <bt_gatt_indicate+0x4a>
		return -ENOTCONN;
    b164:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    b168:	e7b3      	b.n	b0d2 <bt_gatt_indicate+0x4a>
    b16a:	bf00      	nop
    b16c:	2000014c 	.word	0x2000014c
    b170:	00028d6b 	.word	0x00028d6b
    b174:	0000b369 	.word	0x0000b369

0000b178 <sc_process>:
{
    b178:	b573      	push	{r0, r1, r4, r5, r6, lr}
	sc_range[0] = sys_cpu_to_le16(sc->start);
    b17a:	f830 3c08 	ldrh.w	r3, [r0, #-8]
    b17e:	f8ad 3004 	strh.w	r3, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    b182:	f100 0530 	add.w	r5, r0, #48	; 0x30
{
    b186:	4604      	mov	r4, r0
	sc_range[1] = sys_cpu_to_le16(sc->end);
    b188:	f830 3c06 	ldrh.w	r3, [r0, #-6]
    b18c:	f8ad 3006 	strh.w	r3, [sp, #6]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    b190:	f1a0 0620 	sub.w	r6, r0, #32
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    b194:	f06f 0101 	mvn.w	r1, #1
    b198:	4628      	mov	r0, r5
    b19a:	f01d fe90 	bl	28ebe <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
    b19e:	4b0d      	ldr	r3, [pc, #52]	; (b1d4 <sc_process+0x5c>)
    b1a0:	f844 3c1c 	str.w	r3, [r4, #-28]
	sc->params.func = sc_indicate_rsp;
    b1a4:	4b0c      	ldr	r3, [pc, #48]	; (b1d8 <sc_process+0x60>)
    b1a6:	f844 3c18 	str.w	r3, [r4, #-24]
	sc->params.data = &sc_range[0];
    b1aa:	ab01      	add	r3, sp, #4
	sc->start = 0U;
    b1ac:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
    b1ae:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.len = sizeof(sc_range);
    b1b2:	2304      	movs	r3, #4
	sc->start = 0U;
    b1b4:	f824 0c08 	strh.w	r0, [r4, #-8]
	sc->end = 0U;
    b1b8:	f824 0c06 	strh.w	r0, [r4, #-6]
	sc->params.len = sizeof(sc_range);
    b1bc:	f824 3c0c 	strh.w	r3, [r4, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    b1c0:	4631      	mov	r1, r6
    b1c2:	f7ff ff61 	bl	b088 <bt_gatt_indicate>
    b1c6:	b918      	cbnz	r0, b1d0 <sc_process+0x58>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    b1c8:	2102      	movs	r1, #2
    b1ca:	4628      	mov	r0, r5
    b1cc:	f01d fe2e 	bl	28e2c <atomic_or>
}
    b1d0:	b002      	add	sp, #8
    b1d2:	bd70      	pop	{r4, r5, r6, pc}
    b1d4:	0002e2dc 	.word	0x0002e2dc
    b1d8:	0000a971 	.word	0x0000a971

0000b1dc <gatt_notify>:
{
    b1dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b1e0:	4614      	mov	r4, r2
    b1e2:	b089      	sub	sp, #36	; 0x24
    b1e4:	4688      	mov	r8, r1
	if (bt_gatt_check_perm(conn, params->attr,
    b1e6:	2214      	movs	r2, #20
    b1e8:	6861      	ldr	r1, [r4, #4]
{
    b1ea:	4607      	mov	r7, r0
	if (bt_gatt_check_perm(conn, params->attr,
    b1ec:	f01e f80e 	bl	2920c <bt_gatt_check_perm>
    b1f0:	b178      	cbz	r0, b212 <gatt_notify+0x36>
		BT_WARN("Link is not encrypted");
    b1f2:	4b20      	ldr	r3, [pc, #128]	; (b274 <gatt_notify+0x98>)
    b1f4:	4820      	ldr	r0, [pc, #128]	; (b278 <gatt_notify+0x9c>)
    b1f6:	9306      	str	r3, [sp, #24]
    b1f8:	aa05      	add	r2, sp, #20
    b1fa:	2302      	movs	r3, #2
    b1fc:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    b200:	9301      	str	r3, [sp, #4]
    b202:	9305      	str	r3, [sp, #20]
    b204:	f01d fe8f 	bl	28f26 <z_log_msg2_static_create.constprop.0>
		return -EPERM;
    b208:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    b20c:	b009      	add	sp, #36	; 0x24
    b20e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				sizeof(*nfy) + params->len);
    b212:	89a2      	ldrh	r2, [r4, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    b214:	211b      	movs	r1, #27
    b216:	3202      	adds	r2, #2
    b218:	4638      	mov	r0, r7
    b21a:	f7fe fbc1 	bl	99a0 <bt_att_create_pdu>
	if (!buf) {
    b21e:	4605      	mov	r5, r0
    b220:	b968      	cbnz	r0, b23e <gatt_notify+0x62>
		BT_WARN("No buffer available to send notification");
    b222:	4b16      	ldr	r3, [pc, #88]	; (b27c <gatt_notify+0xa0>)
    b224:	4814      	ldr	r0, [pc, #80]	; (b278 <gatt_notify+0x9c>)
    b226:	9306      	str	r3, [sp, #24]
    b228:	aa05      	add	r2, sp, #20
    b22a:	2302      	movs	r3, #2
    b22c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    b230:	9301      	str	r3, [sp, #4]
    b232:	9305      	str	r3, [sp, #20]
    b234:	f01d fe77 	bl	28f26 <z_log_msg2_static_create.constprop.0>
		return -ENOMEM;
    b238:	f06f 000b 	mvn.w	r0, #11
    b23c:	e7e6      	b.n	b20c <gatt_notify+0x30>
    b23e:	f100 0908 	add.w	r9, r0, #8
    b242:	2102      	movs	r1, #2
    b244:	4648      	mov	r0, r9
    b246:	f020 fd79 	bl	2bd3c <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
    b24a:	4606      	mov	r6, r0
    b24c:	89a1      	ldrh	r1, [r4, #12]
    b24e:	f826 8b02 	strh.w	r8, [r6], #2
    b252:	4648      	mov	r0, r9
    b254:	f020 fd72 	bl	2bd3c <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
    b258:	89a2      	ldrh	r2, [r4, #12]
    b25a:	68a1      	ldr	r1, [r4, #8]
    b25c:	4630      	mov	r0, r6
    b25e:	f01c fb07 	bl	27870 <memcpy>
	return bt_att_send(conn, buf, params->func, params->user_data);
    b262:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    b266:	4629      	mov	r1, r5
    b268:	4638      	mov	r0, r7
}
    b26a:	b009      	add	sp, #36	; 0x24
    b26c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
    b270:	f01d bcff 	b.w	28c72 <bt_att_send>
    b274:	00030636 	.word	0x00030636
    b278:	0002daa4 	.word	0x0002daa4
    b27c:	00030673 	.word	0x00030673

0000b280 <bt_gatt_notify_cb>:
{
    b280:	b530      	push	{r4, r5, lr}
    b282:	4604      	mov	r4, r0
    b284:	b08b      	sub	sp, #44	; 0x2c
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    b286:	4835      	ldr	r0, [pc, #212]	; (b35c <bt_gatt_notify_cb+0xdc>)
    b288:	f01d fd75 	bl	28d76 <atomic_get>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b28c:	0782      	lsls	r2, r0, #30
{
    b28e:	460d      	mov	r5, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    b290:	d55d      	bpl.n	b34e <bt_gatt_notify_cb+0xce>
	if (conn && conn->state != BT_CONN_CONNECTED) {
    b292:	b114      	cbz	r4, b29a <bt_gatt_notify_cb+0x1a>
    b294:	7aa3      	ldrb	r3, [r4, #10]
    b296:	2b07      	cmp	r3, #7
    b298:	d15c      	bne.n	b354 <bt_gatt_notify_cb+0xd4>
	data.attr = params->attr;
    b29a:	6868      	ldr	r0, [r5, #4]
    b29c:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
    b29e:	f7ff fbdd 	bl	aa5c <bt_gatt_attr_get_handle>
	if (params->uuid) {
    b2a2:	682a      	ldr	r2, [r5, #0]
	data.handle = bt_gatt_attr_get_handle(data.attr);
    b2a4:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
    b2a8:	b33a      	cbz	r2, b2fa <bt_gatt_notify_cb+0x7a>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b2aa:	a905      	add	r1, sp, #20
    b2ac:	9102      	str	r1, [sp, #8]
    b2ae:	492c      	ldr	r1, [pc, #176]	; (b360 <bt_gatt_notify_cb+0xe0>)
    b2b0:	9101      	str	r1, [sp, #4]
    b2b2:	2101      	movs	r1, #1
	found->attr = NULL;
    b2b4:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b2b6:	9100      	str	r1, [sp, #0]
    b2b8:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
    b2bc:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    b2be:	f7ff fbfd 	bl	aabc <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
    b2c2:	9b05      	ldr	r3, [sp, #20]
		if (!gatt_find_by_uuid(&data, params->uuid)) {
    b2c4:	b91b      	cbnz	r3, b2ce <bt_gatt_notify_cb+0x4e>
			return -ENOENT;
    b2c6:	f06f 0001 	mvn.w	r0, #1
}
    b2ca:	b00b      	add	sp, #44	; 0x2c
    b2cc:	bd30      	pop	{r4, r5, pc}
		params->attr = data.attr;
    b2ce:	606b      	str	r3, [r5, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
    b2d0:	9b05      	ldr	r3, [sp, #20]
    b2d2:	6818      	ldr	r0, [r3, #0]
    b2d4:	2300      	movs	r3, #0
    b2d6:	f88d 3010 	strb.w	r3, [sp, #16]
    b2da:	a904      	add	r1, sp, #16
    b2dc:	f642 0303 	movw	r3, #10243	; 0x2803
    b2e0:	f8ad 3012 	strh.w	r3, [sp, #18]
    b2e4:	f01c fd11 	bl	27d0a <bt_uuid_cmp>
    b2e8:	b970      	cbnz	r0, b308 <bt_gatt_notify_cb+0x88>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
    b2ea:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
    b2ec:	68c3      	ldr	r3, [r0, #12]
    b2ee:	799b      	ldrb	r3, [r3, #6]
    b2f0:	06db      	lsls	r3, r3, #27
    b2f2:	d405      	bmi.n	b300 <bt_gatt_notify_cb+0x80>
			return -EINVAL;
    b2f4:	f06f 0015 	mvn.w	r0, #21
    b2f8:	e7e7      	b.n	b2ca <bt_gatt_notify_cb+0x4a>
		if (!data.handle) {
    b2fa:	2800      	cmp	r0, #0
    b2fc:	d1e8      	bne.n	b2d0 <bt_gatt_notify_cb+0x50>
    b2fe:	e7e2      	b.n	b2c6 <bt_gatt_notify_cb+0x46>
		data.handle = bt_gatt_attr_value_handle(data.attr);
    b300:	f01d ff29 	bl	29156 <bt_gatt_attr_value_handle>
    b304:	f8ad 0018 	strh.w	r0, [sp, #24]
		return gatt_notify(conn, data.handle, params);
    b308:	f8bd 0018 	ldrh.w	r0, [sp, #24]
	if (conn) {
    b30c:	b12c      	cbz	r4, b31a <bt_gatt_notify_cb+0x9a>
		return gatt_notify(conn, data.handle, params);
    b30e:	4601      	mov	r1, r0
    b310:	462a      	mov	r2, r5
    b312:	4620      	mov	r0, r4
    b314:	f7ff ff62 	bl	b1dc <gatt_notify>
    b318:	e7d7      	b.n	b2ca <bt_gatt_notify_cb+0x4a>
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b31a:	f642 1202 	movw	r2, #10498	; 0x2902
    b31e:	f8ad 2012 	strh.w	r2, [sp, #18]
    b322:	aa05      	add	r2, sp, #20
	data.err = -ENOTCONN;
    b324:	f06f 037f 	mvn.w	r3, #127	; 0x7f
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b328:	9202      	str	r2, [sp, #8]
    b32a:	4a0e      	ldr	r2, [pc, #56]	; (b364 <bt_gatt_notify_cb+0xe4>)
	data.err = -ENOTCONN;
    b32c:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
    b32e:	2301      	movs	r3, #1
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b330:	e9cd 3200 	strd	r3, r2, [sp]
	data.type = BT_GATT_CCC_NOTIFY;
    b334:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b338:	aa04      	add	r2, sp, #16
    b33a:	4623      	mov	r3, r4
    b33c:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.nfy_params = params;
    b340:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    b342:	f88d 4010 	strb.w	r4, [sp, #16]
    b346:	f7ff fbb9 	bl	aabc <bt_gatt_foreach_attr_type>
	return data.err;
    b34a:	9807      	ldr	r0, [sp, #28]
    b34c:	e7bd      	b.n	b2ca <bt_gatt_notify_cb+0x4a>
		return -EAGAIN;
    b34e:	f06f 000a 	mvn.w	r0, #10
    b352:	e7ba      	b.n	b2ca <bt_gatt_notify_cb+0x4a>
		return -ENOTCONN;
    b354:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    b358:	e7b7      	b.n	b2ca <bt_gatt_notify_cb+0x4a>
    b35a:	bf00      	nop
    b35c:	2000014c 	.word	0x2000014c
    b360:	00028d6b 	.word	0x00028d6b
    b364:	0000b369 	.word	0x0000b369

0000b368 <notify_cb>:
{
    b368:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    b36a:	4b38      	ldr	r3, [pc, #224]	; (b44c <notify_cb+0xe4>)
{
    b36c:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    b36e:	6882      	ldr	r2, [r0, #8]
    b370:	429a      	cmp	r2, r3
{
    b372:	b089      	sub	sp, #36	; 0x24
    b374:	4606      	mov	r6, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    b376:	d12d      	bne.n	b3d4 <notify_cb+0x6c>
	ccc = attr->user_data;
    b378:	68c7      	ldr	r7, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    b37a:	4b35      	ldr	r3, [pc, #212]	; (b450 <notify_cb+0xe8>)
    b37c:	429f      	cmp	r7, r3
    b37e:	d119      	bne.n	b3b4 <notify_cb+0x4c>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    b380:	4d34      	ldr	r5, [pc, #208]	; (b454 <notify_cb+0xec>)
    b382:	2300      	movs	r3, #0
    b384:	a902      	add	r1, sp, #8
    b386:	1c68      	adds	r0, r5, #1
    b388:	9302      	str	r3, [sp, #8]
    b38a:	f8cd 300b 	str.w	r3, [sp, #11]
    b38e:	f01d fd5c 	bl	28e4a <bt_addr_le_cmp>
    b392:	b178      	cbz	r0, b3b4 <notify_cb+0x4c>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
    b394:	4629      	mov	r1, r5
    b396:	2207      	movs	r2, #7
    b398:	f811 0b01 	ldrb.w	r0, [r1], #1
    b39c:	f7fd fb6c 	bl	8a78 <bt_conn_lookup_state_le>
			if (!conn) {
    b3a0:	b9e0      	cbnz	r0, b3dc <notify_cb+0x74>
				sc = (struct sc_data *)data->ind_params->data;
    b3a2:	6923      	ldr	r3, [r4, #16]
				sc_save(cfg->id, &cfg->peer,
    b3a4:	4629      	mov	r1, r5
				sc = (struct sc_data *)data->ind_params->data;
    b3a6:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
    b3a8:	f811 0b01 	ldrb.w	r0, [r1], #1
    b3ac:	8853      	ldrh	r3, [r2, #2]
    b3ae:	8812      	ldrh	r2, [r2, #0]
    b3b0:	f7fe ff42 	bl	a238 <sc_save>
		if (cfg->value != data->type) {
    b3b4:	893a      	ldrh	r2, [r7, #8]
    b3b6:	89a3      	ldrh	r3, [r4, #12]
    b3b8:	429a      	cmp	r2, r3
    b3ba:	d10b      	bne.n	b3d4 <notify_cb+0x6c>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    b3bc:	4639      	mov	r1, r7
    b3be:	f811 0b01 	ldrb.w	r0, [r1], #1
    b3c2:	f7fd fb17 	bl	89f4 <bt_conn_lookup_addr_le>
		if (!conn) {
    b3c6:	4605      	mov	r5, r0
    b3c8:	b120      	cbz	r0, b3d4 <notify_cb+0x6c>
		if (conn->state != BT_CONN_CONNECTED) {
    b3ca:	7a83      	ldrb	r3, [r0, #10]
    b3cc:	2b07      	cmp	r3, #7
    b3ce:	d008      	beq.n	b3e2 <notify_cb+0x7a>
			bt_conn_unref(conn);
    b3d0:	f01c ff8d 	bl	282ee <bt_conn_unref>
	return BT_GATT_ITER_CONTINUE;
    b3d4:	2701      	movs	r7, #1
}
    b3d6:	4638      	mov	r0, r7
    b3d8:	b009      	add	sp, #36	; 0x24
    b3da:	bdf0      	pop	{r4, r5, r6, r7, pc}
			bt_conn_unref(conn);
    b3dc:	f01c ff87 	bl	282ee <bt_conn_unref>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    b3e0:	e7e8      	b.n	b3b4 <notify_cb+0x4c>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    b3e2:	697b      	ldr	r3, [r7, #20]
    b3e4:	b123      	cbz	r3, b3f0 <notify_cb+0x88>
    b3e6:	4631      	mov	r1, r6
    b3e8:	4798      	blx	r3
    b3ea:	b908      	cbnz	r0, b3f0 <notify_cb+0x88>
			bt_conn_unref(conn);
    b3ec:	4628      	mov	r0, r5
    b3ee:	e7ef      	b.n	b3d0 <notify_cb+0x68>
		if (bt_gatt_check_perm(conn, attr,
    b3f0:	2214      	movs	r2, #20
    b3f2:	4631      	mov	r1, r6
    b3f4:	4628      	mov	r0, r5
    b3f6:	f01d ff09 	bl	2920c <bt_gatt_check_perm>
    b3fa:	4607      	mov	r7, r0
    b3fc:	b158      	cbz	r0, b416 <notify_cb+0xae>
			BT_WARN("Link is not encrypted");
    b3fe:	4b16      	ldr	r3, [pc, #88]	; (b458 <notify_cb+0xf0>)
    b400:	9306      	str	r3, [sp, #24]
    b402:	4816      	ldr	r0, [pc, #88]	; (b45c <notify_cb+0xf4>)
    b404:	2302      	movs	r3, #2
    b406:	aa05      	add	r2, sp, #20
    b408:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    b40c:	9301      	str	r3, [sp, #4]
    b40e:	9305      	str	r3, [sp, #20]
    b410:	f01d fd89 	bl	28f26 <z_log_msg2_static_create.constprop.0>
			continue;
    b414:	e7de      	b.n	b3d4 <notify_cb+0x6c>
		if (data->type == BT_GATT_CCC_INDICATE) {
    b416:	89a3      	ldrh	r3, [r4, #12]
			err = gatt_indicate(conn, data->handle,
    b418:	88a1      	ldrh	r1, [r4, #4]
    b41a:	6922      	ldr	r2, [r4, #16]
		if (data->type == BT_GATT_CCC_INDICATE) {
    b41c:	2b02      	cmp	r3, #2
			err = gatt_indicate(conn, data->handle,
    b41e:	4628      	mov	r0, r5
		if (data->type == BT_GATT_CCC_INDICATE) {
    b420:	d10f      	bne.n	b442 <notify_cb+0xda>
			err = gatt_indicate(conn, data->handle,
    b422:	f7ff fdc9 	bl	afb8 <gatt_indicate>
			if (err == 0) {
    b426:	4606      	mov	r6, r0
    b428:	b918      	cbnz	r0, b432 <notify_cb+0xca>
				data->ind_params->_ref++;
    b42a:	6922      	ldr	r2, [r4, #16]
    b42c:	7d93      	ldrb	r3, [r2, #22]
    b42e:	3301      	adds	r3, #1
    b430:	7593      	strb	r3, [r2, #22]
		bt_conn_unref(conn);
    b432:	4628      	mov	r0, r5
    b434:	f01c ff5b 	bl	282ee <bt_conn_unref>
		if (err < 0) {
    b438:	2e00      	cmp	r6, #0
    b43a:	dbcc      	blt.n	b3d6 <notify_cb+0x6e>
		data->err = 0;
    b43c:	2300      	movs	r3, #0
    b43e:	60a3      	str	r3, [r4, #8]
    b440:	e7c8      	b.n	b3d4 <notify_cb+0x6c>
			err = gatt_notify(conn, data->handle, data->nfy_params);
    b442:	f7ff fecb 	bl	b1dc <gatt_notify>
    b446:	4606      	mov	r6, r0
    b448:	e7f3      	b.n	b432 <notify_cb+0xca>
    b44a:	bf00      	nop
    b44c:	0000a109 	.word	0x0000a109
    b450:	200003f8 	.word	0x200003f8
    b454:	20003890 	.word	0x20003890
    b458:	00030636 	.word	0x00030636
    b45c:	0002daa4 	.word	0x0002daa4

0000b460 <update_ccc>:
{
    b460:	b570      	push	{r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    b462:	4b2f      	ldr	r3, [pc, #188]	; (b520 <update_ccc+0xc0>)
	struct bt_conn *conn = data->conn;
    b464:	6815      	ldr	r5, [r2, #0]
	if (attr->write != bt_gatt_attr_write_ccc) {
    b466:	6882      	ldr	r2, [r0, #8]
    b468:	429a      	cmp	r2, r3
{
    b46a:	b088      	sub	sp, #32
    b46c:	4604      	mov	r4, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    b46e:	d11b      	bne.n	b4a8 <update_ccc+0x48>
	ccc = attr->user_data;
    b470:	68c6      	ldr	r6, [r0, #12]
		if (!cfg->value ||
    b472:	8933      	ldrh	r3, [r6, #8]
    b474:	b1c3      	cbz	r3, b4a8 <update_ccc+0x48>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    b476:	4632      	mov	r2, r6
    b478:	4628      	mov	r0, r5
    b47a:	f812 1b01 	ldrb.w	r1, [r2], #1
    b47e:	f01c ffa1 	bl	283c4 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
    b482:	b188      	cbz	r0, b4a8 <update_ccc+0x48>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    b484:	222a      	movs	r2, #42	; 0x2a
    b486:	4621      	mov	r1, r4
    b488:	4628      	mov	r0, r5
    b48a:	f01d febf 	bl	2920c <bt_gatt_check_perm>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    b48e:	2803      	cmp	r0, #3
    b490:	d10d      	bne.n	b4ae <update_ccc+0x4e>
				BT_WARN("CCC %p not writable", attr);
    b492:	4b24      	ldr	r3, [pc, #144]	; (b524 <update_ccc+0xc4>)
    b494:	9001      	str	r0, [sp, #4]
    b496:	e9cd 3406 	strd	r3, r4, [sp, #24]
    b49a:	9005      	str	r0, [sp, #20]
    b49c:	aa05      	add	r2, sp, #20
    b49e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_ERR("SC restore indication failed");
    b4a2:	4821      	ldr	r0, [pc, #132]	; (b528 <update_ccc+0xc8>)
    b4a4:	f01d fd3f 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    b4a8:	2001      	movs	r0, #1
    b4aa:	b008      	add	sp, #32
    b4ac:	bd70      	pop	{r4, r5, r6, pc}
		gatt_ccc_changed(attr, ccc);
    b4ae:	4631      	mov	r1, r6
    b4b0:	4620      	mov	r0, r4
    b4b2:	f01d fc3d 	bl	28d30 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    b4b6:	4b1d      	ldr	r3, [pc, #116]	; (b52c <update_ccc+0xcc>)
    b4b8:	429e      	cmp	r6, r3
    b4ba:	d1f5      	bne.n	b4a8 <update_ccc+0x48>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
    b4bc:	7a28      	ldrb	r0, [r5, #8]
    b4be:	f105 0188 	add.w	r1, r5, #136	; 0x88
    b4c2:	f7fe fdc5 	bl	a050 <find_sc_cfg>
	if (!cfg) {
    b4c6:	2800      	cmp	r0, #0
    b4c8:	d0ee      	beq.n	b4a8 <update_ccc+0x48>
	if (!(cfg->data.start || cfg->data.end)) {
    b4ca:	8902      	ldrh	r2, [r0, #8]
    b4cc:	8943      	ldrh	r3, [r0, #10]
    b4ce:	ea52 0103 	orrs.w	r1, r2, r3
    b4d2:	d0e9      	beq.n	b4a8 <update_ccc+0x48>
	index = bt_conn_index(conn);
    b4d4:	4628      	mov	r0, r5
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    b4d6:	f8ad 2000 	strh.w	r2, [sp]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    b4da:	f8ad 3002 	strh.w	r3, [sp, #2]
	index = bt_conn_index(conn);
    b4de:	f7fd f9b9 	bl	8854 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    b4e2:	4913      	ldr	r1, [pc, #76]	; (b530 <update_ccc+0xd0>)
    b4e4:	4a13      	ldr	r2, [pc, #76]	; (b534 <update_ccc+0xd4>)
    b4e6:	2318      	movs	r3, #24
    b4e8:	fb03 1300 	mla	r3, r3, r0, r1
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    b4ec:	b200      	sxth	r0, r0
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    b4ee:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    b4f0:	4a11      	ldr	r2, [pc, #68]	; (b538 <update_ccc+0xd8>)
    b4f2:	609a      	str	r2, [r3, #8]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    b4f4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
	sc_restore_params[index].len = sizeof(sc_range);
    b4f8:	2204      	movs	r2, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    b4fa:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
	sc_restore_params[index].data = &sc_range[0];
    b4fe:	f8c3 d010 	str.w	sp, [r3, #16]
	sc_restore_params[index].len = sizeof(sc_range);
    b502:	829a      	strh	r2, [r3, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    b504:	4628      	mov	r0, r5
    b506:	f7ff fdbf 	bl	b088 <bt_gatt_indicate>
    b50a:	2800      	cmp	r0, #0
    b50c:	d0cc      	beq.n	b4a8 <update_ccc+0x48>
		BT_ERR("SC restore indication failed");
    b50e:	4b0b      	ldr	r3, [pc, #44]	; (b53c <update_ccc+0xdc>)
    b510:	9306      	str	r3, [sp, #24]
    b512:	2302      	movs	r3, #2
    b514:	9301      	str	r3, [sp, #4]
    b516:	9305      	str	r3, [sp, #20]
    b518:	aa05      	add	r2, sp, #20
    b51a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    b51e:	e7c0      	b.n	b4a2 <update_ccc+0x42>
    b520:	0000a109 	.word	0x0000a109
    b524:	0003069c 	.word	0x0003069c
    b528:	0002daa4 	.word	0x0002daa4
    b52c:	200003f8 	.word	0x200003f8
    b530:	200026a4 	.word	0x200026a4
    b534:	0002e2dc 	.word	0x0002e2dc
    b538:	00029117 	.word	0x00029117
    b53c:	000306b0 	.word	0x000306b0

0000b540 <bt_gatt_connected>:
{
    b540:	b530      	push	{r4, r5, lr}
    b542:	b08f      	sub	sp, #60	; 0x3c
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b544:	f100 0588 	add.w	r5, r0, #136	; 0x88
{
    b548:	4604      	mov	r4, r0
	data.conn = conn;
    b54a:	9003      	str	r0, [sp, #12]
	data.sec = BT_SECURITY_L1;
    b54c:	2301      	movs	r3, #1
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b54e:	7a00      	ldrb	r0, [r0, #8]
	data.sec = BT_SECURITY_L1;
    b550:	f88d 3010 	strb.w	r3, [sp, #16]
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b554:	4629      	mov	r1, r5
    b556:	f01c fcdb 	bl	27f10 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
    b55a:	b190      	cbz	r0, b582 <bt_gatt_connected+0x42>
		if (conn->id) {
    b55c:	7a22      	ldrb	r2, [r4, #8]
    b55e:	b1ca      	cbz	r2, b594 <bt_gatt_connected+0x54>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    b560:	ac02      	add	r4, sp, #8
    b562:	2104      	movs	r1, #4
    b564:	4620      	mov	r0, r4
    b566:	f019 fd76 	bl	25056 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b56a:	9400      	str	r4, [sp, #0]
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b56c:	4a0a      	ldr	r2, [pc, #40]	; (b598 <bt_gatt_connected+0x58>)
    b56e:	2124      	movs	r1, #36	; 0x24
    b570:	a805      	add	r0, sp, #20
    b572:	462b      	mov	r3, r5
    b574:	f7fa f8ba 	bl	56ec <bt_settings_encode_key>
		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
    b578:	aa05      	add	r2, sp, #20
    b57a:	4908      	ldr	r1, [pc, #32]	; (b59c <bt_gatt_connected+0x5c>)
    b57c:	4610      	mov	r0, r2
    b57e:	f7f8 fb9f 	bl	3cc0 <settings_load_subtree_direct>
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    b582:	4a07      	ldr	r2, [pc, #28]	; (b5a0 <bt_gatt_connected+0x60>)
    b584:	ab03      	add	r3, sp, #12
    b586:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b58a:	2001      	movs	r0, #1
    b58c:	f01d fe31 	bl	291f2 <bt_gatt_foreach_attr>
}
    b590:	b00f      	add	sp, #60	; 0x3c
    b592:	bd30      	pop	{r4, r5, pc}
			bt_settings_encode_key(key, sizeof(key), "ccc",
    b594:	9200      	str	r2, [sp, #0]
    b596:	e7e9      	b.n	b56c <bt_gatt_connected+0x2c>
    b598:	00030626 	.word	0x00030626
    b59c:	0000af69 	.word	0x0000af69
    b5a0:	0000b461 	.word	0x0000b461

0000b5a4 <bt_gatt_att_max_mtu_changed>:
{
    b5a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return list->head;
    b5a6:	4b08      	ldr	r3, [pc, #32]	; (b5c8 <bt_gatt_att_max_mtu_changed+0x24>)
    b5a8:	681c      	ldr	r4, [r3, #0]
    b5aa:	4605      	mov	r5, r0
    b5ac:	460e      	mov	r6, r1
    b5ae:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
    b5b0:	b14c      	cbz	r4, b5c6 <bt_gatt_att_max_mtu_changed+0x22>
		if (cb->att_mtu_updated) {
    b5b2:	f854 3c04 	ldr.w	r3, [r4, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
    b5b6:	3c04      	subs	r4, #4
		if (cb->att_mtu_updated) {
    b5b8:	b11b      	cbz	r3, b5c2 <bt_gatt_att_max_mtu_changed+0x1e>
			cb->att_mtu_updated(conn, tx, rx);
    b5ba:	463a      	mov	r2, r7
    b5bc:	4631      	mov	r1, r6
    b5be:	4628      	mov	r0, r5
    b5c0:	4798      	blx	r3
	return node->next;
    b5c2:	6864      	ldr	r4, [r4, #4]
    b5c4:	e7f4      	b.n	b5b0 <bt_gatt_att_max_mtu_changed+0xc>
}
    b5c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b5c8:	20002680 	.word	0x20002680

0000b5cc <db_hash_read>:
{
    b5cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
    b5ce:	4914      	ldr	r1, [pc, #80]	; (b620 <db_hash_read+0x54>)
{
    b5d0:	f8bd 6018 	ldrh.w	r6, [sp, #24]
    b5d4:	4604      	mov	r4, r0
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
    b5d6:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
{
    b5da:	461f      	mov	r7, r3
    b5dc:	4615      	mov	r5, r2
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
    b5de:	f021 fc26 	bl	2ce2e <k_work_cancel_delayable_sync>
    b5e2:	4810      	ldr	r0, [pc, #64]	; (b624 <db_hash_read+0x58>)
    b5e4:	f01d fbc7 	bl	28d76 <atomic_get>
	if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
    b5e8:	0743      	lsls	r3, r0, #29
    b5ea:	d402      	bmi.n	b5f2 <db_hash_read+0x26>
		db_hash_gen(true);
    b5ec:	2001      	movs	r0, #1
    b5ee:	f7ff fadf 	bl	abb0 <db_hash_gen>
	(void)bt_gatt_change_aware(conn, true);
    b5f2:	2101      	movs	r1, #1
    b5f4:	4620      	mov	r0, r4
    b5f6:	f01d fe2c 	bl	29252 <bt_gatt_change_aware>
	if (offset > value_len) {
    b5fa:	2e10      	cmp	r6, #16
    b5fc:	d80c      	bhi.n	b618 <db_hash_read+0x4c>
	len = MIN(buf_len, value_len - offset);
    b5fe:	f1c6 0410 	rsb	r4, r6, #16
	memcpy(buf, (uint8_t *)value + offset, len);
    b602:	4909      	ldr	r1, [pc, #36]	; (b628 <db_hash_read+0x5c>)
	len = MIN(buf_len, value_len - offset);
    b604:	42bc      	cmp	r4, r7
    b606:	bfa8      	it	ge
    b608:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
    b60a:	4622      	mov	r2, r4
    b60c:	4431      	add	r1, r6
    b60e:	4628      	mov	r0, r5
    b610:	f01c f92e 	bl	27870 <memcpy>
}
    b614:	4620      	mov	r0, r4
    b616:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    b618:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
    b61c:	e7fa      	b.n	b614 <db_hash_read+0x48>
    b61e:	bf00      	nop
    b620:	200018d8 	.word	0x200018d8
    b624:	20001988 	.word	0x20001988
    b628:	20001888 	.word	0x20001888

0000b62c <bt_gatt_store_ccc>:
{
    b62c:	b570      	push	{r4, r5, r6, lr}
    b62e:	b0c6      	sub	sp, #280	; 0x118
	save.count = 0;
    b630:	2300      	movs	r3, #0
{
    b632:	4604      	mov	r4, r0
    b634:	460d      	mov	r5, r1
	save.addr_with_id.addr = addr;
    b636:	9113      	str	r1, [sp, #76]	; 0x4c
	save.addr_with_id.id = id;
    b638:	f88d 0050 	strb.w	r0, [sp, #80]	; 0x50
	save.count = 0;
    b63c:	9345      	str	r3, [sp, #276]	; 0x114
	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_save, &save);
    b63e:	4a18      	ldr	r2, [pc, #96]	; (b6a0 <bt_gatt_store_ccc+0x74>)
    b640:	ab13      	add	r3, sp, #76	; 0x4c
    b642:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b646:	2001      	movs	r0, #1
    b648:	f01d fdd3 	bl	291f2 <bt_gatt_foreach_attr>
	if (id) {
    b64c:	b324      	cbz	r4, b698 <bt_gatt_store_ccc+0x6c>
		u8_to_dec(id_str, sizeof(id_str), id);
    b64e:	ae04      	add	r6, sp, #16
    b650:	4622      	mov	r2, r4
    b652:	2104      	movs	r1, #4
    b654:	4630      	mov	r0, r6
    b656:	f019 fcfe 	bl	25056 <u8_to_dec>
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, id_str);
    b65a:	9600      	str	r6, [sp, #0]
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
    b65c:	4a11      	ldr	r2, [pc, #68]	; (b6a4 <bt_gatt_store_ccc+0x78>)
    b65e:	462b      	mov	r3, r5
    b660:	2124      	movs	r1, #36	; 0x24
    b662:	a80a      	add	r0, sp, #40	; 0x28
    b664:	f7fa f842 	bl	56ec <bt_settings_encode_key>
	if (save.count) {
    b668:	9a45      	ldr	r2, [sp, #276]	; 0x114
    b66a:	b1ba      	cbz	r2, b69c <bt_gatt_store_ccc+0x70>
		len = save.count * sizeof(*save.store);
    b66c:	0092      	lsls	r2, r2, #2
		str = (char *)save.store;
    b66e:	a915      	add	r1, sp, #84	; 0x54
	err = settings_save_one(key, str, len);
    b670:	a80a      	add	r0, sp, #40	; 0x28
    b672:	f7f8 fac5 	bl	3c00 <settings_save_one>
	if (err) {
    b676:	4604      	mov	r4, r0
    b678:	b158      	cbz	r0, b692 <bt_gatt_store_ccc+0x66>
		BT_ERR("Failed to store CCCs (err %d)", err);
    b67a:	4b0b      	ldr	r3, [pc, #44]	; (b6a8 <bt_gatt_store_ccc+0x7c>)
    b67c:	aa07      	add	r2, sp, #28
    b67e:	e9cd 3008 	strd	r3, r0, [sp, #32]
    b682:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    b686:	2303      	movs	r3, #3
    b688:	4808      	ldr	r0, [pc, #32]	; (b6ac <bt_gatt_store_ccc+0x80>)
    b68a:	9303      	str	r3, [sp, #12]
    b68c:	9307      	str	r3, [sp, #28]
    b68e:	f01d fc4a 	bl	28f26 <z_log_msg2_static_create.constprop.0>
}
    b692:	4620      	mov	r0, r4
    b694:	b046      	add	sp, #280	; 0x118
    b696:	bd70      	pop	{r4, r5, r6, pc}
		bt_settings_encode_key(key, sizeof(key), "ccc", addr, NULL);
    b698:	9400      	str	r4, [sp, #0]
    b69a:	e7df      	b.n	b65c <bt_gatt_store_ccc+0x30>
		str = NULL;
    b69c:	4611      	mov	r1, r2
    b69e:	e7e7      	b.n	b670 <bt_gatt_store_ccc+0x44>
    b6a0:	0000a6fd 	.word	0x0000a6fd
    b6a4:	00030626 	.word	0x00030626
    b6a8:	000306cd 	.word	0x000306cd
    b6ac:	0002daa4 	.word	0x0002daa4

0000b6b0 <bt_gatt_service_unregister>:
{
    b6b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b6b4:	b085      	sub	sp, #20
    b6b6:	4604      	mov	r4, r0
	k_sched_lock();
    b6b8:	f018 feb2 	bl	24420 <k_sched_lock>
	return list->head;
    b6bc:	4a3d      	ldr	r2, [pc, #244]	; (b7b4 <bt_gatt_service_unregister+0x104>)
    b6be:	6813      	ldr	r3, [r2, #0]
	if (!sys_slist_find_and_remove(&db, &svc->node)) {
    b6c0:	f104 0008 	add.w	r0, r4, #8
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b6c4:	2100      	movs	r1, #0
    b6c6:	b93b      	cbnz	r3, b6d8 <bt_gatt_service_unregister+0x28>
		k_sched_unlock();
    b6c8:	f019 f878 	bl	247bc <k_sched_unlock>
		return err;
    b6cc:	f06f 0501 	mvn.w	r5, #1
}
    b6d0:	4628      	mov	r0, r5
    b6d2:	b005      	add	sp, #20
    b6d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6d8:	4298      	cmp	r0, r3
    b6da:	d11f      	bne.n	b71c <bt_gatt_service_unregister+0x6c>
	return node->next;
    b6dc:	68a3      	ldr	r3, [r4, #8]
	return list->tail;
    b6de:	6855      	ldr	r5, [r2, #4]
Z_GENLIST_REMOVE(slist, snode)
    b6e0:	b9b9      	cbnz	r1, b712 <bt_gatt_service_unregister+0x62>
    b6e2:	42a8      	cmp	r0, r5
	list->head = node;
    b6e4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    b6e6:	d100      	bne.n	b6ea <bt_gatt_service_unregister+0x3a>
	list->tail = node;
    b6e8:	6053      	str	r3, [r2, #4]
	parent->next = child;
    b6ea:	2500      	movs	r5, #0
		if (attr->write == bt_gatt_attr_write_ccc) {
    b6ec:	f8df b0c8 	ldr.w	fp, [pc, #200]	; b7b8 <bt_gatt_service_unregister+0x108>
    b6f0:	60a5      	str	r5, [r4, #8]
		struct bt_gatt_attr *attr = &svc->attrs[i];
    b6f2:	f04f 0a14 	mov.w	sl, #20
	ccc->value = 0;
    b6f6:	46a9      	mov	r9, r5
	for (uint16_t i = 0; i < svc->attr_count; i++) {
    b6f8:	6863      	ldr	r3, [r4, #4]
    b6fa:	b2aa      	uxth	r2, r5
    b6fc:	4293      	cmp	r3, r2
    b6fe:	d810      	bhi.n	b722 <bt_gatt_service_unregister+0x72>
	if (!atomic_get(&init)) {
    b700:	482e      	ldr	r0, [pc, #184]	; (b7bc <bt_gatt_service_unregister+0x10c>)
    b702:	f01d fb38 	bl	28d76 <atomic_get>
    b706:	4605      	mov	r5, r0
    b708:	2800      	cmp	r0, #0
    b70a:	d142      	bne.n	b792 <bt_gatt_service_unregister+0xe2>
		k_sched_unlock();
    b70c:	f019 f856 	bl	247bc <k_sched_unlock>
		return 0;
    b710:	e7de      	b.n	b6d0 <bt_gatt_service_unregister+0x20>
Z_GENLIST_REMOVE(slist, snode)
    b712:	42a8      	cmp	r0, r5
	parent->next = child;
    b714:	600b      	str	r3, [r1, #0]
	list->tail = node;
    b716:	bf08      	it	eq
    b718:	6051      	streq	r1, [r2, #4]
}
    b71a:	e7e6      	b.n	b6ea <bt_gatt_service_unregister+0x3a>
	return node->next;
    b71c:	4619      	mov	r1, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b71e:	681b      	ldr	r3, [r3, #0]
    b720:	e7d1      	b.n	b6c6 <bt_gatt_service_unregister+0x16>
		struct bt_gatt_attr *attr = &svc->attrs[i];
    b722:	6823      	ldr	r3, [r4, #0]
    b724:	fb0a 3302 	mla	r3, sl, r2, r3
		if (attr->write == bt_gatt_attr_write_ccc) {
    b728:	689a      	ldr	r2, [r3, #8]
    b72a:	455a      	cmp	r2, fp
    b72c:	d12d      	bne.n	b78a <bt_gatt_service_unregister+0xda>
			gatt_unregister_ccc(attr->user_data);
    b72e:	68de      	ldr	r6, [r3, #12]
		if (bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    b730:	f8cd 9008 	str.w	r9, [sp, #8]
    b734:	f106 0801 	add.w	r8, r6, #1
	ccc->value = 0;
    b738:	f8a6 900a 	strh.w	r9, [r6, #10]
		if (bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    b73c:	a902      	add	r1, sp, #8
    b73e:	4640      	mov	r0, r8
    b740:	f8cd 900b 	str.w	r9, [sp, #11]
    b744:	f01d fb81 	bl	28e4a <bt_addr_le_cmp>
    b748:	b1f8      	cbz	r0, b78a <bt_gatt_service_unregister+0xda>
			conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    b74a:	7830      	ldrb	r0, [r6, #0]
    b74c:	4641      	mov	r1, r8
    b74e:	f7fd f951 	bl	89f4 <bt_conn_lookup_addr_le>
			if (conn) {
    b752:	4607      	mov	r7, r0
    b754:	b948      	cbnz	r0, b76a <bt_gatt_service_unregister+0xba>
			    bt_addr_le_is_bonded(cfg->id, &cfg->peer)) {
    b756:	7830      	ldrb	r0, [r6, #0]
    b758:	4641      	mov	r1, r8
    b75a:	f01c fbd9 	bl	27f10 <bt_addr_le_is_bonded>
			if (IS_ENABLED(CONFIG_BT_SETTINGS) && store &&
    b75e:	b188      	cbz	r0, b784 <bt_gatt_service_unregister+0xd4>
				bt_gatt_store_ccc(cfg->id, &cfg->peer);
    b760:	7830      	ldrb	r0, [r6, #0]
    b762:	4641      	mov	r1, r8
    b764:	f7ff ff62 	bl	b62c <bt_gatt_store_ccc>
    b768:	e00c      	b.n	b784 <bt_gatt_service_unregister+0xd4>
				if (conn->state == BT_CONN_CONNECTED) {
    b76a:	7a83      	ldrb	r3, [r0, #10]
    b76c:	2b07      	cmp	r3, #7
    b76e:	d10e      	bne.n	b78e <bt_gatt_service_unregister+0xde>
					gatt_ccc_conn_enqueue(conn);
    b770:	f7fe fca6 	bl	a0c0 <gatt_ccc_conn_enqueue>
					store = false;
    b774:	2300      	movs	r3, #0
				bt_conn_unref(conn);
    b776:	4638      	mov	r0, r7
    b778:	9301      	str	r3, [sp, #4]
    b77a:	f01c fdb8 	bl	282ee <bt_conn_unref>
			if (IS_ENABLED(CONFIG_BT_SETTINGS) && store &&
    b77e:	9b01      	ldr	r3, [sp, #4]
    b780:	2b00      	cmp	r3, #0
    b782:	d1e8      	bne.n	b756 <bt_gatt_service_unregister+0xa6>
			clear_ccc_cfg(cfg);
    b784:	4630      	mov	r0, r6
    b786:	f01d fb8c 	bl	28ea2 <clear_ccc_cfg>
	for (uint16_t i = 0; i < svc->attr_count; i++) {
    b78a:	3501      	adds	r5, #1
    b78c:	e7b4      	b.n	b6f8 <bt_gatt_service_unregister+0x48>
			bool store = true;
    b78e:	2301      	movs	r3, #1
    b790:	e7f1      	b.n	b776 <bt_gatt_service_unregister+0xc6>
		    svc->attrs[svc->attr_count - 1].handle);
    b792:	e9d4 2300 	ldrd	r2, r3, [r4]
	sc_indicate(svc->attrs[0].handle,
    b796:	2114      	movs	r1, #20
    b798:	fb01 2303 	mla	r3, r1, r3, r2
    b79c:	8a10      	ldrh	r0, [r2, #16]
    b79e:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    b7a2:	f7ff f8a1 	bl	a8e8 <sc_indicate>
	return 0;
    b7a6:	2500      	movs	r5, #0
	db_changed();
    b7a8:	f7fe ffc4 	bl	a734 <db_changed>
	k_sched_unlock();
    b7ac:	f019 f806 	bl	247bc <k_sched_unlock>
	return 0;
    b7b0:	e78e      	b.n	b6d0 <bt_gatt_service_unregister+0x20>
    b7b2:	bf00      	nop
    b7b4:	20002698 	.word	0x20002698
    b7b8:	0000a109 	.word	0x0000a109
    b7bc:	200026a0 	.word	0x200026a0

0000b7c0 <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
    b7c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	BT_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    b7c2:	4603      	mov	r3, r0
    b7c4:	4a44      	ldr	r2, [pc, #272]	; (b8d8 <bt_gatt_disconnected+0x118>)
	if (gatt_ccc_store.conn_list[index] != NULL) {
    b7c6:	4e45      	ldr	r6, [pc, #276]	; (b8dc <bt_gatt_disconnected+0x11c>)
{
    b7c8:	b095      	sub	sp, #84	; 0x54
    b7ca:	4604      	mov	r4, r0
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    b7cc:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b7d0:	2001      	movs	r0, #1
    b7d2:	f01d fd0e 	bl	291f2 <bt_gatt_foreach_attr>
	uint8_t index = bt_conn_index(conn);
    b7d6:	4620      	mov	r0, r4
    b7d8:	f7fd f83c 	bl	8854 <bt_conn_index>
    b7dc:	4605      	mov	r5, r0
	if (gatt_ccc_store.conn_list[index] != NULL) {
    b7de:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
    b7e2:	b120      	cbz	r0, b7ee <bt_gatt_disconnected+0x2e>
		bt_conn_unref(gatt_ccc_store.conn_list[index]);
    b7e4:	f01c fd83 	bl	282ee <bt_conn_unref>
		gatt_ccc_store.conn_list[index] = NULL;
    b7e8:	2300      	movs	r3, #0
    b7ea:	f846 3025 	str.w	r3, [r6, r5, lsl #2]

#if defined(CONFIG_BT_SETTINGS_CCC_STORE_ON_WRITE)
	gatt_ccc_conn_unqueue(conn);

	if (gatt_ccc_conn_queue_is_empty()) {
		k_work_cancel_delayable(&gatt_ccc_store.work);
    b7ee:	483c      	ldr	r0, [pc, #240]	; (b8e0 <bt_gatt_disconnected+0x120>)
	}
#endif

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b7f0:	f104 0588 	add.w	r5, r4, #136	; 0x88
		k_work_cancel_delayable(&gatt_ccc_store.work);
    b7f4:	f021 fb07 	bl	2ce06 <k_work_cancel_delayable>
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b7f8:	7a20      	ldrb	r0, [r4, #8]
    b7fa:	4629      	mov	r1, r5
    b7fc:	f01c fb88 	bl	27f10 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    b800:	2800      	cmp	r0, #0
    b802:	d036      	beq.n	b872 <bt_gatt_disconnected+0xb2>
		bt_gatt_store_ccc(conn->id, &conn->le.dst);
    b804:	4629      	mov	r1, r5
    b806:	7a20      	ldrb	r0, [r4, #8]
    b808:	f7ff ff10 	bl	b62c <bt_gatt_store_ccc>
	cfg = find_cf_cfg(conn);
    b80c:	4620      	mov	r0, r4
    b80e:	f7fe fc01 	bl	a014 <find_cf_cfg>
	if (!cfg) {
    b812:	4606      	mov	r6, r0
    b814:	2800      	cmp	r0, #0
    b816:	d04c      	beq.n	b8b2 <bt_gatt_disconnected+0xf2>
		if (conn->id) {
    b818:	7a22      	ldrb	r2, [r4, #8]
		str = (char *)cfg->data;
    b81a:	3608      	adds	r6, #8
		if (conn->id) {
    b81c:	2a00      	cmp	r2, #0
    b81e:	d04a      	beq.n	b8b6 <bt_gatt_disconnected+0xf6>
			u8_to_dec(id_str, sizeof(id_str), conn->id);
    b820:	af04      	add	r7, sp, #16
    b822:	2104      	movs	r1, #4
    b824:	4638      	mov	r0, r7
    b826:	f019 fc16 	bl	25056 <u8_to_dec>
			bt_settings_encode_key(key, sizeof(key), "cf",
    b82a:	9700      	str	r7, [sp, #0]
    b82c:	462b      	mov	r3, r5
    b82e:	4a2d      	ldr	r2, [pc, #180]	; (b8e4 <bt_gatt_disconnected+0x124>)
    b830:	2124      	movs	r1, #36	; 0x24
    b832:	a80b      	add	r0, sp, #44	; 0x2c
    b834:	f7f9 ff5a 	bl	56ec <bt_settings_encode_key>
	if (!cfg || !conn->id) {
    b838:	7a23      	ldrb	r3, [r4, #8]
    b83a:	2701      	movs	r7, #1
    b83c:	b93b      	cbnz	r3, b84e <bt_gatt_disconnected+0x8e>
		bt_settings_encode_key(key, sizeof(key), "cf",
    b83e:	2300      	movs	r3, #0
    b840:	9300      	str	r3, [sp, #0]
    b842:	4a28      	ldr	r2, [pc, #160]	; (b8e4 <bt_gatt_disconnected+0x124>)
    b844:	462b      	mov	r3, r5
    b846:	2124      	movs	r1, #36	; 0x24
    b848:	a80b      	add	r0, sp, #44	; 0x2c
    b84a:	f7f9 ff4f 	bl	56ec <bt_settings_encode_key>
	err = settings_save_one(key, str, len);
    b84e:	463a      	mov	r2, r7
    b850:	4631      	mov	r1, r6
    b852:	a80b      	add	r0, sp, #44	; 0x2c
    b854:	f7f8 f9d4 	bl	3c00 <settings_save_one>
	if (err) {
    b858:	b158      	cbz	r0, b872 <bt_gatt_disconnected+0xb2>
		BT_ERR("Failed to store Client Features (err %d)", err);
    b85a:	4b23      	ldr	r3, [pc, #140]	; (b8e8 <bt_gatt_disconnected+0x128>)
    b85c:	aa07      	add	r2, sp, #28
    b85e:	e9cd 3008 	strd	r3, r0, [sp, #32]
    b862:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    b866:	2303      	movs	r3, #3
    b868:	4820      	ldr	r0, [pc, #128]	; (b8ec <bt_gatt_disconnected+0x12c>)
    b86a:	9303      	str	r3, [sp, #12]
    b86c:	9307      	str	r3, [sp, #28]
    b86e:	f01d fb5a 	bl	28f26 <z_log_msg2_static_create.constprop.0>
		bt_gatt_store_cf(conn);
	}

	/* Make sure to clear the CCC entry when using lazy loading */
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
	    bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b872:	7a20      	ldrb	r0, [r4, #8]
    b874:	4629      	mov	r1, r5
    b876:	f01c fb4b 	bl	27f10 <bt_addr_le_is_bonded>
	if (IS_ENABLED(CONFIG_BT_SETTINGS_CCC_LAZY_LOADING) &&
    b87a:	b150      	cbz	r0, b892 <bt_gatt_disconnected+0xd2>
		struct addr_with_id addr_with_id = {
    b87c:	7a23      	ldrb	r3, [r4, #8]
    b87e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
			.addr = &conn->le.dst,
			.id = conn->id,
		};
		bt_gatt_foreach_attr(0x0001, 0xffff,
    b882:	4a1b      	ldr	r2, [pc, #108]	; (b8f0 <bt_gatt_disconnected+0x130>)
		struct addr_with_id addr_with_id = {
    b884:	950b      	str	r5, [sp, #44]	; 0x2c
		bt_gatt_foreach_attr(0x0001, 0xffff,
    b886:	ab0b      	add	r3, sp, #44	; 0x2c
    b888:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b88c:	2001      	movs	r0, #1
    b88e:	f01d fcb0 	bl	291f2 <bt_gatt_foreach_attr>
	cfg = find_cf_cfg(conn);
    b892:	4620      	mov	r0, r4
    b894:	f7fe fbbe 	bl	a014 <find_cf_cfg>
	if (!cfg) {
    b898:	4606      	mov	r6, r0
    b89a:	b1d8      	cbz	r0, b8d4 <bt_gatt_disconnected+0x114>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    b89c:	7a20      	ldrb	r0, [r4, #8]
    b89e:	4629      	mov	r1, r5
    b8a0:	f01c fb36 	bl	27f10 <bt_addr_le_is_bonded>
    b8a4:	b948      	cbnz	r0, b8ba <bt_gatt_disconnected+0xfa>
		clear_cf_cfg(cfg);
    b8a6:	4630      	mov	r0, r6
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
    b8a8:	b015      	add	sp, #84	; 0x54
    b8aa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		clear_cf_cfg(cfg);
    b8ae:	f01d bb3d 	b.w	28f2c <clear_cf_cfg>
		len = 0;
    b8b2:	4607      	mov	r7, r0
    b8b4:	e7c3      	b.n	b83e <bt_gatt_disconnected+0x7e>
    b8b6:	2701      	movs	r7, #1
    b8b8:	e7c1      	b.n	b83e <bt_gatt_disconnected+0x7e>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    b8ba:	4629      	mov	r1, r5
    b8bc:	1c70      	adds	r0, r6, #1
    b8be:	f01d faed 	bl	28e9c <bt_addr_le_copy>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    b8c2:	f06f 0102 	mvn.w	r1, #2
    b8c6:	f106 000c 	add.w	r0, r6, #12
}
    b8ca:	b015      	add	sp, #84	; 0x54
    b8cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    b8d0:	f01d baf5 	b.w	28ebe <atomic_and>
    b8d4:	b015      	add	sp, #84	; 0x54
    b8d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b8d8:	0000a85d 	.word	0x0000a85d
    b8dc:	20001900 	.word	0x20001900
    b8e0:	20001908 	.word	0x20001908
    b8e4:	00030717 	.word	0x00030717
    b8e8:	000306eb 	.word	0x000306eb
    b8ec:	0002daa4 	.word	0x0002daa4
    b8f0:	0000a649 	.word	0x0000a649

0000b8f4 <bt_smp_accept>:

	return 0;
}

static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    b8f4:	b500      	push	{lr}
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_l2cap_le_chan *smp = &bt_smp_pool[i];

		if (smp->chan.conn) {
    b8f6:	4a0d      	ldr	r2, [pc, #52]	; (b92c <bt_smp_accept+0x38>)
{
    b8f8:	4603      	mov	r3, r0
		if (smp->chan.conn) {
    b8fa:	6810      	ldr	r0, [r2, #0]
{
    b8fc:	b089      	sub	sp, #36	; 0x24
		if (smp->chan.conn) {
    b8fe:	b928      	cbnz	r0, b90c <bt_smp_accept+0x18>
			continue;
		}

		smp->chan.ops = &ops;
    b900:	4b0b      	ldr	r3, [pc, #44]	; (b930 <bt_smp_accept+0x3c>)
    b902:	6053      	str	r3, [r2, #4]

		*chan = &smp->chan;
    b904:	600a      	str	r2, [r1, #0]
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
}
    b906:	b009      	add	sp, #36	; 0x24
    b908:	f85d fb04 	ldr.w	pc, [sp], #4
	BT_ERR("No available SMP context for conn %p", conn);
    b90c:	4a09      	ldr	r2, [pc, #36]	; (b934 <bt_smp_accept+0x40>)
    b90e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    b912:	2303      	movs	r3, #3
    b914:	9301      	str	r3, [sp, #4]
    b916:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    b918:	4807      	ldr	r0, [pc, #28]	; (b938 <bt_smp_accept+0x44>)
    b91a:	2300      	movs	r3, #0
    b91c:	aa05      	add	r2, sp, #20
    b91e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    b922:	f01a f9d9 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	return -ENOMEM;
    b926:	f06f 000b 	mvn.w	r0, #11
    b92a:	e7ec      	b.n	b906 <bt_smp_accept+0x12>
    b92c:	20001990 	.word	0x20001990
    b930:	0002e3e0 	.word	0x0002e3e0
    b934:	00030728 	.word	0x00030728
    b938:	0002dba4 	.word	0x0002dba4

0000b93c <bt_mesh_reset>:

	return -ENOTSUP;
}

void bt_mesh_reset(void)
{
    b93c:	b538      	push	{r3, r4, r5, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b93e:	481f      	ldr	r0, [pc, #124]	; (b9bc <bt_mesh_reset+0x80>)
    b940:	f3bf 8f5b 	dmb	ish
    b944:	6803      	ldr	r3, [r0, #0]
    b946:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    b94a:	07db      	lsls	r3, r3, #31
    b94c:	d534      	bpl.n	b9b8 <bt_mesh_reset+0x7c>
		return;
	}

	bt_mesh.iv_index = 0U;
    b94e:	2400      	movs	r4, #0
	bt_mesh.ivu_duration = 0;
	bt_mesh.seq = 0U;

	memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
    b950:	4621      	mov	r1, r4
    b952:	2204      	movs	r2, #4
	bt_mesh.iv_index = 0U;
    b954:	f1a0 0508 	sub.w	r5, r0, #8
    b958:	f840 4c08 	str.w	r4, [r0, #-8]
	bt_mesh.ivu_duration = 0;
    b95c:	f880 41f0 	strb.w	r4, [r0, #496]	; 0x1f0
	bt_mesh.seq = 0U;
    b960:	f840 4c04 	str.w	r4, [r0, #-4]
	memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
    b964:	f01b ff8f 	bl	27886 <memset>

	/* If this fails, the work handler will return early on the next
	 * execution, as the device is not provisioned. If the device is
	 * reprovisioned, the timer is always restarted.
	 */
	(void)k_work_cancel_delayable(&bt_mesh.ivu_timer);
    b968:	f505 7000 	add.w	r0, r5, #512	; 0x200
    b96c:	f021 fa4b 	bl	2ce06 <k_work_cancel_delayable>

	bt_mesh_model_reset();
    b970:	f008 fdb6 	bl	144e0 <bt_mesh_model_reset>
	bt_mesh_cfg_default_set();
    b974:	f000 fa5a 	bl	be2c <bt_mesh_cfg_default_set>
	bt_mesh_trans_reset();
    b978:	f003 f9f2 	bl	ed60 <bt_mesh_trans_reset>
	bt_mesh_app_keys_reset();
    b97c:	f002 fbe6 	bl	e14c <bt_mesh_app_keys_reset>
	bt_mesh_net_keys_reset();
    b980:	f002 f8be 	bl	db00 <bt_mesh_net_keys_reset>

	bt_mesh_net_loopback_clear(BT_MESH_KEY_ANY);
    b984:	f64f 70ff 	movw	r0, #65535	; 0xffff
    b988:	f001 fb34 	bl	cff4 <bt_mesh_net_loopback_clear>

		bt_mesh_lpn_disable(true);
	}

	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		bt_mesh_friends_clear();
    b98c:	f00a f900 	bl	15b90 <bt_mesh_friends_clear>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY)) {
		(void)bt_mesh_proxy_gatt_disable();
    b990:	f00d fa28 	bl	18de4 <bt_mesh_proxy_gatt_disable>
	}

	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bt_mesh_net_clear();
    b994:	f01d fd8c 	bl	294b0 <bt_mesh_net_clear>
	}

	(void)memset(bt_mesh.dev_key, 0, sizeof(bt_mesh.dev_key));
    b998:	4621      	mov	r1, r4
    b99a:	2210      	movs	r2, #16
    b99c:	f505 700c 	add.w	r0, r5, #560	; 0x230
    b9a0:	f01b ff71 	bl	27886 <memset>

	bt_mesh_scan_disable();
    b9a4:	f000 fb9c 	bl	c0e0 <bt_mesh_scan_disable>
	bt_mesh_beacon_disable();
    b9a8:	f000 fea0 	bl	c6ec <bt_mesh_beacon_disable>

	bt_mesh_comp_unprovision();
    b9ac:	f005 fa54 	bl	10e58 <bt_mesh_comp_unprovision>

	if (IS_ENABLED(CONFIG_BT_MESH_PROV)) {
		bt_mesh_prov_reset();
	}
}
    b9b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_mesh_prov_reset();
    b9b4:	f00b b93c 	b.w	16c30 <bt_mesh_prov_reset>
}
    b9b8:	bd38      	pop	{r3, r4, r5, pc}
    b9ba:	bf00      	nop
    b9bc:	20001ab0 	.word	0x20001ab0

0000b9c0 <bt_mesh_is_provisioned>:
    b9c0:	4b04      	ldr	r3, [pc, #16]	; (b9d4 <bt_mesh_is_provisioned+0x14>)
    b9c2:	f3bf 8f5b 	dmb	ish
    b9c6:	6818      	ldr	r0, [r3, #0]
    b9c8:	f3bf 8f5b 	dmb	ish

bool bt_mesh_is_provisioned(void)
{
	return atomic_test_bit(bt_mesh.flags, BT_MESH_VALID);
}
    b9cc:	f000 0001 	and.w	r0, r0, #1
    b9d0:	4770      	bx	lr
    b9d2:	bf00      	nop
    b9d4:	20001ab0 	.word	0x20001ab0

0000b9d8 <bt_mesh_start>:
		mod->cb->start(mod);
	}
}

int bt_mesh_start(void)
{
    b9d8:	b530      	push	{r4, r5, lr}
    b9da:	b089      	sub	sp, #36	; 0x24
	int err;

	err = bt_mesh_adv_enable();
    b9dc:	f009 fb1c 	bl	15018 <bt_mesh_adv_enable>
	if (err) {
    b9e0:	4604      	mov	r4, r0
    b9e2:	b170      	cbz	r0, ba02 <bt_mesh_start+0x2a>
		BT_ERR("Failed enabling advertiser");
    b9e4:	4b1c      	ldr	r3, [pc, #112]	; (ba58 <bt_mesh_start+0x80>)
    b9e6:	9306      	str	r3, [sp, #24]
    b9e8:	2302      	movs	r3, #2
    b9ea:	9301      	str	r3, [sp, #4]
    b9ec:	9305      	str	r3, [sp, #20]
    b9ee:	481b      	ldr	r0, [pc, #108]	; (ba5c <bt_mesh_start+0x84>)
    b9f0:	2300      	movs	r3, #0
    b9f2:	aa05      	add	r2, sp, #20
    b9f4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    b9f8:	f01a f96e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	bt_mesh_hb_start();

	bt_mesh_model_foreach(model_start, NULL);

	return 0;
}
    b9fc:	4620      	mov	r0, r4
    b9fe:	b009      	add	sp, #36	; 0x24
    ba00:	bd30      	pop	{r4, r5, pc}
	if (bt_mesh_beacon_enabled()) {
    ba02:	f000 f901 	bl	bc08 <bt_mesh_beacon_enabled>
    ba06:	b320      	cbz	r0, ba52 <bt_mesh_start+0x7a>
		bt_mesh_beacon_enable();
    ba08:	f000 fe5e 	bl	c6c8 <bt_mesh_beacon_enable>
	if (!IS_ENABLED(CONFIG_BT_MESH_PROV) || !bt_mesh_prov_active() ||
    ba0c:	f00b f8f8 	bl	16c00 <bt_mesh_prov_active>
    ba10:	b120      	cbz	r0, ba1c <bt_mesh_start+0x44>
	    bt_mesh_prov_link.bearer->type == BT_MESH_PROV_ADV) {
    ba12:	4b13      	ldr	r3, [pc, #76]	; (ba60 <bt_mesh_start+0x88>)
    ba14:	685b      	ldr	r3, [r3, #4]
	if (!IS_ENABLED(CONFIG_BT_MESH_PROV) || !bt_mesh_prov_active() ||
    ba16:	781b      	ldrb	r3, [r3, #0]
    ba18:	2b01      	cmp	r3, #1
    ba1a:	d105      	bne.n	ba28 <bt_mesh_start+0x50>
			(void)bt_mesh_pb_gatt_disable();
    ba1c:	f00c fe24 	bl	18668 <bt_mesh_pb_gatt_disable>
			(void)bt_mesh_proxy_gatt_enable();
    ba20:	f00d f986 	bl	18d30 <bt_mesh_proxy_gatt_enable>
			bt_mesh_adv_gatt_update();
    ba24:	f01e fc21 	bl	2a26a <bt_mesh_adv_gatt_update>
		bt_mesh_scan_enable();
    ba28:	f000 fb2e 	bl	c088 <bt_mesh_scan_enable>
		bt_mesh_friend_init();
    ba2c:	f00a fcd6 	bl	163dc <bt_mesh_friend_init>
		struct bt_mesh_subnet *sub = bt_mesh_subnet_next(NULL);
    ba30:	2000      	movs	r0, #0
    ba32:	f002 f845 	bl	dac0 <bt_mesh_subnet_next>
    ba36:	4605      	mov	r5, r0
		uint16_t addr = bt_mesh_primary_addr();
    ba38:	f005 fa14 	bl	10e64 <bt_mesh_primary_addr>
    ba3c:	4601      	mov	r1, r0
		bt_mesh_prov_complete(sub->net_idx, addr);
    ba3e:	8ba8      	ldrh	r0, [r5, #28]
    ba40:	f00b f8ee 	bl	16c20 <bt_mesh_prov_complete>
	bt_mesh_hb_start();
    ba44:	f004 fc28 	bl	10298 <bt_mesh_hb_start>
	bt_mesh_model_foreach(model_start, NULL);
    ba48:	4806      	ldr	r0, [pc, #24]	; (ba64 <bt_mesh_start+0x8c>)
    ba4a:	2100      	movs	r1, #0
    ba4c:	f004 ff08 	bl	10860 <bt_mesh_model_foreach>
	return 0;
    ba50:	e7d4      	b.n	b9fc <bt_mesh_start+0x24>
		bt_mesh_beacon_disable();
    ba52:	f000 fe4b 	bl	c6ec <bt_mesh_beacon_disable>
    ba56:	e7d9      	b.n	ba0c <bt_mesh_start+0x34>
    ba58:	00030754 	.word	0x00030754
    ba5c:	0002db2c 	.word	0x0002db2c
    ba60:	20002794 	.word	0x20002794
    ba64:	00029329 	.word	0x00029329

0000ba68 <bt_mesh_provision>:
{
    ba68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ba6c:	b088      	sub	sp, #32
    ba6e:	af00      	add	r7, sp, #0
    ba70:	461e      	mov	r6, r3
    ba72:	f8b7 9040 	ldrh.w	r9, [r7, #64]	; 0x40
	BT_INFO("Primary Element: 0x%04x", addr);
    ba76:	4b31      	ldr	r3, [pc, #196]	; (bb3c <bt_mesh_provision+0xd4>)
    ba78:	e9c7 3906 	strd	r3, r9, [r7, #24]
    ba7c:	2303      	movs	r3, #3
{
    ba7e:	4680      	mov	r8, r0
    ba80:	460c      	mov	r4, r1
    ba82:	4615      	mov	r5, r2
	BT_INFO("Primary Element: 0x%04x", addr);
    ba84:	46ea      	mov	sl, sp
    ba86:	607b      	str	r3, [r7, #4]
    ba88:	617b      	str	r3, [r7, #20]
    ba8a:	482d      	ldr	r0, [pc, #180]	; (bb40 <bt_mesh_provision+0xd8>)
    ba8c:	f107 0214 	add.w	r2, r7, #20
    ba90:	2300      	movs	r3, #0
    ba92:	f44f 51c6 	mov.w	r1, #6336	; 0x18c0
    ba96:	f01a f91f 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	BT_DBG("net_idx 0x%04x flags 0x%02x iv_index 0x%04x",
    ba9a:	b08a      	sub	sp, #40	; 0x28
    ba9c:	466a      	mov	r2, sp
    ba9e:	4b29      	ldr	r3, [pc, #164]	; (bb44 <bt_mesh_provision+0xdc>)
    baa0:	6113      	str	r3, [r2, #16]
    baa2:	4b29      	ldr	r3, [pc, #164]	; (bb48 <bt_mesh_provision+0xe0>)
    baa4:	e9c2 3405 	strd	r3, r4, [r2, #20]
    baa8:	2306      	movs	r3, #6
    baaa:	e9c2 5607 	strd	r5, r6, [r2, #28]
    baae:	60bb      	str	r3, [r7, #8]
    bab0:	f842 3f0c 	str.w	r3, [r2, #12]!
    bab4:	4822      	ldr	r0, [pc, #136]	; (bb40 <bt_mesh_provision+0xd8>)
    bab6:	2300      	movs	r3, #0
    bab8:	f44f 5144 	mov.w	r1, #12544	; 0x3100
    babc:	f01a f90c 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    bac0:	f3bf 8f5b 	dmb	ish
    bac4:	46d5      	mov	sp, sl
    bac6:	f8df a084 	ldr.w	sl, [pc, #132]	; bb4c <bt_mesh_provision+0xe4>
    baca:	e85a 3f00 	ldrex	r3, [sl]
    bace:	f043 0201 	orr.w	r2, r3, #1
    bad2:	e84a 2100 	strex	r1, r2, [sl]
    bad6:	2900      	cmp	r1, #0
    bad8:	d1f7      	bne.n	baca <bt_mesh_provision+0x62>
    bada:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_set_bit(bt_mesh.flags, BT_MESH_VALID)) {
    bade:	07db      	lsls	r3, r3, #31
    bae0:	d428      	bmi.n	bb34 <bt_mesh_provision+0xcc>
	err = bt_mesh_net_create(net_idx, flags, net_key, iv_index);
    bae2:	4620      	mov	r0, r4
    bae4:	4633      	mov	r3, r6
    bae6:	4642      	mov	r2, r8
    bae8:	4629      	mov	r1, r5
    baea:	f000 ffc1 	bl	ca70 <bt_mesh_net_create>
	if (err) {
    baee:	4604      	mov	r4, r0
    baf0:	b180      	cbz	r0, bb14 <bt_mesh_provision+0xac>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    baf2:	f3bf 8f5b 	dmb	ish
    baf6:	e85a 3f00 	ldrex	r3, [sl]
    bafa:	f023 0301 	bic.w	r3, r3, #1
    bafe:	e84a 3200 	strex	r2, r3, [sl]
    bb02:	2a00      	cmp	r2, #0
    bb04:	d1f7      	bne.n	baf6 <bt_mesh_provision+0x8e>
    bb06:	f3bf 8f5b 	dmb	ish
}
    bb0a:	4620      	mov	r0, r4
    bb0c:	3720      	adds	r7, #32
    bb0e:	46bd      	mov	sp, r7
    bb10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_mesh.seq = 0U;
    bb14:	f84a 0c04 	str.w	r0, [sl, #-4]
	bt_mesh_comp_provision(addr);
    bb18:	4648      	mov	r0, r9
    bb1a:	f005 f987 	bl	10e2c <bt_mesh_comp_provision>
	memcpy(bt_mesh.dev_key, dev_key, 16);
    bb1e:	6c79      	ldr	r1, [r7, #68]	; 0x44
    bb20:	2210      	movs	r2, #16
    bb22:	f50a 700a 	add.w	r0, sl, #552	; 0x228
    bb26:	f01b fea3 	bl	27870 <memcpy>
		bt_mesh_net_pending_net_store();
    bb2a:	f001 fd0b 	bl	d544 <bt_mesh_net_pending_net_store>
	bt_mesh_start();
    bb2e:	f7ff ff53 	bl	b9d8 <bt_mesh_start>
	return 0;
    bb32:	e7ea      	b.n	bb0a <bt_mesh_provision+0xa2>
		return -EALREADY;
    bb34:	f06f 0477 	mvn.w	r4, #119	; 0x77
    bb38:	e7e7      	b.n	bb0a <bt_mesh_provision+0xa2>
    bb3a:	bf00      	nop
    bb3c:	0003076f 	.word	0x0003076f
    bb40:	0002db2c 	.word	0x0002db2c
    bb44:	00030787 	.word	0x00030787
    bb48:	000307c4 	.word	0x000307c4
    bb4c:	20001ab0 	.word	0x20001ab0

0000bb50 <feature_set>:
	return atomic_test_bit(bt_mesh.flags, BT_MESH_BEACON);
}

static int feature_set(int feature_flag, enum bt_mesh_feat_state state)
{
	if (state != BT_MESH_FEATURE_DISABLED &&
    bb50:	2901      	cmp	r1, #1
{
    bb52:	b538      	push	{r3, r4, r5, lr}
    bb54:	4605      	mov	r5, r0
	if (state != BT_MESH_FEATURE_DISABLED &&
    bb56:	d820      	bhi.n	bb9a <feature_set+0x4a>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    bb58:	4c13      	ldr	r4, [pc, #76]	; (bba8 <feature_set+0x58>)
    bb5a:	4620      	mov	r0, r4
    bb5c:	f01d fc0b 	bl	29376 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    bb60:	fa40 f205 	asr.w	r2, r0, r5
	    state != BT_MESH_FEATURE_ENABLED) {
		return -EINVAL;
	}

	if (atomic_test_bit(bt_mesh.flags, feature_flag) ==
	    (state == BT_MESH_FEATURE_ENABLED)) {
    bb64:	f001 0301 	and.w	r3, r1, #1
	if (atomic_test_bit(bt_mesh.flags, feature_flag) ==
    bb68:	f002 0201 	and.w	r2, r2, #1
    bb6c:	4293      	cmp	r3, r2
    bb6e:	d017      	beq.n	bba0 <feature_set+0x50>
	atomic_val_t mask = ATOMIC_MASK(bit);
    bb70:	2101      	movs	r1, #1
    bb72:	40a9      	lsls	r1, r5
	if (val) {
    bb74:	b123      	cbz	r3, bb80 <feature_set+0x30>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    bb76:	4620      	mov	r0, r4
    bb78:	f01d fc03 	bl	29382 <atomic_or.isra.0>
	}

	atomic_set_bit_to(bt_mesh.flags, feature_flag,
			  (state == BT_MESH_FEATURE_ENABLED));

	return 0;
    bb7c:	2000      	movs	r0, #0
}
    bb7e:	bd38      	pop	{r3, r4, r5, pc}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    bb80:	43c9      	mvns	r1, r1
    bb82:	f3bf 8f5b 	dmb	ish
    bb86:	e854 2f00 	ldrex	r2, [r4]
    bb8a:	400a      	ands	r2, r1
    bb8c:	e844 2000 	strex	r0, r2, [r4]
    bb90:	2800      	cmp	r0, #0
    bb92:	d1f8      	bne.n	bb86 <feature_set+0x36>
    bb94:	f3bf 8f5b 	dmb	ish
    bb98:	e7f0      	b.n	bb7c <feature_set+0x2c>
		return -EINVAL;
    bb9a:	f06f 0015 	mvn.w	r0, #21
    bb9e:	e7ee      	b.n	bb7e <feature_set+0x2e>
		return -EALREADY;
    bba0:	f06f 0077 	mvn.w	r0, #119	; 0x77
    bba4:	e7eb      	b.n	bb7e <feature_set+0x2e>
    bba6:	bf00      	nop
    bba8:	20001ab0 	.word	0x20001ab0

0000bbac <bt_mesh_beacon_set>:
{
    bbac:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    bbae:	4b15      	ldr	r3, [pc, #84]	; (bc04 <bt_mesh_beacon_set+0x58>)
    bbb0:	4602      	mov	r2, r0
    bbb2:	4618      	mov	r0, r3
    bbb4:	f01d fbdf 	bl	29376 <atomic_get>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_BEACON) == beacon) {
    bbb8:	f3c0 10c0 	ubfx	r0, r0, #7, #1
    bbbc:	4282      	cmp	r2, r0
    bbbe:	d01f      	beq.n	bc00 <bt_mesh_beacon_set+0x54>
	if (val) {
    bbc0:	b17a      	cbz	r2, bbe2 <bt_mesh_beacon_set+0x36>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    bbc2:	2180      	movs	r1, #128	; 0x80
    bbc4:	4618      	mov	r0, r3
    bbc6:	f01d fbdc 	bl	29382 <atomic_or.isra.0>
		bt_mesh_beacon_enable();
    bbca:	f000 fd7d 	bl	c6c8 <bt_mesh_beacon_enable>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    bbce:	480d      	ldr	r0, [pc, #52]	; (bc04 <bt_mesh_beacon_set+0x58>)
    bbd0:	f01d fbd1 	bl	29376 <atomic_get>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bbd4:	07c3      	lsls	r3, r0, #31
    bbd6:	d513      	bpl.n	bc00 <bt_mesh_beacon_set+0x54>
}
    bbd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bbdc:	2007      	movs	r0, #7
    bbde:	f009 baa9 	b.w	15134 <bt_mesh_settings_store_schedule>
    bbe2:	f3bf 8f5b 	dmb	ish
    bbe6:	e853 2f00 	ldrex	r2, [r3]
    bbea:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    bbee:	e843 2100 	strex	r1, r2, [r3]
    bbf2:	2900      	cmp	r1, #0
    bbf4:	d1f7      	bne.n	bbe6 <bt_mesh_beacon_set+0x3a>
    bbf6:	f3bf 8f5b 	dmb	ish
		bt_mesh_beacon_disable();
    bbfa:	f000 fd77 	bl	c6ec <bt_mesh_beacon_disable>
    bbfe:	e7e6      	b.n	bbce <bt_mesh_beacon_set+0x22>
}
    bc00:	bd08      	pop	{r3, pc}
    bc02:	bf00      	nop
    bc04:	20001ab0 	.word	0x20001ab0

0000bc08 <bt_mesh_beacon_enabled>:
{
    bc08:	b508      	push	{r3, lr}
    bc0a:	4803      	ldr	r0, [pc, #12]	; (bc18 <bt_mesh_beacon_enabled+0x10>)
    bc0c:	f01d fbb3 	bl	29376 <atomic_get>
}
    bc10:	f3c0 10c0 	ubfx	r0, r0, #7, #1
    bc14:	bd08      	pop	{r3, pc}
    bc16:	bf00      	nop
    bc18:	20001ab0 	.word	0x20001ab0

0000bc1c <bt_mesh_gatt_proxy_set>:
{
	return sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING;
}

int bt_mesh_gatt_proxy_set(enum bt_mesh_feat_state gatt_proxy)
{
    bc1c:	b538      	push	{r3, r4, r5, lr}

	if (!IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY)) {
		return -ENOTSUP;
	}

	err = feature_set(BT_MESH_GATT_PROXY, gatt_proxy);
    bc1e:	4601      	mov	r1, r0
{
    bc20:	4605      	mov	r5, r0
	err = feature_set(BT_MESH_GATT_PROXY, gatt_proxy);
    bc22:	2008      	movs	r0, #8
    bc24:	f7ff ff94 	bl	bb50 <feature_set>
	if (err) {
    bc28:	4604      	mov	r4, r0
    bc2a:	b970      	cbnz	r0, bc4a <bt_mesh_gatt_proxy_set+0x2e>
		return err;
	}

	if ((gatt_proxy == BT_MESH_FEATURE_ENABLED) ||
    bc2c:	2d01      	cmp	r5, #1
    bc2e:	d10e      	bne.n	bc4e <bt_mesh_gatt_proxy_set+0x32>
	    (gatt_proxy == BT_MESH_FEATURE_DISABLED &&
	     !bt_mesh_subnet_find(node_id_is_running, NULL))) {
		bt_mesh_adv_gatt_update();
    bc30:	f01e fb1b 	bl	2a26a <bt_mesh_adv_gatt_update>
	}

	bt_mesh_hb_feature_changed(BT_MESH_FEAT_PROXY);
    bc34:	2002      	movs	r0, #2
    bc36:	f004 fb09 	bl	1024c <bt_mesh_hb_feature_changed>
    bc3a:	4809      	ldr	r0, [pc, #36]	; (bc60 <bt_mesh_gatt_proxy_set+0x44>)
    bc3c:	f01d fb9b 	bl	29376 <atomic_get>

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bc40:	07c3      	lsls	r3, r0, #31
    bc42:	d502      	bpl.n	bc4a <bt_mesh_gatt_proxy_set+0x2e>
	    atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bc44:	2007      	movs	r0, #7
    bc46:	f009 fa75 	bl	15134 <bt_mesh_settings_store_schedule>
	}

	return 0;
}
    bc4a:	4620      	mov	r0, r4
    bc4c:	bd38      	pop	{r3, r4, r5, pc}
	if ((gatt_proxy == BT_MESH_FEATURE_ENABLED) ||
    bc4e:	2d00      	cmp	r5, #0
    bc50:	d1f0      	bne.n	bc34 <bt_mesh_gatt_proxy_set+0x18>
	     !bt_mesh_subnet_find(node_id_is_running, NULL))) {
    bc52:	4601      	mov	r1, r0
    bc54:	4803      	ldr	r0, [pc, #12]	; (bc64 <bt_mesh_gatt_proxy_set+0x48>)
    bc56:	f001 fef3 	bl	da40 <bt_mesh_subnet_find>
	    (gatt_proxy == BT_MESH_FEATURE_DISABLED &&
    bc5a:	2800      	cmp	r0, #0
    bc5c:	d1ea      	bne.n	bc34 <bt_mesh_gatt_proxy_set+0x18>
    bc5e:	e7e7      	b.n	bc30 <bt_mesh_gatt_proxy_set+0x14>
    bc60:	20001ab0 	.word	0x20001ab0
    bc64:	0002936d 	.word	0x0002936d

0000bc68 <bt_mesh_gatt_proxy_get>:

enum bt_mesh_feat_state bt_mesh_gatt_proxy_get(void)
{
    bc68:	b508      	push	{r3, lr}
    bc6a:	4803      	ldr	r0, [pc, #12]	; (bc78 <bt_mesh_gatt_proxy_get+0x10>)
    bc6c:	f01d fb83 	bl	29376 <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY)) {
		return BT_MESH_FEATURE_NOT_SUPPORTED;
	}

	return feature_get(BT_MESH_GATT_PROXY);
}
    bc70:	f3c0 2000 	ubfx	r0, r0, #8, #1
    bc74:	bd08      	pop	{r3, pc}
    bc76:	bf00      	nop
    bc78:	20001ab0 	.word	0x20001ab0

0000bc7c <bt_mesh_default_ttl_set>:

int bt_mesh_default_ttl_set(uint8_t default_ttl)
{
	if (default_ttl == 1 || default_ttl > BT_MESH_TTL_MAX) {
    bc7c:	2801      	cmp	r0, #1
{
    bc7e:	b508      	push	{r3, lr}
	if (default_ttl == 1 || default_ttl > BT_MESH_TTL_MAX) {
    bc80:	d014      	beq.n	bcac <bt_mesh_default_ttl_set+0x30>
    bc82:	0602      	lsls	r2, r0, #24
    bc84:	d412      	bmi.n	bcac <bt_mesh_default_ttl_set+0x30>
		return -EINVAL;
	}

	if (default_ttl == bt_mesh.default_ttl) {
    bc86:	4b0b      	ldr	r3, [pc, #44]	; (bcb4 <bt_mesh_default_ttl_set+0x38>)
    bc88:	f893 21fb 	ldrb.w	r2, [r3, #507]	; 0x1fb
    bc8c:	4282      	cmp	r2, r0
    bc8e:	d101      	bne.n	bc94 <bt_mesh_default_ttl_set+0x18>

	bt_mesh.default_ttl = default_ttl;

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bc90:	2000      	movs	r0, #0
	}

	return 0;
}
    bc92:	bd08      	pop	{r3, pc}
	bt_mesh.default_ttl = default_ttl;
    bc94:	f883 01fb 	strb.w	r0, [r3, #507]	; 0x1fb
    bc98:	f103 0008 	add.w	r0, r3, #8
    bc9c:	f01d fb6b 	bl	29376 <atomic_get>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bca0:	07c3      	lsls	r3, r0, #31
    bca2:	d5f5      	bpl.n	bc90 <bt_mesh_default_ttl_set+0x14>
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bca4:	2007      	movs	r0, #7
    bca6:	f009 fa45 	bl	15134 <bt_mesh_settings_store_schedule>
    bcaa:	e7f1      	b.n	bc90 <bt_mesh_default_ttl_set+0x14>
		return -EINVAL;
    bcac:	f06f 0015 	mvn.w	r0, #21
    bcb0:	e7ef      	b.n	bc92 <bt_mesh_default_ttl_set+0x16>
    bcb2:	bf00      	nop
    bcb4:	20001aa8 	.word	0x20001aa8

0000bcb8 <bt_mesh_default_ttl_get>:

uint8_t bt_mesh_default_ttl_get(void)
{
	return bt_mesh.default_ttl;
}
    bcb8:	4b01      	ldr	r3, [pc, #4]	; (bcc0 <bt_mesh_default_ttl_get+0x8>)
    bcba:	f893 01fb 	ldrb.w	r0, [r3, #507]	; 0x1fb
    bcbe:	4770      	bx	lr
    bcc0:	20001aa8 	.word	0x20001aa8

0000bcc4 <bt_mesh_friend_set>:

int bt_mesh_friend_set(enum bt_mesh_feat_state friendship)
{
    bcc4:	b538      	push	{r3, r4, r5, lr}

	if (!IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		return -ENOTSUP;
	}

	err = feature_set(BT_MESH_FRIEND, friendship);
    bcc6:	4601      	mov	r1, r0
{
    bcc8:	4605      	mov	r5, r0
	err = feature_set(BT_MESH_FRIEND, friendship);
    bcca:	2009      	movs	r0, #9
    bccc:	f7ff ff40 	bl	bb50 <feature_set>
	if (err) {
    bcd0:	4604      	mov	r4, r0
    bcd2:	b968      	cbnz	r0, bcf0 <bt_mesh_friend_set+0x2c>
		return err;
	}

	bt_mesh_hb_feature_changed(BT_MESH_FEAT_FRIEND);
    bcd4:	2004      	movs	r0, #4
    bcd6:	f004 fab9 	bl	1024c <bt_mesh_hb_feature_changed>
    bcda:	4806      	ldr	r0, [pc, #24]	; (bcf4 <bt_mesh_friend_set+0x30>)
    bcdc:	f01d fb4b 	bl	29376 <atomic_get>

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bce0:	07c3      	lsls	r3, r0, #31
    bce2:	d502      	bpl.n	bcea <bt_mesh_friend_set+0x26>
	    atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bce4:	2007      	movs	r0, #7
    bce6:	f009 fa25 	bl	15134 <bt_mesh_settings_store_schedule>
	}

	if (friendship == BT_MESH_FEATURE_DISABLED) {
    bcea:	b90d      	cbnz	r5, bcf0 <bt_mesh_friend_set+0x2c>
		bt_mesh_friends_clear();
    bcec:	f009 ff50 	bl	15b90 <bt_mesh_friends_clear>
	}

	return 0;
}
    bcf0:	4620      	mov	r0, r4
    bcf2:	bd38      	pop	{r3, r4, r5, pc}
    bcf4:	20001ab0 	.word	0x20001ab0

0000bcf8 <bt_mesh_friend_get>:

enum bt_mesh_feat_state bt_mesh_friend_get(void)
{
    bcf8:	b508      	push	{r3, lr}
    bcfa:	4803      	ldr	r0, [pc, #12]	; (bd08 <bt_mesh_friend_get+0x10>)
    bcfc:	f01d fb3b 	bl	29376 <atomic_get>
	if (!IS_ENABLED(CONFIG_BT_MESH_FRIEND)) {
		return BT_MESH_FEATURE_NOT_SUPPORTED;
	}

	return feature_get(BT_MESH_FRIEND);
}
    bd00:	f3c0 2040 	ubfx	r0, r0, #9, #1
    bd04:	bd08      	pop	{r3, pc}
    bd06:	bf00      	nop
    bd08:	20001ab0 	.word	0x20001ab0

0000bd0c <bt_mesh_net_transmit_set>:

void bt_mesh_net_transmit_set(uint8_t xmit)
{
    bd0c:	b508      	push	{r3, lr}
	if (bt_mesh.net_xmit == xmit) {
    bd0e:	4b09      	ldr	r3, [pc, #36]	; (bd34 <bt_mesh_net_transmit_set+0x28>)
    bd10:	f893 21f9 	ldrb.w	r2, [r3, #505]	; 0x1f9
    bd14:	4282      	cmp	r2, r0
    bd16:	d00c      	beq.n	bd32 <bt_mesh_net_transmit_set+0x26>
		return;
	}

	bt_mesh.net_xmit = xmit;
    bd18:	f883 01f9 	strb.w	r0, [r3, #505]	; 0x1f9
    bd1c:	f103 0008 	add.w	r0, r3, #8
    bd20:	f01d fb29 	bl	29376 <atomic_get>

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bd24:	07c3      	lsls	r3, r0, #31
    bd26:	d504      	bpl.n	bd32 <bt_mesh_net_transmit_set+0x26>
	    atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
	}
}
    bd28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bd2c:	2007      	movs	r0, #7
    bd2e:	f009 ba01 	b.w	15134 <bt_mesh_settings_store_schedule>
}
    bd32:	bd08      	pop	{r3, pc}
    bd34:	20001aa8 	.word	0x20001aa8

0000bd38 <bt_mesh_net_transmit_get>:

uint8_t bt_mesh_net_transmit_get(void)
{
	return bt_mesh.net_xmit;
}
    bd38:	4b01      	ldr	r3, [pc, #4]	; (bd40 <bt_mesh_net_transmit_get+0x8>)
    bd3a:	f893 01f9 	ldrb.w	r0, [r3, #505]	; 0x1f9
    bd3e:	4770      	bx	lr
    bd40:	20001aa8 	.word	0x20001aa8

0000bd44 <bt_mesh_relay_set>:

int bt_mesh_relay_set(enum bt_mesh_feat_state relay, uint8_t xmit)
{
    bd44:	b510      	push	{r4, lr}
    bd46:	460c      	mov	r4, r1

	if (!IS_ENABLED(CONFIG_BT_MESH_RELAY)) {
		return -ENOTSUP;
	}

	err = feature_set(BT_MESH_RELAY, relay);
    bd48:	4601      	mov	r1, r0
    bd4a:	2006      	movs	r0, #6
    bd4c:	f7ff ff00 	bl	bb50 <feature_set>
	if (err == -EINVAL) {
    bd50:	f110 0f16 	cmn.w	r0, #22
    bd54:	d016      	beq.n	bd84 <bt_mesh_relay_set+0x40>
		return err;
	}

	if (err == -EALREADY && bt_mesh.relay_xmit == xmit) {
    bd56:	f110 0f78 	cmn.w	r0, #120	; 0x78
    bd5a:	4b0b      	ldr	r3, [pc, #44]	; (bd88 <bt_mesh_relay_set+0x44>)
    bd5c:	d103      	bne.n	bd66 <bt_mesh_relay_set+0x22>
    bd5e:	f893 21fa 	ldrb.w	r2, [r3, #506]	; 0x1fa
    bd62:	42a2      	cmp	r2, r4
    bd64:	d00e      	beq.n	bd84 <bt_mesh_relay_set+0x40>
		return -EALREADY;
	}

	bt_mesh.relay_xmit = xmit;
	bt_mesh_hb_feature_changed(BT_MESH_FEAT_RELAY);
    bd66:	2001      	movs	r0, #1
	bt_mesh.relay_xmit = xmit;
    bd68:	f883 41fa 	strb.w	r4, [r3, #506]	; 0x1fa
	bt_mesh_hb_feature_changed(BT_MESH_FEAT_RELAY);
    bd6c:	f004 fa6e 	bl	1024c <bt_mesh_hb_feature_changed>
    bd70:	4806      	ldr	r0, [pc, #24]	; (bd8c <bt_mesh_relay_set+0x48>)
    bd72:	f01d fb00 	bl	29376 <atomic_get>

	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
    bd76:	f010 0001 	ands.w	r0, r0, #1
    bd7a:	d003      	beq.n	bd84 <bt_mesh_relay_set+0x40>
	    atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
    bd7c:	2007      	movs	r0, #7
    bd7e:	f009 f9d9 	bl	15134 <bt_mesh_settings_store_schedule>
	}

	return 0;
    bd82:	2000      	movs	r0, #0
}
    bd84:	bd10      	pop	{r4, pc}
    bd86:	bf00      	nop
    bd88:	20001aa8 	.word	0x20001aa8
    bd8c:	20001ab0 	.word	0x20001ab0

0000bd90 <cfg_set>:
	}
}

static int cfg_set(const char *name, size_t len_rd,
		   settings_read_cb read_cb, void *cb_arg)
{
    bd90:	b510      	push	{r4, lr}
    bd92:	460c      	mov	r4, r1
    bd94:	b08a      	sub	sp, #40	; 0x28
    bd96:	4610      	mov	r0, r2
    bd98:	4619      	mov	r1, r3
	struct cfg_val cfg;
	int err;

	if (len_rd == 0) {
    bd9a:	b18c      	cbz	r4, bdc0 <cfg_set+0x30>
		BT_DBG("Cleared configuration state");
		return 0;
	}

	err = bt_mesh_settings_set(read_cb, cb_arg, &cfg, sizeof(cfg));
    bd9c:	2307      	movs	r3, #7
    bd9e:	aa02      	add	r2, sp, #8
    bda0:	f009 f98a 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    bda4:	4604      	mov	r4, r0
    bda6:	b170      	cbz	r0, bdc6 <cfg_set+0x36>
		BT_ERR("Failed to set \'cfg\'");
    bda8:	4b16      	ldr	r3, [pc, #88]	; (be04 <cfg_set+0x74>)
    bdaa:	9308      	str	r3, [sp, #32]
    bdac:	2302      	movs	r3, #2
    bdae:	9301      	str	r3, [sp, #4]
    bdb0:	9307      	str	r3, [sp, #28]
    bdb2:	4815      	ldr	r0, [pc, #84]	; (be08 <cfg_set+0x78>)
    bdb4:	2300      	movs	r3, #0
    bdb6:	aa07      	add	r2, sp, #28
    bdb8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    bdbc:	f019 ff8c 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	bt_mesh_default_ttl_set(cfg.default_ttl);

	BT_DBG("Restored configuration state");

	return 0;
}
    bdc0:	4620      	mov	r0, r4
    bdc2:	b00a      	add	sp, #40	; 0x28
    bdc4:	bd10      	pop	{r4, pc}
	bt_mesh_net_transmit_set(cfg.net_transmit);
    bdc6:	f89d 0008 	ldrb.w	r0, [sp, #8]
    bdca:	f7ff ff9f 	bl	bd0c <bt_mesh_net_transmit_set>
	bt_mesh_relay_set(cfg.relay, cfg.relay_retransmit);
    bdce:	f89d 100a 	ldrb.w	r1, [sp, #10]
    bdd2:	f89d 0009 	ldrb.w	r0, [sp, #9]
    bdd6:	f7ff ffb5 	bl	bd44 <bt_mesh_relay_set>
	bt_mesh_beacon_set(cfg.beacon);
    bdda:	f89d 000b 	ldrb.w	r0, [sp, #11]
    bdde:	3800      	subs	r0, #0
    bde0:	bf18      	it	ne
    bde2:	2001      	movne	r0, #1
    bde4:	f7ff fee2 	bl	bbac <bt_mesh_beacon_set>
	bt_mesh_gatt_proxy_set(cfg.gatt_proxy);
    bde8:	f89d 000c 	ldrb.w	r0, [sp, #12]
    bdec:	f7ff ff16 	bl	bc1c <bt_mesh_gatt_proxy_set>
	bt_mesh_friend_set(cfg.frnd);
    bdf0:	f89d 000d 	ldrb.w	r0, [sp, #13]
    bdf4:	f7ff ff66 	bl	bcc4 <bt_mesh_friend_set>
	bt_mesh_default_ttl_set(cfg.default_ttl);
    bdf8:	f89d 000e 	ldrb.w	r0, [sp, #14]
    bdfc:	f7ff ff3e 	bl	bc7c <bt_mesh_default_ttl_set>
	return 0;
    be00:	e7de      	b.n	bdc0 <cfg_set+0x30>
    be02:	bf00      	nop
    be04:	000307d6 	.word	0x000307d6
    be08:	0002daf4 	.word	0x0002daf4

0000be0c <bt_mesh_relay_get>:
{
    be0c:	b508      	push	{r3, lr}
    be0e:	4803      	ldr	r0, [pc, #12]	; (be1c <bt_mesh_relay_get+0x10>)
    be10:	f01d fab1 	bl	29376 <atomic_get>
}
    be14:	f3c0 1080 	ubfx	r0, r0, #6, #1
    be18:	bd08      	pop	{r3, pc}
    be1a:	bf00      	nop
    be1c:	20001ab0 	.word	0x20001ab0

0000be20 <bt_mesh_relay_retransmit_get>:
}
    be20:	4b01      	ldr	r3, [pc, #4]	; (be28 <bt_mesh_relay_retransmit_get+0x8>)
    be22:	f893 01fa 	ldrb.w	r0, [r3, #506]	; 0x1fa
    be26:	4770      	bx	lr
    be28:	20001aa8 	.word	0x20001aa8

0000be2c <bt_mesh_cfg_default_set>:
	bt_mesh.net_xmit =
    be2c:	480c      	ldr	r0, [pc, #48]	; (be60 <bt_mesh_cfg_default_set+0x34>)
{
    be2e:	b508      	push	{r3, lr}
	bt_mesh.net_xmit =
    be30:	230a      	movs	r3, #10
    be32:	f880 31f9 	strb.w	r3, [r0, #505]	; 0x1f9
	bt_mesh.relay_xmit =
    be36:	f240 730a 	movw	r3, #1802	; 0x70a
    be3a:	f8a0 31fa 	strh.w	r3, [r0, #506]	; 0x1fa
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    be3e:	2140      	movs	r1, #64	; 0x40
    be40:	3008      	adds	r0, #8
    be42:	f01d fa9e 	bl	29382 <atomic_or.isra.0>
    be46:	2180      	movs	r1, #128	; 0x80
    be48:	f01d fa9b 	bl	29382 <atomic_or.isra.0>
    be4c:	f44f 7180 	mov.w	r1, #256	; 0x100
    be50:	f01d fa97 	bl	29382 <atomic_or.isra.0>
}
    be54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    be58:	f44f 7100 	mov.w	r1, #512	; 0x200
    be5c:	f01d ba91 	b.w	29382 <atomic_or.isra.0>
    be60:	20001aa8 	.word	0x20001aa8

0000be64 <bt_mesh_cfg_pending_store>:
		BT_HEXDUMP_DBG(&val, sizeof(val), "raw value");
	}
}

void bt_mesh_cfg_pending_store(void)
{
    be64:	b510      	push	{r4, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    be66:	4822      	ldr	r0, [pc, #136]	; (bef0 <bt_mesh_cfg_pending_store+0x8c>)
    be68:	b08a      	sub	sp, #40	; 0x28
    be6a:	f01d fa84 	bl	29376 <atomic_get>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    be6e:	f010 0401 	ands.w	r4, r0, #1
    be72:	d030      	beq.n	bed6 <bt_mesh_cfg_pending_store+0x72>
	return bt_mesh.net_xmit;
    be74:	4a1f      	ldr	r2, [pc, #124]	; (bef4 <bt_mesh_cfg_pending_store+0x90>)
	val.net_transmit = bt_mesh_net_transmit_get();
    be76:	f892 31f9 	ldrb.w	r3, [r2, #505]	; 0x1f9
    be7a:	f88d 3008 	strb.w	r3, [sp, #8]
	val.relay = bt_mesh_relay_get();
    be7e:	f7ff ffc5 	bl	be0c <bt_mesh_relay_get>
	val.relay_retransmit = bt_mesh_relay_retransmit_get();
    be82:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    be86:	f88d 300a 	strb.w	r3, [sp, #10]
	val.relay = bt_mesh_relay_get();
    be8a:	f88d 0009 	strb.w	r0, [sp, #9]
	val.beacon = bt_mesh_beacon_enabled();
    be8e:	f7ff febb 	bl	bc08 <bt_mesh_beacon_enabled>
    be92:	f88d 000b 	strb.w	r0, [sp, #11]
	val.gatt_proxy = bt_mesh_gatt_proxy_get();
    be96:	f7ff fee7 	bl	bc68 <bt_mesh_gatt_proxy_get>
    be9a:	f88d 000c 	strb.w	r0, [sp, #12]
	val.frnd = bt_mesh_friend_get();
    be9e:	f7ff ff2b 	bl	bcf8 <bt_mesh_friend_get>
	err = settings_save_one("bt/mesh/Cfg", &val, sizeof(val));
    bea2:	a902      	add	r1, sp, #8
	val.default_ttl = bt_mesh_default_ttl_get();
    bea4:	f892 31fb 	ldrb.w	r3, [r2, #507]	; 0x1fb
	val.frnd = bt_mesh_friend_get();
    bea8:	f88d 000d 	strb.w	r0, [sp, #13]
	err = settings_save_one("bt/mesh/Cfg", &val, sizeof(val));
    beac:	2207      	movs	r2, #7
    beae:	4812      	ldr	r0, [pc, #72]	; (bef8 <bt_mesh_cfg_pending_store+0x94>)
	val.default_ttl = bt_mesh_default_ttl_get();
    beb0:	f88d 300e 	strb.w	r3, [sp, #14]
	err = settings_save_one("bt/mesh/Cfg", &val, sizeof(val));
    beb4:	f7f7 fea4 	bl	3c00 <settings_save_one>
	if (err) {
    beb8:	b158      	cbz	r0, bed2 <bt_mesh_cfg_pending_store+0x6e>
		BT_ERR("Failed to store configuration value");
    beba:	4b10      	ldr	r3, [pc, #64]	; (befc <bt_mesh_cfg_pending_store+0x98>)
    bebc:	9308      	str	r3, [sp, #32]
    bebe:	2302      	movs	r3, #2
    bec0:	9301      	str	r3, [sp, #4]
    bec2:	9307      	str	r3, [sp, #28]
    bec4:	2300      	movs	r3, #0
    bec6:	480e      	ldr	r0, [pc, #56]	; (bf00 <bt_mesh_cfg_pending_store+0x9c>)
    bec8:	aa07      	add	r2, sp, #28
    beca:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    bece:	f019 ff03 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		store_pending_cfg();
	} else {
		clear_cfg();
	}
}
    bed2:	b00a      	add	sp, #40	; 0x28
    bed4:	bd10      	pop	{r4, pc}
	err = settings_delete("bt/mesh/Cfg");
    bed6:	4808      	ldr	r0, [pc, #32]	; (bef8 <bt_mesh_cfg_pending_store+0x94>)
    bed8:	f01a f98d 	bl	261f6 <settings_delete>
	if (err) {
    bedc:	2800      	cmp	r0, #0
    bede:	d0f8      	beq.n	bed2 <bt_mesh_cfg_pending_store+0x6e>
		BT_ERR("Failed to clear configuration");
    bee0:	4b08      	ldr	r3, [pc, #32]	; (bf04 <bt_mesh_cfg_pending_store+0xa0>)
    bee2:	9308      	str	r3, [sp, #32]
    bee4:	2302      	movs	r3, #2
    bee6:	9302      	str	r3, [sp, #8]
    bee8:	9307      	str	r3, [sp, #28]
    beea:	4623      	mov	r3, r4
    beec:	e7eb      	b.n	bec6 <bt_mesh_cfg_pending_store+0x62>
    beee:	bf00      	nop
    bef0:	20001ab0 	.word	0x20001ab0
    bef4:	20001aa8 	.word	0x20001aa8
    bef8:	000307ea 	.word	0x000307ea
    befc:	000307f6 	.word	0x000307f6
    bf00:	0002daf4 	.word	0x0002daf4
    bf04:	0003081a 	.word	0x0003081a

0000bf08 <bt_mesh_scan_cb>:
	return -ENOTSUP;
}

static void bt_mesh_scan_cb(const bt_addr_le_t *addr, int8_t rssi,
			    uint8_t adv_type, struct net_buf_simple *buf)
{
    bf08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (adv_type != BT_GAP_ADV_TYPE_ADV_NONCONN_IND) {
    bf0c:	2a03      	cmp	r2, #3
{
    bf0e:	b089      	sub	sp, #36	; 0x24
    bf10:	4688      	mov	r8, r1
    bf12:	461c      	mov	r4, r3
	if (adv_type != BT_GAP_ADV_TYPE_ADV_NONCONN_IND) {
    bf14:	d026      	beq.n	bf64 <bt_mesh_scan_cb+0x5c>
		}

		net_buf_simple_restore(buf, &state);
		net_buf_simple_pull(buf, len);
	}
}
    bf16:	b009      	add	sp, #36	; 0x24
    bf18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	state->offset = net_buf_simple_headroom(buf);
    bf1c:	4620      	mov	r0, r4
    bf1e:	f01f ffb0 	bl	2be82 <net_buf_simple_headroom>
    bf22:	4606      	mov	r6, r0
		type = net_buf_simple_pull_u8(buf);
    bf24:	4620      	mov	r0, r4
	state->len = buf->len;
    bf26:	f8b4 9004 	ldrh.w	r9, [r4, #4]
    bf2a:	f01f ff87 	bl	2be3c <net_buf_simple_pull_u8>
		buf->len = len - 1;
    bf2e:	3f01      	subs	r7, #1
		switch (type) {
    bf30:	282a      	cmp	r0, #42	; 0x2a
		buf->len = len - 1;
    bf32:	80a7      	strh	r7, [r4, #4]
		switch (type) {
    bf34:	d007      	beq.n	bf46 <bt_mesh_scan_cb+0x3e>
    bf36:	282b      	cmp	r0, #43	; 0x2b
    bf38:	d02e      	beq.n	bf98 <bt_mesh_scan_cb+0x90>
    bf3a:	2829      	cmp	r0, #41	; 0x29
    bf3c:	d108      	bne.n	bf50 <bt_mesh_scan_cb+0x48>
			bt_mesh_pb_adv_recv(buf);
    bf3e:	4620      	mov	r0, r4
    bf40:	f00c f930 	bl	181a4 <bt_mesh_pb_adv_recv>
			break;
    bf44:	e004      	b.n	bf50 <bt_mesh_scan_cb+0x48>
			bt_mesh_net_recv(buf, rssi, BT_MESH_NET_IF_ADV);
    bf46:	2200      	movs	r2, #0
    bf48:	4641      	mov	r1, r8
    bf4a:	4620      	mov	r0, r4
    bf4c:	f001 f97c 	bl	d248 <bt_mesh_net_recv>
	buf->data = buf->__buf + state->offset;
    bf50:	68a0      	ldr	r0, [r4, #8]
	buf->len = state->len;
    bf52:	f8a4 9004 	strh.w	r9, [r4, #4]
	buf->data = buf->__buf + state->offset;
    bf56:	fa10 f686 	uxtah	r6, r0, r6
    bf5a:	6026      	str	r6, [r4, #0]
		net_buf_simple_pull(buf, len);
    bf5c:	4629      	mov	r1, r5
    bf5e:	4620      	mov	r0, r4
    bf60:	f01f ff5c 	bl	2be1c <net_buf_simple_pull>
	while (buf->len > 1) {
    bf64:	88a3      	ldrh	r3, [r4, #4]
    bf66:	2b01      	cmp	r3, #1
    bf68:	d9d5      	bls.n	bf16 <bt_mesh_scan_cb+0xe>
		len = net_buf_simple_pull_u8(buf);
    bf6a:	4620      	mov	r0, r4
    bf6c:	f01f ff66 	bl	2be3c <net_buf_simple_pull_u8>
		if (len == 0U) {
    bf70:	4605      	mov	r5, r0
    bf72:	2800      	cmp	r0, #0
    bf74:	d0cf      	beq.n	bf16 <bt_mesh_scan_cb+0xe>
		if (len > buf->len) {
    bf76:	88a3      	ldrh	r3, [r4, #4]
    bf78:	b287      	uxth	r7, r0
    bf7a:	42bb      	cmp	r3, r7
    bf7c:	d2ce      	bcs.n	bf1c <bt_mesh_scan_cb+0x14>
			BT_WARN("AD malformed");
    bf7e:	4b08      	ldr	r3, [pc, #32]	; (bfa0 <bt_mesh_scan_cb+0x98>)
    bf80:	9306      	str	r3, [sp, #24]
    bf82:	2302      	movs	r3, #2
    bf84:	9301      	str	r3, [sp, #4]
    bf86:	9305      	str	r3, [sp, #20]
    bf88:	4806      	ldr	r0, [pc, #24]	; (bfa4 <bt_mesh_scan_cb+0x9c>)
    bf8a:	2300      	movs	r3, #0
    bf8c:	aa05      	add	r2, sp, #20
    bf8e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    bf92:	f019 fea1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return;
    bf96:	e7be      	b.n	bf16 <bt_mesh_scan_cb+0xe>
			bt_mesh_beacon_recv(buf);
    bf98:	4620      	mov	r0, r4
    bf9a:	f000 fabb 	bl	c514 <bt_mesh_beacon_recv>
			break;
    bf9e:	e7d7      	b.n	bf50 <bt_mesh_scan_cb+0x48>
    bfa0:	00030844 	.word	0x00030844
    bfa4:	0002dad4 	.word	0x0002dad4

0000bfa8 <bt_mesh_adv_create>:
{
    bfa8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    bfac:	4b1f      	ldr	r3, [pc, #124]	; (c02c <bt_mesh_adv_create+0x84>)
    bfae:	f3bf 8f5b 	dmb	ish
    bfb2:	681b      	ldr	r3, [r3, #0]
    bfb4:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_SUSPENDED)) {
    bfb8:	f3c3 0940 	ubfx	r9, r3, #1, #1
    bfbc:	079b      	lsls	r3, r3, #30
{
    bfbe:	b089      	sub	sp, #36	; 0x24
    bfc0:	4680      	mov	r8, r0
    bfc2:	460c      	mov	r4, r1
    bfc4:	4617      	mov	r7, r2
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_SUSPENDED)) {
    bfc6:	d510      	bpl.n	bfea <bt_mesh_adv_create+0x42>
		BT_WARN("Refusing to allocate buffer while suspended");
    bfc8:	4b19      	ldr	r3, [pc, #100]	; (c030 <bt_mesh_adv_create+0x88>)
    bfca:	9306      	str	r3, [sp, #24]
    bfcc:	2302      	movs	r3, #2
    bfce:	9301      	str	r3, [sp, #4]
    bfd0:	9305      	str	r3, [sp, #20]
    bfd2:	4818      	ldr	r0, [pc, #96]	; (c034 <bt_mesh_adv_create+0x8c>)
    bfd4:	2300      	movs	r3, #0
    bfd6:	aa05      	add	r2, sp, #20
    bfd8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return NULL;
    bfdc:	2600      	movs	r6, #0
    bfde:	f019 fe7b 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
    bfe2:	4630      	mov	r0, r6
    bfe4:	b009      	add	sp, #36	; 0x24
    bfe6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return net_buf_alloc_fixed(pool, timeout);
    bfea:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    bfee:	4812      	ldr	r0, [pc, #72]	; (c038 <bt_mesh_adv_create+0x90>)
    bff0:	f01f fe19 	bl	2bc26 <net_buf_alloc_fixed>
	if (!buf) {
    bff4:	4606      	mov	r6, r0
    bff6:	2800      	cmp	r0, #0
    bff8:	d0f3      	beq.n	bfe2 <bt_mesh_adv_create+0x3a>
	adv = get_id(net_buf_id(buf));
    bffa:	f014 fb8f 	bl	2071c <net_buf_id>
	return &adv_pool[id];
    bffe:	4d0f      	ldr	r5, [pc, #60]	; (c03c <bt_mesh_adv_create+0x94>)
    c000:	220c      	movs	r2, #12
    c002:	fb02 5500 	mla	r5, r2, r0, r5
	BT_MESH_ADV(buf) = adv;
    c006:	6175      	str	r5, [r6, #20]
	(void)memset(adv, 0, sizeof(*adv));
    c008:	4649      	mov	r1, r9
    c00a:	4628      	mov	r0, r5
    c00c:	f01b fc3b 	bl	27886 <memset>
	adv->type         = type;
    c010:	0124      	lsls	r4, r4, #4
    c012:	7a2b      	ldrb	r3, [r5, #8]
	adv->xmit         = xmit;
    c014:	726f      	strb	r7, [r5, #9]
	adv->type         = type;
    c016:	f004 0470 	and.w	r4, r4, #112	; 0x70
    c01a:	f008 0803 	and.w	r8, r8, #3
    c01e:	ea44 0408 	orr.w	r4, r4, r8
    c022:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    c026:	431c      	orrs	r4, r3
    c028:	722c      	strb	r4, [r5, #8]
	return bt_mesh_adv_create_from_pool(&adv_buf_pool, adv_alloc, type,
    c02a:	e7da      	b.n	bfe2 <bt_mesh_adv_create+0x3a>
    c02c:	20001ab0 	.word	0x20001ab0
    c030:	00030851 	.word	0x00030851
    c034:	0002dad4 	.word	0x0002dad4
    c038:	20000fb8 	.word	0x20000fb8
    c03c:	200026c0 	.word	0x200026c0

0000c040 <bt_mesh_adv_buf_get>:
{
    c040:	4602      	mov	r2, r0
    c042:	460b      	mov	r3, r1
	return net_buf_get(&bt_mesh_adv_queue, timeout);
    c044:	4801      	ldr	r0, [pc, #4]	; (c04c <bt_mesh_adv_buf_get+0xc>)
    c046:	f01f bdf3 	b.w	2bc30 <net_buf_get>
    c04a:	bf00      	nop
    c04c:	20000f44 	.word	0x20000f44

0000c050 <bt_mesh_adv_buf_get_cancel>:
	z_impl_k_queue_cancel_wait(queue);
    c050:	4801      	ldr	r0, [pc, #4]	; (c058 <bt_mesh_adv_buf_get_cancel+0x8>)
    c052:	f020 bda3 	b.w	2cb9c <z_impl_k_queue_cancel_wait>
    c056:	bf00      	nop
    c058:	20000f44 	.word	0x20000f44

0000c05c <bt_mesh_adv_send>:
{
    c05c:	b510      	push	{r4, lr}
	BT_MESH_ADV(buf)->cb = cb;
    c05e:	6944      	ldr	r4, [r0, #20]
	BT_MESH_ADV(buf)->cb_data = cb_data;
    c060:	e9c4 1200 	strd	r1, r2, [r4]
	BT_MESH_ADV(buf)->busy = 1U;
    c064:	6942      	ldr	r2, [r0, #20]
    c066:	7a13      	ldrb	r3, [r2, #8]
    c068:	f043 0308 	orr.w	r3, r3, #8
    c06c:	7213      	strb	r3, [r2, #8]
	net_buf_put(&bt_mesh_adv_queue, net_buf_ref(buf));
    c06e:	f01f fe2d 	bl	2bccc <net_buf_ref>
    c072:	4601      	mov	r1, r0
    c074:	4803      	ldr	r0, [pc, #12]	; (c084 <bt_mesh_adv_send+0x28>)
    c076:	f01f fe1c 	bl	2bcb2 <net_buf_put>
}
    c07a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_mesh_adv_buf_local_ready();
    c07e:	f01e b8f3 	b.w	2a268 <bt_mesh_adv_buf_local_ready>
    c082:	bf00      	nop
    c084:	20000f44 	.word	0x20000f44

0000c088 <bt_mesh_scan_enable>:

int bt_mesh_scan_enable(void)
{
    c088:	b510      	push	{r4, lr}
    c08a:	b08c      	sub	sp, #48	; 0x30
	struct bt_le_scan_param scan_param = {
    c08c:	2214      	movs	r2, #20
    c08e:	2100      	movs	r1, #0
    c090:	a801      	add	r0, sp, #4
    c092:	f01b fbf8 	bl	27886 <memset>
    c096:	f04f 1330 	mov.w	r3, #3145776	; 0x300030
			.window     = MESH_SCAN_WINDOW };
	int err;

	BT_DBG("");

	err = bt_le_scan_start(&scan_param, bt_mesh_scan_cb);
    c09a:	490e      	ldr	r1, [pc, #56]	; (c0d4 <bt_mesh_scan_enable+0x4c>)
	struct bt_le_scan_param scan_param = {
    c09c:	9303      	str	r3, [sp, #12]
	err = bt_le_scan_start(&scan_param, bt_mesh_scan_cb);
    c09e:	a801      	add	r0, sp, #4
    c0a0:	f7fb fe70 	bl	7d84 <bt_le_scan_start>
	if (err && err != -EALREADY) {
    c0a4:	4604      	mov	r4, r0
    c0a6:	b178      	cbz	r0, c0c8 <bt_mesh_scan_enable+0x40>
    c0a8:	f110 0f78 	cmn.w	r0, #120	; 0x78
    c0ac:	d00f      	beq.n	c0ce <bt_mesh_scan_enable+0x46>
		BT_ERR("starting scan failed (err %d)", err);
    c0ae:	4b0a      	ldr	r3, [pc, #40]	; (c0d8 <bt_mesh_scan_enable+0x50>)
    c0b0:	e9cd 300a 	strd	r3, r0, [sp, #40]	; 0x28
    c0b4:	2303      	movs	r3, #3
    c0b6:	9300      	str	r3, [sp, #0]
    c0b8:	9309      	str	r3, [sp, #36]	; 0x24
    c0ba:	4808      	ldr	r0, [pc, #32]	; (c0dc <bt_mesh_scan_enable+0x54>)
    c0bc:	2300      	movs	r3, #0
    c0be:	aa09      	add	r2, sp, #36	; 0x24
    c0c0:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    c0c4:	f019 fe08 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
	}

	return 0;
}
    c0c8:	4620      	mov	r0, r4
    c0ca:	b00c      	add	sp, #48	; 0x30
    c0cc:	bd10      	pop	{r4, pc}
	return 0;
    c0ce:	2400      	movs	r4, #0
    c0d0:	e7fa      	b.n	c0c8 <bt_mesh_scan_enable+0x40>
    c0d2:	bf00      	nop
    c0d4:	0000bf09 	.word	0x0000bf09
    c0d8:	0003087d 	.word	0x0003087d
    c0dc:	0002dad4 	.word	0x0002dad4

0000c0e0 <bt_mesh_scan_disable>:

int bt_mesh_scan_disable(void)
{
    c0e0:	b510      	push	{r4, lr}
    c0e2:	b088      	sub	sp, #32
	int err;

	BT_DBG("");

	err = bt_le_scan_stop();
    c0e4:	f7fb ff1a 	bl	7f1c <bt_le_scan_stop>
	if (err && err != -EALREADY) {
    c0e8:	4604      	mov	r4, r0
    c0ea:	b178      	cbz	r0, c10c <bt_mesh_scan_disable+0x2c>
    c0ec:	f110 0f78 	cmn.w	r0, #120	; 0x78
    c0f0:	d00f      	beq.n	c112 <bt_mesh_scan_disable+0x32>
		BT_ERR("stopping scan failed (err %d)", err);
    c0f2:	4b09      	ldr	r3, [pc, #36]	; (c118 <bt_mesh_scan_disable+0x38>)
    c0f4:	e9cd 3006 	strd	r3, r0, [sp, #24]
    c0f8:	2303      	movs	r3, #3
    c0fa:	9301      	str	r3, [sp, #4]
    c0fc:	9305      	str	r3, [sp, #20]
    c0fe:	4807      	ldr	r0, [pc, #28]	; (c11c <bt_mesh_scan_disable+0x3c>)
    c100:	2300      	movs	r3, #0
    c102:	aa05      	add	r2, sp, #20
    c104:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    c108:	f019 fde6 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
	}

	return 0;
}
    c10c:	4620      	mov	r0, r4
    c10e:	b008      	add	sp, #32
    c110:	bd10      	pop	{r4, pc}
	return 0;
    c112:	2400      	movs	r4, #0
    c114:	e7fa      	b.n	c10c <bt_mesh_scan_disable+0x2c>
    c116:	bf00      	nop
    c118:	0003089b 	.word	0x0003089b
    c11c:	0002dad4 	.word	0x0002dad4

0000c120 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    c120:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    c122:	ab0a      	add	r3, sp, #40	; 0x28
    c124:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    c126:	9302      	str	r3, [sp, #8]
    c128:	4b05      	ldr	r3, [pc, #20]	; (c140 <z_log_msg2_runtime_create.constprop.0+0x20>)
    c12a:	9301      	str	r3, [sp, #4]
    c12c:	2300      	movs	r3, #0
    c12e:	9300      	str	r3, [sp, #0]
    c130:	2202      	movs	r2, #2
    c132:	4618      	mov	r0, r3
    c134:	f7f7 f8b8 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    c138:	b007      	add	sp, #28
    c13a:	f85d fb04 	ldr.w	pc, [sp], #4
    c13e:	bf00      	nop
    c140:	000308c9 	.word	0x000308c9

0000c144 <subnet_by_id>:

	return true;
}

static bool subnet_by_id(struct bt_mesh_subnet *sub, void *cb_data)
{
    c144:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		BT_WARN("Authentication Value %s != %s",
    c148:	f8df b08c 	ldr.w	fp, [pc, #140]	; c1d8 <subnet_by_id+0x94>
{
    c14c:	b087      	sub	sp, #28
    c14e:	460c      	mov	r4, r1
	struct beacon_params *params = cb_data;

	for (int i = 0; i < ARRAY_SIZE(sub->keys); i++) {
    c150:	f100 0576 	add.w	r5, r0, #118	; 0x76
    c154:	f04f 0800 	mov.w	r8, #0
		if (sub->keys[i].valid && auth_match(&sub->keys[i], params)) {
    c158:	f815 7c4a 	ldrb.w	r7, [r5, #-74]
    c15c:	b367      	cbz	r7, c1b8 <subnet_by_id+0x74>
	if (memcmp(params->net_id, keys->net_id, 8)) {
    c15e:	f1a5 0a18 	sub.w	sl, r5, #24
    c162:	6820      	ldr	r0, [r4, #0]
    c164:	2208      	movs	r2, #8
    c166:	4651      	mov	r1, sl
    c168:	f01b fb71 	bl	2784e <memcmp>
    c16c:	4606      	mov	r6, r0
    c16e:	bb18      	cbnz	r0, c1b8 <subnet_by_id+0x74>
	bt_mesh_beacon_auth(keys->beacon, params->flags, keys->net_id,
    c170:	f10d 0910 	add.w	r9, sp, #16
    c174:	7b21      	ldrb	r1, [r4, #12]
    c176:	68a3      	ldr	r3, [r4, #8]
    c178:	f8cd 9000 	str.w	r9, [sp]
    c17c:	4652      	mov	r2, sl
    c17e:	4628      	mov	r0, r5
    c180:	f01d fedc 	bl	29f3c <bt_mesh_beacon_auth>
	if (memcmp(params->auth, net_auth, 8)) {
    c184:	6860      	ldr	r0, [r4, #4]
    c186:	2208      	movs	r2, #8
    c188:	4649      	mov	r1, r9
    c18a:	f01b fb60 	bl	2784e <memcmp>
    c18e:	b1e0      	cbz	r0, c1ca <subnet_by_id+0x86>
		BT_WARN("Authentication Value %s != %s",
    c190:	2108      	movs	r1, #8
    c192:	6860      	ldr	r0, [r4, #4]
    c194:	f7f8 ffe0 	bl	5158 <bt_hex_real>
    c198:	2108      	movs	r1, #8
    c19a:	4607      	mov	r7, r0
    c19c:	4648      	mov	r0, r9
    c19e:	f7f8 ffdb 	bl	5158 <bt_hex_real>
    c1a2:	4b0e      	ldr	r3, [pc, #56]	; (c1dc <subnet_by_id+0x98>)
    c1a4:	e9cd 7002 	strd	r7, r0, [sp, #8]
    c1a8:	e9cd 6300 	strd	r6, r3, [sp]
    c1ac:	2202      	movs	r2, #2
    c1ae:	4633      	mov	r3, r6
    c1b0:	4659      	mov	r1, fp
    c1b2:	4630      	mov	r0, r6
    c1b4:	f7ff ffb4 	bl	c120 <z_log_msg2_runtime_create.constprop.0>
	for (int i = 0; i < ARRAY_SIZE(sub->keys); i++) {
    c1b8:	355a      	adds	r5, #90	; 0x5a
    c1ba:	f1b8 0f00 	cmp.w	r8, #0
    c1be:	d001      	beq.n	c1c4 <subnet_by_id+0x80>
			params->new_key = (i > 0);
			return true;
		}
	}

	return false;
    c1c0:	2700      	movs	r7, #0
    c1c2:	e004      	b.n	c1ce <subnet_by_id+0x8a>
    c1c4:	f04f 0801 	mov.w	r8, #1
    c1c8:	e7c6      	b.n	c158 <subnet_by_id+0x14>
			params->new_key = (i > 0);
    c1ca:	f884 800d 	strb.w	r8, [r4, #13]
}
    c1ce:	4638      	mov	r0, r7
    c1d0:	b007      	add	sp, #28
    c1d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c1d6:	bf00      	nop
    c1d8:	0002daec 	.word	0x0002daec
    c1dc:	000308c9 	.word	0x000308c9

0000c1e0 <beacon_send>:
{
    c1e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c1e4:	b08e      	sub	sp, #56	; 0x38
	if (bt_mesh_is_provisioned()) {
    c1e6:	f7ff fbeb 	bl	b9c0 <bt_mesh_is_provisioned>
    c1ea:	b318      	cbz	r0, c234 <beacon_send+0x54>
		if (!bt_mesh_beacon_enabled() &&
    c1ec:	f7ff fd0c 	bl	bc08 <bt_mesh_beacon_enabled>
    c1f0:	b1a8      	cbz	r0, c21e <beacon_send+0x3e>
	first_half = !first_half;
    c1f2:	4a57      	ldr	r2, [pc, #348]	; (c350 <beacon_send+0x170>)
    c1f4:	7813      	ldrb	r3, [r2, #0]
    c1f6:	f083 0301 	eor.w	r3, r3, #1
    c1fa:	7013      	strb	r3, [r2, #0]
	if (first_half) {
    c1fc:	b913      	cbnz	r3, c204 <beacon_send+0x24>
	bt_mesh_subnet_foreach(sub_update_beacon_observation);
    c1fe:	4855      	ldr	r0, [pc, #340]	; (c354 <beacon_send+0x174>)
    c200:	f001 fc42 	bl	da88 <bt_mesh_subnet_foreach>
		(void)bt_mesh_subnet_find(secure_beacon_send, NULL);
    c204:	4854      	ldr	r0, [pc, #336]	; (c358 <beacon_send+0x178>)
    c206:	2100      	movs	r1, #0
    c208:	f001 fc1a 	bl	da40 <bt_mesh_subnet_find>
		k_work_schedule(&beacon_timer, PROVISIONED_INTERVAL);
    c20c:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
		k_work_schedule(&beacon_timer, K_SECONDS(CONFIG_BT_MESH_UNPROV_BEACON_INT));
    c210:	4852      	ldr	r0, [pc, #328]	; (c35c <beacon_send+0x17c>)
    c212:	2300      	movs	r3, #0
}
    c214:	b00e      	add	sp, #56	; 0x38
    c216:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		k_work_schedule(&beacon_timer, K_SECONDS(CONFIG_BT_MESH_UNPROV_BEACON_INT));
    c21a:	f018 b86f 	b.w	242fc <k_work_schedule>
    c21e:	4b50      	ldr	r3, [pc, #320]	; (c360 <beacon_send+0x180>)
    c220:	f3bf 8f5b 	dmb	ish
    c224:	681b      	ldr	r3, [r3, #0]
    c226:	f3bf 8f5b 	dmb	ish
		if (!bt_mesh_beacon_enabled() &&
    c22a:	071b      	lsls	r3, r3, #28
    c22c:	d4e1      	bmi.n	c1f2 <beacon_send+0x12>
}
    c22e:	b00e      	add	sp, #56	; 0x38
    c230:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!bt_mesh_prov_active()) {
    c234:	f00a fce4 	bl	16c00 <bt_mesh_prov_active>
    c238:	4604      	mov	r4, r0
    c23a:	b9c8      	cbnz	r0, c270 <beacon_send+0x90>
				 UNPROV_XMIT, K_NO_WAIT);
    c23c:	2200      	movs	r2, #0
    c23e:	2300      	movs	r3, #0
	uint8_t uri_hash[16] = { 0 };
    c240:	e9cd 0004 	strd	r0, r0, [sp, #16]
    c244:	e9cd 0006 	strd	r0, r0, [sp, #24]
	buf = bt_mesh_adv_create(BT_MESH_ADV_BEACON, BT_MESH_LOCAL_ADV,
    c248:	e9cd 2300 	strd	r2, r3, [sp]
    c24c:	2101      	movs	r1, #1
    c24e:	220a      	movs	r2, #10
    c250:	2002      	movs	r0, #2
    c252:	f7ff fea9 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
    c256:	4606      	mov	r6, r0
    c258:	b968      	cbnz	r0, c276 <beacon_send+0x96>
		BT_ERR("Unable to allocate beacon buffer");
    c25a:	4b42      	ldr	r3, [pc, #264]	; (c364 <beacon_send+0x184>)
			BT_ERR("Unable to allocate URI buffer");
    c25c:	930c      	str	r3, [sp, #48]	; 0x30
    c25e:	4842      	ldr	r0, [pc, #264]	; (c368 <beacon_send+0x188>)
    c260:	2302      	movs	r3, #2
    c262:	aa0b      	add	r2, sp, #44	; 0x2c
    c264:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    c268:	9302      	str	r3, [sp, #8]
    c26a:	930b      	str	r3, [sp, #44]	; 0x2c
    c26c:	f01d f8e8 	bl	29440 <z_log_msg2_static_create.constprop.0>
		k_work_schedule(&beacon_timer, K_SECONDS(CONFIG_BT_MESH_UNPROV_BEACON_INT));
    c270:	f44f 3220 	mov.w	r2, #163840	; 0x28000
    c274:	e7cc      	b.n	c210 <beacon_send+0x30>
	prov = bt_mesh_prov_get();
    c276:	f00a fcbd 	bl	16bf4 <bt_mesh_prov_get>
	return net_buf_simple_add_u8(&buf->b, val);
    c27a:	f106 0708 	add.w	r7, r6, #8
    c27e:	4605      	mov	r5, r0
    c280:	4621      	mov	r1, r4
    c282:	4638      	mov	r0, r7
    c284:	f01f fd69 	bl	2bd5a <net_buf_simple_add_u8>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    c288:	6829      	ldr	r1, [r5, #0]
    c28a:	2210      	movs	r2, #16
    c28c:	4638      	mov	r0, r7
    c28e:	f01f fd5b 	bl	2bd48 <net_buf_simple_add_mem>
	if (prov->uri && bt_mesh_s1(prov->uri, uri_hash) == 0) {
    c292:	f8d5 8004 	ldr.w	r8, [r5, #4]
    c296:	f1b8 0f00 	cmp.w	r8, #0
    c29a:	d032      	beq.n	c302 <beacon_send+0x122>

static inline bool bt_mesh_s1(const char *m, uint8_t salt[16])
{
	const uint8_t zero[16] = { 0 };

	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
    c29c:	4640      	mov	r0, r8
	const uint8_t zero[16] = { 0 };
    c29e:	e9cd 4408 	strd	r4, r4, [sp, #32]
    c2a2:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
    c2a6:	f01b faa5 	bl	277f4 <strlen>
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
    c2aa:	ab04      	add	r3, sp, #16
	struct bt_mesh_sg sg = { m, len };
    c2ac:	e9cd 8002 	strd	r8, r0, [sp, #8]
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
    c2b0:	2201      	movs	r2, #1
    c2b2:	a902      	add	r1, sp, #8
    c2b4:	a808      	add	r0, sp, #32
    c2b6:	f01d fcdb 	bl	29c70 <bt_mesh_aes_cmac>
    c2ba:	bb10      	cbnz	r0, c302 <beacon_send+0x122>
		oob_info = prov->oob_info | BT_MESH_PROV_OOB_URI;
    c2bc:	8929      	ldrh	r1, [r5, #8]
    c2be:	f041 0102 	orr.w	r1, r1, #2
	net_buf_simple_add_be16(&buf->b, val);
    c2c2:	4638      	mov	r0, r7
    c2c4:	f01f fd5b 	bl	2bd7e <net_buf_simple_add_be16>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    c2c8:	2204      	movs	r2, #4
    c2ca:	a904      	add	r1, sp, #16
    c2cc:	4638      	mov	r0, r7
    c2ce:	f01f fd3b 	bl	2bd48 <net_buf_simple_add_mem>
	bt_mesh_adv_send(buf, NULL, NULL);
    c2d2:	2200      	movs	r2, #0
    c2d4:	4611      	mov	r1, r2
    c2d6:	4630      	mov	r0, r6
    c2d8:	f7ff fec0 	bl	c05c <bt_mesh_adv_send>
	net_buf_unref(buf);
    c2dc:	4630      	mov	r0, r6
    c2de:	f014 fad9 	bl	20894 <net_buf_unref>
	if (prov->uri) {
    c2e2:	686b      	ldr	r3, [r5, #4]
    c2e4:	2b00      	cmp	r3, #0
    c2e6:	d0c3      	beq.n	c270 <beacon_send+0x90>
					 UNPROV_XMIT, K_NO_WAIT);
    c2e8:	2200      	movs	r2, #0
    c2ea:	2300      	movs	r3, #0
		buf = bt_mesh_adv_create(BT_MESH_ADV_URI, BT_MESH_LOCAL_ADV,
    c2ec:	e9cd 2300 	strd	r2, r3, [sp]
    c2f0:	2101      	movs	r1, #1
    c2f2:	220a      	movs	r2, #10
    c2f4:	2003      	movs	r0, #3
    c2f6:	f7ff fe57 	bl	bfa8 <bt_mesh_adv_create>
		if (!buf) {
    c2fa:	4604      	mov	r4, r0
    c2fc:	b918      	cbnz	r0, c306 <beacon_send+0x126>
			BT_ERR("Unable to allocate URI buffer");
    c2fe:	4b1b      	ldr	r3, [pc, #108]	; (c36c <beacon_send+0x18c>)
    c300:	e7ac      	b.n	c25c <beacon_send+0x7c>
		oob_info = prov->oob_info;
    c302:	8929      	ldrh	r1, [r5, #8]
    c304:	e7dd      	b.n	c2c2 <beacon_send+0xe2>
		len = strlen(prov->uri);
    c306:	6868      	ldr	r0, [r5, #4]
    c308:	f01b fa74 	bl	277f4 <strlen>
	return net_buf_simple_tailroom(&buf->b);
    c30c:	f104 0708 	add.w	r7, r4, #8
    c310:	4606      	mov	r6, r0
    c312:	4638      	mov	r0, r7
    c314:	f01f fdb9 	bl	2be8a <net_buf_simple_tailroom>
		if (net_buf_tailroom(buf) < len) {
    c318:	4286      	cmp	r6, r0
    c31a:	d90e      	bls.n	c33a <beacon_send+0x15a>
			BT_WARN("Too long URI to fit advertising data");
    c31c:	4b14      	ldr	r3, [pc, #80]	; (c370 <beacon_send+0x190>)
    c31e:	930c      	str	r3, [sp, #48]	; 0x30
    c320:	4811      	ldr	r0, [pc, #68]	; (c368 <beacon_send+0x188>)
    c322:	2302      	movs	r3, #2
    c324:	aa0b      	add	r2, sp, #44	; 0x2c
    c326:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    c32a:	9302      	str	r3, [sp, #8]
    c32c:	930b      	str	r3, [sp, #44]	; 0x2c
    c32e:	f01d f887 	bl	29440 <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
    c332:	4620      	mov	r0, r4
    c334:	f014 faae 	bl	20894 <net_buf_unref>
    c338:	e79a      	b.n	c270 <beacon_send+0x90>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    c33a:	6869      	ldr	r1, [r5, #4]
    c33c:	4632      	mov	r2, r6
    c33e:	4638      	mov	r0, r7
    c340:	f01f fd02 	bl	2bd48 <net_buf_simple_add_mem>
			bt_mesh_adv_send(buf, NULL, NULL);
    c344:	2200      	movs	r2, #0
    c346:	4611      	mov	r1, r2
    c348:	4620      	mov	r0, r4
    c34a:	f7ff fe87 	bl	c05c <bt_mesh_adv_send>
    c34e:	e7f0      	b.n	c332 <beacon_send+0x152>
    c350:	20003aea 	.word	0x20003aea
    c354:	00029425 	.word	0x00029425
    c358:	0000c3c9 	.word	0x0000c3c9
    c35c:	20001a78 	.word	0x20001a78
    c360:	20001ab0 	.word	0x20001ab0
    c364:	000308e7 	.word	0x000308e7
    c368:	0002daec 	.word	0x0002daec
    c36c:	00030908 	.word	0x00030908
    c370:	00030926 	.word	0x00030926

0000c374 <bt_mesh_beacon_create>:
{
    c374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c376:	460c      	mov	r4, r1
    c378:	4605      	mov	r5, r0
	uint8_t flags = bt_mesh_net_flags(sub);
    c37a:	f001 fa0d 	bl	d798 <bt_mesh_net_flags>
	net_buf_simple_add_u8(buf, BEACON_TYPE_SECURE);
    c37e:	2101      	movs	r1, #1
	uint8_t flags = bt_mesh_net_flags(sub);
    c380:	4607      	mov	r7, r0
	net_buf_simple_add_u8(buf, BEACON_TYPE_SECURE);
    c382:	4620      	mov	r0, r4
    c384:	f01f fce9 	bl	2bd5a <net_buf_simple_add_u8>
	keys = &sub->keys[SUBNET_KEY_TX_IDX(sub)];
    c388:	7fae      	ldrb	r6, [r5, #30]
    c38a:	1eb3      	subs	r3, r6, #2
    c38c:	425e      	negs	r6, r3
	net_buf_simple_add_u8(buf, flags);
    c38e:	4639      	mov	r1, r7
    c390:	4620      	mov	r0, r4
	keys = &sub->keys[SUBNET_KEY_TX_IDX(sub)];
    c392:	415e      	adcs	r6, r3
	net_buf_simple_add_u8(buf, flags);
    c394:	f01f fce1 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_mem(buf, keys->net_id, 8);
    c398:	215a      	movs	r1, #90	; 0x5a
    c39a:	fb01 5106 	mla	r1, r1, r6, r5
    c39e:	2208      	movs	r2, #8
    c3a0:	315e      	adds	r1, #94	; 0x5e
    c3a2:	4620      	mov	r0, r4
    c3a4:	f01f fcd0 	bl	2bd48 <net_buf_simple_add_mem>
	net_buf_simple_add_be32(buf, bt_mesh.iv_index);
    c3a8:	4b06      	ldr	r3, [pc, #24]	; (c3c4 <bt_mesh_beacon_create+0x50>)
    c3aa:	4620      	mov	r0, r4
    c3ac:	6819      	ldr	r1, [r3, #0]
    c3ae:	f01f fcfd 	bl	2bdac <net_buf_simple_add_be32>
	net_buf_simple_add_mem(buf, sub->auth, 8);
    c3b2:	f105 0124 	add.w	r1, r5, #36	; 0x24
    c3b6:	4620      	mov	r0, r4
    c3b8:	2208      	movs	r2, #8
}
    c3ba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	net_buf_simple_add_mem(buf, sub->auth, 8);
    c3be:	f01f bcc3 	b.w	2bd48 <net_buf_simple_add_mem>
    c3c2:	bf00      	nop
    c3c4:	20001aa8 	.word	0x20001aa8

0000c3c8 <secure_beacon_send>:
{
    c3c8:	b530      	push	{r4, r5, lr}
    c3ca:	4604      	mov	r4, r0
    c3cc:	b08b      	sub	sp, #44	; 0x2c
	return z_impl_k_uptime_ticks();
    c3ce:	f020 febf 	bl	2d150 <z_impl_k_uptime_ticks>
			return ((t * to_hz + off) / from_hz);
    c3d2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c3d6:	fba0 3002 	umull	r3, r0, r0, r2
    c3da:	fb02 0001 	mla	r0, r2, r1, r0
    c3de:	0bdb      	lsrs	r3, r3, #15
	time_diff = now - sub->beacon_sent;
    c3e0:	6822      	ldr	r2, [r4, #0]
    c3e2:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
    c3e6:	1a9b      	subs	r3, r3, r2
	if (time_diff < (600 * MSEC_PER_SEC) &&
    c3e8:	4a1a      	ldr	r2, [pc, #104]	; (c454 <secure_beacon_send+0x8c>)
    c3ea:	4293      	cmp	r3, r2
    c3ec:	d809      	bhi.n	c402 <secure_beacon_send+0x3a>
		time_diff < BEACON_THRESHOLD(sub)) {
    c3ee:	7922      	ldrb	r2, [r4, #4]
    c3f0:	f242 7110 	movw	r1, #10000	; 0x2710
    c3f4:	fb02 1101 	mla	r1, r2, r1, r1
    c3f8:	f5a1 519c 	sub.w	r1, r1, #4992	; 0x1380
    c3fc:	3908      	subs	r1, #8
	if (time_diff < (600 * MSEC_PER_SEC) &&
    c3fe:	428b      	cmp	r3, r1
    c400:	d325      	bcc.n	c44e <secure_beacon_send+0x86>
				 PROV_XMIT, K_NO_WAIT);
    c402:	2200      	movs	r2, #0
    c404:	2300      	movs	r3, #0
	buf = bt_mesh_adv_create(BT_MESH_ADV_BEACON, BT_MESH_LOCAL_ADV,
    c406:	e9cd 2300 	strd	r2, r3, [sp]
    c40a:	2101      	movs	r1, #1
    c40c:	2208      	movs	r2, #8
    c40e:	2002      	movs	r0, #2
    c410:	f7ff fdca 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
    c414:	4605      	mov	r5, r0
    c416:	b968      	cbnz	r0, c434 <secure_beacon_send+0x6c>
		BT_ERR("Unable to allocate beacon buffer");
    c418:	4b0f      	ldr	r3, [pc, #60]	; (c458 <secure_beacon_send+0x90>)
    c41a:	4810      	ldr	r0, [pc, #64]	; (c45c <secure_beacon_send+0x94>)
    c41c:	9308      	str	r3, [sp, #32]
    c41e:	aa07      	add	r2, sp, #28
    c420:	2302      	movs	r3, #2
    c422:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    c426:	9303      	str	r3, [sp, #12]
    c428:	9307      	str	r3, [sp, #28]
    c42a:	f01d f809 	bl	29440 <z_log_msg2_static_create.constprop.0>
		return true; /* Bail out */
    c42e:	2001      	movs	r0, #1
}
    c430:	b00b      	add	sp, #44	; 0x2c
    c432:	bd30      	pop	{r4, r5, pc}
	bt_mesh_beacon_create(sub, &buf->b);
    c434:	f100 0108 	add.w	r1, r0, #8
    c438:	4620      	mov	r0, r4
    c43a:	f7ff ff9b 	bl	c374 <bt_mesh_beacon_create>
	bt_mesh_adv_send(buf, &send_cb, sub);
    c43e:	4628      	mov	r0, r5
    c440:	4907      	ldr	r1, [pc, #28]	; (c460 <secure_beacon_send+0x98>)
    c442:	4622      	mov	r2, r4
    c444:	f7ff fe0a 	bl	c05c <bt_mesh_adv_send>
	net_buf_unref(buf);
    c448:	4628      	mov	r0, r5
    c44a:	f014 fa23 	bl	20894 <net_buf_unref>
		return false;
    c44e:	2000      	movs	r0, #0
    c450:	e7ee      	b.n	c430 <secure_beacon_send+0x68>
    c452:	bf00      	nop
    c454:	000927bf 	.word	0x000927bf
    c458:	000308e7 	.word	0x000308e7
    c45c:	0002daec 	.word	0x0002daec
    c460:	0002e414 	.word	0x0002e414

0000c464 <bt_mesh_beacon_update>:
		break;
	}
}

void bt_mesh_beacon_update(struct bt_mesh_subnet *sub)
{
    c464:	b520      	push	{r5, lr}
    c466:	4605      	mov	r5, r0
    c468:	b08a      	sub	sp, #40	; 0x28
	uint8_t flags = bt_mesh_net_flags(sub);
    c46a:	f001 f995 	bl	d798 <bt_mesh_net_flags>
	struct bt_mesh_subnet_keys *keys;
	int err;

	keys = &sub->keys[SUBNET_KEY_TX_IDX(sub)];
    c46e:	7fab      	ldrb	r3, [r5, #30]
    c470:	1e9a      	subs	r2, r3, #2
    c472:	4253      	negs	r3, r2
    c474:	4153      	adcs	r3, r2
	uint8_t flags = bt_mesh_net_flags(sub);
    c476:	4601      	mov	r1, r0

	BT_DBG("NetIndex 0x%03x Using %s key", sub->net_idx,
	       SUBNET_KEY_TX_IDX(sub) ? "new" : "current");
	BT_DBG("flags 0x%02x, IVI 0x%08x", flags, bt_mesh.iv_index);

	err = bt_mesh_beacon_auth(keys->beacon, flags, keys->net_id,
    c478:	205a      	movs	r0, #90	; 0x5a
    c47a:	4343      	muls	r3, r0
    c47c:	f103 025e 	add.w	r2, r3, #94	; 0x5e
    c480:	f103 0076 	add.w	r0, r3, #118	; 0x76
				   bt_mesh.iv_index, sub->auth);
    c484:	f105 0324 	add.w	r3, r5, #36	; 0x24
	err = bt_mesh_beacon_auth(keys->beacon, flags, keys->net_id,
    c488:	9300      	str	r3, [sp, #0]
    c48a:	4b0b      	ldr	r3, [pc, #44]	; (c4b8 <bt_mesh_beacon_update+0x54>)
    c48c:	442a      	add	r2, r5
    c48e:	681b      	ldr	r3, [r3, #0]
    c490:	4428      	add	r0, r5
    c492:	f01d fd53 	bl	29f3c <bt_mesh_beacon_auth>
	if (err) {
    c496:	b160      	cbz	r0, c4b2 <bt_mesh_beacon_update+0x4e>
		BT_ERR("Failed updating net beacon for 0x%03x", sub->net_idx);
    c498:	8bab      	ldrh	r3, [r5, #28]
    c49a:	4a08      	ldr	r2, [pc, #32]	; (c4bc <bt_mesh_beacon_update+0x58>)
    c49c:	4808      	ldr	r0, [pc, #32]	; (c4c0 <bt_mesh_beacon_update+0x5c>)
    c49e:	e9cd 2308 	strd	r2, r3, [sp, #32]
    c4a2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    c4a6:	2303      	movs	r3, #3
    c4a8:	aa07      	add	r2, sp, #28
    c4aa:	9303      	str	r3, [sp, #12]
    c4ac:	9307      	str	r3, [sp, #28]
    c4ae:	f01c ffc7 	bl	29440 <z_log_msg2_static_create.constprop.0>
	}
}
    c4b2:	b00a      	add	sp, #40	; 0x28
    c4b4:	bd20      	pop	{r5, pc}
    c4b6:	bf00      	nop
    c4b8:	20001aa8 	.word	0x20001aa8
    c4bc:	0003094b 	.word	0x0003094b
    c4c0:	0002daec 	.word	0x0002daec

0000c4c4 <bt_mesh_beacon_init>:
	.evt_handler = subnet_evt,
};

void bt_mesh_beacon_init(void)
{
	k_work_init_delayable(&beacon_timer, beacon_send);
    c4c4:	4901      	ldr	r1, [pc, #4]	; (c4cc <bt_mesh_beacon_init+0x8>)
    c4c6:	4802      	ldr	r0, [pc, #8]	; (c4d0 <bt_mesh_beacon_init+0xc>)
    c4c8:	f020 bc8f 	b.w	2cdea <k_work_init_delayable>
    c4cc:	0000c1e1 	.word	0x0000c1e1
    c4d0:	20001a78 	.word	0x20001a78

0000c4d4 <bt_mesh_beacon_ivu_initiator>:
	if (val) {
    c4d4:	4b0d      	ldr	r3, [pc, #52]	; (c50c <bt_mesh_beacon_ivu_initiator+0x38>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c4d6:	f3bf 8f5b 	dmb	ish
    c4da:	b170      	cbz	r0, c4fa <bt_mesh_beacon_ivu_initiator+0x26>
    c4dc:	e853 2f00 	ldrex	r2, [r3]
    c4e0:	f042 0208 	orr.w	r2, r2, #8
    c4e4:	e843 2100 	strex	r1, r2, [r3]
    c4e8:	2900      	cmp	r1, #0
    c4ea:	d1f7      	bne.n	c4dc <bt_mesh_beacon_ivu_initiator+0x8>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    c4ec:	f3bf 8f5b 	dmb	ish
	 * An alternative solution would be to check whether beacons are enabled
	 * here, and cancel if not. As the cancel operation may fail, we would
	 * still have to implement an early exit mechanism, so we might as well
	 * just use this every time.
	 */
	k_work_schedule(&beacon_timer, K_NO_WAIT);
    c4f0:	4807      	ldr	r0, [pc, #28]	; (c510 <bt_mesh_beacon_ivu_initiator+0x3c>)
    c4f2:	2200      	movs	r2, #0
    c4f4:	2300      	movs	r3, #0
    c4f6:	f017 bf01 	b.w	242fc <k_work_schedule>
    c4fa:	e853 2f00 	ldrex	r2, [r3]
    c4fe:	f022 0208 	bic.w	r2, r2, #8
    c502:	e843 2100 	strex	r1, r2, [r3]
    c506:	2900      	cmp	r1, #0
    c508:	d0f0      	beq.n	c4ec <bt_mesh_beacon_ivu_initiator+0x18>
    c50a:	e7f6      	b.n	c4fa <bt_mesh_beacon_ivu_initiator+0x26>
    c50c:	20001ab0 	.word	0x20001ab0
    c510:	20001a78 	.word	0x20001a78

0000c514 <bt_mesh_beacon_recv>:
{
    c514:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->len < 1) {
    c516:	8883      	ldrh	r3, [r0, #4]
{
    c518:	b08d      	sub	sp, #52	; 0x34
    c51a:	4604      	mov	r4, r0
	if (buf->len < 1) {
    c51c:	b95b      	cbnz	r3, c536 <bt_mesh_beacon_recv+0x22>
		BT_ERR("Too short beacon");
    c51e:	4b60      	ldr	r3, [pc, #384]	; (c6a0 <bt_mesh_beacon_recv+0x18c>)
    c520:	930a      	str	r3, [sp, #40]	; 0x28
    c522:	2302      	movs	r3, #2
    c524:	9302      	str	r3, [sp, #8]
    c526:	9309      	str	r3, [sp, #36]	; 0x24
    c528:	aa09      	add	r2, sp, #36	; 0x24
    c52a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_WARN("Unknown beacon type 0x%02x", type);
    c52e:	485d      	ldr	r0, [pc, #372]	; (c6a4 <bt_mesh_beacon_recv+0x190>)
    c530:	f01c ff86 	bl	29440 <z_log_msg2_static_create.constprop.0>
		break;
    c534:	e037      	b.n	c5a6 <bt_mesh_beacon_recv+0x92>
	type = net_buf_simple_pull_u8(buf);
    c536:	f01f fc81 	bl	2be3c <net_buf_simple_pull_u8>
	switch (type) {
    c53a:	4605      	mov	r5, r0
    c53c:	b158      	cbz	r0, c556 <bt_mesh_beacon_recv+0x42>
    c53e:	2801      	cmp	r0, #1
    c540:	d033      	beq.n	c5aa <bt_mesh_beacon_recv+0x96>
		BT_WARN("Unknown beacon type 0x%02x", type);
    c542:	4b59      	ldr	r3, [pc, #356]	; (c6a8 <bt_mesh_beacon_recv+0x194>)
	switch (type) {
    c544:	e9cd 300a 	strd	r3, r0, [sp, #40]	; 0x28
		BT_WARN("Unknown beacon type 0x%02x", type);
    c548:	2303      	movs	r3, #3
    c54a:	9302      	str	r3, [sp, #8]
    c54c:	9309      	str	r3, [sp, #36]	; 0x24
    c54e:	aa09      	add	r2, sp, #36	; 0x24
    c550:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    c554:	e7eb      	b.n	c52e <bt_mesh_beacon_recv+0x1a>
	if (buf->len != 18 && buf->len != 22) {
    c556:	88a3      	ldrh	r3, [r4, #4]
    c558:	f023 0204 	bic.w	r2, r3, #4
    c55c:	2a12      	cmp	r2, #18
    c55e:	d009      	beq.n	c574 <bt_mesh_beacon_recv+0x60>
		BT_ERR("Invalid unprovisioned beacon length (%u)", buf->len);
    c560:	4a52      	ldr	r2, [pc, #328]	; (c6ac <bt_mesh_beacon_recv+0x198>)
		BT_ERR("Too short secure beacon (len %u)", buf->len);
    c562:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    c566:	2303      	movs	r3, #3
    c568:	9302      	str	r3, [sp, #8]
    c56a:	9309      	str	r3, [sp, #36]	; 0x24
    c56c:	aa09      	add	r2, sp, #36	; 0x24
    c56e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    c572:	e7dc      	b.n	c52e <bt_mesh_beacon_recv+0x1a>
	uuid = net_buf_simple_pull_mem(buf, 16);
    c574:	2110      	movs	r1, #16
    c576:	4620      	mov	r0, r4
    c578:	f01f fc58 	bl	2be2c <net_buf_simple_pull_mem>
    c57c:	4606      	mov	r6, r0
	oob_info = net_buf_simple_pull_be16(buf);
    c57e:	4620      	mov	r0, r4
    c580:	f01f fc6c 	bl	2be5c <net_buf_simple_pull_be16>
	if (buf->len == 4) {
    c584:	88a3      	ldrh	r3, [r4, #4]
    c586:	2b04      	cmp	r3, #4
	oob_info = net_buf_simple_pull_be16(buf);
    c588:	4607      	mov	r7, r0
	if (buf->len == 4) {
    c58a:	d104      	bne.n	c596 <bt_mesh_beacon_recv+0x82>
		uri_hash_val = net_buf_simple_pull_be32(buf);
    c58c:	4620      	mov	r0, r4
    c58e:	f01f fc6f 	bl	2be70 <net_buf_simple_pull_be32>
		uri_hash = &uri_hash_val;
    c592:	ad06      	add	r5, sp, #24
		uri_hash_val = net_buf_simple_pull_be32(buf);
    c594:	9006      	str	r0, [sp, #24]
	prov = bt_mesh_prov_get();
    c596:	f00a fb2d 	bl	16bf4 <bt_mesh_prov_get>
	if (prov->unprovisioned_beacon) {
    c59a:	6b43      	ldr	r3, [r0, #52]	; 0x34
    c59c:	b11b      	cbz	r3, c5a6 <bt_mesh_beacon_recv+0x92>
		prov->unprovisioned_beacon(uuid,
    c59e:	462a      	mov	r2, r5
    c5a0:	4639      	mov	r1, r7
    c5a2:	4630      	mov	r0, r6
    c5a4:	4798      	blx	r3
}
    c5a6:	b00d      	add	sp, #52	; 0x34
    c5a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (buf->len < 21) {
    c5aa:	88a3      	ldrh	r3, [r4, #4]
    c5ac:	2b14      	cmp	r3, #20
    c5ae:	d801      	bhi.n	c5b4 <bt_mesh_beacon_recv+0xa0>
		BT_ERR("Too short secure beacon (len %u)", buf->len);
    c5b0:	4a3f      	ldr	r2, [pc, #252]	; (c6b0 <bt_mesh_beacon_recv+0x19c>)
    c5b2:	e7d6      	b.n	c562 <bt_mesh_beacon_recv+0x4e>
	sub = bt_mesh_subnet_find(beacon_cache_match, buf->data);
    c5b4:	6821      	ldr	r1, [r4, #0]
    c5b6:	483f      	ldr	r0, [pc, #252]	; (c6b4 <bt_mesh_beacon_recv+0x1a0>)
    c5b8:	f001 fa42 	bl	da40 <bt_mesh_subnet_find>
	if (sub) {
    c5bc:	4605      	mov	r5, r0
    c5be:	2800      	cmp	r0, #0
    c5c0:	d144      	bne.n	c64c <bt_mesh_beacon_recv+0x138>
	params.flags = net_buf_simple_pull_u8(buf);
    c5c2:	4620      	mov	r0, r4
	data = buf->data;
    c5c4:	6826      	ldr	r6, [r4, #0]
	params.flags = net_buf_simple_pull_u8(buf);
    c5c6:	f01f fc39 	bl	2be3c <net_buf_simple_pull_u8>
	params.net_id = net_buf_simple_pull_mem(buf, 8);
    c5ca:	2108      	movs	r1, #8
	params.flags = net_buf_simple_pull_u8(buf);
    c5cc:	f88d 0014 	strb.w	r0, [sp, #20]
	params.net_id = net_buf_simple_pull_mem(buf, 8);
    c5d0:	4620      	mov	r0, r4
    c5d2:	f01f fc2b 	bl	2be2c <net_buf_simple_pull_mem>
    c5d6:	9002      	str	r0, [sp, #8]
	params.iv_index = net_buf_simple_pull_be32(buf);
    c5d8:	4620      	mov	r0, r4
    c5da:	f01f fc49 	bl	2be70 <net_buf_simple_pull_be32>
	params.auth = buf->data;
    c5de:	6823      	ldr	r3, [r4, #0]
	params.iv_index = net_buf_simple_pull_be32(buf);
    c5e0:	9004      	str	r0, [sp, #16]
	sub = bt_mesh_subnet_find(subnet_by_id, &params);
    c5e2:	a902      	add	r1, sp, #8
    c5e4:	4834      	ldr	r0, [pc, #208]	; (c6b8 <bt_mesh_beacon_recv+0x1a4>)
	params.auth = buf->data;
    c5e6:	9303      	str	r3, [sp, #12]
	sub = bt_mesh_subnet_find(subnet_by_id, &params);
    c5e8:	f001 fa2a 	bl	da40 <bt_mesh_subnet_find>
	if (!sub) {
    c5ec:	4605      	mov	r5, r0
    c5ee:	2800      	cmp	r0, #0
    c5f0:	d0d9      	beq.n	c5a6 <bt_mesh_beacon_recv+0x92>
	if (sub->kr_phase == BT_MESH_KR_PHASE_2 && !params.new_key) {
    c5f2:	7f83      	ldrb	r3, [r0, #30]
    c5f4:	2b02      	cmp	r3, #2
    c5f6:	d10a      	bne.n	c60e <bt_mesh_beacon_recv+0xfa>
    c5f8:	f89d 2015 	ldrb.w	r2, [sp, #21]
    c5fc:	b93a      	cbnz	r2, c60e <bt_mesh_beacon_recv+0xfa>
		BT_WARN("Ignoring Phase 2 KR Update secured using old key");
    c5fe:	4a2f      	ldr	r2, [pc, #188]	; (c6bc <bt_mesh_beacon_recv+0x1a8>)
    c600:	920a      	str	r2, [sp, #40]	; 0x28
    c602:	9301      	str	r3, [sp, #4]
    c604:	9309      	str	r3, [sp, #36]	; 0x24
    c606:	aa09      	add	r2, sp, #36	; 0x24
    c608:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    c60c:	e78f      	b.n	c52e <bt_mesh_beacon_recv+0x1a>
	memcpy(sub->beacon_cache, data, 21);
    c60e:	2215      	movs	r2, #21
    c610:	4631      	mov	r1, r6
    c612:	1da8      	adds	r0, r5, #6
    c614:	f01b f92c 	bl	27870 <memcpy>
	bt_mesh_kr_update(sub, BT_MESH_KEY_REFRESH(params.flags),
    c618:	f89d 1014 	ldrb.w	r1, [sp, #20]
    c61c:	f89d 2015 	ldrb.w	r2, [sp, #21]
    c620:	4628      	mov	r0, r5
    c622:	f001 0101 	and.w	r1, r1, #1
    c626:	f01c ffa7 	bl	29578 <bt_mesh_kr_update>
	if (bt_mesh_subnet_get(BT_MESH_KEY_PRIMARY) &&
    c62a:	2000      	movs	r0, #0
    c62c:	f001 f8e8 	bl	d800 <bt_mesh_subnet_get>
    c630:	b1b0      	cbz	r0, c660 <bt_mesh_beacon_recv+0x14c>
    c632:	8bab      	ldrh	r3, [r5, #28]
    c634:	b1a3      	cbz	r3, c660 <bt_mesh_beacon_recv+0x14c>
		BT_WARN("Ignoring secure beacon on non-primary subnet");
    c636:	4b22      	ldr	r3, [pc, #136]	; (c6c0 <bt_mesh_beacon_recv+0x1ac>)
    c638:	930a      	str	r3, [sp, #40]	; 0x28
    c63a:	481a      	ldr	r0, [pc, #104]	; (c6a4 <bt_mesh_beacon_recv+0x190>)
    c63c:	2302      	movs	r3, #2
    c63e:	aa09      	add	r2, sp, #36	; 0x24
    c640:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    c644:	9301      	str	r3, [sp, #4]
    c646:	9309      	str	r3, [sp, #36]	; 0x24
    c648:	f01c fefa 	bl	29440 <z_log_msg2_static_create.constprop.0>
	if (bt_mesh_beacon_enabled() &&
    c64c:	f7ff fadc 	bl	bc08 <bt_mesh_beacon_enabled>
    c650:	2800      	cmp	r0, #0
    c652:	d0a8      	beq.n	c5a6 <bt_mesh_beacon_recv+0x92>
	    sub->beacons_cur < 0xff) {
    c654:	796b      	ldrb	r3, [r5, #5]
	if (bt_mesh_beacon_enabled() &&
    c656:	2bff      	cmp	r3, #255	; 0xff
    c658:	d0a5      	beq.n	c5a6 <bt_mesh_beacon_recv+0x92>
		sub->beacons_cur++;
    c65a:	3301      	adds	r3, #1
    c65c:	716b      	strb	r3, [r5, #5]
    c65e:	e7a2      	b.n	c5a6 <bt_mesh_beacon_recv+0x92>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    c660:	4b18      	ldr	r3, [pc, #96]	; (c6c4 <bt_mesh_beacon_recv+0x1b0>)
    c662:	f3bf 8f5b 	dmb	ish
    c666:	681a      	ldr	r2, [r3, #0]
    c668:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR) &&
    c66c:	0712      	lsls	r2, r2, #28
    c66e:	d50f      	bpl.n	c690 <bt_mesh_beacon_recv+0x17c>
    c670:	f3bf 8f5b 	dmb	ish
    c674:	681a      	ldr	r2, [r3, #0]
    c676:	f3bf 8f5b 	dmb	ish
	     BT_MESH_IV_UPDATE(params.flags))) {
    c67a:	f89d 3014 	ldrb.w	r3, [sp, #20]
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR) &&
    c67e:	f3c2 0280 	ubfx	r2, r2, #2, #1
	     BT_MESH_IV_UPDATE(params.flags))) {
    c682:	f3c3 0340 	ubfx	r3, r3, #1, #1
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR) &&
    c686:	429a      	cmp	r2, r3
    c688:	d102      	bne.n	c690 <bt_mesh_beacon_recv+0x17c>
		bt_mesh_beacon_ivu_initiator(false);
    c68a:	2000      	movs	r0, #0
    c68c:	f7ff ff22 	bl	c4d4 <bt_mesh_beacon_ivu_initiator>
	bt_mesh_net_iv_update(params.iv_index, BT_MESH_IV_UPDATE(params.flags));
    c690:	f89d 1014 	ldrb.w	r1, [sp, #20]
    c694:	9804      	ldr	r0, [sp, #16]
    c696:	f3c1 0140 	ubfx	r1, r1, #1, #1
    c69a:	f000 fa33 	bl	cb04 <bt_mesh_net_iv_update>
    c69e:	e7d5      	b.n	c64c <bt_mesh_beacon_recv+0x138>
    c6a0:	00030971 	.word	0x00030971
    c6a4:	0002daec 	.word	0x0002daec
    c6a8:	00030a2a 	.word	0x00030a2a
    c6ac:	00030982 	.word	0x00030982
    c6b0:	000309ab 	.word	0x000309ab
    c6b4:	0002942f 	.word	0x0002942f
    c6b8:	0000c145 	.word	0x0000c145
    c6bc:	000309cc 	.word	0x000309cc
    c6c0:	000309fd 	.word	0x000309fd
    c6c4:	20001ab0 	.word	0x20001ab0

0000c6c8 <bt_mesh_beacon_enable>:

	bt_mesh_beacon_update(sub);
}

void bt_mesh_beacon_enable(void)
{
    c6c8:	b510      	push	{r4, lr}
	if (bt_mesh_is_provisioned()) {
    c6ca:	f7ff f979 	bl	b9c0 <bt_mesh_is_provisioned>
    c6ce:	b110      	cbz	r0, c6d6 <bt_mesh_beacon_enable+0xe>
		bt_mesh_subnet_foreach(subnet_beacon_enable);
    c6d0:	4804      	ldr	r0, [pc, #16]	; (c6e4 <bt_mesh_beacon_enable+0x1c>)
    c6d2:	f001 f9d9 	bl	da88 <bt_mesh_subnet_foreach>
	}

	k_work_reschedule(&beacon_timer, K_NO_WAIT);
}
    c6d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_reschedule(&beacon_timer, K_NO_WAIT);
    c6da:	4803      	ldr	r0, [pc, #12]	; (c6e8 <bt_mesh_beacon_enable+0x20>)
    c6dc:	2200      	movs	r2, #0
    c6de:	2300      	movs	r3, #0
    c6e0:	f017 be40 	b.w	24364 <k_work_reschedule>
    c6e4:	0002946f 	.word	0x0002946f
    c6e8:	20001a78 	.word	0x20001a78

0000c6ec <bt_mesh_beacon_disable>:
    c6ec:	4b05      	ldr	r3, [pc, #20]	; (c704 <bt_mesh_beacon_disable+0x18>)
    c6ee:	f3bf 8f5b 	dmb	ish
    c6f2:	681b      	ldr	r3, [r3, #0]
    c6f4:	f3bf 8f5b 	dmb	ish

void bt_mesh_beacon_disable(void)
{
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_INITIATOR)) {
    c6f8:	071b      	lsls	r3, r3, #28
    c6fa:	d402      	bmi.n	c702 <bt_mesh_beacon_disable+0x16>
		/* If this fails, we'll do an early exit in the work handler. */
		(void)k_work_cancel_delayable(&beacon_timer);
    c6fc:	4802      	ldr	r0, [pc, #8]	; (c708 <bt_mesh_beacon_disable+0x1c>)
    c6fe:	f020 bb82 	b.w	2ce06 <k_work_cancel_delayable>
	}
}
    c702:	4770      	bx	lr
    c704:	20001ab0 	.word	0x20001ab0
    c708:	20001a78 	.word	0x20001a78

0000c70c <net_decrypt>:
}

static bool net_decrypt(struct bt_mesh_net_rx *rx, struct net_buf_simple *in,
			struct net_buf_simple *out,
			const struct bt_mesh_net_cred *cred)
{
    c70c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c710:	461e      	mov	r6, r3
	bool proxy = (rx->net_if == BT_MESH_NET_IF_PROXY_CFG);

	if (NID(in->data) != cred->nid) {
    c712:	680b      	ldr	r3, [r1, #0]
{
    c714:	4614      	mov	r4, r2
	if (NID(in->data) != cred->nid) {
    c716:	781a      	ldrb	r2, [r3, #0]
{
    c718:	4605      	mov	r5, r0
	if (NID(in->data) != cred->nid) {
    c71a:	7830      	ldrb	r0, [r6, #0]
    c71c:	f002 037f 	and.w	r3, r2, #127	; 0x7f
    c720:	4298      	cmp	r0, r3
    c722:	d002      	beq.n	c72a <net_decrypt+0x1e>
		return false;
    c724:	2000      	movs	r0, #0

	BT_DBG("src 0x%04x", rx->ctx.addr);

	return bt_mesh_net_decrypt(cred->enc, out, BT_MESH_NET_IVI_RX(rx),
				   proxy) == 0;
}
    c726:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rx->old_iv = (IVI(in->data) != (bt_mesh.iv_index & 0x01));
    c72a:	f8df 80c8 	ldr.w	r8, [pc, #200]	; c7f4 <net_decrypt+0xe8>
	bool proxy = (rx->net_if == BT_MESH_NET_IF_PROXY_CFG);
    c72e:	7d2f      	ldrb	r7, [r5, #20]
	rx->old_iv = (IVI(in->data) != (bt_mesh.iv_index & 0x01));
    c730:	f8d8 3000 	ldr.w	r3, [r8]
    c734:	f003 0301 	and.w	r3, r3, #1
    c738:	ea83 13d2 	eor.w	r3, r3, r2, lsr #7
    c73c:	463a      	mov	r2, r7
    c73e:	f363 0200 	bfi	r2, r3, #0, #1
	buf->len  = 0U;
    c742:	2300      	movs	r3, #0
    c744:	752a      	strb	r2, [r5, #20]
    c746:	80a3      	strh	r3, [r4, #4]
	buf->data = buf->__buf;
    c748:	68a3      	ldr	r3, [r4, #8]
    c74a:	6023      	str	r3, [r4, #0]
	net_buf_simple_add_mem(out, in->data, in->len);
    c74c:	888a      	ldrh	r2, [r1, #4]
    c74e:	6809      	ldr	r1, [r1, #0]
    c750:	4620      	mov	r0, r4
    c752:	f01f faf9 	bl	2bd48 <net_buf_simple_add_mem>
	if (bt_mesh_net_obfuscate(out->data, BT_MESH_NET_IVI_RX(rx),
    c756:	7d2b      	ldrb	r3, [r5, #20]
    c758:	f8d8 1000 	ldr.w	r1, [r8]
    c75c:	6820      	ldr	r0, [r4, #0]
    c75e:	f003 0301 	and.w	r3, r3, #1
    c762:	f106 0211 	add.w	r2, r6, #17
    c766:	1ac9      	subs	r1, r1, r3
    c768:	f003 febe 	bl	104e8 <bt_mesh_net_obfuscate>
    c76c:	2800      	cmp	r0, #0
    c76e:	d1d9      	bne.n	c724 <net_decrypt+0x18>
	return ((uint16_t)src[0] << 8) | src[1];
    c770:	6823      	ldr	r3, [r4, #0]
    c772:	f8b3 2005 	ldrh.w	r2, [r3, #5]
    c776:	ba52      	rev16	r2, r2
    c778:	b290      	uxth	r0, r2
	rx->ctx.addr = SRC(out->data);
    c77a:	812a      	strh	r2, [r5, #8]
	if (!BT_MESH_ADDR_IS_UNICAST(rx->ctx.addr)) {
    c77c:	b212      	sxth	r2, r2
    c77e:	2a00      	cmp	r2, #0
    c780:	ddd0      	ble.n	c724 <net_decrypt+0x18>
	if (bt_mesh_has_addr(rx->ctx.addr)) {
    c782:	f004 fb89 	bl	10e98 <bt_mesh_has_addr>
    c786:	2800      	cmp	r0, #0
    c788:	d1cc      	bne.n	c724 <net_decrypt+0x18>
	if (rx->net_if == BT_MESH_NET_IF_ADV && msg_cache_match(out)) {
    c78a:	7d2d      	ldrb	r5, [r5, #20]
    c78c:	f015 0130 	ands.w	r1, r5, #48	; 0x30
    c790:	d11d      	bne.n	c7ce <net_decrypt+0xc2>
		if (msg_cache[i].src == SRC(pdu->data) &&
    c792:	6823      	ldr	r3, [r4, #0]
    c794:	f8df b060 	ldr.w	fp, [pc, #96]	; c7f8 <net_decrypt+0xec>
    c798:	f8b3 9005 	ldrh.w	r9, [r3, #5]
    c79c:	fa99 f999 	rev16.w	r9, r9
    c7a0:	fa1f f989 	uxth.w	r9, r9
		    msg_cache[i].seq == (SEQ(pdu->data) & BIT_MASK(17))) {
    c7a4:	f103 0a02 	add.w	sl, r3, #2
		if (msg_cache[i].src == SRC(pdu->data) &&
    c7a8:	f83b 3021 	ldrh.w	r3, [fp, r1, lsl #2]
    c7ac:	f3c3 030e 	ubfx	r3, r3, #0, #15
    c7b0:	454b      	cmp	r3, r9
    c7b2:	d109      	bne.n	c7c8 <net_decrypt+0xbc>
		    msg_cache[i].seq == (SEQ(pdu->data) & BIT_MASK(17))) {
    c7b4:	4650      	mov	r0, sl
    c7b6:	f01c fe5e 	bl	29476 <sys_get_be24>
    c7ba:	f85b 3021 	ldr.w	r3, [fp, r1, lsl #2]
    c7be:	f3c0 0010 	ubfx	r0, r0, #0, #17
		if (msg_cache[i].src == SRC(pdu->data) &&
    c7c2:	ebb0 3fd3 	cmp.w	r0, r3, lsr #15
    c7c6:	d0ad      	beq.n	c724 <net_decrypt+0x18>
	for (i = 0U; i < ARRAY_SIZE(msg_cache); i++) {
    c7c8:	3101      	adds	r1, #1
    c7ca:	290a      	cmp	r1, #10
    c7cc:	d1ec      	bne.n	c7a8 <net_decrypt+0x9c>
	bool proxy = (rx->net_if == BT_MESH_NET_IF_PROXY_CFG);
    c7ce:	f007 0330 	and.w	r3, r7, #48	; 0x30
	return bt_mesh_net_decrypt(cred->enc, out, BT_MESH_NET_IVI_RX(rx),
    c7d2:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    c7d6:	f8d8 2000 	ldr.w	r2, [r8]
    c7da:	424b      	negs	r3, r1
    c7dc:	f005 0501 	and.w	r5, r5, #1
    c7e0:	414b      	adcs	r3, r1
    c7e2:	1b52      	subs	r2, r2, r5
    c7e4:	4621      	mov	r1, r4
    c7e6:	1c70      	adds	r0, r6, #1
    c7e8:	f01d fae8 	bl	29dbc <bt_mesh_net_decrypt>
				   proxy) == 0;
    c7ec:	fab0 f080 	clz	r0, r0
    c7f0:	0940      	lsrs	r0, r0, #5
    c7f2:	e798      	b.n	c726 <net_decrypt+0x1a>
    c7f4:	20001aa8 	.word	0x20001aa8
    c7f8:	20002734 	.word	0x20002734

0000c7fc <net_set>:
	k_work_init(&bt_mesh.local_work, bt_mesh_net_local);
}

static int net_set(const char *name, size_t len_rd, settings_read_cb read_cb,
		   void *cb_arg)
{
    c7fc:	b510      	push	{r4, lr}
    c7fe:	460c      	mov	r4, r1
    c800:	b08c      	sub	sp, #48	; 0x30
    c802:	4610      	mov	r0, r2
    c804:	4619      	mov	r1, r3
	struct net_val net;
	int err;

	if (len_rd == 0) {
    c806:	b94c      	cbnz	r4, c81c <net_set+0x20>
		BT_DBG("val (null)");

		bt_mesh_comp_unprovision();
    c808:	f004 fb26 	bl	10e58 <bt_mesh_comp_unprovision>
		(void)memset(bt_mesh.dev_key, 0, sizeof(bt_mesh.dev_key));
    c80c:	4812      	ldr	r0, [pc, #72]	; (c858 <net_set+0x5c>)
    c80e:	2210      	movs	r2, #16
    c810:	4621      	mov	r1, r4
    c812:	f01b f838 	bl	27886 <memset>

	BT_DBG("Provisioned with primary address 0x%04x", net.primary_addr);
	BT_DBG("Recovered DevKey %s", bt_hex(bt_mesh.dev_key, 16));

	return 0;
}
    c816:	4620      	mov	r0, r4
    c818:	b00c      	add	sp, #48	; 0x30
    c81a:	bd10      	pop	{r4, pc}
	err = bt_mesh_settings_set(read_cb, cb_arg, &net, sizeof(net));
    c81c:	2312      	movs	r3, #18
    c81e:	aa01      	add	r2, sp, #4
    c820:	f008 fc4a 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    c824:	4604      	mov	r4, r0
    c826:	b158      	cbz	r0, c840 <net_set+0x44>
		BT_ERR("Failed to set \'net\'");
    c828:	4b0c      	ldr	r3, [pc, #48]	; (c85c <net_set+0x60>)
    c82a:	930a      	str	r3, [sp, #40]	; 0x28
    c82c:	480c      	ldr	r0, [pc, #48]	; (c860 <net_set+0x64>)
    c82e:	2302      	movs	r3, #2
    c830:	aa09      	add	r2, sp, #36	; 0x24
    c832:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    c836:	9300      	str	r3, [sp, #0]
    c838:	9309      	str	r3, [sp, #36]	; 0x24
    c83a:	f01c fe24 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return err;
    c83e:	e7ea      	b.n	c816 <net_set+0x1a>
	memcpy(bt_mesh.dev_key, net.dev_key, sizeof(bt_mesh.dev_key));
    c840:	2210      	movs	r2, #16
    c842:	f10d 0106 	add.w	r1, sp, #6
    c846:	4804      	ldr	r0, [pc, #16]	; (c858 <net_set+0x5c>)
    c848:	f01b f812 	bl	27870 <memcpy>
	bt_mesh_comp_provision(net.primary_addr);
    c84c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    c850:	f004 faec 	bl	10e2c <bt_mesh_comp_provision>
	return 0;
    c854:	e7df      	b.n	c816 <net_set+0x1a>
    c856:	bf00      	nop
    c858:	20001cd8 	.word	0x20001cd8
    c85c:	00030a54 	.word	0x00030a54
    c860:	0002db3c 	.word	0x0002db3c

0000c864 <seq_set>:

BT_MESH_SETTINGS_DEFINE(iv, "IV", iv_set);

static int seq_set(const char *name, size_t len_rd, settings_read_cb read_cb,
		   void *cb_arg)
{
    c864:	b510      	push	{r4, lr}
    c866:	460c      	mov	r4, r1
    c868:	b088      	sub	sp, #32
    c86a:	4610      	mov	r0, r2
    c86c:	4619      	mov	r1, r3
	struct seq_val seq;
	int err;

	if (len_rd == 0) {
    c86e:	b924      	cbnz	r4, c87a <seq_set+0x16>
		BT_DBG("val (null)");

		bt_mesh.seq = 0U;
    c870:	4b11      	ldr	r3, [pc, #68]	; (c8b8 <seq_set+0x54>)
    c872:	605c      	str	r4, [r3, #4]
	}

	BT_DBG("Sequence Number 0x%06x", bt_mesh.seq);

	return 0;
}
    c874:	4620      	mov	r0, r4
    c876:	b008      	add	sp, #32
    c878:	bd10      	pop	{r4, pc}
	err = bt_mesh_settings_set(read_cb, cb_arg, &seq, sizeof(seq));
    c87a:	2303      	movs	r3, #3
    c87c:	466a      	mov	r2, sp
    c87e:	f008 fc1b 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    c882:	4604      	mov	r4, r0
    c884:	b158      	cbz	r0, c89e <seq_set+0x3a>
		BT_ERR("Failed to set \'seq\'");
    c886:	4b0d      	ldr	r3, [pc, #52]	; (c8bc <seq_set+0x58>)
    c888:	9306      	str	r3, [sp, #24]
    c88a:	480d      	ldr	r0, [pc, #52]	; (c8c0 <seq_set+0x5c>)
    c88c:	2302      	movs	r3, #2
    c88e:	aa05      	add	r2, sp, #20
    c890:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    c894:	9301      	str	r3, [sp, #4]
    c896:	9305      	str	r3, [sp, #20]
    c898:	f01c fdf5 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return err;
    c89c:	e7ea      	b.n	c874 <seq_set+0x10>
	return ((uint32_t)src[2] << 16) | sys_get_le16(&src[0]);
    c89e:	f89d 2002 	ldrb.w	r2, [sp, #2]
    c8a2:	f8bd 3000 	ldrh.w	r3, [sp]
    c8a6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
		bt_mesh.seq += (CONFIG_BT_MESH_SEQ_STORE_RATE -
    c8aa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		bt_mesh.seq--;
    c8ae:	4a02      	ldr	r2, [pc, #8]	; (c8b8 <seq_set+0x54>)
    c8b0:	337f      	adds	r3, #127	; 0x7f
    c8b2:	6053      	str	r3, [r2, #4]
	return 0;
    c8b4:	e7de      	b.n	c874 <seq_set+0x10>
    c8b6:	bf00      	nop
    c8b8:	20001aa8 	.word	0x20001aa8
    c8bc:	00030a68 	.word	0x00030a68
    c8c0:	0002db3c 	.word	0x0002db3c

0000c8c4 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    c8c4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    c8c6:	ab0a      	add	r3, sp, #40	; 0x28
    c8c8:	9305      	str	r3, [sp, #20]
    c8ca:	9302      	str	r3, [sp, #8]
    c8cc:	4b05      	ldr	r3, [pc, #20]	; (c8e4 <z_log_msg2_runtime_create.constprop.0+0x20>)
    c8ce:	9301      	str	r3, [sp, #4]
    c8d0:	2300      	movs	r3, #0
    c8d2:	9300      	str	r3, [sp, #0]
    c8d4:	2202      	movs	r2, #2
    c8d6:	4618      	mov	r0, r3
    c8d8:	f7f6 fce6 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    c8dc:	b007      	add	sp, #28
    c8de:	f85d fb04 	ldr.w	pc, [sp], #4
    c8e2:	bf00      	nop
    c8e4:	00033605 	.word	0x00033605

0000c8e8 <bt_mesh_net_local>:
{
    c8e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	return list->head;
    c8ea:	4e2d      	ldr	r6, [pc, #180]	; (c9a0 <bt_mesh_net_local+0xb8>)
		k_mem_slab_free(&loopback_buf_pool, (void **)&buf);
    c8ec:	4d2d      	ldr	r5, [pc, #180]	; (c9a4 <bt_mesh_net_local+0xbc>)
{
    c8ee:	b08b      	sub	sp, #44	; 0x2c
    c8f0:	69f4      	ldr	r4, [r6, #28]
Z_GENLIST_GET(slist, snode)
    c8f2:	2c00      	cmp	r4, #0
    c8f4:	d052      	beq.n	c99c <bt_mesh_net_local+0xb4>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c8f6:	6a32      	ldr	r2, [r6, #32]
	return node->next;
    c8f8:	6823      	ldr	r3, [r4, #0]
	list->head = node;
    c8fa:	61f3      	str	r3, [r6, #28]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c8fc:	4294      	cmp	r4, r2
		struct bt_mesh_net_rx rx = {
    c8fe:	f04f 0100 	mov.w	r1, #0
    c902:	f04f 0210 	mov.w	r2, #16
    c906:	a806      	add	r0, sp, #24
	list->tail = node;
    c908:	bf08      	it	eq
    c90a:	6233      	streq	r3, [r6, #32]
		struct loopback_buf *buf = CONTAINER_OF(node, struct loopback_buf, node);
    c90c:	9400      	str	r4, [sp, #0]
		struct bt_mesh_net_rx rx = {
    c90e:	f01a ffba 	bl	27886 <memset>
			.sub = buf->sub,
    c912:	6867      	ldr	r7, [r4, #4]
		struct bt_mesh_net_rx rx = {
    c914:	9704      	str	r7, [sp, #16]
    c916:	8bbb      	ldrh	r3, [r7, #28]
    c918:	f8ad 3014 	strh.w	r3, [sp, #20]
    c91c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    c920:	f8ad 3016 	strh.w	r3, [sp, #22]
    c924:	89e3      	ldrh	r3, [r4, #14]
    c926:	ba5b      	rev16	r3, r3
    c928:	f8ad 3018 	strh.w	r3, [sp, #24]
    c92c:	8a23      	ldrh	r3, [r4, #16]
    c92e:	ba5b      	rev16	r3, r3
    c930:	f8ad 301a 	strh.w	r3, [sp, #26]
				.recv_ttl = TTL(buf->data),
    c934:	7aa1      	ldrb	r1, [r4, #10]
    c936:	f001 037f 	and.w	r3, r1, #127	; 0x7f
		struct bt_mesh_net_rx rx = {
    c93a:	f88d 301d 	strb.w	r3, [sp, #29]
			.seq = SEQ(buf->data),
    c93e:	f104 000b 	add.w	r0, r4, #11
		struct bt_mesh_net_rx rx = {
    c942:	2301      	movs	r3, #1
    c944:	f88d 301f 	strb.w	r3, [sp, #31]
			.seq = SEQ(buf->data),
    c948:	f01c fd95 	bl	29476 <sys_get_be24>
			.old_iv = (IVI(buf->data) != (bt_mesh.iv_index & 0x01)),
    c94c:	6833      	ldr	r3, [r6, #0]
		struct bt_mesh_net_rx rx = {
    c94e:	9008      	str	r0, [sp, #32]
			.old_iv = (IVI(buf->data) != (bt_mesh.iv_index & 0x01)),
    c950:	7a62      	ldrb	r2, [r4, #9]
    c952:	f003 0301 	and.w	r3, r3, #1
		struct bt_mesh_net_rx rx = {
    c956:	ea83 13d2 	eor.w	r3, r3, r2, lsr #7
			.new_key = SUBNET_KEY_TX_IDX(buf->sub),
    c95a:	7fba      	ldrb	r2, [r7, #30]
    c95c:	1e90      	subs	r0, r2, #2
    c95e:	4242      	negs	r2, r0
    c960:	4142      	adcs	r2, r0
		struct bt_mesh_net_rx rx = {
    c962:	f043 0350 	orr.w	r3, r3, #80	; 0x50
    c966:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
    c96a:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
			.ctl = CTL(buf->data),
    c96e:	09c9      	lsrs	r1, r1, #7
		struct bt_mesh_net_rx rx = {
    c970:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
    c974:	f022 027b 	bic.w	r2, r2, #123	; 0x7b
    c978:	4313      	orrs	r3, r2
    c97a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
		net_buf_simple_init_with_data(&sbuf, buf->data, buf->len);
    c97e:	7a22      	ldrb	r2, [r4, #8]
    c980:	f104 0109 	add.w	r1, r4, #9
    c984:	a801      	add	r0, sp, #4
    c986:	f01f f96d 	bl	2bc64 <net_buf_simple_init_with_data>
		(void)bt_mesh_trans_recv(&sbuf, &rx);
    c98a:	a904      	add	r1, sp, #16
    c98c:	a801      	add	r0, sp, #4
    c98e:	f002 fee9 	bl	f764 <bt_mesh_trans_recv>
		k_mem_slab_free(&loopback_buf_pool, (void **)&buf);
    c992:	4669      	mov	r1, sp
    c994:	4628      	mov	r0, r5
    c996:	f020 f839 	bl	2ca0c <k_mem_slab_free>
    c99a:	e7a9      	b.n	c8f0 <bt_mesh_net_local+0x8>
}
    c99c:	b00b      	add	sp, #44	; 0x2c
    c99e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c9a0:	20001aa8 	.word	0x20001aa8
    c9a4:	20000e80 	.word	0x20000e80

0000c9a8 <atomic_get.constprop.0>:
    c9a8:	4b03      	ldr	r3, [pc, #12]	; (c9b8 <atomic_get.constprop.0+0x10>)
    c9aa:	f3bf 8f5b 	dmb	ish
    c9ae:	6898      	ldr	r0, [r3, #8]
    c9b0:	f3bf 8f5b 	dmb	ish
}
    c9b4:	4770      	bx	lr
    c9b6:	bf00      	nop
    c9b8:	20001aa8 	.word	0x20001aa8

0000c9bc <atomic_set_bit_to.constprop.0>:
    c9bc:	4b0b      	ldr	r3, [pc, #44]	; (c9ec <atomic_set_bit_to.constprop.0+0x30>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c9be:	f3bf 8f5b 	dmb	ish
    c9c2:	b150      	cbz	r0, c9da <atomic_set_bit_to.constprop.0+0x1e>
    c9c4:	e853 2f00 	ldrex	r2, [r3]
    c9c8:	f042 0204 	orr.w	r2, r2, #4
    c9cc:	e843 2100 	strex	r1, r2, [r3]
    c9d0:	2900      	cmp	r1, #0
    c9d2:	d1f7      	bne.n	c9c4 <atomic_set_bit_to.constprop.0+0x8>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    c9d4:	f3bf 8f5b 	dmb	ish
	}
}
    c9d8:	4770      	bx	lr
    c9da:	e853 2f00 	ldrex	r2, [r3]
    c9de:	f022 0204 	bic.w	r2, r2, #4
    c9e2:	e843 2100 	strex	r1, r2, [r3]
    c9e6:	2900      	cmp	r1, #0
    c9e8:	d0f4      	beq.n	c9d4 <atomic_set_bit_to.constprop.0+0x18>
    c9ea:	e7f6      	b.n	c9da <atomic_set_bit_to.constprop.0+0x1e>
    c9ec:	20001ab0 	.word	0x20001ab0

0000c9f0 <iv_set>:
{
    c9f0:	b530      	push	{r4, r5, lr}
    c9f2:	460c      	mov	r4, r1
    c9f4:	b08b      	sub	sp, #44	; 0x2c
    c9f6:	4610      	mov	r0, r2
    c9f8:	4619      	mov	r1, r3
	if (len_rd == 0) {
    c9fa:	b98c      	cbnz	r4, ca20 <iv_set+0x30>
		bt_mesh.iv_index = 0U;
    c9fc:	4b19      	ldr	r3, [pc, #100]	; (ca64 <iv_set+0x74>)
    c9fe:	f843 4b08 	str.w	r4, [r3], #8
    ca02:	f3bf 8f5b 	dmb	ish
    ca06:	e853 2f00 	ldrex	r2, [r3]
    ca0a:	f022 0204 	bic.w	r2, r2, #4
    ca0e:	e843 2100 	strex	r1, r2, [r3]
    ca12:	2900      	cmp	r1, #0
    ca14:	d1f7      	bne.n	ca06 <iv_set+0x16>
    ca16:	f3bf 8f5b 	dmb	ish
}
    ca1a:	4620      	mov	r0, r4
    ca1c:	b00b      	add	sp, #44	; 0x2c
    ca1e:	bd30      	pop	{r4, r5, pc}
	err = bt_mesh_settings_set(read_cb, cb_arg, &iv, sizeof(iv));
    ca20:	2305      	movs	r3, #5
    ca22:	aa02      	add	r2, sp, #8
    ca24:	f008 fb48 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    ca28:	4604      	mov	r4, r0
    ca2a:	b158      	cbz	r0, ca44 <iv_set+0x54>
		BT_ERR("Failed to set \'iv\'");
    ca2c:	4b0e      	ldr	r3, [pc, #56]	; (ca68 <iv_set+0x78>)
    ca2e:	9308      	str	r3, [sp, #32]
    ca30:	480e      	ldr	r0, [pc, #56]	; (ca6c <iv_set+0x7c>)
    ca32:	2302      	movs	r3, #2
    ca34:	aa07      	add	r2, sp, #28
    ca36:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    ca3a:	9301      	str	r3, [sp, #4]
    ca3c:	9307      	str	r3, [sp, #28]
    ca3e:	f01c fd22 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return err;
    ca42:	e7ea      	b.n	ca1a <iv_set+0x2a>
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS, iv.iv_update);
    ca44:	f89d 000c 	ldrb.w	r0, [sp, #12]
	bt_mesh.iv_index = iv.iv_index;
    ca48:	4d06      	ldr	r5, [pc, #24]	; (ca64 <iv_set+0x74>)
    ca4a:	9b02      	ldr	r3, [sp, #8]
    ca4c:	602b      	str	r3, [r5, #0]
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS, iv.iv_update);
    ca4e:	f000 0001 	and.w	r0, r0, #1
    ca52:	f7ff ffb3 	bl	c9bc <atomic_set_bit_to.constprop.0>
	bt_mesh.ivu_duration = iv.iv_duration;
    ca56:	f89d 300c 	ldrb.w	r3, [sp, #12]
    ca5a:	f3c3 0346 	ubfx	r3, r3, #1, #7
    ca5e:	f885 31f8 	strb.w	r3, [r5, #504]	; 0x1f8
	return 0;
    ca62:	e7da      	b.n	ca1a <iv_set+0x2a>
    ca64:	20001aa8 	.word	0x20001aa8
    ca68:	00030a7c 	.word	0x00030a7c
    ca6c:	0002db3c 	.word	0x0002db3c

0000ca70 <bt_mesh_net_create>:
{
    ca70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ca74:	460d      	mov	r5, r1
    ca76:	461f      	mov	r7, r3
	if (BT_MESH_KEY_REFRESH(flags)) {
    ca78:	f015 0301 	ands.w	r3, r5, #1
{
    ca7c:	4611      	mov	r1, r2
		err = bt_mesh_subnet_set(idx, BT_MESH_KR_PHASE_2, NULL, key);
    ca7e:	bf18      	it	ne
    ca80:	4613      	movne	r3, r2
{
    ca82:	b088      	sub	sp, #32
		err = bt_mesh_subnet_set(idx, BT_MESH_KR_PHASE_2, NULL, key);
    ca84:	bf1a      	itte	ne
    ca86:	2200      	movne	r2, #0
    ca88:	2102      	movne	r1, #2
		err = bt_mesh_subnet_set(idx, BT_MESH_KR_NORMAL, key, NULL);
    ca8a:	4619      	moveq	r1, r3
{
    ca8c:	4606      	mov	r6, r0
		err = bt_mesh_subnet_set(idx, BT_MESH_KR_NORMAL, key, NULL);
    ca8e:	f01c fe2f 	bl	296f0 <bt_mesh_subnet_set>
    ca92:	4604      	mov	r4, r0
	if (err) {
    ca94:	b170      	cbz	r0, cab4 <bt_mesh_net_create+0x44>
		BT_ERR("Failed creating subnet");
    ca96:	4b16      	ldr	r3, [pc, #88]	; (caf0 <bt_mesh_net_create+0x80>)
    ca98:	9306      	str	r3, [sp, #24]
    ca9a:	4816      	ldr	r0, [pc, #88]	; (caf4 <bt_mesh_net_create+0x84>)
    ca9c:	2302      	movs	r3, #2
    ca9e:	aa05      	add	r2, sp, #20
    caa0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    caa4:	9301      	str	r3, [sp, #4]
    caa6:	9305      	str	r3, [sp, #20]
    caa8:	f01c fced 	bl	29486 <z_log_msg2_static_create.constprop.0>
}
    caac:	4620      	mov	r0, r4
    caae:	b008      	add	sp, #32
    cab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)memset(msg_cache, 0, sizeof(msg_cache));
    cab4:	4601      	mov	r1, r0
    cab6:	2228      	movs	r2, #40	; 0x28
    cab8:	480f      	ldr	r0, [pc, #60]	; (caf8 <bt_mesh_net_create+0x88>)
	bt_mesh.iv_index = iv_index;
    caba:	f8df 8040 	ldr.w	r8, [pc, #64]	; cafc <bt_mesh_net_create+0x8c>
	(void)memset(msg_cache, 0, sizeof(msg_cache));
    cabe:	f01a fee2 	bl	27886 <memset>
	msg_cache_next = 0U;
    cac2:	4b0f      	ldr	r3, [pc, #60]	; (cb00 <bt_mesh_net_create+0x90>)
	bt_mesh.iv_index = iv_index;
    cac4:	f8c8 7000 	str.w	r7, [r8]
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS,
    cac8:	f3c5 0040 	ubfx	r0, r5, #1, #1
	msg_cache_next = 0U;
    cacc:	801c      	strh	r4, [r3, #0]
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS,
    cace:	f7ff ff75 	bl	c9bc <atomic_set_bit_to.constprop.0>
	if (BT_MESH_IV_UPDATE(flags)) {
    cad2:	b110      	cbz	r0, cada <bt_mesh_net_create+0x6a>
		bt_mesh.ivu_duration = BT_MESH_IVU_MIN_HOURS;
    cad4:	2360      	movs	r3, #96	; 0x60
    cad6:	f888 31f8 	strb.w	r3, [r8, #504]	; 0x1f8
		bt_mesh_subnet_store(idx);
    cada:	4630      	mov	r0, r6
    cadc:	f01c fd22 	bl	29524 <bt_mesh_subnet_store>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_IV_PENDING);
    cae0:	2004      	movs	r0, #4
    cae2:	f008 fb27 	bl	15134 <bt_mesh_settings_store_schedule>
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_SEQ_PENDING);
    cae6:	2005      	movs	r0, #5
    cae8:	f008 fb24 	bl	15134 <bt_mesh_settings_store_schedule>
    caec:	e7de      	b.n	caac <bt_mesh_net_create+0x3c>
    caee:	bf00      	nop
    caf0:	00030a8f 	.word	0x00030a8f
    caf4:	0002db3c 	.word	0x0002db3c
    caf8:	20002734 	.word	0x20002734
    cafc:	20001aa8 	.word	0x20001aa8
    cb00:	2000389c 	.word	0x2000389c

0000cb04 <bt_mesh_net_iv_update>:
{
    cb04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cb08:	b088      	sub	sp, #32
    cb0a:	af00      	add	r7, sp, #0
    cb0c:	4604      	mov	r4, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    cb0e:	f7ff ff4b 	bl	c9a8 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    cb12:	4d61      	ldr	r5, [pc, #388]	; (cc98 <bt_mesh_net_iv_update+0x194>)
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    cb14:	f010 0f04 	tst.w	r0, #4
		if (iv_index != bt_mesh.iv_index) {
    cb18:	682b      	ldr	r3, [r5, #0]
{
    cb1a:	460e      	mov	r6, r1
    cb1c:	f3c0 0880 	ubfx	r8, r0, #2, #1
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    cb20:	d028      	beq.n	cb74 <bt_mesh_net_iv_update+0x70>
		if (iv_index != bt_mesh.iv_index) {
    cb22:	42a3      	cmp	r3, r4
    cb24:	d013      	beq.n	cb4e <bt_mesh_net_iv_update+0x4a>
			BT_WARN("IV Index mismatch: 0x%08x != 0x%08x",
    cb26:	466d      	mov	r5, sp
    cb28:	b088      	sub	sp, #32
    cb2a:	466a      	mov	r2, sp
    cb2c:	495b      	ldr	r1, [pc, #364]	; (cc9c <bt_mesh_net_iv_update+0x198>)
    cb2e:	6193      	str	r3, [r2, #24]
    cb30:	2304      	movs	r3, #4
    cb32:	e9c2 1404 	strd	r1, r4, [r2, #16]
    cb36:	485a      	ldr	r0, [pc, #360]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cb38:	f842 3f0c 	str.w	r3, [r2, #12]!
    cb3c:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    cb40:	60bb      	str	r3, [r7, #8]
    cb42:	f01c fca0 	bl	29486 <z_log_msg2_static_create.constprop.0>
    cb46:	46ad      	mov	sp, r5
			return false;
    cb48:	f04f 0800 	mov.w	r8, #0
    cb4c:	e02a      	b.n	cba4 <bt_mesh_net_iv_update+0xa0>
		if (iv_update) {
    cb4e:	2900      	cmp	r1, #0
    cb50:	d1fa      	bne.n	cb48 <bt_mesh_net_iv_update+0x44>
		if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    cb52:	f895 31f8 	ldrb.w	r3, [r5, #504]	; 0x1f8
    cb56:	2b5f      	cmp	r3, #95	; 0x5f
    cb58:	d877      	bhi.n	cc4a <bt_mesh_net_iv_update+0x146>
			BT_WARN("IV Update before minimum duration");
    cb5a:	4b52      	ldr	r3, [pc, #328]	; (cca4 <bt_mesh_net_iv_update+0x1a0>)
    cb5c:	61bb      	str	r3, [r7, #24]
    cb5e:	4850      	ldr	r0, [pc, #320]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cb60:	2302      	movs	r3, #2
    cb62:	f107 0214 	add.w	r2, r7, #20
    cb66:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    cb6a:	607b      	str	r3, [r7, #4]
    cb6c:	617b      	str	r3, [r7, #20]
    cb6e:	f01c fc8a 	bl	29486 <z_log_msg2_static_create.constprop.0>
			return false;
    cb72:	e7e9      	b.n	cb48 <bt_mesh_net_iv_update+0x44>
		if (iv_index == bt_mesh.iv_index) {
    cb74:	42a3      	cmp	r3, r4
    cb76:	d015      	beq.n	cba4 <bt_mesh_net_iv_update+0xa0>
		if (iv_index < bt_mesh.iv_index ||
    cb78:	d803      	bhi.n	cb82 <bt_mesh_net_iv_update+0x7e>
		    iv_index > bt_mesh.iv_index + 42) {
    cb7a:	f103 022a 	add.w	r2, r3, #42	; 0x2a
		if (iv_index < bt_mesh.iv_index ||
    cb7e:	42a2      	cmp	r2, r4
    cb80:	d215      	bcs.n	cbae <bt_mesh_net_iv_update+0xaa>
			BT_ERR("IV Index out of sync: 0x%08x != 0x%08x",
    cb82:	466d      	mov	r5, sp
    cb84:	b088      	sub	sp, #32
    cb86:	466a      	mov	r2, sp
    cb88:	4947      	ldr	r1, [pc, #284]	; (cca8 <bt_mesh_net_iv_update+0x1a4>)
    cb8a:	6193      	str	r3, [r2, #24]
    cb8c:	2304      	movs	r3, #4
    cb8e:	e9c2 1404 	strd	r1, r4, [r2, #16]
    cb92:	4843      	ldr	r0, [pc, #268]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cb94:	f842 3f0c 	str.w	r3, [r2, #12]!
    cb98:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    cb9c:	60bb      	str	r3, [r7, #8]
    cb9e:	f01c fc72 	bl	29486 <z_log_msg2_static_create.constprop.0>
    cba2:	46ad      	mov	sp, r5
}
    cba4:	4640      	mov	r0, r8
    cba6:	3720      	adds	r7, #32
    cba8:	46bd      	mov	sp, r7
    cbaa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ((iv_index > bt_mesh.iv_index + 1) ||
    cbae:	3301      	adds	r3, #1
    cbb0:	42a3      	cmp	r3, r4
    cbb2:	d302      	bcc.n	cbba <bt_mesh_net_iv_update+0xb6>
    cbb4:	d1cd      	bne.n	cb52 <bt_mesh_net_iv_update+0x4e>
		    (iv_index == bt_mesh.iv_index + 1 && !iv_update)) {
    cbb6:	2900      	cmp	r1, #0
    cbb8:	d1cb      	bne.n	cb52 <bt_mesh_net_iv_update+0x4e>
			if (ivi_was_recovered) {
    cbba:	f8df a0f0 	ldr.w	sl, [pc, #240]	; ccac <bt_mesh_net_iv_update+0x1a8>
    cbbe:	f89a 9000 	ldrb.w	r9, [sl]
    cbc2:	2302      	movs	r3, #2
    cbc4:	f1b9 0f00 	cmp.w	r9, #0
    cbc8:	d00b      	beq.n	cbe2 <bt_mesh_net_iv_update+0xde>
				BT_ERR("IV Index Recovery before minimum delay");
    cbca:	4a39      	ldr	r2, [pc, #228]	; (ccb0 <bt_mesh_net_iv_update+0x1ac>)
    cbcc:	61ba      	str	r2, [r7, #24]
    cbce:	4834      	ldr	r0, [pc, #208]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cbd0:	607b      	str	r3, [r7, #4]
    cbd2:	f107 0214 	add.w	r2, r7, #20
    cbd6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    cbda:	617b      	str	r3, [r7, #20]
    cbdc:	f01c fc53 	bl	29486 <z_log_msg2_static_create.constprop.0>
				return false;
    cbe0:	e7e0      	b.n	cba4 <bt_mesh_net_iv_update+0xa0>
			BT_WARN("Performing IV Index Recovery");
    cbe2:	4a34      	ldr	r2, [pc, #208]	; (ccb4 <bt_mesh_net_iv_update+0x1b0>)
    cbe4:	482e      	ldr	r0, [pc, #184]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cbe6:	61ba      	str	r2, [r7, #24]
    cbe8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    cbec:	f107 0214 	add.w	r2, r7, #20
    cbf0:	607b      	str	r3, [r7, #4]
    cbf2:	617b      	str	r3, [r7, #20]
    cbf4:	f01c fc47 	bl	29486 <z_log_msg2_static_create.constprop.0>
			ivi_was_recovered = true;
    cbf8:	2301      	movs	r3, #1
    cbfa:	f88a 3000 	strb.w	r3, [sl]
			bt_mesh_rpl_clear();
    cbfe:	f01d f805 	bl	29c0c <bt_mesh_rpl_clear>
			bt_mesh.seq = 0U;
    cc02:	e9c5 4900 	strd	r4, r9, [r5]
	atomic_set_bit_to(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS, iv_update);
    cc06:	4630      	mov	r0, r6
    cc08:	f7ff fed8 	bl	c9bc <atomic_set_bit_to.constprop.0>
	bt_mesh.ivu_duration = 0U;
    cc0c:	2400      	movs	r4, #0
	k_work_reschedule(&bt_mesh.ivu_timer, BT_MESH_IVU_TIMEOUT);
    cc0e:	4a2a      	ldr	r2, [pc, #168]	; (ccb8 <bt_mesh_net_iv_update+0x1b4>)
    cc10:	482a      	ldr	r0, [pc, #168]	; (ccbc <bt_mesh_net_iv_update+0x1b8>)
	bt_mesh.ivu_duration = 0U;
    cc12:	f885 41f8 	strb.w	r4, [r5, #504]	; 0x1f8
	k_work_reschedule(&bt_mesh.ivu_timer, BT_MESH_IVU_TIMEOUT);
    cc16:	2300      	movs	r3, #0
    cc18:	f017 fba4 	bl	24364 <k_work_reschedule>
		bt_mesh_friend_sec_update(BT_MESH_KEY_ANY);
    cc1c:	f64f 70ff 	movw	r0, #65535	; 0xffff
    cc20:	f008 ffcc 	bl	15bbc <bt_mesh_friend_sec_update>
	bt_mesh_subnet_foreach(bt_mesh_beacon_update);
    cc24:	4826      	ldr	r0, [pc, #152]	; (ccc0 <bt_mesh_net_iv_update+0x1bc>)
    cc26:	f000 ff2f 	bl	da88 <bt_mesh_subnet_foreach>
	    bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED) {
    cc2a:	f7ff f81d 	bl	bc68 <bt_mesh_gatt_proxy_get>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    cc2e:	2801      	cmp	r0, #1
    cc30:	d102      	bne.n	cc38 <bt_mesh_net_iv_update+0x134>
		bt_mesh_proxy_beacon_send(NULL);
    cc32:	4620      	mov	r0, r4
    cc34:	f00b fe12 	bl	1885c <bt_mesh_proxy_beacon_send>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_IV_PENDING);
    cc38:	2004      	movs	r0, #4
    cc3a:	f008 fa7b 	bl	15134 <bt_mesh_settings_store_schedule>
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_SEQ_PENDING);
    cc3e:	2005      	movs	r0, #5
    cc40:	f008 fa78 	bl	15134 <bt_mesh_settings_store_schedule>
	return true;
    cc44:	f04f 0801 	mov.w	r8, #1
    cc48:	e7ac      	b.n	cba4 <bt_mesh_net_iv_update+0xa0>
	if (!iv_update && bt_mesh_tx_in_progress()) {
    cc4a:	b9e6      	cbnz	r6, cc86 <bt_mesh_net_iv_update+0x182>
    cc4c:	f001 ffb2 	bl	ebb4 <bt_mesh_tx_in_progress>
    cc50:	b300      	cbz	r0, cc94 <bt_mesh_net_iv_update+0x190>
		BT_WARN("IV Update deferred because of pending transfer");
    cc52:	4b1c      	ldr	r3, [pc, #112]	; (ccc4 <bt_mesh_net_iv_update+0x1c0>)
    cc54:	61bb      	str	r3, [r7, #24]
    cc56:	4812      	ldr	r0, [pc, #72]	; (cca0 <bt_mesh_net_iv_update+0x19c>)
    cc58:	2302      	movs	r3, #2
    cc5a:	f107 0214 	add.w	r2, r7, #20
    cc5e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    cc62:	607b      	str	r3, [r7, #4]
    cc64:	617b      	str	r3, [r7, #20]
    cc66:	f01c fc0e 	bl	29486 <z_log_msg2_static_create.constprop.0>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    cc6a:	f3bf 8f5b 	dmb	ish
    cc6e:	4b16      	ldr	r3, [pc, #88]	; (ccc8 <bt_mesh_net_iv_update+0x1c4>)
    cc70:	e853 2f00 	ldrex	r2, [r3]
    cc74:	f042 0220 	orr.w	r2, r2, #32
    cc78:	e843 2100 	strex	r1, r2, [r3]
    cc7c:	2900      	cmp	r1, #0
    cc7e:	d1f7      	bne.n	cc70 <bt_mesh_net_iv_update+0x16c>
    cc80:	f3bf 8f5b 	dmb	ish
    cc84:	e760      	b.n	cb48 <bt_mesh_net_iv_update+0x44>
		bt_mesh.iv_index = iv_index;
    cc86:	602c      	str	r4, [r5, #0]
		bt_mesh_rpl_reset();
    cc88:	f002 ffd2 	bl	fc30 <bt_mesh_rpl_reset>
		ivi_was_recovered = false;
    cc8c:	4b07      	ldr	r3, [pc, #28]	; (ccac <bt_mesh_net_iv_update+0x1a8>)
    cc8e:	2200      	movs	r2, #0
    cc90:	701a      	strb	r2, [r3, #0]
    cc92:	e7b8      	b.n	cc06 <bt_mesh_net_iv_update+0x102>
		bt_mesh.seq = 0U;
    cc94:	606e      	str	r6, [r5, #4]
    cc96:	e7b6      	b.n	cc06 <bt_mesh_net_iv_update+0x102>
    cc98:	20001aa8 	.word	0x20001aa8
    cc9c:	00030aa6 	.word	0x00030aa6
    cca0:	0002db3c 	.word	0x0002db3c
    cca4:	00030b35 	.word	0x00030b35
    cca8:	00030aca 	.word	0x00030aca
    ccac:	20003aeb 	.word	0x20003aeb
    ccb0:	00030af1 	.word	0x00030af1
    ccb4:	00030b18 	.word	0x00030b18
    ccb8:	a8c00000 	.word	0xa8c00000
    ccbc:	20001ca8 	.word	0x20001ca8
    ccc0:	0000c465 	.word	0x0000c465
    ccc4:	00030b57 	.word	0x00030b57
    ccc8:	20001ab0 	.word	0x20001ab0

0000cccc <ivu_refresh>:
{
    cccc:	b510      	push	{r4, lr}
	if (!bt_mesh_is_provisioned()) {
    ccce:	f7fe fe77 	bl	b9c0 <bt_mesh_is_provisioned>
    ccd2:	b340      	cbz	r0, cd26 <ivu_refresh+0x5a>
	bt_mesh.ivu_duration = MIN(UINT8_MAX,
    ccd4:	4c14      	ldr	r4, [pc, #80]	; (cd28 <ivu_refresh+0x5c>)
    ccd6:	f894 31f8 	ldrb.w	r3, [r4, #504]	; 0x1f8
    ccda:	2be7      	cmp	r3, #231	; 0xe7
    ccdc:	bf28      	it	cs
    ccde:	23e7      	movcs	r3, #231	; 0xe7
    cce0:	3318      	adds	r3, #24
    cce2:	b2db      	uxtb	r3, r3
	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    cce4:	2b5f      	cmp	r3, #95	; 0x5f
	bt_mesh.ivu_duration = MIN(UINT8_MAX,
    cce6:	f884 31f8 	strb.w	r3, [r4, #504]	; 0x1f8
	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    ccea:	d80a      	bhi.n	cd02 <ivu_refresh+0x36>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_IV_PENDING);
    ccec:	2004      	movs	r0, #4
    ccee:	f008 fa21 	bl	15134 <bt_mesh_settings_store_schedule>
		k_work_reschedule(&bt_mesh.ivu_timer, BT_MESH_IVU_TIMEOUT);
    ccf2:	f504 7000 	add.w	r0, r4, #512	; 0x200
    ccf6:	4a0d      	ldr	r2, [pc, #52]	; (cd2c <ivu_refresh+0x60>)
}
    ccf8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_work_reschedule(&bt_mesh.ivu_timer, BT_MESH_IVU_TIMEOUT);
    ccfc:	2300      	movs	r3, #0
    ccfe:	f017 bb31 	b.w	24364 <k_work_reschedule>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    cd02:	f7ff fe51 	bl	c9a8 <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    cd06:	0743      	lsls	r3, r0, #29
    cd08:	d508      	bpl.n	cd1c <ivu_refresh+0x50>
		bt_mesh_beacon_ivu_initiator(true);
    cd0a:	2001      	movs	r0, #1
    cd0c:	f7ff fbe2 	bl	c4d4 <bt_mesh_beacon_ivu_initiator>
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
    cd10:	6820      	ldr	r0, [r4, #0]
    cd12:	2100      	movs	r1, #0
}
    cd14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
    cd18:	f7ff bef4 	b.w	cb04 <bt_mesh_net_iv_update>
}
    cd1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_IV_PENDING);
    cd20:	2004      	movs	r0, #4
    cd22:	f008 ba07 	b.w	15134 <bt_mesh_settings_store_schedule>
}
    cd26:	bd10      	pop	{r4, pc}
    cd28:	20001aa8 	.word	0x20001aa8
    cd2c:	a8c00000 	.word	0xa8c00000

0000cd30 <bt_mesh_next_seq>:
{
    cd30:	b538      	push	{r3, r4, r5, lr}
	uint32_t seq = bt_mesh.seq++;
    cd32:	4c10      	ldr	r4, [pc, #64]	; (cd74 <bt_mesh_next_seq+0x44>)
    cd34:	6865      	ldr	r5, [r4, #4]
    cd36:	1c6b      	adds	r3, r5, #1
	if (CONFIG_BT_MESH_SEQ_STORE_RATE > 1 &&
    cd38:	065a      	lsls	r2, r3, #25
	uint32_t seq = bt_mesh.seq++;
    cd3a:	6063      	str	r3, [r4, #4]
	if (CONFIG_BT_MESH_SEQ_STORE_RATE > 1 &&
    cd3c:	d102      	bne.n	cd44 <bt_mesh_next_seq+0x14>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_SEQ_PENDING);
    cd3e:	2005      	movs	r0, #5
    cd40:	f008 f9f8 	bl	15134 <bt_mesh_settings_store_schedule>
    cd44:	f7ff fe30 	bl	c9a8 <atomic_get.constprop.0>
    cd48:	4603      	mov	r3, r0
	if (!atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS) &&
    cd4a:	075b      	lsls	r3, r3, #29
    cd4c:	f3c0 0080 	ubfx	r0, r0, #2, #1
    cd50:	d40e      	bmi.n	cd70 <bt_mesh_next_seq+0x40>
    cd52:	6863      	ldr	r3, [r4, #4]
    cd54:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    cd58:	d90a      	bls.n	cd70 <bt_mesh_next_seq+0x40>
	    bt_mesh_subnet_get(BT_MESH_KEY_PRIMARY)) {
    cd5a:	f000 fd51 	bl	d800 <bt_mesh_subnet_get>
	    bt_mesh.seq > IV_UPDATE_SEQ_LIMIT &&
    cd5e:	b138      	cbz	r0, cd70 <bt_mesh_next_seq+0x40>
		bt_mesh_beacon_ivu_initiator(true);
    cd60:	2001      	movs	r0, #1
    cd62:	f7ff fbb7 	bl	c4d4 <bt_mesh_beacon_ivu_initiator>
		bt_mesh_net_iv_update(bt_mesh.iv_index + 1, true);
    cd66:	6820      	ldr	r0, [r4, #0]
    cd68:	2101      	movs	r1, #1
    cd6a:	4408      	add	r0, r1
    cd6c:	f7ff feca 	bl	cb04 <bt_mesh_net_iv_update>
}
    cd70:	4628      	mov	r0, r5
    cd72:	bd38      	pop	{r3, r4, r5, pc}
    cd74:	20001aa8 	.word	0x20001aa8

0000cd78 <net_header_encode>:
{
    cd78:	b5f0      	push	{r4, r5, r6, r7, lr}
	const bool ctl = (tx->ctx->app_idx == BT_MESH_KEY_UNUSED);
    cd7a:	6843      	ldr	r3, [r0, #4]
    cd7c:	885f      	ldrh	r7, [r3, #2]
	if (ctl && net_buf_simple_tailroom(buf) < 8) {
    cd7e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    cd82:	429f      	cmp	r7, r3
{
    cd84:	b089      	sub	sp, #36	; 0x24
    cd86:	4605      	mov	r5, r0
    cd88:	460e      	mov	r6, r1
    cd8a:	4614      	mov	r4, r2
	if (ctl && net_buf_simple_tailroom(buf) < 8) {
    cd8c:	d113      	bne.n	cdb6 <net_header_encode+0x3e>
    cd8e:	4610      	mov	r0, r2
    cd90:	f01f f87b 	bl	2be8a <net_buf_simple_tailroom>
    cd94:	2807      	cmp	r0, #7
    cd96:	d80e      	bhi.n	cdb6 <net_header_encode+0x3e>
		BT_ERR("Insufficient MIC space for CTL PDU");
    cd98:	4b1f      	ldr	r3, [pc, #124]	; (ce18 <net_header_encode+0xa0>)
		BT_ERR("Insufficient MIC space for PDU");
    cd9a:	4820      	ldr	r0, [pc, #128]	; (ce1c <net_header_encode+0xa4>)
    cd9c:	9306      	str	r3, [sp, #24]
    cd9e:	aa05      	add	r2, sp, #20
    cda0:	2302      	movs	r3, #2
    cda2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    cda6:	9301      	str	r3, [sp, #4]
    cda8:	9305      	str	r3, [sp, #20]
    cdaa:	f01c fb6c 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    cdae:	f06f 0015 	mvn.w	r0, #21
}
    cdb2:	b009      	add	sp, #36	; 0x24
    cdb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (net_buf_simple_tailroom(buf) < 4) {
    cdb6:	4620      	mov	r0, r4
    cdb8:	f01f f867 	bl	2be8a <net_buf_simple_tailroom>
    cdbc:	2803      	cmp	r0, #3
    cdbe:	d801      	bhi.n	cdc4 <net_header_encode+0x4c>
		BT_ERR("Insufficient MIC space for PDU");
    cdc0:	4b17      	ldr	r3, [pc, #92]	; (ce20 <net_header_encode+0xa8>)
    cdc2:	e7ea      	b.n	cd9a <net_header_encode+0x22>
	net_buf_simple_push_be16(buf, tx->ctx->addr);
    cdc4:	686b      	ldr	r3, [r5, #4]
    cdc6:	4620      	mov	r0, r4
    cdc8:	8899      	ldrh	r1, [r3, #4]
    cdca:	f01f f802 	bl	2bdd2 <net_buf_simple_push_be16>
	net_buf_simple_push_be16(buf, tx->src);
    cdce:	8929      	ldrh	r1, [r5, #8]
    cdd0:	4620      	mov	r0, r4
    cdd2:	f01e fffe 	bl	2bdd2 <net_buf_simple_push_be16>
	net_buf_simple_push_be24(buf, bt_mesh_next_seq());
    cdd6:	f7ff ffab 	bl	cd30 <bt_mesh_next_seq>
    cdda:	4601      	mov	r1, r0
    cddc:	4620      	mov	r0, r4
    cdde:	f01f f80d 	bl	2bdfc <net_buf_simple_push_be24>
	if (ctl) {
    cde2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    cde6:	429f      	cmp	r7, r3
    cde8:	686b      	ldr	r3, [r5, #4]
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl | 0x80);
    cdea:	7ad9      	ldrb	r1, [r3, #11]
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl);
    cdec:	4620      	mov	r0, r4
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl | 0x80);
    cdee:	bf08      	it	eq
    cdf0:	f041 0180 	orreq.w	r1, r1, #128	; 0x80
		net_buf_simple_push_u8(buf, tx->ctx->send_ttl);
    cdf4:	f01e fff9 	bl	2bdea <net_buf_simple_push_u8>
	net_buf_simple_push_u8(buf, (nid | (BT_MESH_NET_IVI_TX & 1) << 7));
    cdf8:	4b0a      	ldr	r3, [pc, #40]	; (ce24 <net_header_encode+0xac>)
    cdfa:	7819      	ldrb	r1, [r3, #0]
    cdfc:	f7ff fdd4 	bl	c9a8 <atomic_get.constprop.0>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    ce00:	f3c0 0080 	ubfx	r0, r0, #2, #1
    ce04:	1a09      	subs	r1, r1, r0
    ce06:	ea46 11c1 	orr.w	r1, r6, r1, lsl #7
    ce0a:	4620      	mov	r0, r4
    ce0c:	b2c9      	uxtb	r1, r1
    ce0e:	f01e ffec 	bl	2bdea <net_buf_simple_push_u8>
	return 0;
    ce12:	2000      	movs	r0, #0
    ce14:	e7cd      	b.n	cdb2 <net_header_encode+0x3a>
    ce16:	bf00      	nop
    ce18:	00030b86 	.word	0x00030b86
    ce1c:	0002db3c 	.word	0x0002db3c
    ce20:	00030ba9 	.word	0x00030ba9
    ce24:	20001aa8 	.word	0x20001aa8

0000ce28 <bt_mesh_net_encode>:
{
    ce28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	tx->friend_cred = 0U;
    ce2c:	7ac3      	ldrb	r3, [r0, #11]
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce2e:	6807      	ldr	r7, [r0, #0]
	tx->friend_cred = 0U;
    ce30:	f36f 0300 	bfc	r3, #0, #1
    ce34:	72c3      	strb	r3, [r0, #11]
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce36:	7fbc      	ldrb	r4, [r7, #30]
    ce38:	1ea3      	subs	r3, r4, #2
    ce3a:	425c      	negs	r4, r3
    ce3c:	415c      	adcs	r4, r3
{
    ce3e:	460d      	mov	r5, r1
	err = net_header_encode(tx, cred->nid, buf);
    ce40:	215a      	movs	r1, #90	; 0x5a
    ce42:	434c      	muls	r4, r1
    ce44:	193b      	adds	r3, r7, r4
{
    ce46:	4616      	mov	r6, r2
	err = net_header_encode(tx, cred->nid, buf);
    ce48:	f893 103d 	ldrb.w	r1, [r3, #61]	; 0x3d
    ce4c:	462a      	mov	r2, r5
    ce4e:	f7ff ff93 	bl	cd78 <net_header_encode>
	if (err) {
    ce52:	b970      	cbnz	r0, ce72 <bt_mesh_net_encode+0x4a>
	return net_encrypt(buf, cred, BT_MESH_NET_IVI_TX, proxy);
    ce54:	4b08      	ldr	r3, [pc, #32]	; (ce78 <bt_mesh_net_encode+0x50>)
    ce56:	681a      	ldr	r2, [r3, #0]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    ce58:	f7ff fda6 	bl	c9a8 <atomic_get.constprop.0>
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce5c:	343d      	adds	r4, #61	; 0x3d
	return net_encrypt(buf, cred, BT_MESH_NET_IVI_TX, proxy);
    ce5e:	f3c0 0080 	ubfx	r0, r0, #2, #1
    ce62:	4633      	mov	r3, r6
    ce64:	1a12      	subs	r2, r2, r0
    ce66:	1939      	adds	r1, r7, r4
    ce68:	4628      	mov	r0, r5
}
    ce6a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return net_encrypt(buf, cred, BT_MESH_NET_IVI_TX, proxy);
    ce6e:	f01c bb0d 	b.w	2948c <net_encrypt>
}
    ce72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ce76:	bf00      	nop
    ce78:	20001aa8 	.word	0x20001aa8

0000ce7c <bt_mesh_net_send>:
{
    ce7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ce80:	461f      	mov	r7, r3
	tx->friend_cred = 0U;
    ce82:	7ac3      	ldrb	r3, [r0, #11]
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce84:	f8d0 8000 	ldr.w	r8, [r0]
	tx->friend_cred = 0U;
    ce88:	f36f 0300 	bfc	r3, #0, #1
    ce8c:	72c3      	strb	r3, [r0, #11]
{
    ce8e:	460d      	mov	r5, r1
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce90:	f898 101e 	ldrb.w	r1, [r8, #30]
{
    ce94:	4616      	mov	r6, r2
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce96:	1e8a      	subs	r2, r1, #2
{
    ce98:	b08b      	sub	sp, #44	; 0x2c
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    ce9a:	4253      	negs	r3, r2
    ce9c:	4153      	adcs	r3, r2
    ce9e:	9300      	str	r3, [sp, #0]
	err = net_header_encode(tx, cred->nid, &buf->b);
    cea0:	9a00      	ldr	r2, [sp, #0]
    cea2:	235a      	movs	r3, #90	; 0x5a
    cea4:	fb03 8302 	mla	r3, r3, r2, r8
    cea8:	f105 0908 	add.w	r9, r5, #8
    ceac:	f893 103d 	ldrb.w	r1, [r3, #61]	; 0x3d
    ceb0:	464a      	mov	r2, r9
{
    ceb2:	4604      	mov	r4, r0
	err = net_header_encode(tx, cred->nid, &buf->b);
    ceb4:	f7ff ff60 	bl	cd78 <net_header_encode>
	if (err) {
    ceb8:	2800      	cmp	r0, #0
    ceba:	f040 808f 	bne.w	cfdc <bt_mesh_net_send+0x160>
	if (bt_mesh_fixed_group_match(tx->ctx->addr) ||
    cebe:	6863      	ldr	r3, [r4, #4]
    cec0:	8898      	ldrh	r0, [r3, #4]
    cec2:	f01c fa6a 	bl	2939a <bt_mesh_fixed_group_match>
    cec6:	2800      	cmp	r0, #0
    cec8:	d048      	beq.n	cf5c <bt_mesh_net_send+0xe0>
		err = loopback(tx, buf->data, buf->len);
    ceca:	68ab      	ldr	r3, [r5, #8]
    cecc:	9301      	str	r3, [sp, #4]
	err = k_mem_slab_alloc(&loopback_buf_pool, (void **)&buf, K_NO_WAIT);
    cece:	4844      	ldr	r0, [pc, #272]	; (cfe0 <bt_mesh_net_send+0x164>)
		err = loopback(tx, buf->data, buf->len);
    ced0:	f8b5 a00c 	ldrh.w	sl, [r5, #12]
	err = k_mem_slab_alloc(&loopback_buf_pool, (void **)&buf, K_NO_WAIT);
    ced4:	2200      	movs	r2, #0
    ced6:	2300      	movs	r3, #0
    ced8:	a902      	add	r1, sp, #8
    ceda:	f016 fe49 	bl	23b70 <k_mem_slab_alloc>
	if (err) {
    cede:	4683      	mov	fp, r0
    cee0:	2800      	cmp	r0, #0
    cee2:	d048      	beq.n	cf76 <bt_mesh_net_send+0xfa>
		BT_WARN("Unable to allocate loopback");
    cee4:	4b3f      	ldr	r3, [pc, #252]	; (cfe4 <bt_mesh_net_send+0x168>)
    cee6:	9308      	str	r3, [sp, #32]
    cee8:	483f      	ldr	r0, [pc, #252]	; (cfe8 <bt_mesh_net_send+0x16c>)
    ceea:	2302      	movs	r3, #2
    ceec:	aa07      	add	r2, sp, #28
    ceee:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		return -ENOMEM;
    cef2:	f06f 0b0b 	mvn.w	fp, #11
		BT_WARN("Unable to allocate loopback");
    cef6:	9303      	str	r3, [sp, #12]
    cef8:	9307      	str	r3, [sp, #28]
    cefa:	f01c fac4 	bl	29486 <z_log_msg2_static_create.constprop.0>
		if (BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr) ||
    cefe:	6862      	ldr	r2, [r4, #4]
    cf00:	f9b2 1004 	ldrsh.w	r1, [r2, #4]
    cf04:	2900      	cmp	r1, #0
    cf06:	dc4f      	bgt.n	cfa8 <bt_mesh_net_send+0x12c>
    cf08:	7ad2      	ldrb	r2, [r2, #11]
    cf0a:	2a01      	cmp	r2, #1
    cf0c:	d04c      	beq.n	cfa8 <bt_mesh_net_send+0x12c>
	err = net_encrypt(&buf->b, cred, BT_MESH_NET_IVI_TX, false);
    cf0e:	4b37      	ldr	r3, [pc, #220]	; (cfec <bt_mesh_net_send+0x170>)
    cf10:	681a      	ldr	r2, [r3, #0]
    cf12:	f7ff fd49 	bl	c9a8 <atomic_get.constprop.0>
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    cf16:	9b00      	ldr	r3, [sp, #0]
    cf18:	215a      	movs	r1, #90	; 0x5a
	err = net_encrypt(&buf->b, cred, BT_MESH_NET_IVI_TX, false);
    cf1a:	f3c0 0080 	ubfx	r0, r0, #2, #1
	return &tx->sub->keys[SUBNET_KEY_TX_IDX(tx->sub)].msg;
    cf1e:	fb01 8103 	mla	r1, r1, r3, r8
	err = net_encrypt(&buf->b, cred, BT_MESH_NET_IVI_TX, false);
    cf22:	1a12      	subs	r2, r2, r0
    cf24:	2300      	movs	r3, #0
    cf26:	313d      	adds	r1, #61	; 0x3d
    cf28:	4648      	mov	r0, r9
    cf2a:	f01c faaf 	bl	2948c <net_encrypt>
	if (err) {
    cf2e:	4683      	mov	fp, r0
    cf30:	2800      	cmp	r0, #0
    cf32:	d13f      	bne.n	cfb4 <bt_mesh_net_send+0x138>
	BT_MESH_ADV(buf)->cb = cb;
    cf34:	696a      	ldr	r2, [r5, #20]
	BT_MESH_ADV(buf)->cb_data = cb_data;
    cf36:	e9c2 6700 	strd	r6, r7, [r2]
	    bt_mesh_proxy_relay(buf, tx->ctx->addr) &&
    cf3a:	6862      	ldr	r2, [r4, #4]
    cf3c:	4628      	mov	r0, r5
    cf3e:	8891      	ldrh	r1, [r2, #4]
    cf40:	f00b ff96 	bl	18e70 <bt_mesh_proxy_relay>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    cf44:	b120      	cbz	r0, cf50 <bt_mesh_net_send+0xd4>
	    BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    cf46:	6862      	ldr	r2, [r4, #4]
	    bt_mesh_proxy_relay(buf, tx->ctx->addr) &&
    cf48:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
    cf4c:	2a00      	cmp	r2, #0
    cf4e:	dc2f      	bgt.n	cfb0 <bt_mesh_net_send+0x134>
	bt_mesh_adv_send(buf, cb, cb_data);
    cf50:	463a      	mov	r2, r7
    cf52:	4631      	mov	r1, r6
    cf54:	4628      	mov	r0, r5
    cf56:	f7ff f881 	bl	c05c <bt_mesh_adv_send>
    cf5a:	e02b      	b.n	cfb4 <bt_mesh_net_send+0x138>
	    bt_mesh_has_addr(tx->ctx->addr)) {
    cf5c:	6863      	ldr	r3, [r4, #4]
    cf5e:	8898      	ldrh	r0, [r3, #4]
    cf60:	f003 ff9a 	bl	10e98 <bt_mesh_has_addr>
	if (bt_mesh_fixed_group_match(tx->ctx->addr) ||
    cf64:	2800      	cmp	r0, #0
    cf66:	d1b0      	bne.n	ceca <bt_mesh_net_send+0x4e>
	if (tx->ctx->send_ttl == 1U) {
    cf68:	6863      	ldr	r3, [r4, #4]
    cf6a:	7adb      	ldrb	r3, [r3, #11]
    cf6c:	2b01      	cmp	r3, #1
    cf6e:	d1ce      	bne.n	cf0e <bt_mesh_net_send+0x92>
		err = -EINVAL;
    cf70:	f06f 0b15 	mvn.w	fp, #21
    cf74:	e01e      	b.n	cfb4 <bt_mesh_net_send+0x138>
	buf->sub = tx->sub;
    cf76:	9802      	ldr	r0, [sp, #8]
    cf78:	6822      	ldr	r2, [r4, #0]
    cf7a:	6042      	str	r2, [r0, #4]
	(void)memcpy(buf->data, data, len);
    cf7c:	9901      	ldr	r1, [sp, #4]
    cf7e:	4652      	mov	r2, sl
    cf80:	3009      	adds	r0, #9
    cf82:	f01a fc75 	bl	27870 <memcpy>
	buf->len = len;
    cf86:	9a02      	ldr	r2, [sp, #8]
	return list->tail;
    cf88:	4918      	ldr	r1, [pc, #96]	; (cfec <bt_mesh_net_send+0x170>)
    cf8a:	f882 a008 	strb.w	sl, [r2, #8]
    cf8e:	6a08      	ldr	r0, [r1, #32]
	parent->next = child;
    cf90:	f8c2 b000 	str.w	fp, [r2]
Z_GENLIST_APPEND(slist, snode)
    cf94:	b928      	cbnz	r0, cfa2 <bt_mesh_net_send+0x126>
	list->head = node;
    cf96:	e9c1 2207 	strd	r2, r2, [r1, #28]
	k_work_submit(&bt_mesh.local_work);
    cf9a:	4815      	ldr	r0, [pc, #84]	; (cff0 <bt_mesh_net_send+0x174>)
    cf9c:	f017 f946 	bl	2422c <k_work_submit>
	return 0;
    cfa0:	e7ad      	b.n	cefe <bt_mesh_net_send+0x82>
	parent->next = child;
    cfa2:	6002      	str	r2, [r0, #0]
	list->tail = node;
    cfa4:	620a      	str	r2, [r1, #32]
}
    cfa6:	e7f8      	b.n	cf9a <bt_mesh_net_send+0x11e>
			if (!err) {
    cfa8:	f1bb 0f00 	cmp.w	fp, #0
    cfac:	d102      	bne.n	cfb4 <bt_mesh_net_send+0x138>
void bt_mesh_net_settings_commit(void);

static inline void send_cb_finalize(const struct bt_mesh_send_cb *cb,
				    void *cb_data)
{
	if (!cb) {
    cfae:	b946      	cbnz	r6, cfc2 <bt_mesh_net_send+0x146>
		return -ENOMEM;
    cfb0:	f04f 0b00 	mov.w	fp, #0
	net_buf_unref(buf);
    cfb4:	4628      	mov	r0, r5
    cfb6:	f013 fc6d 	bl	20894 <net_buf_unref>
}
    cfba:	4658      	mov	r0, fp
    cfbc:	b00b      	add	sp, #44	; 0x2c
    cfbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;
	}

	if (cb->start) {
    cfc2:	6834      	ldr	r4, [r6, #0]
    cfc4:	b11c      	cbz	r4, cfce <bt_mesh_net_send+0x152>
		cb->start(0, 0, cb_data);
    cfc6:	463a      	mov	r2, r7
    cfc8:	4659      	mov	r1, fp
    cfca:	4658      	mov	r0, fp
    cfcc:	47a0      	blx	r4
	}

	if (cb->end) {
    cfce:	6872      	ldr	r2, [r6, #4]
    cfd0:	2a00      	cmp	r2, #0
    cfd2:	d0ed      	beq.n	cfb0 <bt_mesh_net_send+0x134>
		cb->end(0, cb_data);
    cfd4:	4639      	mov	r1, r7
    cfd6:	2000      	movs	r0, #0
    cfd8:	4790      	blx	r2
    cfda:	e7eb      	b.n	cfb4 <bt_mesh_net_send+0x138>
    cfdc:	4683      	mov	fp, r0
    cfde:	e7e9      	b.n	cfb4 <bt_mesh_net_send+0x138>
    cfe0:	20000e80 	.word	0x20000e80
    cfe4:	00030bc8 	.word	0x00030bc8
    cfe8:	0002db3c 	.word	0x0002db3c
    cfec:	20001aa8 	.word	0x20001aa8
    cff0:	20001ab4 	.word	0x20001ab4

0000cff4 <bt_mesh_net_loopback_clear>:
{
    cff4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	list->tail = NULL;
    cff8:	2400      	movs	r4, #0
	return list->head;
    cffa:	4d14      	ldr	r5, [pc, #80]	; (d04c <bt_mesh_net_loopback_clear+0x58>)
			k_mem_slab_free(&loopback_buf_pool, (void **)&buf);
    cffc:	f8df 9050 	ldr.w	r9, [pc, #80]	; d050 <bt_mesh_net_loopback_clear+0x5c>
{
    d000:	4606      	mov	r6, r0
	list->head = NULL;
    d002:	4627      	mov	r7, r4
		if (net_idx == BT_MESH_KEY_ANY || net_idx == buf->sub->net_idx) {
    d004:	f64f 78ff 	movw	r8, #65535	; 0xffff
	return list->head;
    d008:	69eb      	ldr	r3, [r5, #28]
Z_GENLIST_GET(slist, snode)
    d00a:	b95b      	cbnz	r3, d024 <bt_mesh_net_loopback_clear+0x30>
	bt_mesh.local_queue = new_list;
    d00c:	e9c5 7407 	strd	r7, r4, [r5, #28]
}
    d010:	b003      	add	sp, #12
    d012:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	parent->next = child;
    d016:	2200      	movs	r2, #0
    d018:	601a      	str	r2, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
    d01a:	b10c      	cbz	r4, d020 <bt_mesh_net_loopback_clear+0x2c>
	parent->next = child;
    d01c:	6023      	str	r3, [r4, #0]
}
    d01e:	e013      	b.n	d048 <bt_mesh_net_loopback_clear+0x54>
	list->head = node;
    d020:	461f      	mov	r7, r3
    d022:	e011      	b.n	d048 <bt_mesh_net_loopback_clear+0x54>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    d024:	6a29      	ldr	r1, [r5, #32]
	return node->next;
    d026:	681a      	ldr	r2, [r3, #0]
	list->head = node;
    d028:	61ea      	str	r2, [r5, #28]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    d02a:	428b      	cmp	r3, r1
	list->tail = node;
    d02c:	bf08      	it	eq
    d02e:	622a      	streq	r2, [r5, #32]
		if (net_idx == BT_MESH_KEY_ANY || net_idx == buf->sub->net_idx) {
    d030:	4546      	cmp	r6, r8
		struct loopback_buf *buf = CONTAINER_OF(node, struct loopback_buf, node);
    d032:	9301      	str	r3, [sp, #4]
		if (net_idx == BT_MESH_KEY_ANY || net_idx == buf->sub->net_idx) {
    d034:	d003      	beq.n	d03e <bt_mesh_net_loopback_clear+0x4a>
    d036:	685a      	ldr	r2, [r3, #4]
    d038:	8b92      	ldrh	r2, [r2, #28]
    d03a:	42b2      	cmp	r2, r6
    d03c:	d1eb      	bne.n	d016 <bt_mesh_net_loopback_clear+0x22>
			k_mem_slab_free(&loopback_buf_pool, (void **)&buf);
    d03e:	a901      	add	r1, sp, #4
    d040:	4648      	mov	r0, r9
    d042:	f01f fce3 	bl	2ca0c <k_mem_slab_free>
    d046:	4623      	mov	r3, r4
    d048:	461c      	mov	r4, r3
    d04a:	e7dd      	b.n	d008 <bt_mesh_net_loopback_clear+0x14>
    d04c:	20001aa8 	.word	0x20001aa8
    d050:	20000e80 	.word	0x20000e80

0000d054 <bt_mesh_net_header_parse>:
{
    d054:	b510      	push	{r4, lr}
	rx->old_iv = (IVI(buf->data) != (bt_mesh.iv_index & 0x01));
    d056:	4b11      	ldr	r3, [pc, #68]	; (d09c <bt_mesh_net_header_parse+0x48>)
    d058:	6804      	ldr	r4, [r0, #0]
    d05a:	681b      	ldr	r3, [r3, #0]
    d05c:	7822      	ldrb	r2, [r4, #0]
    d05e:	f003 0301 	and.w	r3, r3, #1
    d062:	ea83 13d2 	eor.w	r3, r3, r2, lsr #7
    d066:	7d0a      	ldrb	r2, [r1, #20]
    d068:	f363 0200 	bfi	r2, r3, #0, #1
    d06c:	750a      	strb	r2, [r1, #20]
	rx->ctl = CTL(buf->data);
    d06e:	7863      	ldrb	r3, [r4, #1]
    d070:	b2d2      	uxtb	r2, r2
    d072:	09db      	lsrs	r3, r3, #7
    d074:	f363 02c3 	bfi	r2, r3, #3, #1
    d078:	750a      	strb	r2, [r1, #20]
	rx->ctx.recv_ttl = TTL(buf->data);
    d07a:	7863      	ldrb	r3, [r4, #1]
    d07c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    d080:	734b      	strb	r3, [r1, #13]
	rx->seq = SEQ(buf->data);
    d082:	1ca0      	adds	r0, r4, #2
    d084:	f01c f9f7 	bl	29476 <sys_get_be24>
    d088:	6108      	str	r0, [r1, #16]
	rx->ctx.addr = SRC(buf->data);
    d08a:	f8b4 3005 	ldrh.w	r3, [r4, #5]
    d08e:	ba5b      	rev16	r3, r3
    d090:	810b      	strh	r3, [r1, #8]
	rx->ctx.recv_dst = DST(buf->data);
    d092:	f8b4 3007 	ldrh.w	r3, [r4, #7]
    d096:	ba5b      	rev16	r3, r3
    d098:	814b      	strh	r3, [r1, #10]
}
    d09a:	bd10      	pop	{r4, pc}
    d09c:	20001aa8 	.word	0x20001aa8

0000d0a0 <bt_mesh_net_decode>:
{
    d0a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d0a4:	4699      	mov	r9, r3
	if (in->len < BT_MESH_NET_MIN_PDU_LEN) {
    d0a6:	8883      	ldrh	r3, [r0, #4]
    d0a8:	2b11      	cmp	r3, #17
{
    d0aa:	b08d      	sub	sp, #52	; 0x34
    d0ac:	4680      	mov	r8, r0
    d0ae:	460e      	mov	r6, r1
    d0b0:	4614      	mov	r4, r2
	if (in->len < BT_MESH_NET_MIN_PDU_LEN) {
    d0b2:	d820      	bhi.n	d0f6 <bt_mesh_net_decode+0x56>
		BT_WARN("Dropping too short mesh packet (len %u)", in->len);
    d0b4:	4a5a      	ldr	r2, [pc, #360]	; (d220 <bt_mesh_net_decode+0x180>)
    d0b6:	485b      	ldr	r0, [pc, #364]	; (d224 <bt_mesh_net_decode+0x184>)
    d0b8:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    d0bc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    d0c0:	2303      	movs	r3, #3
    d0c2:	aa09      	add	r2, sp, #36	; 0x24
    d0c4:	9305      	str	r3, [sp, #20]
    d0c6:	9309      	str	r3, [sp, #36]	; 0x24
    d0c8:	f01c f9dd 	bl	29486 <z_log_msg2_static_create.constprop.0>
		BT_WARN("%s", bt_hex(in->data, in->len));
    d0cc:	f8b8 1004 	ldrh.w	r1, [r8, #4]
    d0d0:	f8d8 0000 	ldr.w	r0, [r8]
    d0d4:	f7f8 f840 	bl	5158 <bt_hex_real>
    d0d8:	4b53      	ldr	r3, [pc, #332]	; (d228 <bt_mesh_net_decode+0x188>)
    d0da:	9301      	str	r3, [sp, #4]
    d0dc:	2300      	movs	r3, #0
    d0de:	9002      	str	r0, [sp, #8]
    d0e0:	4950      	ldr	r1, [pc, #320]	; (d224 <bt_mesh_net_decode+0x184>)
    d0e2:	9300      	str	r3, [sp, #0]
    d0e4:	2202      	movs	r2, #2
    d0e6:	4618      	mov	r0, r3
    d0e8:	f7ff fbec 	bl	c8c4 <z_log_msg2_runtime_create.constprop.0>
		return -EINVAL;
    d0ec:	f06f 0015 	mvn.w	r0, #21
}
    d0f0:	b00d      	add	sp, #52	; 0x34
    d0f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (in->len > BT_MESH_NET_MAX_PDU_LEN) {
    d0f6:	2b1d      	cmp	r3, #29
    d0f8:	d90c      	bls.n	d114 <bt_mesh_net_decode+0x74>
		BT_WARN("Dropping too long mesh packet (len %u)", in->len);
    d0fa:	4a4c      	ldr	r2, [pc, #304]	; (d22c <bt_mesh_net_decode+0x18c>)
    d0fc:	4849      	ldr	r0, [pc, #292]	; (d224 <bt_mesh_net_decode+0x184>)
    d0fe:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    d102:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    d106:	2303      	movs	r3, #3
    d108:	aa09      	add	r2, sp, #36	; 0x24
    d10a:	9305      	str	r3, [sp, #20]
    d10c:	9309      	str	r3, [sp, #36]	; 0x24
    d10e:	f01c f9ba 	bl	29486 <z_log_msg2_static_create.constprop.0>
    d112:	e7eb      	b.n	d0ec <bt_mesh_net_decode+0x4c>
	if (net_if == BT_MESH_NET_IF_ADV && check_dup(in)) {
    d114:	bb91      	cbnz	r1, d17c <bt_mesh_net_decode+0xdc>
	return buf->data + buf->len;
    d116:	6805      	ldr	r5, [r0, #0]
    d118:	441d      	add	r5, r3
	return ((uint16_t)src[0] << 8) | src[1];
    d11a:	f815 7c07 	ldrb.w	r7, [r5, #-7]
    d11e:	f815 3c08 	ldrb.w	r3, [r5, #-8]
    d122:	f815 2c06 	ldrb.w	r2, [r5, #-6]
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d126:	ea47 2303 	orr.w	r3, r7, r3, lsl #8
	return ((uint16_t)src[0] << 8) | src[1];
    d12a:	f815 7c05 	ldrb.w	r7, [r5, #-5]
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d12e:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
    d132:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
	return ((uint16_t)src[0] << 8) | src[1];
    d136:	f815 2c04 	ldrb.w	r2, [r5, #-4]
    d13a:	f815 3c03 	ldrb.w	r3, [r5, #-3]
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d13e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	return ((uint16_t)src[0] << 8) | src[1];
    d142:	f815 2c02 	ldrb.w	r2, [r5, #-2]
    d146:	f815 5c01 	ldrb.w	r5, [r5, #-1]
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
    d14a:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
    d14e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    d152:	4b37      	ldr	r3, [pc, #220]	; (d230 <bt_mesh_net_decode+0x190>)
	val = sys_get_be32(tail - 4) ^ sys_get_be32(tail - 8);
    d154:	407d      	eors	r5, r7
	for (i = 0; i < ARRAY_SIZE(dup_cache); i++) {
    d156:	460a      	mov	r2, r1
    d158:	4618      	mov	r0, r3
		if (dup_cache[i] == val) {
    d15a:	f853 1b04 	ldr.w	r1, [r3], #4
    d15e:	428d      	cmp	r5, r1
    d160:	d0c4      	beq.n	d0ec <bt_mesh_net_decode+0x4c>
	for (i = 0; i < ARRAY_SIZE(dup_cache); i++) {
    d162:	3201      	adds	r2, #1
    d164:	2a0a      	cmp	r2, #10
    d166:	d1f8      	bne.n	d15a <bt_mesh_net_decode+0xba>
	dup_cache[dup_cache_next++] = val;
    d168:	4932      	ldr	r1, [pc, #200]	; (d234 <bt_mesh_net_decode+0x194>)
    d16a:	680b      	ldr	r3, [r1, #0]
    d16c:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
    d170:	3301      	adds	r3, #1
	dup_cache_next %= ARRAY_SIZE(dup_cache);
    d172:	fb93 f0f2 	sdiv	r0, r3, r2
    d176:	fb02 3310 	mls	r3, r2, r0, r3
    d17a:	600b      	str	r3, [r1, #0]
	rx->net_if = net_if;
    d17c:	7d23      	ldrb	r3, [r4, #20]
    d17e:	f366 1305 	bfi	r3, r6, #4, #2
    d182:	7523      	strb	r3, [r4, #20]
	if (!bt_mesh_net_cred_find(rx, in, out, net_decrypt)) {
    d184:	464a      	mov	r2, r9
    d186:	4b2c      	ldr	r3, [pc, #176]	; (d238 <bt_mesh_net_decode+0x198>)
    d188:	4641      	mov	r1, r8
    d18a:	4620      	mov	r0, r4
    d18c:	f000 fcd2 	bl	db34 <bt_mesh_net_cred_find>
    d190:	2800      	cmp	r0, #0
    d192:	d042      	beq.n	d21a <bt_mesh_net_decode+0x17a>
	rx->ctx.recv_ttl = TTL(out->data);
    d194:	f8d9 1000 	ldr.w	r1, [r9]
	rx->ctl = CTL(out->data);
    d198:	7d22      	ldrb	r2, [r4, #20]
	rx->ctx.app_idx = BT_MESH_KEY_UNUSED;
    d19a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d19e:	80e3      	strh	r3, [r4, #6]
	rx->ctx.recv_ttl = TTL(out->data);
    d1a0:	784b      	ldrb	r3, [r1, #1]
    d1a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    d1a6:	7363      	strb	r3, [r4, #13]
	if (rx->ctx.recv_ttl == 0U) {
    d1a8:	3b00      	subs	r3, #0
    d1aa:	bf18      	it	ne
    d1ac:	2301      	movne	r3, #1
    d1ae:	425b      	negs	r3, r3
    d1b0:	73e3      	strb	r3, [r4, #15]
	rx->ctl = CTL(out->data);
    d1b2:	784b      	ldrb	r3, [r1, #1]
    d1b4:	09db      	lsrs	r3, r3, #7
    d1b6:	f363 02c3 	bfi	r2, r3, #3, #1
    d1ba:	7522      	strb	r2, [r4, #20]
	rx->seq = SEQ(out->data);
    d1bc:	1c88      	adds	r0, r1, #2
    d1be:	f01c f95a 	bl	29476 <sys_get_be24>
    d1c2:	6120      	str	r0, [r4, #16]
	return ((uint16_t)src[0] << 8) | src[1];
    d1c4:	f8b1 3007 	ldrh.w	r3, [r1, #7]
	if (net_if != BT_MESH_NET_IF_PROXY_CFG &&
    d1c8:	2e03      	cmp	r6, #3
    d1ca:	ba5b      	rev16	r3, r3
    d1cc:	b29a      	uxth	r2, r3
	rx->ctx.recv_dst = DST(out->data);
    d1ce:	8163      	strh	r3, [r4, #10]
	if (net_if != BT_MESH_NET_IF_PROXY_CFG &&
    d1d0:	d00e      	beq.n	d1f0 <bt_mesh_net_decode+0x150>
    d1d2:	b96a      	cbnz	r2, d1f0 <bt_mesh_net_decode+0x150>
		BT_ERR("Destination address is unassigned; dropping packet");
    d1d4:	4b19      	ldr	r3, [pc, #100]	; (d23c <bt_mesh_net_decode+0x19c>)
    d1d6:	4813      	ldr	r0, [pc, #76]	; (d224 <bt_mesh_net_decode+0x184>)
    d1d8:	930a      	str	r3, [sp, #40]	; 0x28
    d1da:	aa09      	add	r2, sp, #36	; 0x24
    d1dc:	2302      	movs	r3, #2
    d1de:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d1e2:	9305      	str	r3, [sp, #20]
    d1e4:	9309      	str	r3, [sp, #36]	; 0x24
    d1e6:	f01c f94e 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return -EBADMSG;
    d1ea:	f06f 004c 	mvn.w	r0, #76	; 0x4c
    d1ee:	e77f      	b.n	d0f0 <bt_mesh_net_decode+0x50>
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d1f0:	8922      	ldrh	r2, [r4, #8]
	rx->msg_cache_idx = msg_cache_next++;
    d1f2:	4913      	ldr	r1, [pc, #76]	; (d240 <bt_mesh_net_decode+0x1a0>)
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d1f4:	f3c2 020e 	ubfx	r2, r2, #0, #15
	rx->msg_cache_idx = msg_cache_next++;
    d1f8:	880b      	ldrh	r3, [r1, #0]
    d1fa:	82e3      	strh	r3, [r4, #22]
	msg_cache[rx->msg_cache_idx].src = rx->ctx.addr;
    d1fc:	ea42 30c0 	orr.w	r0, r2, r0, lsl #15
    d200:	4a10      	ldr	r2, [pc, #64]	; (d244 <bt_mesh_net_decode+0x1a4>)
    d202:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	rx->msg_cache_idx = msg_cache_next++;
    d206:	3301      	adds	r3, #1
	msg_cache_next %= ARRAY_SIZE(msg_cache);
    d208:	b29b      	uxth	r3, r3
    d20a:	220a      	movs	r2, #10
    d20c:	fbb3 f0f2 	udiv	r0, r3, r2
    d210:	fb02 3310 	mls	r3, r2, r0, r3
    d214:	800b      	strh	r3, [r1, #0]
	return 0;
    d216:	2000      	movs	r0, #0
}
    d218:	e76a      	b.n	d0f0 <bt_mesh_net_decode+0x50>
		return -ENOENT;
    d21a:	f06f 0001 	mvn.w	r0, #1
    d21e:	e767      	b.n	d0f0 <bt_mesh_net_decode+0x50>
    d220:	00030be4 	.word	0x00030be4
    d224:	0002db3c 	.word	0x0002db3c
    d228:	00033605 	.word	0x00033605
    d22c:	00030c0c 	.word	0x00030c0c
    d230:	20002708 	.word	0x20002708
    d234:	20002730 	.word	0x20002730
    d238:	0000c70d 	.word	0x0000c70d
    d23c:	00030c33 	.word	0x00030c33
    d240:	2000389c 	.word	0x2000389c
    d244:	20002734 	.word	0x20002734

0000d248 <bt_mesh_net_recv>:
{
    d248:	b5f0      	push	{r4, r5, r6, r7, lr}
    d24a:	b09b      	sub	sp, #108	; 0x6c
	NET_BUF_SIMPLE_DEFINE(buf, BT_MESH_NET_MAX_PDU_LEN);
    d24c:	ab12      	add	r3, sp, #72	; 0x48
{
    d24e:	4614      	mov	r4, r2
	NET_BUF_SIMPLE_DEFINE(buf, BT_MESH_NET_MAX_PDU_LEN);
    d250:	f44f 12e8 	mov.w	r2, #1900544	; 0x1d0000
    d254:	e9cd 2304 	strd	r2, r3, [sp, #16]
{
    d258:	460d      	mov	r5, r1
    d25a:	4606      	mov	r6, r0
	struct bt_mesh_net_rx rx = { .ctx.recv_rssi = rssi };
    d25c:	2218      	movs	r2, #24
    d25e:	2100      	movs	r1, #0
    d260:	a80c      	add	r0, sp, #48	; 0x30
	NET_BUF_SIMPLE_DEFINE(buf, BT_MESH_NET_MAX_PDU_LEN);
    d262:	9303      	str	r3, [sp, #12]
	struct bt_mesh_net_rx rx = { .ctx.recv_rssi = rssi };
    d264:	f01a fb0f 	bl	27886 <memset>
    d268:	f88d 503c 	strb.w	r5, [sp, #60]	; 0x3c
	if (!bt_mesh_is_provisioned()) {
    d26c:	f7fe fba8 	bl	b9c0 <bt_mesh_is_provisioned>
    d270:	2800      	cmp	r0, #0
    d272:	d07d      	beq.n	d370 <bt_mesh_net_recv+0x128>
	if (bt_mesh_net_decode(data, net_if, &rx, &buf)) {
    d274:	ab03      	add	r3, sp, #12
    d276:	aa0c      	add	r2, sp, #48	; 0x30
    d278:	4621      	mov	r1, r4
    d27a:	4630      	mov	r0, r6
    d27c:	f7ff ff10 	bl	d0a0 <bt_mesh_net_decode>
    d280:	2800      	cmp	r0, #0
    d282:	d175      	bne.n	d370 <bt_mesh_net_recv+0x128>
	state->offset = net_buf_simple_headroom(buf);
    d284:	a803      	add	r0, sp, #12
    d286:	f01e fdfc 	bl	2be82 <net_buf_simple_headroom>
    d28a:	4605      	mov	r5, r0
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d28c:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
	state->len = buf->len;
    d290:	f8bd 7010 	ldrh.w	r7, [sp, #16]
    d294:	f01c f881 	bl	2939a <bt_mesh_fixed_group_match>
    d298:	bb20      	cbnz	r0, d2e4 <bt_mesh_net_recv+0x9c>
			  bt_mesh_has_addr(rx.ctx.recv_dst));
    d29a:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
    d29e:	f003 fdfb 	bl	10e98 <bt_mesh_has_addr>
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d2a2:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d2a6:	2c02      	cmp	r4, #2
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d2a8:	f360 1386 	bfi	r3, r0, #6, #1
    d2ac:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d2b0:	d11a      	bne.n	d2e8 <bt_mesh_net_recv+0xa0>
		bt_mesh_proxy_addr_add(data, rx.ctx.addr);
    d2b2:	f8bd 1038 	ldrh.w	r1, [sp, #56]	; 0x38
    d2b6:	4630      	mov	r0, r6
    d2b8:	f00b fda8 	bl	18e0c <bt_mesh_proxy_addr_add>
		if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_DISABLED &&
    d2bc:	f7fe fcd4 	bl	bc68 <bt_mesh_gatt_proxy_get>
		    !rx.local_match) {
    d2c0:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    d2c4:	f003 0340 	and.w	r3, r3, #64	; 0x40
		if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_DISABLED &&
    d2c8:	4318      	orrs	r0, r3
    d2ca:	b2c0      	uxtb	r0, r0
    d2cc:	b960      	cbnz	r0, d2e8 <bt_mesh_net_recv+0xa0>
			BT_INFO("Proxy is disabled; ignoring message");
    d2ce:	4b6d      	ldr	r3, [pc, #436]	; (d484 <bt_mesh_net_recv+0x23c>)
    d2d0:	930a      	str	r3, [sp, #40]	; 0x28
    d2d2:	9402      	str	r4, [sp, #8]
    d2d4:	9409      	str	r4, [sp, #36]	; 0x24
    d2d6:	aa09      	add	r2, sp, #36	; 0x24
    d2d8:	f44f 5186 	mov.w	r1, #4288	; 0x10c0
		BT_ERR("Out of relay buffers");
    d2dc:	486a      	ldr	r0, [pc, #424]	; (d488 <bt_mesh_net_recv+0x240>)
    d2de:	f01c f8d2 	bl	29486 <z_log_msg2_static_create.constprop.0>
		return;
    d2e2:	e045      	b.n	d370 <bt_mesh_net_recv+0x128>
	rx.local_match = (bt_mesh_fixed_group_match(rx.ctx.recv_dst) ||
    d2e4:	2001      	movs	r0, #1
    d2e6:	e7dc      	b.n	d2a2 <bt_mesh_net_recv+0x5a>
	if (bt_mesh_trans_recv(&buf, &rx) == -EAGAIN) {
    d2e8:	a90c      	add	r1, sp, #48	; 0x30
    d2ea:	a803      	add	r0, sp, #12
    d2ec:	f002 fa3a 	bl	f764 <bt_mesh_trans_recv>
    d2f0:	300b      	adds	r0, #11
    d2f2:	d115      	bne.n	d320 <bt_mesh_net_recv+0xd8>
		BT_WARN("Removing rejected message from Network Message Cache");
    d2f4:	4b65      	ldr	r3, [pc, #404]	; (d48c <bt_mesh_net_recv+0x244>)
    d2f6:	930a      	str	r3, [sp, #40]	; 0x28
    d2f8:	aa09      	add	r2, sp, #36	; 0x24
    d2fa:	2302      	movs	r3, #2
    d2fc:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    d300:	4861      	ldr	r0, [pc, #388]	; (d488 <bt_mesh_net_recv+0x240>)
    d302:	9302      	str	r3, [sp, #8]
    d304:	9309      	str	r3, [sp, #36]	; 0x24
    d306:	f01c f8be 	bl	29486 <z_log_msg2_static_create.constprop.0>
		msg_cache[rx.msg_cache_idx].src = BT_MESH_ADDR_UNASSIGNED;
    d30a:	4a61      	ldr	r2, [pc, #388]	; (d490 <bt_mesh_net_recv+0x248>)
    d30c:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
    d310:	f832 1023 	ldrh.w	r1, [r2, r3, lsl #2]
    d314:	f36f 010e 	bfc	r1, #0, #15
    d318:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
		msg_cache_next = rx.msg_cache_idx;
    d31c:	4a5d      	ldr	r2, [pc, #372]	; (d494 <bt_mesh_net_recv+0x24c>)
    d31e:	8013      	strh	r3, [r2, #0]
	if (!BT_MESH_ADDR_IS_UNICAST(rx.ctx.recv_dst) ||
    d320:	f9bd 303a 	ldrsh.w	r3, [sp, #58]	; 0x3a
    d324:	2b00      	cmp	r3, #0
    d326:	dd04      	ble.n	d332 <bt_mesh_net_recv+0xea>
	    (!rx.local_match && !rx.friend_match)) {
    d328:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
	if (!BT_MESH_ADDR_IS_UNICAST(rx.ctx.recv_dst) ||
    d32c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    d330:	d11e      	bne.n	d370 <bt_mesh_net_recv+0x128>
	buf->data = buf->__buf + state->offset;
    d332:	9805      	ldr	r0, [sp, #20]
	if (rx->ctx.recv_ttl <= 1U) {
    d334:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
	buf->len = state->len;
    d338:	f8ad 7010 	strh.w	r7, [sp, #16]
	buf->data = buf->__buf + state->offset;
    d33c:	fa10 f585 	uxtah	r5, r0, r5
    d340:	2b01      	cmp	r3, #1
    d342:	9503      	str	r5, [sp, #12]
    d344:	d914      	bls.n	d370 <bt_mesh_net_recv+0x128>
	if (rx->net_if == BT_MESH_NET_IF_ADV &&
    d346:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    d34a:	f013 0f34 	tst.w	r3, #52	; 0x34
    d34e:	d108      	bne.n	d362 <bt_mesh_net_recv+0x11a>
	    bt_mesh_relay_get() != BT_MESH_RELAY_ENABLED &&
    d350:	f7fe fd5c 	bl	be0c <bt_mesh_relay_get>
	    !rx->friend_cred &&
    d354:	2801      	cmp	r0, #1
    d356:	d107      	bne.n	d368 <bt_mesh_net_recv+0x120>
	if (rx->net_if == BT_MESH_NET_IF_ADV && !rx->friend_cred) {
    d358:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    d35c:	f013 0f34 	tst.w	r3, #52	; 0x34
    d360:	d008      	beq.n	d374 <bt_mesh_net_recv+0x12c>
		transmit = bt_mesh_net_transmit_get();
    d362:	f7fe fce9 	bl	bd38 <bt_mesh_net_transmit_get>
    d366:	e007      	b.n	d378 <bt_mesh_net_recv+0x130>
	    bt_mesh_gatt_proxy_get() != BT_MESH_GATT_PROXY_ENABLED) {
    d368:	f7fe fc7e 	bl	bc68 <bt_mesh_gatt_proxy_get>
	    bt_mesh_relay_get() != BT_MESH_RELAY_ENABLED &&
    d36c:	2801      	cmp	r0, #1
    d36e:	d0f3      	beq.n	d358 <bt_mesh_net_recv+0x110>
}
    d370:	b01b      	add	sp, #108	; 0x6c
    d372:	bdf0      	pop	{r4, r5, r6, r7, pc}
		transmit = bt_mesh_relay_retransmit_get();
    d374:	f7fe fd54 	bl	be20 <bt_mesh_relay_retransmit_get>
		transmit = bt_mesh_net_transmit_get();
    d378:	4602      	mov	r2, r0
				 transmit, K_NO_WAIT);
    d37a:	2100      	movs	r1, #0
    d37c:	2000      	movs	r0, #0
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_RELAY_ADV,
    d37e:	e9cd 0100 	strd	r0, r1, [sp]
    d382:	2102      	movs	r1, #2
    d384:	2001      	movs	r0, #1
    d386:	f7fe fe0f 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
    d38a:	4604      	mov	r4, r0
    d38c:	b940      	cbnz	r0, d3a0 <bt_mesh_net_recv+0x158>
		BT_ERR("Out of relay buffers");
    d38e:	4b42      	ldr	r3, [pc, #264]	; (d498 <bt_mesh_net_recv+0x250>)
    d390:	930a      	str	r3, [sp, #40]	; 0x28
    d392:	2302      	movs	r3, #2
    d394:	9302      	str	r3, [sp, #8]
    d396:	9309      	str	r3, [sp, #36]	; 0x24
    d398:	aa09      	add	r2, sp, #36	; 0x24
    d39a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d39e:	e79d      	b.n	d2dc <bt_mesh_net_recv+0x94>
	sbuf->data[1] &= 0x80;
    d3a0:	9a03      	ldr	r2, [sp, #12]
    d3a2:	7853      	ldrb	r3, [r2, #1]
    d3a4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    d3a8:	7053      	strb	r3, [r2, #1]
	sbuf->data[1] |= rx->ctx.recv_ttl - 1U;
    d3aa:	9a03      	ldr	r2, [sp, #12]
    d3ac:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
    d3b0:	7851      	ldrb	r1, [r2, #1]
    d3b2:	3b01      	subs	r3, #1
    d3b4:	430b      	orrs	r3, r1
    d3b6:	7053      	strb	r3, [r2, #1]
	return net_buf_simple_add_mem(&buf->b, mem, len);
    d3b8:	f100 0508 	add.w	r5, r0, #8
    d3bc:	f8bd 2010 	ldrh.w	r2, [sp, #16]
    d3c0:	9903      	ldr	r1, [sp, #12]
    d3c2:	4628      	mov	r0, r5
    d3c4:	f01e fcc0 	bl	2bd48 <net_buf_simple_add_mem>
	cred = &rx->sub->keys[SUBNET_KEY_TX_IDX(rx->sub)].msg;
    d3c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	if (rx->friend_cred) {
    d3ca:	f89d 0044 	ldrb.w	r0, [sp, #68]	; 0x44
	cred = &rx->sub->keys[SUBNET_KEY_TX_IDX(rx->sub)].msg;
    d3ce:	7f93      	ldrb	r3, [r2, #30]
    d3d0:	1e99      	subs	r1, r3, #2
    d3d2:	424b      	negs	r3, r1
    d3d4:	414b      	adcs	r3, r1
    d3d6:	215a      	movs	r1, #90	; 0x5a
    d3d8:	434b      	muls	r3, r1
    d3da:	f103 013d 	add.w	r1, r3, #61	; 0x3d
	if (rx->friend_cred) {
    d3de:	0740      	lsls	r0, r0, #29
	cred = &rx->sub->keys[SUBNET_KEY_TX_IDX(rx->sub)].msg;
    d3e0:	4411      	add	r1, r2
	if (rx->friend_cred) {
    d3e2:	d50b      	bpl.n	d3fc <bt_mesh_net_recv+0x1b4>
		buf->data[0] &= 0x80; /* Clear everything except IVI */
    d3e4:	68a6      	ldr	r6, [r4, #8]
    d3e6:	7830      	ldrb	r0, [r6, #0]
    d3e8:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
    d3ec:	7030      	strb	r0, [r6, #0]
		buf->data[0] |= cred->nid;
    d3ee:	68a0      	ldr	r0, [r4, #8]
    d3f0:	4413      	add	r3, r2
    d3f2:	7802      	ldrb	r2, [r0, #0]
    d3f4:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
    d3f8:	4313      	orrs	r3, r2
    d3fa:	7003      	strb	r3, [r0, #0]
	if (net_encrypt(&buf->b, cred, BT_MESH_NET_IVI_RX(rx), false)) {
    d3fc:	4b27      	ldr	r3, [pc, #156]	; (d49c <bt_mesh_net_recv+0x254>)
    d3fe:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
    d402:	6818      	ldr	r0, [r3, #0]
    d404:	f002 0201 	and.w	r2, r2, #1
    d408:	1a82      	subs	r2, r0, r2
    d40a:	2300      	movs	r3, #0
    d40c:	4628      	mov	r0, r5
    d40e:	f01c f83d 	bl	2948c <net_encrypt>
    d412:	b170      	cbz	r0, d432 <bt_mesh_net_recv+0x1ea>
		BT_ERR("Re-encrypting failed");
    d414:	4b22      	ldr	r3, [pc, #136]	; (d4a0 <bt_mesh_net_recv+0x258>)
    d416:	930a      	str	r3, [sp, #40]	; 0x28
    d418:	481b      	ldr	r0, [pc, #108]	; (d488 <bt_mesh_net_recv+0x240>)
    d41a:	2302      	movs	r3, #2
    d41c:	aa09      	add	r2, sp, #36	; 0x24
    d41e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d422:	9302      	str	r3, [sp, #8]
    d424:	9309      	str	r3, [sp, #36]	; 0x24
    d426:	f01c f82e 	bl	29486 <z_log_msg2_static_create.constprop.0>
	net_buf_unref(buf);
    d42a:	4620      	mov	r0, r4
    d42c:	f013 fa32 	bl	20894 <net_buf_unref>
    d430:	e79e      	b.n	d370 <bt_mesh_net_recv+0x128>
	    (rx->friend_cred ||
    d432:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d436:	075a      	lsls	r2, r3, #29
    d438:	d512      	bpl.n	d460 <bt_mesh_net_recv+0x218>
		bt_mesh_proxy_relay(buf, rx->ctx.recv_dst);
    d43a:	f8bd 103a 	ldrh.w	r1, [sp, #58]	; 0x3a
    d43e:	4620      	mov	r0, r4
    d440:	f00b fd16 	bl	18e70 <bt_mesh_proxy_relay>
	if (relay_to_adv(rx->net_if) || rx->friend_cred) {
    d444:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
	switch (net_if) {
    d448:	f013 0f30 	tst.w	r3, #48	; 0x30
	if (relay_to_adv(rx->net_if) || rx->friend_cred) {
    d44c:	f3c3 1201 	ubfx	r2, r3, #4, #2
	switch (net_if) {
    d450:	d00b      	beq.n	d46a <bt_mesh_net_recv+0x222>
    d452:	2a02      	cmp	r2, #2
    d454:	d013      	beq.n	d47e <bt_mesh_net_recv+0x236>
	if (relay_to_adv(rx->net_if) || rx->friend_cred) {
    d456:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    d45a:	075b      	lsls	r3, r3, #29
    d45c:	d409      	bmi.n	d472 <bt_mesh_net_recv+0x22a>
done:
    d45e:	e7e4      	b.n	d42a <bt_mesh_net_recv+0x1e2>
	     bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED)) {
    d460:	f7fe fc02 	bl	bc68 <bt_mesh_gatt_proxy_get>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) &&
    d464:	2801      	cmp	r0, #1
    d466:	d1ed      	bne.n	d444 <bt_mesh_net_recv+0x1fc>
    d468:	e7e7      	b.n	d43a <bt_mesh_net_recv+0x1f2>
		return (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED);
    d46a:	f7fe fccf 	bl	be0c <bt_mesh_relay_get>
	if (relay_to_adv(rx->net_if) || rx->friend_cred) {
    d46e:	2801      	cmp	r0, #1
    d470:	d1f1      	bne.n	d456 <bt_mesh_net_recv+0x20e>
		bt_mesh_adv_send(buf, NULL, NULL);
    d472:	2200      	movs	r2, #0
    d474:	4611      	mov	r1, r2
    d476:	4620      	mov	r0, r4
    d478:	f7fe fdf0 	bl	c05c <bt_mesh_adv_send>
    d47c:	e7d5      	b.n	d42a <bt_mesh_net_recv+0x1e2>
		return (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
    d47e:	f7fe fbf3 	bl	bc68 <bt_mesh_gatt_proxy_get>
    d482:	e7f4      	b.n	d46e <bt_mesh_net_recv+0x226>
    d484:	00030c66 	.word	0x00030c66
    d488:	0002db3c 	.word	0x0002db3c
    d48c:	00030c8a 	.word	0x00030c8a
    d490:	20002734 	.word	0x20002734
    d494:	2000389c 	.word	0x2000389c
    d498:	00030cbf 	.word	0x00030cbf
    d49c:	20001aa8 	.word	0x20001aa8
    d4a0:	00030cd4 	.word	0x00030cd4

0000d4a4 <bt_mesh_net_init>:
{
    d4a4:	b510      	push	{r4, lr}
	k_work_init_delayable(&bt_mesh.ivu_timer, ivu_refresh);
    d4a6:	4c06      	ldr	r4, [pc, #24]	; (d4c0 <bt_mesh_net_init+0x1c>)
    d4a8:	4906      	ldr	r1, [pc, #24]	; (d4c4 <bt_mesh_net_init+0x20>)
    d4aa:	f504 7000 	add.w	r0, r4, #512	; 0x200
    d4ae:	f01f fc9c 	bl	2cdea <k_work_init_delayable>
	k_work_init(&bt_mesh.local_work, bt_mesh_net_local);
    d4b2:	f104 000c 	add.w	r0, r4, #12
    d4b6:	4904      	ldr	r1, [pc, #16]	; (d4c8 <bt_mesh_net_init+0x24>)
}
    d4b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_init(&bt_mesh.local_work, bt_mesh_net_local);
    d4bc:	f01f bc5f 	b.w	2cd7e <k_work_init>
    d4c0:	20001aa8 	.word	0x20001aa8
    d4c4:	0000cccd 	.word	0x0000cccd
    d4c8:	0000c8e9 	.word	0x0000c8e9

0000d4cc <bt_mesh_net_pending_iv_store>:
		BT_DBG("Stored IV value");
	}
}

void bt_mesh_net_pending_iv_store(void)
{
    d4cc:	b500      	push	{lr}
    d4ce:	b08b      	sub	sp, #44	; 0x2c
    d4d0:	f7ff fa6a 	bl	c9a8 <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    d4d4:	07c3      	lsls	r3, r0, #31
    d4d6:	d520      	bpl.n	d51a <bt_mesh_net_pending_iv_store+0x4e>
	iv.iv_index = bt_mesh.iv_index;
    d4d8:	4a15      	ldr	r2, [pc, #84]	; (d530 <bt_mesh_net_pending_iv_store+0x64>)
    d4da:	6813      	ldr	r3, [r2, #0]
    d4dc:	9302      	str	r3, [sp, #8]
    d4de:	f7ff fa63 	bl	c9a8 <atomic_get.constprop.0>
	iv.iv_update = atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS);
    d4e2:	f892 31f8 	ldrb.w	r3, [r2, #504]	; 0x1f8
    d4e6:	f3c0 0080 	ubfx	r0, r0, #2, #1
    d4ea:	ea40 0043 	orr.w	r0, r0, r3, lsl #1
    d4ee:	f88d 000c 	strb.w	r0, [sp, #12]
	err = settings_save_one("bt/mesh/IV", &iv, sizeof(iv));
    d4f2:	2205      	movs	r2, #5
    d4f4:	480f      	ldr	r0, [pc, #60]	; (d534 <bt_mesh_net_pending_iv_store+0x68>)
    d4f6:	a902      	add	r1, sp, #8
    d4f8:	f7f6 fb82 	bl	3c00 <settings_save_one>
	if (err) {
    d4fc:	b150      	cbz	r0, d514 <bt_mesh_net_pending_iv_store+0x48>
		BT_ERR("Failed to store IV value");
    d4fe:	4b0e      	ldr	r3, [pc, #56]	; (d538 <bt_mesh_net_pending_iv_store+0x6c>)
    d500:	9308      	str	r3, [sp, #32]
    d502:	2302      	movs	r3, #2
    d504:	9301      	str	r3, [sp, #4]
		BT_ERR("Failed to clear IV");
    d506:	480d      	ldr	r0, [pc, #52]	; (d53c <bt_mesh_net_pending_iv_store+0x70>)
    d508:	9307      	str	r3, [sp, #28]
    d50a:	aa07      	add	r2, sp, #28
    d50c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d510:	f01b ffb9 	bl	29486 <z_log_msg2_static_create.constprop.0>
		store_pending_iv();
	} else {
		clear_iv();
	}
}
    d514:	b00b      	add	sp, #44	; 0x2c
    d516:	f85d fb04 	ldr.w	pc, [sp], #4
	err = settings_delete("bt/mesh/IV");
    d51a:	4806      	ldr	r0, [pc, #24]	; (d534 <bt_mesh_net_pending_iv_store+0x68>)
    d51c:	f018 fe6b 	bl	261f6 <settings_delete>
	if (err) {
    d520:	2800      	cmp	r0, #0
    d522:	d0f7      	beq.n	d514 <bt_mesh_net_pending_iv_store+0x48>
		BT_ERR("Failed to clear IV");
    d524:	4b06      	ldr	r3, [pc, #24]	; (d540 <bt_mesh_net_pending_iv_store+0x74>)
    d526:	9308      	str	r3, [sp, #32]
    d528:	2302      	movs	r3, #2
    d52a:	9302      	str	r3, [sp, #8]
    d52c:	e7eb      	b.n	d506 <bt_mesh_net_pending_iv_store+0x3a>
    d52e:	bf00      	nop
    d530:	20001aa8 	.word	0x20001aa8
    d534:	00030ce9 	.word	0x00030ce9
    d538:	00030cf4 	.word	0x00030cf4
    d53c:	0002db3c 	.word	0x0002db3c
    d540:	00030d0d 	.word	0x00030d0d

0000d544 <bt_mesh_net_pending_net_store>:
		BT_DBG("Stored Network value");
	}
}

void bt_mesh_net_pending_net_store(void)
{
    d544:	b500      	push	{lr}
    d546:	b08d      	sub	sp, #52	; 0x34
    d548:	f7ff fa2e 	bl	c9a8 <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    d54c:	07c3      	lsls	r3, r0, #31
    d54e:	d51d      	bpl.n	d58c <bt_mesh_net_pending_net_store+0x48>
	net.primary_addr = bt_mesh_primary_addr();
    d550:	f003 fc88 	bl	10e64 <bt_mesh_primary_addr>
	memcpy(net.dev_key, bt_mesh.dev_key, 16);
    d554:	4912      	ldr	r1, [pc, #72]	; (d5a0 <bt_mesh_net_pending_net_store+0x5c>)
	net.primary_addr = bt_mesh_primary_addr();
    d556:	f8ad 0004 	strh.w	r0, [sp, #4]
	memcpy(net.dev_key, bt_mesh.dev_key, 16);
    d55a:	2210      	movs	r2, #16
    d55c:	f10d 0006 	add.w	r0, sp, #6
    d560:	f01a f986 	bl	27870 <memcpy>
	err = settings_save_one("bt/mesh/Net", &net, sizeof(net));
    d564:	480f      	ldr	r0, [pc, #60]	; (d5a4 <bt_mesh_net_pending_net_store+0x60>)
    d566:	2212      	movs	r2, #18
    d568:	a901      	add	r1, sp, #4
    d56a:	f7f6 fb49 	bl	3c00 <settings_save_one>
	if (err) {
    d56e:	b150      	cbz	r0, d586 <bt_mesh_net_pending_net_store+0x42>
		BT_ERR("Failed to store Network value");
    d570:	4b0d      	ldr	r3, [pc, #52]	; (d5a8 <bt_mesh_net_pending_net_store+0x64>)
    d572:	930a      	str	r3, [sp, #40]	; 0x28
    d574:	2302      	movs	r3, #2
    d576:	9300      	str	r3, [sp, #0]
		BT_ERR("Failed to clear Network");
    d578:	480c      	ldr	r0, [pc, #48]	; (d5ac <bt_mesh_net_pending_net_store+0x68>)
    d57a:	9309      	str	r3, [sp, #36]	; 0x24
    d57c:	aa09      	add	r2, sp, #36	; 0x24
    d57e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d582:	f01b ff80 	bl	29486 <z_log_msg2_static_create.constprop.0>
		store_pending_net();
	} else {
		clear_net();
	}
}
    d586:	b00d      	add	sp, #52	; 0x34
    d588:	f85d fb04 	ldr.w	pc, [sp], #4
	err = settings_delete("bt/mesh/Net");
    d58c:	4805      	ldr	r0, [pc, #20]	; (d5a4 <bt_mesh_net_pending_net_store+0x60>)
    d58e:	f018 fe32 	bl	261f6 <settings_delete>
	if (err) {
    d592:	2800      	cmp	r0, #0
    d594:	d0f7      	beq.n	d586 <bt_mesh_net_pending_net_store+0x42>
		BT_ERR("Failed to clear Network");
    d596:	4b06      	ldr	r3, [pc, #24]	; (d5b0 <bt_mesh_net_pending_net_store+0x6c>)
    d598:	930a      	str	r3, [sp, #40]	; 0x28
    d59a:	2302      	movs	r3, #2
    d59c:	9301      	str	r3, [sp, #4]
    d59e:	e7eb      	b.n	d578 <bt_mesh_net_pending_net_store+0x34>
    d5a0:	20001cd8 	.word	0x20001cd8
    d5a4:	00030d20 	.word	0x00030d20
    d5a8:	00030d2c 	.word	0x00030d2c
    d5ac:	0002db3c 	.word	0x0002db3c
    d5b0:	00030d4a 	.word	0x00030d4a

0000d5b4 <bt_mesh_net_pending_seq_store>:

void bt_mesh_net_pending_seq_store(void)
{
    d5b4:	b500      	push	{lr}
    d5b6:	b089      	sub	sp, #36	; 0x24
    d5b8:	f7ff f9f6 	bl	c9a8 <atomic_get.constprop.0>
	struct seq_val seq;
	int err;

	if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    d5bc:	07c3      	lsls	r3, r0, #31
    d5be:	d51e      	bpl.n	d5fe <bt_mesh_net_pending_seq_store+0x4a>
		sys_put_le24(bt_mesh.seq, seq.val);
    d5c0:	4b12      	ldr	r3, [pc, #72]	; (d60c <bt_mesh_net_pending_seq_store+0x58>)

		err = settings_save_one("bt/mesh/Seq", &seq, sizeof(seq));
    d5c2:	4813      	ldr	r0, [pc, #76]	; (d610 <bt_mesh_net_pending_seq_store+0x5c>)
		sys_put_le24(bt_mesh.seq, seq.val);
    d5c4:	685b      	ldr	r3, [r3, #4]
	dst[0] = val;
    d5c6:	f88d 3000 	strb.w	r3, [sp]
	dst[1] = val >> 8;
    d5ca:	f3c3 2207 	ubfx	r2, r3, #8, #8
    d5ce:	f88d 2001 	strb.w	r2, [sp, #1]
	dst[2] = val >> 16;
    d5d2:	0c1b      	lsrs	r3, r3, #16
		err = settings_save_one("bt/mesh/Seq", &seq, sizeof(seq));
    d5d4:	2203      	movs	r2, #3
    d5d6:	4669      	mov	r1, sp
    d5d8:	f88d 3002 	strb.w	r3, [sp, #2]
    d5dc:	f7f6 fb10 	bl	3c00 <settings_save_one>
		if (err) {
    d5e0:	b150      	cbz	r0, d5f8 <bt_mesh_net_pending_seq_store+0x44>
			BT_ERR("Failed to stor Seq value");
    d5e2:	4b0c      	ldr	r3, [pc, #48]	; (d614 <bt_mesh_net_pending_seq_store+0x60>)
			BT_DBG("Stored Seq value");
		}
	} else {
		err = settings_delete("bt/mesh/Seq");
		if (err) {
			BT_ERR("Failed to clear Seq value");
    d5e4:	9306      	str	r3, [sp, #24]
    d5e6:	480c      	ldr	r0, [pc, #48]	; (d618 <bt_mesh_net_pending_seq_store+0x64>)
    d5e8:	2302      	movs	r3, #2
    d5ea:	aa05      	add	r2, sp, #20
    d5ec:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d5f0:	9301      	str	r3, [sp, #4]
    d5f2:	9305      	str	r3, [sp, #20]
    d5f4:	f01b ff47 	bl	29486 <z_log_msg2_static_create.constprop.0>
		} else {
			BT_DBG("Cleared Seq value");
		}
	}
}
    d5f8:	b009      	add	sp, #36	; 0x24
    d5fa:	f85d fb04 	ldr.w	pc, [sp], #4
		err = settings_delete("bt/mesh/Seq");
    d5fe:	4804      	ldr	r0, [pc, #16]	; (d610 <bt_mesh_net_pending_seq_store+0x5c>)
    d600:	f018 fdf9 	bl	261f6 <settings_delete>
		if (err) {
    d604:	2800      	cmp	r0, #0
    d606:	d0f7      	beq.n	d5f8 <bt_mesh_net_pending_seq_store+0x44>
			BT_ERR("Failed to clear Seq value");
    d608:	4b04      	ldr	r3, [pc, #16]	; (d61c <bt_mesh_net_pending_seq_store+0x68>)
    d60a:	e7eb      	b.n	d5e4 <bt_mesh_net_pending_seq_store+0x30>
    d60c:	20001aa8 	.word	0x20001aa8
    d610:	00030d62 	.word	0x00030d62
    d614:	00030d6e 	.word	0x00030d6e
    d618:	0002db3c 	.word	0x0002db3c
    d61c:	00030d87 	.word	0x00030d87

0000d620 <bt_mesh_net_settings_commit>:
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_SEQ_PENDING);
}

void bt_mesh_net_settings_commit(void)
{
	if (bt_mesh.ivu_duration < BT_MESH_IVU_MIN_HOURS) {
    d620:	4805      	ldr	r0, [pc, #20]	; (d638 <bt_mesh_net_settings_commit+0x18>)
    d622:	f890 31f8 	ldrb.w	r3, [r0, #504]	; 0x1f8
    d626:	2b5f      	cmp	r3, #95	; 0x5f
    d628:	d805      	bhi.n	d636 <bt_mesh_net_settings_commit+0x16>
		k_work_reschedule(&bt_mesh.ivu_timer, BT_MESH_IVU_TIMEOUT);
    d62a:	4a04      	ldr	r2, [pc, #16]	; (d63c <bt_mesh_net_settings_commit+0x1c>)
    d62c:	2300      	movs	r3, #0
    d62e:	f500 7000 	add.w	r0, r0, #512	; 0x200
    d632:	f016 be97 	b.w	24364 <k_work_reschedule>
	}
}
    d636:	4770      	bx	lr
    d638:	20001aa8 	.word	0x20001aa8
    d63c:	a8c00000 	.word	0xa8c00000

0000d640 <subnet_evt>:
		.net_idx = BT_MESH_KEY_UNUSED,
	},
};

static void subnet_evt(struct bt_mesh_subnet *sub, enum bt_mesh_key_evt evt)
{
    d640:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	STRUCT_SECTION_FOREACH(bt_mesh_subnet_cb, cb) {
    d642:	4c06      	ldr	r4, [pc, #24]	; (d65c <subnet_evt+0x1c>)
    d644:	4f06      	ldr	r7, [pc, #24]	; (d660 <subnet_evt+0x20>)
{
    d646:	4605      	mov	r5, r0
    d648:	460e      	mov	r6, r1
	STRUCT_SECTION_FOREACH(bt_mesh_subnet_cb, cb) {
    d64a:	42bc      	cmp	r4, r7
    d64c:	d300      	bcc.n	d650 <subnet_evt+0x10>
		cb->evt_handler(sub, evt);
	}
}
    d64e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cb->evt_handler(sub, evt);
    d650:	f854 3b04 	ldr.w	r3, [r4], #4
    d654:	4631      	mov	r1, r6
    d656:	4628      	mov	r0, r5
    d658:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_subnet_cb, cb) {
    d65a:	e7f6      	b.n	d64a <subnet_evt+0xa>
    d65c:	0002d854 	.word	0x0002d854
    d660:	0002d864 	.word	0x0002d864

0000d664 <subnet_alloc>:
{
	struct bt_mesh_subnet *sub = NULL;

	for (int i = 0; i < ARRAY_SIZE(subnets); i++) {
		/* Check for already existing subnet */
		if (subnets[i].net_idx == net_idx) {
    d664:	4b0e      	ldr	r3, [pc, #56]	; (d6a0 <subnet_alloc+0x3c>)
{
    d666:	b510      	push	{r4, lr}
		if (subnets[i].net_idx == net_idx) {
    d668:	8b9c      	ldrh	r4, [r3, #28]
    d66a:	42a0      	cmp	r0, r4
{
    d66c:	4602      	mov	r2, r0
		if (subnets[i].net_idx == net_idx) {
    d66e:	d00f      	beq.n	d690 <subnet_alloc+0x2c>
			return &subnets[i];
		}

		if (!sub && subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    d670:	f64f 71ff 	movw	r1, #65535	; 0xffff
			sub = &subnets[i];
    d674:	428c      	cmp	r4, r1
    d676:	bf0c      	ite	eq
    d678:	4618      	moveq	r0, r3
    d67a:	2000      	movne	r0, #0
		if (subnets[i].net_idx == net_idx) {
    d67c:	f8b3 40fc 	ldrh.w	r4, [r3, #252]	; 0xfc
    d680:	42a2      	cmp	r2, r4
    d682:	d00a      	beq.n	d69a <subnet_alloc+0x36>
		if (!sub && subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    d684:	b918      	cbnz	r0, d68e <subnet_alloc+0x2a>
			sub = &subnets[i];
    d686:	33e0      	adds	r3, #224	; 0xe0
    d688:	428c      	cmp	r4, r1
    d68a:	bf08      	it	eq
    d68c:	4618      	moveq	r0, r3
		}
	}

	return sub;
}
    d68e:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(subnets); i++) {
    d690:	2000      	movs	r0, #0
			return &subnets[i];
    d692:	22e0      	movs	r2, #224	; 0xe0
    d694:	fb02 3000 	mla	r0, r2, r0, r3
    d698:	e7f9      	b.n	d68e <subnet_alloc+0x2a>
	for (int i = 0; i < ARRAY_SIZE(subnets); i++) {
    d69a:	2001      	movs	r0, #1
    d69c:	e7f9      	b.n	d692 <subnet_alloc+0x2e>
    d69e:	bf00      	nop
    d6a0:	20000410 	.word	0x20000410

0000d6a4 <net_keys_create>:
	return bt_mesh_k2(key, p, p_len, &cred->nid, cred->enc, cred->privacy);
}

static int net_keys_create(struct bt_mesh_subnet_keys *keys,
			   const uint8_t key[16])
{
    d6a4:	b570      	push	{r4, r5, r6, lr}
    d6a6:	b08a      	sub	sp, #40	; 0x28
	uint8_t p = 0;
    d6a8:	2300      	movs	r3, #0
    d6aa:	f88d 300b 	strb.w	r3, [sp, #11]
	return bt_mesh_k2(key, p, p_len, &cred->nid, cred->enc, cred->privacy);
    d6ae:	f100 0322 	add.w	r3, r0, #34	; 0x22
{
    d6b2:	460e      	mov	r6, r1
	return bt_mesh_k2(key, p, p_len, &cred->nid, cred->enc, cred->privacy);
    d6b4:	9301      	str	r3, [sp, #4]
    d6b6:	f100 0312 	add.w	r3, r0, #18
    d6ba:	9300      	str	r3, [sp, #0]
{
    d6bc:	4605      	mov	r5, r0
	return bt_mesh_k2(key, p, p_len, &cred->nid, cred->enc, cred->privacy);
    d6be:	f100 0311 	add.w	r3, r0, #17
    d6c2:	2201      	movs	r2, #1
    d6c4:	f10d 010b 	add.w	r1, sp, #11
    d6c8:	4630      	mov	r0, r6
    d6ca:	f002 fe49 	bl	10360 <bt_mesh_k2>
	int err;

	err = msg_cred_create(&keys->msg, &p, 1, key);
	if (err) {
    d6ce:	4604      	mov	r4, r0
    d6d0:	b168      	cbz	r0, d6ee <net_keys_create+0x4a>
		BT_ERR("Unable to generate NID, EncKey & PrivacyKey");
    d6d2:	4b19      	ldr	r3, [pc, #100]	; (d738 <net_keys_create+0x94>)
	BT_DBG("IdentityKey %s", bt_hex(keys->identity, 16));
#endif /* GATT_PROXY */

	err = bt_mesh_beacon_key(key, keys->beacon);
	if (err) {
		BT_ERR("Unable to generate beacon key");
    d6d4:	9308      	str	r3, [sp, #32]
    d6d6:	4819      	ldr	r0, [pc, #100]	; (d73c <net_keys_create+0x98>)
    d6d8:	2302      	movs	r3, #2
    d6da:	aa07      	add	r2, sp, #28
    d6dc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d6e0:	9303      	str	r3, [sp, #12]
    d6e2:	9307      	str	r3, [sp, #28]
    d6e4:	f01b fef3 	bl	294ce <z_log_msg2_static_create.constprop.0>
	BT_DBG("BeaconKey %s", bt_hex(keys->beacon, 16));

	keys->valid = 1U;

	return 0;
}
    d6e8:	4620      	mov	r0, r4
    d6ea:	b00a      	add	sp, #40	; 0x28
    d6ec:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(keys->net, key, 16);
    d6ee:	2210      	movs	r2, #16
    d6f0:	4631      	mov	r1, r6
    d6f2:	1c68      	adds	r0, r5, #1
    d6f4:	f01a f8bc 	bl	27870 <memcpy>
	err = bt_mesh_k3(key, keys->net_id);
    d6f8:	f105 0132 	add.w	r1, r5, #50	; 0x32
    d6fc:	4630      	mov	r0, r6
    d6fe:	f002 fe87 	bl	10410 <bt_mesh_k3>
	if (err) {
    d702:	4604      	mov	r4, r0
    d704:	b108      	cbz	r0, d70a <net_keys_create+0x66>
		BT_ERR("Unable to generate Net ID");
    d706:	4b0e      	ldr	r3, [pc, #56]	; (d740 <net_keys_create+0x9c>)
    d708:	e7e4      	b.n	d6d4 <net_keys_create+0x30>
}

static inline int bt_mesh_identity_key(const uint8_t net_key[16],
				       uint8_t identity_key[16])
{
	return bt_mesh_id128(net_key, "nkik", identity_key);
    d70a:	490e      	ldr	r1, [pc, #56]	; (d744 <net_keys_create+0xa0>)
    d70c:	f105 023a 	add.w	r2, r5, #58	; 0x3a
    d710:	4630      	mov	r0, r6
    d712:	f002 fed3 	bl	104bc <bt_mesh_id128>
	if (err) {
    d716:	4604      	mov	r4, r0
    d718:	b108      	cbz	r0, d71e <net_keys_create+0x7a>
		BT_ERR("Unable to generate IdentityKey");
    d71a:	4b0b      	ldr	r3, [pc, #44]	; (d748 <net_keys_create+0xa4>)
    d71c:	e7da      	b.n	d6d4 <net_keys_create+0x30>
}

static inline int bt_mesh_beacon_key(const uint8_t net_key[16],
				     uint8_t beacon_key[16])
{
	return bt_mesh_id128(net_key, "nkbk", beacon_key);
    d71e:	490b      	ldr	r1, [pc, #44]	; (d74c <net_keys_create+0xa8>)
    d720:	f105 024a 	add.w	r2, r5, #74	; 0x4a
    d724:	4630      	mov	r0, r6
    d726:	f002 fec9 	bl	104bc <bt_mesh_id128>
	if (err) {
    d72a:	4604      	mov	r4, r0
    d72c:	b108      	cbz	r0, d732 <net_keys_create+0x8e>
		BT_ERR("Unable to generate beacon key");
    d72e:	4b08      	ldr	r3, [pc, #32]	; (d750 <net_keys_create+0xac>)
    d730:	e7d0      	b.n	d6d4 <net_keys_create+0x30>
	keys->valid = 1U;
    d732:	2301      	movs	r3, #1
    d734:	702b      	strb	r3, [r5, #0]
	return 0;
    d736:	e7d7      	b.n	d6e8 <net_keys_create+0x44>
    d738:	00030dad 	.word	0x00030dad
    d73c:	0002db44 	.word	0x0002db44
    d740:	00030dd9 	.word	0x00030dd9
    d744:	00030df3 	.word	0x00030df3
    d748:	00030df8 	.word	0x00030df8
    d74c:	00030e17 	.word	0x00030e17
    d750:	00030e1c 	.word	0x00030e1c

0000d754 <clear_net_key>:
{
    d754:	b510      	push	{r4, lr}
    d756:	b08c      	sub	sp, #48	; 0x30
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", net_idx);
    d758:	4603      	mov	r3, r0
    d75a:	4a0c      	ldr	r2, [pc, #48]	; (d78c <clear_net_key+0x38>)
{
    d75c:	4604      	mov	r4, r0
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", net_idx);
    d75e:	2114      	movs	r1, #20
    d760:	a801      	add	r0, sp, #4
    d762:	f017 fd38 	bl	251d6 <snprintk>
	err = settings_delete(path);
    d766:	a801      	add	r0, sp, #4
    d768:	f018 fd45 	bl	261f6 <settings_delete>
	if (err) {
    d76c:	b158      	cbz	r0, d786 <clear_net_key+0x32>
		BT_ERR("Failed to clear NetKeyIndex 0x%03x", net_idx);
    d76e:	4b08      	ldr	r3, [pc, #32]	; (d790 <clear_net_key+0x3c>)
    d770:	4808      	ldr	r0, [pc, #32]	; (d794 <clear_net_key+0x40>)
    d772:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    d776:	aa09      	add	r2, sp, #36	; 0x24
    d778:	2303      	movs	r3, #3
    d77a:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    d77e:	9300      	str	r3, [sp, #0]
    d780:	9309      	str	r3, [sp, #36]	; 0x24
    d782:	f01b fea4 	bl	294ce <z_log_msg2_static_create.constprop.0>
}
    d786:	b00c      	add	sp, #48	; 0x30
    d788:	bd10      	pop	{r4, pc}
    d78a:	bf00      	nop
    d78c:	00030e3a 	.word	0x00030e3a
    d790:	00030e4c 	.word	0x00030e4c
    d794:	0002db44 	.word	0x0002db44

0000d798 <bt_mesh_net_flags>:
	if (sub && (sub->kr_phase == BT_MESH_KR_PHASE_2)) {
    d798:	b118      	cbz	r0, d7a2 <bt_mesh_net_flags+0xa>
    d79a:	7f80      	ldrb	r0, [r0, #30]
	uint8_t flags = 0x00;
    d79c:	1e82      	subs	r2, r0, #2
    d79e:	4250      	negs	r0, r2
    d7a0:	4150      	adcs	r0, r2
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d7a2:	4b05      	ldr	r3, [pc, #20]	; (d7b8 <bt_mesh_net_flags+0x20>)
    d7a4:	f3bf 8f5b 	dmb	ish
    d7a8:	681b      	ldr	r3, [r3, #0]
    d7aa:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_mesh.flags, BT_MESH_IVU_IN_PROGRESS)) {
    d7ae:	075b      	lsls	r3, r3, #29
		flags |= BT_MESH_NET_FLAG_IVU;
    d7b0:	bf48      	it	mi
    d7b2:	f040 0002 	orrmi.w	r0, r0, #2
}
    d7b6:	4770      	bx	lr
    d7b8:	20001ab0 	.word	0x20001ab0

0000d7bc <bt_mesh_subnets_get>:

	return STATUS_SUCCESS;
}

ssize_t bt_mesh_subnets_get(uint16_t net_idxs[], size_t max, off_t skip)
{
    d7bc:	b530      	push	{r4, r5, lr}
	size_t count = 0;

	for (int i = 0; i < ARRAY_SIZE(subnets); i++) {
		struct bt_mesh_subnet *sub = &subnets[i];

		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d7be:	4c0f      	ldr	r4, [pc, #60]	; (d7fc <bt_mesh_subnets_get+0x40>)
{
    d7c0:	4603      	mov	r3, r0
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d7c2:	8ba0      	ldrh	r0, [r4, #28]
    d7c4:	f64f 75ff 	movw	r5, #65535	; 0xffff
    d7c8:	42a8      	cmp	r0, r5
    d7ca:	d010      	beq.n	d7ee <bt_mesh_subnets_get+0x32>
			continue;
		}

		if (skip) {
    d7cc:	b972      	cbnz	r2, d7ec <bt_mesh_subnets_get+0x30>
			skip--;
			continue;
		}

		if (count >= max) {
    d7ce:	b151      	cbz	r1, d7e6 <bt_mesh_subnets_get+0x2a>
			return -ENOMEM;
		}

		net_idxs[count++] = sub->net_idx;
    d7d0:	8018      	strh	r0, [r3, #0]
    d7d2:	2001      	movs	r0, #1
		if (sub->net_idx == BT_MESH_KEY_UNUSED) {
    d7d4:	f8b4 40fc 	ldrh.w	r4, [r4, #252]	; 0xfc
    d7d8:	f64f 75ff 	movw	r5, #65535	; 0xffff
    d7dc:	42ac      	cmp	r4, r5
    d7de:	d004      	beq.n	d7ea <bt_mesh_subnets_get+0x2e>
		if (skip) {
    d7e0:	b91a      	cbnz	r2, d7ea <bt_mesh_subnets_get+0x2e>
		if (count >= max) {
    d7e2:	4281      	cmp	r1, r0
    d7e4:	d805      	bhi.n	d7f2 <bt_mesh_subnets_get+0x36>
			return -ENOMEM;
    d7e6:	f06f 000b 	mvn.w	r0, #11
	}

	return count;
}
    d7ea:	bd30      	pop	{r4, r5, pc}
			skip--;
    d7ec:	3a01      	subs	r2, #1
	size_t count = 0;
    d7ee:	2000      	movs	r0, #0
    d7f0:	e7f0      	b.n	d7d4 <bt_mesh_subnets_get+0x18>
		net_idxs[count++] = sub->net_idx;
    d7f2:	f823 4010 	strh.w	r4, [r3, r0, lsl #1]
    d7f6:	3001      	adds	r0, #1
	return count;
    d7f8:	e7f7      	b.n	d7ea <bt_mesh_subnets_get+0x2e>
    d7fa:	bf00      	nop
    d7fc:	20000410 	.word	0x20000410

0000d800 <bt_mesh_subnet_get>:

struct bt_mesh_subnet *bt_mesh_subnet_get(uint16_t net_idx)
{
    d800:	4603      	mov	r3, r0
	for (int i = 0; i < ARRAY_SIZE(subnets); i++) {
		struct bt_mesh_subnet *sub = &subnets[i];

		if (sub->net_idx == net_idx) {
    d802:	4805      	ldr	r0, [pc, #20]	; (d818 <bt_mesh_subnet_get+0x18>)
    d804:	8b82      	ldrh	r2, [r0, #28]
    d806:	429a      	cmp	r2, r3
    d808:	d005      	beq.n	d816 <bt_mesh_subnet_get+0x16>
    d80a:	f8b0 20fc 	ldrh.w	r2, [r0, #252]	; 0xfc
			return sub;
		}
	}

	return NULL;
    d80e:	30e0      	adds	r0, #224	; 0xe0
    d810:	429a      	cmp	r2, r3
    d812:	bf18      	it	ne
    d814:	2000      	movne	r0, #0
}
    d816:	4770      	bx	lr
    d818:	20000410 	.word	0x20000410

0000d81c <store_subnet>:
{
    d81c:	b510      	push	{r4, lr}
    d81e:	b096      	sub	sp, #88	; 0x58
    d820:	4601      	mov	r1, r0
	sub = bt_mesh_subnet_get(net_idx);
    d822:	f7ff ffed 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
    d826:	4604      	mov	r4, r0
    d828:	b968      	cbnz	r0, d846 <store_subnet+0x2a>
		BT_WARN("NetKeyIndex 0x%03x not found", net_idx);
    d82a:	4b1b      	ldr	r3, [pc, #108]	; (d898 <store_subnet+0x7c>)
    d82c:	e9cd 3110 	strd	r3, r1, [sp, #64]	; 0x40
    d830:	2303      	movs	r3, #3
    d832:	9306      	str	r3, [sp, #24]
    d834:	930f      	str	r3, [sp, #60]	; 0x3c
    d836:	aa0f      	add	r2, sp, #60	; 0x3c
    d838:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_ERR("Failed to store NetKey value");
    d83c:	4817      	ldr	r0, [pc, #92]	; (d89c <store_subnet+0x80>)
    d83e:	f01b fe46 	bl	294ce <z_log_msg2_static_create.constprop.0>
}
    d842:	b016      	add	sp, #88	; 0x58
    d844:	bd10      	pop	{r4, pc}
	snprintk(path, sizeof(path), "bt/mesh/NetKey/%x", net_idx);
    d846:	460b      	mov	r3, r1
    d848:	4a15      	ldr	r2, [pc, #84]	; (d8a0 <store_subnet+0x84>)
    d84a:	2114      	movs	r1, #20
    d84c:	a801      	add	r0, sp, #4
    d84e:	f017 fcc2 	bl	251d6 <snprintk>
	memcpy(&key.val[0], sub->keys[0].net, 16);
    d852:	2210      	movs	r2, #16
    d854:	f104 012d 	add.w	r1, r4, #45	; 0x2d
    d858:	f10d 0031 	add.w	r0, sp, #49	; 0x31
    d85c:	f01a f808 	bl	27870 <memcpy>
	memcpy(&key.val[1], sub->keys[1].net, 16);
    d860:	2210      	movs	r2, #16
    d862:	f104 0187 	add.w	r1, r4, #135	; 0x87
    d866:	f10d 0041 	add.w	r0, sp, #65	; 0x41
    d86a:	f01a f801 	bl	27870 <memcpy>
	key.kr_flag = 0U; /* Deprecated */
    d86e:	7fa3      	ldrb	r3, [r4, #30]
	err = settings_save_one(path, &key, sizeof(key));
    d870:	2221      	movs	r2, #33	; 0x21
	key.kr_flag = 0U; /* Deprecated */
    d872:	005b      	lsls	r3, r3, #1
	err = settings_save_one(path, &key, sizeof(key));
    d874:	a90c      	add	r1, sp, #48	; 0x30
    d876:	a801      	add	r0, sp, #4
	key.kr_flag = 0U; /* Deprecated */
    d878:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	err = settings_save_one(path, &key, sizeof(key));
    d87c:	f7f6 f9c0 	bl	3c00 <settings_save_one>
	if (err) {
    d880:	2800      	cmp	r0, #0
    d882:	d0de      	beq.n	d842 <store_subnet+0x26>
		BT_ERR("Failed to store NetKey value");
    d884:	4b07      	ldr	r3, [pc, #28]	; (d8a4 <store_subnet+0x88>)
    d886:	930a      	str	r3, [sp, #40]	; 0x28
    d888:	2302      	movs	r3, #2
    d88a:	9300      	str	r3, [sp, #0]
    d88c:	9309      	str	r3, [sp, #36]	; 0x24
    d88e:	aa09      	add	r2, sp, #36	; 0x24
    d890:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    d894:	e7d2      	b.n	d83c <store_subnet+0x20>
    d896:	bf00      	nop
    d898:	00030e6f 	.word	0x00030e6f
    d89c:	0002db44 	.word	0x0002db44
    d8a0:	00030e3a 	.word	0x00030e3a
    d8a4:	00030e8c 	.word	0x00030e8c

0000d8a8 <update_subnet_settings>:
{
    d8a8:	b470      	push	{r4, r5, r6}
		if (!update->valid) {
    d8aa:	4c20      	ldr	r4, [pc, #128]	; (d92c <update_subnet_settings+0x84>)
    d8ac:	7863      	ldrb	r3, [r4, #1]
    d8ae:	f013 0310 	ands.w	r3, r3, #16
	uint8_t clear = store ? 0U : 1U;
    d8b2:	f081 0501 	eor.w	r5, r1, #1
		if (!update->valid) {
    d8b6:	d018      	beq.n	d8ea <update_subnet_settings+0x42>
		if (update->key_idx == key_idx) {
    d8b8:	8822      	ldrh	r2, [r4, #0]
    d8ba:	f3c2 020b 	ubfx	r2, r2, #0, #12
    d8be:	4282      	cmp	r2, r0
	*free_slot = NULL;
    d8c0:	f04f 0200 	mov.w	r2, #0
		if (update->key_idx == key_idx) {
    d8c4:	d113      	bne.n	d8ee <update_subnet_settings+0x46>
		struct net_key_update *update = &net_key_updates[i];
    d8c6:	4623      	mov	r3, r4
		if (!update->valid) {
    d8c8:	78e6      	ldrb	r6, [r4, #3]
    d8ca:	06f6      	lsls	r6, r6, #27
    d8cc:	d51b      	bpl.n	d906 <update_subnet_settings+0x5e>
		if (update->key_idx == key_idx) {
    d8ce:	8864      	ldrh	r4, [r4, #2]
    d8d0:	f3c4 040b 	ubfx	r4, r4, #0, #12
    d8d4:	4284      	cmp	r4, r0
    d8d6:	d00c      	beq.n	d8f2 <update_subnet_settings+0x4a>
	if (update) {
    d8d8:	b16b      	cbz	r3, d8f6 <update_subnet_settings+0x4e>
		update->clear = clear;
    d8da:	785a      	ldrb	r2, [r3, #1]
    d8dc:	f365 1245 	bfi	r2, r5, #5, #1
    d8e0:	705a      	strb	r2, [r3, #1]
}
    d8e2:	bc70      	pop	{r4, r5, r6}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_NET_KEYS_PENDING);
    d8e4:	2001      	movs	r0, #1
    d8e6:	f007 bc25 	b.w	15134 <bt_mesh_settings_store_schedule>
			*free_slot = update;
    d8ea:	4622      	mov	r2, r4
    d8ec:	e7ec      	b.n	d8c8 <update_subnet_settings+0x20>
	match = NULL;
    d8ee:	4613      	mov	r3, r2
    d8f0:	e7ea      	b.n	d8c8 <update_subnet_settings+0x20>
		struct net_key_update *update = &net_key_updates[i];
    d8f2:	4b0f      	ldr	r3, [pc, #60]	; (d930 <update_subnet_settings+0x88>)
    d8f4:	e7f1      	b.n	d8da <update_subnet_settings+0x32>
	if (!free_slot) {
    d8f6:	b94a      	cbnz	r2, d90c <update_subnet_settings+0x64>
		if (store) {
    d8f8:	b111      	cbz	r1, d900 <update_subnet_settings+0x58>
}
    d8fa:	bc70      	pop	{r4, r5, r6}
			store_subnet(net_idx);
    d8fc:	f7ff bf8e 	b.w	d81c <store_subnet>
}
    d900:	bc70      	pop	{r4, r5, r6}
			clear_net_key(net_idx);
    d902:	f7ff bf27 	b.w	d754 <clear_net_key>
	if (update) {
    d906:	2b00      	cmp	r3, #0
    d908:	d1e7      	bne.n	d8da <update_subnet_settings+0x32>
			*free_slot = update;
    d90a:	4a09      	ldr	r2, [pc, #36]	; (d930 <update_subnet_settings+0x88>)
	free_slot->key_idx = net_idx;
    d90c:	8811      	ldrh	r1, [r2, #0]
    d90e:	f3c0 030b 	ubfx	r3, r0, #0, #12
    d912:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    d916:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    d91a:	f421 517f 	bic.w	r1, r1, #16320	; 0x3fc0
    d91e:	f3c3 030d 	ubfx	r3, r3, #0, #14
    d922:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
    d926:	430b      	orrs	r3, r1
    d928:	8013      	strh	r3, [r2, #0]
    d92a:	e7da      	b.n	d8e2 <update_subnet_settings+0x3a>
    d92c:	2000389e 	.word	0x2000389e
    d930:	200038a0 	.word	0x200038a0

0000d934 <bt_mesh_subnet_kr_phase_set>:
{
    d934:	b5f0      	push	{r4, r5, r6, r7, lr}
	const uint8_t valid_transitions[] = {
    d936:	4b1d      	ldr	r3, [pc, #116]	; (d9ac <bt_mesh_subnet_kr_phase_set+0x78>)
{
    d938:	b083      	sub	sp, #12
    d93a:	af00      	add	r7, sp, #0
	const uint8_t valid_transitions[] = {
    d93c:	881a      	ldrh	r2, [r3, #0]
    d93e:	789b      	ldrb	r3, [r3, #2]
    d940:	803a      	strh	r2, [r7, #0]
    d942:	70bb      	strb	r3, [r7, #2]
	sub = bt_mesh_subnet_get(net_idx);
    d944:	f7ff ff5c 	bl	d800 <bt_mesh_subnet_get>
{
    d948:	460d      	mov	r5, r1
	if (!sub) {
    d94a:	4604      	mov	r4, r0
    d94c:	b920      	cbnz	r0, d958 <bt_mesh_subnet_kr_phase_set+0x24>
		*phase = 0x00;
    d94e:	7008      	strb	r0, [r1, #0]
		return STATUS_INVALID_NETKEY;
    d950:	2004      	movs	r0, #4
}
    d952:	370c      	adds	r7, #12
    d954:	46bd      	mov	sp, r7
    d956:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (*phase == sub->kr_phase) {
    d958:	7809      	ldrb	r1, [r1, #0]
    d95a:	7f83      	ldrb	r3, [r0, #30]
    d95c:	4299      	cmp	r1, r3
    d95e:	d00d      	beq.n	d97c <bt_mesh_subnet_kr_phase_set+0x48>
	if (sub->kr_phase < ARRAY_SIZE(valid_transitions) &&
    d960:	2b02      	cmp	r3, #2
    d962:	d80d      	bhi.n	d980 <bt_mesh_subnet_kr_phase_set+0x4c>
	    valid_transitions[sub->kr_phase] & BIT(*phase)) {
    d964:	f107 0208 	add.w	r2, r7, #8
    d968:	441a      	add	r2, r3
    d96a:	f812 2c08 	ldrb.w	r2, [r2, #-8]
	if (sub->kr_phase < ARRAY_SIZE(valid_transitions) &&
    d96e:	40ca      	lsrs	r2, r1
    d970:	07d2      	lsls	r2, r2, #31
    d972:	d505      	bpl.n	d980 <bt_mesh_subnet_kr_phase_set+0x4c>
		key_refresh(sub, *phase);
    d974:	f01b fdd9 	bl	2952a <key_refresh>
		*phase = sub->kr_phase;
    d978:	7fa3      	ldrb	r3, [r4, #30]
    d97a:	702b      	strb	r3, [r5, #0]
		return STATUS_SUCCESS;
    d97c:	2000      	movs	r0, #0
    d97e:	e7e8      	b.n	d952 <bt_mesh_subnet_kr_phase_set+0x1e>
	BT_WARN("Invalid KR transition: 0x%02x -> 0x%02x", sub->kr_phase,
    d980:	480b      	ldr	r0, [pc, #44]	; (d9b0 <bt_mesh_subnet_kr_phase_set+0x7c>)
    d982:	466e      	mov	r6, sp
    d984:	b088      	sub	sp, #32
    d986:	466a      	mov	r2, sp
    d988:	e9c2 0304 	strd	r0, r3, [r2, #16]
    d98c:	2304      	movs	r3, #4
    d98e:	6191      	str	r1, [r2, #24]
    d990:	4808      	ldr	r0, [pc, #32]	; (d9b4 <bt_mesh_subnet_kr_phase_set+0x80>)
    d992:	f842 3f0c 	str.w	r3, [r2, #12]!
    d996:	f44f 5102 	mov.w	r1, #8320	; 0x2080
    d99a:	607b      	str	r3, [r7, #4]
    d99c:	f01b fd97 	bl	294ce <z_log_msg2_static_create.constprop.0>
	*phase = sub->kr_phase;
    d9a0:	7fa3      	ldrb	r3, [r4, #30]
    d9a2:	702b      	strb	r3, [r5, #0]
    d9a4:	46b5      	mov	sp, r6
	return STATUS_CANNOT_UPDATE;
    d9a6:	200b      	movs	r0, #11
    d9a8:	e7d3      	b.n	d952 <bt_mesh_subnet_kr_phase_set+0x1e>
    d9aa:	bf00      	nop
    d9ac:	00030ed1 	.word	0x00030ed1
    d9b0:	00030ea9 	.word	0x00030ea9
    d9b4:	0002db44 	.word	0x0002db44

0000d9b8 <net_key_set>:
	return false;
}

static int net_key_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
    d9b8:	b570      	push	{r4, r5, r6, lr}
    d9ba:	4614      	mov	r4, r2
    d9bc:	b092      	sub	sp, #72	; 0x48
    d9be:	461e      	mov	r6, r3
	struct net_key_val key;
	int err;
	uint16_t net_idx;

	if (!name) {
    d9c0:	b978      	cbnz	r0, d9e2 <net_key_set+0x2a>
		BT_ERR("Insufficient number of arguments");
    d9c2:	4b1c      	ldr	r3, [pc, #112]	; (da34 <net_key_set+0x7c>)
    d9c4:	930c      	str	r3, [sp, #48]	; 0x30
    d9c6:	481c      	ldr	r0, [pc, #112]	; (da38 <net_key_set+0x80>)
    d9c8:	2302      	movs	r3, #2
    d9ca:	aa0b      	add	r2, sp, #44	; 0x2c
    d9cc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENOENT;
    d9d0:	f06f 0401 	mvn.w	r4, #1
		BT_ERR("Insufficient number of arguments");
    d9d4:	9302      	str	r3, [sp, #8]
    d9d6:	930b      	str	r3, [sp, #44]	; 0x2c
    d9d8:	f01b fd79 	bl	294ce <z_log_msg2_static_create.constprop.0>
	BT_DBG("NetKeyIndex 0x%03x recovered from storage", net_idx);

	return bt_mesh_subnet_set(
		net_idx, key.kr_phase, key.val[0],
		(key.kr_phase != BT_MESH_KR_NORMAL) ? key.val[1] : NULL);
}
    d9dc:	4620      	mov	r0, r4
    d9de:	b012      	add	sp, #72	; 0x48
    d9e0:	bd70      	pop	{r4, r5, r6, pc}
	net_idx = strtol(name, NULL, 16);
    d9e2:	2210      	movs	r2, #16
    d9e4:	2100      	movs	r1, #0
    d9e6:	f019 fe0e 	bl	27606 <strtol>
	err = bt_mesh_settings_set(read_cb, cb_arg, &key, sizeof(key));
    d9ea:	2321      	movs	r3, #33	; 0x21
	net_idx = strtol(name, NULL, 16);
    d9ec:	b285      	uxth	r5, r0
	err = bt_mesh_settings_set(read_cb, cb_arg, &key, sizeof(key));
    d9ee:	aa08      	add	r2, sp, #32
    d9f0:	4620      	mov	r0, r4
    d9f2:	4631      	mov	r1, r6
    d9f4:	f007 fb60 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    d9f8:	4604      	mov	r4, r0
    d9fa:	b158      	cbz	r0, da14 <net_key_set+0x5c>
		BT_ERR("Failed to set \'net-key\'");
    d9fc:	4b0f      	ldr	r3, [pc, #60]	; (da3c <net_key_set+0x84>)
    d9fe:	9306      	str	r3, [sp, #24]
    da00:	480d      	ldr	r0, [pc, #52]	; (da38 <net_key_set+0x80>)
    da02:	2302      	movs	r3, #2
    da04:	aa05      	add	r2, sp, #20
    da06:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    da0a:	9301      	str	r3, [sp, #4]
    da0c:	9305      	str	r3, [sp, #20]
    da0e:	f01b fd5e 	bl	294ce <z_log_msg2_static_create.constprop.0>
		return err;
    da12:	e7e3      	b.n	d9dc <net_key_set+0x24>
		net_idx, key.kr_phase, key.val[0],
    da14:	f89d 3020 	ldrb.w	r3, [sp, #32]
	return bt_mesh_subnet_set(
    da18:	0859      	lsrs	r1, r3, #1
    da1a:	f013 03fe 	ands.w	r3, r3, #254	; 0xfe
    da1e:	bf18      	it	ne
    da20:	f10d 0331 	addne.w	r3, sp, #49	; 0x31
    da24:	f10d 0221 	add.w	r2, sp, #33	; 0x21
    da28:	4628      	mov	r0, r5
    da2a:	f01b fe61 	bl	296f0 <bt_mesh_subnet_set>
    da2e:	4604      	mov	r4, r0
    da30:	e7d4      	b.n	d9dc <net_key_set+0x24>
    da32:	bf00      	nop
    da34:	0002f4d6 	.word	0x0002f4d6
    da38:	0002db44 	.word	0x0002db44
    da3c:	00030ed5 	.word	0x00030ed5

0000da40 <bt_mesh_subnet_find>:
{
    da40:	b570      	push	{r4, r5, r6, lr}
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da42:	4c0f      	ldr	r4, [pc, #60]	; (da80 <bt_mesh_subnet_find+0x40>)
    da44:	8ba2      	ldrh	r2, [r4, #28]
    da46:	f64f 73ff 	movw	r3, #65535	; 0xffff
    da4a:	429a      	cmp	r2, r3
{
    da4c:	4605      	mov	r5, r0
    da4e:	460e      	mov	r6, r1
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da50:	d003      	beq.n	da5a <bt_mesh_subnet_find+0x1a>
		if (!cb || cb(&subnets[i], cb_data)) {
    da52:	4620      	mov	r0, r4
    da54:	b14d      	cbz	r5, da6a <bt_mesh_subnet_find+0x2a>
    da56:	47a8      	blx	r5
    da58:	b978      	cbnz	r0, da7a <bt_mesh_subnet_find+0x3a>
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da5a:	f8b4 20fc 	ldrh.w	r2, [r4, #252]	; 0xfc
    da5e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    da62:	429a      	cmp	r2, r3
    da64:	d007      	beq.n	da76 <bt_mesh_subnet_find+0x36>
		if (!cb || cb(&subnets[i], cb_data)) {
    da66:	b90d      	cbnz	r5, da6c <bt_mesh_subnet_find+0x2c>
    da68:	4806      	ldr	r0, [pc, #24]	; (da84 <bt_mesh_subnet_find+0x44>)
}
    da6a:	bd70      	pop	{r4, r5, r6, pc}
		if (!cb || cb(&subnets[i], cb_data)) {
    da6c:	4805      	ldr	r0, [pc, #20]	; (da84 <bt_mesh_subnet_find+0x44>)
    da6e:	4631      	mov	r1, r6
    da70:	47a8      	blx	r5
    da72:	2800      	cmp	r0, #0
    da74:	d1f8      	bne.n	da68 <bt_mesh_subnet_find+0x28>
	return NULL;
    da76:	2000      	movs	r0, #0
    da78:	e7f7      	b.n	da6a <bt_mesh_subnet_find+0x2a>
		if (!cb || cb(&subnets[i], cb_data)) {
    da7a:	4620      	mov	r0, r4
    da7c:	e7f5      	b.n	da6a <bt_mesh_subnet_find+0x2a>
    da7e:	bf00      	nop
    da80:	20000410 	.word	0x20000410
    da84:	200004f0 	.word	0x200004f0

0000da88 <bt_mesh_subnet_foreach>:
{
    da88:	b570      	push	{r4, r5, r6, lr}
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da8a:	4e0b      	ldr	r6, [pc, #44]	; (dab8 <bt_mesh_subnet_foreach+0x30>)
    da8c:	8bb2      	ldrh	r2, [r6, #28]
    da8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    da92:	429a      	cmp	r2, r3
{
    da94:	4605      	mov	r5, r0
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da96:	d00d      	beq.n	dab4 <bt_mesh_subnet_foreach+0x2c>
		cb(&subnets[i]);
    da98:	4630      	mov	r0, r6
    da9a:	47a8      	blx	r5
		count++;
    da9c:	2401      	movs	r4, #1
		if (subnets[i].net_idx == BT_MESH_KEY_UNUSED) {
    da9e:	f8b6 20fc 	ldrh.w	r2, [r6, #252]	; 0xfc
    daa2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    daa6:	429a      	cmp	r2, r3
    daa8:	d002      	beq.n	dab0 <bt_mesh_subnet_foreach+0x28>
		cb(&subnets[i]);
    daaa:	4804      	ldr	r0, [pc, #16]	; (dabc <bt_mesh_subnet_foreach+0x34>)
    daac:	47a8      	blx	r5
		count++;
    daae:	3401      	adds	r4, #1
}
    dab0:	4620      	mov	r0, r4
    dab2:	bd70      	pop	{r4, r5, r6, pc}
	size_t count = 0;
    dab4:	2400      	movs	r4, #0
    dab6:	e7f2      	b.n	da9e <bt_mesh_subnet_foreach+0x16>
    dab8:	20000410 	.word	0x20000410
    dabc:	200004f0 	.word	0x200004f0

0000dac0 <bt_mesh_subnet_next>:
	if (sub) {
    dac0:	b1b8      	cbz	r0, daf2 <bt_mesh_subnet_next+0x32>
		if (sub == &subnets[ARRAY_SIZE(subnets)]) {
    dac2:	4b0d      	ldr	r3, [pc, #52]	; (daf8 <bt_mesh_subnet_next+0x38>)
		sub++;
    dac4:	30e0      	adds	r0, #224	; 0xe0
		sub = &subnets[0];
    dac6:	f5a3 72e0 	sub.w	r2, r3, #448	; 0x1c0
    daca:	4298      	cmp	r0, r3
    dacc:	bf08      	it	eq
    dace:	4610      	moveq	r0, r2
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
    dad0:	8b83      	ldrh	r3, [r0, #28]
    dad2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    dad6:	4293      	cmp	r3, r2
    dad8:	d10a      	bne.n	daf0 <bt_mesh_subnet_next+0x30>
		if (sub == &subnets[ARRAY_SIZE(subnets)]) {
    dada:	4a07      	ldr	r2, [pc, #28]	; (daf8 <bt_mesh_subnet_next+0x38>)
	for (int i = 0; i < ARRAY_SIZE(subnets); i++, sub++) {
    dadc:	30e0      	adds	r0, #224	; 0xe0
			sub = &subnets[0];
    dade:	f5a2 71e0 	sub.w	r1, r2, #448	; 0x1c0
    dae2:	4290      	cmp	r0, r2
    dae4:	bf08      	it	eq
    dae6:	4608      	moveq	r0, r1
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
    dae8:	8b82      	ldrh	r2, [r0, #28]
	return NULL;
    daea:	429a      	cmp	r2, r3
    daec:	bf08      	it	eq
    daee:	2000      	moveq	r0, #0
}
    daf0:	4770      	bx	lr
		sub = &subnets[0];
    daf2:	4802      	ldr	r0, [pc, #8]	; (dafc <bt_mesh_subnet_next+0x3c>)
    daf4:	e7ec      	b.n	dad0 <bt_mesh_subnet_next+0x10>
    daf6:	bf00      	nop
    daf8:	200005d0 	.word	0x200005d0
    dafc:	20000410 	.word	0x20000410

0000db00 <bt_mesh_net_keys_reset>:
{
    db00:	b510      	push	{r4, lr}
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
    db02:	4c0a      	ldr	r4, [pc, #40]	; (db2c <bt_mesh_net_keys_reset+0x2c>)
    db04:	8ba2      	ldrh	r2, [r4, #28]
    db06:	f64f 73ff 	movw	r3, #65535	; 0xffff
    db0a:	429a      	cmp	r2, r3
    db0c:	d002      	beq.n	db14 <bt_mesh_net_keys_reset+0x14>
			subnet_del(sub);
    db0e:	4620      	mov	r0, r4
    db10:	f01b fd6c 	bl	295ec <subnet_del>
		if (sub->net_idx != BT_MESH_KEY_UNUSED) {
    db14:	f8b4 20fc 	ldrh.w	r2, [r4, #252]	; 0xfc
    db18:	f64f 73ff 	movw	r3, #65535	; 0xffff
    db1c:	429a      	cmp	r2, r3
    db1e:	d004      	beq.n	db2a <bt_mesh_net_keys_reset+0x2a>
}
    db20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			subnet_del(sub);
    db24:	4802      	ldr	r0, [pc, #8]	; (db30 <bt_mesh_net_keys_reset+0x30>)
    db26:	f01b bd61 	b.w	295ec <subnet_del>
}
    db2a:	bd10      	pop	{r4, pc}
    db2c:	20000410 	.word	0x20000410
    db30:	200004f0 	.word	0x200004f0

0000db34 <bt_mesh_net_cred_find>:
{
    db34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    db38:	4d30      	ldr	r5, [pc, #192]	; (dbfc <bt_mesh_net_cred_find+0xc8>)
    db3a:	4604      	mov	r4, r0
    db3c:	460e      	mov	r6, r1
    db3e:	4617      	mov	r7, r2
    db40:	4698      	mov	r8, r3
    db42:	f505 79e8 	add.w	r9, r5, #464	; 0x1d0
		if (!frnd->subnet) {
    db46:	6bab      	ldr	r3, [r5, #56]	; 0x38
    db48:	b333      	cbz	r3, db98 <bt_mesh_net_cred_find+0x64>
		rx->sub = frnd->subnet;
    db4a:	6023      	str	r3, [r4, #0]
			if (!rx->sub->keys[j].valid) {
    db4c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    db50:	b133      	cbz	r3, db60 <bt_mesh_net_cred_find+0x2c>
			if (cb(rx, in, out, &frnd->cred[j])) {
    db52:	f105 033c 	add.w	r3, r5, #60	; 0x3c
    db56:	463a      	mov	r2, r7
    db58:	4631      	mov	r1, r6
    db5a:	4620      	mov	r0, r4
    db5c:	47c0      	blx	r8
    db5e:	b9c8      	cbnz	r0, db94 <bt_mesh_net_cred_find+0x60>
			if (!rx->sub->keys[j].valid) {
    db60:	6823      	ldr	r3, [r4, #0]
    db62:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
    db66:	b1bb      	cbz	r3, db98 <bt_mesh_net_cred_find+0x64>
			if (cb(rx, in, out, &frnd->cred[j])) {
    db68:	f105 035d 	add.w	r3, r5, #93	; 0x5d
    db6c:	463a      	mov	r2, r7
    db6e:	4631      	mov	r1, r6
    db70:	4620      	mov	r0, r4
    db72:	47c0      	blx	r8
    db74:	b180      	cbz	r0, db98 <bt_mesh_net_cred_find+0x64>
		for (j = 0; j < ARRAY_SIZE(frnd->cred); j++) {
    db76:	2301      	movs	r3, #1
				rx->new_key = (j > 0);
    db78:	7d22      	ldrb	r2, [r4, #20]
    db7a:	005b      	lsls	r3, r3, #1
    db7c:	f043 0304 	orr.w	r3, r3, #4
    db80:	f022 0206 	bic.w	r2, r2, #6
    db84:	4313      	orrs	r3, r2
				rx->new_key = (j > 0);
    db86:	7523      	strb	r3, [r4, #20]
				rx->ctx.net_idx = rx->sub->net_idx;
    db88:	6823      	ldr	r3, [r4, #0]
    db8a:	8b9b      	ldrh	r3, [r3, #28]
    db8c:	80a3      	strh	r3, [r4, #4]
				return true;
    db8e:	2001      	movs	r0, #1
}
    db90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for (j = 0; j < ARRAY_SIZE(frnd->cred); j++) {
    db94:	2300      	movs	r3, #0
    db96:	e7ef      	b.n	db78 <bt_mesh_net_cred_find+0x44>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
    db98:	35e8      	adds	r5, #232	; 0xe8
    db9a:	45a9      	cmp	r9, r5
    db9c:	d1d3      	bne.n	db46 <bt_mesh_net_cred_find+0x12>
    db9e:	4d18      	ldr	r5, [pc, #96]	; (dc00 <bt_mesh_net_cred_find+0xcc>)
	for (i = 0; i < ARRAY_SIZE(subnets); i++) {
    dba0:	f04f 0900 	mov.w	r9, #0
		if (rx->sub->net_idx == BT_MESH_KEY_UNUSED) {
    dba4:	f64f 7aff 	movw	sl, #65535	; 0xffff
    dba8:	8bab      	ldrh	r3, [r5, #28]
		rx->sub = &subnets[i];
    dbaa:	6025      	str	r5, [r4, #0]
		if (rx->sub->net_idx == BT_MESH_KEY_UNUSED) {
    dbac:	4553      	cmp	r3, sl
    dbae:	d01f      	beq.n	dbf0 <bt_mesh_net_cred_find+0xbc>
			if (!rx->sub->keys[j].valid) {
    dbb0:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    dbb4:	b133      	cbz	r3, dbc4 <bt_mesh_net_cred_find+0x90>
			if (cb(rx, in, out, &rx->sub->keys[j].msg)) {
    dbb6:	f105 033d 	add.w	r3, r5, #61	; 0x3d
    dbba:	463a      	mov	r2, r7
    dbbc:	4631      	mov	r1, r6
    dbbe:	4620      	mov	r0, r4
    dbc0:	47c0      	blx	r8
    dbc2:	b998      	cbnz	r0, dbec <bt_mesh_net_cred_find+0xb8>
			if (!rx->sub->keys[j].valid) {
    dbc4:	6823      	ldr	r3, [r4, #0]
    dbc6:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
    dbca:	b18a      	cbz	r2, dbf0 <bt_mesh_net_cred_find+0xbc>
			if (cb(rx, in, out, &rx->sub->keys[j].msg)) {
    dbcc:	3397      	adds	r3, #151	; 0x97
    dbce:	463a      	mov	r2, r7
    dbd0:	4631      	mov	r1, r6
    dbd2:	4620      	mov	r0, r4
    dbd4:	47c0      	blx	r8
    dbd6:	b158      	cbz	r0, dbf0 <bt_mesh_net_cred_find+0xbc>
		for (j = 0; j < ARRAY_SIZE(rx->sub->keys); j++) {
    dbd8:	2201      	movs	r2, #1
				rx->new_key = (j > 0);
    dbda:	7d23      	ldrb	r3, [r4, #20]
    dbdc:	f023 0306 	bic.w	r3, r3, #6
    dbe0:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
    dbe4:	e7cf      	b.n	db86 <bt_mesh_net_cred_find+0x52>
    dbe6:	f04f 0901 	mov.w	r9, #1
    dbea:	e7dd      	b.n	dba8 <bt_mesh_net_cred_find+0x74>
		for (j = 0; j < ARRAY_SIZE(rx->sub->keys); j++) {
    dbec:	2200      	movs	r2, #0
    dbee:	e7f4      	b.n	dbda <bt_mesh_net_cred_find+0xa6>
	for (i = 0; i < ARRAY_SIZE(subnets); i++) {
    dbf0:	35e0      	adds	r5, #224	; 0xe0
    dbf2:	f1b9 0f00 	cmp.w	r9, #0
    dbf6:	d0f6      	beq.n	dbe6 <bt_mesh_net_cred_find+0xb2>
	return false;
    dbf8:	2000      	movs	r0, #0
    dbfa:	e7c9      	b.n	db90 <bt_mesh_net_cred_find+0x5c>
    dbfc:	20001aa8 	.word	0x20001aa8
    dc00:	20000410 	.word	0x20000410

0000dc04 <bt_mesh_subnet_pending_store>:

BT_MESH_SETTINGS_DEFINE(subnet, "NetKey", net_key_set);

void bt_mesh_subnet_pending_store(void)
{
    dc04:	b510      	push	{r4, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(net_key_updates); i++) {
		struct net_key_update *update = &net_key_updates[i];

		if (!update->valid) {
    dc06:	4c12      	ldr	r4, [pc, #72]	; (dc50 <bt_mesh_subnet_pending_store+0x4c>)
    dc08:	7863      	ldrb	r3, [r4, #1]
    dc0a:	06d8      	lsls	r0, r3, #27
    dc0c:	d50a      	bpl.n	dc24 <bt_mesh_subnet_pending_store+0x20>
			continue;
		}

		if (update->clear) {
			clear_net_key(update->key_idx);
    dc0e:	8820      	ldrh	r0, [r4, #0]
		if (update->clear) {
    dc10:	0699      	lsls	r1, r3, #26
			clear_net_key(update->key_idx);
    dc12:	f3c0 000b 	ubfx	r0, r0, #0, #12
		if (update->clear) {
    dc16:	d414      	bmi.n	dc42 <bt_mesh_subnet_pending_store+0x3e>
		} else {
			store_subnet(update->key_idx);
    dc18:	f7ff fe00 	bl	d81c <store_subnet>
		}

		update->valid = 0U;
    dc1c:	7863      	ldrb	r3, [r4, #1]
    dc1e:	f36f 1304 	bfc	r3, #4, #1
    dc22:	7063      	strb	r3, [r4, #1]
		if (!update->valid) {
    dc24:	78e3      	ldrb	r3, [r4, #3]
    dc26:	06da      	lsls	r2, r3, #27
    dc28:	d50a      	bpl.n	dc40 <bt_mesh_subnet_pending_store+0x3c>
			clear_net_key(update->key_idx);
    dc2a:	8860      	ldrh	r0, [r4, #2]
		if (update->clear) {
    dc2c:	069b      	lsls	r3, r3, #26
			clear_net_key(update->key_idx);
    dc2e:	f3c0 000b 	ubfx	r0, r0, #0, #12
		if (update->clear) {
    dc32:	d509      	bpl.n	dc48 <bt_mesh_subnet_pending_store+0x44>
			clear_net_key(update->key_idx);
    dc34:	f7ff fd8e 	bl	d754 <clear_net_key>
		update->valid = 0U;
    dc38:	78e3      	ldrb	r3, [r4, #3]
    dc3a:	f36f 1304 	bfc	r3, #4, #1
    dc3e:	70e3      	strb	r3, [r4, #3]
	}
}
    dc40:	bd10      	pop	{r4, pc}
			clear_net_key(update->key_idx);
    dc42:	f7ff fd87 	bl	d754 <clear_net_key>
    dc46:	e7e9      	b.n	dc1c <bt_mesh_subnet_pending_store+0x18>
			store_subnet(update->key_idx);
    dc48:	f7ff fde8 	bl	d81c <store_subnet>
    dc4c:	e7f4      	b.n	dc38 <bt_mesh_subnet_pending_store+0x34>
    dc4e:	bf00      	nop
    dc50:	2000389e 	.word	0x2000389e

0000dc54 <app_get>:
};

static struct app_key *app_get(uint16_t app_idx)
{
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
		if (apps[i].app_idx == app_idx) {
    dc54:	4b07      	ldr	r3, [pc, #28]	; (dc74 <app_get+0x20>)
    dc56:	885a      	ldrh	r2, [r3, #2]
    dc58:	4282      	cmp	r2, r0
    dc5a:	d007      	beq.n	dc6c <app_get+0x18>
    dc5c:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
    dc5e:	4282      	cmp	r2, r0
    dc60:	d106      	bne.n	dc70 <app_get+0x1c>
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    dc62:	2001      	movs	r0, #1
			return &apps[i];
    dc64:	2228      	movs	r2, #40	; 0x28
    dc66:	fb02 3000 	mla	r0, r2, r0, r3
    dc6a:	4770      	bx	lr
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    dc6c:	2000      	movs	r0, #0
    dc6e:	e7f9      	b.n	dc64 <app_get+0x10>
		}
	}

	return NULL;
    dc70:	2000      	movs	r0, #0
}
    dc72:	4770      	bx	lr
    dc74:	20000d48 	.word	0x20000d48

0000dc78 <app_key_evt>:

	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_APP_KEYS_PENDING);
}

static void app_key_evt(struct app_key *app, enum bt_mesh_key_evt evt)
{
    dc78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	STRUCT_SECTION_FOREACH(bt_mesh_app_key_cb, cb) {
    dc7a:	4d07      	ldr	r5, [pc, #28]	; (dc98 <app_key_evt+0x20>)
    dc7c:	4f07      	ldr	r7, [pc, #28]	; (dc9c <app_key_evt+0x24>)
{
    dc7e:	4604      	mov	r4, r0
    dc80:	460e      	mov	r6, r1
	STRUCT_SECTION_FOREACH(bt_mesh_app_key_cb, cb) {
    dc82:	42bd      	cmp	r5, r7
    dc84:	d300      	bcc.n	dc88 <app_key_evt+0x10>
		cb->evt_handler(app->app_idx, app->net_idx, evt);
	}
}
    dc86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		cb->evt_handler(app->app_idx, app->net_idx, evt);
    dc88:	f855 3b04 	ldr.w	r3, [r5], #4
    dc8c:	8821      	ldrh	r1, [r4, #0]
    dc8e:	8860      	ldrh	r0, [r4, #2]
    dc90:	4632      	mov	r2, r6
    dc92:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_app_key_cb, cb) {
    dc94:	e7f5      	b.n	dc82 <app_key_evt+0xa>
    dc96:	bf00      	nop
    dc98:	0002d864 	.word	0x0002d864
    dc9c:	0002d868 	.word	0x0002d868

0000dca0 <app_key_alloc>:
{
	struct app_key *app = NULL;

	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
		/* Check for already existing app_key */
		if (apps[i].app_idx == app_idx) {
    dca0:	4b0d      	ldr	r3, [pc, #52]	; (dcd8 <app_key_alloc+0x38>)
{
    dca2:	b510      	push	{r4, lr}
		if (apps[i].app_idx == app_idx) {
    dca4:	885c      	ldrh	r4, [r3, #2]
    dca6:	42a0      	cmp	r0, r4
{
    dca8:	4602      	mov	r2, r0
		if (apps[i].app_idx == app_idx) {
    dcaa:	d00e      	beq.n	dcca <app_key_alloc+0x2a>
			return &apps[i];
		}

		if (!app && apps[i].app_idx == BT_MESH_KEY_UNUSED) {
    dcac:	f64f 71ff 	movw	r1, #65535	; 0xffff
			app = &apps[i];
    dcb0:	428c      	cmp	r4, r1
    dcb2:	bf0c      	ite	eq
    dcb4:	4618      	moveq	r0, r3
    dcb6:	2000      	movne	r0, #0
		if (apps[i].app_idx == app_idx) {
    dcb8:	8d5c      	ldrh	r4, [r3, #42]	; 0x2a
    dcba:	42a2      	cmp	r2, r4
    dcbc:	d00a      	beq.n	dcd4 <app_key_alloc+0x34>
		if (!app && apps[i].app_idx == BT_MESH_KEY_UNUSED) {
    dcbe:	b918      	cbnz	r0, dcc8 <app_key_alloc+0x28>
			app = &apps[i];
    dcc0:	3328      	adds	r3, #40	; 0x28
    dcc2:	428c      	cmp	r4, r1
    dcc4:	bf08      	it	eq
    dcc6:	4618      	moveq	r0, r3
		}
	}

	return app;
}
    dcc8:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    dcca:	2000      	movs	r0, #0
			return &apps[i];
    dccc:	2228      	movs	r2, #40	; 0x28
    dcce:	fb02 3000 	mla	r0, r2, r0, r3
    dcd2:	e7f9      	b.n	dcc8 <app_key_alloc+0x28>
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    dcd4:	2001      	movs	r0, #1
    dcd6:	e7f9      	b.n	dccc <app_key_alloc+0x2c>
    dcd8:	20000d48 	.word	0x20000d48

0000dcdc <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    dcdc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    dcde:	ab0a      	add	r3, sp, #40	; 0x28
    dce0:	9305      	str	r3, [sp, #20]
    dce2:	9302      	str	r3, [sp, #8]
    dce4:	4b05      	ldr	r3, [pc, #20]	; (dcfc <z_log_msg2_runtime_create.constprop.0+0x20>)
    dce6:	9301      	str	r3, [sp, #4]
    dce8:	2300      	movs	r3, #0
    dcea:	9300      	str	r3, [sp, #0]
    dcec:	2201      	movs	r2, #1
    dcee:	4618      	mov	r0, r3
    dcf0:	f7f5 fada 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    dcf4:	b007      	add	sp, #28
    dcf6:	f85d fb04 	ldr.w	pc, [sp], #4
    dcfa:	bf00      	nop
    dcfc:	00030f0d 	.word	0x00030f0d

0000dd00 <store_app_key>:
{
    dd00:	b570      	push	{r4, r5, r6, lr}
    dd02:	b094      	sub	sp, #80	; 0x50
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
    dd04:	ae05      	add	r6, sp, #20
    dd06:	4603      	mov	r3, r0
    dd08:	4a1f      	ldr	r2, [pc, #124]	; (dd88 <store_app_key+0x88>)
{
    dd0a:	4605      	mov	r5, r0
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
    dd0c:	2114      	movs	r1, #20
    dd0e:	4630      	mov	r0, r6
    dd10:	f017 fa61 	bl	251d6 <snprintk>
	app = app_get(app_idx);
    dd14:	4628      	mov	r0, r5
    dd16:	f7ff ff9d 	bl	dc54 <app_get>
	if (!app) {
    dd1a:	4604      	mov	r4, r0
    dd1c:	b970      	cbnz	r0, dd3c <store_app_key+0x3c>
		BT_WARN("ApKeyIndex 0x%03x not found", app_idx);
    dd1e:	4b1b      	ldr	r3, [pc, #108]	; (dd8c <store_app_key+0x8c>)
    dd20:	e9cd 350e 	strd	r3, r5, [sp, #56]	; 0x38
    dd24:	2303      	movs	r3, #3
    dd26:	9304      	str	r3, [sp, #16]
    dd28:	930d      	str	r3, [sp, #52]	; 0x34
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    dd2a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    dd2e:	4603      	mov	r3, r0
    dd30:	aa0d      	add	r2, sp, #52	; 0x34
    dd32:	4817      	ldr	r0, [pc, #92]	; (dd90 <store_app_key+0x90>)
    dd34:	f017 ffd0 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
    dd38:	b014      	add	sp, #80	; 0x50
    dd3a:	bd70      	pop	{r4, r5, r6, pc}
	key.net_idx = app->net_idx,
    dd3c:	8803      	ldrh	r3, [r0, #0]
    dd3e:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	memcpy(key.val[0], app->keys[0].val, 16);
    dd42:	1d81      	adds	r1, r0, #6
	key.updated = app->updated,
    dd44:	7903      	ldrb	r3, [r0, #4]
    dd46:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
	memcpy(key.val[0], app->keys[0].val, 16);
    dd4a:	2210      	movs	r2, #16
    dd4c:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
    dd50:	f019 fd8e 	bl	27870 <memcpy>
	memcpy(key.val[1], app->keys[1].val, 16);
    dd54:	2210      	movs	r2, #16
    dd56:	f104 0117 	add.w	r1, r4, #23
    dd5a:	f10d 003b 	add.w	r0, sp, #59	; 0x3b
    dd5e:	f019 fd87 	bl	27870 <memcpy>
	err = settings_save_one(path, &key, sizeof(key));
    dd62:	2223      	movs	r2, #35	; 0x23
    dd64:	a90a      	add	r1, sp, #40	; 0x28
    dd66:	4630      	mov	r0, r6
    dd68:	f7f5 ff4a 	bl	3c00 <settings_save_one>
	if (err) {
    dd6c:	2800      	cmp	r0, #0
    dd6e:	d0e3      	beq.n	dd38 <store_app_key+0x38>
		BT_ERR("Failed to store AppKey %s value", log_strdup(path));
    dd70:	4b08      	ldr	r3, [pc, #32]	; (dd94 <store_app_key+0x94>)
    dd72:	9301      	str	r3, [sp, #4]
    dd74:	2300      	movs	r3, #0
    dd76:	4906      	ldr	r1, [pc, #24]	; (dd90 <store_app_key+0x90>)
    dd78:	9602      	str	r6, [sp, #8]
    dd7a:	9300      	str	r3, [sp, #0]
    dd7c:	2201      	movs	r2, #1
    dd7e:	4618      	mov	r0, r3
    dd80:	f7ff ffac 	bl	dcdc <z_log_msg2_runtime_create.constprop.0>
		BT_DBG("Stored AppKey %s value", log_strdup(path));
    dd84:	e7d8      	b.n	dd38 <store_app_key+0x38>
    dd86:	bf00      	nop
    dd88:	00030f2d 	.word	0x00030f2d
    dd8c:	00030f3f 	.word	0x00030f3f
    dd90:	0002dae4 	.word	0x0002dae4
    dd94:	00030f0d 	.word	0x00030f0d

0000dd98 <clear_app_key>:
{
    dd98:	b510      	push	{r4, lr}
    dd9a:	b08c      	sub	sp, #48	; 0x30
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
    dd9c:	4603      	mov	r3, r0
    dd9e:	4a0c      	ldr	r2, [pc, #48]	; (ddd0 <clear_app_key+0x38>)
{
    dda0:	4604      	mov	r4, r0
	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app_idx);
    dda2:	2114      	movs	r1, #20
    dda4:	a801      	add	r0, sp, #4
    dda6:	f017 fa16 	bl	251d6 <snprintk>
	err = settings_delete(path);
    ddaa:	a801      	add	r0, sp, #4
    ddac:	f018 fa23 	bl	261f6 <settings_delete>
	if (err) {
    ddb0:	b160      	cbz	r0, ddcc <clear_app_key+0x34>
		BT_ERR("Failed to clear AppKeyIndex 0x%03x", app_idx);
    ddb2:	4b08      	ldr	r3, [pc, #32]	; (ddd4 <clear_app_key+0x3c>)
    ddb4:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    ddb8:	2303      	movs	r3, #3
    ddba:	9300      	str	r3, [sp, #0]
    ddbc:	9309      	str	r3, [sp, #36]	; 0x24
    ddbe:	4806      	ldr	r0, [pc, #24]	; (ddd8 <clear_app_key+0x40>)
    ddc0:	2300      	movs	r3, #0
    ddc2:	aa09      	add	r2, sp, #36	; 0x24
    ddc4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    ddc8:	f017 ff86 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
    ddcc:	b00c      	add	sp, #48	; 0x30
    ddce:	bd10      	pop	{r4, pc}
    ddd0:	00030f2d 	.word	0x00030f2d
    ddd4:	00030f5b 	.word	0x00030f5b
    ddd8:	0002dae4 	.word	0x0002dae4

0000dddc <update_app_key_settings>:
{
    dddc:	b470      	push	{r4, r5, r6}
		if (!update->valid) {
    ddde:	4c20      	ldr	r4, [pc, #128]	; (de60 <update_app_key_settings+0x84>)
    dde0:	7863      	ldrb	r3, [r4, #1]
    dde2:	f013 0310 	ands.w	r3, r3, #16
	uint8_t clear = store ? 0U : 1U;
    dde6:	f081 0501 	eor.w	r5, r1, #1
		if (!update->valid) {
    ddea:	d018      	beq.n	de1e <update_app_key_settings+0x42>
		if (update->key_idx == key_idx) {
    ddec:	8822      	ldrh	r2, [r4, #0]
    ddee:	f3c2 020b 	ubfx	r2, r2, #0, #12
    ddf2:	4282      	cmp	r2, r0
	*free_slot = NULL;
    ddf4:	f04f 0200 	mov.w	r2, #0
		if (update->key_idx == key_idx) {
    ddf8:	d113      	bne.n	de22 <update_app_key_settings+0x46>
		struct app_key_update *update = &app_key_updates[i];
    ddfa:	4623      	mov	r3, r4
		if (!update->valid) {
    ddfc:	78e6      	ldrb	r6, [r4, #3]
    ddfe:	06f6      	lsls	r6, r6, #27
    de00:	d51b      	bpl.n	de3a <update_app_key_settings+0x5e>
		if (update->key_idx == key_idx) {
    de02:	8864      	ldrh	r4, [r4, #2]
    de04:	f3c4 040b 	ubfx	r4, r4, #0, #12
    de08:	4284      	cmp	r4, r0
    de0a:	d00c      	beq.n	de26 <update_app_key_settings+0x4a>
	if (update) {
    de0c:	b16b      	cbz	r3, de2a <update_app_key_settings+0x4e>
		update->clear = clear;
    de0e:	785a      	ldrb	r2, [r3, #1]
    de10:	f365 1245 	bfi	r2, r5, #5, #1
    de14:	705a      	strb	r2, [r3, #1]
}
    de16:	bc70      	pop	{r4, r5, r6}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_APP_KEYS_PENDING);
    de18:	2002      	movs	r0, #2
    de1a:	f007 b98b 	b.w	15134 <bt_mesh_settings_store_schedule>
			*free_slot = update;
    de1e:	4622      	mov	r2, r4
    de20:	e7ec      	b.n	ddfc <update_app_key_settings+0x20>
	match = NULL;
    de22:	4613      	mov	r3, r2
    de24:	e7ea      	b.n	ddfc <update_app_key_settings+0x20>
		struct app_key_update *update = &app_key_updates[i];
    de26:	4b0f      	ldr	r3, [pc, #60]	; (de64 <update_app_key_settings+0x88>)
    de28:	e7f1      	b.n	de0e <update_app_key_settings+0x32>
	if (!free_slot) {
    de2a:	b94a      	cbnz	r2, de40 <update_app_key_settings+0x64>
		if (store) {
    de2c:	b111      	cbz	r1, de34 <update_app_key_settings+0x58>
}
    de2e:	bc70      	pop	{r4, r5, r6}
			store_app_key(app_idx);
    de30:	f7ff bf66 	b.w	dd00 <store_app_key>
}
    de34:	bc70      	pop	{r4, r5, r6}
			clear_app_key(app_idx);
    de36:	f7ff bfaf 	b.w	dd98 <clear_app_key>
	if (update) {
    de3a:	2b00      	cmp	r3, #0
    de3c:	d1e7      	bne.n	de0e <update_app_key_settings+0x32>
			*free_slot = update;
    de3e:	4a09      	ldr	r2, [pc, #36]	; (de64 <update_app_key_settings+0x88>)
	free_slot->key_idx = app_idx;
    de40:	8811      	ldrh	r1, [r2, #0]
    de42:	f3c0 030b 	ubfx	r3, r0, #0, #12
    de46:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    de4a:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    de4e:	f421 517f 	bic.w	r1, r1, #16320	; 0x3fc0
    de52:	f3c3 030d 	ubfx	r3, r3, #0, #14
    de56:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
    de5a:	430b      	orrs	r3, r1
    de5c:	8013      	strh	r3, [r2, #0]
    de5e:	e7da      	b.n	de16 <update_app_key_settings+0x3a>
    de60:	200038a2 	.word	0x200038a2
    de64:	200038a4 	.word	0x200038a4

0000de68 <subnet_evt>:
	return BT_MESH_KEY_UNUSED;
}

static void subnet_evt(struct bt_mesh_subnet *sub, enum bt_mesh_key_evt evt)
{
	if (evt == BT_MESH_KEY_UPDATED || evt == BT_MESH_KEY_ADDED) {
    de68:	f011 0ffd 	tst.w	r1, #253	; 0xfd
{
    de6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    de70:	4607      	mov	r7, r0
    de72:	460d      	mov	r5, r1
	if (evt == BT_MESH_KEY_UPDATED || evt == BT_MESH_KEY_ADDED) {
    de74:	d015      	beq.n	dea2 <subnet_evt+0x3a>
    de76:	4c1e      	ldr	r4, [pc, #120]	; (def0 <subnet_evt+0x88>)
    de78:	f04f 0802 	mov.w	r8, #2
	}

	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
		struct app_key *app = &apps[i];

		if (app->app_idx == BT_MESH_KEY_UNUSED) {
    de7c:	f64f 79ff 	movw	r9, #65535	; 0xffff
    de80:	8863      	ldrh	r3, [r4, #2]
    de82:	454b      	cmp	r3, r9
    de84:	d008      	beq.n	de98 <subnet_evt+0x30>
			continue;
		}

		if (app->net_idx != sub->net_idx) {
    de86:	8822      	ldrh	r2, [r4, #0]
    de88:	8bbb      	ldrh	r3, [r7, #28]
    de8a:	429a      	cmp	r2, r3
    de8c:	d104      	bne.n	de98 <subnet_evt+0x30>
			continue;
		}

		if (evt == BT_MESH_KEY_DELETED) {
    de8e:	2d01      	cmp	r5, #1
    de90:	d10c      	bne.n	deac <subnet_evt+0x44>
			app_key_del(app);
    de92:	4620      	mov	r0, r4
    de94:	f01b fc5d 	bl	29752 <app_key_del>
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    de98:	f1b8 0f01 	cmp.w	r8, #1
    de9c:	f104 0428 	add.w	r4, r4, #40	; 0x28
    dea0:	d101      	bne.n	dea6 <subnet_evt+0x3e>
			app_key_revoke(app);
		} else if (evt == BT_MESH_KEY_SWAPPED && app->updated) {
			app_key_evt(app, BT_MESH_KEY_SWAPPED);
		}
	}
}
    dea2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    dea6:	f04f 0801 	mov.w	r8, #1
    deaa:	e7e9      	b.n	de80 <subnet_evt+0x18>
		} else if (evt == BT_MESH_KEY_REVOKED) {
    deac:	2d04      	cmp	r5, #4
    deae:	d119      	bne.n	dee4 <subnet_evt+0x7c>
	if (!app->updated) {
    deb0:	7923      	ldrb	r3, [r4, #4]
    deb2:	2b00      	cmp	r3, #0
    deb4:	d0f0      	beq.n	de98 <subnet_evt+0x30>
	memcpy(&app->keys[0], &app->keys[1], sizeof(app->keys[0]));
    deb6:	f104 0616 	add.w	r6, r4, #22
    deba:	2211      	movs	r2, #17
    debc:	4631      	mov	r1, r6
    debe:	1d60      	adds	r0, r4, #5
    dec0:	f019 fcd6 	bl	27870 <memcpy>
	memset(&app->keys[1], 0, sizeof(app->keys[1]));
    dec4:	2100      	movs	r1, #0
    dec6:	2211      	movs	r2, #17
    dec8:	4630      	mov	r0, r6
    deca:	f019 fcdc 	bl	27886 <memset>
	app->updated = false;
    dece:	2300      	movs	r3, #0
		update_app_key_settings(app->app_idx, true);
    ded0:	8860      	ldrh	r0, [r4, #2]
	app->updated = false;
    ded2:	7123      	strb	r3, [r4, #4]
		update_app_key_settings(app->app_idx, true);
    ded4:	2101      	movs	r1, #1
    ded6:	f7ff ff81 	bl	dddc <update_app_key_settings>
			app_key_evt(app, BT_MESH_KEY_SWAPPED);
    deda:	4629      	mov	r1, r5
    dedc:	4620      	mov	r0, r4
    dede:	f7ff fecb 	bl	dc78 <app_key_evt>
    dee2:	e7d9      	b.n	de98 <subnet_evt+0x30>
		} else if (evt == BT_MESH_KEY_SWAPPED && app->updated) {
    dee4:	2d03      	cmp	r5, #3
    dee6:	d1d7      	bne.n	de98 <subnet_evt+0x30>
    dee8:	7923      	ldrb	r3, [r4, #4]
    deea:	2b00      	cmp	r3, #0
    deec:	d0d4      	beq.n	de98 <subnet_evt+0x30>
    deee:	e7f4      	b.n	deda <subnet_evt+0x72>
    def0:	20000d48 	.word	0x20000d48

0000def4 <app_key_set>:
	}
}

static int app_key_set(const char *name, size_t len_rd,
		       settings_read_cb read_cb, void *cb_arg)
{
    def4:	b5f0      	push	{r4, r5, r6, r7, lr}
    def6:	461f      	mov	r7, r3
    def8:	b093      	sub	sp, #76	; 0x4c
    defa:	460c      	mov	r4, r1
    defc:	4616      	mov	r6, r2
	struct app_key_val key;
	uint16_t app_idx;
	int err;

	if (!name) {
    defe:	4603      	mov	r3, r0
    df00:	b978      	cbnz	r0, df22 <app_key_set+0x2e>
		BT_ERR("Insufficient number of arguments");
    df02:	4a1f      	ldr	r2, [pc, #124]	; (df80 <app_key_set+0x8c>)
    df04:	920c      	str	r2, [sp, #48]	; 0x30
    df06:	2202      	movs	r2, #2
    df08:	9202      	str	r2, [sp, #8]
    df0a:	920b      	str	r2, [sp, #44]	; 0x2c
    df0c:	481d      	ldr	r0, [pc, #116]	; (df84 <app_key_set+0x90>)
    df0e:	aa0b      	add	r2, sp, #44	; 0x2c
    df10:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENOENT;
    df14:	f06f 0401 	mvn.w	r4, #1
    df18:	f017 fede 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	}

	BT_DBG("AppKeyIndex 0x%03x recovered from storage", app_idx);

	return 0;
}
    df1c:	4620      	mov	r0, r4
    df1e:	b013      	add	sp, #76	; 0x4c
    df20:	bdf0      	pop	{r4, r5, r6, r7, pc}
	app_idx = strtol(name, NULL, 16);
    df22:	2210      	movs	r2, #16
    df24:	2100      	movs	r1, #0
    df26:	f019 fb6e 	bl	27606 <strtol>
    df2a:	4605      	mov	r5, r0
	if (!len_rd) {
    df2c:	2c00      	cmp	r4, #0
    df2e:	d0f5      	beq.n	df1c <app_key_set+0x28>
	err = bt_mesh_settings_set(read_cb, cb_arg, &key, sizeof(key));
    df30:	2323      	movs	r3, #35	; 0x23
    df32:	aa08      	add	r2, sp, #32
    df34:	4639      	mov	r1, r7
    df36:	4630      	mov	r0, r6
    df38:	f007 f8be 	bl	150b8 <bt_mesh_settings_set>
	if (err < 0) {
    df3c:	2800      	cmp	r0, #0
    df3e:	db1b      	blt.n	df78 <app_key_set+0x84>
	err = bt_mesh_app_key_set(app_idx, key.net_idx, key.val[0],
    df40:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    df44:	f8bd 1020 	ldrh.w	r1, [sp, #32]
    df48:	b10b      	cbz	r3, df4e <app_key_set+0x5a>
    df4a:	f10d 0333 	add.w	r3, sp, #51	; 0x33
    df4e:	f10d 0223 	add.w	r2, sp, #35	; 0x23
    df52:	b2a8      	uxth	r0, r5
    df54:	f01b fcb1 	bl	298ba <bt_mesh_app_key_set>
	if (err) {
    df58:	4604      	mov	r4, r0
    df5a:	2800      	cmp	r0, #0
    df5c:	d0de      	beq.n	df1c <app_key_set+0x28>
		BT_ERR("Failed to set \'app-key\'");
    df5e:	4b0a      	ldr	r3, [pc, #40]	; (df88 <app_key_set+0x94>)
    df60:	9306      	str	r3, [sp, #24]
    df62:	2302      	movs	r3, #2
    df64:	9301      	str	r3, [sp, #4]
    df66:	9305      	str	r3, [sp, #20]
    df68:	4806      	ldr	r0, [pc, #24]	; (df84 <app_key_set+0x90>)
    df6a:	2300      	movs	r3, #0
    df6c:	aa05      	add	r2, sp, #20
    df6e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    df72:	f017 feb1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
    df76:	e7d1      	b.n	df1c <app_key_set+0x28>
		return -EINVAL;
    df78:	f06f 0415 	mvn.w	r4, #21
    df7c:	e7ce      	b.n	df1c <app_key_set+0x28>
    df7e:	bf00      	nop
    df80:	0002f4d6 	.word	0x0002f4d6
    df84:	0002dae4 	.word	0x0002dae4
    df88:	00030f7e 	.word	0x00030f7e

0000df8c <bt_mesh_app_key_exists>:
		if (apps[i].app_idx == app_idx) {
    df8c:	4b05      	ldr	r3, [pc, #20]	; (dfa4 <bt_mesh_app_key_exists+0x18>)
    df8e:	885a      	ldrh	r2, [r3, #2]
    df90:	4282      	cmp	r2, r0
    df92:	d004      	beq.n	df9e <bt_mesh_app_key_exists+0x12>
    df94:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    df96:	1a1b      	subs	r3, r3, r0
    df98:	4258      	negs	r0, r3
    df9a:	4158      	adcs	r0, r3
    df9c:	4770      	bx	lr
			return true;
    df9e:	2001      	movs	r0, #1
}
    dfa0:	4770      	bx	lr
    dfa2:	bf00      	nop
    dfa4:	20000d48 	.word	0x20000d48

0000dfa8 <bt_mesh_app_keys_get>:
{
    dfa8:	b5f0      	push	{r4, r5, r6, r7, lr}
    dfaa:	4c11      	ldr	r4, [pc, #68]	; (dff0 <bt_mesh_app_keys_get+0x48>)
    dfac:	4605      	mov	r5, r0
    dfae:	2602      	movs	r6, #2
	size_t count = 0;
    dfb0:	2000      	movs	r0, #0
		if (app->app_idx == BT_MESH_KEY_UNUSED) {
    dfb2:	f64f 77ff 	movw	r7, #65535	; 0xffff
    dfb6:	f8b4 c002 	ldrh.w	ip, [r4, #2]
    dfba:	45bc      	cmp	ip, r7
    dfbc:	d007      	beq.n	dfce <bt_mesh_app_keys_get+0x26>
		if (net_idx != BT_MESH_KEY_ANY && app->net_idx != net_idx) {
    dfbe:	42bd      	cmp	r5, r7
    dfc0:	d003      	beq.n	dfca <bt_mesh_app_keys_get+0x22>
    dfc2:	f8b4 e000 	ldrh.w	lr, [r4]
    dfc6:	45ae      	cmp	lr, r5
    dfc8:	d101      	bne.n	dfce <bt_mesh_app_keys_get+0x26>
		if (skip) {
    dfca:	b13b      	cbz	r3, dfdc <bt_mesh_app_keys_get+0x34>
			skip--;
    dfcc:	3b01      	subs	r3, #1
	for (int i = 0; i < ARRAY_SIZE(apps); i++) {
    dfce:	2e01      	cmp	r6, #1
    dfd0:	f104 0428 	add.w	r4, r4, #40	; 0x28
    dfd4:	d100      	bne.n	dfd8 <bt_mesh_app_keys_get+0x30>
}
    dfd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dfd8:	2601      	movs	r6, #1
    dfda:	e7ec      	b.n	dfb6 <bt_mesh_app_keys_get+0xe>
		if (count >= max) {
    dfdc:	4282      	cmp	r2, r0
    dfde:	d903      	bls.n	dfe8 <bt_mesh_app_keys_get+0x40>
		app_idxs[count++] = app->app_idx;
    dfe0:	f821 c010 	strh.w	ip, [r1, r0, lsl #1]
    dfe4:	3001      	adds	r0, #1
    dfe6:	e7f2      	b.n	dfce <bt_mesh_app_keys_get+0x26>
			return -ENOMEM;
    dfe8:	f06f 000b 	mvn.w	r0, #11
    dfec:	e7f3      	b.n	dfd6 <bt_mesh_app_keys_get+0x2e>
    dfee:	bf00      	nop
    dff0:	20000d48 	.word	0x20000d48

0000dff4 <bt_mesh_keys_resolve>:
{
    dff4:	b5f0      	push	{r4, r5, r6, r7, lr}
    dff6:	460f      	mov	r7, r1
	if (BT_MESH_IS_DEV_KEY(ctx->app_idx)) {
    dff8:	8841      	ldrh	r1, [r0, #2]
{
    dffa:	461e      	mov	r6, r3
	if (BT_MESH_IS_DEV_KEY(ctx->app_idx)) {
    dffc:	1ccb      	adds	r3, r1, #3
    dffe:	b29b      	uxth	r3, r3
    e000:	2b01      	cmp	r3, #1
{
    e002:	b089      	sub	sp, #36	; 0x24
    e004:	4604      	mov	r4, r0
    e006:	4615      	mov	r5, r2
	if (BT_MESH_IS_DEV_KEY(ctx->app_idx)) {
    e008:	d820      	bhi.n	e04c <bt_mesh_keys_resolve+0x58>
		*sub = bt_mesh_subnet_get(ctx->net_idx);
    e00a:	8800      	ldrh	r0, [r0, #0]
    e00c:	f7ff fbf8 	bl	d800 <bt_mesh_subnet_get>
    e010:	4603      	mov	r3, r0
    e012:	6038      	str	r0, [r7, #0]
		if (!*sub) {
    e014:	b910      	cbnz	r0, e01c <bt_mesh_keys_resolve+0x28>
		BT_WARN("Unknown NetKey 0x%03x", app->net_idx);
    e016:	8822      	ldrh	r2, [r4, #0]
    e018:	4922      	ldr	r1, [pc, #136]	; (e0a4 <bt_mesh_keys_resolve+0xb0>)
    e01a:	e00b      	b.n	e034 <bt_mesh_keys_resolve+0x40>
		if (ctx->app_idx == BT_MESH_KEY_DEV_REMOTE &&
    e01c:	8862      	ldrh	r2, [r4, #2]
    e01e:	f64f 73fd 	movw	r3, #65533	; 0xfffd
    e022:	429a      	cmp	r2, r3
    e024:	d10c      	bne.n	e040 <bt_mesh_keys_resolve+0x4c>
		    !bt_mesh_has_addr(ctx->addr)) {
    e026:	88a0      	ldrh	r0, [r4, #4]
    e028:	f002 ff36 	bl	10e98 <bt_mesh_has_addr>
		if (ctx->app_idx == BT_MESH_KEY_DEV_REMOTE &&
    e02c:	4603      	mov	r3, r0
    e02e:	b938      	cbnz	r0, e040 <bt_mesh_keys_resolve+0x4c>
				BT_WARN("No DevKey for 0x%04x", ctx->addr);
    e030:	88a2      	ldrh	r2, [r4, #4]
    e032:	491d      	ldr	r1, [pc, #116]	; (e0a8 <bt_mesh_keys_resolve+0xb4>)
		BT_WARN("Unknown NetKey 0x%03x", app->net_idx);
    e034:	e9cd 1206 	strd	r1, r2, [sp, #24]
    e038:	2203      	movs	r2, #3
    e03a:	9201      	str	r2, [sp, #4]
    e03c:	9205      	str	r2, [sp, #20]
	compiler_barrier();
    e03e:	e011      	b.n	e064 <bt_mesh_keys_resolve+0x70>
			*app_key = bt_mesh.dev_key;
    e040:	4b1a      	ldr	r3, [pc, #104]	; (e0ac <bt_mesh_keys_resolve+0xb8>)
    e042:	602b      	str	r3, [r5, #0]
		*aid = 0;
    e044:	2000      	movs	r0, #0
    e046:	7030      	strb	r0, [r6, #0]
}
    e048:	b009      	add	sp, #36	; 0x24
    e04a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	app = app_get(ctx->app_idx);
    e04c:	4608      	mov	r0, r1
    e04e:	f7ff fe01 	bl	dc54 <app_get>
	if (!app) {
    e052:	4604      	mov	r4, r0
    e054:	b978      	cbnz	r0, e076 <bt_mesh_keys_resolve+0x82>
		BT_WARN("Unknown AppKey 0x%03x", ctx->app_idx);
    e056:	4b16      	ldr	r3, [pc, #88]	; (e0b0 <bt_mesh_keys_resolve+0xbc>)
    e058:	e9cd 3106 	strd	r3, r1, [sp, #24]
    e05c:	2303      	movs	r3, #3
    e05e:	9301      	str	r3, [sp, #4]
    e060:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    e062:	4603      	mov	r3, r0
    e064:	4813      	ldr	r0, [pc, #76]	; (e0b4 <bt_mesh_keys_resolve+0xc0>)
    e066:	aa05      	add	r2, sp, #20
    e068:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    e06c:	f017 fe34 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
    e070:	f06f 0015 	mvn.w	r0, #21
    e074:	e7e8      	b.n	e048 <bt_mesh_keys_resolve+0x54>
	*sub = bt_mesh_subnet_get(app->net_idx);
    e076:	8800      	ldrh	r0, [r0, #0]
    e078:	f7ff fbc2 	bl	d800 <bt_mesh_subnet_get>
    e07c:	4603      	mov	r3, r0
    e07e:	6038      	str	r0, [r7, #0]
	if (!*sub) {
    e080:	2800      	cmp	r0, #0
    e082:	d0c8      	beq.n	e016 <bt_mesh_keys_resolve+0x22>
	if ((*sub)->kr_phase == BT_MESH_KR_PHASE_2 && app->updated) {
    e084:	7f83      	ldrb	r3, [r0, #30]
    e086:	2b02      	cmp	r3, #2
    e088:	d107      	bne.n	e09a <bt_mesh_keys_resolve+0xa6>
    e08a:	7923      	ldrb	r3, [r4, #4]
    e08c:	b12b      	cbz	r3, e09a <bt_mesh_keys_resolve+0xa6>
		*aid = app->keys[1].id;
    e08e:	7da3      	ldrb	r3, [r4, #22]
    e090:	7033      	strb	r3, [r6, #0]
		*app_key = app->keys[1].val;
    e092:	3417      	adds	r4, #23
		*app_key = app->keys[0].val;
    e094:	602c      	str	r4, [r5, #0]
	return 0;
    e096:	2000      	movs	r0, #0
    e098:	e7d6      	b.n	e048 <bt_mesh_keys_resolve+0x54>
		*aid = app->keys[0].id;
    e09a:	7963      	ldrb	r3, [r4, #5]
    e09c:	7033      	strb	r3, [r6, #0]
		*app_key = app->keys[0].val;
    e09e:	3406      	adds	r4, #6
    e0a0:	e7f8      	b.n	e094 <bt_mesh_keys_resolve+0xa0>
    e0a2:	bf00      	nop
    e0a4:	00030f96 	.word	0x00030f96
    e0a8:	00030fac 	.word	0x00030fac
    e0ac:	20001cd8 	.word	0x20001cd8
    e0b0:	00030fc1 	.word	0x00030fc1
    e0b4:	0002dae4 	.word	0x0002dae4

0000e0b8 <bt_mesh_app_key_find>:
{
    e0b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e0bc:	f8dd 9020 	ldr.w	r9, [sp, #32]
    e0c0:	4688      	mov	r8, r1
    e0c2:	4616      	mov	r6, r2
    e0c4:	461f      	mov	r7, r3
	if (dev_key) {
    e0c6:	4604      	mov	r4, r0
    e0c8:	b180      	cbz	r0, e0ec <bt_mesh_app_key_find+0x34>
		if (BT_MESH_ADDR_IS_UNICAST(rx->ctx.recv_dst)) {
    e0ca:	f9b2 300a 	ldrsh.w	r3, [r2, #10]
    e0ce:	2b00      	cmp	r3, #0
    e0d0:	dc03      	bgt.n	e0da <bt_mesh_app_key_find+0x22>
		return BT_MESH_KEY_UNUSED;
    e0d2:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
    e0d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			err = cb(rx, bt_mesh.dev_key, cb_data);
    e0da:	4919      	ldr	r1, [pc, #100]	; (e140 <bt_mesh_app_key_find+0x88>)
    e0dc:	464a      	mov	r2, r9
    e0de:	4630      	mov	r0, r6
    e0e0:	47b8      	blx	r7
			if (!err) {
    e0e2:	2800      	cmp	r0, #0
    e0e4:	d1f5      	bne.n	e0d2 <bt_mesh_app_key_find+0x1a>
				return BT_MESH_KEY_DEV_LOCAL;
    e0e6:	f64f 70fe 	movw	r0, #65534	; 0xfffe
    e0ea:	e7f4      	b.n	e0d6 <bt_mesh_app_key_find+0x1e>
    e0ec:	4d15      	ldr	r5, [pc, #84]	; (e144 <bt_mesh_app_key_find+0x8c>)
		if (app->app_idx == BT_MESH_KEY_UNUSED) {
    e0ee:	f64f 7aff 	movw	sl, #65535	; 0xffff
    e0f2:	f835 3c14 	ldrh.w	r3, [r5, #-20]
    e0f6:	4553      	cmp	r3, sl
    e0f8:	4629      	mov	r1, r5
    e0fa:	d01b      	beq.n	e134 <bt_mesh_app_key_find+0x7c>
		if (app->net_idx != rx->sub->net_idx) {
    e0fc:	6833      	ldr	r3, [r6, #0]
    e0fe:	f835 2c16 	ldrh.w	r2, [r5, #-22]
    e102:	8b9b      	ldrh	r3, [r3, #28]
    e104:	429a      	cmp	r2, r3
    e106:	d115      	bne.n	e134 <bt_mesh_app_key_find+0x7c>
		if (rx->new_key && app->updated) {
    e108:	7d33      	ldrb	r3, [r6, #20]
    e10a:	079b      	lsls	r3, r3, #30
    e10c:	d502      	bpl.n	e114 <bt_mesh_app_key_find+0x5c>
    e10e:	f815 3c12 	ldrb.w	r3, [r5, #-18]
    e112:	b90b      	cbnz	r3, e118 <bt_mesh_app_key_find+0x60>
			cred = &app->keys[0];
    e114:	f1a5 0111 	sub.w	r1, r5, #17
		if (cred->id != aid) {
    e118:	780b      	ldrb	r3, [r1, #0]
    e11a:	4543      	cmp	r3, r8
    e11c:	d10a      	bne.n	e134 <bt_mesh_app_key_find+0x7c>
		err = cb(rx, cred->val, cb_data);
    e11e:	464a      	mov	r2, r9
    e120:	3101      	adds	r1, #1
    e122:	4630      	mov	r0, r6
    e124:	47b8      	blx	r7
		if (err) {
    e126:	b928      	cbnz	r0, e134 <bt_mesh_app_key_find+0x7c>
		return app->app_idx;
    e128:	4807      	ldr	r0, [pc, #28]	; (e148 <bt_mesh_app_key_find+0x90>)
    e12a:	2328      	movs	r3, #40	; 0x28
    e12c:	fb03 0404 	mla	r4, r3, r4, r0
    e130:	8860      	ldrh	r0, [r4, #2]
    e132:	e7d0      	b.n	e0d6 <bt_mesh_app_key_find+0x1e>
	for (i = 0; i < ARRAY_SIZE(apps); i++) {
    e134:	3528      	adds	r5, #40	; 0x28
    e136:	2c00      	cmp	r4, #0
    e138:	d1cb      	bne.n	e0d2 <bt_mesh_app_key_find+0x1a>
    e13a:	2401      	movs	r4, #1
    e13c:	e7d9      	b.n	e0f2 <bt_mesh_app_key_find+0x3a>
    e13e:	bf00      	nop
    e140:	20001cd8 	.word	0x20001cd8
    e144:	20000d5e 	.word	0x20000d5e
    e148:	20000d48 	.word	0x20000d48

0000e14c <bt_mesh_app_keys_reset>:
{
    e14c:	b510      	push	{r4, lr}
		if (app->app_idx != BT_MESH_KEY_UNUSED) {
    e14e:	4c0a      	ldr	r4, [pc, #40]	; (e178 <bt_mesh_app_keys_reset+0x2c>)
    e150:	8862      	ldrh	r2, [r4, #2]
    e152:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e156:	429a      	cmp	r2, r3
    e158:	d002      	beq.n	e160 <bt_mesh_app_keys_reset+0x14>
			app_key_del(app);
    e15a:	4620      	mov	r0, r4
    e15c:	f01b faf9 	bl	29752 <app_key_del>
		if (app->app_idx != BT_MESH_KEY_UNUSED) {
    e160:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    e162:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e166:	429a      	cmp	r2, r3
    e168:	d004      	beq.n	e174 <bt_mesh_app_keys_reset+0x28>
}
    e16a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			app_key_del(app);
    e16e:	4803      	ldr	r0, [pc, #12]	; (e17c <bt_mesh_app_keys_reset+0x30>)
    e170:	f01b baef 	b.w	29752 <app_key_del>
}
    e174:	bd10      	pop	{r4, pc}
    e176:	bf00      	nop
    e178:	20000d48 	.word	0x20000d48
    e17c:	20000d70 	.word	0x20000d70

0000e180 <bt_mesh_app_key_pending_store>:

BT_MESH_SETTINGS_DEFINE(app, "AppKey", app_key_set);

void bt_mesh_app_key_pending_store(void)
{
    e180:	b510      	push	{r4, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(app_key_updates); i++) {
		struct app_key_update *update = &app_key_updates[i];

		if (!update->valid) {
    e182:	4c12      	ldr	r4, [pc, #72]	; (e1cc <bt_mesh_app_key_pending_store+0x4c>)
    e184:	7863      	ldrb	r3, [r4, #1]
    e186:	06d8      	lsls	r0, r3, #27
    e188:	d50a      	bpl.n	e1a0 <bt_mesh_app_key_pending_store+0x20>
			continue;
		}

		if (update->clear) {
			clear_app_key(update->key_idx);
    e18a:	8820      	ldrh	r0, [r4, #0]
		if (update->clear) {
    e18c:	0699      	lsls	r1, r3, #26
			clear_app_key(update->key_idx);
    e18e:	f3c0 000b 	ubfx	r0, r0, #0, #12
		if (update->clear) {
    e192:	d414      	bmi.n	e1be <bt_mesh_app_key_pending_store+0x3e>
		} else {
			store_app_key(update->key_idx);
    e194:	f7ff fdb4 	bl	dd00 <store_app_key>
		}

		update->valid = 0U;
    e198:	7863      	ldrb	r3, [r4, #1]
    e19a:	f36f 1304 	bfc	r3, #4, #1
    e19e:	7063      	strb	r3, [r4, #1]
		if (!update->valid) {
    e1a0:	78e3      	ldrb	r3, [r4, #3]
    e1a2:	06da      	lsls	r2, r3, #27
    e1a4:	d50a      	bpl.n	e1bc <bt_mesh_app_key_pending_store+0x3c>
			clear_app_key(update->key_idx);
    e1a6:	8860      	ldrh	r0, [r4, #2]
		if (update->clear) {
    e1a8:	069b      	lsls	r3, r3, #26
			clear_app_key(update->key_idx);
    e1aa:	f3c0 000b 	ubfx	r0, r0, #0, #12
		if (update->clear) {
    e1ae:	d509      	bpl.n	e1c4 <bt_mesh_app_key_pending_store+0x44>
			clear_app_key(update->key_idx);
    e1b0:	f7ff fdf2 	bl	dd98 <clear_app_key>
		update->valid = 0U;
    e1b4:	78e3      	ldrb	r3, [r4, #3]
    e1b6:	f36f 1304 	bfc	r3, #4, #1
    e1ba:	70e3      	strb	r3, [r4, #3]
	}
}
    e1bc:	bd10      	pop	{r4, pc}
			clear_app_key(update->key_idx);
    e1be:	f7ff fdeb 	bl	dd98 <clear_app_key>
    e1c2:	e7e9      	b.n	e198 <bt_mesh_app_key_pending_store+0x18>
			store_app_key(update->key_idx);
    e1c4:	f7ff fd9c 	bl	dd00 <store_app_key>
    e1c8:	e7f4      	b.n	e1b4 <bt_mesh_app_key_pending_store+0x34>
    e1ca:	bf00      	nop
    e1cc:	200038a2 	.word	0x200038a2

0000e1d0 <va_set>:
	return &virtual_addrs[index];
}

static int va_set(const char *name, size_t len_rd,
		  settings_read_cb read_cb, void *cb_arg)
{
    e1d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    e1d2:	460c      	mov	r4, r1
    e1d4:	b08d      	sub	sp, #52	; 0x34
    e1d6:	4616      	mov	r6, r2
    e1d8:	461f      	mov	r7, r3
	struct va_val va;
	struct virtual_addr *lab;
	uint16_t index;
	int err;

	if (!name) {
    e1da:	b978      	cbnz	r0, e1fc <va_set+0x2c>
		BT_ERR("Insufficient number of arguments");
    e1dc:	4b30      	ldr	r3, [pc, #192]	; (e2a0 <va_set+0xd0>)
    e1de:	930a      	str	r3, [sp, #40]	; 0x28
    e1e0:	4830      	ldr	r0, [pc, #192]	; (e2a4 <va_set+0xd4>)
    e1e2:	2302      	movs	r3, #2
    e1e4:	aa09      	add	r2, sp, #36	; 0x24
    e1e6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENOENT;
    e1ea:	f06f 0401 	mvn.w	r4, #1
		BT_ERR("Insufficient number of arguments");
    e1ee:	9301      	str	r3, [sp, #4]
    e1f0:	9309      	str	r3, [sp, #36]	; 0x24
    e1f2:	f01b fc9f 	bl	29b34 <z_log_msg2_static_create.constprop.0>

	BT_DBG("Restored Virtual Address, addr 0x%04x ref 0x%04x",
	       lab->addr, lab->ref);

	return 0;
}
    e1f6:	4620      	mov	r0, r4
    e1f8:	b00d      	add	sp, #52	; 0x34
    e1fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	index = strtol(name, NULL, 16);
    e1fc:	2210      	movs	r2, #16
    e1fe:	2100      	movs	r1, #0
    e200:	f019 fa01 	bl	27606 <strtol>
    e204:	4605      	mov	r5, r0
	if (len_rd == 0) {
    e206:	b944      	cbnz	r4, e21a <va_set+0x4a>
		BT_WARN("Mesh Virtual Address length = 0");
    e208:	4b27      	ldr	r3, [pc, #156]	; (e2a8 <va_set+0xd8>)
    e20a:	930a      	str	r3, [sp, #40]	; 0x28
    e20c:	2302      	movs	r3, #2
    e20e:	9301      	str	r3, [sp, #4]
		BT_WARN("Ignore Mesh Virtual Address ref = 0");
    e210:	9309      	str	r3, [sp, #36]	; 0x24
    e212:	aa09      	add	r2, sp, #36	; 0x24
    e214:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    e218:	e00f      	b.n	e23a <va_set+0x6a>
	err = bt_mesh_settings_set(read_cb, cb_arg, &va, sizeof(va));
    e21a:	2314      	movs	r3, #20
    e21c:	aa01      	add	r2, sp, #4
    e21e:	4639      	mov	r1, r7
    e220:	4630      	mov	r0, r6
    e222:	f006 ff49 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    e226:	4604      	mov	r4, r0
    e228:	b158      	cbz	r0, e242 <va_set+0x72>
		BT_ERR("Failed to set \'virtual address\'");
    e22a:	4b20      	ldr	r3, [pc, #128]	; (e2ac <va_set+0xdc>)
    e22c:	930a      	str	r3, [sp, #40]	; 0x28
    e22e:	2302      	movs	r3, #2
    e230:	9300      	str	r3, [sp, #0]
    e232:	9309      	str	r3, [sp, #36]	; 0x24
    e234:	aa09      	add	r2, sp, #36	; 0x24
    e236:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_WARN("Ignore Mesh Virtual Address ref = 0");
    e23a:	481a      	ldr	r0, [pc, #104]	; (e2a4 <va_set+0xd4>)
    e23c:	f01b fc7a 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return 0;
    e240:	e7d9      	b.n	e1f6 <va_set+0x26>
	if (va.ref == 0) {
    e242:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    e246:	b923      	cbnz	r3, e252 <va_set+0x82>
		BT_WARN("Ignore Mesh Virtual Address ref = 0");
    e248:	4b19      	ldr	r3, [pc, #100]	; (e2b0 <va_set+0xe0>)
    e24a:	930a      	str	r3, [sp, #40]	; 0x28
    e24c:	2302      	movs	r3, #2
    e24e:	9300      	str	r3, [sp, #0]
    e250:	e7de      	b.n	e210 <va_set+0x40>
	if (index >= ARRAY_SIZE(virtual_addrs)) {
    e252:	b2ab      	uxth	r3, r5
    e254:	2b02      	cmp	r3, #2
    e256:	d814      	bhi.n	e282 <va_set+0xb2>
	return &virtual_addrs[index];
    e258:	461d      	mov	r5, r3
	memcpy(lab->uuid, va.uuid, 16);
    e25a:	2014      	movs	r0, #20
    e25c:	4e15      	ldr	r6, [pc, #84]	; (e2b4 <va_set+0xe4>)
    e25e:	4345      	muls	r5, r0
    e260:	1d28      	adds	r0, r5, #4
    e262:	2210      	movs	r2, #16
    e264:	a902      	add	r1, sp, #8
    e266:	4430      	add	r0, r6
    e268:	f019 fb02 	bl	27870 <memcpy>
	lab->addr = va.addr;
    e26c:	1973      	adds	r3, r6, r5
    e26e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    e272:	805a      	strh	r2, [r3, #2]
	lab->ref = va.ref;
    e274:	5b73      	ldrh	r3, [r6, r5]
    e276:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    e27a:	f362 030e 	bfi	r3, r2, #0, #15
    e27e:	5373      	strh	r3, [r6, r5]
	return 0;
    e280:	e7b9      	b.n	e1f6 <va_set+0x26>
		BT_WARN("Out of labels buffers");
    e282:	4b0d      	ldr	r3, [pc, #52]	; (e2b8 <va_set+0xe8>)
    e284:	930a      	str	r3, [sp, #40]	; 0x28
    e286:	4807      	ldr	r0, [pc, #28]	; (e2a4 <va_set+0xd4>)
    e288:	2302      	movs	r3, #2
    e28a:	aa09      	add	r2, sp, #36	; 0x24
    e28c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    e290:	9300      	str	r3, [sp, #0]
    e292:	9309      	str	r3, [sp, #36]	; 0x24
		return -ENOBUFS;
    e294:	f06f 0468 	mvn.w	r4, #104	; 0x68
		BT_WARN("Out of labels buffers");
    e298:	f01b fc4c 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -ENOBUFS;
    e29c:	e7ab      	b.n	e1f6 <va_set+0x26>
    e29e:	bf00      	nop
    e2a0:	0002f4d6 	.word	0x0002f4d6
    e2a4:	0002db8c 	.word	0x0002db8c
    e2a8:	00030ff7 	.word	0x00030ff7
    e2ac:	00031017 	.word	0x00031017
    e2b0:	00031037 	.word	0x00031037
    e2b4:	200038a6 	.word	0x200038a6
    e2b8:	0003105b 	.word	0x0003105b

0000e2bc <seg_rx_reset>:
{
    e2bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e2c0:	4604      	mov	r4, r0
    e2c2:	b089      	sub	sp, #36	; 0x24
	(void)k_work_cancel_delayable(&rx->ack);
    e2c4:	3030      	adds	r0, #48	; 0x30
{
    e2c6:	460d      	mov	r5, r1
	(void)k_work_cancel_delayable(&rx->ack);
    e2c8:	f01e fd9d 	bl	2ce06 <k_work_cancel_delayable>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    e2cc:	f994 301f 	ldrsb.w	r3, [r4, #31]
    e2d0:	2b00      	cmp	r3, #0
    e2d2:	da1b      	bge.n	e30c <seg_rx_reset+0x50>
	    rx->block != BLOCK_COMPLETE(rx->seg_n)) {
    e2d4:	7fe3      	ldrb	r3, [r4, #31]
    e2d6:	f003 031f 	and.w	r3, r3, #31
    e2da:	1c5a      	adds	r2, r3, #1
    e2dc:	2301      	movs	r3, #1
    e2de:	4093      	lsls	r3, r2
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    e2e0:	6a62      	ldr	r2, [r4, #36]	; 0x24
	    rx->block != BLOCK_COMPLETE(rx->seg_n)) {
    e2e2:	3b01      	subs	r3, #1
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->obo &&
    e2e4:	429a      	cmp	r2, r3
    e2e6:	d011      	beq.n	e30c <seg_rx_reset+0x50>
		BT_WARN("Clearing incomplete buffers from Friend queue");
    e2e8:	4b19      	ldr	r3, [pc, #100]	; (e350 <seg_rx_reset+0x94>)
    e2ea:	481a      	ldr	r0, [pc, #104]	; (e354 <seg_rx_reset+0x98>)
    e2ec:	9306      	str	r3, [sp, #24]
    e2ee:	aa05      	add	r2, sp, #20
    e2f0:	2302      	movs	r3, #2
    e2f2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    e2f6:	9301      	str	r3, [sp, #4]
    e2f8:	9305      	str	r3, [sp, #20]
    e2fa:	f01b fc1b 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		bt_mesh_friend_clear_incomplete(rx->sub, rx->src, rx->dst,
    e2fe:	8b62      	ldrh	r2, [r4, #26]
    e300:	8b21      	ldrh	r1, [r4, #24]
    e302:	6820      	ldr	r0, [r4, #0]
    e304:	f104 0310 	add.w	r3, r4, #16
    e308:	f008 f9fe 	bl	16708 <bt_mesh_friend_clear_incomplete>
{
    e30c:	2600      	movs	r6, #0
		k_mem_slab_free(&segs, &rx->seg[i]);
    e30e:	f8df 8048 	ldr.w	r8, [pc, #72]	; e358 <seg_rx_reset+0x9c>
    e312:	1d27      	adds	r7, r4, #4
		rx->seg[i] = NULL;
    e314:	46b1      	mov	r9, r6
		if (!rx->seg[i]) {
    e316:	4639      	mov	r1, r7
    e318:	3704      	adds	r7, #4
    e31a:	680b      	ldr	r3, [r1, #0]
    e31c:	b123      	cbz	r3, e328 <seg_rx_reset+0x6c>
		k_mem_slab_free(&segs, &rx->seg[i]);
    e31e:	4640      	mov	r0, r8
    e320:	f01e fb74 	bl	2ca0c <k_mem_slab_free>
		rx->seg[i] = NULL;
    e324:	f847 9c04 	str.w	r9, [r7, #-4]
	for (i = 0; i <= rx->seg_n; i++) {
    e328:	7fe3      	ldrb	r3, [r4, #31]
    e32a:	3601      	adds	r6, #1
    e32c:	f003 021f 	and.w	r2, r3, #31
    e330:	4296      	cmp	r6, r2
    e332:	ddf0      	ble.n	e316 <seg_rx_reset+0x5a>
	rx->in_use = 0U;
    e334:	f36f 1386 	bfc	r3, #6, #1
    e338:	77e3      	strb	r3, [r4, #31]
	if (full_reset) {
    e33a:	b135      	cbz	r5, e34a <seg_rx_reset+0x8e>
		rx->seq_auth = 0U;
    e33c:	2000      	movs	r0, #0
    e33e:	2100      	movs	r1, #0
    e340:	e9c4 0104 	strd	r0, r1, [r4, #16]
		rx->sub = NULL;
    e344:	2300      	movs	r3, #0
    e346:	6023      	str	r3, [r4, #0]
		rx->src = BT_MESH_ADDR_UNASSIGNED;
    e348:	61a3      	str	r3, [r4, #24]
}
    e34a:	b009      	add	sp, #36	; 0x24
    e34c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e350:	00031071 	.word	0x00031071
    e354:	0002db8c 	.word	0x0002db8c
    e358:	20000eb8 	.word	0x20000eb8

0000e35c <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    e35c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    e35e:	ab0a      	add	r3, sp, #40	; 0x28
    e360:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
    e362:	9302      	str	r3, [sp, #8]
    e364:	4b05      	ldr	r3, [pc, #20]	; (e37c <z_log_msg2_runtime_create.constprop.0+0x20>)
    e366:	9301      	str	r3, [sp, #4]
    e368:	2300      	movs	r3, #0
    e36a:	9300      	str	r3, [sp, #0]
    e36c:	2201      	movs	r2, #1
    e36e:	4618      	mov	r0, r3
    e370:	f7f4 ff9a 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    e374:	b007      	add	sp, #28
    e376:	f85d fb04 	ldr.w	pc, [sp], #4
    e37a:	bf00      	nop
    e37c:	0003109f 	.word	0x0003109f

0000e380 <seg_tx_reset>:
{
    e380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e384:	4604      	mov	r4, r0
	(void)k_work_cancel_delayable(&tx->retransmit);
    e386:	3030      	adds	r0, #48	; 0x30
    e388:	f01e fd3d 	bl	2ce06 <k_work_cancel_delayable>
	tx->cb = NULL;
    e38c:	2500      	movs	r5, #0
	tx->blocked = false;
    e38e:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e392:	4f20      	ldr	r7, [pc, #128]	; (e414 <seg_tx_reset+0x94>)
	tx->sub = NULL;
    e394:	6025      	str	r5, [r4, #0]
	tx->seq_auth = 0U;
    e396:	2000      	movs	r0, #0
    e398:	2100      	movs	r1, #0
	tx->cb_data = NULL;
    e39a:	e9c4 550a 	strd	r5, r5, [r4, #40]	; 0x28
	tx->seq_auth = 0U;
    e39e:	e9c4 0104 	strd	r0, r1, [r4, #16]
	tx->blocked = false;
    e3a2:	f365 0200 	bfi	r2, r5, #0, #1
	tx->src = BT_MESH_ADDR_UNASSIGNED;
    e3a6:	61a5      	str	r5, [r4, #24]
	tx->blocked = false;
    e3a8:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    e3ac:	1d26      	adds	r6, r4, #4
	tx->seg[seg_idx] = NULL;
    e3ae:	46a8      	mov	r8, r5
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    e3b0:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    e3b4:	b19b      	cbz	r3, e3de <seg_tx_reset+0x5e>
		if (!tx->seg[i]) {
    e3b6:	6833      	ldr	r3, [r6, #0]
    e3b8:	b153      	cbz	r3, e3d0 <seg_tx_reset+0x50>
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e3ba:	4631      	mov	r1, r6
    e3bc:	4638      	mov	r0, r7
    e3be:	f01e fb25 	bl	2ca0c <k_mem_slab_free>
	tx->seg[seg_idx] = NULL;
    e3c2:	f8c6 8000 	str.w	r8, [r6]
	tx->nack_count--;
    e3c6:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    e3ca:	3b01      	subs	r3, #1
    e3cc:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	for (i = 0; i <= tx->seg_n && tx->nack_count; i++) {
    e3d0:	f894 3020 	ldrb.w	r3, [r4, #32]
    e3d4:	3501      	adds	r5, #1
    e3d6:	42ab      	cmp	r3, r5
    e3d8:	f106 0604 	add.w	r6, r6, #4
    e3dc:	dae8      	bge.n	e3b0 <seg_tx_reset+0x30>
	tx->nack_count = 0;
    e3de:	2100      	movs	r1, #0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    e3e0:	4b0d      	ldr	r3, [pc, #52]	; (e418 <seg_tx_reset+0x98>)
    e3e2:	f884 1022 	strb.w	r1, [r4, #34]	; 0x22
    e3e6:	f3bf 8f5b 	dmb	ish
    e3ea:	e853 2f00 	ldrex	r2, [r3]
    e3ee:	f022 0020 	bic.w	r0, r2, #32
    e3f2:	e843 0400 	strex	r4, r0, [r3]
    e3f6:	2c00      	cmp	r4, #0
    e3f8:	d1f7      	bne.n	e3ea <seg_tx_reset+0x6a>
    e3fa:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_mesh.flags, BT_MESH_IVU_PENDING)) {
    e3fe:	0692      	lsls	r2, r2, #26
    e400:	d505      	bpl.n	e40e <seg_tx_reset+0x8e>
}
    e402:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_mesh_net_iv_update(bt_mesh.iv_index, false);
    e406:	f853 0c08 	ldr.w	r0, [r3, #-8]
    e40a:	f7fe bb7b 	b.w	cb04 <bt_mesh_net_iv_update>
}
    e40e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e412:	bf00      	nop
    e414:	20000eb8 	.word	0x20000eb8
    e418:	20001ab0 	.word	0x20001ab0

0000e41c <seg_tx_complete>:
{
    e41c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e420:	4604      	mov	r4, r0
	void *cb_data = tx->cb_data;
    e422:	e9d0 670a 	ldrd	r6, r7, [r0, #40]	; 0x28
		if (&seg_tx[i] != tx &&
    e426:	4813      	ldr	r0, [pc, #76]	; (e474 <seg_tx_complete+0x58>)
    e428:	4284      	cmp	r4, r0
{
    e42a:	460d      	mov	r5, r1
		if (&seg_tx[i] != tx &&
    e42c:	d014      	beq.n	e458 <seg_tx_complete+0x3c>
		    seg_tx[i].blocked &&
    e42e:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
		if (&seg_tx[i] != tx &&
    e432:	07da      	lsls	r2, r3, #31
    e434:	d510      	bpl.n	e458 <seg_tx_complete+0x3c>
	return (tx->src == src) && (tx->dst == dst);
    e436:	8b01      	ldrh	r1, [r0, #24]
    e438:	8b22      	ldrh	r2, [r4, #24]
    e43a:	4291      	cmp	r1, r2
    e43c:	d10c      	bne.n	e458 <seg_tx_complete+0x3c>
    e43e:	8b41      	ldrh	r1, [r0, #26]
    e440:	8b62      	ldrh	r2, [r4, #26]
    e442:	4291      	cmp	r1, r2
    e444:	d108      	bne.n	e458 <seg_tx_complete+0x3c>
		blocked->blocked = false;
    e446:	f36f 0300 	bfc	r3, #0, #1
    e44a:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		k_work_reschedule(&blocked->retransmit, K_NO_WAIT);
    e44e:	2200      	movs	r2, #0
    e450:	2300      	movs	r3, #0
    e452:	3030      	adds	r0, #48	; 0x30
    e454:	f015 ff86 	bl	24364 <k_work_reschedule>
	seg_tx_reset(tx);
    e458:	4620      	mov	r0, r4
    e45a:	f7ff ff91 	bl	e380 <seg_tx_reset>
	if (cb && cb->end) {
    e45e:	b136      	cbz	r6, e46e <seg_tx_complete+0x52>
    e460:	6873      	ldr	r3, [r6, #4]
    e462:	b123      	cbz	r3, e46e <seg_tx_complete+0x52>
		cb->end(err, cb_data);
    e464:	4639      	mov	r1, r7
    e466:	4628      	mov	r0, r5
}
    e468:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb->end(err, cb_data);
    e46c:	4718      	bx	r3
}
    e46e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e472:	bf00      	nop
    e474:	20001d48 	.word	0x20001d48

0000e478 <seg_tx_send_unacked>:
{
    e478:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!tx->nack_count) {
    e47c:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
{
    e480:	b091      	sub	sp, #68	; 0x44
    e482:	4604      	mov	r4, r0
	if (!tx->nack_count) {
    e484:	2b00      	cmp	r3, #0
    e486:	d03c      	beq.n	e502 <seg_tx_send_unacked+0x8a>
		.net_idx = tx->sub->net_idx,
    e488:	6801      	ldr	r1, [r0, #0]
	struct bt_mesh_net_tx net_tx = {
    e48a:	9107      	str	r1, [sp, #28]
	struct bt_mesh_msg_ctx ctx = {
    e48c:	2300      	movs	r3, #0
    e48e:	2501      	movs	r5, #1
    e490:	f8cd 3016 	str.w	r3, [sp, #22]
    e494:	8b8b      	ldrh	r3, [r1, #28]
    e496:	f8ad 3010 	strh.w	r3, [sp, #16]
	struct bt_mesh_net_tx net_tx = {
    e49a:	a904      	add	r1, sp, #16
	struct bt_mesh_msg_ctx ctx = {
    e49c:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
    e4a0:	f88d 501a 	strb.w	r5, [sp, #26]
	struct bt_mesh_net_tx net_tx = {
    e4a4:	9108      	str	r1, [sp, #32]
	struct bt_mesh_msg_ctx ctx = {
    e4a6:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
	struct bt_mesh_net_tx net_tx = {
    e4aa:	8b01      	ldrh	r1, [r0, #24]
	struct bt_mesh_msg_ctx ctx = {
    e4ac:	f88d 501b 	strb.w	r5, [sp, #27]
	struct bt_mesh_net_tx net_tx = {
    e4b0:	f8ad 1024 	strh.w	r1, [sp, #36]	; 0x24
    e4b4:	7f85      	ldrb	r5, [r0, #30]
    e4b6:	7fc1      	ldrb	r1, [r0, #31]
    e4b8:	f88d 1026 	strb.w	r1, [sp, #38]	; 0x26
		.friend_cred = tx->friend_cred,
    e4bc:	f3c3 1140 	ubfx	r1, r3, #5, #1
	struct bt_mesh_net_tx net_tx = {
    e4c0:	ea41 0185 	orr.w	r1, r1, r5, lsl #2
	struct bt_mesh_msg_ctx ctx = {
    e4c4:	f343 0240 	sbfx	r2, r3, #1, #1
	struct bt_mesh_net_tx net_tx = {
    e4c8:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
	if (!tx->attempts) {
    e4cc:	f890 1023 	ldrb.w	r1, [r0, #35]	; 0x23
	struct bt_mesh_msg_ctx ctx = {
    e4d0:	f8ad 2012 	strh.w	r2, [sp, #18]
		.addr = tx->dst,
    e4d4:	8b42      	ldrh	r2, [r0, #26]
	struct bt_mesh_msg_ctx ctx = {
    e4d6:	f8ad 2014 	strh.w	r2, [sp, #20]
	if (!tx->attempts) {
    e4da:	b9a9      	cbnz	r1, e508 <seg_tx_send_unacked+0x90>
		if (BT_MESH_ADDR_IS_UNICAST(tx->dst)) {
    e4dc:	b212      	sxth	r2, r2
    e4de:	2a00      	cmp	r2, #0
    e4e0:	dd0d      	ble.n	e4fe <seg_tx_send_unacked+0x86>
			BT_ERR("Ran out of retransmit attempts");
    e4e2:	4b41      	ldr	r3, [pc, #260]	; (e5e8 <seg_tx_send_unacked+0x170>)
    e4e4:	4841      	ldr	r0, [pc, #260]	; (e5ec <seg_tx_send_unacked+0x174>)
    e4e6:	930e      	str	r3, [sp, #56]	; 0x38
    e4e8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    e4ec:	2302      	movs	r3, #2
    e4ee:	aa0d      	add	r2, sp, #52	; 0x34
    e4f0:	9303      	str	r3, [sp, #12]
    e4f2:	930d      	str	r3, [sp, #52]	; 0x34
    e4f4:	f01b fb1e 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			seg_tx_complete(tx, -ETIMEDOUT);
    e4f8:	f06f 0173 	mvn.w	r1, #115	; 0x73
    e4fc:	4620      	mov	r0, r4
			seg_tx_complete(tx, 0);
    e4fe:	f7ff ff8d 	bl	e41c <seg_tx_complete>
}
    e502:	b011      	add	sp, #68	; 0x44
    e504:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	tx->sending = 1U;
    e508:	f043 0310 	orr.w	r3, r3, #16
		err = bt_mesh_net_send(&net_tx, seg, &seg_sent_cb, tx);
    e50c:	f8df 80e0 	ldr.w	r8, [pc, #224]	; e5f0 <seg_tx_send_unacked+0x178>
	tx->sending = 1U;
    e510:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
					 tx->xmit, BUF_TIMEOUT);
    e514:	2600      	movs	r6, #0
    e516:	2700      	movs	r7, #0
	for (; tx->seg_o <= tx->seg_n; tx->seg_o++) {
    e518:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    e51c:	f894 2020 	ldrb.w	r2, [r4, #32]
    e520:	429a      	cmp	r2, r3
    e522:	d208      	bcs.n	e536 <seg_tx_send_unacked+0xbe>
	tx->seg_o = 0U;
    e524:	2300      	movs	r3, #0
    e526:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	tx->attempts--;
    e52a:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    e52e:	3b01      	subs	r3, #1
    e530:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
    e534:	e030      	b.n	e598 <seg_tx_send_unacked+0x120>
		if (!tx->seg[tx->seg_o]) {
    e536:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    e53a:	685b      	ldr	r3, [r3, #4]
    e53c:	b92b      	cbnz	r3, e54a <seg_tx_send_unacked+0xd2>
	for (; tx->seg_o <= tx->seg_n; tx->seg_o++) {
    e53e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    e542:	3301      	adds	r3, #1
    e544:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    e548:	e7e6      	b.n	e518 <seg_tx_send_unacked+0xa0>
		seg = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_LOCAL_ADV,
    e54a:	2101      	movs	r1, #1
    e54c:	e9cd 6700 	strd	r6, r7, [sp]
    e550:	7fe2      	ldrb	r2, [r4, #31]
    e552:	4608      	mov	r0, r1
    e554:	f7fd fd28 	bl	bfa8 <bt_mesh_adv_create>
		if (!seg) {
    e558:	4605      	mov	r5, r0
    e55a:	b1e8      	cbz	r0, e598 <seg_tx_send_unacked+0x120>
	net_buf_simple_reserve(&buf->b, reserve);
    e55c:	f100 0908 	add.w	r9, r0, #8
    e560:	2109      	movs	r1, #9
    e562:	4648      	mov	r0, r9
    e564:	f01d fb84 	bl	2bc70 <net_buf_simple_reserve>
		seg_tx_buf_build(tx, tx->seg_o, &seg->b);
    e568:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
    e56c:	464a      	mov	r2, r9
    e56e:	4620      	mov	r0, r4
    e570:	f01b f9ee 	bl	29950 <seg_tx_buf_build>
		tx->seg_pending++;
    e574:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e578:	3301      	adds	r3, #1
    e57a:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		err = bt_mesh_net_send(&net_tx, seg, &seg_sent_cb, tx);
    e57e:	4642      	mov	r2, r8
    e580:	4623      	mov	r3, r4
    e582:	4629      	mov	r1, r5
    e584:	a807      	add	r0, sp, #28
    e586:	f7fe fc79 	bl	ce7c <bt_mesh_net_send>
		if (err) {
    e58a:	2800      	cmp	r0, #0
    e58c:	d0d7      	beq.n	e53e <seg_tx_send_unacked+0xc6>
			tx->seg_pending--;
    e58e:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e592:	3b01      	subs	r3, #1
    e594:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	if (!tx->seg_pending) {
    e598:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
    e59c:	b9e1      	cbnz	r1, e5d8 <seg_tx_send_unacked+0x160>
				  K_MSEC(SEG_RETRANSMIT_TIMEOUT(tx)));
    e59e:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
    e5a2:	2b00      	cmp	r3, #0
    e5a4:	bfc4      	itt	gt
    e5a6:	f894 2024 	ldrbgt.w	r2, [r4, #36]	; 0x24
    e5aa:	f44f 73c8 	movgt.w	r3, #400	; 0x190
    e5ae:	f04f 0032 	mov.w	r0, #50	; 0x32
    e5b2:	bfc8      	it	gt
    e5b4:	fb00 3002 	mlagt	r0, r0, r2, r3
    e5b8:	03c0      	lsls	r0, r0, #15
    e5ba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e5be:	2300      	movs	r3, #0
    e5c0:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
    e5c4:	03c9      	lsls	r1, r1, #15
    e5c6:	f7f1 fd8b 	bl	e0 <__aeabi_uldivmod>
		k_work_reschedule(&tx->retransmit,
    e5ca:	f104 0530 	add.w	r5, r4, #48	; 0x30
    e5ce:	4602      	mov	r2, r0
    e5d0:	460b      	mov	r3, r1
    e5d2:	4628      	mov	r0, r5
    e5d4:	f015 fec6 	bl	24364 <k_work_reschedule>
	tx->sending = 0U;
    e5d8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
    e5dc:	f36f 1304 	bfc	r3, #4, #1
    e5e0:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
    e5e4:	e78d      	b.n	e502 <seg_tx_send_unacked+0x8a>
    e5e6:	bf00      	nop
    e5e8:	000310be 	.word	0x000310be
    e5ec:	0002db8c 	.word	0x0002db8c
    e5f0:	0002e41c 	.word	0x0002e41c

0000e5f4 <ctl_recv>:
{
    e5f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e5f8:	460f      	mov	r7, r1
	switch (ctl_op) {
    e5fa:	f017 077f 	ands.w	r7, r7, #127	; 0x7f
{
    e5fe:	b08a      	sub	sp, #40	; 0x28
    e600:	4605      	mov	r5, r0
    e602:	4611      	mov	r1, r2
    e604:	4698      	mov	r8, r3
	switch (ctl_op) {
    e606:	d010      	beq.n	e62a <ctl_recv+0x36>
    e608:	2f0a      	cmp	r7, #10
    e60a:	f000 80b6 	beq.w	e77a <ctl_recv+0x186>
	if (!rx->local_match) {
    e60e:	7d03      	ldrb	r3, [r0, #20]
    e610:	f013 0440 	ands.w	r4, r3, #64	; 0x40
    e614:	d033      	beq.n	e67e <ctl_recv+0x8a>
		switch (ctl_op) {
    e616:	1e7b      	subs	r3, r7, #1
    e618:	2b07      	cmp	r3, #7
    e61a:	f200 80d1 	bhi.w	e7c0 <ctl_recv+0x1cc>
    e61e:	e8df f003 	tbb	[pc, r3]
    e622:	cfb1      	.short	0xcfb1
    e624:	c0bbcfb6 	.word	0xc0bbcfb6
    e628:	cac5      	.short	0xcac5
	if (buf->len < 6) {
    e62a:	8893      	ldrh	r3, [r2, #4]
    e62c:	2b05      	cmp	r3, #5
    e62e:	d80d      	bhi.n	e64c <ctl_recv+0x58>
		BT_ERR("Too short ack message");
    e630:	4b6f      	ldr	r3, [pc, #444]	; (e7f0 <ctl_recv+0x1fc>)
		BT_ERR("Received ack for group seg");
    e632:	9308      	str	r3, [sp, #32]
    e634:	2302      	movs	r3, #2
    e636:	9303      	str	r3, [sp, #12]
    e638:	9307      	str	r3, [sp, #28]
    e63a:	aa07      	add	r2, sp, #28
    e63c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    e640:	486c      	ldr	r0, [pc, #432]	; (e7f4 <ctl_recv+0x200>)
    e642:	f01b fa77 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    e646:	f06f 0415 	mvn.w	r4, #21
    e64a:	e018      	b.n	e67e <ctl_recv+0x8a>
	seq_zero = net_buf_simple_pull_be16(buf);
    e64c:	4610      	mov	r0, r2
    e64e:	9201      	str	r2, [sp, #4]
    e650:	f01d fc04 	bl	2be5c <net_buf_simple_pull_be16>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match) {
    e654:	f995 3014 	ldrsb.w	r3, [r5, #20]
    e658:	9901      	ldr	r1, [sp, #4]
    e65a:	2b00      	cmp	r3, #0
	obo = seq_zero >> 15;
    e65c:	f3c0 39cf 	ubfx	r9, r0, #15, #16
	seq_zero = (seq_zero >> 2) & TRANS_SEQ_ZERO_MASK;
    e660:	f3c0 048c 	ubfx	r4, r0, #2, #13
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match) {
    e664:	da0f      	bge.n	e686 <ctl_recv+0x92>
		*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(rx), seq_zero);
    e666:	7d2a      	ldrb	r2, [r5, #20]
    e668:	f002 0301 	and.w	r3, r2, #1
    e66c:	4a62      	ldr	r2, [pc, #392]	; (e7f8 <ctl_recv+0x204>)
    e66e:	6812      	ldr	r2, [r2, #0]
    e670:	1ad2      	subs	r2, r2, r3
    e672:	0a13      	lsrs	r3, r2, #8
    e674:	ea44 6202 	orr.w	r2, r4, r2, lsl #24
    e678:	e9c8 2300 	strd	r2, r3, [r8]
		return 0;
    e67c:	463c      	mov	r4, r7
}
    e67e:	4620      	mov	r0, r4
    e680:	b00a      	add	sp, #40	; 0x28
    e682:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ack = net_buf_simple_pull_be32(buf);
    e686:	4608      	mov	r0, r1
    e688:	f01d fbf2 	bl	2be70 <net_buf_simple_pull_be32>
	tx = seg_tx_lookup(seq_zero, obo, rx->ctx.addr);
    e68c:	8929      	ldrh	r1, [r5, #8]
		if ((tx->seq_auth & TRANS_SEQ_ZERO_MASK) != seq_zero) {
    e68e:	4d5b      	ldr	r5, [pc, #364]	; (e7fc <ctl_recv+0x208>)
	ack = net_buf_simple_pull_be32(buf);
    e690:	4606      	mov	r6, r0
		if ((tx->seq_auth & TRANS_SEQ_ZERO_MASK) != seq_zero) {
    e692:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    e696:	f3c2 030c 	ubfx	r3, r2, #0, #13
    e69a:	42bf      	cmp	r7, r7
    e69c:	bf08      	it	eq
    e69e:	42a3      	cmpeq	r3, r4
    e6a0:	f040 809d 	bne.w	e7de <ctl_recv+0x1ea>
		if (tx->dst == addr) {
    e6a4:	8b6b      	ldrh	r3, [r5, #26]
    e6a6:	428b      	cmp	r3, r1
    e6a8:	d00c      	beq.n	e6c4 <ctl_recv+0xd0>
		if (obo && tx->nack_count == tx->seg_n + 1) {
    e6aa:	f1b9 0f00 	cmp.w	r9, #0
    e6ae:	f000 8096 	beq.w	e7de <ctl_recv+0x1ea>
    e6b2:	f895 3020 	ldrb.w	r3, [r5, #32]
    e6b6:	f895 4022 	ldrb.w	r4, [r5, #34]	; 0x22
    e6ba:	3301      	adds	r3, #1
    e6bc:	429c      	cmp	r4, r3
    e6be:	f040 808e 	bne.w	e7de <ctl_recv+0x1ea>
			tx->dst = addr;
    e6c2:	8369      	strh	r1, [r5, #26]
	if (!BT_MESH_ADDR_IS_UNICAST(tx->dst)) {
    e6c4:	f9b5 301a 	ldrsh.w	r3, [r5, #26]
    e6c8:	2b00      	cmp	r3, #0
    e6ca:	dc01      	bgt.n	e6d0 <ctl_recv+0xdc>
		BT_ERR("Received ack for group seg");
    e6cc:	4b4c      	ldr	r3, [pc, #304]	; (e800 <ctl_recv+0x20c>)
    e6ce:	e7b0      	b.n	e632 <ctl_recv+0x3e>
	*seq_auth = tx->seq_auth;
    e6d0:	e9c8 2000 	strd	r2, r0, [r8]
	if (!ack) {
    e6d4:	b98e      	cbnz	r6, e6fa <ctl_recv+0x106>
		BT_WARN("SDU canceled");
    e6d6:	4b4b      	ldr	r3, [pc, #300]	; (e804 <ctl_recv+0x210>)
    e6d8:	4846      	ldr	r0, [pc, #280]	; (e7f4 <ctl_recv+0x200>)
    e6da:	9308      	str	r3, [sp, #32]
    e6dc:	aa07      	add	r2, sp, #28
    e6de:	2302      	movs	r3, #2
    e6e0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    e6e4:	9303      	str	r3, [sp, #12]
    e6e6:	9307      	str	r3, [sp, #28]
    e6e8:	f01b fa24 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		seg_tx_complete(tx, -ECANCELED);
    e6ec:	4843      	ldr	r0, [pc, #268]	; (e7fc <ctl_recv+0x208>)
    e6ee:	f06f 018b 	mvn.w	r1, #139	; 0x8b
    e6f2:	f7ff fe93 	bl	e41c <seg_tx_complete>
		return 0;
    e6f6:	4634      	mov	r4, r6
    e6f8:	e7c1      	b.n	e67e <ctl_recv+0x8a>
	if (find_msb_set(ack) - 1 > tx->seg_n) {
    e6fa:	f895 2020 	ldrb.w	r2, [r5, #32]
{
	if (op == 0) {
		return 0;
	}

	return 32 - __builtin_clz(op);
    e6fe:	fab6 f386 	clz	r3, r6
    e702:	f1c3 031f 	rsb	r3, r3, #31
    e706:	4293      	cmp	r3, r2
    e708:	d818      	bhi.n	e73c <ctl_recv+0x148>
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e70a:	f8df a0fc 	ldr.w	sl, [pc, #252]	; e808 <ctl_recv+0x214>
	tx->seg[seg_idx] = NULL;
    e70e:	f04f 0800 	mov.w	r8, #0
		ack &= ~BIT(bit - 1);
    e712:	f04f 0901 	mov.w	r9, #1
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    e716:	2e00      	cmp	r6, #0
    e718:	fa96 f7a6 	rbit	r7, r6
    e71c:	fab7 f787 	clz	r7, r7
    e720:	bf08      	it	eq
    e722:	f04f 37ff 	moveq.w	r7, #4294967295	; 0xffffffff
	while ((bit = find_lsb_set(ack))) {
    e726:	1c7c      	adds	r4, r7, #1
    e728:	d10a      	bne.n	e740 <ctl_recv+0x14c>
	if (tx->nack_count) {
    e72a:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
    e72e:	b1fb      	cbz	r3, e770 <ctl_recv+0x17c>
		k_work_reschedule(&tx->retransmit, K_NO_WAIT);
    e730:	2200      	movs	r2, #0
    e732:	2300      	movs	r3, #0
    e734:	4835      	ldr	r0, [pc, #212]	; (e80c <ctl_recv+0x218>)
    e736:	f015 fe15 	bl	24364 <k_work_reschedule>
    e73a:	e7a0      	b.n	e67e <ctl_recv+0x8a>
		BT_ERR("Too large segment number in ack");
    e73c:	4b34      	ldr	r3, [pc, #208]	; (e810 <ctl_recv+0x21c>)
    e73e:	e778      	b.n	e632 <ctl_recv+0x3e>
		if (tx->seg[bit - 1]) {
    e740:	eb05 0387 	add.w	r3, r5, r7, lsl #2
    e744:	685b      	ldr	r3, [r3, #4]
    e746:	b173      	cbz	r3, e766 <ctl_recv+0x172>
	k_mem_slab_free(&segs, (void **)&tx->seg[seg_idx]);
    e748:	eb05 0184 	add.w	r1, r5, r4, lsl #2
    e74c:	4650      	mov	r0, sl
    e74e:	f01e f95d 	bl	2ca0c <k_mem_slab_free>
    e752:	b2fb      	uxtb	r3, r7
	tx->seg[seg_idx] = NULL;
    e754:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    e758:	f8c3 8004 	str.w	r8, [r3, #4]
	tx->nack_count--;
    e75c:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
    e760:	3b01      	subs	r3, #1
    e762:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		ack &= ~BIT(bit - 1);
    e766:	fa09 f707 	lsl.w	r7, r9, r7
    e76a:	ea26 0607 	bic.w	r6, r6, r7
    e76e:	e7d2      	b.n	e716 <ctl_recv+0x122>
		seg_tx_complete(tx, 0);
    e770:	4822      	ldr	r0, [pc, #136]	; (e7fc <ctl_recv+0x208>)
    e772:	4621      	mov	r1, r4
    e774:	f7ff fe52 	bl	e41c <seg_tx_complete>
    e778:	e781      	b.n	e67e <ctl_recv+0x8a>
}
    e77a:	b00a      	add	sp, #40	; 0x28
    e77c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return bt_mesh_hb_recv(rx, buf);
    e780:	f001 bbc8 	b.w	ff14 <bt_mesh_hb_recv>
}
    e784:	b00a      	add	sp, #40	; 0x28
    e786:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_poll(rx, buf);
    e78a:	f007 bb97 	b.w	15ebc <bt_mesh_friend_poll>
}
    e78e:	b00a      	add	sp, #40	; 0x28
    e790:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_req(rx, buf);
    e794:	f007 bc94 	b.w	160c0 <bt_mesh_friend_req>
}
    e798:	b00a      	add	sp, #40	; 0x28
    e79a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_clear(rx, buf);
    e79e:	f007 ba33 	b.w	15c08 <bt_mesh_friend_clear>
}
    e7a2:	b00a      	add	sp, #40	; 0x28
    e7a4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_clear_cfm(rx, buf);
    e7a8:	f007 bc1e 	b.w	15fe8 <bt_mesh_friend_clear_cfm>
}
    e7ac:	b00a      	add	sp, #40	; 0x28
    e7ae:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_sub_add(rx, buf);
    e7b2:	f007 baa7 	b.w	15d04 <bt_mesh_friend_sub_add>
}
    e7b6:	b00a      	add	sp, #40	; 0x28
    e7b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return bt_mesh_friend_sub_rem(rx, buf);
    e7bc:	f007 bb16 	b.w	15dec <bt_mesh_friend_sub_rem>
	BT_WARN("Unhandled TransOpCode 0x%02x", ctl_op);
    e7c0:	4b14      	ldr	r3, [pc, #80]	; (e814 <ctl_recv+0x220>)
    e7c2:	480c      	ldr	r0, [pc, #48]	; (e7f4 <ctl_recv+0x200>)
	switch (ctl_op) {
    e7c4:	e9cd 3708 	strd	r3, r7, [sp, #32]
	BT_WARN("Unhandled TransOpCode 0x%02x", ctl_op);
    e7c8:	aa07      	add	r2, sp, #28
    e7ca:	2303      	movs	r3, #3
    e7cc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    e7d0:	9303      	str	r3, [sp, #12]
    e7d2:	9307      	str	r3, [sp, #28]
	return -ENOENT;
    e7d4:	f06f 0401 	mvn.w	r4, #1
	BT_WARN("Unhandled TransOpCode 0x%02x", ctl_op);
    e7d8:	f01b f9ac 	bl	29b34 <z_log_msg2_static_create.constprop.0>
	return -ENOENT;
    e7dc:	e74f      	b.n	e67e <ctl_recv+0x8a>
		BT_WARN("No matching TX context for ack");
    e7de:	4b0e      	ldr	r3, [pc, #56]	; (e818 <ctl_recv+0x224>)
    e7e0:	9308      	str	r3, [sp, #32]
    e7e2:	2302      	movs	r3, #2
    e7e4:	9303      	str	r3, [sp, #12]
    e7e6:	9307      	str	r3, [sp, #28]
    e7e8:	aa07      	add	r2, sp, #28
    e7ea:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    e7ee:	e727      	b.n	e640 <ctl_recv+0x4c>
    e7f0:	000310dd 	.word	0x000310dd
    e7f4:	0002db8c 	.word	0x0002db8c
    e7f8:	20001aa8 	.word	0x20001aa8
    e7fc:	20001d48 	.word	0x20001d48
    e800:	000310f3 	.word	0x000310f3
    e804:	0003110e 	.word	0x0003110e
    e808:	20000eb8 	.word	0x20000eb8
    e80c:	20001d78 	.word	0x20001d78
    e810:	0003111b 	.word	0x0003111b
    e814:	0003113b 	.word	0x0003113b
    e818:	00031158 	.word	0x00031158

0000e81c <send_seg>:
{
    e81c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if (seg_tx[i].nack_count) {
    e820:	4c8f      	ldr	r4, [pc, #572]	; (ea60 <send_seg+0x244>)
{
    e822:	b093      	sub	sp, #76	; 0x4c
    e824:	4605      	mov	r5, r0
    e826:	460e      	mov	r6, r1
    e828:	9305      	str	r3, [sp, #20]
			blocked |= seg_tx_blocks(&seg_tx[i], net_tx->src,
    e82a:	8901      	ldrh	r1, [r0, #8]
						 net_tx->ctx->addr);
    e82c:	6843      	ldr	r3, [r0, #4]
		if (seg_tx[i].nack_count) {
    e82e:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
{
    e832:	f8dd 9070 	ldr.w	r9, [sp, #112]	; 0x70
    e836:	4617      	mov	r7, r2
			blocked |= seg_tx_blocks(&seg_tx[i], net_tx->src,
    e838:	889a      	ldrh	r2, [r3, #4]
		if (seg_tx[i].nack_count) {
    e83a:	b178      	cbz	r0, e85c <send_seg+0x40>
		BT_ERR("No multi-segment message contexts available");
    e83c:	4b89      	ldr	r3, [pc, #548]	; (ea64 <send_seg+0x248>)
    e83e:	488a      	ldr	r0, [pc, #552]	; (ea68 <send_seg+0x24c>)
    e840:	9310      	str	r3, [sp, #64]	; 0x40
    e842:	aa0f      	add	r2, sp, #60	; 0x3c
    e844:	2302      	movs	r3, #2
    e846:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    e84a:	9309      	str	r3, [sp, #36]	; 0x24
    e84c:	930f      	str	r3, [sp, #60]	; 0x3c
    e84e:	f01b f971 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EBUSY;
    e852:	f06f 000f 	mvn.w	r0, #15
}
    e856:	b013      	add	sp, #76	; 0x4c
    e858:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (ctl_op) {
    e85c:	f1b9 0f00 	cmp.w	r9, #0
    e860:	f000 8083 	beq.w	e96a <send_seg+0x14e>
		tx->hdr = TRANS_CTL_HDR(*ctl_op, 1);
    e864:	f899 3000 	ldrb.w	r3, [r9]
    e868:	f063 037f 	orn	r3, r3, #127	; 0x7f
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e86c:	77a3      	strb	r3, [r4, #30]
	tx->dst = net_tx->ctx->addr;
    e86e:	8362      	strh	r2, [r4, #26]
	tx->seg_n = (sdu->len - 1) / seg_len(!!ctl_op);
    e870:	88b2      	ldrh	r2, [r6, #4]
	tx->src = net_tx->src;
    e872:	8321      	strh	r1, [r4, #24]
		return BT_MESH_APP_SEG_SDU_MAX;
    e874:	f1b9 0f00 	cmp.w	r9, #0
    e878:	bf14      	ite	ne
    e87a:	2108      	movne	r1, #8
    e87c:	210c      	moveq	r1, #12
	tx->seg_n = (sdu->len - 1) / seg_len(!!ctl_op);
    e87e:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    e882:	fb93 f3f1 	sdiv	r3, r3, r1
    e886:	b2db      	uxtb	r3, r3
    e888:	f884 3020 	strb.w	r3, [r4, #32]
	tx->len = sdu->len;
    e88c:	83a2      	strh	r2, [r4, #28]
	tx->seg_o = 0;
    e88e:	f04f 0000 	mov.w	r0, #0
	tx->seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_TX, bt_mesh.seq);
    e892:	4a76      	ldr	r2, [pc, #472]	; (ea6c <send_seg+0x250>)
	tx->seg_o = 0;
    e894:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
	tx->nack_count = tx->seg_n + 1;
    e898:	f103 0301 	add.w	r3, r3, #1
    e89c:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		return BT_MESH_APP_SEG_SDU_MAX;
    e8a0:	9103      	str	r1, [sp, #12]
	tx->seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_TX, bt_mesh.seq);
    e8a2:	6813      	ldr	r3, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    e8a4:	f3bf 8f5b 	dmb	ish
    e8a8:	6891      	ldr	r1, [r2, #8]
    e8aa:	f3bf 8f5b 	dmb	ish
    e8ae:	f3c1 0180 	ubfx	r1, r1, #2, #1
    e8b2:	6852      	ldr	r2, [r2, #4]
    e8b4:	f8df a1b8 	ldr.w	sl, [pc, #440]	; ea70 <send_seg+0x254>
    e8b8:	eba3 0301 	sub.w	r3, r3, r1
    e8bc:	ea4f 2113 	mov.w	r1, r3, lsr #8
    e8c0:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
    e8c4:	e9c4 3104 	strd	r3, r1, [r4, #16]
	tx->cb_data = cb_data;
    e8c8:	9b05      	ldr	r3, [sp, #20]
	tx->sub = net_tx->sub;
    e8ca:	6829      	ldr	r1, [r5, #0]
	tx->cb_data = cb_data;
    e8cc:	62e3      	str	r3, [r4, #44]	; 0x2c
	tx->attempts = SEG_RETRANSMIT_ATTEMPTS;
    e8ce:	f04f 0304 	mov.w	r3, #4
    e8d2:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	tx->cb = cb;
    e8d6:	62a7      	str	r7, [r4, #40]	; 0x28
	tx->xmit = net_tx->xmit;
    e8d8:	7aab      	ldrb	r3, [r5, #10]
    e8da:	77e3      	strb	r3, [r4, #31]
	tx->aszmic = net_tx->aszmic;
    e8dc:	7aea      	ldrb	r2, [r5, #11]
	tx->seg_pending = 0;
    e8de:	f884 0025 	strb.w	r0, [r4, #37]	; 0x25
	tx->aszmic = net_tx->aszmic;
    e8e2:	f3c2 0340 	ubfx	r3, r2, #1, #1
	tx->ctl = !!ctl_op;
    e8e6:	bf18      	it	ne
    e8e8:	2001      	movne	r0, #1
	tx->blocked = blocked;
    e8ea:	009b      	lsls	r3, r3, #2
	tx->friend_cred = net_tx->friend_cred;
    e8ec:	f002 0201 	and.w	r2, r2, #1
	tx->blocked = blocked;
    e8f0:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
    e8f4:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    e8f8:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
	tx->sub = net_tx->sub;
    e8fc:	6021      	str	r1, [r4, #0]
	tx->blocked = blocked;
    e8fe:	f022 022f 	bic.w	r2, r2, #47	; 0x2f
    e902:	4313      	orrs	r3, r2
    e904:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
	tx->ttl = net_tx->ctx->send_ttl;
    e908:	686b      	ldr	r3, [r5, #4]
    e90a:	7adb      	ldrb	r3, [r3, #11]
    e90c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	    !bt_mesh_friend_queue_has_space(tx->sub->net_idx, net_tx->src,
    e910:	f894 3020 	ldrb.w	r3, [r4, #32]
    e914:	8b88      	ldrh	r0, [r1, #28]
    e916:	8929      	ldrh	r1, [r5, #8]
    e918:	3301      	adds	r3, #1
    e91a:	b2db      	uxtb	r3, r3
    e91c:	9300      	str	r3, [sp, #0]
    e91e:	8b62      	ldrh	r2, [r4, #26]
    e920:	4b53      	ldr	r3, [pc, #332]	; (ea70 <send_seg+0x254>)
    e922:	f007 fd97 	bl	16454 <bt_mesh_friend_queue_has_space>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) &&
    e926:	b918      	cbnz	r0, e930 <send_seg+0x114>
					    tx->seg_n + 1) &&
    e928:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
    e92c:	2b00      	cmp	r3, #0
    e92e:	dc28      	bgt.n	e982 <send_seg+0x166>
    e930:	f1b9 0f00 	cmp.w	r9, #0
    e934:	bf0c      	ite	eq
    e936:	4653      	moveq	r3, sl
    e938:	2300      	movne	r3, #0
		err = k_mem_slab_alloc(&segs, &buf, BUF_TIMEOUT);
    e93a:	f8df a138 	ldr.w	sl, [pc, #312]	; ea74 <send_seg+0x258>
    e93e:	9306      	str	r3, [sp, #24]
				type = BT_MESH_FRIEND_PDU_PARTIAL;
    e940:	f04f 0800 	mov.w	r8, #0
	for (seg_o = 0U; sdu->len; seg_o++) {
    e944:	f8b6 b004 	ldrh.w	fp, [r6, #4]
    e948:	fa5f f988 	uxtb.w	r9, r8
    e94c:	f1bb 0f00 	cmp.w	fp, #0
    e950:	d12d      	bne.n	e9ae <send_seg+0x192>
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !tx->seg[0]) {
    e952:	6864      	ldr	r4, [r4, #4]
		seg_tx_reset(tx);
    e954:	4842      	ldr	r0, [pc, #264]	; (ea60 <send_seg+0x244>)
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !tx->seg[0]) {
    e956:	2c00      	cmp	r4, #0
    e958:	d17d      	bne.n	ea56 <send_seg+0x23a>
		seg_tx_reset(tx);
    e95a:	f7ff fd11 	bl	e380 <seg_tx_reset>
		send_cb_finalize(cb, cb_data);
    e95e:	4638      	mov	r0, r7
    e960:	9905      	ldr	r1, [sp, #20]
    e962:	f01a ffe3 	bl	2992c <send_cb_finalize>
		return 0;
    e966:	4620      	mov	r0, r4
    e968:	e775      	b.n	e856 <send_seg+0x3a>
	} else if (BT_MESH_IS_DEV_KEY(net_tx->ctx->app_idx)) {
    e96a:	885b      	ldrh	r3, [r3, #2]
    e96c:	3303      	adds	r3, #3
    e96e:	b29b      	uxth	r3, r3
    e970:	2b01      	cmp	r3, #1
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e972:	bf85      	ittet	hi
    e974:	7aeb      	ldrbhi	r3, [r5, #11]
    e976:	f3c3 0385 	ubfxhi	r3, r3, #2, #6
		tx->hdr = SEG_HDR(0, 0);
    e97a:	2380      	movls	r3, #128	; 0x80
		tx->hdr = SEG_HDR(1, net_tx->aid);
    e97c:	f063 033f 	ornhi	r3, r3, #63	; 0x3f
    e980:	e774      	b.n	e86c <send_seg+0x50>
		BT_ERR("Not enough space in Friend Queue for %u segments",
    e982:	f894 3020 	ldrb.w	r3, [r4, #32]
    e986:	4a3c      	ldr	r2, [pc, #240]	; (ea78 <send_seg+0x25c>)
    e988:	4837      	ldr	r0, [pc, #220]	; (ea68 <send_seg+0x24c>)
    e98a:	3301      	adds	r3, #1
    e98c:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
    e990:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    e994:	2303      	movs	r3, #3
    e996:	aa0f      	add	r2, sp, #60	; 0x3c
    e998:	9309      	str	r3, [sp, #36]	; 0x24
    e99a:	930f      	str	r3, [sp, #60]	; 0x3c
    e99c:	f01b f8ca 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		seg_tx_reset(tx);
    e9a0:	f1aa 0010 	sub.w	r0, sl, #16
			seg_tx_reset(tx);
    e9a4:	f7ff fcec 	bl	e380 <seg_tx_reset>
			return -ENOBUFS;
    e9a8:	f06f 0068 	mvn.w	r0, #104	; 0x68
    e9ac:	e753      	b.n	e856 <send_seg+0x3a>
		err = k_mem_slab_alloc(&segs, &buf, BUF_TIMEOUT);
    e9ae:	2200      	movs	r2, #0
    e9b0:	2300      	movs	r3, #0
    e9b2:	a908      	add	r1, sp, #32
    e9b4:	4650      	mov	r0, sl
    e9b6:	f015 f8db 	bl	23b70 <k_mem_slab_alloc>
		if (err) {
    e9ba:	9004      	str	r0, [sp, #16]
    e9bc:	b160      	cbz	r0, e9d8 <send_seg+0x1bc>
			BT_ERR("Out of segment buffers");
    e9be:	4b2f      	ldr	r3, [pc, #188]	; (ea7c <send_seg+0x260>)
    e9c0:	4829      	ldr	r0, [pc, #164]	; (ea68 <send_seg+0x24c>)
    e9c2:	9310      	str	r3, [sp, #64]	; 0x40
    e9c4:	aa0f      	add	r2, sp, #60	; 0x3c
    e9c6:	2302      	movs	r3, #2
    e9c8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    e9cc:	9309      	str	r3, [sp, #36]	; 0x24
    e9ce:	930f      	str	r3, [sp, #60]	; 0x3c
    e9d0:	f01b f8b0 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			seg_tx_reset(tx);
    e9d4:	4822      	ldr	r0, [pc, #136]	; (ea60 <send_seg+0x244>)
    e9d6:	e7e5      	b.n	e9a4 <send_seg+0x188>
		memcpy(buf, net_buf_simple_pull_mem(sdu, len), len);
    e9d8:	88b2      	ldrh	r2, [r6, #4]
    e9da:	9b03      	ldr	r3, [sp, #12]
    e9dc:	f8dd b020 	ldr.w	fp, [sp, #32]
    e9e0:	429a      	cmp	r2, r3
    e9e2:	bf28      	it	cs
    e9e4:	461a      	movcs	r2, r3
    e9e6:	4611      	mov	r1, r2
    e9e8:	4630      	mov	r0, r6
    e9ea:	9207      	str	r2, [sp, #28]
    e9ec:	f01d fa1e 	bl	2be2c <net_buf_simple_pull_mem>
    e9f0:	9a07      	ldr	r2, [sp, #28]
    e9f2:	4601      	mov	r1, r0
    e9f4:	4658      	mov	r0, fp
		tx->seg[seg_o] = buf;
    e9f6:	eb04 0b89 	add.w	fp, r4, r9, lsl #2
		memcpy(buf, net_buf_simple_pull_mem(sdu, len), len);
    e9fa:	f018 ff39 	bl	27870 <memcpy>
		tx->seg[seg_o] = buf;
    e9fe:	9b08      	ldr	r3, [sp, #32]
    ea00:	f8cb 3004 	str.w	r3, [fp, #4]
			NET_BUF_SIMPLE_DEFINE(seg, 16);
    ea04:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    ea08:	ab0c      	add	r3, sp, #48	; 0x30
    ea0a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
			seg_tx_buf_build(tx, seg_o, &seg);
    ea0e:	4814      	ldr	r0, [pc, #80]	; (ea60 <send_seg+0x244>)
			NET_BUF_SIMPLE_DEFINE(seg, 16);
    ea10:	9309      	str	r3, [sp, #36]	; 0x24
			seg_tx_buf_build(tx, seg_o, &seg);
    ea12:	aa09      	add	r2, sp, #36	; 0x24
    ea14:	4649      	mov	r1, r9
    ea16:	f01a ff9b 	bl	29950 <seg_tx_buf_build>
			if (seg_o == tx->seg_n) {
    ea1a:	f894 1020 	ldrb.w	r1, [r4, #32]
			if (bt_mesh_friend_enqueue_tx(
    ea1e:	aa09      	add	r2, sp, #36	; 0x24
    ea20:	1c4b      	adds	r3, r1, #1
    ea22:	9200      	str	r2, [sp, #0]
    ea24:	b2db      	uxtb	r3, r3
    ea26:	9a06      	ldr	r2, [sp, #24]
    ea28:	4589      	cmp	r9, r1
    ea2a:	bf0c      	ite	eq
    ea2c:	2102      	moveq	r1, #2
    ea2e:	2101      	movne	r1, #1
    ea30:	4628      	mov	r0, r5
    ea32:	f007 fdd3 	bl	165dc <bt_mesh_friend_enqueue_tx>
    ea36:	b158      	cbz	r0, ea50 <send_seg+0x234>
			    BT_MESH_ADDR_IS_UNICAST(net_tx->ctx->addr)) {
    ea38:	686b      	ldr	r3, [r5, #4]
				    tx->seg_n + 1, &seg) &&
    ea3a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    ea3e:	2b00      	cmp	r3, #0
    ea40:	dd06      	ble.n	ea50 <send_seg+0x234>
				k_mem_slab_free(&segs, &buf);
    ea42:	a908      	add	r1, sp, #32
    ea44:	4650      	mov	r0, sl
    ea46:	f01d ffe1 	bl	2ca0c <k_mem_slab_free>
				tx->seg[seg_o] = NULL;
    ea4a:	9b04      	ldr	r3, [sp, #16]
    ea4c:	f8cb 3004 	str.w	r3, [fp, #4]
	for (seg_o = 0U; sdu->len; seg_o++) {
    ea50:	f108 0801 	add.w	r8, r8, #1
    ea54:	e776      	b.n	e944 <send_seg+0x128>
	seg_tx_send_unacked(tx);
    ea56:	f7ff fd0f 	bl	e478 <seg_tx_send_unacked>
	return 0;
    ea5a:	4658      	mov	r0, fp
    ea5c:	e6fb      	b.n	e856 <send_seg+0x3a>
    ea5e:	bf00      	nop
    ea60:	20001d48 	.word	0x20001d48
    ea64:	00031177 	.word	0x00031177
    ea68:	0002db8c 	.word	0x0002db8c
    ea6c:	20001aa8 	.word	0x20001aa8
    ea70:	20001d58 	.word	0x20001d58
    ea74:	20000eb8 	.word	0x20000eb8
    ea78:	000311a3 	.word	0x000311a3
    ea7c:	000311d4 	.word	0x000311d4

0000ea80 <send_unseg>:
{
    ea80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ea84:	4690      	mov	r8, r2
    ea86:	b08b      	sub	sp, #44	; 0x2c
				 tx->xmit, BUF_TIMEOUT);
    ea88:	2200      	movs	r2, #0
{
    ea8a:	4699      	mov	r9, r3
				 tx->xmit, BUF_TIMEOUT);
    ea8c:	2300      	movs	r3, #0
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_LOCAL_ADV,
    ea8e:	e9cd 2300 	strd	r2, r3, [sp]
{
    ea92:	468a      	mov	sl, r1
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_LOCAL_ADV,
    ea94:	2101      	movs	r1, #1
    ea96:	7a82      	ldrb	r2, [r0, #10]
{
    ea98:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    ea9c:	4604      	mov	r4, r0
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_LOCAL_ADV,
    ea9e:	4608      	mov	r0, r1
    eaa0:	f7fd fa82 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
    eaa4:	4605      	mov	r5, r0
    eaa6:	b978      	cbnz	r0, eac8 <send_unseg+0x48>
		BT_ERR("Out of network buffers");
    eaa8:	4b3e      	ldr	r3, [pc, #248]	; (eba4 <send_unseg+0x124>)
    eaaa:	9308      	str	r3, [sp, #32]
    eaac:	483e      	ldr	r0, [pc, #248]	; (eba8 <send_unseg+0x128>)
    eaae:	2302      	movs	r3, #2
    eab0:	aa07      	add	r2, sp, #28
    eab2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    eab6:	9303      	str	r3, [sp, #12]
    eab8:	9307      	str	r3, [sp, #28]
    eaba:	f01b f83b 	bl	29b34 <z_log_msg2_static_create.constprop.0>
				return -ENOBUFS;
    eabe:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
    eac2:	b00b      	add	sp, #44	; 0x2c
    eac4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    eac8:	f100 0608 	add.w	r6, r0, #8
    eacc:	2109      	movs	r1, #9
    eace:	4630      	mov	r0, r6
    ead0:	f01d f8ce 	bl	2bc70 <net_buf_simple_reserve>
	if (ctl_op) {
    ead4:	f1bb 0f00 	cmp.w	fp, #0
    ead8:	d02e      	beq.n	eb38 <send_unseg+0xb8>
		net_buf_add_u8(buf, TRANS_CTL_HDR(*ctl_op, 0));
    eada:	f89b 1000 	ldrb.w	r1, [fp]
	return net_buf_simple_add_u8(&buf->b, val);
    eade:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    eae2:	4630      	mov	r0, r6
    eae4:	f01d f939 	bl	2bd5a <net_buf_simple_add_u8>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    eae8:	f8ba 2004 	ldrh.w	r2, [sl, #4]
    eaec:	f8da 1000 	ldr.w	r1, [sl]
    eaf0:	4630      	mov	r0, r6
    eaf2:	f01d f929 	bl	2bd48 <net_buf_simple_add_mem>
		if (!bt_mesh_friend_queue_has_space(tx->sub->net_idx,
    eaf6:	6863      	ldr	r3, [r4, #4]
    eaf8:	8921      	ldrh	r1, [r4, #8]
    eafa:	889a      	ldrh	r2, [r3, #4]
    eafc:	6823      	ldr	r3, [r4, #0]
    eafe:	2701      	movs	r7, #1
    eb00:	8b98      	ldrh	r0, [r3, #28]
    eb02:	9700      	str	r7, [sp, #0]
    eb04:	2300      	movs	r3, #0
    eb06:	f007 fca5 	bl	16454 <bt_mesh_friend_queue_has_space>
    eb0a:	2800      	cmp	r0, #0
    eb0c:	d133      	bne.n	eb76 <send_unseg+0xf6>
			if (BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    eb0e:	6863      	ldr	r3, [r4, #4]
    eb10:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    eb14:	2b00      	cmp	r3, #0
    eb16:	f04f 0302 	mov.w	r3, #2
    eb1a:	dd19      	ble.n	eb50 <send_unseg+0xd0>
				BT_ERR("Not enough space in Friend Queue");
    eb1c:	4a23      	ldr	r2, [pc, #140]	; (ebac <send_unseg+0x12c>)
    eb1e:	9208      	str	r2, [sp, #32]
    eb20:	4821      	ldr	r0, [pc, #132]	; (eba8 <send_unseg+0x128>)
    eb22:	9303      	str	r3, [sp, #12]
    eb24:	aa07      	add	r2, sp, #28
    eb26:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    eb2a:	9307      	str	r3, [sp, #28]
    eb2c:	f01b f802 	bl	29b34 <z_log_msg2_static_create.constprop.0>
				net_buf_unref(buf);
    eb30:	4628      	mov	r0, r5
    eb32:	f011 feaf 	bl	20894 <net_buf_unref>
    eb36:	e7c2      	b.n	eabe <send_unseg+0x3e>
	} else if (BT_MESH_IS_DEV_KEY(tx->ctx->app_idx)) {
    eb38:	6863      	ldr	r3, [r4, #4]
    eb3a:	885f      	ldrh	r7, [r3, #2]
    eb3c:	3703      	adds	r7, #3
    eb3e:	b2bf      	uxth	r7, r7
    eb40:	2f01      	cmp	r7, #1
		net_buf_add_u8(buf, UNSEG_HDR(1, tx->aid));
    eb42:	bf85      	ittet	hi
    eb44:	7ae1      	ldrbhi	r1, [r4, #11]
    eb46:	0889      	lsrhi	r1, r1, #2
	return net_buf_simple_add_u8(&buf->b, val);
    eb48:	4659      	movls	r1, fp
    eb4a:	f041 0140 	orrhi.w	r1, r1, #64	; 0x40
    eb4e:	e7c8      	b.n	eae2 <send_unseg+0x62>
				BT_WARN("No space in Friend Queue");
    eb50:	4a17      	ldr	r2, [pc, #92]	; (ebb0 <send_unseg+0x130>)
    eb52:	9208      	str	r2, [sp, #32]
    eb54:	4814      	ldr	r0, [pc, #80]	; (eba8 <send_unseg+0x128>)
    eb56:	9303      	str	r3, [sp, #12]
    eb58:	aa07      	add	r2, sp, #28
    eb5a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    eb5e:	9307      	str	r3, [sp, #28]
    eb60:	f01a ffe8 	bl	29b34 <z_log_msg2_static_create.constprop.0>
	return bt_mesh_net_send(tx, buf, cb, cb_data);
    eb64:	464b      	mov	r3, r9
    eb66:	4642      	mov	r2, r8
    eb68:	4629      	mov	r1, r5
    eb6a:	4620      	mov	r0, r4
}
    eb6c:	b00b      	add	sp, #44	; 0x2c
    eb6e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_mesh_net_send(tx, buf, cb, cb_data);
    eb72:	f7fe b983 	b.w	ce7c <bt_mesh_net_send>
		if (bt_mesh_friend_enqueue_tx(tx, BT_MESH_FRIEND_PDU_SINGLE,
    eb76:	2200      	movs	r2, #0
    eb78:	9600      	str	r6, [sp, #0]
    eb7a:	463b      	mov	r3, r7
    eb7c:	4611      	mov	r1, r2
    eb7e:	4620      	mov	r0, r4
    eb80:	f007 fd2c 	bl	165dc <bt_mesh_friend_enqueue_tx>
    eb84:	2800      	cmp	r0, #0
    eb86:	d0ed      	beq.n	eb64 <send_unseg+0xe4>
		    BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr)) {
    eb88:	6863      	ldr	r3, [r4, #4]
					      NULL, 1, &buf->b) &&
    eb8a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    eb8e:	2b00      	cmp	r3, #0
    eb90:	dde8      	ble.n	eb64 <send_unseg+0xe4>
			net_buf_unref(buf);
    eb92:	4628      	mov	r0, r5
    eb94:	f011 fe7e 	bl	20894 <net_buf_unref>
			send_cb_finalize(cb, cb_data);
    eb98:	4640      	mov	r0, r8
    eb9a:	4649      	mov	r1, r9
    eb9c:	f01a fec6 	bl	2992c <send_cb_finalize>
			return 0;
    eba0:	2000      	movs	r0, #0
    eba2:	e78e      	b.n	eac2 <send_unseg+0x42>
    eba4:	000311eb 	.word	0x000311eb
    eba8:	0002db8c 	.word	0x0002db8c
    ebac:	00031202 	.word	0x00031202
    ebb0:	00031223 	.word	0x00031223

0000ebb4 <bt_mesh_tx_in_progress>:
		if (seg_tx[i].nack_count) {
    ebb4:	4b03      	ldr	r3, [pc, #12]	; (ebc4 <bt_mesh_tx_in_progress+0x10>)
    ebb6:	f893 0022 	ldrb.w	r0, [r3, #34]	; 0x22
}
    ebba:	3800      	subs	r0, #0
    ebbc:	bf18      	it	ne
    ebbe:	2001      	movne	r0, #1
    ebc0:	4770      	bx	lr
    ebc2:	bf00      	nop
    ebc4:	20001d48 	.word	0x20001d48

0000ebc8 <bt_mesh_ctl_send>:
{
    ebc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    ebcc:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
    ebd0:	461d      	mov	r5, r3
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    ebd2:	f899 300b 	ldrb.w	r3, [r9, #11]
{
    ebd6:	b08f      	sub	sp, #60	; 0x3c
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    ebd8:	2bff      	cmp	r3, #255	; 0xff
{
    ebda:	e9dd 7816 	ldrd	r7, r8, [sp, #88]	; 0x58
    ebde:	4604      	mov	r4, r0
    ebe0:	4616      	mov	r6, r2
    ebe2:	f88d 100f 	strb.w	r1, [sp, #15]
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    ebe6:	d11c      	bne.n	ec22 <bt_mesh_ctl_send+0x5a>
		tx->ctx->send_ttl = bt_mesh_default_ttl_get();
    ebe8:	f7fd f866 	bl	bcb8 <bt_mesh_default_ttl_get>
    ebec:	f889 000b 	strb.w	r0, [r9, #11]
	net_buf_simple_init_with_data(&buf, data, data_len);
    ebf0:	462a      	mov	r2, r5
    ebf2:	4631      	mov	r1, r6
    ebf4:	a805      	add	r0, sp, #20
    ebf6:	f01d f835 	bl	2bc64 <net_buf_simple_init_with_data>
	if (data_len > BT_MESH_SDU_UNSEG_MAX) {
    ebfa:	6863      	ldr	r3, [r4, #4]
    ebfc:	2d0b      	cmp	r5, #11
		tx->ctx->send_rel = true;
    ebfe:	bf84      	itt	hi
    ec00:	2201      	movhi	r2, #1
    ec02:	729a      	strbhi	r2, [r3, #10]
	tx->ctx->app_idx = BT_MESH_KEY_UNUSED;
    ec04:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ec08:	805a      	strh	r2, [r3, #2]
	if (tx->ctx->addr == BT_MESH_ADDR_UNASSIGNED ||
    ec0a:	889a      	ldrh	r2, [r3, #4]
    ec0c:	b122      	cbz	r2, ec18 <bt_mesh_ctl_send+0x50>
    ec0e:	f482 4200 	eor.w	r2, r2, #32768	; 0x8000
    ec12:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    ec16:	d216      	bcs.n	ec46 <bt_mesh_ctl_send+0x7e>
		BT_ERR("Invalid destination address");
    ec18:	4b14      	ldr	r3, [pc, #80]	; (ec6c <bt_mesh_ctl_send+0xa4>)
    ec1a:	930c      	str	r3, [sp, #48]	; 0x30
    ec1c:	2302      	movs	r3, #2
    ec1e:	9304      	str	r3, [sp, #16]
    ec20:	e005      	b.n	ec2e <bt_mesh_ctl_send+0x66>
	} else if (tx->ctx->send_ttl > BT_MESH_TTL_MAX) {
    ec22:	061b      	lsls	r3, r3, #24
    ec24:	d5e4      	bpl.n	ebf0 <bt_mesh_ctl_send+0x28>
		BT_ERR("TTL too large (max 127)");
    ec26:	4b12      	ldr	r3, [pc, #72]	; (ec70 <bt_mesh_ctl_send+0xa8>)
    ec28:	930c      	str	r3, [sp, #48]	; 0x30
    ec2a:	2302      	movs	r3, #2
    ec2c:	9305      	str	r3, [sp, #20]
		BT_ERR("Invalid destination address");
    ec2e:	4811      	ldr	r0, [pc, #68]	; (ec74 <bt_mesh_ctl_send+0xac>)
    ec30:	930b      	str	r3, [sp, #44]	; 0x2c
    ec32:	aa0b      	add	r2, sp, #44	; 0x2c
    ec34:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    ec38:	f01a ff7c 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    ec3c:	f06f 0015 	mvn.w	r0, #21
}
    ec40:	b00f      	add	sp, #60	; 0x3c
    ec42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (tx->ctx->send_rel) {
    ec46:	7a9a      	ldrb	r2, [r3, #10]
    ec48:	f10d 030f 	add.w	r3, sp, #15
		return send_seg(tx, &buf, cb, cb_data, &ctl_op);
    ec4c:	9300      	str	r3, [sp, #0]
    ec4e:	4643      	mov	r3, r8
	if (tx->ctx->send_rel) {
    ec50:	b12a      	cbz	r2, ec5e <bt_mesh_ctl_send+0x96>
		return send_seg(tx, &buf, cb, cb_data, &ctl_op);
    ec52:	463a      	mov	r2, r7
    ec54:	a905      	add	r1, sp, #20
    ec56:	4620      	mov	r0, r4
    ec58:	f7ff fde0 	bl	e81c <send_seg>
    ec5c:	e7f0      	b.n	ec40 <bt_mesh_ctl_send+0x78>
		return send_unseg(tx, &buf, cb, cb_data, &ctl_op);
    ec5e:	463a      	mov	r2, r7
    ec60:	a905      	add	r1, sp, #20
    ec62:	4620      	mov	r0, r4
    ec64:	f7ff ff0c 	bl	ea80 <send_unseg>
    ec68:	e7ea      	b.n	ec40 <bt_mesh_ctl_send+0x78>
    ec6a:	bf00      	nop
    ec6c:	00031254 	.word	0x00031254
    ec70:	0003123c 	.word	0x0003123c
    ec74:	0002db8c 	.word	0x0002db8c

0000ec78 <seg_ack>:
{
    ec78:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!rx->in_use || rx->block == BLOCK_COMPLETE(rx->seg_n)) {
    ec7a:	f810 3c11 	ldrb.w	r3, [r0, #-17]
    ec7e:	065a      	lsls	r2, r3, #25
{
    ec80:	b08d      	sub	sp, #52	; 0x34
    ec82:	4604      	mov	r4, r0
	if (!rx->in_use || rx->block == BLOCK_COMPLETE(rx->seg_n)) {
    ec84:	d55f      	bpl.n	ed46 <seg_ack+0xce>
    ec86:	f003 031f 	and.w	r3, r3, #31
    ec8a:	2201      	movs	r2, #1
    ec8c:	3301      	adds	r3, #1
    ec8e:	fa02 f303 	lsl.w	r3, r2, r3
    ec92:	f850 2c0c 	ldr.w	r2, [r0, #-12]
    ec96:	3b01      	subs	r3, #1
    ec98:	429a      	cmp	r2, r3
    ec9a:	d054      	beq.n	ed46 <seg_ack+0xce>
	struct seg_rx *rx = CONTAINER_OF(dwork, struct seg_rx, ack);
    ec9c:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
    eca0:	f01e fa56 	bl	2d150 <z_impl_k_uptime_ticks>
    eca4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    eca8:	fba0 0302 	umull	r0, r3, r0, r2
    ecac:	fb02 3301 	mla	r3, r2, r1, r3
    ecb0:	0bc0      	lsrs	r0, r0, #15
    ecb2:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	if (k_uptime_get_32() - rx->last > (60 * MSEC_PER_SEC)) {
    ecb6:	f854 3c08 	ldr.w	r3, [r4, #-8]
    ecba:	1ac0      	subs	r0, r0, r3
    ecbc:	f64e 2360 	movw	r3, #60000	; 0xea60
    ecc0:	4298      	cmp	r0, r3
    ecc2:	f04f 0500 	mov.w	r5, #0
    ecc6:	d911      	bls.n	ecec <seg_ack+0x74>
		BT_WARN("Incomplete timer expired");
    ecc8:	4b20      	ldr	r3, [pc, #128]	; (ed4c <seg_ack+0xd4>)
    ecca:	930a      	str	r3, [sp, #40]	; 0x28
    eccc:	4820      	ldr	r0, [pc, #128]	; (ed50 <seg_ack+0xd8>)
    ecce:	2302      	movs	r3, #2
    ecd0:	aa09      	add	r2, sp, #36	; 0x24
    ecd2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    ecd6:	9305      	str	r3, [sp, #20]
    ecd8:	9309      	str	r3, [sp, #36]	; 0x24
    ecda:	f01a ff2b 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		seg_rx_reset(rx, false);
    ecde:	4629      	mov	r1, r5
    ece0:	4630      	mov	r0, r6
}
    ece2:	b00d      	add	sp, #52	; 0x34
    ece4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		seg_rx_reset(rx, false);
    ece8:	f7ff bae8 	b.w	e2bc <seg_rx_reset>
		 rx->block, rx->obo);
    ecec:	f814 3c11 	ldrb.w	r3, [r4, #-17]
	send_ack(rx->sub, rx->dst, rx->src, rx->ttl, &rx->seq_auth,
    ecf0:	f834 2c18 	ldrh.w	r2, [r4, #-24]
    ecf4:	f834 1c16 	ldrh.w	r1, [r4, #-22]
    ecf8:	f854 0c30 	ldr.w	r0, [r4, #-48]
    ecfc:	09db      	lsrs	r3, r3, #7
    ecfe:	9302      	str	r3, [sp, #8]
    ed00:	f854 3c0c 	ldr.w	r3, [r4, #-12]
    ed04:	9301      	str	r3, [sp, #4]
    ed06:	f1a4 0320 	sub.w	r3, r4, #32
    ed0a:	9300      	str	r3, [sp, #0]
    ed0c:	f814 3c10 	ldrb.w	r3, [r4, #-16]
    ed10:	f01a ff16 	bl	29b40 <send_ack.isra.0>
	timeout = ack_timeout(rx);
    ed14:	4630      	mov	r0, r6
    ed16:	f01a fe86 	bl	29a26 <ack_timeout>
    ed1a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
	k_work_schedule(&rx->ack, K_MSEC(timeout));
    ed1e:	ea20 76e0 	bic.w	r6, r0, r0, asr #31
    ed22:	4629      	mov	r1, r5
    ed24:	f240 30e7 	movw	r0, #999	; 0x3e7
    ed28:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ed2c:	2300      	movs	r3, #0
    ed2e:	fbc6 0107 	smlal	r0, r1, r6, r7
    ed32:	f7f1 f9d5 	bl	e0 <__aeabi_uldivmod>
    ed36:	4602      	mov	r2, r0
    ed38:	460b      	mov	r3, r1
    ed3a:	4620      	mov	r0, r4
}
    ed3c:	b00d      	add	sp, #52	; 0x34
    ed3e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_work_schedule(&rx->ack, K_MSEC(timeout));
    ed42:	f015 badb 	b.w	242fc <k_work_schedule>
}
    ed46:	b00d      	add	sp, #52	; 0x34
    ed48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ed4a:	bf00      	nop
    ed4c:	00031270 	.word	0x00031270
    ed50:	0002db8c 	.word	0x0002db8c

0000ed54 <bt_mesh_rx_reset>:
		seg_rx_reset(&seg_rx[i], true);
    ed54:	4801      	ldr	r0, [pc, #4]	; (ed5c <bt_mesh_rx_reset+0x8>)
    ed56:	2101      	movs	r1, #1
    ed58:	f7ff bab0 	b.w	e2bc <seg_rx_reset>
    ed5c:	20001ce8 	.word	0x20001ce8

0000ed60 <bt_mesh_trans_reset>:
{
    ed60:	b538      	push	{r3, r4, r5, lr}
	bt_mesh_rx_reset();
    ed62:	f7ff fff7 	bl	ed54 <bt_mesh_rx_reset>
		seg_tx_reset(&seg_tx[i]);
    ed66:	480c      	ldr	r0, [pc, #48]	; (ed98 <bt_mesh_trans_reset+0x38>)
    ed68:	f7ff fb0a 	bl	e380 <seg_tx_reset>
		if (virtual_addrs[i].ref) {
    ed6c:	490b      	ldr	r1, [pc, #44]	; (ed9c <bt_mesh_trans_reset+0x3c>)
	for (i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    ed6e:	2300      	movs	r3, #0
		if (virtual_addrs[i].ref) {
    ed70:	2414      	movs	r4, #20
			virtual_addrs[i].ref = 0U;
    ed72:	f44f 4500 	mov.w	r5, #32768	; 0x8000
		if (virtual_addrs[i].ref) {
    ed76:	fb04 f003 	mul.w	r0, r4, r3
    ed7a:	5a0a      	ldrh	r2, [r1, r0]
    ed7c:	f3c2 020e 	ubfx	r2, r2, #0, #15
    ed80:	b102      	cbz	r2, ed84 <bt_mesh_trans_reset+0x24>
			virtual_addrs[i].ref = 0U;
    ed82:	520d      	strh	r5, [r1, r0]
	for (i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    ed84:	3301      	adds	r3, #1
    ed86:	2b03      	cmp	r3, #3
    ed88:	d1f5      	bne.n	ed76 <bt_mesh_trans_reset+0x16>
	bt_mesh_rpl_clear();
    ed8a:	f01a ff3f 	bl	29c0c <bt_mesh_rpl_clear>
}
    ed8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_VA_PENDING);
    ed92:	2009      	movs	r0, #9
    ed94:	f006 b9ce 	b.w	15134 <bt_mesh_settings_store_schedule>
    ed98:	20001d48 	.word	0x20001d48
    ed9c:	200038a6 	.word	0x200038a6

0000eda0 <bt_mesh_trans_init>:
{
    eda0:	b508      	push	{r3, lr}
		k_work_init_delayable(&seg_tx[i].retransmit, seg_retransmit);
    eda2:	4905      	ldr	r1, [pc, #20]	; (edb8 <bt_mesh_trans_init+0x18>)
    eda4:	4805      	ldr	r0, [pc, #20]	; (edbc <bt_mesh_trans_init+0x1c>)
    eda6:	f01e f820 	bl	2cdea <k_work_init_delayable>
}
    edaa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		k_work_init_delayable(&seg_rx[i].ack, seg_ack);
    edae:	4904      	ldr	r1, [pc, #16]	; (edc0 <bt_mesh_trans_init+0x20>)
    edb0:	4804      	ldr	r0, [pc, #16]	; (edc4 <bt_mesh_trans_init+0x24>)
    edb2:	f01e b81a 	b.w	2cdea <k_work_init_delayable>
    edb6:	bf00      	nop
    edb8:	00029b3b 	.word	0x00029b3b
    edbc:	20001d78 	.word	0x20001d78
    edc0:	0000ec79 	.word	0x0000ec79
    edc4:	20001d18 	.word	0x20001d18

0000edc8 <bt_mesh_va_add>:
{
    edc8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    edcc:	f8df a0a0 	ldr.w	sl, [pc, #160]	; ee70 <bt_mesh_va_add+0xa8>
	for (int i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    edd0:	2700      	movs	r7, #0
{
    edd2:	4606      	mov	r6, r0
    edd4:	4688      	mov	r8, r1
	struct virtual_addr *va = NULL;
    edd6:	463d      	mov	r5, r7
    edd8:	46d3      	mov	fp, sl
		if (!virtual_addrs[i].ref) {
    edda:	2314      	movs	r3, #20
    eddc:	fb03 f207 	mul.w	r2, r3, r7
    ede0:	eb0b 0902 	add.w	r9, fp, r2
    ede4:	f83b 2002 	ldrh.w	r2, [fp, r2]
    ede8:	f3c2 020e 	ubfx	r2, r2, #0, #15
    edec:	b9c2      	cbnz	r2, ee20 <bt_mesh_va_add+0x58>
				va = &virtual_addrs[i];
    edee:	2d00      	cmp	r5, #0
    edf0:	bf08      	it	eq
    edf2:	4655      	moveq	r5, sl
	for (int i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    edf4:	3701      	adds	r7, #1
    edf6:	2f03      	cmp	r7, #3
    edf8:	f10a 0a14 	add.w	sl, sl, #20
    edfc:	d1ee      	bne.n	eddc <bt_mesh_va_add+0x14>
	if (!va) {
    edfe:	b3ad      	cbz	r5, ee6c <bt_mesh_va_add+0xa4>
	memcpy(va->uuid, uuid, ARRAY_SIZE(va->uuid));
    ee00:	2210      	movs	r2, #16
    ee02:	4631      	mov	r1, r6
    ee04:	1d28      	adds	r0, r5, #4
    ee06:	f018 fd33 	bl	27870 <memcpy>
	err = bt_mesh_virtual_addr(uuid, &va->addr);
    ee0a:	1ca9      	adds	r1, r5, #2
    ee0c:	4630      	mov	r0, r6
    ee0e:	f001 fbc5 	bl	1059c <bt_mesh_virtual_addr>
	if (err) {
    ee12:	4604      	mov	r4, r0
    ee14:	b300      	cbz	r0, ee58 <bt_mesh_va_add+0x90>
		va->addr = BT_MESH_ADDR_UNASSIGNED;
    ee16:	2300      	movs	r3, #0
    ee18:	806b      	strh	r3, [r5, #2]
		return STATUS_UNSPECIFIED;
    ee1a:	2010      	movs	r0, #16
}
    ee1c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!memcmp(uuid, virtual_addrs[i].uuid,
    ee20:	2210      	movs	r2, #16
    ee22:	f10a 0104 	add.w	r1, sl, #4
    ee26:	4630      	mov	r0, r6
    ee28:	f018 fd11 	bl	2784e <memcmp>
    ee2c:	2314      	movs	r3, #20
    ee2e:	4604      	mov	r4, r0
    ee30:	2800      	cmp	r0, #0
    ee32:	d1df      	bne.n	edf4 <bt_mesh_va_add+0x2c>
			*addr = virtual_addrs[i].addr;
    ee34:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    ee38:	f8a8 3000 	strh.w	r3, [r8]
			virtual_addrs[i].ref++;
    ee3c:	f8b9 3000 	ldrh.w	r3, [r9]
    ee40:	3301      	adds	r3, #1
    ee42:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    ee46:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    ee4a:	f8a9 3000 	strh.w	r3, [r9]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_VA_PENDING);
    ee4e:	2009      	movs	r0, #9
    ee50:	f006 f970 	bl	15134 <bt_mesh_settings_store_schedule>
	return STATUS_SUCCESS;
    ee54:	4620      	mov	r0, r4
    ee56:	e7e1      	b.n	ee1c <bt_mesh_va_add+0x54>
	va->ref = 1;
    ee58:	f248 0301 	movw	r3, #32769	; 0x8001
    ee5c:	802b      	strh	r3, [r5, #0]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_VA_PENDING);
    ee5e:	2009      	movs	r0, #9
    ee60:	f006 f968 	bl	15134 <bt_mesh_settings_store_schedule>
	*addr = va->addr;
    ee64:	886b      	ldrh	r3, [r5, #2]
    ee66:	f8a8 3000 	strh.w	r3, [r8]
    ee6a:	e7f3      	b.n	ee54 <bt_mesh_va_add+0x8c>
		return STATUS_INSUFF_RESOURCES;
    ee6c:	2005      	movs	r0, #5
    ee6e:	e7d5      	b.n	ee1c <bt_mesh_va_add+0x54>
    ee70:	200038a6 	.word	0x200038a6

0000ee74 <bt_mesh_va_del>:
{
    ee74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ee78:	4f1b      	ldr	r7, [pc, #108]	; (eee8 <bt_mesh_va_del+0x74>)
    ee7a:	4681      	mov	r9, r0
    ee7c:	460e      	mov	r6, r1
	for (int i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    ee7e:	2500      	movs	r5, #0
		if (virtual_addrs[i].ref &&
    ee80:	1f3c      	subs	r4, r7, #4
    ee82:	f04f 0a14 	mov.w	sl, #20
    ee86:	fb0a f305 	mul.w	r3, sl, r5
    ee8a:	eb04 0803 	add.w	r8, r4, r3
    ee8e:	5ae3      	ldrh	r3, [r4, r3]
    ee90:	f3c3 030e 	ubfx	r3, r3, #0, #15
    ee94:	b1db      	cbz	r3, eece <bt_mesh_va_del+0x5a>
		    !memcmp(uuid, virtual_addrs[i].uuid,
    ee96:	2210      	movs	r2, #16
    ee98:	4639      	mov	r1, r7
    ee9a:	4648      	mov	r0, r9
    ee9c:	f018 fcd7 	bl	2784e <memcmp>
		if (virtual_addrs[i].ref &&
    eea0:	b9a8      	cbnz	r0, eece <bt_mesh_va_del+0x5a>
	va->ref--;
    eea2:	f8b8 3000 	ldrh.w	r3, [r8]
    eea6:	f503 42ff 	add.w	r2, r3, #32640	; 0x7f80
    eeaa:	327f      	adds	r2, #127	; 0x7f
    eeac:	f362 030e 	bfi	r3, r2, #0, #15
    eeb0:	f8a8 3000 	strh.w	r3, [r8]
	if (addr) {
    eeb4:	b99e      	cbnz	r6, eede <bt_mesh_va_del+0x6a>
	store->changed = 1U;
    eeb6:	2314      	movs	r3, #20
    eeb8:	fb03 4405 	mla	r4, r3, r5, r4
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_VA_PENDING);
    eebc:	2009      	movs	r0, #9
	store->changed = 1U;
    eebe:	7863      	ldrb	r3, [r4, #1]
    eec0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    eec4:	7063      	strb	r3, [r4, #1]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_VA_PENDING);
    eec6:	f006 f935 	bl	15134 <bt_mesh_settings_store_schedule>
	return STATUS_SUCCESS;
    eeca:	2000      	movs	r0, #0
}
    eecc:	e005      	b.n	eeda <bt_mesh_va_del+0x66>
	for (int i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    eece:	3501      	adds	r5, #1
    eed0:	2d03      	cmp	r5, #3
    eed2:	f107 0714 	add.w	r7, r7, #20
    eed6:	d1d6      	bne.n	ee86 <bt_mesh_va_del+0x12>
		return STATUS_CANNOT_REMOVE;
    eed8:	200c      	movs	r0, #12
}
    eeda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		*addr = va->addr;
    eede:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    eee2:	8033      	strh	r3, [r6, #0]
    eee4:	e7e7      	b.n	eeb6 <bt_mesh_va_del+0x42>
    eee6:	bf00      	nop
    eee8:	200038aa 	.word	0x200038aa

0000eeec <bt_mesh_va_label_get>:
{
    eeec:	b570      	push	{r4, r5, r6, lr}
    eeee:	4912      	ldr	r1, [pc, #72]	; (ef38 <__kernel_ram_size+0x28>)
    eef0:	b088      	sub	sp, #32
	for (i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    eef2:	2300      	movs	r3, #0
    eef4:	460a      	mov	r2, r1
		if (virtual_addrs[i].ref && virtual_addrs[i].addr == addr) {
    eef6:	2614      	movs	r6, #20
    eef8:	fb06 f403 	mul.w	r4, r6, r3
    eefc:	5b15      	ldrh	r5, [r2, r4]
    eefe:	f3c5 050e 	ubfx	r5, r5, #0, #15
    ef02:	b135      	cbz	r5, ef12 <__kernel_ram_size+0x2>
    ef04:	884d      	ldrh	r5, [r1, #2]
    ef06:	4285      	cmp	r5, r0
    ef08:	d103      	bne.n	ef12 <__kernel_ram_size+0x2>
			return virtual_addrs[i].uuid;
    ef0a:	1d20      	adds	r0, r4, #4
    ef0c:	4410      	add	r0, r2
}
    ef0e:	b008      	add	sp, #32
    ef10:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 0; i < ARRAY_SIZE(virtual_addrs); i++) {
    ef12:	3301      	adds	r3, #1
    ef14:	2b03      	cmp	r3, #3
    ef16:	f101 0114 	add.w	r1, r1, #20
    ef1a:	d1ed      	bne.n	eef8 <bt_mesh_va_label_get+0xc>
	BT_WARN("No matching Label UUID for 0x%04x", addr);
    ef1c:	4a07      	ldr	r2, [pc, #28]	; (ef3c <__kernel_ram_size+0x2c>)
    ef1e:	9301      	str	r3, [sp, #4]
    ef20:	e9cd 2006 	strd	r2, r0, [sp, #24]
    ef24:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    ef28:	4805      	ldr	r0, [pc, #20]	; (ef40 <__kernel_ram_size+0x30>)
    ef2a:	9305      	str	r3, [sp, #20]
    ef2c:	aa05      	add	r2, sp, #20
    ef2e:	f01a fe01 	bl	29b34 <z_log_msg2_static_create.constprop.0>
	return NULL;
    ef32:	2000      	movs	r0, #0
    ef34:	e7eb      	b.n	ef0e <bt_mesh_va_label_get+0x22>
    ef36:	bf00      	nop
    ef38:	200038a6 	.word	0x200038a6
    ef3c:	00031289 	.word	0x00031289
    ef40:	0002db8c 	.word	0x0002db8c

0000ef44 <bt_mesh_trans_send>:
{
    ef44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ef48:	461f      	mov	r7, r3
	if (msg->len < 1) {
    ef4a:	888b      	ldrh	r3, [r1, #4]
{
    ef4c:	b08b      	sub	sp, #44	; 0x2c
    ef4e:	4604      	mov	r4, r0
    ef50:	460d      	mov	r5, r1
    ef52:	4616      	mov	r6, r2
	if (msg->len < 1) {
    ef54:	b96b      	cbnz	r3, ef72 <bt_mesh_trans_send+0x2e>
		BT_ERR("Zero-length SDU not allowed");
    ef56:	4b5b      	ldr	r3, [pc, #364]	; (f0c4 <bt_mesh_trans_send+0x180>)
		BT_ERR("Invalid destination address");
    ef58:	485b      	ldr	r0, [pc, #364]	; (f0c8 <bt_mesh_trans_send+0x184>)
    ef5a:	9308      	str	r3, [sp, #32]
    ef5c:	aa07      	add	r2, sp, #28
    ef5e:	2302      	movs	r3, #2
    ef60:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    ef64:	9303      	str	r3, [sp, #12]
    ef66:	9307      	str	r3, [sp, #28]
    ef68:	f01a fde4 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    ef6c:	f06f 0015 	mvn.w	r0, #21
    ef70:	e00f      	b.n	ef92 <bt_mesh_trans_send+0x4e>
	if (msg->len > BT_MESH_TX_SDU_MAX - BT_MESH_MIC_SHORT) {
    ef72:	2b20      	cmp	r3, #32
    ef74:	d910      	bls.n	ef98 <bt_mesh_trans_send+0x54>
		BT_ERR("Message too big: %u", msg->len);
    ef76:	4a55      	ldr	r2, [pc, #340]	; (f0cc <bt_mesh_trans_send+0x188>)
    ef78:	4853      	ldr	r0, [pc, #332]	; (f0c8 <bt_mesh_trans_send+0x184>)
    ef7a:	e9cd 2308 	strd	r2, r3, [sp, #32]
    ef7e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    ef82:	2303      	movs	r3, #3
    ef84:	aa07      	add	r2, sp, #28
    ef86:	9303      	str	r3, [sp, #12]
    ef88:	9307      	str	r3, [sp, #28]
    ef8a:	f01a fdd3 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
    ef8e:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
    ef92:	b00b      	add	sp, #44	; 0x2c
    ef94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (net_buf_simple_tailroom(msg) < BT_MESH_MIC_SHORT) {
    ef98:	4608      	mov	r0, r1
    ef9a:	f01c ff76 	bl	2be8a <net_buf_simple_tailroom>
    ef9e:	2803      	cmp	r0, #3
    efa0:	d801      	bhi.n	efa6 <bt_mesh_trans_send+0x62>
		BT_ERR("Insufficient tailroom for Transport MIC");
    efa2:	4b4b      	ldr	r3, [pc, #300]	; (f0d0 <bt_mesh_trans_send+0x18c>)
    efa4:	e7d8      	b.n	ef58 <bt_mesh_trans_send+0x14>
	if (tx->ctx->send_ttl == BT_MESH_TTL_DEFAULT) {
    efa6:	f8d4 8004 	ldr.w	r8, [r4, #4]
    efaa:	f898 300b 	ldrb.w	r3, [r8, #11]
    efae:	2bff      	cmp	r3, #255	; 0xff
    efb0:	d115      	bne.n	efde <bt_mesh_trans_send+0x9a>
		tx->ctx->send_ttl = bt_mesh_default_ttl_get();
    efb2:	f7fc fe81 	bl	bcb8 <bt_mesh_default_ttl_get>
    efb6:	f888 000b 	strb.w	r0, [r8, #11]
	if (msg->len > BT_MESH_SDU_UNSEG_MAX) {
    efba:	88ab      	ldrh	r3, [r5, #4]
		tx->ctx->send_rel = true;
    efbc:	6860      	ldr	r0, [r4, #4]
	if (msg->len > BT_MESH_SDU_UNSEG_MAX) {
    efbe:	2b0b      	cmp	r3, #11
		tx->ctx->send_rel = true;
    efc0:	bf84      	itt	hi
    efc2:	2301      	movhi	r3, #1
    efc4:	7283      	strbhi	r3, [r0, #10]
	if (tx->ctx->addr == BT_MESH_ADDR_UNASSIGNED ||
    efc6:	8883      	ldrh	r3, [r0, #4]
    efc8:	b13b      	cbz	r3, efda <bt_mesh_trans_send+0x96>
    efca:	b21b      	sxth	r3, r3
    efcc:	2b00      	cmp	r3, #0
    efce:	dc0a      	bgt.n	efe6 <bt_mesh_trans_send+0xa2>
	     BT_MESH_IS_DEV_KEY(tx->ctx->app_idx))) {
    efd0:	8843      	ldrh	r3, [r0, #2]
    efd2:	3303      	adds	r3, #3
	    (!BT_MESH_ADDR_IS_UNICAST(tx->ctx->addr) &&
    efd4:	b29b      	uxth	r3, r3
    efd6:	2b01      	cmp	r3, #1
    efd8:	d805      	bhi.n	efe6 <bt_mesh_trans_send+0xa2>
		BT_ERR("Invalid destination address");
    efda:	4b3e      	ldr	r3, [pc, #248]	; (f0d4 <bt_mesh_trans_send+0x190>)
    efdc:	e7bc      	b.n	ef58 <bt_mesh_trans_send+0x14>
	} else if (tx->ctx->send_ttl > BT_MESH_TTL_MAX) {
    efde:	061b      	lsls	r3, r3, #24
    efe0:	d5eb      	bpl.n	efba <bt_mesh_trans_send+0x76>
		BT_ERR("TTL too large (max 127)");
    efe2:	4b3d      	ldr	r3, [pc, #244]	; (f0d8 <bt_mesh_trans_send+0x194>)
    efe4:	e7b8      	b.n	ef58 <bt_mesh_trans_send+0x14>
	err = bt_mesh_keys_resolve(tx->ctx, &tx->sub, &key, &aid);
    efe6:	f10d 030b 	add.w	r3, sp, #11
    efea:	aa03      	add	r2, sp, #12
    efec:	4621      	mov	r1, r4
    efee:	f7ff f801 	bl	dff4 <bt_mesh_keys_resolve>
	if (err) {
    eff2:	2800      	cmp	r0, #0
    eff4:	d1cd      	bne.n	ef92 <bt_mesh_trans_send+0x4e>
	tx->xmit = bt_mesh_net_transmit_get();
    eff6:	f7fc fe9f 	bl	bd38 <bt_mesh_net_transmit_get>
	tx->aid = aid;
    effa:	7ae3      	ldrb	r3, [r4, #11]
    effc:	f89d 200b 	ldrb.w	r2, [sp, #11]
	tx->xmit = bt_mesh_net_transmit_get();
    f000:	72a0      	strb	r0, [r4, #10]
	tx->aid = aid;
    f002:	f362 0387 	bfi	r3, r2, #2, #6
    f006:	72e3      	strb	r3, [r4, #11]
	if (!tx->ctx->send_rel || net_buf_simple_tailroom(msg) < 8) {
    f008:	6863      	ldr	r3, [r4, #4]
    f00a:	f893 900a 	ldrb.w	r9, [r3, #10]
    f00e:	f1b9 0f00 	cmp.w	r9, #0
    f012:	d008      	beq.n	f026 <bt_mesh_trans_send+0xe2>
    f014:	4628      	mov	r0, r5
    f016:	f01c ff38 	bl	2be8a <net_buf_simple_tailroom>
    f01a:	2807      	cmp	r0, #7
    f01c:	bf94      	ite	ls
    f01e:	f04f 0900 	movls.w	r9, #0
    f022:	f04f 0901 	movhi.w	r9, #1
    f026:	7ae3      	ldrb	r3, [r4, #11]
	err = trans_encrypt(tx, key, msg);
    f028:	f8dd 800c 	ldr.w	r8, [sp, #12]
    f02c:	f369 0341 	bfi	r3, r9, #1, #1
    f030:	72e3      	strb	r3, [r4, #11]
	struct bt_mesh_app_crypto_ctx crypto = {
    f032:	2210      	movs	r2, #16
    f034:	2100      	movs	r1, #0
    f036:	a805      	add	r0, sp, #20
    f038:	f018 fc25 	bl	27886 <memset>
		.dev_key = BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f03c:	6863      	ldr	r3, [r4, #4]
	struct bt_mesh_app_crypto_ctx crypto = {
    f03e:	8922      	ldrh	r2, [r4, #8]
		.dev_key = BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f040:	8859      	ldrh	r1, [r3, #2]
	struct bt_mesh_app_crypto_ctx crypto = {
    f042:	f88d 9011 	strb.w	r9, [sp, #17]
		.dev_key = BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f046:	3103      	adds	r1, #3
    f048:	b289      	uxth	r1, r1
	struct bt_mesh_app_crypto_ctx crypto = {
    f04a:	f8ad 2012 	strh.w	r2, [sp, #18]
		.seq_num = bt_mesh.seq,
    f04e:	4a23      	ldr	r2, [pc, #140]	; (f0dc <bt_mesh_trans_send+0x198>)
	struct bt_mesh_app_crypto_ctx crypto = {
    f050:	889b      	ldrh	r3, [r3, #4]
    f052:	f8ad 3014 	strh.w	r3, [sp, #20]
		.dev_key = BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f056:	2901      	cmp	r1, #1
	struct bt_mesh_app_crypto_ctx crypto = {
    f058:	6853      	ldr	r3, [r2, #4]
    f05a:	9306      	str	r3, [sp, #24]
		.dev_key = BT_MESH_IS_DEV_KEY(tx->ctx->app_idx),
    f05c:	bf8c      	ite	hi
    f05e:	2100      	movhi	r1, #0
    f060:	2101      	movls	r1, #1
    f062:	f88d 1010 	strb.w	r1, [sp, #16]
		.iv_index = BT_MESH_NET_IVI_TX,
    f066:	6813      	ldr	r3, [r2, #0]
    f068:	f3bf 8f5b 	dmb	ish
    f06c:	6892      	ldr	r2, [r2, #8]
    f06e:	f3bf 8f5b 	dmb	ish
    f072:	f3c2 0280 	ubfx	r2, r2, #2, #1
    f076:	1a9b      	subs	r3, r3, r2
	struct bt_mesh_app_crypto_ctx crypto = {
    f078:	9307      	str	r3, [sp, #28]
	if (BT_MESH_ADDR_IS_VIRTUAL(tx->ctx->addr)) {
    f07a:	6863      	ldr	r3, [r4, #4]
    f07c:	8898      	ldrh	r0, [r3, #4]
    f07e:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
    f082:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    f086:	d202      	bcs.n	f08e <bt_mesh_trans_send+0x14a>
		crypto.ad = bt_mesh_va_label_get(tx->ctx->addr);
    f088:	f7ff ff30 	bl	eeec <bt_mesh_va_label_get>
    f08c:	9008      	str	r0, [sp, #32]
	return bt_mesh_app_encrypt(key, &crypto, msg);
    f08e:	462a      	mov	r2, r5
    f090:	a904      	add	r1, sp, #16
    f092:	4640      	mov	r0, r8
    f094:	f01a feda 	bl	29e4c <bt_mesh_app_encrypt>
	if (err) {
    f098:	2800      	cmp	r0, #0
    f09a:	f47f af7a 	bne.w	ef92 <bt_mesh_trans_send+0x4e>
	if (tx->ctx->send_rel) {
    f09e:	6863      	ldr	r3, [r4, #4]
    f0a0:	7a9b      	ldrb	r3, [r3, #10]
		err = send_seg(tx, msg, cb, cb_data, NULL);
    f0a2:	9000      	str	r0, [sp, #0]
	if (tx->ctx->send_rel) {
    f0a4:	b133      	cbz	r3, f0b4 <bt_mesh_trans_send+0x170>
		err = send_seg(tx, msg, cb, cb_data, NULL);
    f0a6:	463b      	mov	r3, r7
    f0a8:	4632      	mov	r2, r6
    f0aa:	4629      	mov	r1, r5
    f0ac:	4620      	mov	r0, r4
    f0ae:	f7ff fbb5 	bl	e81c <send_seg>
    f0b2:	e76e      	b.n	ef92 <bt_mesh_trans_send+0x4e>
		err = send_unseg(tx, msg, cb, cb_data, NULL);
    f0b4:	463b      	mov	r3, r7
    f0b6:	4632      	mov	r2, r6
    f0b8:	4629      	mov	r1, r5
    f0ba:	4620      	mov	r0, r4
    f0bc:	f7ff fce0 	bl	ea80 <send_unseg>
    f0c0:	e767      	b.n	ef92 <bt_mesh_trans_send+0x4e>
    f0c2:	bf00      	nop
    f0c4:	000312ab 	.word	0x000312ab
    f0c8:	0002db8c 	.word	0x0002db8c
    f0cc:	000312c7 	.word	0x000312c7
    f0d0:	000312db 	.word	0x000312db
    f0d4:	00031254 	.word	0x00031254
    f0d8:	0003123c 	.word	0x0003123c
    f0dc:	20001aa8 	.word	0x20001aa8

0000f0e0 <sdu_recv>:
{
    f0e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f0e4:	b08b      	sub	sp, #44	; 0x2c
    f0e6:	4604      	mov	r4, r0
    f0e8:	460d      	mov	r5, r1
    f0ea:	4691      	mov	r9, r2
	struct decrypt_ctx ctx = {
    f0ec:	2100      	movs	r1, #0
    f0ee:	2210      	movs	r2, #16
    f0f0:	a803      	add	r0, sp, #12
{
    f0f2:	4698      	mov	r8, r3
    f0f4:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	struct decrypt_ctx ctx = {
    f0f8:	f018 fbc5 	bl	27886 <memset>
			.dev_key = !AKF(&hdr),
    f0fc:	ea6f 1395 	mvn.w	r3, r5, lsr #6
    f100:	f003 0301 	and.w	r3, r3, #1
			.dst = rx->ctx.recv_dst,
    f104:	8960      	ldrh	r0, [r4, #10]
			.dev_key = !AKF(&hdr),
    f106:	f88d 3008 	strb.w	r3, [sp, #8]
	struct decrypt_ctx ctx = {
    f10a:	8923      	ldrh	r3, [r4, #8]
    f10c:	f88d 9009 	strb.w	r9, [sp, #9]
    f110:	f8ad 300a 	strh.w	r3, [sp, #10]
    f114:	f8ad 000c 	strh.w	r0, [sp, #12]
    f118:	b377      	cbz	r7, f178 <sdu_recv+0x98>
    f11a:	693a      	ldr	r2, [r7, #16]
    f11c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
			.iv_index = BT_MESH_NET_IVI_RX(rx),
    f120:	4b16      	ldr	r3, [pc, #88]	; (f17c <sdu_recv+0x9c>)
	struct decrypt_ctx ctx = {
    f122:	9204      	str	r2, [sp, #16]
			.iv_index = BT_MESH_NET_IVI_RX(rx),
    f124:	7d22      	ldrb	r2, [r4, #20]
    f126:	681b      	ldr	r3, [r3, #0]
	struct decrypt_ctx ctx = {
    f128:	9709      	str	r7, [sp, #36]	; 0x24
			.iv_index = BT_MESH_NET_IVI_RX(rx),
    f12a:	f002 0101 	and.w	r1, r2, #1
    f12e:	1a5b      	subs	r3, r3, r1
	struct decrypt_ctx ctx = {
    f130:	9305      	str	r3, [sp, #20]
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !rx->local_match) {
    f132:	0653      	lsls	r3, r2, #25
	struct decrypt_ctx ctx = {
    f134:	e9cd 8607 	strd	r8, r6, [sp, #28]
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && !rx->local_match) {
    f138:	d51a      	bpl.n	f170 <sdu_recv+0x90>
	if (BT_MESH_ADDR_IS_VIRTUAL(rx->ctx.recv_dst)) {
    f13a:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
    f13e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    f142:	d202      	bcs.n	f14a <sdu_recv+0x6a>
		ctx.crypto.ad = bt_mesh_va_label_get(rx->ctx.recv_dst);
    f144:	f7ff fed2 	bl	eeec <bt_mesh_va_label_get>
    f148:	9006      	str	r0, [sp, #24]
	rx->ctx.app_idx = bt_mesh_app_key_find(ctx.crypto.dev_key, AID(&hdr),
    f14a:	ab02      	add	r3, sp, #8
    f14c:	9300      	str	r3, [sp, #0]
    f14e:	f89d 0008 	ldrb.w	r0, [sp, #8]
    f152:	4b0b      	ldr	r3, [pc, #44]	; (f180 <sdu_recv+0xa0>)
    f154:	4622      	mov	r2, r4
    f156:	f005 013f 	and.w	r1, r5, #63	; 0x3f
    f15a:	f7fe ffad 	bl	e0b8 <bt_mesh_app_key_find>
	if (rx->ctx.app_idx == BT_MESH_KEY_UNUSED) {
    f15e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f162:	4298      	cmp	r0, r3
	rx->ctx.app_idx = bt_mesh_app_key_find(ctx.crypto.dev_key, AID(&hdr),
    f164:	80e0      	strh	r0, [r4, #6]
	if (rx->ctx.app_idx == BT_MESH_KEY_UNUSED) {
    f166:	d003      	beq.n	f170 <sdu_recv+0x90>
	bt_mesh_model_recv(rx, sdu);
    f168:	4631      	mov	r1, r6
    f16a:	4620      	mov	r0, r4
    f16c:	f001 ff48 	bl	11000 <bt_mesh_model_recv>
}
    f170:	2000      	movs	r0, #0
    f172:	b00b      	add	sp, #44	; 0x2c
    f174:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct decrypt_ctx ctx = {
    f178:	6922      	ldr	r2, [r4, #16]
    f17a:	e7d1      	b.n	f120 <sdu_recv+0x40>
    f17c:	20001aa8 	.word	0x20001aa8
    f180:	00029a63 	.word	0x00029a63

0000f184 <trans_seg>:
{
    f184:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f188:	b093      	sub	sp, #76	; 0x4c
    f18a:	af04      	add	r7, sp, #16
    f18c:	461e      	mov	r6, r3
	struct bt_mesh_rpl *rpl = NULL;
    f18e:	2300      	movs	r3, #0
    f190:	613b      	str	r3, [r7, #16]
	if (buf->len < 5) {
    f192:	8883      	ldrh	r3, [r0, #4]
	uint8_t *hdr = buf->data;
    f194:	f8d0 b000 	ldr.w	fp, [r0]
{
    f198:	60ba      	str	r2, [r7, #8]
	if (buf->len < 5) {
    f19a:	2b04      	cmp	r3, #4
{
    f19c:	4681      	mov	r9, r0
    f19e:	460c      	mov	r4, r1
	if (buf->len < 5) {
    f1a0:	d80d      	bhi.n	f1be <trans_seg+0x3a>
		BT_ERR("Too short segmented message (len %u)", buf->len);
    f1a2:	4aa3      	ldr	r2, [pc, #652]	; (f430 <trans_seg+0x2ac>)
    f1a4:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    f1a8:	2303      	movs	r3, #3
    f1aa:	617b      	str	r3, [r7, #20]
    f1ac:	62fb      	str	r3, [r7, #44]	; 0x2c
    f1ae:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f1b2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
			BT_ERR("Incorrect segment size for message type");
    f1b6:	489f      	ldr	r0, [pc, #636]	; (f434 <trans_seg+0x2b0>)
    f1b8:	f01a fcbc 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			return -EINVAL;
    f1bc:	e01a      	b.n	f1f4 <trans_seg+0x70>
	if (bt_mesh_rpl_check(net_rx, &rpl)) {
    f1be:	f107 0110 	add.w	r1, r7, #16
    f1c2:	4620      	mov	r0, r4
    f1c4:	f000 fce4 	bl	fb90 <bt_mesh_rpl_check>
    f1c8:	b1d8      	cbz	r0, f202 <trans_seg+0x7e>
		BT_WARN("Replay: src 0x%04x dst 0x%04x seq 0x%06x",
    f1ca:	8961      	ldrh	r1, [r4, #10]
    f1cc:	6923      	ldr	r3, [r4, #16]
    f1ce:	8920      	ldrh	r0, [r4, #8]
    f1d0:	4d99      	ldr	r5, [pc, #612]	; (f438 <trans_seg+0x2b4>)
    f1d2:	466c      	mov	r4, sp
    f1d4:	b088      	sub	sp, #32
    f1d6:	aa04      	add	r2, sp, #16
    f1d8:	e9c2 1306 	strd	r1, r3, [r2, #24]
    f1dc:	2305      	movs	r3, #5
    f1de:	e9c2 5004 	strd	r5, r0, [r2, #16]
    f1e2:	f842 3f0c 	str.w	r3, [r2, #12]!
    f1e6:	623b      	str	r3, [r7, #32]
    f1e8:	f44f 5122 	mov.w	r1, #10368	; 0x2880
    f1ec:	4891      	ldr	r0, [pc, #580]	; (f434 <trans_seg+0x2b0>)
    f1ee:	f01a fca1 	bl	29b34 <z_log_msg2_static_create.constprop.0>
    f1f2:	46a5      	mov	sp, r4
		return -EINVAL;
    f1f4:	f06f 0a15 	mvn.w	sl, #21
}
    f1f8:	4650      	mov	r0, sl
    f1fa:	373c      	adds	r7, #60	; 0x3c
    f1fc:	46bd      	mov	sp, r7
    f1fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	net_buf_simple_pull(buf, 1);
    f202:	2101      	movs	r1, #1
    f204:	4648      	mov	r0, r9
    f206:	f01c fe09 	bl	2be1c <net_buf_simple_pull>
	seq_zero = net_buf_simple_pull_be16(buf);
    f20a:	4648      	mov	r0, r9
    f20c:	f01c fe26 	bl	2be5c <net_buf_simple_pull_be16>
	seq_zero = (seq_zero >> 2) & TRANS_SEQ_ZERO_MASK;
    f210:	f3c0 038c 	ubfx	r3, r0, #2, #13
	seg_o = (seq_zero & 0x03) << 3;
    f214:	00c5      	lsls	r5, r0, #3
	seg_n = net_buf_simple_pull_u8(buf);
    f216:	4648      	mov	r0, r9
	seq_zero = (seq_zero >> 2) & TRANS_SEQ_ZERO_MASK;
    f218:	60fb      	str	r3, [r7, #12]
	seg_n = net_buf_simple_pull_u8(buf);
    f21a:	f01c fe0f 	bl	2be3c <net_buf_simple_pull_u8>
	seg_o = (seq_zero & 0x03) << 3;
    f21e:	f005 0518 	and.w	r5, r5, #24
	seg_o |= seg_n >> 5;
    f222:	ea45 1550 	orr.w	r5, r5, r0, lsr #5
    f226:	b2ed      	uxtb	r5, r5
	seg_n &= 0x1f;
    f228:	f000 0a1f 	and.w	sl, r0, #31
	if (seg_o > seg_n) {
    f22c:	45aa      	cmp	sl, r5
    f22e:	68fb      	ldr	r3, [r7, #12]
	seg_n = net_buf_simple_pull_u8(buf);
    f230:	4680      	mov	r8, r0
	if (seg_o > seg_n) {
    f232:	d20e      	bcs.n	f252 <trans_seg+0xce>
		BT_ERR("SegO greater than SegN (%u > %u)", seg_o, seg_n);
    f234:	4b81      	ldr	r3, [pc, #516]	; (f43c <trans_seg+0x2b8>)
    f236:	466c      	mov	r4, sp
    f238:	b088      	sub	sp, #32
    f23a:	aa04      	add	r2, sp, #16
    f23c:	e9c2 3504 	strd	r3, r5, [r2, #16]
    f240:	2304      	movs	r3, #4
    f242:	f8c2 a018 	str.w	sl, [r2, #24]
    f246:	623b      	str	r3, [r7, #32]
    f248:	f842 3f0c 	str.w	r3, [r2, #12]!
    f24c:	f44f 5101 	mov.w	r1, #8256	; 0x2040
    f250:	e7cc      	b.n	f1ec <trans_seg+0x68>
	*seq_auth = SEQ_AUTH(BT_MESH_NET_IVI_RX(net_rx),
    f252:	6922      	ldr	r2, [r4, #16]
    f254:	487a      	ldr	r0, [pc, #488]	; (f440 <trans_seg+0x2bc>)
    f256:	f894 c014 	ldrb.w	ip, [r4, #20]
    f25a:	6800      	ldr	r0, [r0, #0]
    f25c:	1ad3      	subs	r3, r2, r3
    f25e:	f00c 0101 	and.w	r1, ip, #1
    f262:	f3c3 030c 	ubfx	r3, r3, #0, #13
    f266:	eba0 0c01 	sub.w	ip, r0, r1
    f26a:	1ad3      	subs	r3, r2, r3
    f26c:	ea4f 211c 	mov.w	r1, ip, lsr #8
    f270:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
    f274:	e9c6 3100 	strd	r3, r1, [r6]
	*seg_count = seg_n + 1;
    f278:	6e3a      	ldr	r2, [r7, #96]	; 0x60
	auth_seqnum = *seq_auth & BIT_MASK(24);
    f27a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    f27e:	60fb      	str	r3, [r7, #12]
	*seg_count = seg_n + 1;
    f280:	f10a 0301 	add.w	r3, sl, #1
    f284:	7013      	strb	r3, [r2, #0]
    f286:	607b      	str	r3, [r7, #4]
		if (rx->src != net_rx->ctx.addr ||
    f288:	4b6e      	ldr	r3, [pc, #440]	; (f444 <trans_seg+0x2c0>)
    f28a:	68a2      	ldr	r2, [r4, #8]
    f28c:	6999      	ldr	r1, [r3, #24]
    f28e:	4291      	cmp	r1, r2
    f290:	d11e      	bne.n	f2d0 <trans_seg+0x14c>
		if (rx->seq_auth >= *seq_auth) {
    f292:	e9d3 0204 	ldrd	r0, r2, [r3, #16]
    f296:	e9d6 c100 	ldrd	ip, r1, [r6]
    f29a:	4560      	cmp	r0, ip
    f29c:	eb72 0e01 	sbcs.w	lr, r2, r1
    f2a0:	f080 8239 	bcs.w	f716 <trans_seg+0x592>
		if (rx->in_use) {
    f2a4:	7fda      	ldrb	r2, [r3, #31]
    f2a6:	0650      	lsls	r0, r2, #25
    f2a8:	d512      	bpl.n	f2d0 <trans_seg+0x14c>
			BT_WARN("Duplicate SDU from src 0x%04x",
    f2aa:	8922      	ldrh	r2, [r4, #8]
    f2ac:	4966      	ldr	r1, [pc, #408]	; (f448 <trans_seg+0x2c4>)
    f2ae:	4861      	ldr	r0, [pc, #388]	; (f434 <trans_seg+0x2b0>)
    f2b0:	e9c7 120c 	strd	r1, r2, [r7, #48]	; 0x30
    f2b4:	2203      	movs	r2, #3
    f2b6:	617a      	str	r2, [r7, #20]
    f2b8:	62fa      	str	r2, [r7, #44]	; 0x2c
    f2ba:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    f2be:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f2c2:	f01a fc37 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			seg_rx_reset(rx, true);
    f2c6:	4b5f      	ldr	r3, [pc, #380]	; (f444 <trans_seg+0x2c0>)
    f2c8:	2101      	movs	r1, #1
    f2ca:	4618      	mov	r0, r3
    f2cc:	f7fe fff6 	bl	e2bc <seg_rx_reset>
	if (!sdu_len_is_ok(net_rx->ctl, seg_n)) {
    f2d0:	f1ba 0f02 	cmp.w	sl, #2
    f2d4:	d959      	bls.n	f38a <trans_seg+0x206>
		BT_ERR("Too big incoming SDU length");
    f2d6:	4b5d      	ldr	r3, [pc, #372]	; (f44c <trans_seg+0x2c8>)
    f2d8:	4856      	ldr	r0, [pc, #344]	; (f434 <trans_seg+0x2b0>)
    f2da:	633b      	str	r3, [r7, #48]	; 0x30
    f2dc:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f2e0:	2302      	movs	r3, #2
    f2e2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    f2e6:	617b      	str	r3, [r7, #20]
    f2e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    f2ea:	f01a fc23 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			 net_rx->friend_match);
    f2ee:	7d20      	ldrb	r0, [r4, #20]
		send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    f2f0:	7be3      	ldrb	r3, [r4, #15]
    f2f2:	8922      	ldrh	r2, [r4, #8]
    f2f4:	8961      	ldrh	r1, [r4, #10]
    f2f6:	09c0      	lsrs	r0, r0, #7
    f2f8:	9002      	str	r0, [sp, #8]
    f2fa:	2000      	movs	r0, #0
    f2fc:	e9cd 6000 	strd	r6, r0, [sp]
    f300:	6820      	ldr	r0, [r4, #0]
    f302:	f01a fc1d 	bl	29b40 <send_ack.isra.0>
			return -EMSGSIZE;
    f306:	f06f 0a79 	mvn.w	sl, #121	; 0x79
    f30a:	e775      	b.n	f1f8 <trans_seg+0x74>
	if (rx->hdr != *hdr || rx->seg_n != seg_n) {
    f30c:	f89b 1000 	ldrb.w	r1, [fp]
    f310:	7f9a      	ldrb	r2, [r3, #30]
    f312:	4291      	cmp	r1, r2
    f314:	d104      	bne.n	f320 <trans_seg+0x19c>
    f316:	7fd9      	ldrb	r1, [r3, #31]
    f318:	f001 021f 	and.w	r2, r1, #31
    f31c:	4552      	cmp	r2, sl
    f31e:	d009      	beq.n	f334 <trans_seg+0x1b0>
		BT_ERR("Invalid segment for ongoing session");
    f320:	4b4b      	ldr	r3, [pc, #300]	; (f450 <trans_seg+0x2cc>)
			BT_ERR("Incorrect segment size for message type");
    f322:	633b      	str	r3, [r7, #48]	; 0x30
    f324:	2302      	movs	r3, #2
    f326:	617b      	str	r3, [r7, #20]
    f328:	62fb      	str	r3, [r7, #44]	; 0x2c
    f32a:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f32e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    f332:	e740      	b.n	f1b6 <trans_seg+0x32>
	if (rx->ctl != net_rx->ctl) {
    f334:	7d20      	ldrb	r0, [r4, #20]
    f336:	f3c1 1c40 	ubfx	ip, r1, #5, #1
    f33a:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    f33e:	4584      	cmp	ip, r0
    f340:	d001      	beq.n	f346 <trans_seg+0x1c2>
		BT_ERR("Inconsistent CTL in segment");
    f342:	4b44      	ldr	r3, [pc, #272]	; (f454 <trans_seg+0x2d0>)
    f344:	e7ed      	b.n	f322 <trans_seg+0x19e>
		if (rx->in_use) {
    f346:	0649      	lsls	r1, r1, #25
    f348:	f100 80d6 	bmi.w	f4f8 <trans_seg+0x374>
		if (rx->block == BLOCK_COMPLETE(rx->seg_n)) {
    f34c:	1c51      	adds	r1, r2, #1
    f34e:	2201      	movs	r2, #1
    f350:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    f352:	408a      	lsls	r2, r1
    f354:	3a01      	subs	r2, #1
    f356:	4295      	cmp	r5, r2
    f358:	d115      	bne.n	f386 <trans_seg+0x202>
				 seq_auth, rx->block, rx->obo);
    f35a:	7fd8      	ldrb	r0, [r3, #31]
			send_ack(net_rx->sub, net_rx->ctx.recv_dst,
    f35c:	f894 c00f 	ldrb.w	ip, [r4, #15]
    f360:	8922      	ldrh	r2, [r4, #8]
    f362:	8961      	ldrh	r1, [r4, #10]
    f364:	9600      	str	r6, [sp, #0]
    f366:	09c0      	lsrs	r0, r0, #7
    f368:	e9cd 5001 	strd	r5, r0, [sp, #4]
    f36c:	4663      	mov	r3, ip
    f36e:	6820      	ldr	r0, [r4, #0]
    f370:	f01a fbe6 	bl	29b40 <send_ack.isra.0>
			if (rpl) {
    f374:	6938      	ldr	r0, [r7, #16]
    f376:	b910      	cbnz	r0, f37e <trans_seg+0x1fa>
		return -EALREADY;
    f378:	f06f 0a77 	mvn.w	sl, #119	; 0x77
    f37c:	e73c      	b.n	f1f8 <trans_seg+0x74>
				bt_mesh_rpl_update(rpl, net_rx);
    f37e:	4621      	mov	r1, r4
    f380:	f01a fc29 	bl	29bd6 <bt_mesh_rpl_update>
    f384:	e7f8      	b.n	f378 <trans_seg+0x1f4>
		BT_WARN("Got segment for canceled SDU");
    f386:	4b34      	ldr	r3, [pc, #208]	; (f458 <trans_seg+0x2d4>)
    f388:	e1cb      	b.n	f722 <trans_seg+0x59e>
	    net_rx->friend_match && !net_rx->local_match &&
    f38a:	7d23      	ldrb	r3, [r4, #20]
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) &&
    f38c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    f390:	2b80      	cmp	r3, #128	; 0x80
    f392:	d12a      	bne.n	f3ea <trans_seg+0x266>
	    !bt_mesh_friend_queue_has_space(net_rx->sub->net_idx,
    f394:	6823      	ldr	r3, [r4, #0]
    f396:	8962      	ldrh	r2, [r4, #10]
    f398:	8b98      	ldrh	r0, [r3, #28]
    f39a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    f39c:	8921      	ldrh	r1, [r4, #8]
    f39e:	781b      	ldrb	r3, [r3, #0]
    f3a0:	9300      	str	r3, [sp, #0]
    f3a2:	4633      	mov	r3, r6
    f3a4:	f007 f856 	bl	16454 <bt_mesh_friend_queue_has_space>
	    net_rx->friend_match && !net_rx->local_match &&
    f3a8:	b9f8      	cbnz	r0, f3ea <trans_seg+0x266>
		BT_ERR("No space in Friend Queue for %u segments", *seg_count);
    f3aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    f3ac:	492b      	ldr	r1, [pc, #172]	; (f45c <trans_seg+0x2d8>)
    f3ae:	781a      	ldrb	r2, [r3, #0]
    f3b0:	60f8      	str	r0, [r7, #12]
    f3b2:	e9c7 120c 	strd	r1, r2, [r7, #48]	; 0x30
    f3b6:	2203      	movs	r2, #3
    f3b8:	481e      	ldr	r0, [pc, #120]	; (f434 <trans_seg+0x2b0>)
    f3ba:	617a      	str	r2, [r7, #20]
    f3bc:	62fa      	str	r2, [r7, #44]	; 0x2c
    f3be:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    f3c2:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f3c6:	f01a fbb5 	bl	29b34 <z_log_msg2_static_create.constprop.0>
			 net_rx->friend_match);
    f3ca:	7d20      	ldrb	r0, [r4, #20]
		send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    f3cc:	7be5      	ldrb	r5, [r4, #15]
    f3ce:	8922      	ldrh	r2, [r4, #8]
    f3d0:	8961      	ldrh	r1, [r4, #10]
    f3d2:	09c0      	lsrs	r0, r0, #7
    f3d4:	9002      	str	r0, [sp, #8]
    f3d6:	68fb      	ldr	r3, [r7, #12]
    f3d8:	e9cd 6300 	strd	r6, r3, [sp]
    f3dc:	462b      	mov	r3, r5
    f3de:	6820      	ldr	r0, [r4, #0]
    f3e0:	f01a fbae 	bl	29b40 <send_ack.isra.0>
		return -ENOBUFS;
    f3e4:	f06f 0a68 	mvn.w	sl, #104	; 0x68
    f3e8:	e706      	b.n	f1f8 <trans_seg+0x74>
	if (rpl && rpl->src && auth_seqnum <= rpl->seg &&
    f3ea:	693b      	ldr	r3, [r7, #16]
    f3ec:	2b00      	cmp	r3, #0
    f3ee:	d039      	beq.n	f464 <trans_seg+0x2e0>
    f3f0:	881a      	ldrh	r2, [r3, #0]
    f3f2:	f3c2 020e 	ubfx	r2, r2, #0, #15
    f3f6:	2a00      	cmp	r2, #0
    f3f8:	d034      	beq.n	f464 <trans_seg+0x2e0>
    f3fa:	685a      	ldr	r2, [r3, #4]
    f3fc:	68f9      	ldr	r1, [r7, #12]
    f3fe:	ebb1 2f12 	cmp.w	r1, r2, lsr #8
    f402:	d82f      	bhi.n	f464 <trans_seg+0x2e0>
    f404:	f993 3001 	ldrsb.w	r3, [r3, #1]
    f408:	2b00      	cmp	r3, #0
    f40a:	da02      	bge.n	f412 <trans_seg+0x28e>
	    (!rpl->old_iv || net_rx->old_iv)) {
    f40c:	7d23      	ldrb	r3, [r4, #20]
    f40e:	07da      	lsls	r2, r3, #31
    f410:	d528      	bpl.n	f464 <trans_seg+0x2e0>
		BT_WARN("Ignoring old SeqAuth 0x%06x", auth_seqnum);
    f412:	4b13      	ldr	r3, [pc, #76]	; (f460 <trans_seg+0x2dc>)
    f414:	633b      	str	r3, [r7, #48]	; 0x30
    f416:	68fb      	ldr	r3, [r7, #12]
    f418:	637b      	str	r3, [r7, #52]	; 0x34
    f41a:	4806      	ldr	r0, [pc, #24]	; (f434 <trans_seg+0x2b0>)
    f41c:	2303      	movs	r3, #3
    f41e:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f422:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    f426:	617b      	str	r3, [r7, #20]
    f428:	62fb      	str	r3, [r7, #44]	; 0x2c
    f42a:	f01a fb83 	bl	29b34 <z_log_msg2_static_create.constprop.0>
    f42e:	e7a3      	b.n	f378 <trans_seg+0x1f4>
    f430:	00031303 	.word	0x00031303
    f434:	0002db8c 	.word	0x0002db8c
    f438:	00031328 	.word	0x00031328
    f43c:	00031351 	.word	0x00031351
    f440:	20001aa8 	.word	0x20001aa8
    f444:	20001ce8 	.word	0x20001ce8
    f448:	00031372 	.word	0x00031372
    f44c:	00031402 	.word	0x00031402
    f450:	000313a5 	.word	0x000313a5
    f454:	000313c9 	.word	0x000313c9
    f458:	000313e5 	.word	0x000313e5
    f45c:	0003141e 	.word	0x0003141e
    f460:	00031447 	.word	0x00031447
 *
 * @return Number of unallocated memory blocks.
 */
static inline uint32_t k_mem_slab_num_free_get(struct k_mem_slab *slab)
{
	return slab->num_blocks - slab->num_used;
    f464:	4bb3      	ldr	r3, [pc, #716]	; (f734 <trans_seg+0x5b0>)
	if (k_mem_slab_num_free_get(&segs) < 1) {
    f466:	689a      	ldr	r2, [r3, #8]
    f468:	699b      	ldr	r3, [r3, #24]
    f46a:	429a      	cmp	r2, r3
    f46c:	d11a      	bne.n	f4a4 <trans_seg+0x320>
		BT_WARN("Not enough segments for incoming message");
    f46e:	4bb2      	ldr	r3, [pc, #712]	; (f738 <trans_seg+0x5b4>)
    f470:	633b      	str	r3, [r7, #48]	; 0x30
    f472:	48b2      	ldr	r0, [pc, #712]	; (f73c <trans_seg+0x5b8>)
    f474:	2302      	movs	r3, #2
    f476:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f47a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    f47e:	617b      	str	r3, [r7, #20]
    f480:	62fb      	str	r3, [r7, #44]	; 0x2c
    f482:	f01a fb57 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		BT_WARN("No free slots for new incoming segmented messages");
    f486:	4bae      	ldr	r3, [pc, #696]	; (f740 <trans_seg+0x5bc>)
    f488:	633b      	str	r3, [r7, #48]	; 0x30
    f48a:	48ac      	ldr	r0, [pc, #688]	; (f73c <trans_seg+0x5b8>)
    f48c:	2302      	movs	r3, #2
    f48e:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f492:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    f496:	617b      	str	r3, [r7, #20]
    f498:	62fb      	str	r3, [r7, #44]	; 0x2c
		return -ENOMEM;
    f49a:	f06f 0a0b 	mvn.w	sl, #11
		BT_WARN("No free slots for new incoming segmented messages");
    f49e:	f01a fb49 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -ENOMEM;
    f4a2:	e6a9      	b.n	f1f8 <trans_seg+0x74>
		if (rx->in_use) {
    f4a4:	49a7      	ldr	r1, [pc, #668]	; (f744 <trans_seg+0x5c0>)
    f4a6:	7fca      	ldrb	r2, [r1, #31]
    f4a8:	f012 0040 	ands.w	r0, r2, #64	; 0x40
    f4ac:	d1eb      	bne.n	f486 <trans_seg+0x302>
		rx->sub = net_rx->sub;
    f4ae:	6823      	ldr	r3, [r4, #0]
    f4b0:	600b      	str	r3, [r1, #0]
		rx->ctl = net_rx->ctl;
    f4b2:	7d23      	ldrb	r3, [r4, #20]
    f4b4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    f4b8:	015b      	lsls	r3, r3, #5
    f4ba:	f022 0260 	bic.w	r2, r2, #96	; 0x60
    f4be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f4c2:	4313      	orrs	r3, r2
    f4c4:	77cb      	strb	r3, [r1, #31]
		rx->seq_auth = *seq_auth;
    f4c6:	e9d6 2300 	ldrd	r2, r3, [r6]
    f4ca:	e9c1 2304 	strd	r2, r3, [r1, #16]
		rx->seg_n = seg_n;
    f4ce:	7fcb      	ldrb	r3, [r1, #31]
    f4d0:	f368 0304 	bfi	r3, r8, #0, #5
    f4d4:	77cb      	strb	r3, [r1, #31]
		rx->hdr = *hdr;
    f4d6:	f89b 3000 	ldrb.w	r3, [fp]
    f4da:	778b      	strb	r3, [r1, #30]
		rx->ttl = net_rx->ctx.send_ttl;
    f4dc:	7be3      	ldrb	r3, [r4, #15]
    f4de:	f881 3020 	strb.w	r3, [r1, #32]
		rx->src = net_rx->ctx.addr;
    f4e2:	8923      	ldrh	r3, [r4, #8]
    f4e4:	830b      	strh	r3, [r1, #24]
		rx->dst = net_rx->ctx.recv_dst;
    f4e6:	8963      	ldrh	r3, [r4, #10]
    f4e8:	834b      	strh	r3, [r1, #26]
	rx->obo = net_rx->friend_match;
    f4ea:	7d23      	ldrb	r3, [r4, #20]
    f4ec:	7fca      	ldrb	r2, [r1, #31]
		rx->block = 0U;
    f4ee:	6248      	str	r0, [r1, #36]	; 0x24
	rx->obo = net_rx->friend_match;
    f4f0:	09db      	lsrs	r3, r3, #7
    f4f2:	f363 12c7 	bfi	r2, r3, #7, #1
    f4f6:	77ca      	strb	r2, [r1, #31]
	if (BIT(seg_o) & rx->block) {
    f4f8:	f8df 8248 	ldr.w	r8, [pc, #584]	; f744 <trans_seg+0x5c0>
    f4fc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    f500:	40eb      	lsrs	r3, r5
    f502:	f013 0301 	ands.w	r3, r3, #1
    f506:	603b      	str	r3, [r7, #0]
    f508:	f47f af36 	bne.w	f378 <trans_seg+0x1f4>
		rx->len = seg_n * seg_len(rx->ctl) + buf->len;
    f50c:	f898 201f 	ldrb.w	r2, [r8, #31]
    f510:	f8b9 3004 	ldrh.w	r3, [r9, #4]
    f514:	f3c2 1240 	ubfx	r2, r2, #5, #1
		return BT_MESH_APP_SEG_SDU_MAX;
    f518:	2a00      	cmp	r2, #0
    f51a:	bf14      	ite	ne
    f51c:	2208      	movne	r2, #8
    f51e:	220c      	moveq	r2, #12
	if (seg_o == seg_n) {
    f520:	45aa      	cmp	sl, r5
    f522:	d124      	bne.n	f56e <trans_seg+0x3ea>
		rx->len = seg_n * seg_len(rx->ctl) + buf->len;
    f524:	fb02 330a 	mla	r3, r2, sl, r3
    f528:	b29b      	uxth	r3, r3
		if (rx->len > BT_MESH_RX_SDU_MAX) {
    f52a:	2b24      	cmp	r3, #36	; 0x24
		rx->len = seg_n * seg_len(rx->ctl) + buf->len;
    f52c:	f8a8 301c 	strh.w	r3, [r8, #28]
		if (rx->len > BT_MESH_RX_SDU_MAX) {
    f530:	d921      	bls.n	f576 <trans_seg+0x3f2>
			BT_ERR("Too large SDU len");
    f532:	4b85      	ldr	r3, [pc, #532]	; (f748 <trans_seg+0x5c4>)
    f534:	633b      	str	r3, [r7, #48]	; 0x30
    f536:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f53a:	2302      	movs	r3, #2
    f53c:	487f      	ldr	r0, [pc, #508]	; (f73c <trans_seg+0x5b8>)
    f53e:	617b      	str	r3, [r7, #20]
    f540:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    f544:	62fb      	str	r3, [r7, #44]	; 0x2c
    f546:	f01a faf5 	bl	29b34 <z_log_msg2_static_create.constprop.0>
				 seq_auth, 0, rx->obo);
    f54a:	f898 001f 	ldrb.w	r0, [r8, #31]
			send_ack(net_rx->sub, net_rx->ctx.recv_dst,
    f54e:	8961      	ldrh	r1, [r4, #10]
    f550:	7be3      	ldrb	r3, [r4, #15]
    f552:	8922      	ldrh	r2, [r4, #8]
    f554:	09c0      	lsrs	r0, r0, #7
    f556:	9002      	str	r0, [sp, #8]
    f558:	6838      	ldr	r0, [r7, #0]
    f55a:	e9cd 6000 	strd	r6, r0, [sp]
    f55e:	6820      	ldr	r0, [r4, #0]
    f560:	f01a faee 	bl	29b40 <send_ack.isra.0>
			seg_rx_reset(rx, true);
    f564:	2101      	movs	r1, #1
    f566:	4640      	mov	r0, r8
    f568:	f7fe fea8 	bl	e2bc <seg_rx_reset>
    f56c:	e6cb      	b.n	f306 <trans_seg+0x182>
		if (buf->len != seg_len(rx->ctl)) {
    f56e:	4293      	cmp	r3, r2
    f570:	d001      	beq.n	f576 <trans_seg+0x3f2>
			BT_ERR("Incorrect segment size for message type");
    f572:	4b76      	ldr	r3, [pc, #472]	; (f74c <trans_seg+0x5c8>)
    f574:	e6d5      	b.n	f322 <trans_seg+0x19e>
    f576:	f01d fdeb 	bl	2d150 <z_impl_k_uptime_ticks>
    f57a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f57e:	fba0 0302 	umull	r0, r3, r0, r2
    f582:	fb02 3301 	mla	r3, r2, r1, r3
    f586:	0bc0      	lsrs	r0, r0, #15
    f588:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return (uint32_t)k_uptime_get();
    f58c:	f8c8 0028 	str.w	r0, [r8, #40]	; 0x28
		int32_t timeout = ack_timeout(rx);
    f590:	486c      	ldr	r0, [pc, #432]	; (f744 <trans_seg+0x5c0>)
    f592:	f01a fa48 	bl	29a26 <ack_timeout>
		k_work_schedule(&rx->ack, K_MSEC(timeout));
    f596:	ea20 71e0 	bic.w	r1, r0, r0, asr #31
    f59a:	f240 30e7 	movw	r0, #999	; 0x3e7
    f59e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f5a2:	2300      	movs	r3, #0
    f5a4:	eb00 30c1 	add.w	r0, r0, r1, lsl #15
    f5a8:	1449      	asrs	r1, r1, #17
    f5aa:	f7f0 fd99 	bl	e0 <__aeabi_uldivmod>
    f5ae:	4602      	mov	r2, r0
    f5b0:	460b      	mov	r3, r1
    f5b2:	4867      	ldr	r0, [pc, #412]	; (f750 <trans_seg+0x5cc>)
    f5b4:	f014 fea2 	bl	242fc <k_work_schedule>
	err = k_mem_slab_alloc(&segs, &rx->seg[seg_o], K_NO_WAIT);
    f5b8:	1c69      	adds	r1, r5, #1
    f5ba:	b2c9      	uxtb	r1, r1
    f5bc:	485d      	ldr	r0, [pc, #372]	; (f734 <trans_seg+0x5b0>)
    f5be:	2200      	movs	r2, #0
    f5c0:	2300      	movs	r3, #0
    f5c2:	eb08 0181 	add.w	r1, r8, r1, lsl #2
    f5c6:	f014 fad3 	bl	23b70 <k_mem_slab_alloc>
	if (err) {
    f5ca:	4682      	mov	sl, r0
    f5cc:	b168      	cbz	r0, f5ea <trans_seg+0x466>
		BT_WARN("Unable allocate buffer for Seg %u", seg_o);
    f5ce:	4b61      	ldr	r3, [pc, #388]	; (f754 <trans_seg+0x5d0>)
    f5d0:	485a      	ldr	r0, [pc, #360]	; (f73c <trans_seg+0x5b8>)
    f5d2:	e9c7 350c 	strd	r3, r5, [r7, #48]	; 0x30
    f5d6:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f5da:	2303      	movs	r3, #3
    f5dc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    f5e0:	617b      	str	r3, [r7, #20]
    f5e2:	62fb      	str	r3, [r7, #44]	; 0x2c
    f5e4:	f01a faa6 	bl	29b34 <z_log_msg2_static_create.constprop.0>
    f5e8:	e6fc      	b.n	f3e4 <trans_seg+0x260>
	memcpy(rx->seg[seg_o], buf->data, buf->len);
    f5ea:	eb08 0385 	add.w	r3, r8, r5, lsl #2
    f5ee:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    f5f2:	6858      	ldr	r0, [r3, #4]
    f5f4:	f8d9 1000 	ldr.w	r1, [r9]
    f5f8:	f018 f93a 	bl	27870 <memcpy>
	rx->block |= BIT(seg_o);
    f5fc:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    f600:	2201      	movs	r2, #1
    f602:	fa02 f505 	lsl.w	r5, r2, r5
    f606:	431d      	orrs	r5, r3
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    f608:	687b      	ldr	r3, [r7, #4]
	rx->block |= BIT(seg_o);
    f60a:	f8c8 5024 	str.w	r5, [r8, #36]	; 0x24
	if (rx->block != BLOCK_COMPLETE(seg_n)) {
    f60e:	fa02 f303 	lsl.w	r3, r2, r3
    f612:	3b01      	subs	r3, #1
    f614:	429d      	cmp	r5, r3
    f616:	d002      	beq.n	f61e <trans_seg+0x49a>
		*pdu_type = BT_MESH_FRIEND_PDU_PARTIAL;
    f618:	68bb      	ldr	r3, [r7, #8]
    f61a:	701a      	strb	r2, [r3, #0]
		return 0;
    f61c:	e5ec      	b.n	f1f8 <trans_seg+0x74>
	if (rpl) {
    f61e:	6938      	ldr	r0, [r7, #16]
    f620:	b168      	cbz	r0, f63e <trans_seg+0x4ba>
		bt_mesh_rpl_update(rpl, net_rx);
    f622:	4621      	mov	r1, r4
    f624:	f01a fad7 	bl	29bd6 <bt_mesh_rpl_update>
		rpl->seg = MAX(rpl->seg, auth_seqnum);
    f628:	6939      	ldr	r1, [r7, #16]
    f62a:	68f8      	ldr	r0, [r7, #12]
    f62c:	684b      	ldr	r3, [r1, #4]
    f62e:	f3c3 2217 	ubfx	r2, r3, #8, #24
    f632:	4282      	cmp	r2, r0
    f634:	bf38      	it	cc
    f636:	4602      	movcc	r2, r0
    f638:	f362 231f 	bfi	r3, r2, #8, #24
    f63c:	604b      	str	r3, [r1, #4]
	*pdu_type = BT_MESH_FRIEND_PDU_COMPLETE;
    f63e:	68bb      	ldr	r3, [r7, #8]
	(void)k_work_cancel_delayable(&rx->ack);
    f640:	4843      	ldr	r0, [pc, #268]	; (f750 <trans_seg+0x5cc>)
	*pdu_type = BT_MESH_FRIEND_PDU_COMPLETE;
    f642:	2502      	movs	r5, #2
    f644:	701d      	strb	r5, [r3, #0]
	(void)k_work_cancel_delayable(&rx->ack);
    f646:	f01d fbde 	bl	2ce06 <k_work_cancel_delayable>
		 net_rx->ctx.send_ttl, seq_auth, rx->block, rx->obo);
    f64a:	f898 001f 	ldrb.w	r0, [r8, #31]
	send_ack(net_rx->sub, net_rx->ctx.recv_dst, net_rx->ctx.addr,
    f64e:	7be3      	ldrb	r3, [r4, #15]
    f650:	8922      	ldrh	r2, [r4, #8]
    f652:	8961      	ldrh	r1, [r4, #10]
    f654:	09c0      	lsrs	r0, r0, #7
    f656:	9002      	str	r0, [sp, #8]
    f658:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
    f65c:	e9cd 6000 	strd	r6, r0, [sp]
    f660:	6820      	ldr	r0, [r4, #0]
    f662:	f01a fa6d 	bl	29b40 <send_ack.isra.0>
	if (net_rx->ctl) {
    f666:	7d23      	ldrb	r3, [r4, #20]
    f668:	071b      	lsls	r3, r3, #28
    f66a:	d516      	bpl.n	f69a <trans_seg+0x516>
		NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_RX_CTL_MAX);
    f66c:	f107 0320 	add.w	r3, r7, #32
    f670:	f44f 12c0 	mov.w	r2, #1572864	; 0x180000
    f674:	e9c7 2306 	strd	r2, r3, [r7, #24]
		seg_rx_assemble(rx, &sdu, 0U);
    f678:	4832      	ldr	r0, [pc, #200]	; (f744 <trans_seg+0x5c0>)
		NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_RX_CTL_MAX);
    f67a:	617b      	str	r3, [r7, #20]
		seg_rx_assemble(rx, &sdu, 0U);
    f67c:	2200      	movs	r2, #0
    f67e:	f107 0114 	add.w	r1, r7, #20
    f682:	f01a f9a2 	bl	299ca <seg_rx_assemble>
		err = ctl_recv(net_rx, *hdr, &sdu, seq_auth);
    f686:	f89b 1000 	ldrb.w	r1, [fp]
    f68a:	4633      	mov	r3, r6
    f68c:	f107 0214 	add.w	r2, r7, #20
    f690:	4620      	mov	r0, r4
    f692:	f7fe ffaf 	bl	e5f4 <ctl_recv>
		err = sdu_recv(net_rx, *hdr, ASZMIC(hdr), &seg_buf, &sdu, rx);
    f696:	4682      	mov	sl, r0
    f698:	e016      	b.n	f6c8 <trans_seg+0x544>
	} else if (rx->len < 1 + APP_MIC_LEN(ASZMIC(hdr))) {
    f69a:	f89b 3001 	ldrb.w	r3, [fp, #1]
    f69e:	f8b8 201c 	ldrh.w	r2, [r8, #28]
    f6a2:	09db      	lsrs	r3, r3, #7
    f6a4:	bf14      	ite	ne
    f6a6:	2309      	movne	r3, #9
    f6a8:	2305      	moveq	r3, #5
    f6aa:	4293      	cmp	r3, r2
    f6ac:	dd11      	ble.n	f6d2 <trans_seg+0x54e>
		BT_ERR("Too short SDU + MIC");
    f6ae:	4b2a      	ldr	r3, [pc, #168]	; (f758 <trans_seg+0x5d4>)
    f6b0:	4822      	ldr	r0, [pc, #136]	; (f73c <trans_seg+0x5b8>)
    f6b2:	633b      	str	r3, [r7, #48]	; 0x30
    f6b4:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f6b8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		err = -EINVAL;
    f6bc:	f06f 0a15 	mvn.w	sl, #21
		BT_ERR("Too short SDU + MIC");
    f6c0:	617d      	str	r5, [r7, #20]
    f6c2:	62fd      	str	r5, [r7, #44]	; 0x2c
    f6c4:	f01a fa36 	bl	29b34 <z_log_msg2_static_create.constprop.0>
	seg_rx_reset(rx, false);
    f6c8:	481e      	ldr	r0, [pc, #120]	; (f744 <trans_seg+0x5c0>)
    f6ca:	2100      	movs	r1, #0
    f6cc:	f7fe fdf6 	bl	e2bc <seg_rx_reset>
	return err;
    f6d0:	e592      	b.n	f1f8 <trans_seg+0x74>
	if (!buf->__buf) {
    f6d2:	4b22      	ldr	r3, [pc, #136]	; (f75c <trans_seg+0x5d8>)
    f6d4:	6899      	ldr	r1, [r3, #8]
    f6d6:	b911      	cbnz	r1, f6de <trans_seg+0x55a>
		buf->__buf = (uint8_t *)buf + sizeof(*buf);
    f6d8:	f103 010c 	add.w	r1, r3, #12
    f6dc:	6099      	str	r1, [r3, #8]
	buf->data = buf->__buf + reserve_head;
    f6de:	6899      	ldr	r1, [r3, #8]
    f6e0:	6019      	str	r1, [r3, #0]
	buf->len = 0U;
    f6e2:	2000      	movs	r0, #0
    f6e4:	8098      	strh	r0, [r3, #4]
			&sdu, seg_buf.data, rx->len - APP_MIC_LEN(ASZMIC(hdr)));
    f6e6:	f89b 3001 	ldrb.w	r3, [fp, #1]
    f6ea:	09db      	lsrs	r3, r3, #7
    f6ec:	bf14      	ite	ne
    f6ee:	2308      	movne	r3, #8
    f6f0:	2304      	moveq	r3, #4
		net_buf_simple_init_with_data(
    f6f2:	f107 0520 	add.w	r5, r7, #32
    f6f6:	1ad2      	subs	r2, r2, r3
    f6f8:	4628      	mov	r0, r5
    f6fa:	f01c fab3 	bl	2bc64 <net_buf_simple_init_with_data>
		err = sdu_recv(net_rx, *hdr, ASZMIC(hdr), &seg_buf, &sdu, rx);
    f6fe:	f89b 2001 	ldrb.w	r2, [fp, #1]
    f702:	f89b 1000 	ldrb.w	r1, [fp]
    f706:	4b15      	ldr	r3, [pc, #84]	; (f75c <trans_seg+0x5d8>)
    f708:	e9cd 5800 	strd	r5, r8, [sp]
    f70c:	09d2      	lsrs	r2, r2, #7
    f70e:	4620      	mov	r0, r4
    f710:	f7ff fce6 	bl	f0e0 <sdu_recv>
    f714:	e7bf      	b.n	f696 <trans_seg+0x512>
		if (rx->seq_auth > *seq_auth) {
    f716:	4584      	cmp	ip, r0
    f718:	eb71 0202 	sbcs.w	r2, r1, r2
    f71c:	f4bf adf6 	bcs.w	f30c <trans_seg+0x188>
			BT_WARN("Ignoring old SeqAuth");
    f720:	4b0f      	ldr	r3, [pc, #60]	; (f760 <trans_seg+0x5dc>)
		BT_WARN("Got segment for canceled SDU");
    f722:	633b      	str	r3, [r7, #48]	; 0x30
    f724:	2302      	movs	r3, #2
    f726:	617b      	str	r3, [r7, #20]
    f728:	62fb      	str	r3, [r7, #44]	; 0x2c
    f72a:	f107 022c 	add.w	r2, r7, #44	; 0x2c
    f72e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
    f732:	e540      	b.n	f1b6 <trans_seg+0x32>
    f734:	20000eb8 	.word	0x20000eb8
    f738:	00031463 	.word	0x00031463
    f73c:	0002db8c 	.word	0x0002db8c
    f740:	0003148c 	.word	0x0003148c
    f744:	20001ce8 	.word	0x20001ce8
    f748:	000314be 	.word	0x000314be
    f74c:	000314d0 	.word	0x000314d0
    f750:	20001d18 	.word	0x20001d18
    f754:	000314f8 	.word	0x000314f8
    f758:	0003151a 	.word	0x0003151a
    f75c:	200005dc 	.word	0x200005dc
    f760:	00031390 	.word	0x00031390

0000f764 <bt_mesh_trans_recv>:
{
    f764:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f768:	b08d      	sub	sp, #52	; 0x34
	uint64_t seq_auth = TRANS_SEQ_AUTH_NVAL;
    f76a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    f76e:	af02      	add	r7, sp, #8
	uint64_t seq_auth = TRANS_SEQ_AUTH_NVAL;
    f770:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f774:	e9c7 2302 	strd	r2, r3, [r7, #8]
		rx->friend_match = bt_mesh_friend_match(rx->sub->net_idx,
    f778:	680b      	ldr	r3, [r1, #0]
{
    f77a:	4606      	mov	r6, r0
    f77c:	460d      	mov	r5, r1
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    f77e:	2400      	movs	r4, #0
		rx->friend_match = bt_mesh_friend_match(rx->sub->net_idx,
    f780:	8949      	ldrh	r1, [r1, #10]
    f782:	8b98      	ldrh	r0, [r3, #28]
	enum bt_mesh_friend_pdu_type pdu_type = BT_MESH_FRIEND_PDU_SINGLE;
    f784:	70bc      	strb	r4, [r7, #2]
	uint8_t seg_count = 0;
    f786:	70fc      	strb	r4, [r7, #3]
		rx->friend_match = bt_mesh_friend_match(rx->sub->net_idx,
    f788:	f006 fe52 	bl	16430 <bt_mesh_friend_match>
    f78c:	7d2b      	ldrb	r3, [r5, #20]
    f78e:	f360 13c7 	bfi	r3, r0, #7, #1
    f792:	752b      	strb	r3, [r5, #20]
	net_buf_simple_pull(buf, BT_MESH_NET_HDR_LEN);
    f794:	2109      	movs	r1, #9
    f796:	4630      	mov	r0, r6
    f798:	f01c fb40 	bl	2be1c <net_buf_simple_pull>
	state->offset = net_buf_simple_headroom(buf);
    f79c:	4630      	mov	r0, r6
    f79e:	f01c fb70 	bl	2be82 <net_buf_simple_headroom>
	if (SEG(buf->data)) {
    f7a2:	6833      	ldr	r3, [r6, #0]
	state->len = buf->len;
    f7a4:	f8b6 9004 	ldrh.w	r9, [r6, #4]
    f7a8:	f993 3000 	ldrsb.w	r3, [r3]
    f7ac:	42a3      	cmp	r3, r4
	state->offset = net_buf_simple_headroom(buf);
    f7ae:	4680      	mov	r8, r0
    f7b0:	da0e      	bge.n	f7d0 <bt_mesh_trans_recv+0x6c>
		if (!rx->local_match && !rx->friend_match) {
    f7b2:	7d2c      	ldrb	r4, [r5, #20]
    f7b4:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
    f7b8:	d055      	beq.n	f866 <bt_mesh_trans_recv+0x102>
		err = trans_seg(buf, rx, &pdu_type, &seq_auth, &seg_count);
    f7ba:	1cfb      	adds	r3, r7, #3
    f7bc:	9300      	str	r3, [sp, #0]
    f7be:	1cba      	adds	r2, r7, #2
    f7c0:	f107 0308 	add.w	r3, r7, #8
    f7c4:	4629      	mov	r1, r5
    f7c6:	4630      	mov	r0, r6
    f7c8:	f7ff fcdc 	bl	f184 <trans_seg>
	return sdu_recv(rx, hdr, 0, buf, &sdu, NULL);
    f7cc:	4604      	mov	r4, r0
    f7ce:	e02e      	b.n	f82e <bt_mesh_trans_recv+0xca>
		seg_count = 1;
    f7d0:	2301      	movs	r3, #1
    f7d2:	70fb      	strb	r3, [r7, #3]
	if (buf->len < 1) {
    f7d4:	f1b9 0f00 	cmp.w	r9, #0
    f7d8:	d10c      	bne.n	f7f4 <bt_mesh_trans_recv+0x90>
		BT_ERR("Too small unsegmented PDU");
    f7da:	4b34      	ldr	r3, [pc, #208]	; (f8ac <bt_mesh_trans_recv+0x148>)
		BT_ERR("Too short SDU + MIC");
    f7dc:	623b      	str	r3, [r7, #32]
    f7de:	4834      	ldr	r0, [pc, #208]	; (f8b0 <bt_mesh_trans_recv+0x14c>)
    f7e0:	2302      	movs	r3, #2
    f7e2:	f107 021c 	add.w	r2, r7, #28
    f7e6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    f7ea:	607b      	str	r3, [r7, #4]
    f7ec:	61fb      	str	r3, [r7, #28]
    f7ee:	f01a f9a1 	bl	29b34 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
    f7f2:	e01a      	b.n	f82a <bt_mesh_trans_recv+0xc6>
	if (bt_mesh_rpl_check(rx, NULL)) {
    f7f4:	4621      	mov	r1, r4
    f7f6:	4628      	mov	r0, r5
    f7f8:	f000 f9ca 	bl	fb90 <bt_mesh_rpl_check>
    f7fc:	2800      	cmp	r0, #0
    f7fe:	d037      	beq.n	f870 <bt_mesh_trans_recv+0x10c>
		BT_WARN("Replay: src 0x%04x dst 0x%04x seq 0x%06x",
    f800:	8928      	ldrh	r0, [r5, #8]
    f802:	4b2c      	ldr	r3, [pc, #176]	; (f8b4 <bt_mesh_trans_recv+0x150>)
    f804:	8969      	ldrh	r1, [r5, #10]
    f806:	466c      	mov	r4, sp
    f808:	b088      	sub	sp, #32
    f80a:	aa02      	add	r2, sp, #8
    f80c:	e9c2 3004 	strd	r3, r0, [r2, #16]
    f810:	692b      	ldr	r3, [r5, #16]
    f812:	61d3      	str	r3, [r2, #28]
    f814:	2305      	movs	r3, #5
    f816:	6191      	str	r1, [r2, #24]
    f818:	4825      	ldr	r0, [pc, #148]	; (f8b0 <bt_mesh_trans_recv+0x14c>)
    f81a:	f842 3f0c 	str.w	r3, [r2, #12]!
    f81e:	f44f 5122 	mov.w	r1, #10368	; 0x2880
    f822:	613b      	str	r3, [r7, #16]
    f824:	f01a f986 	bl	29b34 <z_log_msg2_static_create.constprop.0>
    f828:	46a5      	mov	sp, r4
		return -EINVAL;
    f82a:	f06f 0415 	mvn.w	r4, #21
	buf->data = buf->__buf + state->offset;
    f82e:	68b0      	ldr	r0, [r6, #8]
	if (IS_ENABLED(CONFIG_BT_MESH_FRIEND) && rx->friend_match && !err) {
    f830:	f995 3014 	ldrsb.w	r3, [r5, #20]
	buf->len = state->len;
    f834:	f8a6 9004 	strh.w	r9, [r6, #4]
	buf->data = buf->__buf + state->offset;
    f838:	fa10 f088 	uxtah	r0, r0, r8
    f83c:	2b00      	cmp	r3, #0
    f83e:	6030      	str	r0, [r6, #0]
    f840:	da11      	bge.n	f866 <bt_mesh_trans_recv+0x102>
    f842:	b984      	cbnz	r4, f866 <bt_mesh_trans_recv+0x102>
		if (seq_auth == TRANS_SEQ_AUTH_NVAL) {
    f844:	e9d7 0202 	ldrd	r0, r2, [r7, #8]
    f848:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    f84c:	bf08      	it	eq
    f84e:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
			bt_mesh_friend_enqueue_rx(rx, pdu_type, NULL,
    f852:	78b9      	ldrb	r1, [r7, #2]
    f854:	78fb      	ldrb	r3, [r7, #3]
    f856:	9600      	str	r6, [sp, #0]
    f858:	bf0c      	ite	eq
    f85a:	4622      	moveq	r2, r4
			bt_mesh_friend_enqueue_rx(rx, pdu_type, &seq_auth,
    f85c:	f107 0208 	addne.w	r2, r7, #8
    f860:	4628      	mov	r0, r5
    f862:	f006 fe2f 	bl	164c4 <bt_mesh_friend_enqueue_rx>
}
    f866:	4620      	mov	r0, r4
    f868:	372c      	adds	r7, #44	; 0x2c
    f86a:	46bd      	mov	sp, r7
    f86c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	hdr = net_buf_simple_pull_u8(buf);
    f870:	4630      	mov	r0, r6
    f872:	f01c fae3 	bl	2be3c <net_buf_simple_pull_u8>
	if (rx->ctl) {
    f876:	7d2a      	ldrb	r2, [r5, #20]
    f878:	f012 0208 	ands.w	r2, r2, #8
	hdr = net_buf_simple_pull_u8(buf);
    f87c:	4601      	mov	r1, r0
	if (rx->ctl) {
    f87e:	d006      	beq.n	f88e <bt_mesh_trans_recv+0x12a>
		return ctl_recv(rx, hdr, buf, seq_auth);
    f880:	f107 0308 	add.w	r3, r7, #8
    f884:	4632      	mov	r2, r6
    f886:	4628      	mov	r0, r5
    f888:	f7fe feb4 	bl	e5f4 <ctl_recv>
    f88c:	e79e      	b.n	f7cc <bt_mesh_trans_recv+0x68>
	if (buf->len < 1 + APP_MIC_LEN(0)) {
    f88e:	88b3      	ldrh	r3, [r6, #4]
    f890:	2b04      	cmp	r3, #4
    f892:	d801      	bhi.n	f898 <bt_mesh_trans_recv+0x134>
		BT_ERR("Too short SDU + MIC");
    f894:	4b08      	ldr	r3, [pc, #32]	; (f8b8 <bt_mesh_trans_recv+0x154>)
    f896:	e7a1      	b.n	f7dc <bt_mesh_trans_recv+0x78>
	buf->len -= APP_MIC_LEN(0);
    f898:	3b04      	subs	r3, #4
    f89a:	80b3      	strh	r3, [r6, #4]
	return sdu_recv(rx, hdr, 0, buf, &sdu, NULL);
    f89c:	4b07      	ldr	r3, [pc, #28]	; (f8bc <bt_mesh_trans_recv+0x158>)
    f89e:	9300      	str	r3, [sp, #0]
    f8a0:	9201      	str	r2, [sp, #4]
    f8a2:	4633      	mov	r3, r6
    f8a4:	4628      	mov	r0, r5
    f8a6:	f7ff fc1b 	bl	f0e0 <sdu_recv>
    f8aa:	e78f      	b.n	f7cc <bt_mesh_trans_recv+0x68>
    f8ac:	0003152e 	.word	0x0003152e
    f8b0:	0002db8c 	.word	0x0002db8c
    f8b4:	00031328 	.word	0x00031328
    f8b8:	0003151a 	.word	0x0003151a
    f8bc:	200005d0 	.word	0x200005d0

0000f8c0 <bt_mesh_va_pending_store>:

BT_MESH_SETTINGS_DEFINE(va, "Va", va_set);

#define IS_VA_DEL(_label)	((_label)->ref == 0)
void bt_mesh_va_pending_store(void)
{
    f8c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f8c4:	4d2a      	ldr	r5, [pc, #168]	; (f970 <bt_mesh_va_pending_store+0xb0>)
			continue;
		}

		lab->changed = 0U;

		snprintk(path, sizeof(path), "bt/mesh/Va/%x", i);
    f8c6:	f8df a0ac 	ldr.w	sl, [pc, #172]	; f974 <bt_mesh_va_pending_store+0xb4>

			err = settings_save_one(path, &va, sizeof(va));
		}

		if (err) {
			BT_ERR("Failed to %s %s value (err %d)",
    f8ca:	f8df b0ac 	ldr.w	fp, [pc, #172]	; f978 <bt_mesh_va_pending_store+0xb8>
{
    f8ce:	b091      	sub	sp, #68	; 0x44
			BT_ERR("Failed to %s %s value (err %d)",
    f8d0:	2400      	movs	r4, #0
    f8d2:	462f      	mov	r7, r5
		if (!lab->changed) {
    f8d4:	f04f 0914 	mov.w	r9, #20
    f8d8:	fb09 f804 	mul.w	r8, r9, r4
    f8dc:	eb07 0308 	add.w	r3, r7, r8
    f8e0:	f993 2001 	ldrsb.w	r2, [r3, #1]
    f8e4:	2a00      	cmp	r2, #0
    f8e6:	da28      	bge.n	f93a <bt_mesh_va_pending_store+0x7a>
		lab->changed = 0U;
    f8e8:	785a      	ldrb	r2, [r3, #1]
		snprintk(path, sizeof(path), "bt/mesh/Va/%x", i);
    f8ea:	ae06      	add	r6, sp, #24
		lab->changed = 0U;
    f8ec:	f36f 12c7 	bfc	r2, #7, #1
    f8f0:	705a      	strb	r2, [r3, #1]
		snprintk(path, sizeof(path), "bt/mesh/Va/%x", i);
    f8f2:	2112      	movs	r1, #18
    f8f4:	4623      	mov	r3, r4
    f8f6:	4652      	mov	r2, sl
    f8f8:	4630      	mov	r0, r6
    f8fa:	f015 fc6c 	bl	251d6 <snprintk>
		if (IS_VA_DEL(lab)) {
    f8fe:	f837 3008 	ldrh.w	r3, [r7, r8]
    f902:	f3c3 020e 	ubfx	r2, r3, #0, #15
    f906:	bb02      	cbnz	r2, f94a <bt_mesh_va_pending_store+0x8a>
			err = settings_delete(path);
    f908:	4630      	mov	r0, r6
    f90a:	f016 fc74 	bl	261f6 <settings_delete>
		if (err) {
    f90e:	b1a0      	cbz	r0, f93a <bt_mesh_va_pending_store+0x7a>
			BT_ERR("Failed to %s %s value (err %d)",
    f910:	2314      	movs	r3, #20
    f912:	4363      	muls	r3, r4
    f914:	4a19      	ldr	r2, [pc, #100]	; (f97c <bt_mesh_va_pending_store+0xbc>)
    f916:	5afb      	ldrh	r3, [r7, r3]
    f918:	4919      	ldr	r1, [pc, #100]	; (f980 <bt_mesh_va_pending_store+0xc0>)
    f91a:	f3c3 030e 	ubfx	r3, r3, #0, #15
    f91e:	2b00      	cmp	r3, #0
    f920:	bf18      	it	ne
    f922:	465a      	movne	r2, fp
    f924:	4b17      	ldr	r3, [pc, #92]	; (f984 <bt_mesh_va_pending_store+0xc4>)
    f926:	9301      	str	r3, [sp, #4]
    f928:	2300      	movs	r3, #0
    f92a:	e9cd 6003 	strd	r6, r0, [sp, #12]
    f92e:	9202      	str	r2, [sp, #8]
    f930:	9300      	str	r3, [sp, #0]
    f932:	2201      	movs	r2, #1
    f934:	4618      	mov	r0, r3
    f936:	f7fe fd11 	bl	e35c <z_log_msg2_runtime_create.constprop.0>
	if (index >= ARRAY_SIZE(virtual_addrs)) {
    f93a:	3401      	adds	r4, #1
    f93c:	2c03      	cmp	r4, #3
    f93e:	f105 0514 	add.w	r5, r5, #20
    f942:	d1c7      	bne.n	f8d4 <bt_mesh_va_pending_store+0x14>
			BT_DBG("%s %s value",
			       IS_VA_DEL(lab) ? "Deleted" : "Stored",
			       log_strdup(path));
		}
	}
}
    f944:	b011      	add	sp, #68	; 0x44
    f946:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			va.ref = lab->ref;
    f94a:	f3c3 030e 	ubfx	r3, r3, #0, #15
    f94e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
			memcpy(va.uuid, lab->uuid, 16);
    f952:	1d29      	adds	r1, r5, #4
			va.addr = lab->addr;
    f954:	886b      	ldrh	r3, [r5, #2]
    f956:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
			memcpy(va.uuid, lab->uuid, 16);
    f95a:	2210      	movs	r2, #16
    f95c:	a80c      	add	r0, sp, #48	; 0x30
    f95e:	f017 ff87 	bl	27870 <memcpy>
			err = settings_save_one(path, &va, sizeof(va));
    f962:	464a      	mov	r2, r9
    f964:	a90b      	add	r1, sp, #44	; 0x2c
    f966:	4630      	mov	r0, r6
    f968:	f7f4 f94a 	bl	3c00 <settings_save_one>
    f96c:	e7cf      	b.n	f90e <bt_mesh_va_pending_store+0x4e>
    f96e:	bf00      	nop
    f970:	200038a6 	.word	0x200038a6
    f974:	00031555 	.word	0x00031555
    f978:	0003154f 	.word	0x0003154f
    f97c:	00031548 	.word	0x00031548
    f980:	0002db8c 	.word	0x0002db8c
    f984:	0003109f 	.word	0x0003109f

0000f988 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
    f988:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
    f98a:	ab0a      	add	r3, sp, #40	; 0x28
    f98c:	9305      	str	r3, [sp, #20]
    f98e:	9302      	str	r3, [sp, #8]
    f990:	4b05      	ldr	r3, [pc, #20]	; (f9a8 <z_log_msg2_runtime_create.constprop.0+0x20>)
    f992:	9301      	str	r3, [sp, #4]
    f994:	2300      	movs	r3, #0
    f996:	9300      	str	r3, [sp, #0]
    f998:	2201      	movs	r2, #1
    f99a:	4618      	mov	r0, r3
    f99c:	f7f3 fc84 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
    f9a0:	b007      	add	sp, #28
    f9a2:	f85d fb04 	ldr.w	pc, [sp], #4
    f9a6:	bf00      	nop
    f9a8:	00031580 	.word	0x00031580

0000f9ac <schedule_rpl_store.constprop.0>:
static struct bt_mesh_rpl replay_list[CONFIG_BT_MESH_CRPL];
static ATOMIC_DEFINE(store, CONFIG_BT_MESH_CRPL);

static inline int rpl_idx(const struct bt_mesh_rpl *rpl)
{
	return rpl - &replay_list[0];
    f9ac:	4b0c      	ldr	r3, [pc, #48]	; (f9e0 <schedule_rpl_store.constprop.0+0x34>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    f9ae:	f3bf 8f5b 	dmb	ish
    f9b2:	1ac0      	subs	r0, r0, r3
    f9b4:	10c0      	asrs	r0, r0, #3
    f9b6:	4b0b      	ldr	r3, [pc, #44]	; (f9e4 <schedule_rpl_store.constprop.0+0x38>)
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    f9b8:	0941      	lsrs	r1, r0, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
    f9ba:	2201      	movs	r2, #1
    f9bc:	f000 001f 	and.w	r0, r0, #31
    f9c0:	fa02 f000 	lsl.w	r0, r2, r0
    f9c4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    f9c8:	e853 2f00 	ldrex	r2, [r3]
    f9cc:	4302      	orrs	r2, r0
    f9ce:	e843 2100 	strex	r1, r2, [r3]
    f9d2:	2900      	cmp	r1, #0
    f9d4:	d1f8      	bne.n	f9c8 <schedule_rpl_store.constprop.0+0x1c>
    f9d6:	f3bf 8f5b 	dmb	ish
	if (force
#ifdef CONFIG_BT_MESH_RPL_STORE_TIMEOUT
	    || CONFIG_BT_MESH_RPL_STORE_TIMEOUT >= 0
#endif
	    ) {
		bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_RPL_PENDING);
    f9da:	2000      	movs	r0, #0
    f9dc:	f005 bbaa 	b.w	15134 <bt_mesh_settings_store_schedule>
    f9e0:	20001da8 	.word	0x20001da8
    f9e4:	2000275c 	.word	0x2000275c

0000f9e8 <clear_rpl>:
{
    f9e8:	b510      	push	{r4, lr}
	if (!rpl->src) {
    f9ea:	8803      	ldrh	r3, [r0, #0]
    f9ec:	f3c3 020e 	ubfx	r2, r3, #0, #15
{
    f9f0:	b08c      	sub	sp, #48	; 0x30
    f9f2:	4604      	mov	r4, r0
	if (!rpl->src) {
    f9f4:	b392      	cbz	r2, fa5c <clear_rpl+0x74>
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", rpl->src);
    f9f6:	4613      	mov	r3, r2
    f9f8:	2112      	movs	r1, #18
    f9fa:	4a19      	ldr	r2, [pc, #100]	; (fa60 <clear_rpl+0x78>)
    f9fc:	a801      	add	r0, sp, #4
    f9fe:	f015 fbea 	bl	251d6 <snprintk>
	err = settings_delete(path);
    fa02:	a801      	add	r0, sp, #4
    fa04:	f016 fbf7 	bl	261f6 <settings_delete>
	if (err) {
    fa08:	b158      	cbz	r0, fa22 <clear_rpl+0x3a>
		BT_ERR("Failed to clear RPL");
    fa0a:	4b16      	ldr	r3, [pc, #88]	; (fa64 <clear_rpl+0x7c>)
    fa0c:	930a      	str	r3, [sp, #40]	; 0x28
    fa0e:	2302      	movs	r3, #2
    fa10:	9300      	str	r3, [sp, #0]
    fa12:	9309      	str	r3, [sp, #36]	; 0x24
	z_impl_z_log_msg2_static_create(source, desc, package, data);
    fa14:	4814      	ldr	r0, [pc, #80]	; (fa68 <clear_rpl+0x80>)
    fa16:	2300      	movs	r3, #0
    fa18:	aa09      	add	r2, sp, #36	; 0x24
    fa1a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    fa1e:	f016 f95b 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	(void)memset(rpl, 0, sizeof(*rpl));
    fa22:	2208      	movs	r2, #8
    fa24:	4620      	mov	r0, r4
    fa26:	2100      	movs	r1, #0
    fa28:	f017 ff2d 	bl	27886 <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    fa2c:	f3bf 8f5b 	dmb	ish
	return rpl - &replay_list[0];
    fa30:	480e      	ldr	r0, [pc, #56]	; (fa6c <clear_rpl+0x84>)
    fa32:	1a24      	subs	r4, r4, r0
    fa34:	10e4      	asrs	r4, r4, #3
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    fa36:	0962      	lsrs	r2, r4, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
    fa38:	2301      	movs	r3, #1
    fa3a:	f004 041f 	and.w	r4, r4, #31
    fa3e:	fa03 f404 	lsl.w	r4, r3, r4
    fa42:	4b0b      	ldr	r3, [pc, #44]	; (fa70 <clear_rpl+0x88>)
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    fa44:	43e4      	mvns	r4, r4
    fa46:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    fa4a:	e853 2f00 	ldrex	r2, [r3]
    fa4e:	4022      	ands	r2, r4
    fa50:	e843 2100 	strex	r1, r2, [r3]
    fa54:	2900      	cmp	r1, #0
    fa56:	d1f8      	bne.n	fa4a <clear_rpl+0x62>
    fa58:	f3bf 8f5b 	dmb	ish
}
    fa5c:	b00c      	add	sp, #48	; 0x30
    fa5e:	bd10      	pop	{r4, pc}
    fa60:	0003159d 	.word	0x0003159d
    fa64:	000315ac 	.word	0x000315ac
    fa68:	0002db7c 	.word	0x0002db7c
    fa6c:	20001da8 	.word	0x20001da8
    fa70:	2000275c 	.word	0x2000275c

0000fa74 <rpl_set>:
	}
}

static int rpl_set(const char *name, size_t len_rd,
		   settings_read_cb read_cb, void *cb_arg)
{
    fa74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fa78:	4698      	mov	r8, r3
    fa7a:	b088      	sub	sp, #32
    fa7c:	460c      	mov	r4, r1
    fa7e:	4617      	mov	r7, r2
	struct bt_mesh_rpl *entry;
	struct rpl_val rpl;
	int err;
	uint16_t src;

	if (!name) {
    fa80:	4603      	mov	r3, r0
    fa82:	b980      	cbnz	r0, faa6 <rpl_set+0x32>
		BT_ERR("Insufficient number of arguments");
    fa84:	4a3c      	ldr	r2, [pc, #240]	; (fb78 <rpl_set+0x104>)
    fa86:	9206      	str	r2, [sp, #24]
    fa88:	2202      	movs	r2, #2
    fa8a:	9201      	str	r2, [sp, #4]
    fa8c:	9205      	str	r2, [sp, #20]
    fa8e:	483b      	ldr	r0, [pc, #236]	; (fb7c <rpl_set+0x108>)
    fa90:	aa05      	add	r2, sp, #20
    fa92:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -ENOENT;
    fa96:	f06f 0401 	mvn.w	r4, #1
    fa9a:	f016 f91d 	bl	25cd8 <z_impl_z_log_msg2_static_create>

	BT_DBG("RPL entry for 0x%04x: Seq 0x%06x old_iv %u", entry->src,
	       entry->seq, entry->old_iv);

	return 0;
}
    fa9e:	4620      	mov	r0, r4
    faa0:	b008      	add	sp, #32
    faa2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	src = strtol(name, NULL, 16);
    faa6:	2210      	movs	r2, #16
    faa8:	2100      	movs	r1, #0
    faaa:	f017 fdac 	bl	27606 <strtol>
		if (replay_list[i].src == src) {
    faae:	4d34      	ldr	r5, [pc, #208]	; (fb80 <rpl_set+0x10c>)
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fab0:	2300      	movs	r3, #0
    fab2:	b282      	uxth	r2, r0
		if (replay_list[i].src == src) {
    fab4:	f835 1033 	ldrh.w	r1, [r5, r3, lsl #3]
    fab8:	f3c1 010e 	ubfx	r1, r1, #0, #15
    fabc:	428a      	cmp	r2, r1
    fabe:	d115      	bne.n	faec <rpl_set+0x78>
			return &replay_list[i];
    fac0:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
	if (len_rd == 0) {
    fac4:	b31c      	cbz	r4, fb0e <rpl_set+0x9a>
	err = bt_mesh_settings_set(read_cb, cb_arg, &rpl, sizeof(rpl));
    fac6:	2304      	movs	r3, #4
    fac8:	466a      	mov	r2, sp
    faca:	4641      	mov	r1, r8
    facc:	4638      	mov	r0, r7
    face:	f005 faf3 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
    fad2:	4604      	mov	r4, r0
    fad4:	2800      	cmp	r0, #0
    fad6:	d041      	beq.n	fb5c <rpl_set+0xe8>
		BT_ERR("Failed to set `net`");
    fad8:	4b2a      	ldr	r3, [pc, #168]	; (fb84 <rpl_set+0x110>)
    fada:	9306      	str	r3, [sp, #24]
    fadc:	2302      	movs	r3, #2
    fade:	9301      	str	r3, [sp, #4]
    fae0:	9305      	str	r3, [sp, #20]
    fae2:	2300      	movs	r3, #0
    fae4:	aa05      	add	r2, sp, #20
    fae6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    faea:	e020      	b.n	fb2e <rpl_set+0xba>
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    faec:	3301      	adds	r3, #1
    faee:	2b0a      	cmp	r3, #10
    faf0:	d1e0      	bne.n	fab4 <rpl_set+0x40>
	if (len_rd == 0) {
    faf2:	b194      	cbz	r4, fb1a <rpl_set+0xa6>
    faf4:	2400      	movs	r4, #0
		if (!replay_list[i].src) {
    faf6:	f835 6034 	ldrh.w	r6, [r5, r4, lsl #3]
    fafa:	f3c6 030e 	ubfx	r3, r6, #0, #15
    fafe:	b9d3      	cbnz	r3, fb36 <rpl_set+0xc2>
			replay_list[i].src = src;
    fb00:	f360 060e 	bfi	r6, r0, #0, #15
    fb04:	f825 6034 	strh.w	r6, [r5, r4, lsl #3]
			return &replay_list[i];
    fb08:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
		if (!entry) {
    fb0c:	e7db      	b.n	fac6 <rpl_set+0x52>
			(void)memset(entry, 0, sizeof(*entry));
    fb0e:	2208      	movs	r2, #8
    fb10:	4621      	mov	r1, r4
    fb12:	4628      	mov	r0, r5
    fb14:	f017 feb7 	bl	27886 <memset>
    fb18:	e7c1      	b.n	fa9e <rpl_set+0x2a>
			BT_WARN("Unable to find RPL entry for 0x%04x", src);
    fb1a:	4b1b      	ldr	r3, [pc, #108]	; (fb88 <rpl_set+0x114>)
    fb1c:	e9cd 3206 	strd	r3, r2, [sp, #24]
    fb20:	2303      	movs	r3, #3
    fb22:	9301      	str	r3, [sp, #4]
    fb24:	9305      	str	r3, [sp, #20]
    fb26:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
    fb2a:	4623      	mov	r3, r4
    fb2c:	aa05      	add	r2, sp, #20
    fb2e:	4813      	ldr	r0, [pc, #76]	; (fb7c <rpl_set+0x108>)
    fb30:	f016 f8d2 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return err;
    fb34:	e7b3      	b.n	fa9e <rpl_set+0x2a>
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fb36:	3401      	adds	r4, #1
    fb38:	2c0a      	cmp	r4, #10
    fb3a:	d1dc      	bne.n	faf6 <rpl_set+0x82>
			BT_ERR("Unable to allocate RPL entry for 0x%04x", src);
    fb3c:	4b13      	ldr	r3, [pc, #76]	; (fb8c <rpl_set+0x118>)
    fb3e:	e9cd 3206 	strd	r3, r2, [sp, #24]
    fb42:	2303      	movs	r3, #3
    fb44:	9301      	str	r3, [sp, #4]
    fb46:	9305      	str	r3, [sp, #20]
    fb48:	480c      	ldr	r0, [pc, #48]	; (fb7c <rpl_set+0x108>)
    fb4a:	2300      	movs	r3, #0
    fb4c:	aa05      	add	r2, sp, #20
    fb4e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    fb52:	f016 f8c1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return -ENOMEM;
    fb56:	f06f 040b 	mvn.w	r4, #11
    fb5a:	e7a0      	b.n	fa9e <rpl_set+0x2a>
	entry->seq = rpl.seq;
    fb5c:	9b00      	ldr	r3, [sp, #0]
    fb5e:	806b      	strh	r3, [r5, #2]
    fb60:	f3c3 4307 	ubfx	r3, r3, #16, #8
    fb64:	712b      	strb	r3, [r5, #4]
	entry->old_iv = rpl.old_iv;
    fb66:	f89d 3003 	ldrb.w	r3, [sp, #3]
    fb6a:	786a      	ldrb	r2, [r5, #1]
    fb6c:	f3c3 0300 	ubfx	r3, r3, #0, #1
    fb70:	f363 12c7 	bfi	r2, r3, #7, #1
    fb74:	706a      	strb	r2, [r5, #1]
	return 0;
    fb76:	e792      	b.n	fa9e <rpl_set+0x2a>
    fb78:	0002f4d6 	.word	0x0002f4d6
    fb7c:	0002db7c 	.word	0x0002db7c
    fb80:	20001da8 	.word	0x20001da8
    fb84:	000315e4 	.word	0x000315e4
    fb88:	000315c0 	.word	0x000315c0
    fb8c:	000315f8 	.word	0x000315f8

0000fb90 <bt_mesh_rpl_check>:
{
    fb90:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
    fb92:	7d06      	ldrb	r6, [r0, #20]
    fb94:	f006 0330 	and.w	r3, r6, #48	; 0x30
    fb98:	2b10      	cmp	r3, #16
{
    fb9a:	b089      	sub	sp, #36	; 0x24
    fb9c:	4605      	mov	r5, r0
    fb9e:	460c      	mov	r4, r1
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
    fba0:	d00c      	beq.n	fbbc <bt_mesh_rpl_check+0x2c>
	if (!rx->local_match) {
    fba2:	f016 0040 	ands.w	r0, r6, #64	; 0x40
    fba6:	d00a      	beq.n	fbbe <bt_mesh_rpl_check+0x2e>
    fba8:	481e      	ldr	r0, [pc, #120]	; (fc24 <bt_mesh_rpl_check+0x94>)
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fbaa:	2200      	movs	r2, #0
    fbac:	4601      	mov	r1, r0
		if (!rpl->src) {
    fbae:	f831 7032 	ldrh.w	r7, [r1, r2, lsl #3]
    fbb2:	f3c7 030e 	ubfx	r3, r7, #0, #15
    fbb6:	b923      	cbnz	r3, fbc2 <bt_mesh_rpl_check+0x32>
				if (match) {
    fbb8:	b1f4      	cbz	r4, fbf8 <bt_mesh_rpl_check+0x68>
					*match = rpl;
    fbba:	6020      	str	r0, [r4, #0]
		return false;
    fbbc:	2000      	movs	r0, #0
}
    fbbe:	b009      	add	sp, #36	; 0x24
    fbc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (rpl->src == rx->ctx.addr) {
    fbc2:	892b      	ldrh	r3, [r5, #8]
    fbc4:	f3c7 070e 	ubfx	r7, r7, #0, #15
    fbc8:	429f      	cmp	r7, r3
    fbca:	d119      	bne.n	fc00 <bt_mesh_rpl_check+0x70>
			if (rx->old_iv && !rpl->old_iv) {
    fbcc:	00d7      	lsls	r7, r2, #3
    fbce:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    fbd2:	f992 3001 	ldrsb.w	r3, [r2, #1]
    fbd6:	07f2      	lsls	r2, r6, #31
    fbd8:	d503      	bpl.n	fbe2 <bt_mesh_rpl_check+0x52>
    fbda:	2b00      	cmp	r3, #0
    fbdc:	db03      	blt.n	fbe6 <bt_mesh_rpl_check+0x56>
				return true;
    fbde:	2001      	movs	r0, #1
    fbe0:	e7ed      	b.n	fbbe <bt_mesh_rpl_check+0x2e>
			if ((!rx->old_iv && rpl->old_iv) ||
    fbe2:	2b00      	cmp	r3, #0
    fbe4:	dbe8      	blt.n	fbb8 <bt_mesh_rpl_check+0x28>
			    rpl->seq < rx->seq) {
    fbe6:	4439      	add	r1, r7
    fbe8:	790a      	ldrb	r2, [r1, #4]
    fbea:	884b      	ldrh	r3, [r1, #2]
    fbec:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
			if ((!rx->old_iv && rpl->old_iv) ||
    fbf0:	692a      	ldr	r2, [r5, #16]
    fbf2:	4293      	cmp	r3, r2
    fbf4:	d2f3      	bcs.n	fbde <bt_mesh_rpl_check+0x4e>
    fbf6:	e7df      	b.n	fbb8 <bt_mesh_rpl_check+0x28>
					bt_mesh_rpl_update(rpl, rx);
    fbf8:	4629      	mov	r1, r5
    fbfa:	f019 ffec 	bl	29bd6 <bt_mesh_rpl_update>
    fbfe:	e7dd      	b.n	fbbc <bt_mesh_rpl_check+0x2c>
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fc00:	3201      	adds	r2, #1
    fc02:	2a0a      	cmp	r2, #10
    fc04:	f100 0008 	add.w	r0, r0, #8
    fc08:	d1d1      	bne.n	fbae <bt_mesh_rpl_check+0x1e>
	BT_ERR("RPL is full!");
    fc0a:	4b07      	ldr	r3, [pc, #28]	; (fc28 <bt_mesh_rpl_check+0x98>)
    fc0c:	9306      	str	r3, [sp, #24]
    fc0e:	2302      	movs	r3, #2
    fc10:	9301      	str	r3, [sp, #4]
    fc12:	9305      	str	r3, [sp, #20]
    fc14:	4805      	ldr	r0, [pc, #20]	; (fc2c <bt_mesh_rpl_check+0x9c>)
    fc16:	2300      	movs	r3, #0
    fc18:	aa05      	add	r2, sp, #20
    fc1a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    fc1e:	f016 f85b 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	return true;
    fc22:	e7dc      	b.n	fbde <bt_mesh_rpl_check+0x4e>
    fc24:	20001da8 	.word	0x20001da8
    fc28:	00031620 	.word	0x00031620
    fc2c:	0002db7c 	.word	0x0002db7c

0000fc30 <bt_mesh_rpl_reset>:
{
    fc30:	b570      	push	{r4, r5, r6, lr}
    fc32:	4d0f      	ldr	r5, [pc, #60]	; (fc70 <bt_mesh_rpl_reset+0x40>)
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fc34:	2400      	movs	r4, #0
    fc36:	462e      	mov	r6, r5
		if (rpl->src) {
    fc38:	f836 3034 	ldrh.w	r3, [r6, r4, lsl #3]
    fc3c:	f3c3 030e 	ubfx	r3, r3, #0, #15
    fc40:	b143      	cbz	r3, fc54 <bt_mesh_rpl_reset+0x24>
			if (rpl->old_iv) {
    fc42:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
    fc46:	f993 2001 	ldrsb.w	r2, [r3, #1]
    fc4a:	2a00      	cmp	r2, #0
    fc4c:	da08      	bge.n	fc60 <bt_mesh_rpl_reset+0x30>
					clear_rpl(rpl);
    fc4e:	4628      	mov	r0, r5
    fc50:	f7ff feca 	bl	f9e8 <clear_rpl>
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fc54:	3401      	adds	r4, #1
    fc56:	2c0a      	cmp	r4, #10
    fc58:	f105 0508 	add.w	r5, r5, #8
    fc5c:	d1ec      	bne.n	fc38 <bt_mesh_rpl_reset+0x8>
}
    fc5e:	bd70      	pop	{r4, r5, r6, pc}
				rpl->old_iv = true;
    fc60:	785a      	ldrb	r2, [r3, #1]
    fc62:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    fc66:	705a      	strb	r2, [r3, #1]
					schedule_rpl_store(rpl, true);
    fc68:	4628      	mov	r0, r5
    fc6a:	f7ff fe9f 	bl	f9ac <schedule_rpl_store.constprop.0>
    fc6e:	e7f1      	b.n	fc54 <bt_mesh_rpl_reset+0x24>
    fc70:	20001da8 	.word	0x20001da8

0000fc74 <bt_mesh_rpl_pending_store>:
		store_rpl(rpl);
	}
}

void bt_mesh_rpl_pending_store(uint16_t addr)
{
    fc74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int i;

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) ||
    fc78:	b203      	sxth	r3, r0
    fc7a:	2b00      	cmp	r3, #0
{
    fc7c:	b08b      	sub	sp, #44	; 0x2c
    fc7e:	4604      	mov	r4, r0
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) ||
    fc80:	dc06      	bgt.n	fc90 <bt_mesh_rpl_pending_store+0x1c>
    fc82:	f64f 73ff 	movw	r3, #65535	; 0xffff
    fc86:	4298      	cmp	r0, r3
    fc88:	d118      	bne.n	fcbc <bt_mesh_rpl_pending_store+0x48>
	     addr != BT_MESH_ADDR_ALL_NODES)) {
		return;
	}

	if (addr == BT_MESH_ADDR_ALL_NODES) {
		bt_mesh_settings_store_cancel(BT_MESH_SETTINGS_RPL_PENDING);
    fc8a:	2000      	movs	r0, #0
    fc8c:	f005 faae 	bl	151ec <bt_mesh_settings_store_cancel>
    fc90:	4e3b      	ldr	r6, [pc, #236]	; (fd80 <bt_mesh_rpl_pending_store+0x10c>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    fc92:	f8df a0f0 	ldr.w	sl, [pc, #240]	; fd84 <bt_mesh_rpl_pending_store+0x110>
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", entry->src);
    fc96:	f8df b0f0 	ldr.w	fp, [pc, #240]	; fd88 <bt_mesh_rpl_pending_store+0x114>
{
    fc9a:	2500      	movs	r5, #0
    fc9c:	4637      	mov	r7, r6
	}

	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
		if (addr != BT_MESH_ADDR_ALL_NODES &&
    fc9e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    fca2:	429c      	cmp	r4, r3
    fca4:	d00d      	beq.n	fcc2 <bt_mesh_rpl_pending_store+0x4e>
		    addr != replay_list[i].src) {
    fca6:	f837 3035 	ldrh.w	r3, [r7, r5, lsl #3]
		if (addr != BT_MESH_ADDR_ALL_NODES &&
    fcaa:	f3c3 030e 	ubfx	r3, r3, #0, #15
    fcae:	42a3      	cmp	r3, r4
    fcb0:	d007      	beq.n	fcc2 <bt_mesh_rpl_pending_store+0x4e>
	for (i = 0; i < ARRAY_SIZE(replay_list); i++) {
    fcb2:	3501      	adds	r5, #1
    fcb4:	2d0a      	cmp	r5, #10
    fcb6:	f106 0608 	add.w	r6, r6, #8
    fcba:	d1f0      	bne.n	fc9e <bt_mesh_rpl_pending_store+0x2a>

		if (addr != BT_MESH_ADDR_ALL_NODES) {
			break;
		}
	}
}
    fcbc:	b00b      	add	sp, #44	; 0x2c
    fcbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    fcc2:	4b32      	ldr	r3, [pc, #200]	; (fd8c <bt_mesh_rpl_pending_store+0x118>)
    fcc4:	f3bf 8f5b 	dmb	ish
    fcc8:	681b      	ldr	r3, [r3, #0]
    fcca:	f3bf 8f5b 	dmb	ish
		if (atomic_test_bit(bt_mesh.flags, BT_MESH_VALID)) {
    fcce:	07db      	lsls	r3, r3, #31
    fcd0:	d552      	bpl.n	fd78 <bt_mesh_rpl_pending_store+0x104>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    fcd2:	f3bf 8f5b 	dmb	ish
	return rpl - &replay_list[0];
    fcd6:	1bf3      	subs	r3, r6, r7
	atomic_val_t mask = ATOMIC_MASK(bit);
    fcd8:	f3c3 02c4 	ubfx	r2, r3, #3, #5
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    fcdc:	119b      	asrs	r3, r3, #6
	atomic_val_t mask = ATOMIC_MASK(bit);
    fcde:	f04f 0901 	mov.w	r9, #1
    fce2:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    fce6:	fa09 f202 	lsl.w	r2, r9, r2
    fcea:	f023 0303 	bic.w	r3, r3, #3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    fcee:	43d0      	mvns	r0, r2
    fcf0:	4453      	add	r3, sl
    fcf2:	e853 1f00 	ldrex	r1, [r3]
    fcf6:	ea01 0c00 	and.w	ip, r1, r0
    fcfa:	e843 ce00 	strex	lr, ip, [r3]
    fcfe:	f1be 0f00 	cmp.w	lr, #0
    fd02:	d1f6      	bne.n	fcf2 <bt_mesh_rpl_pending_store+0x7e>
    fd04:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(store, rpl_idx(rpl))) {
    fd08:	4211      	tst	r1, r2
    fd0a:	d030      	beq.n	fd6e <bt_mesh_rpl_pending_store+0xfa>
	if (!entry->src) {
    fd0c:	f837 3035 	ldrh.w	r3, [r7, r5, lsl #3]
    fd10:	f3c3 020e 	ubfx	r2, r3, #0, #15
    fd14:	b35a      	cbz	r2, fd6e <bt_mesh_rpl_pending_store+0xfa>
	rpl.seq = entry->seq;
    fd16:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", entry->src);
    fd1a:	f10d 0814 	add.w	r8, sp, #20
	rpl.seq = entry->seq;
    fd1e:	790a      	ldrb	r2, [r1, #4]
    fd20:	8848      	ldrh	r0, [r1, #2]
    fd22:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    fd26:	9a04      	ldr	r2, [sp, #16]
    fd28:	f360 0217 	bfi	r2, r0, #0, #24
    fd2c:	9204      	str	r2, [sp, #16]
	rpl.old_iv = entry->old_iv;
    fd2e:	7849      	ldrb	r1, [r1, #1]
    fd30:	f3c2 6207 	ubfx	r2, r2, #24, #8
    fd34:	09c9      	lsrs	r1, r1, #7
    fd36:	f361 0200 	bfi	r2, r1, #0, #1
    fd3a:	f88d 2013 	strb.w	r2, [sp, #19]
	snprintk(path, sizeof(path), "bt/mesh/RPL/%x", entry->src);
    fd3e:	2112      	movs	r1, #18
    fd40:	465a      	mov	r2, fp
    fd42:	f3c3 030e 	ubfx	r3, r3, #0, #15
    fd46:	4640      	mov	r0, r8
    fd48:	f015 fa45 	bl	251d6 <snprintk>
	err = settings_save_one(path, &rpl, sizeof(rpl));
    fd4c:	2204      	movs	r2, #4
    fd4e:	a904      	add	r1, sp, #16
    fd50:	4640      	mov	r0, r8
    fd52:	f7f3 ff55 	bl	3c00 <settings_save_one>
	if (err) {
    fd56:	b150      	cbz	r0, fd6e <bt_mesh_rpl_pending_store+0xfa>
		BT_ERR("Failed to store RPL %s value", log_strdup(path));
    fd58:	4b0d      	ldr	r3, [pc, #52]	; (fd90 <bt_mesh_rpl_pending_store+0x11c>)
    fd5a:	9301      	str	r3, [sp, #4]
    fd5c:	2300      	movs	r3, #0
    fd5e:	490d      	ldr	r1, [pc, #52]	; (fd94 <bt_mesh_rpl_pending_store+0x120>)
    fd60:	f8cd 8008 	str.w	r8, [sp, #8]
    fd64:	9300      	str	r3, [sp, #0]
    fd66:	464a      	mov	r2, r9
    fd68:	4618      	mov	r0, r3
    fd6a:	f7ff fe0d 	bl	f988 <z_log_msg2_runtime_create.constprop.0>
		if (addr != BT_MESH_ADDR_ALL_NODES) {
    fd6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    fd72:	429c      	cmp	r4, r3
    fd74:	d09d      	beq.n	fcb2 <bt_mesh_rpl_pending_store+0x3e>
    fd76:	e7a1      	b.n	fcbc <bt_mesh_rpl_pending_store+0x48>
			clear_rpl(&replay_list[i]);
    fd78:	4630      	mov	r0, r6
    fd7a:	f7ff fe35 	bl	f9e8 <clear_rpl>
    fd7e:	e7f6      	b.n	fd6e <bt_mesh_rpl_pending_store+0xfa>
    fd80:	20001da8 	.word	0x20001da8
    fd84:	2000275c 	.word	0x2000275c
    fd88:	0003159d 	.word	0x0003159d
    fd8c:	20001ab0 	.word	0x20001ab0
    fd90:	00031580 	.word	0x00031580
    fd94:	0002db7c 	.word	0x0002db7c

0000fd98 <sub_end>:
		}
	}
}

static void sub_end(struct k_work *work)
{
    fd98:	b570      	push	{r4, r5, r6, lr}
	sub.remaining = 0;
    fd9a:	4d07      	ldr	r5, [pc, #28]	; (fdb8 <sub_end+0x20>)
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    fd9c:	4c07      	ldr	r4, [pc, #28]	; (fdbc <sub_end+0x24>)
    fd9e:	4e08      	ldr	r6, [pc, #32]	; (fdc0 <sub_end+0x28>)
	sub.remaining = 0;
    fda0:	2300      	movs	r3, #0
    fda2:	606b      	str	r3, [r5, #4]
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    fda4:	42b4      	cmp	r4, r6
    fda6:	d300      	bcc.n	fdaa <sub_end+0x12>
	notify_sub_end();
}
    fda8:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->sub_end) {
    fdaa:	6863      	ldr	r3, [r4, #4]
    fdac:	b10b      	cbz	r3, fdb2 <sub_end+0x1a>
			cb->sub_end(&sub);
    fdae:	4628      	mov	r0, r5
    fdb0:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    fdb2:	3408      	adds	r4, #8
    fdb4:	e7f6      	b.n	fda4 <sub_end+0xc>
    fdb6:	bf00      	nop
    fdb8:	20002770 	.word	0x20002770
    fdbc:	0002d868 	.word	0x0002d868
    fdc0:	0002d868 	.word	0x0002d868

0000fdc4 <hb_publish_end_cb>:
{
    fdc4:	b570      	push	{r4, r5, r6, lr}
	if (pub.period && pub.count > 1) {
    fdc6:	4d11      	ldr	r5, [pc, #68]	; (fe0c <hb_publish_end_cb+0x48>)
    fdc8:	68ec      	ldr	r4, [r5, #12]
    fdca:	b1b4      	cbz	r4, fdfa <hb_publish_end_cb+0x36>
    fdcc:	886b      	ldrh	r3, [r5, #2]
    fdce:	2b01      	cmp	r3, #1
    fdd0:	d913      	bls.n	fdfa <hb_publish_end_cb+0x36>
		k_work_reschedule(&pub_timer, K_SECONDS(pub.period));
    fdd2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    fdd6:	435c      	muls	r4, r3
    fdd8:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    fddc:	f240 30e7 	movw	r0, #999	; 0x3e7
    fde0:	2100      	movs	r1, #0
    fde2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    fde6:	2300      	movs	r3, #0
    fde8:	fbe4 0106 	umlal	r0, r1, r4, r6
    fdec:	f7f0 f978 	bl	e0 <__aeabi_uldivmod>
    fdf0:	4602      	mov	r2, r0
    fdf2:	460b      	mov	r3, r1
    fdf4:	4806      	ldr	r0, [pc, #24]	; (fe10 <hb_publish_end_cb+0x4c>)
    fdf6:	f014 fab5 	bl	24364 <k_work_reschedule>
	if (pub.count != 0xffff) {
    fdfa:	886b      	ldrh	r3, [r5, #2]
    fdfc:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fe00:	4293      	cmp	r3, r2
		pub.count--;
    fe02:	bf1c      	itt	ne
    fe04:	f103 33ff 	addne.w	r3, r3, #4294967295	; 0xffffffff
    fe08:	806b      	strhne	r3, [r5, #2]
}
    fe0a:	bd70      	pop	{r4, r5, r6, pc}
    fe0c:	20002760 	.word	0x20002760
    fe10:	20001df8 	.word	0x20001df8

0000fe14 <heartbeat_send.constprop.0>:

static int heartbeat_send(const struct bt_mesh_send_cb *cb, void *cb_data)
    fe14:	b530      	push	{r4, r5, lr}
	struct __packed {
		uint8_t init_ttl;
		uint16_t feat;
	} hb;
	struct bt_mesh_msg_ctx ctx = {
		.net_idx = pub.net_idx,
    fe16:	4c26      	ldr	r4, [pc, #152]	; (feb0 <heartbeat_send.constprop.0+0x9c>)
static int heartbeat_send(const struct bt_mesh_send_cb *cb, void *cb_data)
    fe18:	b08b      	sub	sp, #44	; 0x2c
	struct bt_mesh_msg_ctx ctx = {
    fe1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    fe1e:	f8ad 2012 	strh.w	r2, [sp, #18]
    fe22:	8822      	ldrh	r2, [r4, #0]
    fe24:	f8ad 2014 	strh.w	r2, [sp, #20]
    fe28:	2300      	movs	r3, #0
    fe2a:	7922      	ldrb	r2, [r4, #4]
    fe2c:	f88d 201b 	strb.w	r2, [sp, #27]
static int heartbeat_send(const struct bt_mesh_send_cb *cb, void *cb_data)
    fe30:	4605      	mov	r5, r0
		.net_idx = pub.net_idx,
    fe32:	8920      	ldrh	r0, [r4, #8]
	struct bt_mesh_msg_ctx ctx = {
    fe34:	f8cd 3016 	str.w	r3, [sp, #22]
		.app_idx = BT_MESH_KEY_UNUSED,
		.addr = pub.dst,
		.send_ttl = pub.ttl,
	};
	struct bt_mesh_net_tx tx = {
    fe38:	e9cd 3307 	strd	r3, r3, [sp, #28]
	struct bt_mesh_msg_ctx ctx = {
    fe3c:	f88d 301a 	strb.w	r3, [sp, #26]
	struct bt_mesh_net_tx tx = {
    fe40:	9309      	str	r3, [sp, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
    fe42:	f8ad 0010 	strh.w	r0, [sp, #16]
		.sub = bt_mesh_subnet_get(pub.net_idx),
    fe46:	f7fd fcdb 	bl	d800 <bt_mesh_subnet_get>
	struct bt_mesh_net_tx tx = {
    fe4a:	ab04      	add	r3, sp, #16
    fe4c:	9308      	str	r3, [sp, #32]
    fe4e:	9007      	str	r0, [sp, #28]
		.ctx = &ctx,
		.src = bt_mesh_primary_addr(),
    fe50:	f001 f808 	bl	10e64 <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
    fe54:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
    fe58:	f7fb ff6e 	bl	bd38 <bt_mesh_net_transmit_get>
	struct bt_mesh_net_tx tx = {
    fe5c:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
	};

	/* Do nothing if heartbeat publication is not enabled or the subnet is
	 * removed.
	 */
	if (!tx.sub || pub.dst == BT_MESH_ADDR_UNASSIGNED) {
    fe60:	9807      	ldr	r0, [sp, #28]
    fe62:	b310      	cbz	r0, feaa <heartbeat_send.constprop.0+0x96>
    fe64:	8820      	ldrh	r0, [r4, #0]
    fe66:	b300      	cbz	r0, feaa <heartbeat_send.constprop.0+0x96>
		return 0;
	}

	hb.init_ttl = pub.ttl;
    fe68:	7923      	ldrb	r3, [r4, #4]
    fe6a:	f88d 300c 	strb.w	r3, [sp, #12]

	if (bt_mesh_relay_get() == BT_MESH_RELAY_ENABLED) {
    fe6e:	f7fb ffcd 	bl	be0c <bt_mesh_relay_get>
	uint16_t feat = 0U;
    fe72:	1e43      	subs	r3, r0, #1
    fe74:	425c      	negs	r4, r3
    fe76:	415c      	adcs	r4, r3
		feat |= BT_MESH_FEAT_RELAY;
	}

	if (bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED) {
    fe78:	f7fb fef6 	bl	bc68 <bt_mesh_gatt_proxy_get>
    fe7c:	2801      	cmp	r0, #1
		feat |= BT_MESH_FEAT_PROXY;
    fe7e:	bf08      	it	eq
    fe80:	f044 0402 	orreq.w	r4, r4, #2
	}

	if (bt_mesh_friend_get() == BT_MESH_FRIEND_ENABLED) {
    fe84:	f7fb ff38 	bl	bcf8 <bt_mesh_friend_get>
    fe88:	2801      	cmp	r0, #1

	hb.feat = sys_cpu_to_be16(feat);

	BT_DBG("InitTTL %u feat 0x%04x", pub.ttl, feat);

	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
    fe8a:	f04f 0300 	mov.w	r3, #0
		feat |= BT_MESH_FEAT_FRIEND;
    fe8e:	bf08      	it	eq
    fe90:	f044 0404 	orreq.w	r4, r4, #4
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
    fe94:	e9cd 5300 	strd	r5, r3, [sp]
	hb.feat = sys_cpu_to_be16(feat);
    fe98:	0224      	lsls	r4, r4, #8
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
    fe9a:	2303      	movs	r3, #3
    fe9c:	aa03      	add	r2, sp, #12
    fe9e:	210a      	movs	r1, #10
    fea0:	a807      	add	r0, sp, #28
	hb.feat = sys_cpu_to_be16(feat);
    fea2:	f8ad 400d 	strh.w	r4, [sp, #13]
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_HEARTBEAT, &hb, sizeof(hb),
    fea6:	f7fe fe8f 	bl	ebc8 <bt_mesh_ctl_send>
				cb, cb_data);
}
    feaa:	b00b      	add	sp, #44	; 0x2c
    feac:	bd30      	pop	{r4, r5, pc}
    feae:	bf00      	nop
    feb0:	20002760 	.word	0x20002760

0000feb4 <hb_publish>:
		hb_publish_end_cb(err, cb_data);
	}
}

static void hb_publish(struct k_work *work)
{
    feb4:	b530      	push	{r4, r5, lr}
	int err;

	BT_DBG("hb_pub.count: %u", pub.count);

	/* Fast exit if disabled or expired */
	if (pub.period == 0U || pub.count == 0U) {
    feb6:	4c13      	ldr	r4, [pc, #76]	; (ff04 <hb_publish+0x50>)
    feb8:	68e3      	ldr	r3, [r4, #12]
{
    feba:	b089      	sub	sp, #36	; 0x24
	if (pub.period == 0U || pub.count == 0U) {
    febc:	b1ab      	cbz	r3, feea <hb_publish+0x36>
    febe:	8863      	ldrh	r3, [r4, #2]
    fec0:	b19b      	cbz	r3, feea <hb_publish+0x36>
		return;
	}

	sub = bt_mesh_subnet_get(pub.net_idx);
    fec2:	8920      	ldrh	r0, [r4, #8]
    fec4:	f7fd fc9c 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
    fec8:	4605      	mov	r5, r0
    feca:	b980      	cbnz	r0, feee <hb_publish+0x3a>
		BT_ERR("No matching subnet for idx 0x%02x", pub.net_idx);
    fecc:	8923      	ldrh	r3, [r4, #8]
    fece:	4a0e      	ldr	r2, [pc, #56]	; (ff08 <hb_publish+0x54>)
    fed0:	e9cd 2306 	strd	r2, r3, [sp, #24]
    fed4:	2303      	movs	r3, #3
    fed6:	9301      	str	r3, [sp, #4]
    fed8:	9305      	str	r3, [sp, #20]
    feda:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
    fede:	4603      	mov	r3, r0
    fee0:	aa05      	add	r2, sp, #20
    fee2:	480a      	ldr	r0, [pc, #40]	; (ff0c <hb_publish+0x58>)
    fee4:	f015 fef8 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		pub.dst = BT_MESH_ADDR_UNASSIGNED;
    fee8:	8025      	strh	r5, [r4, #0]

	err = heartbeat_send(&publish_cb, NULL);
	if (err) {
		hb_publish_end_cb(err, NULL);
	}
}
    feea:	b009      	add	sp, #36	; 0x24
    feec:	bd30      	pop	{r4, r5, pc}
	err = heartbeat_send(&publish_cb, NULL);
    feee:	4808      	ldr	r0, [pc, #32]	; (ff10 <hb_publish+0x5c>)
    fef0:	f7ff ff90 	bl	fe14 <heartbeat_send.constprop.0>
	if (err) {
    fef4:	2800      	cmp	r0, #0
    fef6:	d0f8      	beq.n	feea <hb_publish+0x36>
		hb_publish_end_cb(err, NULL);
    fef8:	2100      	movs	r1, #0
}
    fefa:	b009      	add	sp, #36	; 0x24
    fefc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		hb_publish_end_cb(err, NULL);
    ff00:	f7ff bf60 	b.w	fdc4 <hb_publish_end_cb>
    ff04:	20002760 	.word	0x20002760
    ff08:	00031645 	.word	0x00031645
    ff0c:	0002db1c 	.word	0x0002db1c
    ff10:	0002e424 	.word	0x0002e424

0000ff14 <bt_mesh_hb_recv>:

int bt_mesh_hb_recv(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
{
    ff14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t init_ttl, hops;
	uint16_t feat;

	if (buf->len < 3) {
    ff18:	888b      	ldrh	r3, [r1, #4]
    ff1a:	2b02      	cmp	r3, #2
{
    ff1c:	b088      	sub	sp, #32
    ff1e:	4607      	mov	r7, r0
    ff20:	460d      	mov	r5, r1
	if (buf->len < 3) {
    ff22:	d810      	bhi.n	ff46 <bt_mesh_hb_recv+0x32>
		BT_ERR("Too short heartbeat message");
    ff24:	4b2c      	ldr	r3, [pc, #176]	; (ffd8 <bt_mesh_hb_recv+0xc4>)
    ff26:	9306      	str	r3, [sp, #24]
    ff28:	2302      	movs	r3, #2
    ff2a:	9301      	str	r3, [sp, #4]
    ff2c:	9305      	str	r3, [sp, #20]
    ff2e:	482b      	ldr	r0, [pc, #172]	; (ffdc <bt_mesh_hb_recv+0xc8>)
    ff30:	2300      	movs	r3, #0
    ff32:	aa05      	add	r2, sp, #20
    ff34:	f44f 5182 	mov.w	r1, #4160	; 0x1040
    ff38:	f015 fece 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
    ff3c:	f06f 0015 	mvn.w	r0, #21
	       (hops == 1U) ? "" : "s", feat);

	notify_recv(hops, feat);

	return 0;
}
    ff40:	b008      	add	sp, #32
    ff42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	init_ttl = (net_buf_simple_pull_u8(buf) & 0x7f);
    ff46:	4608      	mov	r0, r1
    ff48:	f01b ff78 	bl	2be3c <net_buf_simple_pull_u8>
	if (rx->ctx.addr != sub.src || rx->ctx.recv_dst != sub.dst) {
    ff4c:	4e24      	ldr	r6, [pc, #144]	; (ffe0 <bt_mesh_hb_recv+0xcc>)
	init_ttl = (net_buf_simple_pull_u8(buf) & 0x7f);
    ff4e:	4604      	mov	r4, r0
	feat = net_buf_simple_pull_be16(buf);
    ff50:	4628      	mov	r0, r5
    ff52:	f01b ff83 	bl	2be5c <net_buf_simple_pull_be16>
	if (rx->ctx.addr != sub.src || rx->ctx.recv_dst != sub.dst) {
    ff56:	68ba      	ldr	r2, [r7, #8]
    ff58:	68b3      	ldr	r3, [r6, #8]
    ff5a:	429a      	cmp	r2, r3
	feat = net_buf_simple_pull_be16(buf);
    ff5c:	4605      	mov	r5, r0
	if (rx->ctx.addr != sub.src || rx->ctx.recv_dst != sub.dst) {
    ff5e:	d001      	beq.n	ff64 <bt_mesh_hb_recv+0x50>
		return 0;
    ff60:	2000      	movs	r0, #0
    ff62:	e7ed      	b.n	ff40 <bt_mesh_hb_recv+0x2c>
	return k_work_delayable_busy_get(dwork) != 0;
    ff64:	481f      	ldr	r0, [pc, #124]	; (ffe4 <bt_mesh_hb_recv+0xd0>)
	hops = (init_ttl - rx->ctx.recv_ttl + 1);
    ff66:	7b7f      	ldrb	r7, [r7, #13]
    ff68:	f01c ff4b 	bl	2ce02 <k_work_delayable_busy_get>
	if (!k_work_delayable_is_pending(&sub_timer)) {
    ff6c:	2800      	cmp	r0, #0
    ff6e:	d0f7      	beq.n	ff60 <bt_mesh_hb_recv+0x4c>
	init_ttl = (net_buf_simple_pull_u8(buf) & 0x7f);
    ff70:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	hops = (init_ttl - rx->ctx.recv_ttl + 1);
    ff74:	f1c7 0701 	rsb	r7, r7, #1
	sub.min_hops = MIN(sub.min_hops, hops);
    ff78:	7bb3      	ldrb	r3, [r6, #14]
	hops = (init_ttl - rx->ctx.recv_ttl + 1);
    ff7a:	443c      	add	r4, r7
    ff7c:	b2e4      	uxtb	r4, r4
	sub.min_hops = MIN(sub.min_hops, hops);
    ff7e:	42a3      	cmp	r3, r4
    ff80:	bf28      	it	cs
    ff82:	4623      	movcs	r3, r4
    ff84:	73b3      	strb	r3, [r6, #14]
	sub.max_hops = MAX(sub.max_hops, hops);
    ff86:	7bf3      	ldrb	r3, [r6, #15]
    ff88:	42a3      	cmp	r3, r4
    ff8a:	bf38      	it	cc
    ff8c:	4623      	movcc	r3, r4
    ff8e:	73f3      	strb	r3, [r6, #15]
	if (sub.count < 0xffff) {
    ff90:	89b3      	ldrh	r3, [r6, #12]
    ff92:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ff96:	4293      	cmp	r3, r2
		sub.count++;
    ff98:	bf1c      	itt	ne
    ff9a:	3301      	addne	r3, #1
    ff9c:	81b3      	strhne	r3, [r6, #12]
	if (sub.dst == BT_MESH_ADDR_UNASSIGNED) {
    ff9e:	8973      	ldrh	r3, [r6, #10]
    ffa0:	b15b      	cbz	r3, ffba <bt_mesh_hb_recv+0xa6>
	return z_timeout_remaining(&dwork->timeout);
    ffa2:	4811      	ldr	r0, [pc, #68]	; (ffe8 <bt_mesh_hb_recv+0xd4>)
    ffa4:	f01d f896 	bl	2d0d4 <z_timeout_remaining>
			return (uint32_t)((t * to_hz + off) / from_hz);
    ffa8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ffac:	fba0 3002 	umull	r3, r0, r0, r2
    ffb0:	0bdb      	lsrs	r3, r3, #15
    ffb2:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
	return rem_ms / MSEC_PER_SEC;
    ffb6:	fbb3 f3f2 	udiv	r3, r3, r2
	sub.remaining = sub_remaining();
    ffba:	6073      	str	r3, [r6, #4]
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    ffbc:	4f0b      	ldr	r7, [pc, #44]	; (ffec <bt_mesh_hb_recv+0xd8>)
    ffbe:	4e0c      	ldr	r6, [pc, #48]	; (fff0 <bt_mesh_hb_recv+0xdc>)
			cb->recv(&sub, hops, feat);
    ffc0:	f8df 801c 	ldr.w	r8, [pc, #28]	; ffe0 <bt_mesh_hb_recv+0xcc>
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    ffc4:	42be      	cmp	r6, r7
    ffc6:	d2cb      	bcs.n	ff60 <bt_mesh_hb_recv+0x4c>
		if (cb->recv) {
    ffc8:	6833      	ldr	r3, [r6, #0]
    ffca:	b11b      	cbz	r3, ffd4 <bt_mesh_hb_recv+0xc0>
			cb->recv(&sub, hops, feat);
    ffcc:	462a      	mov	r2, r5
    ffce:	4621      	mov	r1, r4
    ffd0:	4640      	mov	r0, r8
    ffd2:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_hb_cb, cb) {
    ffd4:	3608      	adds	r6, #8
    ffd6:	e7f5      	b.n	ffc4 <bt_mesh_hb_recv+0xb0>
    ffd8:	00031667 	.word	0x00031667
    ffdc:	0002db1c 	.word	0x0002db1c
    ffe0:	20002770 	.word	0x20002770
    ffe4:	20001e28 	.word	0x20001e28
    ffe8:	20001e38 	.word	0x20001e38
    ffec:	0002d868 	.word	0x0002d868
    fff0:	0002d868 	.word	0x0002d868

0000fff4 <bt_mesh_hb_pub_set>:
	 */
	(void)k_work_cancel_delayable(&pub_timer);
}

uint8_t bt_mesh_hb_pub_set(struct bt_mesh_hb_pub *new_pub)
{
    fff4:	b530      	push	{r4, r5, lr}
	if (!new_pub || new_pub->dst == BT_MESH_ADDR_UNASSIGNED) {
    fff6:	4604      	mov	r4, r0
{
    fff8:	b089      	sub	sp, #36	; 0x24
	if (!new_pub || new_pub->dst == BT_MESH_ADDR_UNASSIGNED) {
    fffa:	b108      	cbz	r0, 10000 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x1>
    fffc:	8803      	ldrh	r3, [r0, #0]
    fffe:	b97b      	cbnz	r3, 10020 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x21>
	pub.dst = BT_MESH_ADDR_UNASSIGNED;
   10000:	4b1b      	ldr	r3, [pc, #108]	; (10070 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x71>)
	(void)k_work_cancel_delayable(&pub_timer);
   10002:	481c      	ldr	r0, [pc, #112]	; (10074 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x75>)
	pub.dst = BT_MESH_ADDR_UNASSIGNED;
   10004:	2400      	movs	r4, #0
   10006:	601c      	str	r4, [r3, #0]
	pub.ttl = 0U;
   10008:	711c      	strb	r4, [r3, #4]
	pub.period = 0U;
   1000a:	60dc      	str	r4, [r3, #12]
	(void)k_work_cancel_delayable(&pub_timer);
   1000c:	f01c fefb 	bl	2ce06 <k_work_cancel_delayable>
		pub_disable();

		if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
		    bt_mesh_is_provisioned()) {
   10010:	f7fb fcd6 	bl	b9c0 <bt_mesh_is_provisioned>
		if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
   10014:	b1b8      	cbz	r0, 10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
	 * the work item.
	 */
	k_work_reschedule(&pub_timer, K_NO_WAIT);

	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		bt_mesh_settings_store_schedule(
   10016:	2006      	movs	r0, #6
   10018:	f005 f88c 	bl	15134 <bt_mesh_settings_store_schedule>
					BT_MESH_SETTINGS_HB_PUB_PENDING);
	}

	return STATUS_SUCCESS;
   1001c:	2000      	movs	r0, #0
   1001e:	e012      	b.n	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
	if (!bt_mesh_subnet_get(new_pub->net_idx)) {
   10020:	8900      	ldrh	r0, [r0, #8]
   10022:	f7fd fbed 	bl	d800 <bt_mesh_subnet_get>
   10026:	4603      	mov	r3, r0
   10028:	b978      	cbnz	r0, 1004a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4b>
		BT_ERR("Unknown NetKey 0x%04x", new_pub->net_idx);
   1002a:	8922      	ldrh	r2, [r4, #8]
   1002c:	4912      	ldr	r1, [pc, #72]	; (10078 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x79>)
   1002e:	e9cd 1206 	strd	r1, r2, [sp, #24]
   10032:	2203      	movs	r2, #3
   10034:	9201      	str	r2, [sp, #4]
   10036:	9205      	str	r2, [sp, #20]
   10038:	4810      	ldr	r0, [pc, #64]	; (1007c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x7d>)
   1003a:	aa05      	add	r2, sp, #20
   1003c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   10040:	f015 fe4a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return STATUS_INVALID_NETKEY;
   10044:	2004      	movs	r0, #4
}
   10046:	b009      	add	sp, #36	; 0x24
   10048:	bd30      	pop	{r4, r5, pc}
	new_pub->feat &= BT_MESH_FEAT_SUPPORTED;
   1004a:	88e3      	ldrh	r3, [r4, #6]
	pub = *new_pub;
   1004c:	4d08      	ldr	r5, [pc, #32]	; (10070 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x71>)
	new_pub->feat &= BT_MESH_FEAT_SUPPORTED;
   1004e:	f003 030f 	and.w	r3, r3, #15
   10052:	80e3      	strh	r3, [r4, #6]
	pub = *new_pub;
   10054:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   10058:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (!bt_mesh_is_provisioned()) {
   1005c:	f7fb fcb0 	bl	b9c0 <bt_mesh_is_provisioned>
   10060:	2800      	cmp	r0, #0
   10062:	d0f0      	beq.n	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
	k_work_reschedule(&pub_timer, K_NO_WAIT);
   10064:	2200      	movs	r2, #0
   10066:	2300      	movs	r3, #0
   10068:	4802      	ldr	r0, [pc, #8]	; (10074 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x75>)
   1006a:	f014 f97b 	bl	24364 <k_work_reschedule>
   1006e:	e7d2      	b.n	10016 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x17>
   10070:	20002760 	.word	0x20002760
   10074:	20001df8 	.word	0x20001df8
   10078:	00031683 	.word	0x00031683
   1007c:	0002db1c 	.word	0x0002db1c

00010080 <hb_pub_set>:
	}
}

static int hb_pub_set(const char *name, size_t len_rd,
		      settings_read_cb read_cb, void *cb_arg)
{
   10080:	b510      	push	{r4, lr}
   10082:	4619      	mov	r1, r3
   10084:	b08a      	sub	sp, #40	; 0x28
	struct bt_mesh_hb_pub pub;
	struct hb_pub_val hb_val;
	int err;

	err = bt_mesh_settings_set(read_cb, cb_arg, &hb_val, sizeof(hb_val));
   10086:	2308      	movs	r3, #8
{
   10088:	4610      	mov	r0, r2
	err = bt_mesh_settings_set(read_cb, cb_arg, &hb_val, sizeof(hb_val));
   1008a:	eb0d 0203 	add.w	r2, sp, r3
   1008e:	f005 f813 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
   10092:	4604      	mov	r4, r0
   10094:	b170      	cbz	r0, 100b4 <hb_pub_set+0x34>
		BT_ERR("Failed to set \'hb_val\'");
   10096:	4b1e      	ldr	r3, [pc, #120]	; (10110 <hb_pub_set+0x90>)
   10098:	9308      	str	r3, [sp, #32]
   1009a:	2302      	movs	r3, #2
   1009c:	9301      	str	r3, [sp, #4]
   1009e:	9307      	str	r3, [sp, #28]
   100a0:	481c      	ldr	r0, [pc, #112]	; (10114 <hb_pub_set+0x94>)
   100a2:	2300      	movs	r3, #0
   100a4:	aa07      	add	r2, sp, #28
   100a6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   100aa:	f015 fe15 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	(void)bt_mesh_hb_pub_set(&pub);

	BT_DBG("Restored heartbeat publication");

	return 0;
}
   100ae:	4620      	mov	r0, r4
   100b0:	b00a      	add	sp, #40	; 0x28
   100b2:	bd10      	pop	{r4, pc}
	pub.period = bt_mesh_hb_pwr2(hb_val.period);
   100b4:	f89d 200a 	ldrb.w	r2, [sp, #10]
	pub.dst = hb_val.dst;
   100b8:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   100bc:	f8ad 3010 	strh.w	r3, [sp, #16]
 * SPDX-License-Identifier: Apache-2.0
 */

static inline uint16_t bt_mesh_hb_pwr2(uint8_t val)
{
	if (!val) {
   100c0:	b302      	cbz	r2, 10104 <hb_pub_set+0x84>
		return 0x0000;
	} else if (val == 0xff || val == 0x11) {
   100c2:	2aff      	cmp	r2, #255	; 0xff
   100c4:	d020      	beq.n	10108 <hb_pub_set+0x88>
   100c6:	2a11      	cmp	r2, #17
   100c8:	d01e      	beq.n	10108 <hb_pub_set+0x88>
		return 0xffff;
	} else {
		return (1 << (val - 1));
   100ca:	3a01      	subs	r2, #1
   100cc:	2301      	movs	r3, #1
   100ce:	4093      	lsls	r3, r2
   100d0:	b29b      	uxth	r3, r3
	pub.period = bt_mesh_hb_pwr2(hb_val.period);
   100d2:	9307      	str	r3, [sp, #28]
	pub.ttl = hb_val.ttl;
   100d4:	f89d 300b 	ldrb.w	r3, [sp, #11]
   100d8:	f88d 3014 	strb.w	r3, [sp, #20]
	pub.feat = hb_val.feat;
   100dc:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   100e0:	f8ad 3016 	strh.w	r3, [sp, #22]
	pub.net_idx = hb_val.net_idx;
   100e4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   100e8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   100ec:	f8ad 3018 	strh.w	r3, [sp, #24]
	if (hb_val.indefinite) {
   100f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
	(void)bt_mesh_hb_pub_set(&pub);
   100f4:	a804      	add	r0, sp, #16
	if (hb_val.indefinite) {
   100f6:	f343 1300 	sbfx	r3, r3, #4, #1
   100fa:	f8ad 3012 	strh.w	r3, [sp, #18]
	(void)bt_mesh_hb_pub_set(&pub);
   100fe:	f7ff ff79 	bl	fff4 <bt_mesh_hb_pub_set>
	return 0;
   10102:	e7d4      	b.n	100ae <hb_pub_set+0x2e>
		return 0x0000;
   10104:	4603      	mov	r3, r0
   10106:	e7e4      	b.n	100d2 <hb_pub_set+0x52>
		return 0xffff;
   10108:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1010c:	e7e1      	b.n	100d2 <hb_pub_set+0x52>
   1010e:	bf00      	nop
   10110:	00031699 	.word	0x00031699
   10114:	0002db1c 	.word	0x0002db1c

00010118 <bt_mesh_hb_pub_get>:
	*get = pub;
   10118:	4b03      	ldr	r3, [pc, #12]	; (10128 <bt_mesh_hb_pub_get+0x10>)
{
   1011a:	b510      	push	{r4, lr}
   1011c:	4604      	mov	r4, r0
	*get = pub;
   1011e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   10120:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
   10124:	bd10      	pop	{r4, pc}
   10126:	bf00      	nop
   10128:	20002760 	.word	0x20002760

0001012c <bt_mesh_hb_sub_set>:
{
   1012c:	b570      	push	{r4, r5, r6, lr}
	if (src != BT_MESH_ADDR_UNASSIGNED && !BT_MESH_ADDR_IS_UNICAST(src)) {
   1012e:	0403      	lsls	r3, r0, #16
{
   10130:	b088      	sub	sp, #32
   10132:	4606      	mov	r6, r0
   10134:	460c      	mov	r4, r1
   10136:	4615      	mov	r5, r2
	if (src != BT_MESH_ADDR_UNASSIGNED && !BT_MESH_ADDR_IS_UNICAST(src)) {
   10138:	d50e      	bpl.n	10158 <bt_mesh_hb_sub_set+0x2c>
		BT_WARN("Prohibited source address");
   1013a:	4b2d      	ldr	r3, [pc, #180]	; (101f0 <bt_mesh_hb_sub_set+0xc4>)
		BT_WARN("Prohibited destination address");
   1013c:	9306      	str	r3, [sp, #24]
   1013e:	2302      	movs	r3, #2
   10140:	9301      	str	r3, [sp, #4]
   10142:	9305      	str	r3, [sp, #20]
   10144:	482b      	ldr	r0, [pc, #172]	; (101f4 <bt_mesh_hb_sub_set+0xc8>)
   10146:	2300      	movs	r3, #0
   10148:	aa05      	add	r2, sp, #20
   1014a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1014e:	f015 fdc3 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return STATUS_INVALID_ADDRESS;
   10152:	2001      	movs	r0, #1
}
   10154:	b008      	add	sp, #32
   10156:	bd70      	pop	{r4, r5, r6, pc}
	if (BT_MESH_ADDR_IS_VIRTUAL(dst) || BT_MESH_ADDR_IS_RFU(dst) ||
   10158:	f481 4300 	eor.w	r3, r1, #32768	; 0x8000
   1015c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   10160:	d201      	bcs.n	10166 <bt_mesh_hb_sub_set+0x3a>
		BT_WARN("Prohibited destination address");
   10162:	4b25      	ldr	r3, [pc, #148]	; (101f8 <bt_mesh_hb_sub_set+0xcc>)
   10164:	e7ea      	b.n	1013c <bt_mesh_hb_sub_set+0x10>
	if (BT_MESH_ADDR_IS_VIRTUAL(dst) || BT_MESH_ADDR_IS_RFU(dst) ||
   10166:	f501 7380 	add.w	r3, r1, #256	; 0x100
   1016a:	b29b      	uxth	r3, r3
   1016c:	2bfb      	cmp	r3, #251	; 0xfb
   1016e:	d9f8      	bls.n	10162 <bt_mesh_hb_sub_set+0x36>
   10170:	b20b      	sxth	r3, r1
   10172:	2b00      	cmp	r3, #0
   10174:	dd03      	ble.n	1017e <bt_mesh_hb_sub_set+0x52>
	    (BT_MESH_ADDR_IS_UNICAST(dst) && dst != bt_mesh_primary_addr())) {
   10176:	f000 fe75 	bl	10e64 <bt_mesh_primary_addr>
   1017a:	42a0      	cmp	r0, r4
   1017c:	d1f1      	bne.n	10162 <bt_mesh_hb_sub_set+0x36>
	if (period > (1U << 16)) {
   1017e:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
   10182:	d90e      	bls.n	101a2 <bt_mesh_hb_sub_set+0x76>
		BT_WARN("Prohibited subscription period %u s", period);
   10184:	4b1d      	ldr	r3, [pc, #116]	; (101fc <bt_mesh_hb_sub_set+0xd0>)
   10186:	e9cd 3506 	strd	r3, r5, [sp, #24]
   1018a:	2303      	movs	r3, #3
   1018c:	9301      	str	r3, [sp, #4]
   1018e:	9305      	str	r3, [sp, #20]
   10190:	4818      	ldr	r0, [pc, #96]	; (101f4 <bt_mesh_hb_sub_set+0xc8>)
   10192:	2300      	movs	r3, #0
   10194:	aa05      	add	r2, sp, #20
   10196:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   1019a:	f015 fd9d 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return STATUS_CANNOT_SET;
   1019e:	200f      	movs	r0, #15
   101a0:	e7d8      	b.n	10154 <bt_mesh_hb_sub_set+0x28>
	if (src == BT_MESH_ADDR_UNASSIGNED || dst == BT_MESH_ADDR_UNASSIGNED) {
   101a2:	4b17      	ldr	r3, [pc, #92]	; (10200 <bt_mesh_hb_sub_set+0xd4>)
   101a4:	b106      	cbz	r6, 101a8 <bt_mesh_hb_sub_set+0x7c>
   101a6:	b9dc      	cbnz	r4, 101e0 <bt_mesh_hb_sub_set+0xb4>
		sub.src = BT_MESH_ADDR_UNASSIGNED;
   101a8:	2200      	movs	r2, #0
		sub.count = 0U;
   101aa:	e9c3 2202 	strd	r2, r2, [r3, #8]
		sub.period = 0U;
   101ae:	601a      	str	r2, [r3, #0]
	k_work_reschedule(&sub_timer, K_SECONDS(sub.period));
   101b0:	681d      	ldr	r5, [r3, #0]
			return ((t * to_hz + off) / from_hz);
   101b2:	2400      	movs	r4, #0
   101b4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   101b8:	435d      	muls	r5, r3
   101ba:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   101be:	f240 30e7 	movw	r0, #999	; 0x3e7
   101c2:	4621      	mov	r1, r4
   101c4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   101c8:	2300      	movs	r3, #0
   101ca:	fbe5 0106 	umlal	r0, r1, r5, r6
   101ce:	f7ef ff87 	bl	e0 <__aeabi_uldivmod>
   101d2:	4602      	mov	r2, r0
   101d4:	460b      	mov	r3, r1
   101d6:	480b      	ldr	r0, [pc, #44]	; (10204 <bt_mesh_hb_sub_set+0xd8>)
   101d8:	f014 f8c4 	bl	24364 <k_work_reschedule>
	return STATUS_SUCCESS;
   101dc:	4620      	mov	r0, r4
   101de:	e7b9      	b.n	10154 <bt_mesh_hb_sub_set+0x28>
	} else if (period) {
   101e0:	b125      	cbz	r5, 101ec <bt_mesh_hb_sub_set+0xc0>
		sub.count = 0U;
   101e2:	f44f 02fe 	mov.w	r2, #8323072	; 0x7f0000
		sub.src = src;
   101e6:	811e      	strh	r6, [r3, #8]
		sub.dst = dst;
   101e8:	815c      	strh	r4, [r3, #10]
		sub.count = 0U;
   101ea:	60da      	str	r2, [r3, #12]
		sub.period = 0U;
   101ec:	601d      	str	r5, [r3, #0]
   101ee:	e7df      	b.n	101b0 <bt_mesh_hb_sub_set+0x84>
   101f0:	000316b0 	.word	0x000316b0
   101f4:	0002db1c 	.word	0x0002db1c
   101f8:	000316ca 	.word	0x000316ca
   101fc:	000316e9 	.word	0x000316e9
   10200:	20002770 	.word	0x20002770
   10204:	20001e28 	.word	0x20001e28

00010208 <bt_mesh_hb_sub_reset_count>:
	sub.count = 0;
   10208:	4b01      	ldr	r3, [pc, #4]	; (10210 <bt_mesh_hb_sub_reset_count+0x8>)
   1020a:	2200      	movs	r2, #0
   1020c:	819a      	strh	r2, [r3, #12]
}
   1020e:	4770      	bx	lr
   10210:	20002770 	.word	0x20002770

00010214 <bt_mesh_hb_sub_get>:
{
   10214:	b538      	push	{r3, r4, r5, lr}
	*get = sub;
   10216:	4d0b      	ldr	r5, [pc, #44]	; (10244 <bt_mesh_hb_sub_get+0x30>)
{
   10218:	4604      	mov	r4, r0
	*get = sub;
   1021a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1021e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	if (sub.dst == BT_MESH_ADDR_UNASSIGNED) {
   10222:	896b      	ldrh	r3, [r5, #10]
   10224:	b15b      	cbz	r3, 1023e <bt_mesh_hb_sub_get+0x2a>
   10226:	4808      	ldr	r0, [pc, #32]	; (10248 <bt_mesh_hb_sub_get+0x34>)
   10228:	f01c ff54 	bl	2d0d4 <z_timeout_remaining>
			return (uint32_t)((t * to_hz + off) / from_hz);
   1022c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10230:	fba0 3002 	umull	r3, r0, r0, r2
   10234:	0bdb      	lsrs	r3, r3, #15
   10236:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
	return rem_ms / MSEC_PER_SEC;
   1023a:	fbb3 f3f2 	udiv	r3, r3, r2
	get->remaining = sub_remaining();
   1023e:	6063      	str	r3, [r4, #4]
}
   10240:	bd38      	pop	{r3, r4, r5, pc}
   10242:	bf00      	nop
   10244:	20002770 	.word	0x20002770
   10248:	20001e38 	.word	0x20001e38

0001024c <bt_mesh_hb_feature_changed>:
	if (pub.dst == BT_MESH_ADDR_UNASSIGNED) {
   1024c:	4b04      	ldr	r3, [pc, #16]	; (10260 <bt_mesh_hb_feature_changed+0x14>)
   1024e:	881a      	ldrh	r2, [r3, #0]
   10250:	b12a      	cbz	r2, 1025e <bt_mesh_hb_feature_changed+0x12>
	if (!(pub.feat & features)) {
   10252:	88db      	ldrh	r3, [r3, #6]
   10254:	4218      	tst	r0, r3
   10256:	d002      	beq.n	1025e <bt_mesh_hb_feature_changed+0x12>
	heartbeat_send(NULL, NULL);
   10258:	2000      	movs	r0, #0
   1025a:	f7ff bddb 	b.w	fe14 <heartbeat_send.constprop.0>
}
   1025e:	4770      	bx	lr
   10260:	20002760 	.word	0x20002760

00010264 <bt_mesh_hb_init>:
{
   10264:	b508      	push	{r3, lr}
	pub.net_idx = BT_MESH_KEY_UNUSED;
   10266:	4b07      	ldr	r3, [pc, #28]	; (10284 <bt_mesh_hb_init+0x20>)
	k_work_init_delayable(&pub_timer, hb_publish);
   10268:	4907      	ldr	r1, [pc, #28]	; (10288 <bt_mesh_hb_init+0x24>)
   1026a:	4808      	ldr	r0, [pc, #32]	; (1028c <bt_mesh_hb_init+0x28>)
	pub.net_idx = BT_MESH_KEY_UNUSED;
   1026c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10270:	811a      	strh	r2, [r3, #8]
	k_work_init_delayable(&pub_timer, hb_publish);
   10272:	f01c fdba 	bl	2cdea <k_work_init_delayable>
}
   10276:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_work_init_delayable(&sub_timer, sub_end);
   1027a:	4905      	ldr	r1, [pc, #20]	; (10290 <bt_mesh_hb_init+0x2c>)
   1027c:	4805      	ldr	r0, [pc, #20]	; (10294 <bt_mesh_hb_init+0x30>)
   1027e:	f01c bdb4 	b.w	2cdea <k_work_init_delayable>
   10282:	bf00      	nop
   10284:	20002760 	.word	0x20002760
   10288:	0000feb5 	.word	0x0000feb5
   1028c:	20001df8 	.word	0x20001df8
   10290:	0000fd99 	.word	0x0000fd99
   10294:	20001e28 	.word	0x20001e28

00010298 <bt_mesh_hb_start>:
	if (pub.count && pub.period) {
   10298:	4b05      	ldr	r3, [pc, #20]	; (102b0 <bt_mesh_hb_start+0x18>)
   1029a:	885a      	ldrh	r2, [r3, #2]
   1029c:	b132      	cbz	r2, 102ac <bt_mesh_hb_start+0x14>
   1029e:	68db      	ldr	r3, [r3, #12]
   102a0:	b123      	cbz	r3, 102ac <bt_mesh_hb_start+0x14>
		k_work_reschedule(&pub_timer, K_NO_WAIT);
   102a2:	4804      	ldr	r0, [pc, #16]	; (102b4 <bt_mesh_hb_start+0x1c>)
   102a4:	2200      	movs	r2, #0
   102a6:	2300      	movs	r3, #0
   102a8:	f014 b85c 	b.w	24364 <k_work_reschedule>
}
   102ac:	4770      	bx	lr
   102ae:	bf00      	nop
   102b0:	20002760 	.word	0x20002760
   102b4:	20001df8 	.word	0x20001df8

000102b8 <bt_mesh_hb_pub_pending_store>:

BT_MESH_SETTINGS_DEFINE(pub, "HBPub", hb_pub_set);

void bt_mesh_hb_pub_pending_store(void)
{
   102b8:	b500      	push	{lr}
   102ba:	b08f      	sub	sp, #60	; 0x3c
	struct bt_mesh_hb_pub pub;
	struct hb_pub_val val;
	int err;

	bt_mesh_hb_pub_get(&pub);
   102bc:	a804      	add	r0, sp, #16
   102be:	f7ff ff2b 	bl	10118 <bt_mesh_hb_pub_get>
	if (pub.dst == BT_MESH_ADDR_UNASSIGNED) {
   102c2:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   102c6:	b991      	cbnz	r1, 102ee <bt_mesh_hb_pub_pending_store+0x36>
		err = settings_delete("bt/mesh/HBPub");
   102c8:	4822      	ldr	r0, [pc, #136]	; (10354 <bt_mesh_hb_pub_pending_store+0x9c>)
   102ca:	f015 ff94 	bl	261f6 <settings_delete>
		val.net_idx = pub.net_idx;

		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
	}

	if (err) {
   102ce:	b158      	cbz	r0, 102e8 <bt_mesh_hb_pub_pending_store+0x30>
		BT_ERR("Failed to store Heartbeat Publication");
   102d0:	4b21      	ldr	r3, [pc, #132]	; (10358 <bt_mesh_hb_pub_pending_store+0xa0>)
   102d2:	930c      	str	r3, [sp, #48]	; 0x30
   102d4:	2302      	movs	r3, #2
   102d6:	9301      	str	r3, [sp, #4]
   102d8:	930b      	str	r3, [sp, #44]	; 0x2c
   102da:	4820      	ldr	r0, [pc, #128]	; (1035c <bt_mesh_hb_pub_pending_store+0xa4>)
   102dc:	2300      	movs	r3, #0
   102de:	aa0b      	add	r2, sp, #44	; 0x2c
   102e0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   102e4:	f015 fcf8 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	} else {
		BT_DBG("Stored Heartbeat Publication");
	}
}
   102e8:	b00f      	add	sp, #60	; 0x3c
   102ea:	f85d fb04 	ldr.w	pc, [sp], #4
		val.indefinite = (pub.count == 0xffff);
   102ee:	f8bd 3012 	ldrh.w	r3, [sp, #18]
		val.dst = pub.dst;
   102f2:	f8ad 1008 	strh.w	r1, [sp, #8]
		val.indefinite = (pub.count == 0xffff);
   102f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   102fa:	1a98      	subs	r0, r3, r2
   102fc:	4243      	negs	r3, r0
   102fe:	4143      	adcs	r3, r0
   10300:	f89d 000f 	ldrb.w	r0, [sp, #15]
   10304:	f363 1004 	bfi	r0, r3, #4, #1
		val.period = bt_mesh_hb_log(pub.period);
   10308:	9b07      	ldr	r3, [sp, #28]
		val.indefinite = (pub.count == 0xffff);
   1030a:	f88d 000f 	strb.w	r0, [sp, #15]
	}
}

static inline uint8_t bt_mesh_hb_log(uint32_t val)
{
	if (!val) {
   1030e:	b13b      	cbz	r3, 10320 <bt_mesh_hb_pub_pending_store+0x68>
		return 0x00;
	} else if (val == 0xffff) {
   10310:	4293      	cmp	r3, r2
		return 0xff;
	} else {
		return 32 - __builtin_clz(val);
   10312:	bf1d      	ittte	ne
   10314:	fab3 f383 	clzne	r3, r3
   10318:	f1c3 0320 	rsbne	r3, r3, #32
   1031c:	b2db      	uxtbne	r3, r3
		return 0xff;
   1031e:	23ff      	moveq	r3, #255	; 0xff
		val.period = bt_mesh_hb_log(pub.period);
   10320:	f88d 300a 	strb.w	r3, [sp, #10]
		val.ttl = pub.ttl;
   10324:	f89d 3014 	ldrb.w	r3, [sp, #20]
   10328:	f88d 300b 	strb.w	r3, [sp, #11]
		val.feat = pub.feat;
   1032c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
		val.net_idx = pub.net_idx;
   10330:	f8bd 2018 	ldrh.w	r2, [sp, #24]
		val.feat = pub.feat;
   10334:	f8ad 300c 	strh.w	r3, [sp, #12]
		val.net_idx = pub.net_idx;
   10338:	f8bd 300e 	ldrh.w	r3, [sp, #14]
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   1033c:	4805      	ldr	r0, [pc, #20]	; (10354 <bt_mesh_hb_pub_pending_store+0x9c>)
		val.net_idx = pub.net_idx;
   1033e:	f362 030b 	bfi	r3, r2, #0, #12
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   10342:	2208      	movs	r2, #8
   10344:	eb0d 0102 	add.w	r1, sp, r2
		val.net_idx = pub.net_idx;
   10348:	f8ad 300e 	strh.w	r3, [sp, #14]
		err = settings_save_one("bt/mesh/HBPub", &val, sizeof(val));
   1034c:	f7f3 fc58 	bl	3c00 <settings_save_one>
   10350:	e7bd      	b.n	102ce <bt_mesh_hb_pub_pending_store+0x16>
   10352:	bf00      	nop
   10354:	0003170d 	.word	0x0003170d
   10358:	0003171b 	.word	0x0003171b
   1035c:	0002db1c 	.word	0x0002db1c

00010360 <bt_mesh_k2>:
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
}

int bt_mesh_k2(const uint8_t n[16], const uint8_t *p, size_t p_len,
	       uint8_t net_id[1], uint8_t enc_key[16], uint8_t priv_key[16])
{
   10360:	b5f0      	push	{r4, r5, r6, r7, lr}
   10362:	b095      	sub	sp, #84	; 0x54
   10364:	4604      	mov	r4, r0
   10366:	460f      	mov	r7, r1
	int err;

	BT_DBG("n %s", bt_hex(n, 16));
	BT_DBG("p %s", bt_hex(p, p_len));

	err = bt_mesh_s1("smk2", salt);
   10368:	4828      	ldr	r0, [pc, #160]	; (1040c <bt_mesh_k2+0xac>)
   1036a:	a902      	add	r1, sp, #8
{
   1036c:	4615      	mov	r5, r2
   1036e:	461e      	mov	r6, r3
	err = bt_mesh_s1("smk2", salt);
   10370:	f019 fcaa 	bl	29cc8 <bt_mesh_s1>
	if (err) {
   10374:	2800      	cmp	r0, #0
   10376:	d146      	bne.n	10406 <bt_mesh_k2+0xa6>
		return err;
	}

	err = bt_mesh_aes_cmac_one(salt, n, 16, t);
   10378:	4621      	mov	r1, r4
   1037a:	ab0a      	add	r3, sp, #40	; 0x28
   1037c:	2210      	movs	r2, #16
   1037e:	a802      	add	r0, sp, #8
   10380:	f019 fc98 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   10384:	4604      	mov	r4, r0
   10386:	2800      	cmp	r0, #0
   10388:	d13a      	bne.n	10400 <bt_mesh_k2+0xa0>
		return err;
	}

	pad = 0x01;
   1038a:	2301      	movs	r3, #1

	sg[0].data = NULL;
	sg[0].len  = 0;
	sg[1].data = p;
	sg[1].len  = p_len;
   1038c:	e9cd 7510 	strd	r7, r5, [sp, #64]	; 0x40
	sg[2].data = &pad;
   10390:	f10d 0207 	add.w	r2, sp, #7
	sg[2].len  = sizeof(pad);

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   10394:	ad06      	add	r5, sp, #24
	sg[2].len  = sizeof(pad);
   10396:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
	sg[0].len  = 0;
   1039a:	e9cd 000e 	strd	r0, r0, [sp, #56]	; 0x38
	pad = 0x01;
   1039e:	f88d 3007 	strb.w	r3, [sp, #7]
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   103a2:	2203      	movs	r2, #3
   103a4:	462b      	mov	r3, r5
   103a6:	a90e      	add	r1, sp, #56	; 0x38
   103a8:	a80a      	add	r0, sp, #40	; 0x28
   103aa:	f019 fc61 	bl	29c70 <bt_mesh_aes_cmac>
	if (err) {
   103ae:	4604      	mov	r4, r0
   103b0:	bb30      	cbnz	r0, 10400 <bt_mesh_k2+0xa0>
		return err;
	}

	net_id[0] = out[15] & 0x7f;
   103b2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27

	sg[0].data = out;
   103b6:	950e      	str	r5, [sp, #56]	; 0x38
	net_id[0] = out[15] & 0x7f;
   103b8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   103bc:	7033      	strb	r3, [r6, #0]
	sg[0].len  = sizeof(out);
	pad = 0x02;
   103be:	2302      	movs	r3, #2
   103c0:	f88d 3007 	strb.w	r3, [sp, #7]
	sg[0].len  = sizeof(out);
   103c4:	2610      	movs	r6, #16

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   103c6:	462b      	mov	r3, r5
   103c8:	2203      	movs	r2, #3
   103ca:	a90e      	add	r1, sp, #56	; 0x38
   103cc:	a80a      	add	r0, sp, #40	; 0x28
	sg[0].len  = sizeof(out);
   103ce:	960f      	str	r6, [sp, #60]	; 0x3c
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   103d0:	f019 fc4e 	bl	29c70 <bt_mesh_aes_cmac>
	if (err) {
   103d4:	4604      	mov	r4, r0
   103d6:	b998      	cbnz	r0, 10400 <bt_mesh_k2+0xa0>
		return err;
	}

	memcpy(enc_key, out, 16);
   103d8:	4632      	mov	r2, r6
   103da:	4629      	mov	r1, r5
   103dc:	981a      	ldr	r0, [sp, #104]	; 0x68
   103de:	f017 fa47 	bl	27870 <memcpy>

	pad = 0x03;
   103e2:	2203      	movs	r2, #3

	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   103e4:	462b      	mov	r3, r5
   103e6:	a90e      	add	r1, sp, #56	; 0x38
   103e8:	a80a      	add	r0, sp, #40	; 0x28
	pad = 0x03;
   103ea:	f88d 2007 	strb.w	r2, [sp, #7]
	err = bt_mesh_aes_cmac(t, sg, ARRAY_SIZE(sg), out);
   103ee:	f019 fc3f 	bl	29c70 <bt_mesh_aes_cmac>
	if (err) {
   103f2:	4604      	mov	r4, r0
   103f4:	b920      	cbnz	r0, 10400 <bt_mesh_k2+0xa0>
		return err;
	}

	memcpy(priv_key, out, 16);
   103f6:	981b      	ldr	r0, [sp, #108]	; 0x6c
   103f8:	4632      	mov	r2, r6
   103fa:	4629      	mov	r1, r5
   103fc:	f017 fa38 	bl	27870 <memcpy>

	BT_DBG("NID 0x%02x enc_key %s", net_id[0], bt_hex(enc_key, 16));
	BT_DBG("priv_key %s", bt_hex(priv_key, 16));

	return 0;
}
   10400:	4620      	mov	r0, r4
   10402:	b015      	add	sp, #84	; 0x54
   10404:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return err;
   10406:	2401      	movs	r4, #1
   10408:	e7fa      	b.n	10400 <bt_mesh_k2+0xa0>
   1040a:	bf00      	nop
   1040c:	0003174c 	.word	0x0003174c

00010410 <bt_mesh_k3>:

int bt_mesh_k3(const uint8_t n[16], uint8_t out[8])
{
   10410:	b530      	push	{r4, r5, lr}
	uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
   10412:	4b14      	ldr	r3, [pc, #80]	; (10464 <bt_mesh_k3+0x54>)
{
   10414:	b08b      	sub	sp, #44	; 0x2c
   10416:	4604      	mov	r4, r0
	uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
   10418:	6818      	ldr	r0, [r3, #0]
   1041a:	9000      	str	r0, [sp, #0]
   1041c:	791b      	ldrb	r3, [r3, #4]
	uint8_t tmp[16];
	uint8_t t[16];
	int err;

	err = bt_mesh_s1("smk3", tmp);
   1041e:	4812      	ldr	r0, [pc, #72]	; (10468 <bt_mesh_k3+0x58>)
	uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
   10420:	f88d 3004 	strb.w	r3, [sp, #4]
{
   10424:	460d      	mov	r5, r1
	err = bt_mesh_s1("smk3", tmp);
   10426:	a902      	add	r1, sp, #8
   10428:	f019 fc4e 	bl	29cc8 <bt_mesh_s1>
	if (err) {
   1042c:	b9b8      	cbnz	r0, 1045e <bt_mesh_k3+0x4e>
		return err;
	}

	err = bt_mesh_aes_cmac_one(tmp, n, 16, t);
   1042e:	4621      	mov	r1, r4
   10430:	ab06      	add	r3, sp, #24
   10432:	2210      	movs	r2, #16
   10434:	a802      	add	r0, sp, #8
   10436:	f019 fc3d 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   1043a:	4604      	mov	r4, r0
   1043c:	b960      	cbnz	r0, 10458 <bt_mesh_k3+0x48>
		return err;
	}

	err = bt_mesh_aes_cmac_one(t, id64, sizeof(id64), tmp);
   1043e:	ab02      	add	r3, sp, #8
   10440:	2205      	movs	r2, #5
   10442:	4669      	mov	r1, sp
   10444:	a806      	add	r0, sp, #24
   10446:	f019 fc35 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   1044a:	4604      	mov	r4, r0
   1044c:	b920      	cbnz	r0, 10458 <bt_mesh_k3+0x48>
		return err;
	}

	memcpy(out, tmp + 8, 8);
   1044e:	2208      	movs	r2, #8
   10450:	a904      	add	r1, sp, #16
   10452:	4628      	mov	r0, r5
   10454:	f017 fa0c 	bl	27870 <memcpy>

	return 0;
}
   10458:	4620      	mov	r0, r4
   1045a:	b00b      	add	sp, #44	; 0x2c
   1045c:	bd30      	pop	{r4, r5, pc}
		return err;
   1045e:	2401      	movs	r4, #1
   10460:	e7fa      	b.n	10458 <bt_mesh_k3+0x48>
   10462:	bf00      	nop
   10464:	00031756 	.word	0x00031756
   10468:	00031751 	.word	0x00031751

0001046c <bt_mesh_k4>:

int bt_mesh_k4(const uint8_t n[16], uint8_t out[1])
{
   1046c:	b530      	push	{r4, r5, lr}
   1046e:	b08b      	sub	sp, #44	; 0x2c
	uint8_t id6[] = { 'i', 'd', '6', 0x01 };
   10470:	4b10      	ldr	r3, [pc, #64]	; (104b4 <bt_mesh_k4+0x48>)
   10472:	9301      	str	r3, [sp, #4]
{
   10474:	4605      	mov	r5, r0
   10476:	460c      	mov	r4, r1
	uint8_t tmp[16];
	uint8_t t[16];
	int err;

	err = bt_mesh_s1("smk4", tmp);
   10478:	480f      	ldr	r0, [pc, #60]	; (104b8 <bt_mesh_k4+0x4c>)
   1047a:	a902      	add	r1, sp, #8
   1047c:	f019 fc24 	bl	29cc8 <bt_mesh_s1>
	if (err) {
   10480:	b9a8      	cbnz	r0, 104ae <bt_mesh_k4+0x42>
		return err;
	}

	err = bt_mesh_aes_cmac_one(tmp, n, 16, t);
   10482:	ab06      	add	r3, sp, #24
   10484:	2210      	movs	r2, #16
   10486:	4629      	mov	r1, r5
   10488:	a802      	add	r0, sp, #8
   1048a:	f019 fc13 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   1048e:	b960      	cbnz	r0, 104aa <bt_mesh_k4+0x3e>
		return err;
	}

	err = bt_mesh_aes_cmac_one(t, id6, sizeof(id6), tmp);
   10490:	2204      	movs	r2, #4
   10492:	ab02      	add	r3, sp, #8
   10494:	eb0d 0102 	add.w	r1, sp, r2
   10498:	a806      	add	r0, sp, #24
   1049a:	f019 fc0b 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   1049e:	b920      	cbnz	r0, 104aa <bt_mesh_k4+0x3e>
		return err;
	}

	out[0] = tmp[15] & BIT_MASK(6);
   104a0:	f89d 3017 	ldrb.w	r3, [sp, #23]
   104a4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   104a8:	7023      	strb	r3, [r4, #0]

	return 0;
}
   104aa:	b00b      	add	sp, #44	; 0x2c
   104ac:	bd30      	pop	{r4, r5, pc}
		return err;
   104ae:	2001      	movs	r0, #1
   104b0:	e7fb      	b.n	104aa <bt_mesh_k4+0x3e>
   104b2:	bf00      	nop
   104b4:	01366469 	.word	0x01366469
   104b8:	0003175c 	.word	0x0003175c

000104bc <bt_mesh_id128>:

int bt_mesh_id128(const uint8_t n[16], const char *s, uint8_t out[16])
{
   104bc:	b530      	push	{r4, r5, lr}
   104be:	b087      	sub	sp, #28
   104c0:	4604      	mov	r4, r0
   104c2:	4608      	mov	r0, r1
	const char *id128 = "id128\x01";
	uint8_t salt[16];
	int err;

	err = bt_mesh_s1(s, salt);
   104c4:	a902      	add	r1, sp, #8
{
   104c6:	4615      	mov	r5, r2
	err = bt_mesh_s1(s, salt);
   104c8:	f019 fbfe 	bl	29cc8 <bt_mesh_s1>
	if (err) {
   104cc:	b940      	cbnz	r0, 104e0 <bt_mesh_id128+0x24>
		return err;
	}

	return bt_mesh_k1(n, 16, salt, id128, out);
   104ce:	4b05      	ldr	r3, [pc, #20]	; (104e4 <bt_mesh_id128+0x28>)
   104d0:	9500      	str	r5, [sp, #0]
   104d2:	aa02      	add	r2, sp, #8
   104d4:	2110      	movs	r1, #16
   104d6:	4620      	mov	r0, r4
   104d8:	f019 fc0c 	bl	29cf4 <bt_mesh_k1>
}
   104dc:	b007      	add	sp, #28
   104de:	bd30      	pop	{r4, r5, pc}
		return err;
   104e0:	2001      	movs	r0, #1
   104e2:	e7fb      	b.n	104dc <bt_mesh_id128+0x20>
   104e4:	00031761 	.word	0x00031761

000104e8 <bt_mesh_net_obfuscate>:
	sys_put_be32(iv_index, &nonce[9]);
}

int bt_mesh_net_obfuscate(uint8_t *pdu, uint32_t iv_index,
			  const uint8_t privacy_key[16])
{
   104e8:	b570      	push	{r4, r5, r6, lr}
	uint8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
   104ea:	4b18      	ldr	r3, [pc, #96]	; (1054c <bt_mesh_net_obfuscate+0x64>)
{
   104ec:	b088      	sub	sp, #32
   104ee:	4604      	mov	r4, r0
   104f0:	460e      	mov	r6, r1
	uint8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
   104f2:	6818      	ldr	r0, [r3, #0]
   104f4:	889b      	ldrh	r3, [r3, #4]
   104f6:	9000      	str	r0, [sp, #0]
   104f8:	f8ad 3004 	strh.w	r3, [sp, #4]
	uint8_t tmp[16];
	int err, i;

	BT_DBG("IVIndex %u, PrivacyKey %s", iv_index, bt_hex(privacy_key, 16));

	sys_put_be32(iv_index, &priv_rand[5]);
   104fc:	f10d 0105 	add.w	r1, sp, #5
	uint8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
   10500:	2300      	movs	r3, #0
	sys_put_be32(iv_index, &priv_rand[5]);
   10502:	4630      	mov	r0, r6
{
   10504:	4615      	mov	r5, r2
	uint8_t priv_rand[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, };
   10506:	f8cd 3006 	str.w	r3, [sp, #6]
   1050a:	f8cd 300a 	str.w	r3, [sp, #10]
   1050e:	f8ad 300e 	strh.w	r3, [sp, #14]
	sys_put_be32(iv_index, &priv_rand[5]);
   10512:	f019 fb84 	bl	29c1e <sys_put_be32>
	memcpy(&priv_rand[9], &pdu[7], 7);
   10516:	2207      	movs	r2, #7
   10518:	18a1      	adds	r1, r4, r2
   1051a:	f10d 0009 	add.w	r0, sp, #9
   1051e:	f017 f9a7 	bl	27870 <memcpy>

	BT_DBG("PrivacyRandom %s", bt_hex(priv_rand, 16));

	err = bt_encrypt_be(privacy_key, priv_rand, tmp);
   10522:	aa04      	add	r2, sp, #16
   10524:	4669      	mov	r1, sp
   10526:	4628      	mov	r0, r5
   10528:	f01a fcf1 	bl	2af0e <bt_encrypt_be>
	if (err) {
   1052c:	b958      	cbnz	r0, 10546 <bt_mesh_net_obfuscate+0x5e>
   1052e:	4623      	mov	r3, r4
   10530:	aa04      	add	r2, sp, #16
   10532:	3406      	adds	r4, #6
		return err;
	}

	for (i = 0; i < 6; i++) {
		pdu[1 + i] ^= tmp[i];
   10534:	f813 5f01 	ldrb.w	r5, [r3, #1]!
   10538:	f812 1b01 	ldrb.w	r1, [r2], #1
	for (i = 0; i < 6; i++) {
   1053c:	42a3      	cmp	r3, r4
		pdu[1 + i] ^= tmp[i];
   1053e:	ea81 0105 	eor.w	r1, r1, r5
   10542:	7019      	strb	r1, [r3, #0]
	for (i = 0; i < 6; i++) {
   10544:	d1f6      	bne.n	10534 <bt_mesh_net_obfuscate+0x4c>
	}

	return 0;
}
   10546:	b008      	add	sp, #32
   10548:	bd70      	pop	{r4, r5, r6, pc}
   1054a:	bf00      	nop
   1054c:	0002dd57 	.word	0x0002dd57

00010550 <bt_mesh_fcs_calc>:
	0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,
	0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf
};

uint8_t bt_mesh_fcs_calc(const uint8_t *data, uint8_t data_len)
{
   10550:	b510      	push	{r4, lr}
	uint8_t fcs = 0xff;

	while (data_len--) {
		fcs = crc_table[fcs ^ *data++];
   10552:	4a06      	ldr	r2, [pc, #24]	; (1056c <bt_mesh_fcs_calc+0x1c>)
   10554:	4401      	add	r1, r0
	uint8_t fcs = 0xff;
   10556:	23ff      	movs	r3, #255	; 0xff
	while (data_len--) {
   10558:	4288      	cmp	r0, r1
   1055a:	d102      	bne.n	10562 <bt_mesh_fcs_calc+0x12>
	}

	BT_DBG("fcs 0x%02x", 0xff - fcs);

	return 0xff - fcs;
   1055c:	43d8      	mvns	r0, r3
}
   1055e:	b2c0      	uxtb	r0, r0
   10560:	bd10      	pop	{r4, pc}
		fcs = crc_table[fcs ^ *data++];
   10562:	f810 4b01 	ldrb.w	r4, [r0], #1
   10566:	4063      	eors	r3, r4
   10568:	5cd3      	ldrb	r3, [r2, r3]
   1056a:	e7f5      	b.n	10558 <bt_mesh_fcs_calc+0x8>
   1056c:	00031781 	.word	0x00031781

00010570 <bt_mesh_fcs_check>:

bool bt_mesh_fcs_check(struct net_buf_simple *buf, uint8_t received_fcs)
{
   10570:	b530      	push	{r4, r5, lr}
	const uint8_t *data = buf->data;
   10572:	6804      	ldr	r4, [r0, #0]
	uint16_t data_len = buf->len;
	uint8_t fcs = 0xff;

	while (data_len--) {
   10574:	8880      	ldrh	r0, [r0, #4]
   10576:	4d08      	ldr	r5, [pc, #32]	; (10598 <bt_mesh_fcs_check+0x28>)
   10578:	4420      	add	r0, r4
	uint8_t fcs = 0xff;
   1057a:	23ff      	movs	r3, #255	; 0xff
	while (data_len--) {
   1057c:	4284      	cmp	r4, r0
   1057e:	d106      	bne.n	1058e <bt_mesh_fcs_check+0x1e>
		fcs = crc_table[fcs ^ *data++];
	}

	return crc_table[fcs ^ received_fcs] == 0xcf;
   10580:	404b      	eors	r3, r1
   10582:	5ce8      	ldrb	r0, [r5, r3]
}
   10584:	f1a0 03cf 	sub.w	r3, r0, #207	; 0xcf
   10588:	4258      	negs	r0, r3
   1058a:	4158      	adcs	r0, r3
   1058c:	bd30      	pop	{r4, r5, pc}
		fcs = crc_table[fcs ^ *data++];
   1058e:	f814 2b01 	ldrb.w	r2, [r4], #1
   10592:	405a      	eors	r2, r3
   10594:	5cab      	ldrb	r3, [r5, r2]
   10596:	e7f1      	b.n	1057c <bt_mesh_fcs_check+0xc>
   10598:	00031781 	.word	0x00031781

0001059c <bt_mesh_virtual_addr>:

int bt_mesh_virtual_addr(const uint8_t virtual_label[16], uint16_t *addr)
{
   1059c:	b530      	push	{r4, r5, lr}
   1059e:	b089      	sub	sp, #36	; 0x24
   105a0:	4605      	mov	r5, r0
   105a2:	460c      	mov	r4, r1
	uint8_t salt[16];
	uint8_t tmp[16];
	int err;

	err = bt_mesh_s1("vtad", salt);
   105a4:	480c      	ldr	r0, [pc, #48]	; (105d8 <bt_mesh_virtual_addr+0x3c>)
   105a6:	4669      	mov	r1, sp
   105a8:	f019 fb8e 	bl	29cc8 <bt_mesh_s1>
	if (err) {
   105ac:	b990      	cbnz	r0, 105d4 <bt_mesh_virtual_addr+0x38>
		return err;
	}

	err = bt_mesh_aes_cmac_one(salt, virtual_label, 16, tmp);
   105ae:	ab04      	add	r3, sp, #16
   105b0:	2210      	movs	r2, #16
   105b2:	4629      	mov	r1, r5
   105b4:	4668      	mov	r0, sp
   105b6:	f019 fb7d 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err) {
   105ba:	b948      	cbnz	r0, 105d0 <bt_mesh_virtual_addr+0x34>
		return err;
	}

	*addr = (sys_get_be16(&tmp[14]) & 0x3fff) | 0x8000;
   105bc:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   105c0:	ba5b      	rev16	r3, r3
   105c2:	f3c3 030d 	ubfx	r3, r3, #0, #14
   105c6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
   105ca:	ea6f 4353 	mvn.w	r3, r3, lsr #17
   105ce:	8023      	strh	r3, [r4, #0]

	return 0;
}
   105d0:	b009      	add	sp, #36	; 0x24
   105d2:	bd30      	pop	{r4, r5, pc}
		return err;
   105d4:	2001      	movs	r0, #1
   105d6:	e7fb      	b.n	105d0 <bt_mesh_virtual_addr+0x34>
   105d8:	00031768 	.word	0x00031768

000105dc <bt_mesh_prov_conf_key>:
	return bt_mesh_aes_cmac_one(conf_salt_key, conf_inputs, 145, salt);
}

int bt_mesh_prov_conf_key(const uint8_t dhkey[32], const uint8_t conf_salt[16],
			  uint8_t conf_key[16])
{
   105dc:	b507      	push	{r0, r1, r2, lr}
	return bt_mesh_k1(dhkey, 32, conf_salt, "prck", conf_key);
   105de:	4b04      	ldr	r3, [pc, #16]	; (105f0 <bt_mesh_prov_conf_key+0x14>)
   105e0:	9200      	str	r2, [sp, #0]
   105e2:	460a      	mov	r2, r1
   105e4:	2120      	movs	r1, #32
   105e6:	f019 fb85 	bl	29cf4 <bt_mesh_k1>
}
   105ea:	b003      	add	sp, #12
   105ec:	f85d fb04 	ldr.w	pc, [sp], #4
   105f0:	0003176d 	.word	0x0003176d

000105f4 <mod_init>:
}
#endif

static void mod_init(struct bt_mesh_model *mod, struct bt_mesh_elem *elem,
		     bool vnd, bool primary, void *user_data)
{
   105f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   105f8:	b082      	sub	sp, #8
   105fa:	af00      	add	r7, sp, #0
   105fc:	4604      	mov	r4, r0
   105fe:	6a3d      	ldr	r5, [r7, #32]
	int i;
	int *err = user_data;

	if (*err) {
   10600:	682b      	ldr	r3, [r5, #0]
{
   10602:	460e      	mov	r6, r1
   10604:	4690      	mov	r8, r2
	if (*err) {
   10606:	2b00      	cmp	r3, #0
   10608:	d141      	bne.n	1068e <mod_init+0x9a>
		return;
	}

	if (mod->pub) {
   1060a:	6880      	ldr	r0, [r0, #8]
   1060c:	b120      	cbz	r0, 10618 <mod_init+0x24>
		mod->pub->mod = mod;
   1060e:	f840 4b18 	str.w	r4, [r0], #24
		k_work_init_delayable(&mod->pub->timer, mod_publish);
   10612:	4924      	ldr	r1, [pc, #144]	; (106a4 <mod_init+0xb0>)
   10614:	f01c fbe9 	bl	2cdea <k_work_init_delayable>
	}

	for (i = 0; i < ARRAY_SIZE(mod->keys); i++) {
		mod->keys[i] = BT_MESH_KEY_UNUSED;
   10618:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1061c:	81a3      	strh	r3, [r4, #12]
	}

	mod->elem_idx = elem - dev_comp->elem;
   1061e:	4b22      	ldr	r3, [pc, #136]	; (106a8 <mod_init+0xb4>)
   10620:	4a22      	ldr	r2, [pc, #136]	; (106ac <mod_init+0xb8>)
   10622:	681b      	ldr	r3, [r3, #0]
   10624:	68db      	ldr	r3, [r3, #12]
   10626:	1af3      	subs	r3, r6, r3
   10628:	111b      	asrs	r3, r3, #4
   1062a:	7123      	strb	r3, [r4, #4]
	if (vnd) {
   1062c:	f1b8 0f00 	cmp.w	r8, #0
   10630:	d031      	beq.n	10696 <mod_init+0xa2>
		mod->mod_idx = mod - elem->vnd_models;
   10632:	68f3      	ldr	r3, [r6, #12]
   10634:	1ae3      	subs	r3, r4, r3
   10636:	109b      	asrs	r3, r3, #2
   10638:	4353      	muls	r3, r2
   1063a:	7163      	strb	r3, [r4, #5]
	for (op = mod->op; op->func; op++) {
   1063c:	6963      	ldr	r3, [r4, #20]
   1063e:	689a      	ldr	r2, [r3, #8]
   10640:	b942      	cbnz	r2, 10654 <mod_init+0x60>

		if (IS_ENABLED(CONFIG_BT_MESH_MODEL_VND_MSG_CID_FORCE)) {
			*err = bt_mesh_vnd_mod_msg_cid_check(mod);
   10642:	602a      	str	r2, [r5, #0]

	} else {
		mod->mod_idx = mod - elem->models;
	}

	if (mod->cb && mod->cb->init) {
   10644:	69a3      	ldr	r3, [r4, #24]
   10646:	b313      	cbz	r3, 1068e <mod_init+0x9a>
   10648:	689b      	ldr	r3, [r3, #8]
   1064a:	b303      	cbz	r3, 1068e <mod_init+0x9a>
		*err = mod->cb->init(mod);
   1064c:	4620      	mov	r0, r4
   1064e:	4798      	blx	r3
   10650:	6028      	str	r0, [r5, #0]
   10652:	e01c      	b.n	1068e <mod_init+0x9a>
		if (cid == mod->vnd.company) {
   10654:	8821      	ldrh	r1, [r4, #0]
   10656:	881a      	ldrh	r2, [r3, #0]
   10658:	428a      	cmp	r2, r1
   1065a:	d101      	bne.n	10660 <mod_init+0x6c>
	for (op = mod->op; op->func; op++) {
   1065c:	330c      	adds	r3, #12
   1065e:	e7ee      	b.n	1063e <mod_init+0x4a>
		BT_ERR("Invalid vendor model(company:0x%04x"
   10660:	8860      	ldrh	r0, [r4, #2]
   10662:	4e13      	ldr	r6, [pc, #76]	; (106b0 <mod_init+0xbc>)
   10664:	466c      	mov	r4, sp
   10666:	b088      	sub	sp, #32
   10668:	466a      	mov	r2, sp
   1066a:	e9c2 6104 	strd	r6, r1, [r2, #16]
   1066e:	6190      	str	r0, [r2, #24]
   10670:	681b      	ldr	r3, [r3, #0]
   10672:	61d3      	str	r3, [r2, #28]
   10674:	2305      	movs	r3, #5
   10676:	f842 3f0c 	str.w	r3, [r2, #12]!
   1067a:	480e      	ldr	r0, [pc, #56]	; (106b4 <mod_init+0xc0>)
   1067c:	607b      	str	r3, [r7, #4]
   1067e:	f44f 5121 	mov.w	r1, #10304	; 0x2840
   10682:	f019 fca4 	bl	29fce <z_log_msg2_static_create.constprop.0>
			*err = bt_mesh_vnd_mod_msg_cid_check(mod);
   10686:	f06f 0315 	mvn.w	r3, #21
   1068a:	46a5      	mov	sp, r4
   1068c:	602b      	str	r3, [r5, #0]
	}
}
   1068e:	3708      	adds	r7, #8
   10690:	46bd      	mov	sp, r7
   10692:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		mod->mod_idx = mod - elem->models;
   10696:	68b3      	ldr	r3, [r6, #8]
   10698:	1ae3      	subs	r3, r4, r3
   1069a:	109b      	asrs	r3, r3, #2
   1069c:	4353      	muls	r3, r2
   1069e:	7163      	strb	r3, [r4, #5]
   106a0:	e7d0      	b.n	10644 <mod_init+0x50>
   106a2:	bf00      	nop
   106a4:	00010a19 	.word	0x00010a19
   106a8:	20002780 	.word	0x20002780
   106ac:	38e38e39 	.word	0x38e38e39
   106b0:	00031881 	.word	0x00031881
   106b4:	0002dacc 	.word	0x0002dacc

000106b8 <encode_mod_path.isra.0>:
	return mod_set(true, name, len_rd, read_cb, cb_arg);
}

BT_MESH_SETTINGS_DEFINE(vnd_mod, "v", vnd_mod_set);

static void encode_mod_path(struct bt_mesh_model *mod, bool vnd,
   106b8:	b470      	push	{r4, r5, r6}
   106ba:	4606      	mov	r6, r0
   106bc:	460c      	mov	r4, r1
   106be:	461d      	mov	r5, r3
   106c0:	e9dd 0103 	ldrd	r0, r1, [sp, #12]
			    const char *key, char *path, size_t path_len)
{
	uint16_t mod_key = (((uint16_t)mod->elem_idx << 8) | mod->mod_idx);

	if (vnd) {
		snprintk(path, path_len, "bt/mesh/v/%x/%s", mod_key, key);
   106c4:	ea44 2306 	orr.w	r3, r4, r6, lsl #8
   106c8:	9503      	str	r5, [sp, #12]
	if (vnd) {
   106ca:	b11a      	cbz	r2, 106d4 <encode_mod_path.isra.0+0x1c>
		snprintk(path, path_len, "bt/mesh/v/%x/%s", mod_key, key);
   106cc:	4a02      	ldr	r2, [pc, #8]	; (106d8 <encode_mod_path.isra.0+0x20>)
	} else {
		snprintk(path, path_len, "bt/mesh/s/%x/%s", mod_key, key);
	}
}
   106ce:	bc70      	pop	{r4, r5, r6}
		snprintk(path, path_len, "bt/mesh/s/%x/%s", mod_key, key);
   106d0:	f014 bd81 	b.w	251d6 <snprintk>
   106d4:	4a01      	ldr	r2, [pc, #4]	; (106dc <encode_mod_path.isra.0+0x24>)
   106d6:	e7fa      	b.n	106ce <encode_mod_path.isra.0+0x16>
   106d8:	000318c6 	.word	0x000318c6
   106dc:	000318d6 	.word	0x000318d6

000106e0 <store_pending_mod>:
}

static void store_pending_mod(struct bt_mesh_model *mod,
			      struct bt_mesh_elem *elem, bool vnd,
			      bool primary, void *user_data)
{
   106e0:	b570      	push	{r4, r5, r6, lr}
	if (!mod->flags) {
   106e2:	88c3      	ldrh	r3, [r0, #6]
{
   106e4:	b08c      	sub	sp, #48	; 0x30
   106e6:	4604      	mov	r4, r0
   106e8:	4616      	mov	r6, r2
	if (!mod->flags) {
   106ea:	2b00      	cmp	r3, #0
   106ec:	d07f      	beq.n	107ee <store_pending_mod+0x10e>
		return;
	}

	if (mod->flags & BT_MESH_MOD_BIND_PENDING) {
   106ee:	07d8      	lsls	r0, r3, #31
   106f0:	d52a      	bpl.n	10748 <store_pending_mod+0x68>
		mod->flags &= ~BT_MESH_MOD_BIND_PENDING;
   106f2:	f023 0301 	bic.w	r3, r3, #1
   106f6:	80e3      	strh	r3, [r4, #6]
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   106f8:	89a3      	ldrh	r3, [r4, #12]
	encode_mod_path(mod, vnd, "bind", path, sizeof(path));
   106fa:	7961      	ldrb	r1, [r4, #5]
   106fc:	7920      	ldrb	r0, [r4, #4]
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   106fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10702:	4293      	cmp	r3, r2
			keys[count++] = mod->keys[i];
   10704:	bf18      	it	ne
   10706:	f8ad 3014 	strhne.w	r3, [sp, #20]
	encode_mod_path(mod, vnd, "bind", path, sizeof(path));
   1070a:	f04f 0314 	mov.w	r3, #20
   1070e:	9301      	str	r3, [sp, #4]
   10710:	ab07      	add	r3, sp, #28
			keys[count++] = mod->keys[i];
   10712:	bf14      	ite	ne
   10714:	2501      	movne	r5, #1
		if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   10716:	2500      	moveq	r5, #0
	encode_mod_path(mod, vnd, "bind", path, sizeof(path));
   10718:	9300      	str	r3, [sp, #0]
   1071a:	4632      	mov	r2, r6
   1071c:	4b4b      	ldr	r3, [pc, #300]	; (1084c <store_pending_mod+0x16c>)
   1071e:	f7ff ffcb 	bl	106b8 <encode_mod_path.isra.0>
	if (count) {
   10722:	2d00      	cmp	r5, #0
   10724:	d065      	beq.n	107f2 <store_pending_mod+0x112>
		err = settings_save_one(path, keys, count * sizeof(keys[0]));
   10726:	2202      	movs	r2, #2
   10728:	a905      	add	r1, sp, #20
   1072a:	a807      	add	r0, sp, #28
   1072c:	f7f3 fa68 	bl	3c00 <settings_save_one>
	if (err) {
   10730:	b150      	cbz	r0, 10748 <store_pending_mod+0x68>
		BT_ERR("Failed to store %s value", log_strdup(path));
   10732:	ab07      	add	r3, sp, #28
   10734:	9302      	str	r3, [sp, #8]
   10736:	4b46      	ldr	r3, [pc, #280]	; (10850 <store_pending_mod+0x170>)
   10738:	9301      	str	r3, [sp, #4]
   1073a:	2300      	movs	r3, #0
   1073c:	4945      	ldr	r1, [pc, #276]	; (10854 <store_pending_mod+0x174>)
   1073e:	9300      	str	r3, [sp, #0]
   10740:	2201      	movs	r2, #1
   10742:	4618      	mov	r0, r3
   10744:	f019 fc46 	bl	29fd4 <z_log_msg2_runtime_create.constprop.0>
		store_pending_mod_bind(mod, vnd);
	}

	if (mod->flags & BT_MESH_MOD_SUB_PENDING) {
   10748:	88e3      	ldrh	r3, [r4, #6]
   1074a:	0799      	lsls	r1, r3, #30
   1074c:	d52c      	bpl.n	107a8 <store_pending_mod+0xc8>
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   1074e:	89e5      	ldrh	r5, [r4, #14]
		mod->flags &= ~BT_MESH_MOD_SUB_PENDING;
   10750:	f023 0302 	bic.w	r3, r3, #2
   10754:	80e3      	strh	r3, [r4, #6]
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   10756:	b115      	cbz	r5, 1075e <store_pending_mod+0x7e>
			groups[count++] = mod->groups[i];
   10758:	f8ad 5014 	strh.w	r5, [sp, #20]
   1075c:	2501      	movs	r5, #1
		if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   1075e:	8a23      	ldrh	r3, [r4, #16]
   10760:	b12b      	cbz	r3, 1076e <store_pending_mod+0x8e>
			groups[count++] = mod->groups[i];
   10762:	aa0c      	add	r2, sp, #48	; 0x30
   10764:	eb02 0245 	add.w	r2, r2, r5, lsl #1
   10768:	3501      	adds	r5, #1
   1076a:	f822 3c1c 	strh.w	r3, [r2, #-28]
	encode_mod_path(mod, vnd, "sub", path, sizeof(path));
   1076e:	2314      	movs	r3, #20
   10770:	9301      	str	r3, [sp, #4]
   10772:	ab07      	add	r3, sp, #28
   10774:	9300      	str	r3, [sp, #0]
   10776:	7961      	ldrb	r1, [r4, #5]
   10778:	4b37      	ldr	r3, [pc, #220]	; (10858 <store_pending_mod+0x178>)
   1077a:	7920      	ldrb	r0, [r4, #4]
   1077c:	4632      	mov	r2, r6
   1077e:	f7ff ff9b 	bl	106b8 <encode_mod_path.isra.0>
	if (count) {
   10782:	2d00      	cmp	r5, #0
   10784:	d039      	beq.n	107fa <store_pending_mod+0x11a>
		err = settings_save_one(path, groups,
   10786:	006a      	lsls	r2, r5, #1
   10788:	a905      	add	r1, sp, #20
   1078a:	a807      	add	r0, sp, #28
   1078c:	f7f3 fa38 	bl	3c00 <settings_save_one>
	if (err) {
   10790:	b150      	cbz	r0, 107a8 <store_pending_mod+0xc8>
		BT_ERR("Failed to store %s value", log_strdup(path));
   10792:	ab07      	add	r3, sp, #28
   10794:	9302      	str	r3, [sp, #8]
   10796:	4b2e      	ldr	r3, [pc, #184]	; (10850 <store_pending_mod+0x170>)
   10798:	9301      	str	r3, [sp, #4]
   1079a:	2300      	movs	r3, #0
   1079c:	492d      	ldr	r1, [pc, #180]	; (10854 <store_pending_mod+0x174>)
   1079e:	9300      	str	r3, [sp, #0]
   107a0:	2201      	movs	r2, #1
   107a2:	4618      	mov	r0, r3
   107a4:	f019 fc16 	bl	29fd4 <z_log_msg2_runtime_create.constprop.0>
		store_pending_mod_sub(mod, vnd);
	}

	if (mod->flags & BT_MESH_MOD_PUB_PENDING) {
   107a8:	88e3      	ldrh	r3, [r4, #6]
   107aa:	075a      	lsls	r2, r3, #29
   107ac:	d51f      	bpl.n	107ee <store_pending_mod+0x10e>
		mod->flags &= ~BT_MESH_MOD_PUB_PENDING;
   107ae:	f023 0304 	bic.w	r3, r3, #4
   107b2:	80e3      	strh	r3, [r4, #6]
	encode_mod_path(mod, vnd, "pub", path, sizeof(path));
   107b4:	2314      	movs	r3, #20
   107b6:	9301      	str	r3, [sp, #4]
   107b8:	ab07      	add	r3, sp, #28
   107ba:	9300      	str	r3, [sp, #0]
   107bc:	4632      	mov	r2, r6
   107be:	4b27      	ldr	r3, [pc, #156]	; (1085c <store_pending_mod+0x17c>)
   107c0:	7961      	ldrb	r1, [r4, #5]
   107c2:	7920      	ldrb	r0, [r4, #4]
   107c4:	f7ff ff78 	bl	106b8 <encode_mod_path.isra.0>
	if (!mod->pub || mod->pub->addr == BT_MESH_ADDR_UNASSIGNED) {
   107c8:	68a2      	ldr	r2, [r4, #8]
   107ca:	b10a      	cbz	r2, 107d0 <store_pending_mod+0xf0>
   107cc:	8893      	ldrh	r3, [r2, #4]
   107ce:	b9c3      	cbnz	r3, 10802 <store_pending_mod+0x122>
		err = settings_delete(path);
   107d0:	a807      	add	r0, sp, #28
   107d2:	f015 fd10 	bl	261f6 <settings_delete>
	if (err) {
   107d6:	b150      	cbz	r0, 107ee <store_pending_mod+0x10e>
		BT_ERR("Failed to store %s value", log_strdup(path));
   107d8:	ab07      	add	r3, sp, #28
   107da:	9302      	str	r3, [sp, #8]
   107dc:	4b1c      	ldr	r3, [pc, #112]	; (10850 <store_pending_mod+0x170>)
   107de:	9301      	str	r3, [sp, #4]
   107e0:	2300      	movs	r3, #0
   107e2:	491c      	ldr	r1, [pc, #112]	; (10854 <store_pending_mod+0x174>)
   107e4:	9300      	str	r3, [sp, #0]
   107e6:	2201      	movs	r2, #1
   107e8:	4618      	mov	r0, r3
   107ea:	f019 fbf3 	bl	29fd4 <z_log_msg2_runtime_create.constprop.0>
		store_pending_mod_pub(mod, vnd);
	}
}
   107ee:	b00c      	add	sp, #48	; 0x30
   107f0:	bd70      	pop	{r4, r5, r6, pc}
		err = settings_delete(path);
   107f2:	a807      	add	r0, sp, #28
   107f4:	f015 fcff 	bl	261f6 <settings_delete>
   107f8:	e79a      	b.n	10730 <store_pending_mod+0x50>
		err = settings_delete(path);
   107fa:	a807      	add	r0, sp, #28
   107fc:	f015 fcfb 	bl	261f6 <settings_delete>
   10800:	e7c6      	b.n	10790 <store_pending_mod+0xb0>
		pub.addr = mod->pub->addr;
   10802:	f8ad 3014 	strh.w	r3, [sp, #20]
		pub.key = mod->pub->key;
   10806:	88d3      	ldrh	r3, [r2, #6]
   10808:	f3c3 030b 	ubfx	r3, r3, #0, #12
   1080c:	f8ad 3016 	strh.w	r3, [sp, #22]
		pub.ttl = mod->pub->ttl;
   10810:	8913      	ldrh	r3, [r2, #8]
   10812:	f8ad 3018 	strh.w	r3, [sp, #24]
		pub.period = mod->pub->period;
   10816:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   1081a:	8951      	ldrh	r1, [r2, #10]
   1081c:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   10820:	f3c1 010b 	ubfx	r1, r1, #0, #12
   10824:	f023 030f 	bic.w	r3, r3, #15
   10828:	430b      	orrs	r3, r1
   1082a:	f8ad 301a 	strh.w	r3, [sp, #26]
		pub.cred = mod->pub->cred;
   1082e:	79d3      	ldrb	r3, [r2, #7]
   10830:	f89d 201b 	ldrb.w	r2, [sp, #27]
   10834:	f3c3 1300 	ubfx	r3, r3, #4, #1
   10838:	f363 1204 	bfi	r2, r3, #4, #1
   1083c:	f88d 201b 	strb.w	r2, [sp, #27]
		err = settings_save_one(path, &pub, sizeof(pub));
   10840:	a905      	add	r1, sp, #20
   10842:	2208      	movs	r2, #8
   10844:	a807      	add	r0, sp, #28
   10846:	f7f3 f9db 	bl	3c00 <settings_save_one>
   1084a:	e7c4      	b.n	107d6 <store_pending_mod+0xf6>
   1084c:	000318e6 	.word	0x000318e6
   10850:	000318eb 	.word	0x000318eb
   10854:	0002dacc 	.word	0x0002dacc
   10858:	00031904 	.word	0x00031904
   1085c:	00031908 	.word	0x00031908

00010860 <bt_mesh_model_foreach>:
{
   10860:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	for (i = 0; i < dev_comp->elem_count; i++) {
   10864:	f8df a06c 	ldr.w	sl, [pc, #108]	; 108d4 <bt_mesh_model_foreach+0x74>
{
   10868:	4606      	mov	r6, r0
   1086a:	460f      	mov	r7, r1
	for (i = 0; i < dev_comp->elem_count; i++) {
   1086c:	2500      	movs	r5, #0
			struct bt_mesh_model *model = &elem->models[j];
   1086e:	f04f 0924 	mov.w	r9, #36	; 0x24
	for (i = 0; i < dev_comp->elem_count; i++) {
   10872:	f8da 3000 	ldr.w	r3, [sl]
   10876:	689a      	ldr	r2, [r3, #8]
   10878:	42aa      	cmp	r2, r5
   1087a:	d802      	bhi.n	10882 <bt_mesh_model_foreach+0x22>
}
   1087c:	b002      	add	sp, #8
   1087e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		struct bt_mesh_elem *elem = &dev_comp->elem[i];
   10882:	68dc      	ldr	r4, [r3, #12]
		for (j = 0; j < elem->model_count; j++) {
   10884:	f04f 0800 	mov.w	r8, #0
		struct bt_mesh_elem *elem = &dev_comp->elem[i];
   10888:	eb04 1405 	add.w	r4, r4, r5, lsl #4
		for (j = 0; j < elem->model_count; j++) {
   1088c:	7923      	ldrb	r3, [r4, #4]
   1088e:	4543      	cmp	r3, r8
   10890:	dc06      	bgt.n	108a0 <bt_mesh_model_foreach+0x40>
		for (j = 0; j < elem->vnd_model_count; j++) {
   10892:	f04f 0800 	mov.w	r8, #0
   10896:	7963      	ldrb	r3, [r4, #5]
   10898:	4543      	cmp	r3, r8
   1089a:	dc0e      	bgt.n	108ba <bt_mesh_model_foreach+0x5a>
	for (i = 0; i < dev_comp->elem_count; i++) {
   1089c:	3501      	adds	r5, #1
   1089e:	e7e8      	b.n	10872 <bt_mesh_model_foreach+0x12>
			struct bt_mesh_model *model = &elem->models[j];
   108a0:	68a0      	ldr	r0, [r4, #8]
			func(model, elem, false, i == 0, user_data);
   108a2:	9700      	str	r7, [sp, #0]
   108a4:	fab5 f385 	clz	r3, r5
   108a8:	fb09 0008 	mla	r0, r9, r8, r0
   108ac:	095b      	lsrs	r3, r3, #5
   108ae:	2200      	movs	r2, #0
   108b0:	4621      	mov	r1, r4
   108b2:	47b0      	blx	r6
		for (j = 0; j < elem->model_count; j++) {
   108b4:	f108 0801 	add.w	r8, r8, #1
   108b8:	e7e8      	b.n	1088c <bt_mesh_model_foreach+0x2c>
			struct bt_mesh_model *model = &elem->vnd_models[j];
   108ba:	68e0      	ldr	r0, [r4, #12]
			func(model, elem, true, i == 0, user_data);
   108bc:	9700      	str	r7, [sp, #0]
   108be:	fab5 f385 	clz	r3, r5
   108c2:	fb09 0008 	mla	r0, r9, r8, r0
   108c6:	095b      	lsrs	r3, r3, #5
   108c8:	2201      	movs	r2, #1
   108ca:	4621      	mov	r1, r4
   108cc:	47b0      	blx	r6
		for (j = 0; j < elem->vnd_model_count; j++) {
   108ce:	f108 0801 	add.w	r8, r8, #1
   108d2:	e7e0      	b.n	10896 <bt_mesh_model_foreach+0x36>
   108d4:	20002780 	.word	0x20002780

000108d8 <bt_mesh_model_pub_period_get>:
	if (!mod->pub) {
   108d8:	6883      	ldr	r3, [r0, #8]
   108da:	b1eb      	cbz	r3, 10918 <bt_mesh_model_pub_period_get+0x40>
	switch (mod->pub->period >> 6) {
   108dc:	7a98      	ldrb	r0, [r3, #10]
   108de:	0982      	lsrs	r2, r0, #6
   108e0:	2a02      	cmp	r2, #2
   108e2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   108e6:	d012      	beq.n	1090e <bt_mesh_model_pub_period_get+0x36>
   108e8:	2a03      	cmp	r2, #3
   108ea:	d013      	beq.n	10914 <bt_mesh_model_pub_period_get+0x3c>
   108ec:	2a01      	cmp	r2, #1
   108ee:	d00a      	beq.n	10906 <bt_mesh_model_pub_period_get+0x2e>
		period = (mod->pub->period & BIT_MASK(6)) * 100U;
   108f0:	2264      	movs	r2, #100	; 0x64
   108f2:	fb10 f002 	smulbb	r0, r0, r2
	if (mod->pub->fast_period) {
   108f6:	79da      	ldrb	r2, [r3, #7]
   108f8:	0652      	lsls	r2, r2, #25
   108fa:	d50e      	bpl.n	1091a <bt_mesh_model_pub_period_get+0x42>
		return period >> mod->pub->period_div;
   108fc:	7adb      	ldrb	r3, [r3, #11]
   108fe:	f003 030f 	and.w	r3, r3, #15
   10902:	4118      	asrs	r0, r3
   10904:	4770      	bx	lr
		period = (mod->pub->period & BIT_MASK(6)) * MSEC_PER_SEC;
   10906:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		period = (mod->pub->period & BIT_MASK(6)) * 600U * MSEC_PER_SEC;
   1090a:	4350      	muls	r0, r2
		break;
   1090c:	e7f3      	b.n	108f6 <bt_mesh_model_pub_period_get+0x1e>
		period = (mod->pub->period & BIT_MASK(6)) * 10U * MSEC_PER_SEC;
   1090e:	f242 7210 	movw	r2, #10000	; 0x2710
   10912:	e7fa      	b.n	1090a <bt_mesh_model_pub_period_get+0x32>
		period = (mod->pub->period & BIT_MASK(6)) * 600U * MSEC_PER_SEC;
   10914:	4a01      	ldr	r2, [pc, #4]	; (1091c <bt_mesh_model_pub_period_get+0x44>)
   10916:	e7f8      	b.n	1090a <bt_mesh_model_pub_period_get+0x32>
		return 0;
   10918:	4618      	mov	r0, r3
}
   1091a:	4770      	bx	lr
   1091c:	000927c0 	.word	0x000927c0

00010920 <publish_sent>:
{
   10920:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_mesh_model_pub *pub = mod->pub;
   10922:	688f      	ldr	r7, [r1, #8]
{
   10924:	460d      	mov	r5, r1
   10926:	b089      	sub	sp, #36	; 0x24
	elapsed = k_uptime_get_32() - pub->period_start;
   10928:	f019 fb2a 	bl	29f80 <k_uptime_get_32>
   1092c:	68fc      	ldr	r4, [r7, #12]
	if (mod->pub->count) {
   1092e:	68ab      	ldr	r3, [r5, #8]
	elapsed = k_uptime_get_32() - pub->period_start;
   10930:	4606      	mov	r6, r0
   10932:	1b07      	subs	r7, r0, r4
	if (mod->pub->count) {
   10934:	7ad8      	ldrb	r0, [r3, #11]
   10936:	f010 0ff0 	tst.w	r0, #240	; 0xf0
   1093a:	d031      	beq.n	109a0 <publish_sent+0x80>
		period = BT_MESH_PUB_TRANSMIT_INT(mod->pub->retransmit);
   1093c:	7a59      	ldrb	r1, [r3, #9]
   1093e:	2332      	movs	r3, #50	; 0x32
   10940:	08ca      	lsrs	r2, r1, #3
   10942:	fb02 3303 	mla	r3, r2, r3, r3
		period *= BT_MESH_PUB_MSG_NUM(mod->pub);
   10946:	f001 0207 	and.w	r2, r1, #7
   1094a:	3201      	adds	r2, #1
   1094c:	eba2 1210 	sub.w	r2, r2, r0, lsr #4
		if (period && elapsed >= period) {
   10950:	4353      	muls	r3, r2
   10952:	d025      	beq.n	109a0 <publish_sent+0x80>
   10954:	429f      	cmp	r7, r3
   10956:	d32c      	bcc.n	109b2 <publish_sent+0x92>
			BT_WARN("Retransmission interval is too short");
   10958:	4b18      	ldr	r3, [pc, #96]	; (109bc <publish_sent+0x9c>)
		BT_WARN("Publication sending took longer than the period");
   1095a:	9306      	str	r3, [sp, #24]
   1095c:	4818      	ldr	r0, [pc, #96]	; (109c0 <publish_sent+0xa0>)
   1095e:	2302      	movs	r3, #2
   10960:	aa05      	add	r2, sp, #20
   10962:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   10966:	9301      	str	r3, [sp, #4]
   10968:	9305      	str	r3, [sp, #20]
   1096a:	f019 fb30 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return 1;
   1096e:	2301      	movs	r3, #1
		k_work_schedule(&mod->pub->timer, K_MSEC(delay));
   10970:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
			return ((t * to_hz + off) / from_hz);
   10974:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   10978:	f240 30e7 	movw	r0, #999	; 0x3e7
   1097c:	2100      	movs	r1, #0
   1097e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10982:	2300      	movs	r3, #0
   10984:	fbc4 0106 	smlal	r0, r1, r4, r6
   10988:	f7ef fbaa 	bl	e0 <__aeabi_uldivmod>
   1098c:	68ad      	ldr	r5, [r5, #8]
   1098e:	3518      	adds	r5, #24
   10990:	4602      	mov	r2, r0
   10992:	460b      	mov	r3, r1
   10994:	4628      	mov	r0, r5
}
   10996:	b009      	add	sp, #36	; 0x24
   10998:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		k_work_schedule(&mod->pub->timer, K_MSEC(delay));
   1099c:	f013 bcae 	b.w	242fc <k_work_schedule>
		period = bt_mesh_model_pub_period_get(mod);
   109a0:	4628      	mov	r0, r5
   109a2:	f7ff ff99 	bl	108d8 <bt_mesh_model_pub_period_get>
   109a6:	4603      	mov	r3, r0
		if (!period) {
   109a8:	b130      	cbz	r0, 109b8 <publish_sent+0x98>
	if (elapsed >= period) {
   109aa:	4287      	cmp	r7, r0
   109ac:	d301      	bcc.n	109b2 <publish_sent+0x92>
		BT_WARN("Publication sending took longer than the period");
   109ae:	4b05      	ldr	r3, [pc, #20]	; (109c4 <publish_sent+0xa4>)
   109b0:	e7d3      	b.n	1095a <publish_sent+0x3a>
	return period - elapsed;
   109b2:	1ba4      	subs	r4, r4, r6
	if (delay) {
   109b4:	18e3      	adds	r3, r4, r3
   109b6:	d1db      	bne.n	10970 <publish_sent+0x50>
}
   109b8:	b009      	add	sp, #36	; 0x24
   109ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   109bc:	0003190c 	.word	0x0003190c
   109c0:	0002dacc 	.word	0x0002dacc
   109c4:	00031931 	.word	0x00031931

000109c8 <publish_start>:
{
   109c8:	b530      	push	{r4, r5, lr}
   109ca:	4615      	mov	r5, r2
   109cc:	b089      	sub	sp, #36	; 0x24
	if (err) {
   109ce:	460c      	mov	r4, r1
   109d0:	b191      	cbz	r1, 109f8 <publish_start+0x30>
		BT_ERR("Failed to publish: err %d", err);
   109d2:	4b0a      	ldr	r3, [pc, #40]	; (109fc <publish_start+0x34>)
   109d4:	480a      	ldr	r0, [pc, #40]	; (10a00 <publish_start+0x38>)
   109d6:	e9cd 3106 	strd	r3, r1, [sp, #24]
   109da:	aa05      	add	r2, sp, #20
   109dc:	2303      	movs	r3, #3
   109de:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   109e2:	9301      	str	r3, [sp, #4]
   109e4:	9305      	str	r3, [sp, #20]
   109e6:	f019 faf2 	bl	29fce <z_log_msg2_static_create.constprop.0>
		publish_sent(err, user_data);
   109ea:	4629      	mov	r1, r5
   109ec:	4620      	mov	r0, r4
}
   109ee:	b009      	add	sp, #36	; 0x24
   109f0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		publish_sent(err, user_data);
   109f4:	f7ff bf94 	b.w	10920 <publish_sent>
}
   109f8:	b009      	add	sp, #36	; 0x24
   109fa:	bd30      	pop	{r4, r5, pc}
   109fc:	00031961 	.word	0x00031961
   10a00:	0002dacc 	.word	0x0002dacc

00010a04 <bt_mesh_model_elem>:
	return &dev_comp->elem[mod->elem_idx];
   10a04:	4b03      	ldr	r3, [pc, #12]	; (10a14 <bt_mesh_model_elem+0x10>)
   10a06:	7900      	ldrb	r0, [r0, #4]
   10a08:	681b      	ldr	r3, [r3, #0]
   10a0a:	68db      	ldr	r3, [r3, #12]
}
   10a0c:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   10a10:	4770      	bx	lr
   10a12:	bf00      	nop
   10a14:	20002780 	.word	0x20002780

00010a18 <mod_publish>:
{
   10a18:	b570      	push	{r4, r5, r6, lr}
	if (pub->addr == BT_MESH_ADDR_UNASSIGNED ||
   10a1a:	f830 3c14 	ldrh.w	r3, [r0, #-20]
{
   10a1e:	b094      	sub	sp, #80	; 0x50
   10a20:	4604      	mov	r4, r0
	if (pub->addr == BT_MESH_ADDR_UNASSIGNED ||
   10a22:	2b00      	cmp	r3, #0
   10a24:	f000 808e 	beq.w	10b44 <mod_publish+0x12c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   10a28:	f3bf 8f5b 	dmb	ish
   10a2c:	4b46      	ldr	r3, [pc, #280]	; (10b48 <mod_publish+0x130>)
   10a2e:	681b      	ldr	r3, [r3, #0]
   10a30:	f3bf 8f5b 	dmb	ish
   10a34:	079b      	lsls	r3, r3, #30
   10a36:	f100 8085 	bmi.w	10b44 <mod_publish+0x12c>
	if (pub->count) {
   10a3a:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
		    bt_mesh_model_pub_is_retransmission(pub->mod)) {
   10a3e:	f850 0c18 	ldr.w	r0, [r0, #-24]
	if (pub->count) {
   10a42:	f013 06f0 	ands.w	r6, r3, #240	; 0xf0
   10a46:	d01a      	beq.n	10a7e <mod_publish+0x66>
		pub->count--;
   10a48:	33f0      	adds	r3, #240	; 0xf0
   10a4a:	f804 3c0d 	strb.w	r3, [r4, #-13]
		if (pub->retr_update && pub->update &&
   10a4e:	f914 3c11 	ldrsb.w	r3, [r4, #-17]
   10a52:	2b00      	cmp	r3, #0
   10a54:	da2f      	bge.n	10ab6 <mod_publish+0x9e>
   10a56:	f854 2c04 	ldr.w	r2, [r4, #-4]
   10a5a:	b362      	cbz	r2, 10ab6 <mod_publish+0x9e>
   10a5c:	6883      	ldr	r3, [r0, #8]
 *
 * @return true if this is a retransmission, false if this is a first publication.
 */
static inline bool bt_mesh_model_pub_is_retransmission(const struct bt_mesh_model *model)
{
	return model->pub->count != BT_MESH_PUB_TRANSMIT_COUNT(model->pub->retransmit);
   10a5e:	7ad9      	ldrb	r1, [r3, #11]
   10a60:	7a5b      	ldrb	r3, [r3, #9]
   10a62:	f003 0307 	and.w	r3, r3, #7
   10a66:	ebb3 1f11 	cmp.w	r3, r1, lsr #4
   10a6a:	d024      	beq.n	10ab6 <mod_publish+0x9e>
			err = pub->update(pub->mod);
   10a6c:	4790      	blx	r2
			if (err) {
   10a6e:	b310      	cbz	r0, 10ab6 <mod_publish+0x9e>
				publish_sent(err, pub->mod);
   10a70:	f854 1c18 	ldr.w	r1, [r4, #-24]
}
   10a74:	b014      	add	sp, #80	; 0x50
   10a76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		publish_sent(err, pub->mod);
   10a7a:	f7ff bf51 	b.w	10920 <publish_sent>
	pub->count = BT_MESH_PUB_TRANSMIT_COUNT(pub->retransmit);
   10a7e:	f814 2c0f 	ldrb.w	r2, [r4, #-15]
   10a82:	f002 0207 	and.w	r2, r2, #7
   10a86:	f362 1307 	bfi	r3, r2, #4, #4
   10a8a:	f804 3c0d 	strb.w	r3, [r4, #-13]
	if (!pub->update) {
   10a8e:	f854 3c04 	ldr.w	r3, [r4, #-4]
   10a92:	b183      	cbz	r3, 10ab6 <mod_publish+0x9e>
	err = pub->update(pub->mod);
   10a94:	4798      	blx	r3
   10a96:	4605      	mov	r5, r0
	pub->period_start = k_uptime_get_32();
   10a98:	f019 fa72 	bl	29f80 <k_uptime_get_32>
   10a9c:	f844 0c0c 	str.w	r0, [r4, #-12]
	if (err) {
   10aa0:	b14d      	cbz	r5, 10ab6 <mod_publish+0x9e>
		pub->count = 0;
   10aa2:	f814 3c0d 	ldrb.w	r3, [r4, #-13]
   10aa6:	f366 1307 	bfi	r3, r6, #4, #4
   10aaa:	f804 3c0d 	strb.w	r3, [r4, #-13]
		publish_sent(err, pub->mod);
   10aae:	f854 1c18 	ldr.w	r1, [r4, #-24]
   10ab2:	4628      	mov	r0, r5
   10ab4:	e7de      	b.n	10a74 <mod_publish+0x5c>
	err = publish_transmit(pub->mod);
   10ab6:	f854 5c18 	ldr.w	r5, [r4, #-24]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   10aba:	ab0a      	add	r3, sp, #40	; 0x28
   10abc:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
   10ac0:	e9cd 2302 	strd	r2, r3, [sp, #8]
	struct bt_mesh_model_pub *pub = mod->pub;
   10ac4:	68aa      	ldr	r2, [r5, #8]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   10ac6:	9301      	str	r3, [sp, #4]
		.app_idx = pub->key,
   10ac8:	88d0      	ldrh	r0, [r2, #6]
	struct bt_mesh_msg_ctx ctx = {
   10aca:	2100      	movs	r1, #0
   10acc:	e9cd 1104 	strd	r1, r1, [sp, #16]
		.app_idx = pub->key,
   10ad0:	f3c0 000b 	ubfx	r0, r0, #0, #12
	struct bt_mesh_msg_ctx ctx = {
   10ad4:	f8cd 1017 	str.w	r1, [sp, #23]
   10ad8:	f8ad 0012 	strh.w	r0, [sp, #18]
   10adc:	8890      	ldrh	r0, [r2, #4]
   10ade:	f8ad 0014 	strh.w	r0, [sp, #20]
   10ae2:	7a10      	ldrb	r0, [r2, #8]
   10ae4:	f88d 001b 	strb.w	r0, [sp, #27]
   10ae8:	ab04      	add	r3, sp, #16
		.src = bt_mesh_model_elem(mod)->addr,
   10aea:	4628      	mov	r0, r5
	struct bt_mesh_net_tx tx = {
   10aec:	e9cd 3108 	strd	r3, r1, [sp, #32]
   10af0:	9107      	str	r1, [sp, #28]
		.src = bt_mesh_model_elem(mod)->addr,
   10af2:	f7ff ff87 	bl	10a04 <bt_mesh_model_elem>
	struct bt_mesh_net_tx tx = {
   10af6:	8803      	ldrh	r3, [r0, #0]
   10af8:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
		.friend_cred = pub->cred,
   10afc:	79d3      	ldrb	r3, [r2, #7]
	struct bt_mesh_net_tx tx = {
   10afe:	f89d 1027 	ldrb.w	r1, [sp, #39]	; 0x27
		.friend_cred = pub->cred,
   10b02:	f3c3 1300 	ubfx	r3, r3, #4, #1
	struct bt_mesh_net_tx tx = {
   10b06:	f363 0100 	bfi	r1, r3, #0, #1
	net_buf_simple_add_mem(&sdu, pub->msg->data, pub->msg->len);
   10b0a:	6913      	ldr	r3, [r2, #16]
	struct bt_mesh_net_tx tx = {
   10b0c:	f88d 1027 	strb.w	r1, [sp, #39]	; 0x27
	net_buf_simple_add_mem(&sdu, pub->msg->data, pub->msg->len);
   10b10:	889a      	ldrh	r2, [r3, #4]
   10b12:	6819      	ldr	r1, [r3, #0]
   10b14:	a801      	add	r0, sp, #4
   10b16:	f01b f917 	bl	2bd48 <net_buf_simple_add_mem>
	return bt_mesh_trans_send(&tx, &sdu, &pub_sent_cb, mod);
   10b1a:	462b      	mov	r3, r5
   10b1c:	4a0b      	ldr	r2, [pc, #44]	; (10b4c <mod_publish+0x134>)
   10b1e:	a901      	add	r1, sp, #4
   10b20:	a807      	add	r0, sp, #28
   10b22:	f7fe fa0f 	bl	ef44 <bt_mesh_trans_send>
	if (err) {
   10b26:	4605      	mov	r5, r0
   10b28:	b160      	cbz	r0, 10b44 <mod_publish+0x12c>
		BT_ERR("Failed to publish (err %d)", err);
   10b2a:	4b09      	ldr	r3, [pc, #36]	; (10b50 <mod_publish+0x138>)
   10b2c:	aa0d      	add	r2, sp, #52	; 0x34
   10b2e:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
   10b32:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   10b36:	2303      	movs	r3, #3
   10b38:	4806      	ldr	r0, [pc, #24]	; (10b54 <mod_publish+0x13c>)
   10b3a:	9307      	str	r3, [sp, #28]
   10b3c:	930d      	str	r3, [sp, #52]	; 0x34
   10b3e:	f019 fa46 	bl	29fce <z_log_msg2_static_create.constprop.0>
   10b42:	e7b4      	b.n	10aae <mod_publish+0x96>
}
   10b44:	b014      	add	sp, #80	; 0x50
   10b46:	bd70      	pop	{r4, r5, r6, pc}
   10b48:	20001ab0 	.word	0x20001ab0
   10b4c:	0002e42c 	.word	0x0002e42c
   10b50:	0003197b 	.word	0x0003197b
   10b54:	0002dacc 	.word	0x0002dacc

00010b58 <bt_mesh_model_get>:
	if (elem_idx >= dev_comp->elem_count) {
   10b58:	4b18      	ldr	r3, [pc, #96]	; (10bbc <bt_mesh_model_get+0x64>)
{
   10b5a:	b510      	push	{r4, lr}
	if (elem_idx >= dev_comp->elem_count) {
   10b5c:	681b      	ldr	r3, [r3, #0]
{
   10b5e:	4604      	mov	r4, r0
	if (elem_idx >= dev_comp->elem_count) {
   10b60:	6898      	ldr	r0, [r3, #8]
   10b62:	4281      	cmp	r1, r0
{
   10b64:	b088      	sub	sp, #32
	if (elem_idx >= dev_comp->elem_count) {
   10b66:	d30e      	bcc.n	10b86 <bt_mesh_model_get+0x2e>
		BT_ERR("Invalid element index %u", elem_idx);
   10b68:	4b15      	ldr	r3, [pc, #84]	; (10bc0 <bt_mesh_model_get+0x68>)
   10b6a:	e9cd 3106 	strd	r3, r1, [sp, #24]
   10b6e:	2303      	movs	r3, #3
   10b70:	4814      	ldr	r0, [pc, #80]	; (10bc4 <bt_mesh_model_get+0x6c>)
   10b72:	9301      	str	r3, [sp, #4]
   10b74:	aa05      	add	r2, sp, #20
   10b76:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   10b7a:	9305      	str	r3, [sp, #20]
   10b7c:	f019 fa27 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return NULL;
   10b80:	2000      	movs	r0, #0
}
   10b82:	b008      	add	sp, #32
   10b84:	bd10      	pop	{r4, pc}
	elem = &dev_comp->elem[elem_idx];
   10b86:	68db      	ldr	r3, [r3, #12]
   10b88:	eb03 1101 	add.w	r1, r3, r1, lsl #4
	if (vnd) {
   10b8c:	b164      	cbz	r4, 10ba8 <bt_mesh_model_get+0x50>
		if (mod_idx >= elem->vnd_model_count) {
   10b8e:	794b      	ldrb	r3, [r1, #5]
   10b90:	4293      	cmp	r3, r2
   10b92:	d803      	bhi.n	10b9c <bt_mesh_model_get+0x44>
			BT_ERR("Invalid vendor model index %u", mod_idx);
   10b94:	4b0c      	ldr	r3, [pc, #48]	; (10bc8 <bt_mesh_model_get+0x70>)
			BT_ERR("Invalid SIG model index %u", mod_idx);
   10b96:	e9cd 3206 	strd	r3, r2, [sp, #24]
   10b9a:	e7e8      	b.n	10b6e <bt_mesh_model_get+0x16>
		return &elem->vnd_models[mod_idx];
   10b9c:	68c8      	ldr	r0, [r1, #12]
   10b9e:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
		return &elem->models[mod_idx];
   10ba2:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   10ba6:	e7ec      	b.n	10b82 <bt_mesh_model_get+0x2a>
		if (mod_idx >= elem->model_count) {
   10ba8:	790b      	ldrb	r3, [r1, #4]
   10baa:	4293      	cmp	r3, r2
   10bac:	d801      	bhi.n	10bb2 <bt_mesh_model_get+0x5a>
			BT_ERR("Invalid SIG model index %u", mod_idx);
   10bae:	4b07      	ldr	r3, [pc, #28]	; (10bcc <bt_mesh_model_get+0x74>)
   10bb0:	e7f1      	b.n	10b96 <bt_mesh_model_get+0x3e>
		return &elem->models[mod_idx];
   10bb2:	6888      	ldr	r0, [r1, #8]
   10bb4:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
   10bb8:	e7f3      	b.n	10ba2 <bt_mesh_model_get+0x4a>
   10bba:	bf00      	nop
   10bbc:	20002780 	.word	0x20002780
   10bc0:	00031996 	.word	0x00031996
   10bc4:	0002dacc 	.word	0x0002dacc
   10bc8:	000319af 	.word	0x000319af
   10bcc:	000319cd 	.word	0x000319cd

00010bd0 <mod_set>:
{
   10bd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10bd4:	b08f      	sub	sp, #60	; 0x3c
   10bd6:	af04      	add	r7, sp, #16
   10bd8:	4605      	mov	r5, r0
   10bda:	f8d7 a050 	ldr.w	sl, [r7, #80]	; 0x50
   10bde:	4616      	mov	r6, r2
   10be0:	4698      	mov	r8, r3
	if (!name) {
   10be2:	460c      	mov	r4, r1
   10be4:	b961      	cbnz	r1, 10c00 <mod_set+0x30>
		BT_ERR("Insufficient number of arguments");
   10be6:	4b7a      	ldr	r3, [pc, #488]	; (10dd0 <mod_set+0x200>)
   10be8:	623b      	str	r3, [r7, #32]
   10bea:	487a      	ldr	r0, [pc, #488]	; (10dd4 <mod_set+0x204>)
   10bec:	2302      	movs	r3, #2
   10bee:	f107 021c 	add.w	r2, r7, #28
   10bf2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   10bf6:	60bb      	str	r3, [r7, #8]
   10bf8:	61fb      	str	r3, [r7, #28]
   10bfa:	f019 f9e8 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return -ENOENT;
   10bfe:	e022      	b.n	10c46 <mod_set+0x76>
	mod_key = strtol(name, NULL, 16);
   10c00:	2210      	movs	r2, #16
   10c02:	2100      	movs	r1, #0
   10c04:	4620      	mov	r0, r4
   10c06:	f016 fcfe 	bl	27606 <strtol>
	elem_idx = mod_key >> 8;
   10c0a:	f3c0 2907 	ubfx	r9, r0, #8, #8
	mod = bt_mesh_model_get(vnd, elem_idx, mod_idx);
   10c0e:	fa5f fb80 	uxtb.w	fp, r0
   10c12:	465a      	mov	r2, fp
   10c14:	4628      	mov	r0, r5
   10c16:	4649      	mov	r1, r9
   10c18:	f7ff ff9e 	bl	10b58 <bt_mesh_model_get>
	if (!mod) {
   10c1c:	4605      	mov	r5, r0
   10c1e:	b9a8      	cbnz	r0, 10c4c <mod_set+0x7c>
		BT_ERR("Failed to get model for elem_idx %u mod_idx %u",
   10c20:	4a6d      	ldr	r2, [pc, #436]	; (10dd8 <mod_set+0x208>)
   10c22:	486c      	ldr	r0, [pc, #432]	; (10dd4 <mod_set+0x204>)
   10c24:	466c      	mov	r4, sp
   10c26:	b088      	sub	sp, #32
   10c28:	ab04      	add	r3, sp, #16
   10c2a:	e9cd 2908 	strd	r2, r9, [sp, #32]
   10c2e:	461a      	mov	r2, r3
   10c30:	2104      	movs	r1, #4
   10c32:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
   10c36:	6139      	str	r1, [r7, #16]
   10c38:	f842 1f0c 	str.w	r1, [r2, #12]!
   10c3c:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   10c40:	f019 f9c5 	bl	29fce <z_log_msg2_static_create.constprop.0>
   10c44:	46a5      	mov	sp, r4
	return -ENOENT;
   10c46:	f06f 0401 	mvn.w	r4, #1
   10c4a:	e011      	b.n	10c70 <mod_set+0xa0>
	len = settings_name_next(name, &next);
   10c4c:	4639      	mov	r1, r7
   10c4e:	4620      	mov	r0, r4
   10c50:	f015 faf8 	bl	26244 <settings_name_next>
   10c54:	4681      	mov	r9, r0
	if (!next) {
   10c56:	6838      	ldr	r0, [r7, #0]
   10c58:	2800      	cmp	r0, #0
   10c5a:	d0c4      	beq.n	10be6 <mod_set+0x16>
	if (!strncmp(next, "bind", len)) {
   10c5c:	495f      	ldr	r1, [pc, #380]	; (10ddc <mod_set+0x20c>)
   10c5e:	464a      	mov	r2, r9
   10c60:	f016 fde4 	bl	2782c <strncmp>
   10c64:	b9f0      	cbnz	r0, 10ca4 <mod_set+0xd4>
		mod->keys[i] = BT_MESH_KEY_UNUSED;
   10c66:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10c6a:	81ab      	strh	r3, [r5, #12]
	if (len_rd == 0) {
   10c6c:	b92e      	cbnz	r6, 10c7a <mod_set+0xaa>
		return 0;
   10c6e:	2400      	movs	r4, #0
}
   10c70:	4620      	mov	r0, r4
   10c72:	372c      	adds	r7, #44	; 0x2c
   10c74:	46bd      	mov	sp, r7
   10c76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	len = read_cb(cb_arg, mod->keys, sizeof(mod->keys));
   10c7a:	2202      	movs	r2, #2
   10c7c:	f105 010c 	add.w	r1, r5, #12
	len = read_cb(cb_arg, mod->groups, sizeof(mod->groups));
   10c80:	4650      	mov	r0, sl
   10c82:	47c0      	blx	r8
	if (len < 0) {
   10c84:	1e04      	subs	r4, r0, #0
   10c86:	daf2      	bge.n	10c6e <mod_set+0x9e>
		BT_ERR("Failed to read value (err %zd)", len);
   10c88:	4b55      	ldr	r3, [pc, #340]	; (10de0 <mod_set+0x210>)
   10c8a:	e9c7 3408 	strd	r3, r4, [r7, #32]
   10c8e:	2303      	movs	r3, #3
   10c90:	60bb      	str	r3, [r7, #8]
   10c92:	61fb      	str	r3, [r7, #28]
   10c94:	f107 021c 	add.w	r2, r7, #28
   10c98:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
		BT_ERR("Failed to set \'model-pub\'");
   10c9c:	484d      	ldr	r0, [pc, #308]	; (10dd4 <mod_set+0x204>)
   10c9e:	f019 f996 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return err;
   10ca2:	e7e5      	b.n	10c70 <mod_set+0xa0>
	if (!strncmp(next, "sub", len)) {
   10ca4:	494f      	ldr	r1, [pc, #316]	; (10de4 <mod_set+0x214>)
   10ca6:	6838      	ldr	r0, [r7, #0]
   10ca8:	464a      	mov	r2, r9
   10caa:	f016 fdbf 	bl	2782c <strncmp>
   10cae:	4601      	mov	r1, r0
   10cb0:	b948      	cbnz	r0, 10cc6 <mod_set+0xf6>
	(void)memset(mod->groups, 0, sizeof(mod->groups));
   10cb2:	350e      	adds	r5, #14
   10cb4:	2204      	movs	r2, #4
   10cb6:	4628      	mov	r0, r5
   10cb8:	f016 fde5 	bl	27886 <memset>
	if (len_rd == 0) {
   10cbc:	2e00      	cmp	r6, #0
   10cbe:	d0d6      	beq.n	10c6e <mod_set+0x9e>
	len = read_cb(cb_arg, mod->groups, sizeof(mod->groups));
   10cc0:	2204      	movs	r2, #4
   10cc2:	4629      	mov	r1, r5
   10cc4:	e7dc      	b.n	10c80 <mod_set+0xb0>
	if (!strncmp(next, "pub", len)) {
   10cc6:	4948      	ldr	r1, [pc, #288]	; (10de8 <mod_set+0x218>)
   10cc8:	6838      	ldr	r0, [r7, #0]
   10cca:	464a      	mov	r2, r9
   10ccc:	f016 fdae 	bl	2782c <strncmp>
   10cd0:	4604      	mov	r4, r0
   10cd2:	2800      	cmp	r0, #0
   10cd4:	d150      	bne.n	10d78 <mod_set+0x1a8>
	if (!mod->pub) {
   10cd6:	68ab      	ldr	r3, [r5, #8]
   10cd8:	b973      	cbnz	r3, 10cf8 <mod_set+0x128>
		BT_WARN("Model has no publication context!");
   10cda:	4b44      	ldr	r3, [pc, #272]	; (10dec <mod_set+0x21c>)
   10cdc:	623b      	str	r3, [r7, #32]
   10cde:	483d      	ldr	r0, [pc, #244]	; (10dd4 <mod_set+0x204>)
   10ce0:	2302      	movs	r3, #2
   10ce2:	f107 021c 	add.w	r2, r7, #28
   10ce6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   10cea:	60bb      	str	r3, [r7, #8]
   10cec:	61fb      	str	r3, [r7, #28]
		return -EINVAL;
   10cee:	f06f 0415 	mvn.w	r4, #21
		BT_WARN("Model has no publication context!");
   10cf2:	f019 f96c 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   10cf6:	e7bb      	b.n	10c70 <mod_set+0xa0>
	if (len_rd == 0) {
   10cf8:	b946      	cbnz	r6, 10d0c <mod_set+0x13c>
		mod->pub->addr = BT_MESH_ADDR_UNASSIGNED;
   10cfa:	685a      	ldr	r2, [r3, #4]
   10cfc:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
   10d00:	605a      	str	r2, [r3, #4]
		mod->pub->ttl = 0U;
   10d02:	689a      	ldr	r2, [r3, #8]
   10d04:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
   10d08:	609a      	str	r2, [r3, #8]
		return 0;
   10d0a:	e7b1      	b.n	10c70 <mod_set+0xa0>
	err = bt_mesh_settings_set(read_cb, cb_arg, &pub, sizeof(pub));
   10d0c:	2308      	movs	r3, #8
   10d0e:	18fa      	adds	r2, r7, r3
   10d10:	4651      	mov	r1, sl
   10d12:	4640      	mov	r0, r8
   10d14:	f004 f9d0 	bl	150b8 <bt_mesh_settings_set>
	if (err) {
   10d18:	4604      	mov	r4, r0
   10d1a:	b148      	cbz	r0, 10d30 <mod_set+0x160>
		BT_ERR("Failed to set \'model-pub\'");
   10d1c:	4b34      	ldr	r3, [pc, #208]	; (10df0 <mod_set+0x220>)
   10d1e:	623b      	str	r3, [r7, #32]
   10d20:	2302      	movs	r3, #2
   10d22:	607b      	str	r3, [r7, #4]
   10d24:	61fb      	str	r3, [r7, #28]
   10d26:	f107 021c 	add.w	r2, r7, #28
   10d2a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   10d2e:	e7b5      	b.n	10c9c <mod_set+0xcc>
	mod->pub->addr = pub.addr;
   10d30:	68aa      	ldr	r2, [r5, #8]
   10d32:	893b      	ldrh	r3, [r7, #8]
   10d34:	8093      	strh	r3, [r2, #4]
	mod->pub->cred = pub.cred;
   10d36:	7bfb      	ldrb	r3, [r7, #15]
	mod->pub->key = pub.key;
   10d38:	f3c3 1100 	ubfx	r1, r3, #4, #1
   10d3c:	897b      	ldrh	r3, [r7, #10]
   10d3e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   10d42:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
   10d46:	88d1      	ldrh	r1, [r2, #6]
   10d48:	f421 51ff 	bic.w	r1, r1, #8160	; 0x1fe0
   10d4c:	f021 011f 	bic.w	r1, r1, #31
   10d50:	430b      	orrs	r3, r1
   10d52:	80d3      	strh	r3, [r2, #6]
	mod->pub->ttl = pub.ttl;
   10d54:	89bb      	ldrh	r3, [r7, #12]
   10d56:	8113      	strh	r3, [r2, #8]
	mod->pub->period = pub.period;
   10d58:	8953      	ldrh	r3, [r2, #10]
   10d5a:	89f9      	ldrh	r1, [r7, #14]
   10d5c:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   10d60:	f023 030f 	bic.w	r3, r3, #15
   10d64:	f3c1 010b 	ubfx	r1, r1, #0, #12
   10d68:	430b      	orrs	r3, r1
   10d6a:	8153      	strh	r3, [r2, #10]
	mod->pub->count = 0U;
   10d6c:	f3c3 2307 	ubfx	r3, r3, #8, #8
   10d70:	f360 1307 	bfi	r3, r0, #4, #4
   10d74:	72d3      	strb	r3, [r2, #11]
		return mod_set_pub(mod, len_rd, read_cb, cb_arg);
   10d76:	e77b      	b.n	10c70 <mod_set+0xa0>
	if (!strncmp(next, "data", len)) {
   10d78:	491e      	ldr	r1, [pc, #120]	; (10df4 <mod_set+0x224>)
   10d7a:	6838      	ldr	r0, [r7, #0]
   10d7c:	464a      	mov	r2, r9
   10d7e:	f016 fd55 	bl	2782c <strncmp>
   10d82:	4604      	mov	r4, r0
   10d84:	b9b8      	cbnz	r0, 10db6 <mod_set+0x1e6>
	settings_name_next(name, &next);
   10d86:	6838      	ldr	r0, [r7, #0]
   10d88:	f107 0110 	add.w	r1, r7, #16
   10d8c:	f015 fa5a 	bl	26244 <settings_name_next>
	if (mod->cb && mod->cb->settings_set) {
   10d90:	69ab      	ldr	r3, [r5, #24]
   10d92:	2b00      	cmp	r3, #0
   10d94:	f43f af6c 	beq.w	10c70 <mod_set+0xa0>
   10d98:	f8d3 9000 	ldr.w	r9, [r3]
   10d9c:	f1b9 0f00 	cmp.w	r9, #0
   10da0:	f43f af66 	beq.w	10c70 <mod_set+0xa0>
		return mod->cb->settings_set(mod, next, len_rd,
   10da4:	f8cd a000 	str.w	sl, [sp]
   10da8:	6939      	ldr	r1, [r7, #16]
   10daa:	4643      	mov	r3, r8
   10dac:	4632      	mov	r2, r6
   10dae:	4628      	mov	r0, r5
   10db0:	47c8      	blx	r9
   10db2:	4604      	mov	r4, r0
		return mod_data_set(mod, next, len_rd, read_cb, cb_arg);
   10db4:	e75c      	b.n	10c70 <mod_set+0xa0>
	BT_WARN("Unknown module key %s", next);
   10db6:	683b      	ldr	r3, [r7, #0]
   10db8:	9302      	str	r3, [sp, #8]
   10dba:	4b0f      	ldr	r3, [pc, #60]	; (10df8 <mod_set+0x228>)
   10dbc:	9301      	str	r3, [sp, #4]
   10dbe:	2300      	movs	r3, #0
   10dc0:	4904      	ldr	r1, [pc, #16]	; (10dd4 <mod_set+0x204>)
   10dc2:	9300      	str	r3, [sp, #0]
   10dc4:	2202      	movs	r2, #2
   10dc6:	4618      	mov	r0, r3
   10dc8:	f019 f904 	bl	29fd4 <z_log_msg2_runtime_create.constprop.0>
   10dcc:	e73b      	b.n	10c46 <mod_set+0x76>
   10dce:	bf00      	nop
   10dd0:	0002f4d6 	.word	0x0002f4d6
   10dd4:	0002dacc 	.word	0x0002dacc
   10dd8:	000319e8 	.word	0x000319e8
   10ddc:	000318e6 	.word	0x000318e6
   10de0:	00031a17 	.word	0x00031a17
   10de4:	00031904 	.word	0x00031904
   10de8:	00031908 	.word	0x00031908
   10dec:	00031a36 	.word	0x00031a36
   10df0:	00031a58 	.word	0x00031a58
   10df4:	0002ff67 	.word	0x0002ff67
   10df8:	00031a72 	.word	0x00031a72

00010dfc <bt_mesh_comp_register>:
{
   10dfc:	b507      	push	{r0, r1, r2, lr}
	if (!comp || !comp->elem_count) {
   10dfe:	b168      	cbz	r0, 10e1c <bt_mesh_comp_register+0x20>
   10e00:	6883      	ldr	r3, [r0, #8]
   10e02:	b15b      	cbz	r3, 10e1c <bt_mesh_comp_register+0x20>
	dev_comp = comp;
   10e04:	4b07      	ldr	r3, [pc, #28]	; (10e24 <bt_mesh_comp_register+0x28>)
	bt_mesh_model_foreach(mod_init, &err);
   10e06:	a901      	add	r1, sp, #4
	dev_comp = comp;
   10e08:	6018      	str	r0, [r3, #0]
	bt_mesh_model_foreach(mod_init, &err);
   10e0a:	4807      	ldr	r0, [pc, #28]	; (10e28 <bt_mesh_comp_register+0x2c>)
	err = 0;
   10e0c:	2300      	movs	r3, #0
   10e0e:	9301      	str	r3, [sp, #4]
	bt_mesh_model_foreach(mod_init, &err);
   10e10:	f7ff fd26 	bl	10860 <bt_mesh_model_foreach>
	return err;
   10e14:	9801      	ldr	r0, [sp, #4]
}
   10e16:	b003      	add	sp, #12
   10e18:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EINVAL;
   10e1c:	f06f 0015 	mvn.w	r0, #21
   10e20:	e7f9      	b.n	10e16 <bt_mesh_comp_register+0x1a>
   10e22:	bf00      	nop
   10e24:	20002780 	.word	0x20002780
   10e28:	000105f5 	.word	0x000105f5

00010e2c <bt_mesh_comp_provision>:
	dev_primary_addr = addr;
   10e2c:	4b08      	ldr	r3, [pc, #32]	; (10e50 <bt_mesh_comp_provision+0x24>)
{
   10e2e:	b570      	push	{r4, r5, r6, lr}
	dev_primary_addr = addr;
   10e30:	8018      	strh	r0, [r3, #0]
	for (i = 0; i < dev_comp->elem_count; i++) {
   10e32:	4b08      	ldr	r3, [pc, #32]	; (10e54 <bt_mesh_comp_provision+0x28>)
   10e34:	6819      	ldr	r1, [r3, #0]
   10e36:	688c      	ldr	r4, [r1, #8]
   10e38:	2300      	movs	r3, #0
   10e3a:	18c2      	adds	r2, r0, r3
   10e3c:	42a3      	cmp	r3, r4
   10e3e:	b292      	uxth	r2, r2
   10e40:	d100      	bne.n	10e44 <bt_mesh_comp_provision+0x18>
}
   10e42:	bd70      	pop	{r4, r5, r6, pc}
		elem->addr = addr++;
   10e44:	011d      	lsls	r5, r3, #4
   10e46:	68ce      	ldr	r6, [r1, #12]
	for (i = 0; i < dev_comp->elem_count; i++) {
   10e48:	3301      	adds	r3, #1
		elem->addr = addr++;
   10e4a:	5372      	strh	r2, [r6, r5]
	for (i = 0; i < dev_comp->elem_count; i++) {
   10e4c:	e7f5      	b.n	10e3a <bt_mesh_comp_provision+0xe>
   10e4e:	bf00      	nop
   10e50:	200038e2 	.word	0x200038e2
   10e54:	20002780 	.word	0x20002780

00010e58 <bt_mesh_comp_unprovision>:
	dev_primary_addr = BT_MESH_ADDR_UNASSIGNED;
   10e58:	4b01      	ldr	r3, [pc, #4]	; (10e60 <bt_mesh_comp_unprovision+0x8>)
   10e5a:	2200      	movs	r2, #0
   10e5c:	801a      	strh	r2, [r3, #0]
}
   10e5e:	4770      	bx	lr
   10e60:	200038e2 	.word	0x200038e2

00010e64 <bt_mesh_primary_addr>:
}
   10e64:	4b01      	ldr	r3, [pc, #4]	; (10e6c <bt_mesh_primary_addr+0x8>)
   10e66:	8818      	ldrh	r0, [r3, #0]
   10e68:	4770      	bx	lr
   10e6a:	bf00      	nop
   10e6c:	200038e2 	.word	0x200038e2

00010e70 <bt_mesh_elem_find>:
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   10e70:	b203      	sxth	r3, r0
   10e72:	2b00      	cmp	r3, #0
   10e74:	dd0b      	ble.n	10e8e <bt_mesh_elem_find+0x1e>
	index = addr - dev_comp->elem[0].addr;
   10e76:	4b07      	ldr	r3, [pc, #28]	; (10e94 <bt_mesh_elem_find+0x24>)
   10e78:	681a      	ldr	r2, [r3, #0]
   10e7a:	68d3      	ldr	r3, [r2, #12]
	if (index >= dev_comp->elem_count) {
   10e7c:	6892      	ldr	r2, [r2, #8]
	index = addr - dev_comp->elem[0].addr;
   10e7e:	8819      	ldrh	r1, [r3, #0]
   10e80:	1a40      	subs	r0, r0, r1
	if (index >= dev_comp->elem_count) {
   10e82:	b280      	uxth	r0, r0
   10e84:	4290      	cmp	r0, r2
   10e86:	d202      	bcs.n	10e8e <bt_mesh_elem_find+0x1e>
	return &dev_comp->elem[index];
   10e88:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   10e8c:	4770      	bx	lr
		return NULL;
   10e8e:	2000      	movs	r0, #0
}
   10e90:	4770      	bx	lr
   10e92:	bf00      	nop
   10e94:	20002780 	.word	0x20002780

00010e98 <bt_mesh_has_addr>:
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
   10e98:	b202      	sxth	r2, r0
   10e9a:	2a00      	cmp	r2, #0
{
   10e9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10e9e:	4603      	mov	r3, r0
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
   10ea0:	dc09      	bgt.n	10eb6 <bt_mesh_has_addr+0x1e>
	for (index = 0; index < dev_comp->elem_count; index++) {
   10ea2:	4a1c      	ldr	r2, [pc, #112]	; (10f14 <bt_mesh_has_addr+0x7c>)
   10ea4:	6815      	ldr	r5, [r2, #0]
   10ea6:	68af      	ldr	r7, [r5, #8]
   10ea8:	2400      	movs	r4, #0
		model = &elem->models[i];
   10eaa:	2624      	movs	r6, #36	; 0x24
	for (index = 0; index < dev_comp->elem_count; index++) {
   10eac:	b2a2      	uxth	r2, r4
   10eae:	4297      	cmp	r7, r2
   10eb0:	d807      	bhi.n	10ec2 <bt_mesh_has_addr+0x2a>
	return false;
   10eb2:	2000      	movs	r0, #0
   10eb4:	e004      	b.n	10ec0 <bt_mesh_has_addr+0x28>
		return bt_mesh_elem_find(addr) != NULL;
   10eb6:	f7ff ffdb 	bl	10e70 <bt_mesh_elem_find>
   10eba:	3800      	subs	r0, #0
   10ebc:	bf18      	it	ne
   10ebe:	2001      	movne	r0, #1
}
   10ec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		struct bt_mesh_elem *elem = &dev_comp->elem[index];
   10ec2:	68e9      	ldr	r1, [r5, #12]
   10ec4:	eb01 1202 	add.w	r2, r1, r2, lsl #4
	for (i = 0; i < elem->model_count; i++) {
   10ec8:	2100      	movs	r1, #0
   10eca:	f892 c004 	ldrb.w	ip, [r2, #4]
   10ece:	4561      	cmp	r1, ip
   10ed0:	db06      	blt.n	10ee0 <bt_mesh_has_addr+0x48>
	for (i = 0; i < elem->vnd_model_count; i++) {
   10ed2:	f892 c005 	ldrb.w	ip, [r2, #5]
   10ed6:	2100      	movs	r1, #0
   10ed8:	4561      	cmp	r1, ip
   10eda:	db0d      	blt.n	10ef8 <bt_mesh_has_addr+0x60>
	for (index = 0; index < dev_comp->elem_count; index++) {
   10edc:	3401      	adds	r4, #1
   10ede:	e7e5      	b.n	10eac <bt_mesh_has_addr+0x14>
		model = &elem->models[i];
   10ee0:	6890      	ldr	r0, [r2, #8]
   10ee2:	fb06 0001 	mla	r0, r6, r1, r0
		if (mod->groups[i] == addr) {
   10ee6:	f8b0 e00e 	ldrh.w	lr, [r0, #14]
   10eea:	459e      	cmp	lr, r3
   10eec:	d010      	beq.n	10f10 <bt_mesh_has_addr+0x78>
   10eee:	8a00      	ldrh	r0, [r0, #16]
   10ef0:	4298      	cmp	r0, r3
   10ef2:	d00d      	beq.n	10f10 <bt_mesh_has_addr+0x78>
	for (i = 0; i < elem->model_count; i++) {
   10ef4:	3101      	adds	r1, #1
   10ef6:	e7ea      	b.n	10ece <bt_mesh_has_addr+0x36>
		model = &elem->vnd_models[i];
   10ef8:	68d0      	ldr	r0, [r2, #12]
   10efa:	fb06 0001 	mla	r0, r6, r1, r0
		if (mod->groups[i] == addr) {
   10efe:	f8b0 e00e 	ldrh.w	lr, [r0, #14]
   10f02:	459e      	cmp	lr, r3
   10f04:	d004      	beq.n	10f10 <bt_mesh_has_addr+0x78>
   10f06:	8a00      	ldrh	r0, [r0, #16]
   10f08:	4298      	cmp	r0, r3
   10f0a:	d001      	beq.n	10f10 <bt_mesh_has_addr+0x78>
	for (i = 0; i < elem->vnd_model_count; i++) {
   10f0c:	3101      	adds	r1, #1
   10f0e:	e7e3      	b.n	10ed8 <bt_mesh_has_addr+0x40>
			return true;
   10f10:	2001      	movs	r0, #1
   10f12:	e7d5      	b.n	10ec0 <bt_mesh_has_addr+0x28>
   10f14:	20002780 	.word	0x20002780

00010f18 <bt_mesh_msg_send>:
{
   10f18:	b530      	push	{r4, r5, lr}
   10f1a:	b08b      	sub	sp, #44	; 0x2c
   10f1c:	461d      	mov	r5, r3
	struct bt_mesh_net_tx tx = {
   10f1e:	2300      	movs	r3, #0
   10f20:	e9cd 0302 	strd	r0, r3, [sp, #8]
{
   10f24:	460c      	mov	r4, r1
	struct bt_mesh_net_tx tx = {
   10f26:	9301      	str	r3, [sp, #4]
   10f28:	f8ad 200c 	strh.w	r2, [sp, #12]
	if (!bt_mesh_is_provisioned()) {
   10f2c:	f7fa fd48 	bl	b9c0 <bt_mesh_is_provisioned>
   10f30:	b970      	cbnz	r0, 10f50 <bt_mesh_msg_send+0x38>
		BT_ERR("Local node is not yet provisioned");
   10f32:	4b0b      	ldr	r3, [pc, #44]	; (10f60 <bt_mesh_msg_send+0x48>)
   10f34:	480b      	ldr	r0, [pc, #44]	; (10f64 <bt_mesh_msg_send+0x4c>)
   10f36:	9308      	str	r3, [sp, #32]
   10f38:	aa07      	add	r2, sp, #28
   10f3a:	2302      	movs	r3, #2
   10f3c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   10f40:	9300      	str	r3, [sp, #0]
   10f42:	9307      	str	r3, [sp, #28]
   10f44:	f019 f843 	bl	29fce <z_log_msg2_static_create.constprop.0>
		return -EAGAIN;
   10f48:	f06f 000a 	mvn.w	r0, #10
}
   10f4c:	b00b      	add	sp, #44	; 0x2c
   10f4e:	bd30      	pop	{r4, r5, pc}
	return bt_mesh_trans_send(&tx, buf, cb, cb_data);
   10f50:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   10f52:	462a      	mov	r2, r5
   10f54:	4621      	mov	r1, r4
   10f56:	a801      	add	r0, sp, #4
   10f58:	f7fd fff4 	bl	ef44 <bt_mesh_trans_send>
   10f5c:	e7f6      	b.n	10f4c <bt_mesh_msg_send+0x34>
   10f5e:	bf00      	nop
   10f60:	00031a88 	.word	0x00031a88
   10f64:	0002dacc 	.word	0x0002dacc

00010f68 <bt_mesh_elem_count>:
	return dev_comp->elem_count;
   10f68:	4b01      	ldr	r3, [pc, #4]	; (10f70 <bt_mesh_elem_count+0x8>)
   10f6a:	681b      	ldr	r3, [r3, #0]
}
   10f6c:	7a18      	ldrb	r0, [r3, #8]
   10f6e:	4770      	bx	lr
   10f70:	20002780 	.word	0x20002780

00010f74 <bt_mesh_model_send>:
{
   10f74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10f78:	460c      	mov	r4, r1
   10f7a:	b088      	sub	sp, #32
	if (!bt_mesh_model_has_key(model, ctx->app_idx)) {
   10f7c:	8849      	ldrh	r1, [r1, #2]
{
   10f7e:	4607      	mov	r7, r0
   10f80:	4615      	mov	r5, r2
   10f82:	461e      	mov	r6, r3
	if (!bt_mesh_model_has_key(model, ctx->app_idx)) {
   10f84:	f019 f86a 	bl	2a05c <bt_mesh_model_has_key>
   10f88:	b158      	cbz	r0, 10fa2 <bt_mesh_model_send+0x2e>
	return bt_mesh_msg_send(ctx, msg, bt_mesh_model_elem(model)->addr, cb, cb_data);
   10f8a:	4638      	mov	r0, r7
   10f8c:	f7ff fd3a 	bl	10a04 <bt_mesh_model_elem>
   10f90:	8802      	ldrh	r2, [r0, #0]
   10f92:	4633      	mov	r3, r6
   10f94:	4629      	mov	r1, r5
   10f96:	4620      	mov	r0, r4
}
   10f98:	b008      	add	sp, #32
   10f9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_mesh_msg_send(ctx, msg, bt_mesh_model_elem(model)->addr, cb, cb_data);
   10f9e:	f7ff bfbb 	b.w	10f18 <bt_mesh_msg_send>
		BT_ERR("Model not bound to AppKey 0x%04x", ctx->app_idx);
   10fa2:	4b08      	ldr	r3, [pc, #32]	; (10fc4 <bt_mesh_model_send+0x50>)
   10fa4:	4808      	ldr	r0, [pc, #32]	; (10fc8 <bt_mesh_model_send+0x54>)
   10fa6:	e9cd 3106 	strd	r3, r1, [sp, #24]
   10faa:	aa05      	add	r2, sp, #20
   10fac:	2303      	movs	r3, #3
   10fae:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   10fb2:	9301      	str	r3, [sp, #4]
   10fb4:	9305      	str	r3, [sp, #20]
   10fb6:	f019 f80a 	bl	29fce <z_log_msg2_static_create.constprop.0>
}
   10fba:	f06f 0015 	mvn.w	r0, #21
   10fbe:	b008      	add	sp, #32
   10fc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10fc4:	00031aaa 	.word	0x00031aaa
   10fc8:	0002dacc 	.word	0x0002dacc

00010fcc <bt_mesh_comp_get>:
}
   10fcc:	4b01      	ldr	r3, [pc, #4]	; (10fd4 <bt_mesh_comp_get+0x8>)
   10fce:	6818      	ldr	r0, [r3, #0]
   10fd0:	4770      	bx	lr
   10fd2:	bf00      	nop
   10fd4:	20002780 	.word	0x20002780

00010fd8 <bt_mesh_model_find_group>:
{
   10fd8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   10fda:	4604      	mov	r4, r0
	struct find_group_visitor_ctx ctx = {
   10fdc:	2300      	movs	r3, #0
		.mod = *mod,
   10fde:	6800      	ldr	r0, [r0, #0]
	struct find_group_visitor_ctx ctx = {
   10fe0:	f8ad 100c 	strh.w	r1, [sp, #12]
	bt_mesh_model_extensions_walk(*mod, find_group_mod_visitor, &ctx);
   10fe4:	aa01      	add	r2, sp, #4
   10fe6:	4905      	ldr	r1, [pc, #20]	; (10ffc <bt_mesh_model_find_group+0x24>)
	struct find_group_visitor_ctx ctx = {
   10fe8:	9301      	str	r3, [sp, #4]
   10fea:	9002      	str	r0, [sp, #8]
	bt_mesh_model_extensions_walk(*mod, find_group_mod_visitor, &ctx);
   10fec:	f019 f873 	bl	2a0d6 <bt_mesh_model_extensions_walk>
	*mod = ctx.mod;
   10ff0:	9b02      	ldr	r3, [sp, #8]
}
   10ff2:	9801      	ldr	r0, [sp, #4]
	*mod = ctx.mod;
   10ff4:	6023      	str	r3, [r4, #0]
}
   10ff6:	b004      	add	sp, #16
   10ff8:	bd10      	pop	{r4, pc}
   10ffa:	bf00      	nop
   10ffc:	00029f9b 	.word	0x00029f9b

00011000 <bt_mesh_model_recv>:
{
   11000:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	switch (buf->data[0] >> 6) {
   11004:	680b      	ldr	r3, [r1, #0]
   11006:	781a      	ldrb	r2, [r3, #0]
   11008:	0993      	lsrs	r3, r2, #6
   1100a:	2b02      	cmp	r3, #2
{
   1100c:	b08b      	sub	sp, #44	; 0x2c
   1100e:	4607      	mov	r7, r0
   11010:	460c      	mov	r4, r1
	switch (buf->data[0] >> 6) {
   11012:	d02d      	beq.n	11070 <bt_mesh_model_recv+0x70>
   11014:	2b03      	cmp	r3, #3
   11016:	d04a      	beq.n	110ae <bt_mesh_model_recv+0xae>
		if (buf->data[0] == 0x7f) {
   11018:	2a7f      	cmp	r2, #127	; 0x7f
   1101a:	d103      	bne.n	11024 <bt_mesh_model_recv+0x24>
			BT_ERR("Ignoring RFU OpCode");
   1101c:	4b5e      	ldr	r3, [pc, #376]	; (11198 <bt_mesh_model_recv+0x198>)
			BT_ERR("Too short payload for 3-octet OpCode");
   1101e:	9308      	str	r3, [sp, #32]
   11020:	2302      	movs	r3, #2
   11022:	e02a      	b.n	1107a <bt_mesh_model_recv+0x7a>
		*opcode = net_buf_simple_pull_u8(buf);
   11024:	4608      	mov	r0, r1
   11026:	f01a ff09 	bl	2be3c <net_buf_simple_pull_u8>
		*opcode = net_buf_simple_pull_be16(buf);
   1102a:	4605      	mov	r5, r0
			BT_ERR("Invalid message size for OpCode 0x%08x",
   1102c:	f8df a16c 	ldr.w	sl, [pc, #364]	; 1119c <bt_mesh_model_recv+0x19c>
	for (i = 0; i < dev_comp->elem_count; i++) {
   11030:	f04f 0900 	mov.w	r9, #0
   11034:	4b5a      	ldr	r3, [pc, #360]	; (111a0 <bt_mesh_model_recv+0x1a0>)
   11036:	681b      	ldr	r3, [r3, #0]
   11038:	689a      	ldr	r2, [r3, #8]
   1103a:	4591      	cmp	r9, r2
   1103c:	d230      	bcs.n	110a0 <bt_mesh_model_recv+0xa0>
		op = find_op(&dev_comp->elem[i], opcode, &model);
   1103e:	f8d3 800c 	ldr.w	r8, [r3, #12]
   11042:	eb08 1309 	add.w	r3, r8, r9, lsl #4
		models = elem->vnd_models;
   11046:	e9d3 2602 	ldrd	r2, r6, [r3, #8]
	if (BT_MESH_MODEL_OP_LEN(opcode) < 3) {
   1104a:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
		count = elem->model_count;
   1104e:	bf37      	itett	cc
   11050:	f893 c004 	ldrbcc.w	ip, [r3, #4]
		count = elem->vnd_model_count;
   11054:	f893 c005 	ldrbcs.w	ip, [r3, #5]
		models = elem->models;
   11058:	4616      	movcc	r6, r2
	uint32_t cid = UINT32_MAX;
   1105a:	f04f 30ff 	movcc.w	r0, #4294967295	; 0xffffffff
		cid = (uint16_t)(opcode & 0xffff);
   1105e:	bf28      	it	cs
   11060:	b2a8      	uxthcs	r0, r5
	for (i = 0U; i < count; i++) {
   11062:	2200      	movs	r2, #0
   11064:	b2d3      	uxtb	r3, r2
   11066:	4563      	cmp	r3, ip
   11068:	d330      	bcc.n	110cc <bt_mesh_model_recv+0xcc>
	for (i = 0; i < dev_comp->elem_count; i++) {
   1106a:	f109 0901 	add.w	r9, r9, #1
   1106e:	e7e1      	b.n	11034 <bt_mesh_model_recv+0x34>
		if (buf->len < 2) {
   11070:	888a      	ldrh	r2, [r1, #4]
   11072:	2a01      	cmp	r2, #1
   11074:	d817      	bhi.n	110a6 <bt_mesh_model_recv+0xa6>
			BT_ERR("Too short payload for 2-octet OpCode");
   11076:	4a4b      	ldr	r2, [pc, #300]	; (111a4 <bt_mesh_model_recv+0x1a4>)
   11078:	9208      	str	r2, [sp, #32]
   1107a:	4848      	ldr	r0, [pc, #288]	; (1119c <bt_mesh_model_recv+0x19c>)
   1107c:	9303      	str	r3, [sp, #12]
   1107e:	aa07      	add	r2, sp, #28
   11080:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11084:	9307      	str	r3, [sp, #28]
   11086:	f018 ffa2 	bl	29fce <z_log_msg2_static_create.constprop.0>
		BT_WARN("Unable to decode OpCode");
   1108a:	4b47      	ldr	r3, [pc, #284]	; (111a8 <bt_mesh_model_recv+0x1a8>)
   1108c:	9308      	str	r3, [sp, #32]
   1108e:	4843      	ldr	r0, [pc, #268]	; (1119c <bt_mesh_model_recv+0x19c>)
   11090:	2302      	movs	r3, #2
   11092:	aa07      	add	r2, sp, #28
   11094:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   11098:	9303      	str	r3, [sp, #12]
   1109a:	9307      	str	r3, [sp, #28]
   1109c:	f018 ff97 	bl	29fce <z_log_msg2_static_create.constprop.0>
}
   110a0:	b00b      	add	sp, #44	; 0x2c
   110a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*opcode = net_buf_simple_pull_be16(buf);
   110a6:	4608      	mov	r0, r1
   110a8:	f01a fed8 	bl	2be5c <net_buf_simple_pull_be16>
   110ac:	e7bd      	b.n	1102a <bt_mesh_model_recv+0x2a>
		if (buf->len < 3) {
   110ae:	888b      	ldrh	r3, [r1, #4]
   110b0:	2b02      	cmp	r3, #2
   110b2:	d801      	bhi.n	110b8 <bt_mesh_model_recv+0xb8>
			BT_ERR("Too short payload for 3-octet OpCode");
   110b4:	4b3d      	ldr	r3, [pc, #244]	; (111ac <bt_mesh_model_recv+0x1ac>)
   110b6:	e7b2      	b.n	1101e <bt_mesh_model_recv+0x1e>
		*opcode = net_buf_simple_pull_u8(buf) << 16;
   110b8:	4608      	mov	r0, r1
   110ba:	f01a febf 	bl	2be3c <net_buf_simple_pull_u8>
   110be:	4605      	mov	r5, r0
		*opcode |= net_buf_simple_pull_le16(buf);
   110c0:	4620      	mov	r0, r4
   110c2:	f01a fec3 	bl	2be4c <net_buf_simple_pull_le16>
   110c6:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
		return 0;
   110ca:	e7af      	b.n	1102c <bt_mesh_model_recv+0x2c>
		if (IS_ENABLED(CONFIG_BT_MESH_MODEL_VND_MSG_CID_FORCE) &&
   110cc:	1c41      	adds	r1, r0, #1
   110ce:	d002      	beq.n	110d6 <bt_mesh_model_recv+0xd6>
		     cid != models[i].vnd.company) {
   110d0:	8833      	ldrh	r3, [r6, #0]
		     cid != UINT32_MAX &&
   110d2:	4298      	cmp	r0, r3
   110d4:	d104      	bne.n	110e0 <bt_mesh_model_recv+0xe0>
		for (op = (*model)->op; op->func; op++) {
   110d6:	f8d6 b014 	ldr.w	fp, [r6, #20]
   110da:	f8db 1008 	ldr.w	r1, [fp, #8]
   110de:	b911      	cbnz	r1, 110e6 <bt_mesh_model_recv+0xe6>
	for (i = 0U; i < count; i++) {
   110e0:	3201      	adds	r2, #1
   110e2:	3624      	adds	r6, #36	; 0x24
   110e4:	e7be      	b.n	11064 <bt_mesh_model_recv+0x64>
			if (op->opcode == opcode) {
   110e6:	f8db 1000 	ldr.w	r1, [fp]
   110ea:	428d      	cmp	r5, r1
   110ec:	d02a      	beq.n	11144 <bt_mesh_model_recv+0x144>
		for (op = (*model)->op; op->func; op++) {
   110ee:	f10b 0b0c 	add.w	fp, fp, #12
   110f2:	e7f2      	b.n	110da <bt_mesh_model_recv+0xda>
	} else if (BT_MESH_ADDR_IS_GROUP(dst) || BT_MESH_ADDR_IS_VIRTUAL(dst)) {
   110f4:	f481 4200 	eor.w	r2, r1, #32768	; 0x8000
   110f8:	f5b2 4ffe 	cmp.w	r2, #32512	; 0x7f00
   110fc:	d806      	bhi.n	1110c <bt_mesh_model_recv+0x10c>
		return !!bt_mesh_model_find_group(&mod, dst);
   110fe:	a804      	add	r0, sp, #16
   11100:	f7ff ff6a 	bl	10fd8 <bt_mesh_model_find_group>
   11104:	3800      	subs	r0, #0
   11106:	bf18      	it	ne
   11108:	2001      	movne	r0, #1
   1110a:	e02e      	b.n	1116a <bt_mesh_model_recv+0x16a>
	return mod->elem_idx == 0;
   1110c:	7930      	ldrb	r0, [r6, #4]
   1110e:	fab0 f080 	clz	r0, r0
   11112:	0940      	lsrs	r0, r0, #5
   11114:	e029      	b.n	1116a <bt_mesh_model_recv+0x16a>
		} else if ((op->len < 0) && (buf->len != (size_t)(-op->len))) {
   11116:	42d1      	cmn	r1, r2
   11118:	d001      	beq.n	1111e <bt_mesh_model_recv+0x11e>
			BT_ERR("Invalid message size for OpCode 0x%08x",
   1111a:	4b25      	ldr	r3, [pc, #148]	; (111b0 <bt_mesh_model_recv+0x1b0>)
   1111c:	e030      	b.n	11180 <bt_mesh_model_recv+0x180>
	state->offset = net_buf_simple_headroom(buf);
   1111e:	4620      	mov	r0, r4
   11120:	f01a feaf 	bl	2be82 <net_buf_simple_headroom>
	state->len = buf->len;
   11124:	88a3      	ldrh	r3, [r4, #4]
   11126:	9301      	str	r3, [sp, #4]
	state->offset = net_buf_simple_headroom(buf);
   11128:	4680      	mov	r8, r0
		(void)op->func(model, &rx->ctx, buf);
   1112a:	f8db 3008 	ldr.w	r3, [fp, #8]
   1112e:	4622      	mov	r2, r4
   11130:	1d39      	adds	r1, r7, #4
   11132:	4630      	mov	r0, r6
   11134:	4798      	blx	r3
	buf->data = buf->__buf + state->offset;
   11136:	68a0      	ldr	r0, [r4, #8]
	buf->len = state->len;
   11138:	9b01      	ldr	r3, [sp, #4]
   1113a:	80a3      	strh	r3, [r4, #4]
	buf->data = buf->__buf + state->offset;
   1113c:	fa10 f088 	uxtah	r0, r0, r8
   11140:	6020      	str	r0, [r4, #0]
	buf->len = state->len;
   11142:	e792      	b.n	1106a <bt_mesh_model_recv+0x6a>
		if (!bt_mesh_model_has_key(model, rx->ctx.app_idx)) {
   11144:	88f9      	ldrh	r1, [r7, #6]
   11146:	4630      	mov	r0, r6
   11148:	f018 ff88 	bl	2a05c <bt_mesh_model_has_key>
   1114c:	2800      	cmp	r0, #0
   1114e:	d08c      	beq.n	1106a <bt_mesh_model_recv+0x6a>
	if (BT_MESH_ADDR_IS_UNICAST(dst)) {
   11150:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
		if (!model_has_dst(model, rx->ctx.recv_dst)) {
   11154:	8979      	ldrh	r1, [r7, #10]
   11156:	9604      	str	r6, [sp, #16]
	if (BT_MESH_ADDR_IS_UNICAST(dst)) {
   11158:	2a00      	cmp	r2, #0
   1115a:	ddcb      	ble.n	110f4 <bt_mesh_model_recv+0xf4>
		return (dev_comp->elem[mod->elem_idx].addr == dst);
   1115c:	7932      	ldrb	r2, [r6, #4]
   1115e:	0112      	lsls	r2, r2, #4
   11160:	f838 0002 	ldrh.w	r0, [r8, r2]
   11164:	1a43      	subs	r3, r0, r1
   11166:	4258      	negs	r0, r3
   11168:	4158      	adcs	r0, r3
		if (!model_has_dst(model, rx->ctx.recv_dst)) {
   1116a:	2800      	cmp	r0, #0
   1116c:	f43f af7d 	beq.w	1106a <bt_mesh_model_recv+0x6a>
		if ((op->len >= 0) && (buf->len < (size_t)op->len)) {
   11170:	f8db 2004 	ldr.w	r2, [fp, #4]
   11174:	88a1      	ldrh	r1, [r4, #4]
   11176:	2a00      	cmp	r2, #0
   11178:	dbcd      	blt.n	11116 <bt_mesh_model_recv+0x116>
   1117a:	428a      	cmp	r2, r1
   1117c:	d9cf      	bls.n	1111e <bt_mesh_model_recv+0x11e>
			BT_ERR("Too short message for OpCode 0x%08x", opcode);
   1117e:	4b0d      	ldr	r3, [pc, #52]	; (111b4 <bt_mesh_model_recv+0x1b4>)
			BT_ERR("Invalid message size for OpCode 0x%08x",
   11180:	e9cd 3508 	strd	r3, r5, [sp, #32]
   11184:	aa07      	add	r2, sp, #28
   11186:	2303      	movs	r3, #3
   11188:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   1118c:	4650      	mov	r0, sl
   1118e:	9303      	str	r3, [sp, #12]
   11190:	9307      	str	r3, [sp, #28]
   11192:	f018 ff1c 	bl	29fce <z_log_msg2_static_create.constprop.0>
			continue;
   11196:	e768      	b.n	1106a <bt_mesh_model_recv+0x6a>
   11198:	00031acb 	.word	0x00031acb
   1119c:	0002dacc 	.word	0x0002dacc
   111a0:	20002780 	.word	0x20002780
   111a4:	00031adf 	.word	0x00031adf
   111a8:	00031b29 	.word	0x00031b29
   111ac:	00031b04 	.word	0x00031b04
   111b0:	00031b65 	.word	0x00031b65
   111b4:	00031b41 	.word	0x00031b41

000111b8 <bt_mesh_model_pending_store>:

void bt_mesh_model_pending_store(void)
{
	bt_mesh_model_foreach(store_pending_mod, NULL);
   111b8:	4801      	ldr	r0, [pc, #4]	; (111c0 <bt_mesh_model_pending_store+0x8>)
   111ba:	2100      	movs	r1, #0
   111bc:	f7ff bb50 	b.w	10860 <bt_mesh_model_foreach>
   111c0:	000106e1 	.word	0x000106e1

000111c4 <bt_mesh_model_settings_commit>:
	}
}

void bt_mesh_model_settings_commit(void)
{
	bt_mesh_model_foreach(commit_mod, NULL);
   111c4:	4801      	ldr	r0, [pc, #4]	; (111cc <bt_mesh_model_settings_commit+0x8>)
   111c6:	2100      	movs	r1, #0
   111c8:	f7ff bb4a 	b.w	10860 <bt_mesh_model_foreach>
   111cc:	00029ff1 	.word	0x00029ff1

000111d0 <app_key_evt>:
	mod_unbind(mod, *app_idx, true);
}

static void app_key_evt(uint16_t app_idx, uint16_t net_idx,
			enum bt_mesh_key_evt evt)
{
   111d0:	b507      	push	{r0, r1, r2, lr}
	if (evt == BT_MESH_KEY_DELETED) {
   111d2:	2a01      	cmp	r2, #1
{
   111d4:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (evt == BT_MESH_KEY_DELETED) {
   111d8:	d104      	bne.n	111e4 <app_key_evt+0x14>
		bt_mesh_model_foreach(&mod_app_key_del, &app_idx);
   111da:	4804      	ldr	r0, [pc, #16]	; (111ec <app_key_evt+0x1c>)
   111dc:	f10d 0106 	add.w	r1, sp, #6
   111e0:	f7ff fb3e 	bl	10860 <bt_mesh_model_foreach>
	}
}
   111e4:	b003      	add	sp, #12
   111e6:	f85d fb04 	ldr.w	pc, [sp], #4
   111ea:	bf00      	nop
   111ec:	0002a22f 	.word	0x0002a22f

000111f0 <_mod_pub_set.constprop.0>:
static uint8_t _mod_pub_set(struct bt_mesh_model *model, uint16_t pub_addr,
   111f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   111f4:	b083      	sub	sp, #12
   111f6:	4604      	mov	r4, r0
   111f8:	af00      	add	r7, sp, #0
	if (!model->pub) {
   111fa:	6880      	ldr	r0, [r0, #8]
static uint8_t _mod_pub_set(struct bt_mesh_model *model, uint16_t pub_addr,
   111fc:	f897 802c 	ldrb.w	r8, [r7, #44]	; 0x2c
   11200:	460e      	mov	r6, r1
   11202:	4691      	mov	r9, r2
   11204:	461d      	mov	r5, r3
	if (!model->pub) {
   11206:	2800      	cmp	r0, #0
   11208:	d07c      	beq.n	11304 <_mod_pub_set.constprop.0+0x114>
	if (!IS_ENABLED(CONFIG_BT_MESH_LOW_POWER) && cred_flag) {
   1120a:	2b00      	cmp	r3, #0
   1120c:	d178      	bne.n	11300 <_mod_pub_set.constprop.0+0x110>
	if (!model->pub->update && period) {
   1120e:	6942      	ldr	r2, [r0, #20]
   11210:	b912      	cbnz	r2, 11218 <_mod_pub_set.constprop.0+0x28>
   11212:	f1b8 0f00 	cmp.w	r8, #0
   11216:	d175      	bne.n	11304 <_mod_pub_set.constprop.0+0x114>
	if (pub_addr == BT_MESH_ADDR_UNASSIGNED) {
   11218:	b9ae      	cbnz	r6, 11246 <_mod_pub_set.constprop.0+0x56>
		if (model->pub->addr == BT_MESH_ADDR_UNASSIGNED) {
   1121a:	8883      	ldrh	r3, [r0, #4]
   1121c:	b173      	cbz	r3, 1123c <_mod_pub_set.constprop.0+0x4c>
		model->pub->addr = BT_MESH_ADDR_UNASSIGNED;
   1121e:	6843      	ldr	r3, [r0, #4]
   11220:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   11224:	6043      	str	r3, [r0, #4]
		model->pub->ttl = 0U;
   11226:	6883      	ldr	r3, [r0, #8]
   11228:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
   1122c:	6083      	str	r3, [r0, #8]
		if (model->pub->update) {
   1122e:	b112      	cbz	r2, 11236 <_mod_pub_set.constprop.0+0x46>
			(void)k_work_cancel_delayable(&model->pub->timer);
   11230:	3018      	adds	r0, #24
   11232:	f01b fde8 	bl	2ce06 <k_work_cancel_delayable>
			bt_mesh_model_pub_store(model);
   11236:	4620      	mov	r0, r4
   11238:	f018 ff6e 	bl	2a118 <bt_mesh_model_pub_store>
}
   1123c:	4628      	mov	r0, r5
   1123e:	370c      	adds	r7, #12
   11240:	46bd      	mov	sp, r7
   11242:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!bt_mesh_app_key_exists(app_idx) || !bt_mesh_model_has_key(model, app_idx)) {
   11246:	4648      	mov	r0, r9
   11248:	f7fc fea0 	bl	df8c <bt_mesh_app_key_exists>
   1124c:	b908      	cbnz	r0, 11252 <_mod_pub_set.constprop.0+0x62>
		return STATUS_INVALID_APPKEY;
   1124e:	2503      	movs	r5, #3
   11250:	e7f4      	b.n	1123c <_mod_pub_set.constprop.0+0x4c>
	if (!bt_mesh_app_key_exists(app_idx) || !bt_mesh_model_has_key(model, app_idx)) {
   11252:	4649      	mov	r1, r9
   11254:	4620      	mov	r0, r4
   11256:	f018 ff01 	bl	2a05c <bt_mesh_model_has_key>
   1125a:	2800      	cmp	r0, #0
   1125c:	d0f7      	beq.n	1124e <_mod_pub_set.constprop.0+0x5e>
	if (BT_MESH_ADDR_IS_VIRTUAL(model->pub->addr)) {
   1125e:	68a3      	ldr	r3, [r4, #8]
   11260:	8898      	ldrh	r0, [r3, #4]
   11262:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
   11266:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   1126a:	d205      	bcs.n	11278 <_mod_pub_set.constprop.0+0x88>
		uint8_t *uuid = bt_mesh_va_label_get(model->pub->addr);
   1126c:	f7fd fe3e 	bl	eeec <bt_mesh_va_label_get>
		if (uuid) {
   11270:	b110      	cbz	r0, 11278 <_mod_pub_set.constprop.0+0x88>
			bt_mesh_va_del(uuid, NULL);
   11272:	2100      	movs	r1, #0
   11274:	f7fd fdfe 	bl	ee74 <bt_mesh_va_del>
	model->pub->addr = pub_addr;
   11278:	68a3      	ldr	r3, [r4, #8]
	model->pub->ttl = ttl;
   1127a:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
	model->pub->addr = pub_addr;
   1127e:	809e      	strh	r6, [r3, #4]
	model->pub->key = app_idx;
   11280:	88de      	ldrh	r6, [r3, #6]
	model->pub->ttl = ttl;
   11282:	721a      	strb	r2, [r3, #8]
	model->pub->key = app_idx;
   11284:	f426 56ff 	bic.w	r6, r6, #8160	; 0x1fe0
   11288:	f026 061f 	bic.w	r6, r6, #31
   1128c:	f3c9 090c 	ubfx	r9, r9, #0, #13
	model->pub->retransmit = retransmit;
   11290:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
	model->pub->period = period;
   11294:	f883 800a 	strb.w	r8, [r3, #10]
	model->pub->key = app_idx;
   11298:	ea46 0609 	orr.w	r6, r6, r9
   1129c:	80de      	strh	r6, [r3, #6]
	model->pub->retransmit = retransmit;
   1129e:	725a      	strb	r2, [r3, #9]
	if (model->pub->update) {
   112a0:	695b      	ldr	r3, [r3, #20]
   112a2:	2b00      	cmp	r3, #0
   112a4:	d0c7      	beq.n	11236 <_mod_pub_set.constprop.0+0x46>
		period_ms = bt_mesh_model_pub_period_get(model);
   112a6:	4620      	mov	r0, r4
   112a8:	f7ff fb16 	bl	108d8 <bt_mesh_model_pub_period_get>
		BT_DBG("period %u ms", period_ms);
   112ac:	46e8      	mov	r8, sp
   112ae:	b088      	sub	sp, #32
   112b0:	466a      	mov	r2, sp
   112b2:	4b15      	ldr	r3, [pc, #84]	; (11308 <_mod_pub_set.constprop.0+0x118>)
   112b4:	6113      	str	r3, [r2, #16]
   112b6:	4b15      	ldr	r3, [pc, #84]	; (1130c <_mod_pub_set.constprop.0+0x11c>)
   112b8:	e9c2 3005 	strd	r3, r0, [r2, #20]
   112bc:	2304      	movs	r3, #4
		period_ms = bt_mesh_model_pub_period_get(model);
   112be:	4606      	mov	r6, r0
		BT_DBG("period %u ms", period_ms);
   112c0:	f842 3f0c 	str.w	r3, [r2, #12]!
   112c4:	4812      	ldr	r0, [pc, #72]	; (11310 <_mod_pub_set.constprop.0+0x120>)
   112c6:	607b      	str	r3, [r7, #4]
   112c8:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   112cc:	f018 ffac 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		if (period_ms > 0) {
   112d0:	2e00      	cmp	r6, #0
   112d2:	68a0      	ldr	r0, [r4, #8]
   112d4:	46c5      	mov	sp, r8
   112d6:	ddab      	ble.n	11230 <_mod_pub_set.constprop.0+0x40>
			k_work_reschedule(&model->pub->timer,
   112d8:	f100 0818 	add.w	r8, r0, #24
   112dc:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   112e0:	f240 30e7 	movw	r0, #999	; 0x3e7
   112e4:	2100      	movs	r1, #0
   112e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   112ea:	2300      	movs	r3, #0
   112ec:	fbc6 010c 	smlal	r0, r1, r6, ip
   112f0:	f7ee fef6 	bl	e0 <__aeabi_uldivmod>
   112f4:	4602      	mov	r2, r0
   112f6:	460b      	mov	r3, r1
   112f8:	4640      	mov	r0, r8
   112fa:	f013 f833 	bl	24364 <k_work_reschedule>
   112fe:	e79a      	b.n	11236 <_mod_pub_set.constprop.0+0x46>
		return STATUS_FEAT_NOT_SUPP;
   11300:	250a      	movs	r5, #10
   11302:	e79b      	b.n	1123c <_mod_pub_set.constprop.0+0x4c>
		return STATUS_NVAL_PUB_PARAM;
   11304:	2507      	movs	r5, #7
   11306:	e799      	b.n	1123c <_mod_pub_set.constprop.0+0x4c>
   11308:	00031bbb 	.word	0x00031bbb
   1130c:	000328e3 	.word	0x000328e3
   11310:	0002dafc 	.word	0x0002dafc

00011314 <mod_unbind.constprop.0>:
static uint8_t mod_unbind(struct bt_mesh_model *model, uint16_t key_idx, bool store)
   11314:	b5f0      	push	{r4, r5, r6, r7, lr}
   11316:	b087      	sub	sp, #28
	BT_DBG("model %p key_idx 0x%03x store %u", model, key_idx, store);
   11318:	466e      	mov	r6, sp
static uint8_t mod_unbind(struct bt_mesh_model *model, uint16_t key_idx, bool store)
   1131a:	af04      	add	r7, sp, #16
	BT_DBG("model %p key_idx 0x%03x store %u", model, key_idx, store);
   1131c:	b08a      	sub	sp, #40	; 0x28
   1131e:	4b1d      	ldr	r3, [pc, #116]	; (11394 <mod_unbind.constprop.0+0x80>)
   11320:	9308      	str	r3, [sp, #32]
   11322:	4b1d      	ldr	r3, [pc, #116]	; (11398 <mod_unbind.constprop.0+0x84>)
   11324:	910b      	str	r1, [sp, #44]	; 0x2c
   11326:	aa04      	add	r2, sp, #16
   11328:	e9c2 3005 	strd	r3, r0, [r2, #20]
   1132c:	2301      	movs	r3, #1
   1132e:	6213      	str	r3, [r2, #32]
   11330:	2306      	movs	r3, #6
static uint8_t mod_unbind(struct bt_mesh_model *model, uint16_t key_idx, bool store)
   11332:	460c      	mov	r4, r1
	BT_DBG("model %p key_idx 0x%03x store %u", model, key_idx, store);
   11334:	f842 3f0c 	str.w	r3, [r2, #12]!
static uint8_t mod_unbind(struct bt_mesh_model *model, uint16_t key_idx, bool store)
   11338:	4605      	mov	r5, r0
	BT_DBG("model %p key_idx 0x%03x store %u", model, key_idx, store);
   1133a:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   1133e:	4817      	ldr	r0, [pc, #92]	; (1139c <mod_unbind.constprop.0+0x88>)
   11340:	607b      	str	r3, [r7, #4]
   11342:	f018 ff71 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	if (!bt_mesh_app_key_exists(key_idx)) {
   11346:	4620      	mov	r0, r4
   11348:	46b5      	mov	sp, r6
   1134a:	f7fc fe1f 	bl	df8c <bt_mesh_app_key_exists>
   1134e:	b998      	cbnz	r0, 11378 <mod_unbind.constprop.0+0x64>
		return STATUS_INVALID_APPKEY;
   11350:	2003      	movs	r0, #3
}
   11352:	370c      	adds	r7, #12
   11354:	46bd      	mov	sp, r7
   11356:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (model->pub && model->pub->key == key_idx) {
   11358:	88db      	ldrh	r3, [r3, #6]
   1135a:	f3c3 030b 	ubfx	r3, r3, #0, #12
   1135e:	429e      	cmp	r6, r3
   11360:	d116      	bne.n	11390 <mod_unbind.constprop.0+0x7c>
			_mod_pub_set(model, BT_MESH_ADDR_UNASSIGNED,
   11362:	2400      	movs	r4, #0
   11364:	e9cd 4401 	strd	r4, r4, [sp, #4]
   11368:	9400      	str	r4, [sp, #0]
   1136a:	4623      	mov	r3, r4
   1136c:	4622      	mov	r2, r4
   1136e:	4621      	mov	r1, r4
   11370:	4628      	mov	r0, r5
   11372:	f7ff ff3d 	bl	111f0 <_mod_pub_set.constprop.0>
   11376:	e00b      	b.n	11390 <mod_unbind.constprop.0+0x7c>
		if (model->keys[i] != key_idx) {
   11378:	89ae      	ldrh	r6, [r5, #12]
   1137a:	42a6      	cmp	r6, r4
   1137c:	d108      	bne.n	11390 <mod_unbind.constprop.0+0x7c>
		model->keys[i] = BT_MESH_KEY_UNUSED;
   1137e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11382:	81ab      	strh	r3, [r5, #12]
			bt_mesh_model_bind_store(model);
   11384:	4628      	mov	r0, r5
   11386:	f018 feb9 	bl	2a0fc <bt_mesh_model_bind_store>
		if (model->pub && model->pub->key == key_idx) {
   1138a:	68ab      	ldr	r3, [r5, #8]
   1138c:	2b00      	cmp	r3, #0
   1138e:	d1e3      	bne.n	11358 <mod_unbind.constprop.0+0x44>
	return STATUS_SUCCESS;
   11390:	2000      	movs	r0, #0
   11392:	e7de      	b.n	11352 <mod_unbind.constprop.0+0x3e>
   11394:	00031bcc 	.word	0x00031bcc
   11398:	000328f0 	.word	0x000328f0
   1139c:	0002dafc 	.word	0x0002dafc

000113a0 <app_key_get>:
#define IDX_LEN(num) (((num) / 2) * 3 + ((num) % 2) * 2)

static int app_key_get(struct bt_mesh_model *model,
		       struct bt_mesh_msg_ctx *ctx,
		       struct net_buf_simple *buf)
{
   113a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   113a4:	b091      	sub	sp, #68	; 0x44
   113a6:	af02      	add	r7, sp, #8
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_LIST,
   113a8:	f107 0308 	add.w	r3, r7, #8
{
   113ac:	4606      	mov	r6, r0
   113ae:	4688      	mov	r8, r1
	uint16_t get_idx;
	uint8_t status;
	ssize_t count;
	int i;

	get_idx = net_buf_simple_pull_le16(buf);
   113b0:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_LIST,
   113b2:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   113b6:	e9c7 1306 	strd	r1, r3, [r7, #24]
   113ba:	617b      	str	r3, [r7, #20]
	get_idx = net_buf_simple_pull_le16(buf);
   113bc:	f01a fd46 	bl	2be4c <net_buf_simple_pull_le16>
	if (get_idx > 0xfff) {
   113c0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	get_idx = net_buf_simple_pull_le16(buf);
   113c4:	4605      	mov	r5, r0
	if (get_idx > 0xfff) {
   113c6:	d312      	bcc.n	113ee <app_key_get+0x4e>
		BT_ERR("Invalid NetKeyIndex 0x%04x", get_idx);
   113c8:	4b3b      	ldr	r3, [pc, #236]	; (114b8 <app_key_get+0x118>)
   113ca:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   113ce:	e9c7 300c 	strd	r3, r0, [r7, #48]	; 0x30
   113d2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   113d6:	2303      	movs	r3, #3
   113d8:	4838      	ldr	r0, [pc, #224]	; (114bc <app_key_get+0x11c>)
   113da:	607b      	str	r3, [r7, #4]
   113dc:	62fb      	str	r3, [r7, #44]	; 0x2c
   113de:	f018 ff23 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   113e2:	f06f 0015 	mvn.w	r0, #21
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send AppKey List");
	}

	return 0;
}
   113e6:	373c      	adds	r7, #60	; 0x3c
   113e8:	46bd      	mov	sp, r7
   113ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	BT_DBG("idx 0x%04x", get_idx);
   113ee:	466c      	mov	r4, sp
   113f0:	b088      	sub	sp, #32
   113f2:	aa02      	add	r2, sp, #8
   113f4:	4b32      	ldr	r3, [pc, #200]	; (114c0 <app_key_get+0x120>)
   113f6:	6113      	str	r3, [r2, #16]
   113f8:	4b32      	ldr	r3, [pc, #200]	; (114c4 <app_key_get+0x124>)
   113fa:	e9c2 3005 	strd	r3, r0, [r2, #20]
   113fe:	2304      	movs	r3, #4
   11400:	f842 3f0c 	str.w	r3, [r2, #12]!
   11404:	482d      	ldr	r0, [pc, #180]	; (114bc <app_key_get+0x11c>)
   11406:	623b      	str	r3, [r7, #32]
   11408:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1140c:	f018 ff0c 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_LIST);
   11410:	f248 0102 	movw	r1, #32770	; 0x8002
   11414:	46a5      	mov	sp, r4
   11416:	f107 0014 	add.w	r0, r7, #20
   1141a:	f018 fe84 	bl	2a126 <bt_mesh_model_msg_init>
	if (!bt_mesh_subnet_exists(get_idx)) {
   1141e:	4628      	mov	r0, r5
   11420:	f018 f8fa 	bl	29618 <bt_mesh_subnet_exists>
		status = STATUS_SUCCESS;
   11424:	2800      	cmp	r0, #0
   11426:	bf0c      	ite	eq
   11428:	2404      	moveq	r4, #4
   1142a:	2400      	movne	r4, #0
	net_buf_simple_add_u8(&msg, status);
   1142c:	4621      	mov	r1, r4
   1142e:	f107 0014 	add.w	r0, r7, #20
   11432:	f01a fc92 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, get_idx);
   11436:	4629      	mov	r1, r5
   11438:	f107 0014 	add.w	r0, r7, #20
   1143c:	f01a fc95 	bl	2bd6a <net_buf_simple_add_le16>
	if (status != STATUS_SUCCESS) {
   11440:	b9cc      	cbnz	r4, 11476 <app_key_get+0xd6>
	count = bt_mesh_app_keys_get(get_idx, app_idx, ARRAY_SIZE(app_idx), 0);
   11442:	4628      	mov	r0, r5
   11444:	4623      	mov	r3, r4
   11446:	2202      	movs	r2, #2
   11448:	4639      	mov	r1, r7
   1144a:	f7fc fdad 	bl	dfa8 <bt_mesh_app_keys_get>
		count = ARRAY_SIZE(app_idx);
   1144e:	2803      	cmp	r0, #3
	count = bt_mesh_app_keys_get(get_idx, app_idx, ARRAY_SIZE(app_idx), 0);
   11450:	4605      	mov	r5, r0
		count = ARRAY_SIZE(app_idx);
   11452:	bf28      	it	cs
   11454:	2502      	movcs	r5, #2
	for (i = 0; i < count - 1; i += 2) {
   11456:	f105 39ff 	add.w	r9, r5, #4294967295	; 0xffffffff
   1145a:	45a1      	cmp	r9, r4
   1145c:	dc24      	bgt.n	114a8 <app_key_get+0x108>
	if (i < count) {
   1145e:	42a5      	cmp	r5, r4
   11460:	dd09      	ble.n	11476 <app_key_get+0xd6>
		net_buf_simple_add_le16(&msg, app_idx[i]);
   11462:	f107 0338 	add.w	r3, r7, #56	; 0x38
   11466:	eb03 0444 	add.w	r4, r3, r4, lsl #1
   1146a:	f107 0014 	add.w	r0, r7, #20
   1146e:	f834 1c38 	ldrh.w	r1, [r4, #-56]
   11472:	f01a fc7a 	bl	2bd6a <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11476:	2400      	movs	r4, #0
   11478:	9400      	str	r4, [sp, #0]
   1147a:	4623      	mov	r3, r4
   1147c:	f107 0214 	add.w	r2, r7, #20
   11480:	4641      	mov	r1, r8
   11482:	4630      	mov	r0, r6
   11484:	f7ff fd76 	bl	10f74 <bt_mesh_model_send>
   11488:	2800      	cmp	r0, #0
   1148a:	d0ac      	beq.n	113e6 <app_key_get+0x46>
		BT_ERR("Unable to send AppKey List");
   1148c:	4b0e      	ldr	r3, [pc, #56]	; (114c8 <app_key_get+0x128>)
   1148e:	480b      	ldr	r0, [pc, #44]	; (114bc <app_key_get+0x11c>)
   11490:	633b      	str	r3, [r7, #48]	; 0x30
   11492:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   11496:	2302      	movs	r3, #2
   11498:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1149c:	607b      	str	r3, [r7, #4]
   1149e:	62fb      	str	r3, [r7, #44]	; 0x2c
   114a0:	f018 fec2 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   114a4:	4620      	mov	r0, r4
   114a6:	e79e      	b.n	113e6 <app_key_get+0x46>
		key_idx_pack(&msg, app_idx[i], app_idx[i + 1]);
   114a8:	887a      	ldrh	r2, [r7, #2]
   114aa:	8839      	ldrh	r1, [r7, #0]
   114ac:	f107 0014 	add.w	r0, r7, #20
   114b0:	f018 fe62 	bl	2a178 <key_idx_pack>
	for (i = 0; i < count - 1; i += 2) {
   114b4:	2402      	movs	r4, #2
   114b6:	e7d0      	b.n	1145a <app_key_get+0xba>
   114b8:	00031bf1 	.word	0x00031bf1
   114bc:	0002dafc 	.word	0x0002dafc
   114c0:	00031c0c 	.word	0x00031c0c
   114c4:	00032830 	.word	0x00032830
   114c8:	00031c1b 	.word	0x00031c1b

000114cc <send_gatt_proxy_status>:
	return 0;
}

static int send_gatt_proxy_status(struct bt_mesh_model *model,
				  struct bt_mesh_msg_ctx *ctx)
{
   114cc:	b530      	push	{r4, r5, lr}
   114ce:	b08f      	sub	sp, #60	; 0x3c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_GATT_PROXY_STATUS, 1);
   114d0:	ab03      	add	r3, sp, #12
   114d2:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   114d6:	4604      	mov	r4, r0
   114d8:	460d      	mov	r5, r1

	bt_mesh_model_msg_init(&msg, OP_GATT_PROXY_STATUS);
   114da:	a805      	add	r0, sp, #20
   114dc:	f248 0114 	movw	r1, #32788	; 0x8014
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_GATT_PROXY_STATUS, 1);
   114e0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   114e4:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_GATT_PROXY_STATUS);
   114e6:	f018 fe1e 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_gatt_proxy_get());
   114ea:	f7fa fbbd 	bl	bc68 <bt_mesh_gatt_proxy_get>
   114ee:	4601      	mov	r1, r0
   114f0:	a805      	add	r0, sp, #20
   114f2:	f01a fc32 	bl	2bd5a <net_buf_simple_add_u8>

	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   114f6:	2300      	movs	r3, #0
   114f8:	9300      	str	r3, [sp, #0]
   114fa:	aa05      	add	r2, sp, #20
   114fc:	4629      	mov	r1, r5
   114fe:	4620      	mov	r0, r4
   11500:	f7ff fd38 	bl	10f74 <bt_mesh_model_send>
   11504:	b150      	cbz	r0, 1151c <send_gatt_proxy_status+0x50>
		BT_ERR("Unable to send GATT Proxy Status");
   11506:	4b07      	ldr	r3, [pc, #28]	; (11524 <send_gatt_proxy_status+0x58>)
   11508:	930c      	str	r3, [sp, #48]	; 0x30
   1150a:	4807      	ldr	r0, [pc, #28]	; (11528 <send_gatt_proxy_status+0x5c>)
   1150c:	2302      	movs	r3, #2
   1150e:	aa0b      	add	r2, sp, #44	; 0x2c
   11510:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11514:	9302      	str	r3, [sp, #8]
   11516:	930b      	str	r3, [sp, #44]	; 0x2c
   11518:	f018 fe86 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	}

	return 0;
}
   1151c:	2000      	movs	r0, #0
   1151e:	b00f      	add	sp, #60	; 0x3c
   11520:	bd30      	pop	{r4, r5, pc}
   11522:	bf00      	nop
   11524:	00031c36 	.word	0x00031c36
   11528:	0002dafc 	.word	0x0002dafc

0001152c <send_mod_pub_status>:
static int send_mod_pub_status(struct bt_mesh_model *cfg_mod,
			       struct bt_mesh_msg_ctx *ctx, uint16_t elem_addr,
			       uint16_t pub_addr, bool vnd,
			       struct bt_mesh_model *mod, uint8_t status,
			       uint8_t *mod_id)
{
   1152c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11530:	b093      	sub	sp, #76	; 0x4c
   11532:	4692      	mov	sl, r2
   11534:	f89d b078 	ldrb.w	fp, [sp, #120]	; 0x78
   11538:	f89d 8070 	ldrb.w	r8, [sp, #112]	; 0x70
   1153c:	9c1d      	ldr	r4, [sp, #116]	; 0x74
   1153e:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_PUB_STATUS, 14);
   11540:	f44f 12a0 	mov.w	r2, #1310720	; 0x140000
{
   11544:	4605      	mov	r5, r0
   11546:	460e      	mov	r6, r1

	bt_mesh_model_msg_init(&msg, OP_MOD_PUB_STATUS);
   11548:	a804      	add	r0, sp, #16
   1154a:	f248 0119 	movw	r1, #32793	; 0x8019
{
   1154e:	4699      	mov	r9, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_PUB_STATUS, 14);
   11550:	ab07      	add	r3, sp, #28
   11552:	e9cd 2305 	strd	r2, r3, [sp, #20]
   11556:	9304      	str	r3, [sp, #16]
	bt_mesh_model_msg_init(&msg, OP_MOD_PUB_STATUS);
   11558:	f018 fde5 	bl	2a126 <bt_mesh_model_msg_init>

	net_buf_simple_add_u8(&msg, status);
   1155c:	4659      	mov	r1, fp
   1155e:	a804      	add	r0, sp, #16
   11560:	f01a fbfb 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   11564:	4651      	mov	r1, sl
   11566:	a804      	add	r0, sp, #16
   11568:	f01a fbff 	bl	2bd6a <net_buf_simple_add_le16>

	if (status != STATUS_SUCCESS) {
   1156c:	f1bb 0f00 	cmp.w	fp, #0
   11570:	d029      	beq.n	115c6 <send_mod_pub_status+0x9a>
		(void)memset(net_buf_simple_add(&msg, 7), 0, 7);
   11572:	2107      	movs	r1, #7
   11574:	a804      	add	r0, sp, #16
   11576:	f01a fbe1 	bl	2bd3c <net_buf_simple_add>
   1157a:	2207      	movs	r2, #7
   1157c:	2100      	movs	r1, #0
   1157e:	f016 f982 	bl	27886 <memset>
		net_buf_simple_add_u8(&msg, mod->pub->ttl);
		net_buf_simple_add_u8(&msg, mod->pub->period);
		net_buf_simple_add_u8(&msg, mod->pub->retransmit);
	}

	if (vnd) {
   11582:	f1b8 0f00 	cmp.w	r8, #0
   11586:	d040      	beq.n	1160a <send_mod_pub_status+0xde>
		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
   11588:	2104      	movs	r1, #4
   1158a:	a804      	add	r0, sp, #16
   1158c:	f01a fbd6 	bl	2bd3c <net_buf_simple_add>
   11590:	2204      	movs	r2, #4
	} else {
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   11592:	4639      	mov	r1, r7
   11594:	f016 f96c 	bl	27870 <memcpy>
	}

	if (bt_mesh_model_send(cfg_mod, ctx, &msg, NULL, NULL)) {
   11598:	2300      	movs	r3, #0
   1159a:	9300      	str	r3, [sp, #0]
   1159c:	aa04      	add	r2, sp, #16
   1159e:	4631      	mov	r1, r6
   115a0:	4628      	mov	r0, r5
   115a2:	f7ff fce7 	bl	10f74 <bt_mesh_model_send>
   115a6:	b150      	cbz	r0, 115be <send_mod_pub_status+0x92>
		BT_ERR("Unable to send Model Publication Status");
   115a8:	4b1b      	ldr	r3, [pc, #108]	; (11618 <send_mod_pub_status+0xec>)
   115aa:	9310      	str	r3, [sp, #64]	; 0x40
   115ac:	481b      	ldr	r0, [pc, #108]	; (1161c <send_mod_pub_status+0xf0>)
   115ae:	2302      	movs	r3, #2
   115b0:	aa0f      	add	r2, sp, #60	; 0x3c
   115b2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   115b6:	9303      	str	r3, [sp, #12]
   115b8:	930f      	str	r3, [sp, #60]	; 0x3c
   115ba:	f018 fe35 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	}

	return 0;
}
   115be:	2000      	movs	r0, #0
   115c0:	b013      	add	sp, #76	; 0x4c
   115c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		net_buf_simple_add_le16(&msg, pub_addr);
   115c6:	4649      	mov	r1, r9
   115c8:	a804      	add	r0, sp, #16
   115ca:	f01a fbce 	bl	2bd6a <net_buf_simple_add_le16>
		idx_cred = mod->pub->key | (uint16_t)mod->pub->cred << 12;
   115ce:	68a3      	ldr	r3, [r4, #8]
   115d0:	79d9      	ldrb	r1, [r3, #7]
   115d2:	88db      	ldrh	r3, [r3, #6]
   115d4:	f3c1 1100 	ubfx	r1, r1, #4, #1
   115d8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   115dc:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
		net_buf_simple_add_le16(&msg, idx_cred);
   115e0:	a804      	add	r0, sp, #16
   115e2:	f3c1 010c 	ubfx	r1, r1, #0, #13
   115e6:	f01a fbc0 	bl	2bd6a <net_buf_simple_add_le16>
		net_buf_simple_add_u8(&msg, mod->pub->ttl);
   115ea:	68a3      	ldr	r3, [r4, #8]
   115ec:	a804      	add	r0, sp, #16
   115ee:	7a19      	ldrb	r1, [r3, #8]
   115f0:	f01a fbb3 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_u8(&msg, mod->pub->period);
   115f4:	68a3      	ldr	r3, [r4, #8]
   115f6:	a804      	add	r0, sp, #16
   115f8:	7a99      	ldrb	r1, [r3, #10]
   115fa:	f01a fbae 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_u8(&msg, mod->pub->retransmit);
   115fe:	68a3      	ldr	r3, [r4, #8]
   11600:	a804      	add	r0, sp, #16
   11602:	7a59      	ldrb	r1, [r3, #9]
   11604:	f01a fba9 	bl	2bd5a <net_buf_simple_add_u8>
   11608:	e7bb      	b.n	11582 <send_mod_pub_status+0x56>
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   1160a:	2102      	movs	r1, #2
   1160c:	a804      	add	r0, sp, #16
   1160e:	f01a fb95 	bl	2bd3c <net_buf_simple_add>
   11612:	2202      	movs	r2, #2
   11614:	e7bd      	b.n	11592 <send_mod_pub_status+0x66>
   11616:	bf00      	nop
   11618:	00031c57 	.word	0x00031c57
   1161c:	0002dafc 	.word	0x0002dafc

00011620 <mod_sub_list_clear>:
	return send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
				   status, mod_id);
}

static size_t mod_sub_list_clear(struct bt_mesh_model *mod)
{
   11620:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t *label_uuid;
	size_t clear_count;
	int i;

	/* Unref stored labels related to this model */
	for (i = 0, clear_count = 0; i < ARRAY_SIZE(mod->groups); i++) {
   11624:	2400      	movs	r4, #0
		clear_count++;

		if (label_uuid) {
			bt_mesh_va_del(label_uuid, NULL);
		} else {
			BT_ERR("Label UUID not found");
   11626:	f8df 8060 	ldr.w	r8, [pc, #96]	; 11688 <mod_sub_list_clear+0x68>
   1162a:	f8df 9060 	ldr.w	r9, [pc, #96]	; 1168c <mod_sub_list_clear+0x6c>
{
   1162e:	b089      	sub	sp, #36	; 0x24
   11630:	f100 060e 	add.w	r6, r0, #14
   11634:	f100 0512 	add.w	r5, r0, #18
		mod->groups[i] = BT_MESH_ADDR_UNASSIGNED;
   11638:	4627      	mov	r7, r4
		if (!BT_MESH_ADDR_IS_VIRTUAL(mod->groups[i])) {
   1163a:	f836 0b02 	ldrh.w	r0, [r6], #2
   1163e:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
   11642:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   11646:	d309      	bcc.n	1165c <mod_sub_list_clear+0x3c>
			if (mod->groups[i] != BT_MESH_ADDR_UNASSIGNED) {
   11648:	b110      	cbz	r0, 11650 <mod_sub_list_clear+0x30>
				mod->groups[i] = BT_MESH_ADDR_UNASSIGNED;
   1164a:	f826 7c02 	strh.w	r7, [r6, #-2]
				clear_count++;
   1164e:	3401      	adds	r4, #1
	for (i = 0, clear_count = 0; i < ARRAY_SIZE(mod->groups); i++) {
   11650:	42ae      	cmp	r6, r5
   11652:	d1f2      	bne.n	1163a <mod_sub_list_clear+0x1a>
		}
	}

	return clear_count;
}
   11654:	4620      	mov	r0, r4
   11656:	b009      	add	sp, #36	; 0x24
   11658:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		label_uuid = bt_mesh_va_label_get(mod->groups[i]);
   1165c:	f7fd fc46 	bl	eeec <bt_mesh_va_label_get>
		clear_count++;
   11660:	3401      	adds	r4, #1
		mod->groups[i] = BT_MESH_ADDR_UNASSIGNED;
   11662:	f826 7c02 	strh.w	r7, [r6, #-2]
		if (label_uuid) {
   11666:	b118      	cbz	r0, 11670 <mod_sub_list_clear+0x50>
			bt_mesh_va_del(label_uuid, NULL);
   11668:	2100      	movs	r1, #0
   1166a:	f7fd fc03 	bl	ee74 <bt_mesh_va_del>
   1166e:	e7ef      	b.n	11650 <mod_sub_list_clear+0x30>
			BT_ERR("Label UUID not found");
   11670:	2302      	movs	r3, #2
   11672:	aa05      	add	r2, sp, #20
   11674:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11678:	4648      	mov	r0, r9
   1167a:	f8cd 8018 	str.w	r8, [sp, #24]
   1167e:	9301      	str	r3, [sp, #4]
   11680:	9305      	str	r3, [sp, #20]
   11682:	f018 fdd1 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   11686:	e7e3      	b.n	11650 <mod_sub_list_clear+0x30>
   11688:	00031c7f 	.word	0x00031c7f
   1168c:	0002dafc 	.word	0x0002dafc

00011690 <mod_sub_list_visitor>:
	uint16_t elem_idx;
	struct net_buf_simple *msg;
};

static enum bt_mesh_walk mod_sub_list_visitor(struct bt_mesh_model *mod, void *ctx)
{
   11690:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11694:	b089      	sub	sp, #36	; 0x24
	struct mod_sub_list_ctx *visit = ctx;
	int count = 0;
	int i;

	if (mod->elem_idx != visit->elem_idx) {
   11696:	7902      	ldrb	r2, [r0, #4]
   11698:	880b      	ldrh	r3, [r1, #0]
   1169a:	429a      	cmp	r2, r3
{
   1169c:	af00      	add	r7, sp, #0
   1169e:	4604      	mov	r4, r0
   116a0:	460d      	mov	r5, r1
	if (mod->elem_idx != visit->elem_idx) {
   116a2:	d13d      	bne.n	11720 <mod_sub_list_visitor+0x90>
   116a4:	f100 060e 	add.w	r6, r0, #14
   116a8:	f100 0912 	add.w	r9, r0, #18
	int count = 0;
   116ac:	f04f 0800 	mov.w	r8, #0
		return BT_MESH_WALK_CONTINUE;
	}

	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
		if (mod->groups[i] == BT_MESH_ADDR_UNASSIGNED) {
   116b0:	f836 3b02 	ldrh.w	r3, [r6], #2
   116b4:	b1e3      	cbz	r3, 116f0 <mod_sub_list_visitor+0x60>
			continue;
		}

		if (net_buf_simple_tailroom(visit->msg) <
   116b6:	6868      	ldr	r0, [r5, #4]
   116b8:	f01a fbe7 	bl	2be8a <net_buf_simple_tailroom>
   116bc:	2805      	cmp	r0, #5
   116be:	d810      	bhi.n	116e2 <mod_sub_list_visitor+0x52>
		    2 + BT_MESH_MIC_SHORT) {
			BT_WARN("No room for all groups");
   116c0:	4b18      	ldr	r3, [pc, #96]	; (11724 <mod_sub_list_visitor+0x94>)
   116c2:	4819      	ldr	r0, [pc, #100]	; (11728 <mod_sub_list_visitor+0x98>)
   116c4:	61bb      	str	r3, [r7, #24]
   116c6:	f107 0214 	add.w	r2, r7, #20
   116ca:	2302      	movs	r3, #2
   116cc:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   116d0:	607b      	str	r3, [r7, #4]
   116d2:	617b      	str	r3, [r7, #20]
   116d4:	f018 fda8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
			return BT_MESH_WALK_STOP;
   116d8:	2000      	movs	r0, #0

	BT_DBG("sublist: model %u:%x: %u groups", mod->elem_idx, mod->id,
	       count);

	return BT_MESH_WALK_CONTINUE;
}
   116da:	3724      	adds	r7, #36	; 0x24
   116dc:	46bd      	mov	sp, r7
   116de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		net_buf_simple_add_le16(visit->msg, mod->groups[i]);
   116e2:	f836 1c02 	ldrh.w	r1, [r6, #-2]
   116e6:	6868      	ldr	r0, [r5, #4]
   116e8:	f01a fb3f 	bl	2bd6a <net_buf_simple_add_le16>
		count++;
   116ec:	f108 0801 	add.w	r8, r8, #1
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
   116f0:	454e      	cmp	r6, r9
   116f2:	d1dd      	bne.n	116b0 <mod_sub_list_visitor+0x20>
	BT_DBG("sublist: model %u:%x: %u groups", mod->elem_idx, mod->id,
   116f4:	7921      	ldrb	r1, [r4, #4]
   116f6:	8823      	ldrh	r3, [r4, #0]
   116f8:	480c      	ldr	r0, [pc, #48]	; (1172c <mod_sub_list_visitor+0x9c>)
   116fa:	466c      	mov	r4, sp
   116fc:	b08a      	sub	sp, #40	; 0x28
   116fe:	466a      	mov	r2, sp
   11700:	e9c2 3807 	strd	r3, r8, [r2, #28]
   11704:	6110      	str	r0, [r2, #16]
   11706:	480a      	ldr	r0, [pc, #40]	; (11730 <mod_sub_list_visitor+0xa0>)
   11708:	2306      	movs	r3, #6
   1170a:	e9c2 0105 	strd	r0, r1, [r2, #20]
   1170e:	f842 3f0c 	str.w	r3, [r2, #12]!
   11712:	4805      	ldr	r0, [pc, #20]	; (11728 <mod_sub_list_visitor+0x98>)
   11714:	60bb      	str	r3, [r7, #8]
   11716:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   1171a:	f018 fd85 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   1171e:	46a5      	mov	sp, r4
		return BT_MESH_WALK_CONTINUE;
   11720:	2001      	movs	r0, #1
   11722:	e7da      	b.n	116da <mod_sub_list_visitor+0x4a>
   11724:	00031c94 	.word	0x00031c94
   11728:	0002dafc 	.word	0x0002dafc
   1172c:	00031cab 	.word	0x00031cab
   11730:	0003277d 	.word	0x0003277d

00011734 <mod_sub_get>:

static int mod_sub_get(struct bt_mesh_model *model,
		       struct bt_mesh_msg_ctx *ctx,
		       struct net_buf_simple *buf)
{
   11734:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11738:	b098      	sub	sp, #96	; 0x60
   1173a:	4614      	mov	r4, r2
   1173c:	af02      	add	r7, sp, #8
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   1173e:	f107 0334 	add.w	r3, r7, #52	; 0x34
   11742:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
{
   11746:	4680      	mov	r8, r0
	struct mod_sub_list_ctx visit_ctx;
	struct bt_mesh_model *mod;
	struct bt_mesh_elem *elem;
	uint16_t addr, id;

	addr = net_buf_simple_pull_le16(buf);
   11748:	4620      	mov	r0, r4
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   1174a:	e9c7 2304 	strd	r2, r3, [r7, #16]
   1174e:	60fb      	str	r3, [r7, #12]
{
   11750:	4689      	mov	r9, r1
	addr = net_buf_simple_pull_le16(buf);
   11752:	f01a fb7b 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   11756:	b203      	sxth	r3, r0
   11758:	2b00      	cmp	r3, #0
	addr = net_buf_simple_pull_le16(buf);
   1175a:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   1175c:	dc11      	bgt.n	11782 <mod_sub_get+0x4e>
		BT_WARN("Prohibited element address");
   1175e:	4b3a      	ldr	r3, [pc, #232]	; (11848 <mod_sub_get+0x114>)
   11760:	483a      	ldr	r0, [pc, #232]	; (1184c <mod_sub_get+0x118>)
   11762:	62bb      	str	r3, [r7, #40]	; 0x28
   11764:	f107 0224 	add.w	r2, r7, #36	; 0x24
   11768:	2302      	movs	r3, #2
   1176a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1176e:	607b      	str	r3, [r7, #4]
   11770:	627b      	str	r3, [r7, #36]	; 0x24
   11772:	f018 fd59 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   11776:	f06f 0015 	mvn.w	r0, #21
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send Model Subscription List");
	}

	return 0;
}
   1177a:	3758      	adds	r7, #88	; 0x58
   1177c:	46bd      	mov	sp, r7
   1177e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	id = net_buf_simple_pull_le16(buf);
   11782:	4620      	mov	r0, r4
   11784:	f01a fb62 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("addr 0x%04x id 0x%04x", addr, id);
   11788:	466c      	mov	r4, sp
   1178a:	b088      	sub	sp, #32
   1178c:	4b30      	ldr	r3, [pc, #192]	; (11850 <mod_sub_get+0x11c>)
   1178e:	9306      	str	r3, [sp, #24]
   11790:	4b30      	ldr	r3, [pc, #192]	; (11854 <mod_sub_get+0x120>)
   11792:	9009      	str	r0, [sp, #36]	; 0x24
   11794:	aa02      	add	r2, sp, #8
   11796:	e9c2 3505 	strd	r3, r5, [r2, #20]
   1179a:	2305      	movs	r3, #5
   1179c:	f842 3f0c 	str.w	r3, [r2, #12]!
   117a0:	f44f 5124 	mov.w	r1, #10496	; 0x2900
	id = net_buf_simple_pull_le16(buf);
   117a4:	4606      	mov	r6, r0
	BT_DBG("addr 0x%04x id 0x%04x", addr, id);
   117a6:	4829      	ldr	r0, [pc, #164]	; (1184c <mod_sub_get+0x118>)
   117a8:	61bb      	str	r3, [r7, #24]
   117aa:	f018 fd3d 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   117ae:	46a5      	mov	sp, r4
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST);
   117b0:	f107 040c 	add.w	r4, r7, #12
   117b4:	4620      	mov	r0, r4
   117b6:	f248 012a 	movw	r1, #32810	; 0x802a
   117ba:	f018 fcb4 	bl	2a126 <bt_mesh_model_msg_init>
	elem = bt_mesh_elem_find(addr);
   117be:	4628      	mov	r0, r5
   117c0:	f7ff fb56 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   117c4:	bb18      	cbnz	r0, 1180e <mod_sub_get+0xda>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_ADDRESS);
   117c6:	2101      	movs	r1, #1
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   117c8:	4620      	mov	r0, r4
   117ca:	f01a fac6 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, addr);
   117ce:	4629      	mov	r1, r5
   117d0:	4620      	mov	r0, r4
   117d2:	f01a faca 	bl	2bd6a <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, id);
   117d6:	4631      	mov	r1, r6
   117d8:	4620      	mov	r0, r4
   117da:	f01a fac6 	bl	2bd6a <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   117de:	2500      	movs	r5, #0
   117e0:	9500      	str	r5, [sp, #0]
   117e2:	462b      	mov	r3, r5
   117e4:	4622      	mov	r2, r4
   117e6:	4649      	mov	r1, r9
   117e8:	4640      	mov	r0, r8
   117ea:	f7ff fbc3 	bl	10f74 <bt_mesh_model_send>
   117ee:	2800      	cmp	r0, #0
   117f0:	d0c3      	beq.n	1177a <mod_sub_get+0x46>
		BT_ERR("Unable to send Model Subscription List");
   117f2:	4b19      	ldr	r3, [pc, #100]	; (11858 <mod_sub_get+0x124>)
   117f4:	4815      	ldr	r0, [pc, #84]	; (1184c <mod_sub_get+0x118>)
   117f6:	62bb      	str	r3, [r7, #40]	; 0x28
   117f8:	f107 0224 	add.w	r2, r7, #36	; 0x24
   117fc:	2302      	movs	r3, #2
   117fe:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11802:	603b      	str	r3, [r7, #0]
   11804:	627b      	str	r3, [r7, #36]	; 0x24
   11806:	f018 fd0f 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   1180a:	4628      	mov	r0, r5
   1180c:	e7b5      	b.n	1177a <mod_sub_get+0x46>
	mod = bt_mesh_model_find(elem, id);
   1180e:	4631      	mov	r1, r6
   11810:	f018 fc4d 	bl	2a0ae <bt_mesh_model_find>
	if (!mod) {
   11814:	4682      	mov	sl, r0
   11816:	b908      	cbnz	r0, 1181c <mod_sub_get+0xe8>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   11818:	2102      	movs	r1, #2
   1181a:	e7d5      	b.n	117c8 <mod_sub_get+0x94>
	net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1181c:	2100      	movs	r1, #0
   1181e:	4620      	mov	r0, r4
   11820:	f01a fa9b 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, addr);
   11824:	4629      	mov	r1, r5
   11826:	4620      	mov	r0, r4
   11828:	f01a fa9f 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, id);
   1182c:	4631      	mov	r1, r6
   1182e:	4620      	mov	r0, r4
   11830:	f01a fa9b 	bl	2bd6a <net_buf_simple_add_le16>
	visit_ctx.msg = &msg;
   11834:	60bc      	str	r4, [r7, #8]
	visit_ctx.elem_idx = mod->elem_idx;
   11836:	f89a 3004 	ldrb.w	r3, [sl, #4]
	bt_mesh_model_extensions_walk(mod, mod_sub_list_visitor, &visit_ctx);
   1183a:	4908      	ldr	r1, [pc, #32]	; (1185c <mod_sub_get+0x128>)
	visit_ctx.elem_idx = mod->elem_idx;
   1183c:	80bb      	strh	r3, [r7, #4]
	bt_mesh_model_extensions_walk(mod, mod_sub_list_visitor, &visit_ctx);
   1183e:	1d3a      	adds	r2, r7, #4
   11840:	4650      	mov	r0, sl
   11842:	f018 fc48 	bl	2a0d6 <bt_mesh_model_extensions_walk>
   11846:	e7ca      	b.n	117de <mod_sub_get+0xaa>
   11848:	00031ccf 	.word	0x00031ccf
   1184c:	0002dafc 	.word	0x0002dafc
   11850:	00031cea 	.word	0x00031cea
   11854:	00032771 	.word	0x00032771
   11858:	00031d04 	.word	0x00031d04
   1185c:	00011691 	.word	0x00011691

00011860 <mod_sub_get_vnd>:

static int mod_sub_get_vnd(struct bt_mesh_model *model,
			   struct bt_mesh_msg_ctx *ctx,
			   struct net_buf_simple *buf)
{
   11860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11864:	b099      	sub	sp, #100	; 0x64
   11866:	4614      	mov	r4, r2
   11868:	af02      	add	r7, sp, #8
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   1186a:	f107 0334 	add.w	r3, r7, #52	; 0x34
   1186e:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
{
   11872:	4681      	mov	r9, r0
	struct mod_sub_list_ctx visit_ctx;
	struct bt_mesh_model *mod;
	struct bt_mesh_elem *elem;
	uint16_t company, addr, id;

	addr = net_buf_simple_pull_le16(buf);
   11874:	4620      	mov	r0, r4
	NET_BUF_SIMPLE_DEFINE(msg, BT_MESH_TX_SDU_MAX);
   11876:	e9c7 2304 	strd	r2, r3, [r7, #16]
   1187a:	60fb      	str	r3, [r7, #12]
{
   1187c:	468a      	mov	sl, r1
	addr = net_buf_simple_pull_le16(buf);
   1187e:	f01a fae5 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   11882:	b203      	sxth	r3, r0
   11884:	2b00      	cmp	r3, #0
	addr = net_buf_simple_pull_le16(buf);
   11886:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(addr)) {
   11888:	dc11      	bgt.n	118ae <mod_sub_get_vnd+0x4e>
		BT_WARN("Prohibited element address");
   1188a:	4b41      	ldr	r3, [pc, #260]	; (11990 <mod_sub_get_vnd+0x130>)
   1188c:	4841      	ldr	r0, [pc, #260]	; (11994 <mod_sub_get_vnd+0x134>)
   1188e:	62bb      	str	r3, [r7, #40]	; 0x28
   11890:	f107 0224 	add.w	r2, r7, #36	; 0x24
   11894:	2302      	movs	r3, #2
   11896:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1189a:	607b      	str	r3, [r7, #4]
   1189c:	627b      	str	r3, [r7, #36]	; 0x24
   1189e:	f018 fcc3 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   118a2:	f06f 0015 	mvn.w	r0, #21
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send Vendor Model Subscription List");
	}

	return 0;
}
   118a6:	375c      	adds	r7, #92	; 0x5c
   118a8:	46bd      	mov	sp, r7
   118aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	company = net_buf_simple_pull_le16(buf);
   118ae:	4620      	mov	r0, r4
   118b0:	f01a facc 	bl	2be4c <net_buf_simple_pull_le16>
   118b4:	4680      	mov	r8, r0
	id = net_buf_simple_pull_le16(buf);
   118b6:	4620      	mov	r0, r4
   118b8:	f01a fac8 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("addr 0x%04x company 0x%04x id 0x%04x", addr, company, id);
   118bc:	466c      	mov	r4, sp
   118be:	b08a      	sub	sp, #40	; 0x28
   118c0:	aa02      	add	r2, sp, #8
   118c2:	4b35      	ldr	r3, [pc, #212]	; (11998 <mod_sub_get_vnd+0x138>)
   118c4:	6113      	str	r3, [r2, #16]
   118c6:	4b35      	ldr	r3, [pc, #212]	; (1199c <mod_sub_get_vnd+0x13c>)
   118c8:	e9c2 3505 	strd	r3, r5, [r2, #20]
   118cc:	2306      	movs	r3, #6
   118ce:	e9c2 8007 	strd	r8, r0, [r2, #28]
   118d2:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   118d6:	f842 3f0c 	str.w	r3, [r2, #12]!
	id = net_buf_simple_pull_le16(buf);
   118da:	4606      	mov	r6, r0
	BT_DBG("addr 0x%04x company 0x%04x id 0x%04x", addr, company, id);
   118dc:	482d      	ldr	r0, [pc, #180]	; (11994 <mod_sub_get_vnd+0x134>)
   118de:	61bb      	str	r3, [r7, #24]
   118e0:	f018 fca2 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   118e4:	46a5      	mov	sp, r4
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_LIST_VND);
   118e6:	f107 040c 	add.w	r4, r7, #12
   118ea:	4620      	mov	r0, r4
   118ec:	f248 012c 	movw	r1, #32812	; 0x802c
   118f0:	f018 fc19 	bl	2a126 <bt_mesh_model_msg_init>
	elem = bt_mesh_elem_find(addr);
   118f4:	4628      	mov	r0, r5
   118f6:	f7ff fabb 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   118fa:	bb38      	cbnz	r0, 1194c <mod_sub_get_vnd+0xec>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_ADDRESS);
   118fc:	2101      	movs	r1, #1
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   118fe:	4620      	mov	r0, r4
   11900:	f01a fa2b 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_le16(&msg, addr);
   11904:	4629      	mov	r1, r5
   11906:	4620      	mov	r0, r4
   11908:	f01a fa2f 	bl	2bd6a <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, company);
   1190c:	4641      	mov	r1, r8
   1190e:	4620      	mov	r0, r4
   11910:	f01a fa2b 	bl	2bd6a <net_buf_simple_add_le16>
		net_buf_simple_add_le16(&msg, id);
   11914:	4631      	mov	r1, r6
   11916:	4620      	mov	r0, r4
   11918:	f01a fa27 	bl	2bd6a <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1191c:	2500      	movs	r5, #0
   1191e:	9500      	str	r5, [sp, #0]
   11920:	462b      	mov	r3, r5
   11922:	4622      	mov	r2, r4
   11924:	4651      	mov	r1, sl
   11926:	4648      	mov	r0, r9
   11928:	f7ff fb24 	bl	10f74 <bt_mesh_model_send>
   1192c:	2800      	cmp	r0, #0
   1192e:	d0ba      	beq.n	118a6 <mod_sub_get_vnd+0x46>
		BT_ERR("Unable to send Vendor Model Subscription List");
   11930:	4b1b      	ldr	r3, [pc, #108]	; (119a0 <mod_sub_get_vnd+0x140>)
   11932:	4818      	ldr	r0, [pc, #96]	; (11994 <mod_sub_get_vnd+0x134>)
   11934:	62bb      	str	r3, [r7, #40]	; 0x28
   11936:	f107 0224 	add.w	r2, r7, #36	; 0x24
   1193a:	2302      	movs	r3, #2
   1193c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11940:	603b      	str	r3, [r7, #0]
   11942:	627b      	str	r3, [r7, #36]	; 0x24
   11944:	f018 fc70 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   11948:	4628      	mov	r0, r5
   1194a:	e7ac      	b.n	118a6 <mod_sub_get_vnd+0x46>
	mod = bt_mesh_model_find_vnd(elem, company, id);
   1194c:	4632      	mov	r2, r6
   1194e:	4641      	mov	r1, r8
   11950:	f018 fb96 	bl	2a080 <bt_mesh_model_find_vnd>
	if (!mod) {
   11954:	4683      	mov	fp, r0
   11956:	b908      	cbnz	r0, 1195c <mod_sub_get_vnd+0xfc>
		net_buf_simple_add_u8(&msg, STATUS_INVALID_MODEL);
   11958:	2102      	movs	r1, #2
   1195a:	e7d0      	b.n	118fe <mod_sub_get_vnd+0x9e>
	net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   1195c:	2100      	movs	r1, #0
   1195e:	4620      	mov	r0, r4
   11960:	f01a f9fb 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, addr);
   11964:	4629      	mov	r1, r5
   11966:	4620      	mov	r0, r4
   11968:	f01a f9ff 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, company);
   1196c:	4641      	mov	r1, r8
   1196e:	4620      	mov	r0, r4
   11970:	f01a f9fb 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, id);
   11974:	4631      	mov	r1, r6
   11976:	4620      	mov	r0, r4
   11978:	f01a f9f7 	bl	2bd6a <net_buf_simple_add_le16>
	visit_ctx.msg = &msg;
   1197c:	60bc      	str	r4, [r7, #8]
	visit_ctx.elem_idx = mod->elem_idx;
   1197e:	f89b 3004 	ldrb.w	r3, [fp, #4]
	bt_mesh_model_extensions_walk(mod, mod_sub_list_visitor, &visit_ctx);
   11982:	4908      	ldr	r1, [pc, #32]	; (119a4 <mod_sub_get_vnd+0x144>)
	visit_ctx.elem_idx = mod->elem_idx;
   11984:	80bb      	strh	r3, [r7, #4]
	bt_mesh_model_extensions_walk(mod, mod_sub_list_visitor, &visit_ctx);
   11986:	1d3a      	adds	r2, r7, #4
   11988:	4658      	mov	r0, fp
   1198a:	f018 fba4 	bl	2a0d6 <bt_mesh_model_extensions_walk>
   1198e:	e7c5      	b.n	1191c <mod_sub_get_vnd+0xbc>
   11990:	00031ccf 	.word	0x00031ccf
   11994:	0002dafc 	.word	0x0002dafc
   11998:	00031d2b 	.word	0x00031d2b
   1199c:	00032792 	.word	0x00032792
   119a0:	00031d54 	.word	0x00031d54
   119a4:	00011691 	.word	0x00011691

000119a8 <net_key_get>:
}

static int net_key_get(struct bt_mesh_model *model,
		       struct bt_mesh_msg_ctx *ctx,
		       struct net_buf_simple *buf)
{
   119a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   119aa:	b091      	sub	sp, #68	; 0x44
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_LIST,
   119ac:	ab04      	add	r3, sp, #16
   119ae:	f44f 2210 	mov.w	r2, #589824	; 0x90000
{
   119b2:	4605      	mov	r5, r0
   119b4:	460e      	mov	r6, r1
				 IDX_LEN(CONFIG_BT_MESH_SUBNET_COUNT));
	uint16_t net_idx[CONFIG_BT_MESH_SUBNET_COUNT];
	ssize_t count;
	int i;

	bt_mesh_model_msg_init(&msg, OP_NET_KEY_LIST);
   119b6:	a807      	add	r0, sp, #28
   119b8:	f248 0143 	movw	r1, #32835	; 0x8043
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_LIST,
   119bc:	e9cd 2308 	strd	r2, r3, [sp, #32]
   119c0:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_LIST);
   119c2:	f018 fbb0 	bl	2a126 <bt_mesh_model_msg_init>

	count = bt_mesh_subnets_get(net_idx, ARRAY_SIZE(net_idx), 0);
   119c6:	2200      	movs	r2, #0
   119c8:	2102      	movs	r1, #2
   119ca:	a802      	add	r0, sp, #8
   119cc:	f7fb fef6 	bl	d7bc <bt_mesh_subnets_get>
	if (count < 0 || count > ARRAY_SIZE(net_idx)) {
		count = ARRAY_SIZE(net_idx);
   119d0:	2803      	cmp	r0, #3
	count = bt_mesh_subnets_get(net_idx, ARRAY_SIZE(net_idx), 0);
   119d2:	4604      	mov	r4, r0
		count = ARRAY_SIZE(net_idx);
   119d4:	bf28      	it	cs
   119d6:	2402      	movcs	r4, #2
	}

	for (i = 0; i < count - 1; i += 2) {
   119d8:	2300      	movs	r3, #0
   119da:	1e67      	subs	r7, r4, #1
   119dc:	429f      	cmp	r7, r3
   119de:	dc1f      	bgt.n	11a20 <net_key_get+0x78>
		key_idx_pack(&msg, net_idx[i], net_idx[i + 1]);
	}

	if (i < count) {
   119e0:	429c      	cmp	r4, r3
   119e2:	dd07      	ble.n	119f4 <net_key_get+0x4c>
		net_buf_simple_add_le16(&msg, net_idx[i]);
   119e4:	aa10      	add	r2, sp, #64	; 0x40
   119e6:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   119ea:	a807      	add	r0, sp, #28
   119ec:	f833 1c38 	ldrh.w	r1, [r3, #-56]
   119f0:	f01a f9bb 	bl	2bd6a <net_buf_simple_add_le16>
	}

	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   119f4:	2300      	movs	r3, #0
   119f6:	9300      	str	r3, [sp, #0]
   119f8:	aa07      	add	r2, sp, #28
   119fa:	4631      	mov	r1, r6
   119fc:	4628      	mov	r0, r5
   119fe:	f7ff fab9 	bl	10f74 <bt_mesh_model_send>
   11a02:	b150      	cbz	r0, 11a1a <net_key_get+0x72>
		BT_ERR("Unable to send NetKey List");
   11a04:	4b0b      	ldr	r3, [pc, #44]	; (11a34 <net_key_get+0x8c>)
   11a06:	930e      	str	r3, [sp, #56]	; 0x38
   11a08:	480b      	ldr	r0, [pc, #44]	; (11a38 <net_key_get+0x90>)
   11a0a:	2302      	movs	r3, #2
   11a0c:	aa0d      	add	r2, sp, #52	; 0x34
   11a0e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11a12:	9303      	str	r3, [sp, #12]
   11a14:	930d      	str	r3, [sp, #52]	; 0x34
   11a16:	f018 fc07 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	}

	return 0;
}
   11a1a:	2000      	movs	r0, #0
   11a1c:	b011      	add	sp, #68	; 0x44
   11a1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		key_idx_pack(&msg, net_idx[i], net_idx[i + 1]);
   11a20:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   11a24:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   11a28:	a807      	add	r0, sp, #28
   11a2a:	f018 fba5 	bl	2a178 <key_idx_pack>
	for (i = 0; i < count - 1; i += 2) {
   11a2e:	2302      	movs	r3, #2
   11a30:	e7d4      	b.n	119dc <net_key_get+0x34>
   11a32:	bf00      	nop
   11a34:	00031d82 	.word	0x00031d82
   11a38:	0002dafc 	.word	0x0002dafc

00011a3c <send_mod_sub_status>:
{
   11a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11a40:	b093      	sub	sp, #76	; 0x4c
   11a42:	af02      	add	r7, sp, #8
   11a44:	461c      	mov	r4, r3
   11a46:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
   11a4a:	607b      	str	r3, [r7, #4]
   11a4c:	4615      	mov	r5, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_SUB_STATUS, 9);
   11a4e:	f107 0318 	add.w	r3, r7, #24
   11a52:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a56:	46eb      	mov	fp, sp
   11a58:	b08a      	sub	sp, #40	; 0x28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_SUB_STATUS, 9);
   11a5a:	e9c7 2304 	strd	r2, r3, [r7, #16]
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a5e:	aa02      	add	r2, sp, #8
{
   11a60:	4688      	mov	r8, r1
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a62:	492c      	ldr	r1, [pc, #176]	; (11b14 <send_mod_sub_status+0xd8>)
   11a64:	6111      	str	r1, [r2, #16]
   11a66:	492c      	ldr	r1, [pc, #176]	; (11b18 <send_mod_sub_status+0xdc>)
{
   11a68:	f8b7 a068 	ldrh.w	sl, [r7, #104]	; 0x68
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_SUB_STATUS, 9);
   11a6c:	60fb      	str	r3, [r7, #12]
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a6e:	e9c2 1505 	strd	r1, r5, [r2, #20]
   11a72:	2106      	movs	r1, #6
   11a74:	e9c2 4a07 	strd	r4, sl, [r2, #28]
   11a78:	62b9      	str	r1, [r7, #40]	; 0x28
   11a7a:	f842 1f0c 	str.w	r1, [r2, #12]!
{
   11a7e:	4606      	mov	r6, r0
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a80:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   11a84:	4825      	ldr	r0, [pc, #148]	; (11b1c <send_mod_sub_status+0xe0>)
{
   11a86:	f8d7 906c 	ldr.w	r9, [r7, #108]	; 0x6c
	BT_DBG("status 0x%02x elem_addr 0x%04x sub_addr 0x%04x", status,
   11a8a:	f018 fbcd 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_MOD_SUB_STATUS);
   11a8e:	f248 011f 	movw	r1, #32799	; 0x801f
   11a92:	46dd      	mov	sp, fp
   11a94:	f107 000c 	add.w	r0, r7, #12
   11a98:	f018 fb45 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   11a9c:	4629      	mov	r1, r5
   11a9e:	f107 000c 	add.w	r0, r7, #12
   11aa2:	f01a f95a 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   11aa6:	4621      	mov	r1, r4
   11aa8:	f107 000c 	add.w	r0, r7, #12
   11aac:	f01a f95d 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, sub_addr);
   11ab0:	4651      	mov	r1, sl
   11ab2:	f107 000c 	add.w	r0, r7, #12
   11ab6:	f01a f958 	bl	2bd6a <net_buf_simple_add_le16>
	if (vnd) {
   11aba:	687b      	ldr	r3, [r7, #4]
   11abc:	b313      	cbz	r3, 11b04 <send_mod_sub_status+0xc8>
		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
   11abe:	2104      	movs	r1, #4
   11ac0:	f107 000c 	add.w	r0, r7, #12
   11ac4:	f01a f93a 	bl	2bd3c <net_buf_simple_add>
   11ac8:	2204      	movs	r2, #4
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   11aca:	4649      	mov	r1, r9
   11acc:	f015 fed0 	bl	27870 <memcpy>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11ad0:	2300      	movs	r3, #0
   11ad2:	9300      	str	r3, [sp, #0]
   11ad4:	f107 020c 	add.w	r2, r7, #12
   11ad8:	4641      	mov	r1, r8
   11ada:	4630      	mov	r0, r6
   11adc:	f7ff fa4a 	bl	10f74 <bt_mesh_model_send>
   11ae0:	b158      	cbz	r0, 11afa <send_mod_sub_status+0xbe>
		BT_ERR("Unable to send Model Subscription Status");
   11ae2:	4b0f      	ldr	r3, [pc, #60]	; (11b20 <send_mod_sub_status+0xe4>)
   11ae4:	63bb      	str	r3, [r7, #56]	; 0x38
   11ae6:	480d      	ldr	r0, [pc, #52]	; (11b1c <send_mod_sub_status+0xe0>)
   11ae8:	2302      	movs	r3, #2
   11aea:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11aee:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11af2:	60bb      	str	r3, [r7, #8]
   11af4:	637b      	str	r3, [r7, #52]	; 0x34
   11af6:	f018 fb97 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   11afa:	2000      	movs	r0, #0
   11afc:	3744      	adds	r7, #68	; 0x44
   11afe:	46bd      	mov	sp, r7
   11b00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
   11b04:	2102      	movs	r1, #2
   11b06:	f107 000c 	add.w	r0, r7, #12
   11b0a:	f01a f917 	bl	2bd3c <net_buf_simple_add>
   11b0e:	2202      	movs	r2, #2
   11b10:	e7db      	b.n	11aca <send_mod_sub_status+0x8e>
   11b12:	bf00      	nop
   11b14:	00031d9d 	.word	0x00031d9d
   11b18:	0003274d 	.word	0x0003274d
   11b1c:	0002dafc 	.word	0x0002dafc
   11b20:	00031dd0 	.word	0x00031dd0

00011b24 <get_model>:
{
   11b24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11b28:	b082      	sub	sp, #8
	if (buf->len < 4) {
   11b2a:	888b      	ldrh	r3, [r1, #4]
   11b2c:	f8df 9094 	ldr.w	r9, [pc, #148]	; 11bc4 <get_model+0xa0>
   11b30:	2b03      	cmp	r3, #3
{
   11b32:	4604      	mov	r4, r0
   11b34:	af00      	add	r7, sp, #0
   11b36:	460d      	mov	r5, r1
   11b38:	4616      	mov	r6, r2
		id = net_buf_simple_pull_le16(buf);
   11b3a:	4608      	mov	r0, r1
	if (buf->len < 4) {
   11b3c:	d81f      	bhi.n	11b7e <get_model+0x5a>
		id = net_buf_simple_pull_le16(buf);
   11b3e:	f01a f985 	bl	2be4c <net_buf_simple_pull_le16>
		BT_DBG("ID 0x%04x addr 0x%04x", id, elem->addr);
   11b42:	46e8      	mov	r8, sp
   11b44:	8823      	ldrh	r3, [r4, #0]
   11b46:	4920      	ldr	r1, [pc, #128]	; (11bc8 <get_model+0xa4>)
   11b48:	b088      	sub	sp, #32
   11b4a:	466a      	mov	r2, sp
   11b4c:	e9c2 0306 	strd	r0, r3, [r2, #24]
   11b50:	2305      	movs	r3, #5
   11b52:	e9c2 1904 	strd	r1, r9, [r2, #16]
		id = net_buf_simple_pull_le16(buf);
   11b56:	4605      	mov	r5, r0
		BT_DBG("ID 0x%04x addr 0x%04x", id, elem->addr);
   11b58:	f842 3f0c 	str.w	r3, [r2, #12]!
   11b5c:	481b      	ldr	r0, [pc, #108]	; (11bcc <get_model+0xa8>)
   11b5e:	607b      	str	r3, [r7, #4]
   11b60:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   11b64:	f018 fb60 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		*vnd = false;
   11b68:	2300      	movs	r3, #0
   11b6a:	46c5      	mov	sp, r8
   11b6c:	7033      	strb	r3, [r6, #0]
		return bt_mesh_model_find(elem, id);
   11b6e:	4629      	mov	r1, r5
   11b70:	4620      	mov	r0, r4
   11b72:	f018 fa9c 	bl	2a0ae <bt_mesh_model_find>
}
   11b76:	3708      	adds	r7, #8
   11b78:	46bd      	mov	sp, r7
   11b7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		company = net_buf_simple_pull_le16(buf);
   11b7e:	f01a f965 	bl	2be4c <net_buf_simple_pull_le16>
   11b82:	4680      	mov	r8, r0
		id = net_buf_simple_pull_le16(buf);
   11b84:	4628      	mov	r0, r5
   11b86:	f01a f961 	bl	2be4c <net_buf_simple_pull_le16>
		BT_DBG("Company 0x%04x ID 0x%04x addr 0x%04x", company, id,
   11b8a:	46ea      	mov	sl, sp
   11b8c:	b08a      	sub	sp, #40	; 0x28
   11b8e:	466a      	mov	r2, sp
   11b90:	8823      	ldrh	r3, [r4, #0]
   11b92:	490f      	ldr	r1, [pc, #60]	; (11bd0 <get_model+0xac>)
   11b94:	6213      	str	r3, [r2, #32]
   11b96:	2306      	movs	r3, #6
   11b98:	e9c2 1904 	strd	r1, r9, [r2, #16]
   11b9c:	e9c2 8006 	strd	r8, r0, [r2, #24]
		id = net_buf_simple_pull_le16(buf);
   11ba0:	4605      	mov	r5, r0
		BT_DBG("Company 0x%04x ID 0x%04x addr 0x%04x", company, id,
   11ba2:	f842 3f0c 	str.w	r3, [r2, #12]!
   11ba6:	4809      	ldr	r0, [pc, #36]	; (11bcc <get_model+0xa8>)
   11ba8:	607b      	str	r3, [r7, #4]
   11baa:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   11bae:	f018 fb3b 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		*vnd = true;
   11bb2:	2301      	movs	r3, #1
   11bb4:	46d5      	mov	sp, sl
   11bb6:	7033      	strb	r3, [r6, #0]
		return bt_mesh_model_find_vnd(elem, company, id);
   11bb8:	462a      	mov	r2, r5
   11bba:	4641      	mov	r1, r8
   11bbc:	4620      	mov	r0, r4
   11bbe:	f018 fa5f 	bl	2a080 <bt_mesh_model_find_vnd>
   11bc2:	e7d8      	b.n	11b76 <get_model+0x52>
   11bc4:	0003280f 	.word	0x0003280f
   11bc8:	00031df9 	.word	0x00031df9
   11bcc:	0002dafc 	.word	0x0002dafc
   11bd0:	00031e13 	.word	0x00031e13

00011bd4 <mod_app_get>:
#define KEY_LIST_LEN (CONFIG_BT_MESH_MODEL_KEY_COUNT * 2)

static int mod_app_get(struct bt_mesh_model *model,
		       struct bt_mesh_msg_ctx *ctx,
		       struct net_buf_simple *buf)
{
   11bd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11bd8:	4692      	mov	sl, r2
   11bda:	b093      	sub	sp, #76	; 0x4c
	struct bt_mesh_elem *elem;
	uint8_t *mod_id, status;
	uint16_t elem_addr;
	bool vnd;

	if ((buf->len != 4U) && (buf->len != 6U)) {
   11bdc:	f8ba b004 	ldrh.w	fp, [sl, #4]
   11be0:	f02b 0b02 	bic.w	fp, fp, #2
{
   11be4:	af02      	add	r7, sp, #8
	if ((buf->len != 4U) && (buf->len != 6U)) {
   11be6:	fa1f fb8b 	uxth.w	fp, fp
	NET_BUF_SIMPLE_DEFINE(msg,
   11bea:	f107 0314 	add.w	r3, r7, #20
   11bee:	f44f 1288 	mov.w	r2, #1114112	; 0x110000
	if ((buf->len != 4U) && (buf->len != 6U)) {
   11bf2:	f1bb 0f04 	cmp.w	fp, #4
	NET_BUF_SIMPLE_DEFINE(msg,
   11bf6:	e9c7 2303 	strd	r2, r3, [r7, #12]
{
   11bfa:	4606      	mov	r6, r0
   11bfc:	4688      	mov	r8, r1
	NET_BUF_SIMPLE_DEFINE(msg,
   11bfe:	60bb      	str	r3, [r7, #8]
	if ((buf->len != 4U) && (buf->len != 6U)) {
   11c00:	d011      	beq.n	11c26 <mod_app_get+0x52>
		BT_ERR("The message size for the application opcode is incorrect.");
   11c02:	4b4c      	ldr	r3, [pc, #304]	; (11d34 <mod_app_get+0x160>)
   11c04:	484c      	ldr	r0, [pc, #304]	; (11d38 <mod_app_get+0x164>)
   11c06:	63bb      	str	r3, [r7, #56]	; 0x38
   11c08:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11c0c:	2302      	movs	r3, #2
   11c0e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11c12:	607b      	str	r3, [r7, #4]
   11c14:	637b      	str	r3, [r7, #52]	; 0x34
   11c16:	f018 fb07 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   11c1a:	f06f 0079 	mvn.w	r0, #121	; 0x79
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send Model Application List message");
	}

	return 0;
}
   11c1e:	3744      	adds	r7, #68	; 0x44
   11c20:	46bd      	mov	sp, r7
   11c22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   11c26:	4650      	mov	r0, sl
   11c28:	f01a f910 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11c2c:	b203      	sxth	r3, r0
   11c2e:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11c30:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11c32:	dc0e      	bgt.n	11c52 <mod_app_get+0x7e>
		BT_WARN("Prohibited element address");
   11c34:	4b41      	ldr	r3, [pc, #260]	; (11d3c <mod_app_get+0x168>)
   11c36:	4840      	ldr	r0, [pc, #256]	; (11d38 <mod_app_get+0x164>)
   11c38:	63bb      	str	r3, [r7, #56]	; 0x38
   11c3a:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11c3e:	2302      	movs	r3, #2
   11c40:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   11c44:	607b      	str	r3, [r7, #4]
   11c46:	637b      	str	r3, [r7, #52]	; 0x34
   11c48:	f018 faee 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   11c4c:	f06f 0015 	mvn.w	r0, #21
   11c50:	e7e5      	b.n	11c1e <mod_app_get+0x4a>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   11c52:	466c      	mov	r4, sp
   11c54:	b088      	sub	sp, #32
   11c56:	aa02      	add	r2, sp, #8
   11c58:	4b39      	ldr	r3, [pc, #228]	; (11d40 <mod_app_get+0x16c>)
   11c5a:	6113      	str	r3, [r2, #16]
   11c5c:	4b39      	ldr	r3, [pc, #228]	; (11d44 <mod_app_get+0x170>)
	mod_id = buf->data;
   11c5e:	f8da 9000 	ldr.w	r9, [sl]
	BT_DBG("elem_addr 0x%04x", elem_addr);
   11c62:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
   11c66:	e9c2 3005 	strd	r3, r0, [r2, #20]
   11c6a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   11c6e:	f842 bf0c 	str.w	fp, [r2, #12]!
   11c72:	4831      	ldr	r0, [pc, #196]	; (11d38 <mod_app_get+0x164>)
   11c74:	f018 fad8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   11c78:	4628      	mov	r0, r5
   11c7a:	46a5      	mov	sp, r4
   11c7c:	f7ff f8f8 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   11c80:	4604      	mov	r4, r0
   11c82:	2800      	cmp	r0, #0
   11c84:	d13c      	bne.n	11d00 <mod_app_get+0x12c>
		vnd = (buf->len == 4U);
   11c86:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   11c8a:	1f1a      	subs	r2, r3, #4
   11c8c:	4253      	negs	r3, r2
   11c8e:	4153      	adcs	r3, r2
   11c90:	70fb      	strb	r3, [r7, #3]
		status = STATUS_INVALID_ADDRESS;
   11c92:	f04f 0a01 	mov.w	sl, #1
	if (vnd) {
   11c96:	78fb      	ldrb	r3, [r7, #3]
   11c98:	2b00      	cmp	r3, #0
   11c9a:	d03c      	beq.n	11d16 <mod_app_get+0x142>
		bt_mesh_model_msg_init(&msg, OP_VND_MOD_APP_LIST);
   11c9c:	f248 014e 	movw	r1, #32846	; 0x804e
		bt_mesh_model_msg_init(&msg, OP_SIG_MOD_APP_LIST);
   11ca0:	f107 0008 	add.w	r0, r7, #8
   11ca4:	f018 fa3f 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   11ca8:	4651      	mov	r1, sl
   11caa:	f107 0008 	add.w	r0, r7, #8
   11cae:	f01a f854 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, elem_addr);
   11cb2:	4629      	mov	r1, r5
   11cb4:	f107 0008 	add.w	r0, r7, #8
   11cb8:	f01a f857 	bl	2bd6a <net_buf_simple_add_le16>
	if (vnd) {
   11cbc:	78fb      	ldrb	r3, [r7, #3]
   11cbe:	b36b      	cbz	r3, 11d1c <mod_app_get+0x148>
		net_buf_simple_add_mem(&msg, mod_id, 4);
   11cc0:	2204      	movs	r2, #4
		net_buf_simple_add_mem(&msg, mod_id, 2);
   11cc2:	4649      	mov	r1, r9
   11cc4:	f107 0008 	add.w	r0, r7, #8
   11cc8:	f01a f83e 	bl	2bd48 <net_buf_simple_add_mem>
	if (mod) {
   11ccc:	bb44      	cbnz	r4, 11d20 <mod_app_get+0x14c>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11cce:	2400      	movs	r4, #0
   11cd0:	9400      	str	r4, [sp, #0]
   11cd2:	4623      	mov	r3, r4
   11cd4:	f107 0208 	add.w	r2, r7, #8
   11cd8:	4641      	mov	r1, r8
   11cda:	4630      	mov	r0, r6
   11cdc:	f7ff f94a 	bl	10f74 <bt_mesh_model_send>
   11ce0:	2800      	cmp	r0, #0
   11ce2:	d09c      	beq.n	11c1e <mod_app_get+0x4a>
		BT_ERR("Unable to send Model Application List message");
   11ce4:	4b18      	ldr	r3, [pc, #96]	; (11d48 <mod_app_get+0x174>)
   11ce6:	4814      	ldr	r0, [pc, #80]	; (11d38 <mod_app_get+0x164>)
   11ce8:	63bb      	str	r3, [r7, #56]	; 0x38
   11cea:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11cee:	2302      	movs	r3, #2
   11cf0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11cf4:	607b      	str	r3, [r7, #4]
   11cf6:	637b      	str	r3, [r7, #52]	; 0x34
   11cf8:	f018 fa96 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   11cfc:	4620      	mov	r0, r4
   11cfe:	e78e      	b.n	11c1e <mod_app_get+0x4a>
	mod = get_model(elem, buf, &vnd);
   11d00:	4651      	mov	r1, sl
   11d02:	1cfa      	adds	r2, r7, #3
   11d04:	f7ff ff0e 	bl	11b24 <get_model>
		status = STATUS_INVALID_MODEL;
   11d08:	1e04      	subs	r4, r0, #0
   11d0a:	bf14      	ite	ne
   11d0c:	f04f 0a00 	movne.w	sl, #0
   11d10:	f04f 0a02 	moveq.w	sl, #2
   11d14:	e7bf      	b.n	11c96 <mod_app_get+0xc2>
		bt_mesh_model_msg_init(&msg, OP_SIG_MOD_APP_LIST);
   11d16:	f248 014c 	movw	r1, #32844	; 0x804c
   11d1a:	e7c1      	b.n	11ca0 <mod_app_get+0xcc>
		net_buf_simple_add_mem(&msg, mod_id, 2);
   11d1c:	2202      	movs	r2, #2
   11d1e:	e7d0      	b.n	11cc2 <mod_app_get+0xee>
			if (mod->keys[i] != BT_MESH_KEY_UNUSED) {
   11d20:	89a1      	ldrh	r1, [r4, #12]
   11d22:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11d26:	4299      	cmp	r1, r3
   11d28:	d0d1      	beq.n	11cce <mod_app_get+0xfa>
				net_buf_simple_add_le16(&msg, mod->keys[i]);
   11d2a:	f107 0008 	add.w	r0, r7, #8
   11d2e:	f01a f81c 	bl	2bd6a <net_buf_simple_add_le16>
		for (i = 0; i < ARRAY_SIZE(mod->keys); i++) {
   11d32:	e7cc      	b.n	11cce <mod_app_get+0xfa>
   11d34:	00031e3c 	.word	0x00031e3c
   11d38:	0002dafc 	.word	0x0002dafc
   11d3c:	00031ccf 	.word	0x00031ccf
   11d40:	00031e76 	.word	0x00031e76
   11d44:	00032819 	.word	0x00032819
   11d48:	00031e8b 	.word	0x00031e8b

00011d4c <mod_app_unbind>:
{
   11d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11d50:	b093      	sub	sp, #76	; 0x4c
   11d52:	4614      	mov	r4, r2
   11d54:	af02      	add	r7, sp, #8
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   11d56:	f107 0318 	add.w	r3, r7, #24
   11d5a:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   11d5e:	e9c7 2304 	strd	r2, r3, [r7, #16]
   11d62:	60fb      	str	r3, [r7, #12]
	if ((buf->len != 6U) && (buf->len != 8U)) {
   11d64:	88a3      	ldrh	r3, [r4, #4]
   11d66:	2b06      	cmp	r3, #6
{
   11d68:	4680      	mov	r8, r0
   11d6a:	4689      	mov	r9, r1
	if ((buf->len != 6U) && (buf->len != 8U)) {
   11d6c:	d013      	beq.n	11d96 <mod_app_unbind+0x4a>
   11d6e:	2b08      	cmp	r3, #8
   11d70:	d011      	beq.n	11d96 <mod_app_unbind+0x4a>
		BT_ERR("The message size for the application opcode is incorrect.");
   11d72:	4b3c      	ldr	r3, [pc, #240]	; (11e64 <mod_app_unbind+0x118>)
   11d74:	483c      	ldr	r0, [pc, #240]	; (11e68 <mod_app_unbind+0x11c>)
   11d76:	63bb      	str	r3, [r7, #56]	; 0x38
   11d78:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11d7c:	2302      	movs	r3, #2
   11d7e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11d82:	60bb      	str	r3, [r7, #8]
   11d84:	637b      	str	r3, [r7, #52]	; 0x34
   11d86:	f018 fa4f 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   11d8a:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   11d8e:	3744      	adds	r7, #68	; 0x44
   11d90:	46bd      	mov	sp, r7
   11d92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   11d96:	4620      	mov	r0, r4
   11d98:	f01a f858 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11d9c:	b203      	sxth	r3, r0
   11d9e:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11da0:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11da2:	dc0e      	bgt.n	11dc2 <mod_app_unbind+0x76>
		BT_WARN("Prohibited element address");
   11da4:	4b31      	ldr	r3, [pc, #196]	; (11e6c <mod_app_unbind+0x120>)
   11da6:	4830      	ldr	r0, [pc, #192]	; (11e68 <mod_app_unbind+0x11c>)
   11da8:	63bb      	str	r3, [r7, #56]	; 0x38
   11daa:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11dae:	2302      	movs	r3, #2
   11db0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   11db4:	60bb      	str	r3, [r7, #8]
   11db6:	637b      	str	r3, [r7, #52]	; 0x34
   11db8:	f018 fa36 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   11dbc:	f06f 0015 	mvn.w	r0, #21
   11dc0:	e7e5      	b.n	11d8e <mod_app_unbind+0x42>
	key_app_idx = net_buf_simple_pull_le16(buf);
   11dc2:	4620      	mov	r0, r4
   11dc4:	f01a f842 	bl	2be4c <net_buf_simple_pull_le16>
   11dc8:	4606      	mov	r6, r0
	elem = bt_mesh_elem_find(elem_addr);
   11dca:	4628      	mov	r0, r5
	mod_id = buf->data;
   11dcc:	f8d4 a000 	ldr.w	sl, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   11dd0:	f7ff f84e 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   11dd4:	2800      	cmp	r0, #0
   11dd6:	d139      	bne.n	11e4c <mod_app_unbind+0x100>
		vnd = (buf->len == 4U);
   11dd8:	88a3      	ldrh	r3, [r4, #4]
   11dda:	1f1a      	subs	r2, r3, #4
   11ddc:	4253      	negs	r3, r2
   11dde:	4153      	adcs	r3, r2
   11de0:	71fb      	strb	r3, [r7, #7]
		status = STATUS_INVALID_ADDRESS;
   11de2:	2401      	movs	r4, #1
	BT_DBG("status 0x%02x", status);
   11de4:	46eb      	mov	fp, sp
   11de6:	b088      	sub	sp, #32
   11de8:	aa02      	add	r2, sp, #8
   11dea:	4b21      	ldr	r3, [pc, #132]	; (11e70 <mod_app_unbind+0x124>)
   11dec:	6113      	str	r3, [r2, #16]
   11dee:	4b21      	ldr	r3, [pc, #132]	; (11e74 <mod_app_unbind+0x128>)
   11df0:	481d      	ldr	r0, [pc, #116]	; (11e68 <mod_app_unbind+0x11c>)
   11df2:	e9c2 3405 	strd	r3, r4, [r2, #20]
   11df6:	2304      	movs	r3, #4
   11df8:	f842 3f0c 	str.w	r3, [r2, #12]!
   11dfc:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   11e00:	62bb      	str	r3, [r7, #40]	; 0x28
   11e02:	f018 fa11 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   11e06:	46dd      	mov	sp, fp
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   11e08:	79f9      	ldrb	r1, [r7, #7]
   11e0a:	4633      	mov	r3, r6
   11e0c:	e9cd 4a00 	strd	r4, sl, [sp]
   11e10:	462a      	mov	r2, r5
   11e12:	f107 000c 	add.w	r0, r7, #12
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11e16:	2400      	movs	r4, #0
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   11e18:	f018 f9db 	bl	2a1d2 <create_mod_app_status.constprop.0>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   11e1c:	9400      	str	r4, [sp, #0]
   11e1e:	4623      	mov	r3, r4
   11e20:	f107 020c 	add.w	r2, r7, #12
   11e24:	4649      	mov	r1, r9
   11e26:	4640      	mov	r0, r8
   11e28:	f7ff f8a4 	bl	10f74 <bt_mesh_model_send>
   11e2c:	2800      	cmp	r0, #0
   11e2e:	d0ae      	beq.n	11d8e <mod_app_unbind+0x42>
		BT_ERR("Unable to send Model App Unbind Status response");
   11e30:	4b11      	ldr	r3, [pc, #68]	; (11e78 <mod_app_unbind+0x12c>)
   11e32:	480d      	ldr	r0, [pc, #52]	; (11e68 <mod_app_unbind+0x11c>)
   11e34:	63bb      	str	r3, [r7, #56]	; 0x38
   11e36:	f107 0234 	add.w	r2, r7, #52	; 0x34
   11e3a:	2302      	movs	r3, #2
   11e3c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11e40:	60bb      	str	r3, [r7, #8]
   11e42:	637b      	str	r3, [r7, #52]	; 0x34
   11e44:	f018 f9f0 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   11e48:	4620      	mov	r0, r4
   11e4a:	e7a0      	b.n	11d8e <mod_app_unbind+0x42>
	mod = get_model(elem, buf, &vnd);
   11e4c:	1dfa      	adds	r2, r7, #7
   11e4e:	4621      	mov	r1, r4
   11e50:	f7ff fe68 	bl	11b24 <get_model>
	if (!mod) {
   11e54:	b120      	cbz	r0, 11e60 <mod_app_unbind+0x114>
	status = mod_unbind(mod, key_app_idx, true);
   11e56:	4631      	mov	r1, r6
   11e58:	f7ff fa5c 	bl	11314 <mod_unbind.constprop.0>
   11e5c:	4604      	mov	r4, r0
send_status:
   11e5e:	e7c1      	b.n	11de4 <mod_app_unbind+0x98>
		status = STATUS_INVALID_MODEL;
   11e60:	2402      	movs	r4, #2
   11e62:	e7bf      	b.n	11de4 <mod_app_unbind+0x98>
   11e64:	00031e3c 	.word	0x00031e3c
   11e68:	0002dafc 	.word	0x0002dafc
   11e6c:	00031ccf 	.word	0x00031ccf
   11e70:	00031eb9 	.word	0x00031eb9
   11e74:	00032800 	.word	0x00032800
   11e78:	00031ecb 	.word	0x00031ecb

00011e7c <mod_sub_del_all>:
{
   11e7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11e80:	b08c      	sub	sp, #48	; 0x30
	if ((buf->len != 4U) && (buf->len != 6U)) {
   11e82:	8895      	ldrh	r5, [r2, #4]
   11e84:	f025 0502 	bic.w	r5, r5, #2
   11e88:	b2ad      	uxth	r5, r5
   11e8a:	2d04      	cmp	r5, #4
{
   11e8c:	af04      	add	r7, sp, #16
   11e8e:	4680      	mov	r8, r0
   11e90:	4689      	mov	r9, r1
   11e92:	4614      	mov	r4, r2
	if ((buf->len != 4U) && (buf->len != 6U)) {
   11e94:	d011      	beq.n	11eba <mod_sub_del_all+0x3e>
		BT_ERR("The message size for the application opcode is incorrect.");
   11e96:	4b30      	ldr	r3, [pc, #192]	; (11f58 <mod_sub_del_all+0xdc>)
   11e98:	4830      	ldr	r0, [pc, #192]	; (11f5c <mod_sub_del_all+0xe0>)
   11e9a:	61bb      	str	r3, [r7, #24]
   11e9c:	f107 0214 	add.w	r2, r7, #20
   11ea0:	2302      	movs	r3, #2
   11ea2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11ea6:	607b      	str	r3, [r7, #4]
   11ea8:	617b      	str	r3, [r7, #20]
   11eaa:	f018 f9bd 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   11eae:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   11eb2:	3720      	adds	r7, #32
   11eb4:	46bd      	mov	sp, r7
   11eb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   11eba:	4610      	mov	r0, r2
   11ebc:	f019 ffc6 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11ec0:	b203      	sxth	r3, r0
   11ec2:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11ec4:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11ec6:	dc0e      	bgt.n	11ee6 <mod_sub_del_all+0x6a>
		BT_WARN("Prohibited element address");
   11ec8:	4b25      	ldr	r3, [pc, #148]	; (11f60 <mod_sub_del_all+0xe4>)
   11eca:	4824      	ldr	r0, [pc, #144]	; (11f5c <mod_sub_del_all+0xe0>)
   11ecc:	61bb      	str	r3, [r7, #24]
   11ece:	f107 0214 	add.w	r2, r7, #20
   11ed2:	2302      	movs	r3, #2
   11ed4:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   11ed8:	607b      	str	r3, [r7, #4]
   11eda:	617b      	str	r3, [r7, #20]
   11edc:	f018 f9a4 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   11ee0:	f06f 0015 	mvn.w	r0, #21
   11ee4:	e7e5      	b.n	11eb2 <mod_sub_del_all+0x36>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   11ee6:	46ea      	mov	sl, sp
   11ee8:	b088      	sub	sp, #32
   11eea:	aa04      	add	r2, sp, #16
   11eec:	4b1d      	ldr	r3, [pc, #116]	; (11f64 <mod_sub_del_all+0xe8>)
   11eee:	6113      	str	r3, [r2, #16]
   11ef0:	4b1d      	ldr	r3, [pc, #116]	; (11f68 <mod_sub_del_all+0xec>)
   11ef2:	60bd      	str	r5, [r7, #8]
   11ef4:	e9c2 3005 	strd	r3, r0, [r2, #20]
   11ef8:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   11efc:	f842 5f0c 	str.w	r5, [r2, #12]!
   11f00:	4816      	ldr	r0, [pc, #88]	; (11f5c <mod_sub_del_all+0xe0>)
   11f02:	f018 f991 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   11f06:	4630      	mov	r0, r6
   11f08:	46d5      	mov	sp, sl
	mod_id = buf->data;
   11f0a:	6825      	ldr	r5, [r4, #0]
	elem = bt_mesh_elem_find(elem_addr);
   11f0c:	f7fe ffb0 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   11f10:	b980      	cbnz	r0, 11f34 <mod_sub_del_all+0xb8>
		vnd = (buf->len == 4U);
   11f12:	88a3      	ldrh	r3, [r4, #4]
   11f14:	1f1a      	subs	r2, r3, #4
   11f16:	4253      	negs	r3, r2
   11f18:	4153      	adcs	r3, r2
   11f1a:	723b      	strb	r3, [r7, #8]
		status = STATUS_INVALID_ADDRESS;
   11f1c:	2201      	movs	r2, #1
	return send_mod_sub_status(model, ctx, status, elem_addr,
   11f1e:	7a3b      	ldrb	r3, [r7, #8]
   11f20:	e9cd 5301 	strd	r5, r3, [sp, #4]
   11f24:	2300      	movs	r3, #0
   11f26:	9300      	str	r3, [sp, #0]
   11f28:	4649      	mov	r1, r9
   11f2a:	4633      	mov	r3, r6
   11f2c:	4640      	mov	r0, r8
   11f2e:	f7ff fd85 	bl	11a3c <send_mod_sub_status>
   11f32:	e7be      	b.n	11eb2 <mod_sub_del_all+0x36>
	mod = get_model(elem, buf, &vnd);
   11f34:	4621      	mov	r1, r4
   11f36:	f107 0208 	add.w	r2, r7, #8
   11f3a:	f7ff fdf3 	bl	11b24 <get_model>
	if (!mod) {
   11f3e:	4604      	mov	r4, r0
   11f40:	b140      	cbz	r0, 11f54 <mod_sub_del_all+0xd8>
	bt_mesh_model_extensions_walk(mod, mod_sub_clear_visitor, NULL);
   11f42:	2200      	movs	r2, #0
   11f44:	4909      	ldr	r1, [pc, #36]	; (11f6c <mod_sub_del_all+0xf0>)
   11f46:	f018 f8c6 	bl	2a0d6 <bt_mesh_model_extensions_walk>
		bt_mesh_model_sub_store(mod);
   11f4a:	4620      	mov	r0, r4
   11f4c:	f018 f8dd 	bl	2a10a <bt_mesh_model_sub_store>
	status = STATUS_SUCCESS;
   11f50:	2200      	movs	r2, #0
   11f52:	e7e4      	b.n	11f1e <mod_sub_del_all+0xa2>
		status = STATUS_INVALID_MODEL;
   11f54:	2202      	movs	r2, #2
   11f56:	e7e2      	b.n	11f1e <mod_sub_del_all+0xa2>
   11f58:	00031e3c 	.word	0x00031e3c
   11f5c:	0002dafc 	.word	0x0002dafc
   11f60:	00031ccf 	.word	0x00031ccf
   11f64:	00031e76 	.word	0x00031e76
   11f68:	00032761 	.word	0x00032761
   11f6c:	0002a237 	.word	0x0002a237

00011f70 <mod_sub_overwrite>:
{
   11f70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11f74:	b08c      	sub	sp, #48	; 0x30
	if ((buf->len != 6U) && (buf->len != 8U)) {
   11f76:	8893      	ldrh	r3, [r2, #4]
   11f78:	2b06      	cmp	r3, #6
{
   11f7a:	af04      	add	r7, sp, #16
   11f7c:	4680      	mov	r8, r0
   11f7e:	4689      	mov	r9, r1
   11f80:	4614      	mov	r4, r2
	if ((buf->len != 6U) && (buf->len != 8U)) {
   11f82:	d013      	beq.n	11fac <mod_sub_overwrite+0x3c>
   11f84:	2b08      	cmp	r3, #8
   11f86:	d011      	beq.n	11fac <mod_sub_overwrite+0x3c>
		BT_ERR("The message size for the application opcode is incorrect.");
   11f88:	4b36      	ldr	r3, [pc, #216]	; (12064 <mod_sub_overwrite+0xf4>)
   11f8a:	4837      	ldr	r0, [pc, #220]	; (12068 <mod_sub_overwrite+0xf8>)
   11f8c:	61bb      	str	r3, [r7, #24]
   11f8e:	f107 0214 	add.w	r2, r7, #20
   11f92:	2302      	movs	r3, #2
   11f94:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   11f98:	607b      	str	r3, [r7, #4]
   11f9a:	617b      	str	r3, [r7, #20]
   11f9c:	f018 f944 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   11fa0:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   11fa4:	3720      	adds	r7, #32
   11fa6:	46bd      	mov	sp, r7
   11fa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   11fac:	4620      	mov	r0, r4
   11fae:	f019 ff4d 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11fb2:	b203      	sxth	r3, r0
   11fb4:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   11fb6:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   11fb8:	dc0e      	bgt.n	11fd8 <mod_sub_overwrite+0x68>
		BT_WARN("Prohibited element address");
   11fba:	4b2c      	ldr	r3, [pc, #176]	; (1206c <mod_sub_overwrite+0xfc>)
   11fbc:	482a      	ldr	r0, [pc, #168]	; (12068 <mod_sub_overwrite+0xf8>)
   11fbe:	61bb      	str	r3, [r7, #24]
   11fc0:	f107 0214 	add.w	r2, r7, #20
   11fc4:	2302      	movs	r3, #2
   11fc6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   11fca:	607b      	str	r3, [r7, #4]
   11fcc:	617b      	str	r3, [r7, #20]
   11fce:	f018 f92b 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   11fd2:	f06f 0015 	mvn.w	r0, #21
   11fd6:	e7e5      	b.n	11fa4 <mod_sub_overwrite+0x34>
	sub_addr = net_buf_simple_pull_le16(buf);
   11fd8:	4620      	mov	r0, r4
   11fda:	f019 ff37 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("elem_addr 0x%04x sub_addr 0x%04x", elem_addr, sub_addr);
   11fde:	46ea      	mov	sl, sp
   11fe0:	b088      	sub	sp, #32
   11fe2:	4b23      	ldr	r3, [pc, #140]	; (12070 <mod_sub_overwrite+0x100>)
   11fe4:	9308      	str	r3, [sp, #32]
   11fe6:	4b23      	ldr	r3, [pc, #140]	; (12074 <mod_sub_overwrite+0x104>)
   11fe8:	900b      	str	r0, [sp, #44]	; 0x2c
   11fea:	aa04      	add	r2, sp, #16
   11fec:	e9c2 3505 	strd	r3, r5, [r2, #20]
   11ff0:	2305      	movs	r3, #5
   11ff2:	f842 3f0c 	str.w	r3, [r2, #12]!
	sub_addr = net_buf_simple_pull_le16(buf);
   11ff6:	4606      	mov	r6, r0
	BT_DBG("elem_addr 0x%04x sub_addr 0x%04x", elem_addr, sub_addr);
   11ff8:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   11ffc:	481a      	ldr	r0, [pc, #104]	; (12068 <mod_sub_overwrite+0xf8>)
   11ffe:	60bb      	str	r3, [r7, #8]
   12000:	f018 f912 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12004:	4628      	mov	r0, r5
   12006:	46d5      	mov	sp, sl
	mod_id = buf->data;
   12008:	f8d4 a000 	ldr.w	sl, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   1200c:	f7fe ff30 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   12010:	b930      	cbnz	r0, 12020 <mod_sub_overwrite+0xb0>
		vnd = (buf->len == 4U);
   12012:	88a3      	ldrh	r3, [r4, #4]
   12014:	1f1a      	subs	r2, r3, #4
   12016:	4253      	negs	r3, r2
   12018:	4153      	adcs	r3, r2
   1201a:	723b      	strb	r3, [r7, #8]
		status = STATUS_INVALID_ADDRESS;
   1201c:	2201      	movs	r2, #1
   1201e:	e015      	b.n	1204c <mod_sub_overwrite+0xdc>
	mod = get_model(elem, buf, &vnd);
   12020:	4621      	mov	r1, r4
   12022:	f107 0208 	add.w	r2, r7, #8
   12026:	f7ff fd7d 	bl	11b24 <get_model>
	if (!mod) {
   1202a:	4604      	mov	r4, r0
   1202c:	b1c0      	cbz	r0, 12060 <mod_sub_overwrite+0xf0>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   1202e:	f506 4380 	add.w	r3, r6, #16384	; 0x4000
   12032:	b29b      	uxth	r3, r3
   12034:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   12038:	d8f0      	bhi.n	1201c <mod_sub_overwrite+0xac>
		bt_mesh_model_extensions_walk(mod, mod_sub_clear_visitor, NULL);
   1203a:	2200      	movs	r2, #0
   1203c:	490e      	ldr	r1, [pc, #56]	; (12078 <mod_sub_overwrite+0x108>)
   1203e:	f018 f84a 	bl	2a0d6 <bt_mesh_model_extensions_walk>
		mod->groups[0] = sub_addr;
   12042:	81e6      	strh	r6, [r4, #14]
			bt_mesh_model_sub_store(mod);
   12044:	4620      	mov	r0, r4
   12046:	f018 f860 	bl	2a10a <bt_mesh_model_sub_store>
		status = STATUS_SUCCESS;
   1204a:	2200      	movs	r2, #0
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   1204c:	7a3b      	ldrb	r3, [r7, #8]
   1204e:	9600      	str	r6, [sp, #0]
   12050:	e9cd a301 	strd	sl, r3, [sp, #4]
   12054:	4649      	mov	r1, r9
   12056:	462b      	mov	r3, r5
   12058:	4640      	mov	r0, r8
   1205a:	f7ff fcef 	bl	11a3c <send_mod_sub_status>
   1205e:	e7a1      	b.n	11fa4 <mod_sub_overwrite+0x34>
		status = STATUS_INVALID_MODEL;
   12060:	2202      	movs	r2, #2
   12062:	e7f3      	b.n	1204c <mod_sub_overwrite+0xdc>
   12064:	00031e3c 	.word	0x00031e3c
   12068:	0002dafc 	.word	0x0002dafc
   1206c:	00031ccf 	.word	0x00031ccf
   12070:	00031efb 	.word	0x00031efb
   12074:	00032726 	.word	0x00032726
   12078:	0002a237 	.word	0x0002a237

0001207c <mod_sub_va_overwrite>:
{
   1207c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12080:	b08d      	sub	sp, #52	; 0x34
   12082:	af04      	add	r7, sp, #16
	uint16_t elem_addr, sub_addr = BT_MESH_ADDR_UNASSIGNED;
   12084:	2300      	movs	r3, #0
   12086:	807b      	strh	r3, [r7, #2]
	if ((buf->len != 20U) && (buf->len != 22U)) {
   12088:	8893      	ldrh	r3, [r2, #4]
   1208a:	f023 0302 	bic.w	r3, r3, #2
   1208e:	b29b      	uxth	r3, r3
   12090:	2b14      	cmp	r3, #20
{
   12092:	4606      	mov	r6, r0
   12094:	4688      	mov	r8, r1
   12096:	4614      	mov	r4, r2
	if ((buf->len != 20U) && (buf->len != 22U)) {
   12098:	d011      	beq.n	120be <mod_sub_va_overwrite+0x42>
		BT_ERR("The message size for the application opcode is incorrect.");
   1209a:	4b39      	ldr	r3, [pc, #228]	; (12180 <mod_sub_va_overwrite+0x104>)
   1209c:	4839      	ldr	r0, [pc, #228]	; (12184 <mod_sub_va_overwrite+0x108>)
   1209e:	61bb      	str	r3, [r7, #24]
   120a0:	f107 0214 	add.w	r2, r7, #20
   120a4:	2302      	movs	r3, #2
   120a6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   120aa:	607b      	str	r3, [r7, #4]
   120ac:	617b      	str	r3, [r7, #20]
   120ae:	f018 f8bb 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   120b2:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   120b6:	3724      	adds	r7, #36	; 0x24
   120b8:	46bd      	mov	sp, r7
   120ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   120be:	4610      	mov	r0, r2
   120c0:	f019 fec4 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   120c4:	b203      	sxth	r3, r0
   120c6:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   120c8:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   120ca:	dc0e      	bgt.n	120ea <mod_sub_va_overwrite+0x6e>
		BT_WARN("Prohibited element address");
   120cc:	4b2e      	ldr	r3, [pc, #184]	; (12188 <mod_sub_va_overwrite+0x10c>)
   120ce:	482d      	ldr	r0, [pc, #180]	; (12184 <mod_sub_va_overwrite+0x108>)
   120d0:	61bb      	str	r3, [r7, #24]
   120d2:	f107 0214 	add.w	r2, r7, #20
   120d6:	2302      	movs	r3, #2
   120d8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   120dc:	607b      	str	r3, [r7, #4]
   120de:	617b      	str	r3, [r7, #20]
   120e0:	f018 f8a2 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   120e4:	f06f 0015 	mvn.w	r0, #21
   120e8:	e7e5      	b.n	120b6 <mod_sub_va_overwrite+0x3a>
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   120ea:	2110      	movs	r1, #16
   120ec:	4620      	mov	r0, r4
   120ee:	f019 fe9d 	bl	2be2c <net_buf_simple_pull_mem>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   120f2:	46ea      	mov	sl, sp
   120f4:	b088      	sub	sp, #32
   120f6:	aa04      	add	r2, sp, #16
   120f8:	4b24      	ldr	r3, [pc, #144]	; (1218c <mod_sub_va_overwrite+0x110>)
   120fa:	6113      	str	r3, [r2, #16]
   120fc:	4b24      	ldr	r3, [pc, #144]	; (12190 <mod_sub_va_overwrite+0x114>)
   120fe:	e9c2 3505 	strd	r3, r5, [r2, #20]
   12102:	2304      	movs	r3, #4
   12104:	f842 3f0c 	str.w	r3, [r2, #12]!
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   12108:	4681      	mov	r9, r0
	BT_DBG("elem_addr 0x%04x", elem_addr);
   1210a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1210e:	481d      	ldr	r0, [pc, #116]	; (12184 <mod_sub_va_overwrite+0x108>)
   12110:	60bb      	str	r3, [r7, #8]
   12112:	f018 f889 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12116:	4628      	mov	r0, r5
   12118:	46d5      	mov	sp, sl
	mod_id = buf->data;
   1211a:	f8d4 a000 	ldr.w	sl, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   1211e:	f7fe fea7 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   12122:	b988      	cbnz	r0, 12148 <mod_sub_va_overwrite+0xcc>
		vnd = (buf->len == 4U);
   12124:	88a3      	ldrh	r3, [r4, #4]
   12126:	1f1a      	subs	r2, r3, #4
   12128:	4253      	negs	r3, r2
   1212a:	4153      	adcs	r3, r2
   1212c:	723b      	strb	r3, [r7, #8]
		status = STATUS_INVALID_ADDRESS;
   1212e:	2401      	movs	r4, #1
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   12130:	7a3b      	ldrb	r3, [r7, #8]
   12132:	e9cd a301 	strd	sl, r3, [sp, #4]
   12136:	887b      	ldrh	r3, [r7, #2]
   12138:	9300      	str	r3, [sp, #0]
   1213a:	4622      	mov	r2, r4
   1213c:	462b      	mov	r3, r5
   1213e:	4641      	mov	r1, r8
   12140:	4630      	mov	r0, r6
   12142:	f7ff fc7b 	bl	11a3c <send_mod_sub_status>
   12146:	e7b6      	b.n	120b6 <mod_sub_va_overwrite+0x3a>
	mod = get_model(elem, buf, &vnd);
   12148:	f107 0208 	add.w	r2, r7, #8
   1214c:	4621      	mov	r1, r4
   1214e:	f7ff fce9 	bl	11b24 <get_model>
	if (!mod) {
   12152:	4683      	mov	fp, r0
   12154:	b190      	cbz	r0, 1217c <mod_sub_va_overwrite+0x100>
		status = bt_mesh_va_add(label_uuid, &sub_addr);
   12156:	1cb9      	adds	r1, r7, #2
   12158:	4648      	mov	r0, r9
   1215a:	f7fc fe35 	bl	edc8 <bt_mesh_va_add>
		if (status == STATUS_SUCCESS) {
   1215e:	4604      	mov	r4, r0
   12160:	2800      	cmp	r0, #0
   12162:	d1e5      	bne.n	12130 <mod_sub_va_overwrite+0xb4>
			bt_mesh_model_extensions_walk(mod, mod_sub_clear_visitor, NULL);
   12164:	4602      	mov	r2, r0
   12166:	490b      	ldr	r1, [pc, #44]	; (12194 <mod_sub_va_overwrite+0x118>)
   12168:	4658      	mov	r0, fp
   1216a:	f017 ffb4 	bl	2a0d6 <bt_mesh_model_extensions_walk>
			mod->groups[0] = sub_addr;
   1216e:	887b      	ldrh	r3, [r7, #2]
   12170:	f8ab 300e 	strh.w	r3, [fp, #14]
				bt_mesh_model_sub_store(mod);
   12174:	4658      	mov	r0, fp
   12176:	f017 ffc8 	bl	2a10a <bt_mesh_model_sub_store>
   1217a:	e7d9      	b.n	12130 <mod_sub_va_overwrite+0xb4>
		status = STATUS_INVALID_MODEL;
   1217c:	2402      	movs	r4, #2
   1217e:	e7d7      	b.n	12130 <mod_sub_va_overwrite+0xb4>
   12180:	00031e3c 	.word	0x00031e3c
   12184:	0002dafc 	.word	0x0002dafc
   12188:	00031ccf 	.word	0x00031ccf
   1218c:	00031e76 	.word	0x00031e76
   12190:	00032738 	.word	0x00032738
   12194:	0002a237 	.word	0x0002a237

00012198 <mod_sub_va_del>:
{
   12198:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1219c:	b08c      	sub	sp, #48	; 0x30
	if ((buf->len != 20U) && (buf->len != 22U)) {
   1219e:	8893      	ldrh	r3, [r2, #4]
   121a0:	f023 0302 	bic.w	r3, r3, #2
   121a4:	b29b      	uxth	r3, r3
   121a6:	2b14      	cmp	r3, #20
{
   121a8:	af04      	add	r7, sp, #16
   121aa:	4606      	mov	r6, r0
   121ac:	4688      	mov	r8, r1
   121ae:	4614      	mov	r4, r2
	if ((buf->len != 20U) && (buf->len != 22U)) {
   121b0:	d011      	beq.n	121d6 <mod_sub_va_del+0x3e>
		BT_ERR("The message size for the application opcode is incorrect.");
   121b2:	4b3b      	ldr	r3, [pc, #236]	; (122a0 <mod_sub_va_del+0x108>)
   121b4:	483b      	ldr	r0, [pc, #236]	; (122a4 <mod_sub_va_del+0x10c>)
   121b6:	61bb      	str	r3, [r7, #24]
   121b8:	f107 0214 	add.w	r2, r7, #20
   121bc:	2302      	movs	r3, #2
   121be:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   121c2:	607b      	str	r3, [r7, #4]
   121c4:	617b      	str	r3, [r7, #20]
   121c6:	f018 f82f 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   121ca:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   121ce:	3720      	adds	r7, #32
   121d0:	46bd      	mov	sp, r7
   121d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   121d6:	4610      	mov	r0, r2
   121d8:	f019 fe38 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   121dc:	b203      	sxth	r3, r0
   121de:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   121e0:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   121e2:	dc0e      	bgt.n	12202 <mod_sub_va_del+0x6a>
		BT_WARN("Prohibited element address");
   121e4:	4b30      	ldr	r3, [pc, #192]	; (122a8 <mod_sub_va_del+0x110>)
   121e6:	482f      	ldr	r0, [pc, #188]	; (122a4 <mod_sub_va_del+0x10c>)
   121e8:	61bb      	str	r3, [r7, #24]
   121ea:	f107 0214 	add.w	r2, r7, #20
   121ee:	2302      	movs	r3, #2
   121f0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   121f4:	607b      	str	r3, [r7, #4]
   121f6:	617b      	str	r3, [r7, #20]
   121f8:	f018 f816 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   121fc:	f06f 0015 	mvn.w	r0, #21
   12200:	e7e5      	b.n	121ce <mod_sub_va_del+0x36>
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   12202:	2110      	movs	r1, #16
   12204:	4620      	mov	r0, r4
   12206:	f019 fe11 	bl	2be2c <net_buf_simple_pull_mem>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   1220a:	46e9      	mov	r9, sp
   1220c:	b088      	sub	sp, #32
   1220e:	aa04      	add	r2, sp, #16
   12210:	4b26      	ldr	r3, [pc, #152]	; (122ac <mod_sub_va_del+0x114>)
   12212:	6113      	str	r3, [r2, #16]
   12214:	4b26      	ldr	r3, [pc, #152]	; (122b0 <mod_sub_va_del+0x118>)
   12216:	e9c2 3505 	strd	r3, r5, [r2, #20]
   1221a:	2304      	movs	r3, #4
   1221c:	f842 3f0c 	str.w	r3, [r2, #12]!
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   12220:	4682      	mov	sl, r0
	BT_DBG("elem_addr 0x%04x", elem_addr);
   12222:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   12226:	481f      	ldr	r0, [pc, #124]	; (122a4 <mod_sub_va_del+0x10c>)
   12228:	60bb      	str	r3, [r7, #8]
   1222a:	f017 fffd 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   1222e:	4628      	mov	r0, r5
   12230:	46cd      	mov	sp, r9
	mod_id = buf->data;
   12232:	f8d4 9000 	ldr.w	r9, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   12236:	f7fe fe1b 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   1223a:	b990      	cbnz	r0, 12262 <mod_sub_va_del+0xca>
		vnd = (buf->len == 4U);
   1223c:	88a2      	ldrh	r2, [r4, #4]
		mod = NULL;
   1223e:	60b8      	str	r0, [r7, #8]
		vnd = (buf->len == 4U);
   12240:	1f11      	subs	r1, r2, #4
   12242:	424a      	negs	r2, r1
   12244:	414a      	adcs	r2, r1
   12246:	70fa      	strb	r2, [r7, #3]
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   12248:	80b8      	strh	r0, [r7, #4]
		status = STATUS_INVALID_ADDRESS;
   1224a:	2201      	movs	r2, #1
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   1224c:	78fb      	ldrb	r3, [r7, #3]
   1224e:	e9cd 9301 	strd	r9, r3, [sp, #4]
   12252:	88bb      	ldrh	r3, [r7, #4]
   12254:	9300      	str	r3, [sp, #0]
   12256:	4641      	mov	r1, r8
   12258:	462b      	mov	r3, r5
   1225a:	4630      	mov	r0, r6
   1225c:	f7ff fbee 	bl	11a3c <send_mod_sub_status>
   12260:	e7b5      	b.n	121ce <mod_sub_va_del+0x36>
	mod = get_model(elem, buf, &vnd);
   12262:	1cfa      	adds	r2, r7, #3
   12264:	4621      	mov	r1, r4
   12266:	f7ff fc5d 	bl	11b24 <get_model>
   1226a:	60b8      	str	r0, [r7, #8]
	if (!mod) {
   1226c:	b910      	cbnz	r0, 12274 <mod_sub_va_del+0xdc>
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   1226e:	80b8      	strh	r0, [r7, #4]
		status = STATUS_INVALID_MODEL;
   12270:	2202      	movs	r2, #2
		goto send_status;
   12272:	e7eb      	b.n	1224c <mod_sub_va_del+0xb4>
	status = bt_mesh_va_del(label_uuid, &sub_addr);
   12274:	1d39      	adds	r1, r7, #4
   12276:	4650      	mov	r0, sl
   12278:	f7fc fdfc 	bl	ee74 <bt_mesh_va_del>
	if (sub_addr == BT_MESH_ADDR_UNASSIGNED) {
   1227c:	88b9      	ldrh	r1, [r7, #4]
	status = bt_mesh_va_del(label_uuid, &sub_addr);
   1227e:	4602      	mov	r2, r0
	if (sub_addr == BT_MESH_ADDR_UNASSIGNED) {
   12280:	2900      	cmp	r1, #0
   12282:	d0e3      	beq.n	1224c <mod_sub_va_del+0xb4>
	match = bt_mesh_model_find_group(&mod, sub_addr);
   12284:	f107 0008 	add.w	r0, r7, #8
   12288:	f7fe fea6 	bl	10fd8 <bt_mesh_model_find_group>
	if (match) {
   1228c:	b130      	cbz	r0, 1229c <mod_sub_va_del+0x104>
		*match = BT_MESH_ADDR_UNASSIGNED;
   1228e:	2400      	movs	r4, #0
   12290:	8004      	strh	r4, [r0, #0]
			bt_mesh_model_sub_store(mod);
   12292:	68b8      	ldr	r0, [r7, #8]
   12294:	f017 ff39 	bl	2a10a <bt_mesh_model_sub_store>
		status = STATUS_SUCCESS;
   12298:	4622      	mov	r2, r4
   1229a:	e7d7      	b.n	1224c <mod_sub_va_del+0xb4>
		status = STATUS_CANNOT_REMOVE;
   1229c:	220c      	movs	r2, #12
   1229e:	e7d5      	b.n	1224c <mod_sub_va_del+0xb4>
   122a0:	00031e3c 	.word	0x00031e3c
   122a4:	0002dafc 	.word	0x0002dafc
   122a8:	00031ccf 	.word	0x00031ccf
   122ac:	00031e76 	.word	0x00031e76
   122b0:	00032717 	.word	0x00032717

000122b4 <mod_sub_del>:
{
   122b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   122b8:	b08c      	sub	sp, #48	; 0x30
	if ((buf->len != 6U) && (buf->len != 8U)) {
   122ba:	8893      	ldrh	r3, [r2, #4]
   122bc:	2b06      	cmp	r3, #6
{
   122be:	af04      	add	r7, sp, #16
   122c0:	4606      	mov	r6, r0
   122c2:	4688      	mov	r8, r1
   122c4:	4692      	mov	sl, r2
	if ((buf->len != 6U) && (buf->len != 8U)) {
   122c6:	d013      	beq.n	122f0 <mod_sub_del+0x3c>
   122c8:	2b08      	cmp	r3, #8
   122ca:	d011      	beq.n	122f0 <mod_sub_del+0x3c>
		BT_ERR("The message size for the application opcode is incorrect.");
   122cc:	4b3a      	ldr	r3, [pc, #232]	; (123b8 <mod_sub_del+0x104>)
   122ce:	483b      	ldr	r0, [pc, #236]	; (123bc <mod_sub_del+0x108>)
   122d0:	61bb      	str	r3, [r7, #24]
   122d2:	f107 0214 	add.w	r2, r7, #20
   122d6:	2302      	movs	r3, #2
   122d8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   122dc:	607b      	str	r3, [r7, #4]
   122de:	617b      	str	r3, [r7, #20]
   122e0:	f017 ffa2 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   122e4:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   122e8:	3720      	adds	r7, #32
   122ea:	46bd      	mov	sp, r7
   122ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   122f0:	4650      	mov	r0, sl
   122f2:	f019 fdab 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   122f6:	b203      	sxth	r3, r0
   122f8:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   122fa:	4604      	mov	r4, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   122fc:	dc0e      	bgt.n	1231c <mod_sub_del+0x68>
		BT_WARN("Prohibited element address");
   122fe:	4b30      	ldr	r3, [pc, #192]	; (123c0 <mod_sub_del+0x10c>)
   12300:	482e      	ldr	r0, [pc, #184]	; (123bc <mod_sub_del+0x108>)
   12302:	61bb      	str	r3, [r7, #24]
   12304:	f107 0214 	add.w	r2, r7, #20
   12308:	2302      	movs	r3, #2
   1230a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1230e:	607b      	str	r3, [r7, #4]
   12310:	617b      	str	r3, [r7, #20]
   12312:	f017 ff89 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12316:	f06f 0015 	mvn.w	r0, #21
   1231a:	e7e5      	b.n	122e8 <mod_sub_del+0x34>
	sub_addr = net_buf_simple_pull_le16(buf);
   1231c:	4650      	mov	r0, sl
   1231e:	f019 fd95 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("elem_addr 0x%04x sub_addr 0x%04x", elem_addr, sub_addr);
   12322:	46e9      	mov	r9, sp
   12324:	b088      	sub	sp, #32
   12326:	4b27      	ldr	r3, [pc, #156]	; (123c4 <mod_sub_del+0x110>)
   12328:	9308      	str	r3, [sp, #32]
   1232a:	4b27      	ldr	r3, [pc, #156]	; (123c8 <mod_sub_del+0x114>)
   1232c:	900b      	str	r0, [sp, #44]	; 0x2c
   1232e:	aa04      	add	r2, sp, #16
   12330:	e9c2 3405 	strd	r3, r4, [r2, #20]
   12334:	2305      	movs	r3, #5
   12336:	f842 3f0c 	str.w	r3, [r2, #12]!
	sub_addr = net_buf_simple_pull_le16(buf);
   1233a:	4605      	mov	r5, r0
	BT_DBG("elem_addr 0x%04x sub_addr 0x%04x", elem_addr, sub_addr);
   1233c:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12340:	481e      	ldr	r0, [pc, #120]	; (123bc <mod_sub_del+0x108>)
   12342:	60bb      	str	r3, [r7, #8]
   12344:	f017 ff70 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12348:	4620      	mov	r0, r4
   1234a:	46cd      	mov	sp, r9
	mod_id = buf->data;
   1234c:	f8da 9000 	ldr.w	r9, [sl]
	elem = bt_mesh_elem_find(elem_addr);
   12350:	f7fe fd8e 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   12354:	b940      	cbnz	r0, 12368 <mod_sub_del+0xb4>
		vnd = (buf->len == 4U);
   12356:	f8ba 3004 	ldrh.w	r3, [sl, #4]
		mod = NULL;
   1235a:	60b8      	str	r0, [r7, #8]
		vnd = (buf->len == 4U);
   1235c:	1f1a      	subs	r2, r3, #4
   1235e:	4253      	negs	r3, r2
   12360:	4153      	adcs	r3, r2
   12362:	713b      	strb	r3, [r7, #4]
		status = STATUS_INVALID_ADDRESS;
   12364:	2201      	movs	r2, #1
   12366:	e01a      	b.n	1239e <mod_sub_del+0xea>
	mod = get_model(elem, buf, &vnd);
   12368:	1d3a      	adds	r2, r7, #4
   1236a:	4651      	mov	r1, sl
   1236c:	f7ff fbda 	bl	11b24 <get_model>
   12370:	60b8      	str	r0, [r7, #8]
	if (!mod) {
   12372:	b1f0      	cbz	r0, 123b2 <mod_sub_del+0xfe>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   12374:	f505 4380 	add.w	r3, r5, #16384	; 0x4000
   12378:	b29b      	uxth	r3, r3
   1237a:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   1237e:	d8f1      	bhi.n	12364 <mod_sub_del+0xb0>
	match = bt_mesh_model_find_group(&mod, sub_addr);
   12380:	4629      	mov	r1, r5
   12382:	f107 0008 	add.w	r0, r7, #8
   12386:	f7fe fe27 	bl	10fd8 <bt_mesh_model_find_group>
	if (match) {
   1238a:	f04f 0a00 	mov.w	sl, #0
   1238e:	4602      	mov	r2, r0
   12390:	b128      	cbz	r0, 1239e <mod_sub_del+0xea>
		*match = BT_MESH_ADDR_UNASSIGNED;
   12392:	f8a0 a000 	strh.w	sl, [r0]
			bt_mesh_model_sub_store(mod);
   12396:	68b8      	ldr	r0, [r7, #8]
   12398:	f017 feb7 	bl	2a10a <bt_mesh_model_sub_store>
	status = STATUS_SUCCESS;
   1239c:	4652      	mov	r2, sl
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   1239e:	793b      	ldrb	r3, [r7, #4]
   123a0:	9500      	str	r5, [sp, #0]
   123a2:	e9cd 9301 	strd	r9, r3, [sp, #4]
   123a6:	4641      	mov	r1, r8
   123a8:	4623      	mov	r3, r4
   123aa:	4630      	mov	r0, r6
   123ac:	f7ff fb46 	bl	11a3c <send_mod_sub_status>
   123b0:	e79a      	b.n	122e8 <mod_sub_del+0x34>
		status = STATUS_INVALID_MODEL;
   123b2:	2202      	movs	r2, #2
   123b4:	e7f3      	b.n	1239e <mod_sub_del+0xea>
   123b6:	bf00      	nop
   123b8:	00031e3c 	.word	0x00031e3c
   123bc:	0002dafc 	.word	0x0002dafc
   123c0:	00031ccf 	.word	0x00031ccf
   123c4:	00031efb 	.word	0x00031efb
   123c8:	0003270b 	.word	0x0003270b

000123cc <mod_sub_va_add>:
{
   123cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   123d0:	b08c      	sub	sp, #48	; 0x30
	if ((buf->len != 20U) && (buf->len != 22U)) {
   123d2:	8893      	ldrh	r3, [r2, #4]
   123d4:	f023 0302 	bic.w	r3, r3, #2
   123d8:	b29b      	uxth	r3, r3
   123da:	2b14      	cmp	r3, #20
{
   123dc:	af04      	add	r7, sp, #16
   123de:	4680      	mov	r8, r0
   123e0:	4689      	mov	r9, r1
   123e2:	4614      	mov	r4, r2
	if ((buf->len != 20U) && (buf->len != 22U)) {
   123e4:	d011      	beq.n	1240a <mod_sub_va_add+0x3e>
		BT_ERR("The message size for the application opcode is incorrect.");
   123e6:	4b42      	ldr	r3, [pc, #264]	; (124f0 <mod_sub_va_add+0x124>)
   123e8:	4842      	ldr	r0, [pc, #264]	; (124f4 <mod_sub_va_add+0x128>)
   123ea:	61bb      	str	r3, [r7, #24]
   123ec:	f107 0214 	add.w	r2, r7, #20
   123f0:	2302      	movs	r3, #2
   123f2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   123f6:	607b      	str	r3, [r7, #4]
   123f8:	617b      	str	r3, [r7, #20]
   123fa:	f017 ff15 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   123fe:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   12402:	3720      	adds	r7, #32
   12404:	46bd      	mov	sp, r7
   12406:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   1240a:	4610      	mov	r0, r2
   1240c:	f019 fd1e 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12410:	b203      	sxth	r3, r0
   12412:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   12414:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12416:	dc0e      	bgt.n	12436 <mod_sub_va_add+0x6a>
		BT_WARN("Prohibited element address");
   12418:	4b37      	ldr	r3, [pc, #220]	; (124f8 <mod_sub_va_add+0x12c>)
   1241a:	4836      	ldr	r0, [pc, #216]	; (124f4 <mod_sub_va_add+0x128>)
   1241c:	61bb      	str	r3, [r7, #24]
   1241e:	f107 0214 	add.w	r2, r7, #20
   12422:	2302      	movs	r3, #2
   12424:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   12428:	607b      	str	r3, [r7, #4]
   1242a:	617b      	str	r3, [r7, #20]
   1242c:	f017 fefc 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12430:	f06f 0015 	mvn.w	r0, #21
   12434:	e7e5      	b.n	12402 <mod_sub_va_add+0x36>
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   12436:	2110      	movs	r1, #16
   12438:	4620      	mov	r0, r4
   1243a:	f019 fcf7 	bl	2be2c <net_buf_simple_pull_mem>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   1243e:	46ea      	mov	sl, sp
   12440:	b088      	sub	sp, #32
   12442:	aa04      	add	r2, sp, #16
   12444:	4b2d      	ldr	r3, [pc, #180]	; (124fc <mod_sub_va_add+0x130>)
   12446:	6113      	str	r3, [r2, #16]
   12448:	4b2d      	ldr	r3, [pc, #180]	; (12500 <mod_sub_va_add+0x134>)
   1244a:	e9c2 3505 	strd	r3, r5, [r2, #20]
   1244e:	2304      	movs	r3, #4
   12450:	f842 3f0c 	str.w	r3, [r2, #12]!
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   12454:	4606      	mov	r6, r0
	BT_DBG("elem_addr 0x%04x", elem_addr);
   12456:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1245a:	4826      	ldr	r0, [pc, #152]	; (124f4 <mod_sub_va_add+0x128>)
   1245c:	60bb      	str	r3, [r7, #8]
   1245e:	f017 fee3 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12462:	4628      	mov	r0, r5
   12464:	46d5      	mov	sp, sl
	mod_id = buf->data;
   12466:	f8d4 a000 	ldr.w	sl, [r4]
	elem = bt_mesh_elem_find(elem_addr);
   1246a:	f7fe fd01 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   1246e:	b998      	cbnz	r0, 12498 <mod_sub_va_add+0xcc>
		vnd = (buf->len == 4U);
   12470:	88a2      	ldrh	r2, [r4, #4]
		mod = NULL;
   12472:	60b8      	str	r0, [r7, #8]
		vnd = (buf->len == 4U);
   12474:	1f11      	subs	r1, r2, #4
   12476:	424a      	negs	r2, r1
   12478:	414a      	adcs	r2, r1
   1247a:	70fa      	strb	r2, [r7, #3]
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   1247c:	80b8      	strh	r0, [r7, #4]
		status = STATUS_INVALID_ADDRESS;
   1247e:	2401      	movs	r4, #1
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   12480:	78fb      	ldrb	r3, [r7, #3]
   12482:	e9cd a301 	strd	sl, r3, [sp, #4]
   12486:	88bb      	ldrh	r3, [r7, #4]
   12488:	9300      	str	r3, [sp, #0]
   1248a:	4622      	mov	r2, r4
   1248c:	462b      	mov	r3, r5
   1248e:	4649      	mov	r1, r9
   12490:	4640      	mov	r0, r8
   12492:	f7ff fad3 	bl	11a3c <send_mod_sub_status>
   12496:	e7b4      	b.n	12402 <mod_sub_va_add+0x36>
	mod = get_model(elem, buf, &vnd);
   12498:	1cfa      	adds	r2, r7, #3
   1249a:	4621      	mov	r1, r4
   1249c:	f7ff fb42 	bl	11b24 <get_model>
   124a0:	60b8      	str	r0, [r7, #8]
	if (!mod) {
   124a2:	b910      	cbnz	r0, 124aa <mod_sub_va_add+0xde>
		sub_addr = BT_MESH_ADDR_UNASSIGNED;
   124a4:	80b8      	strh	r0, [r7, #4]
		status = STATUS_INVALID_MODEL;
   124a6:	2402      	movs	r4, #2
		goto send_status;
   124a8:	e7ea      	b.n	12480 <mod_sub_va_add+0xb4>
	status = bt_mesh_va_add(label_uuid, &sub_addr);
   124aa:	1d39      	adds	r1, r7, #4
   124ac:	4630      	mov	r0, r6
   124ae:	f7fc fc8b 	bl	edc8 <bt_mesh_va_add>
	if (status != STATUS_SUCCESS) {
   124b2:	4604      	mov	r4, r0
   124b4:	2800      	cmp	r0, #0
   124b6:	d1e3      	bne.n	12480 <mod_sub_va_add+0xb4>
	if (bt_mesh_model_find_group(&mod, sub_addr)) {
   124b8:	88b9      	ldrh	r1, [r7, #4]
   124ba:	f107 0008 	add.w	r0, r7, #8
   124be:	f7fe fd8b 	bl	10fd8 <bt_mesh_model_find_group>
		bt_mesh_va_del(label_uuid, NULL);
   124c2:	4621      	mov	r1, r4
	if (bt_mesh_model_find_group(&mod, sub_addr)) {
   124c4:	b118      	cbz	r0, 124ce <mod_sub_va_add+0x102>
		bt_mesh_va_del(label_uuid, NULL);
   124c6:	4630      	mov	r0, r6
   124c8:	f7fc fcd4 	bl	ee74 <bt_mesh_va_del>
		goto send_status;
   124cc:	e7d8      	b.n	12480 <mod_sub_va_add+0xb4>
	entry = bt_mesh_model_find_group(&mod, BT_MESH_ADDR_UNASSIGNED);
   124ce:	f107 0008 	add.w	r0, r7, #8
   124d2:	f7fe fd81 	bl	10fd8 <bt_mesh_model_find_group>
	if (!entry) {
   124d6:	b928      	cbnz	r0, 124e4 <mod_sub_va_add+0x118>
		bt_mesh_va_del(label_uuid, NULL);
   124d8:	4621      	mov	r1, r4
   124da:	4630      	mov	r0, r6
   124dc:	f7fc fcca 	bl	ee74 <bt_mesh_va_del>
		status = STATUS_INSUFF_RESOURCES;
   124e0:	2405      	movs	r4, #5
		goto send_status;
   124e2:	e7cd      	b.n	12480 <mod_sub_va_add+0xb4>
	*entry = sub_addr;
   124e4:	88bb      	ldrh	r3, [r7, #4]
   124e6:	8003      	strh	r3, [r0, #0]
		bt_mesh_model_sub_store(mod);
   124e8:	68b8      	ldr	r0, [r7, #8]
   124ea:	f017 fe0e 	bl	2a10a <bt_mesh_model_sub_store>
	status = STATUS_SUCCESS;
   124ee:	e7c7      	b.n	12480 <mod_sub_va_add+0xb4>
   124f0:	00031e3c 	.word	0x00031e3c
   124f4:	0002dafc 	.word	0x0002dafc
   124f8:	00031ccf 	.word	0x00031ccf
   124fc:	00031e76 	.word	0x00031e76
   12500:	000326ed 	.word	0x000326ed

00012504 <mod_sub_add>:
{
   12504:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12508:	b091      	sub	sp, #68	; 0x44
   1250a:	4693      	mov	fp, r2
	if ((buf->len != 6U) && (buf->len != 8U)) {
   1250c:	8892      	ldrh	r2, [r2, #4]
   1250e:	2a06      	cmp	r2, #6
{
   12510:	af04      	add	r7, sp, #16
   12512:	4680      	mov	r8, r0
   12514:	4689      	mov	r9, r1
	if ((buf->len != 6U) && (buf->len != 8U)) {
   12516:	d013      	beq.n	12540 <mod_sub_add+0x3c>
   12518:	2a08      	cmp	r2, #8
   1251a:	d011      	beq.n	12540 <mod_sub_add+0x3c>
		BT_ERR("The message size for the application opcode is incorrect.");
   1251c:	4b45      	ldr	r3, [pc, #276]	; (12634 <mod_sub_add+0x130>)
   1251e:	4846      	ldr	r0, [pc, #280]	; (12638 <mod_sub_add+0x134>)
   12520:	62bb      	str	r3, [r7, #40]	; 0x28
   12522:	f107 0224 	add.w	r2, r7, #36	; 0x24
   12526:	2302      	movs	r3, #2
   12528:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1252c:	617b      	str	r3, [r7, #20]
   1252e:	627b      	str	r3, [r7, #36]	; 0x24
   12530:	f017 fe7a 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   12534:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   12538:	3734      	adds	r7, #52	; 0x34
   1253a:	46bd      	mov	sp, r7
   1253c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   12540:	4658      	mov	r0, fp
   12542:	f019 fc83 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12546:	b202      	sxth	r2, r0
   12548:	2a00      	cmp	r2, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   1254a:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1254c:	dc0e      	bgt.n	1256c <mod_sub_add+0x68>
		BT_WARN("Prohibited element address");
   1254e:	4b3b      	ldr	r3, [pc, #236]	; (1263c <mod_sub_add+0x138>)
   12550:	4839      	ldr	r0, [pc, #228]	; (12638 <mod_sub_add+0x134>)
   12552:	62bb      	str	r3, [r7, #40]	; 0x28
   12554:	f107 0224 	add.w	r2, r7, #36	; 0x24
   12558:	2302      	movs	r3, #2
   1255a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1255e:	617b      	str	r3, [r7, #20]
   12560:	627b      	str	r3, [r7, #36]	; 0x24
   12562:	f017 fe61 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12566:	f06f 0015 	mvn.w	r0, #21
   1256a:	e7e5      	b.n	12538 <mod_sub_add+0x34>
	sub_addr = net_buf_simple_pull_le16(buf);
   1256c:	4658      	mov	r0, fp
   1256e:	f019 fc6d 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("elem_addr 0x%04x, sub_addr 0x%04x", elem_addr, sub_addr);
   12572:	46ea      	mov	sl, sp
   12574:	b088      	sub	sp, #32
   12576:	aa04      	add	r2, sp, #16
   12578:	4b31      	ldr	r3, [pc, #196]	; (12640 <mod_sub_add+0x13c>)
   1257a:	4932      	ldr	r1, [pc, #200]	; (12644 <mod_sub_add+0x140>)
   1257c:	6111      	str	r1, [r2, #16]
   1257e:	2405      	movs	r4, #5
   12580:	e9c2 3605 	strd	r3, r6, [r2, #20]
   12584:	61d0      	str	r0, [r2, #28]
	sub_addr = net_buf_simple_pull_le16(buf);
   12586:	4605      	mov	r5, r0
	BT_DBG("elem_addr 0x%04x, sub_addr 0x%04x", elem_addr, sub_addr);
   12588:	f842 4f0c 	str.w	r4, [r2, #12]!
   1258c:	482a      	ldr	r0, [pc, #168]	; (12638 <mod_sub_add+0x134>)
   1258e:	61bc      	str	r4, [r7, #24]
   12590:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12594:	f017 fe48 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12598:	4630      	mov	r0, r6
	mod_id = buf->data;
   1259a:	f8db 3000 	ldr.w	r3, [fp]
   1259e:	607b      	str	r3, [r7, #4]
   125a0:	46d5      	mov	sp, sl
	elem = bt_mesh_elem_find(elem_addr);
   125a2:	f7fe fc65 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   125a6:	b940      	cbnz	r0, 125ba <mod_sub_add+0xb6>
		vnd = (buf->len == 4U);
   125a8:	f8bb 3004 	ldrh.w	r3, [fp, #4]
		mod = NULL;
   125ac:	6138      	str	r0, [r7, #16]
		vnd = (buf->len == 4U);
   125ae:	1f1a      	subs	r2, r3, #4
   125b0:	4253      	negs	r3, r2
   125b2:	4153      	adcs	r3, r2
   125b4:	73fb      	strb	r3, [r7, #15]
		status = STATUS_INVALID_ADDRESS;
   125b6:	2201      	movs	r2, #1
   125b8:	e021      	b.n	125fe <mod_sub_add+0xfa>
	mod = get_model(elem, buf, &vnd);
   125ba:	f107 020f 	add.w	r2, r7, #15
   125be:	4659      	mov	r1, fp
   125c0:	f7ff fab0 	bl	11b24 <get_model>
   125c4:	6138      	str	r0, [r7, #16]
	if (!mod) {
   125c6:	b380      	cbz	r0, 1262a <mod_sub_add+0x126>
	if (!BT_MESH_ADDR_IS_GROUP(sub_addr)) {
   125c8:	f505 4380 	add.w	r3, r5, #16384	; 0x4000
   125cc:	b29b      	uxth	r3, r3
   125ce:	f5b3 5f7c 	cmp.w	r3, #16128	; 0x3f00
   125d2:	d8f0      	bhi.n	125b6 <mod_sub_add+0xb2>
	if (bt_mesh_model_find_group(&mod, sub_addr)) {
   125d4:	4629      	mov	r1, r5
   125d6:	f107 0010 	add.w	r0, r7, #16
   125da:	f7fe fcfd 	bl	10fd8 <bt_mesh_model_find_group>
   125de:	b1c8      	cbz	r0, 12614 <mod_sub_add+0x110>
		BT_DBG("found existing subscription");
   125e0:	4b19      	ldr	r3, [pc, #100]	; (12648 <mod_sub_add+0x144>)
   125e2:	62bb      	str	r3, [r7, #40]	; 0x28
   125e4:	4b16      	ldr	r3, [pc, #88]	; (12640 <mod_sub_add+0x13c>)
   125e6:	62fb      	str	r3, [r7, #44]	; 0x2c
   125e8:	4813      	ldr	r0, [pc, #76]	; (12638 <mod_sub_add+0x134>)
   125ea:	2303      	movs	r3, #3
   125ec:	f107 0224 	add.w	r2, r7, #36	; 0x24
   125f0:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   125f4:	617b      	str	r3, [r7, #20]
   125f6:	627b      	str	r3, [r7, #36]	; 0x24
   125f8:	f017 fe16 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		status = STATUS_SUCCESS;
   125fc:	2200      	movs	r2, #0
	return send_mod_sub_status(model, ctx, status, elem_addr, sub_addr,
   125fe:	7bfb      	ldrb	r3, [r7, #15]
   12600:	9302      	str	r3, [sp, #8]
   12602:	687b      	ldr	r3, [r7, #4]
   12604:	4649      	mov	r1, r9
   12606:	e9cd 5300 	strd	r5, r3, [sp]
   1260a:	4640      	mov	r0, r8
   1260c:	4633      	mov	r3, r6
   1260e:	f7ff fa15 	bl	11a3c <send_mod_sub_status>
   12612:	e791      	b.n	12538 <mod_sub_add+0x34>
	entry = bt_mesh_model_find_group(&mod, BT_MESH_ADDR_UNASSIGNED);
   12614:	4601      	mov	r1, r0
   12616:	f107 0010 	add.w	r0, r7, #16
   1261a:	f7fe fcdd 	bl	10fd8 <bt_mesh_model_find_group>
	if (!entry) {
   1261e:	b130      	cbz	r0, 1262e <mod_sub_add+0x12a>
	*entry = sub_addr;
   12620:	8005      	strh	r5, [r0, #0]
		bt_mesh_model_sub_store(mod);
   12622:	6938      	ldr	r0, [r7, #16]
   12624:	f017 fd71 	bl	2a10a <bt_mesh_model_sub_store>
   12628:	e7e8      	b.n	125fc <mod_sub_add+0xf8>
		status = STATUS_INVALID_MODEL;
   1262a:	2202      	movs	r2, #2
   1262c:	e7e7      	b.n	125fe <mod_sub_add+0xfa>
		status = STATUS_INSUFF_RESOURCES;
   1262e:	4622      	mov	r2, r4
   12630:	e7e5      	b.n	125fe <mod_sub_add+0xfa>
   12632:	bf00      	nop
   12634:	00031e3c 	.word	0x00031e3c
   12638:	0002dafc 	.word	0x0002dafc
   1263c:	00031ccf 	.word	0x00031ccf
   12640:	000326e1 	.word	0x000326e1
   12644:	00031f20 	.word	0x00031f20
   12648:	00031f46 	.word	0x00031f46

0001264c <mod_pub_va_set>:
{
   1264c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12650:	b095      	sub	sp, #84	; 0x54
	if ((buf->len != 25U) && (buf->len != 27U)) {
   12652:	8893      	ldrh	r3, [r2, #4]
   12654:	f023 0302 	bic.w	r3, r3, #2
   12658:	b29b      	uxth	r3, r3
{
   1265a:	af04      	add	r7, sp, #16
	if ((buf->len != 25U) && (buf->len != 27U)) {
   1265c:	2b19      	cmp	r3, #25
{
   1265e:	e9c7 1001 	strd	r1, r0, [r7, #4]
   12662:	4614      	mov	r4, r2
	if ((buf->len != 25U) && (buf->len != 27U)) {
   12664:	d011      	beq.n	1268a <mod_pub_va_set+0x3e>
		BT_ERR("The message size for the application opcode is incorrect.");
   12666:	4b6f      	ldr	r3, [pc, #444]	; (12824 <mod_pub_va_set+0x1d8>)
   12668:	486f      	ldr	r0, [pc, #444]	; (12828 <mod_pub_va_set+0x1dc>)
   1266a:	63bb      	str	r3, [r7, #56]	; 0x38
   1266c:	f107 0234 	add.w	r2, r7, #52	; 0x34
   12670:	2302      	movs	r3, #2
   12672:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12676:	627b      	str	r3, [r7, #36]	; 0x24
   12678:	637b      	str	r3, [r7, #52]	; 0x34
   1267a:	f017 fdd5 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   1267e:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   12682:	3744      	adds	r7, #68	; 0x44
   12684:	46bd      	mov	sp, r7
   12686:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   1268a:	4610      	mov	r0, r2
   1268c:	f019 fbde 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12690:	b203      	sxth	r3, r0
   12692:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   12694:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12696:	dc0e      	bgt.n	126b6 <mod_pub_va_set+0x6a>
		BT_WARN("Prohibited element address");
   12698:	4b64      	ldr	r3, [pc, #400]	; (1282c <mod_pub_va_set+0x1e0>)
   1269a:	63bb      	str	r3, [r7, #56]	; 0x38
   1269c:	2302      	movs	r3, #2
   1269e:	627b      	str	r3, [r7, #36]	; 0x24
   126a0:	637b      	str	r3, [r7, #52]	; 0x34
   126a2:	f107 0234 	add.w	r2, r7, #52	; 0x34
   126a6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   126aa:	485f      	ldr	r0, [pc, #380]	; (12828 <mod_pub_va_set+0x1dc>)
   126ac:	f017 fdbc 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   126b0:	f06f 0015 	mvn.w	r0, #21
   126b4:	e7e5      	b.n	12682 <mod_pub_va_set+0x36>
	label_uuid = net_buf_simple_pull_mem(buf, 16);
   126b6:	2110      	movs	r1, #16
   126b8:	4620      	mov	r0, r4
   126ba:	f019 fbb7 	bl	2be2c <net_buf_simple_pull_mem>
   126be:	4681      	mov	r9, r0
	pub_app_idx = net_buf_simple_pull_le16(buf);
   126c0:	4620      	mov	r0, r4
   126c2:	f019 fbc3 	bl	2be4c <net_buf_simple_pull_le16>
	cred_flag = ((pub_app_idx >> 12) & BIT_MASK(1));
   126c6:	f3c0 3300 	ubfx	r3, r0, #12, #1
   126ca:	617b      	str	r3, [r7, #20]
	pub_app_idx &= BIT_MASK(12);
   126cc:	f3c0 030b 	ubfx	r3, r0, #0, #12
	pub_ttl = net_buf_simple_pull_u8(buf);
   126d0:	4620      	mov	r0, r4
	pub_app_idx &= BIT_MASK(12);
   126d2:	61bb      	str	r3, [r7, #24]
	pub_ttl = net_buf_simple_pull_u8(buf);
   126d4:	f019 fbb2 	bl	2be3c <net_buf_simple_pull_u8>
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   126d8:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
   126dc:	b2db      	uxtb	r3, r3
   126de:	2b7e      	cmp	r3, #126	; 0x7e
	pub_ttl = net_buf_simple_pull_u8(buf);
   126e0:	61f8      	str	r0, [r7, #28]
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   126e2:	d80a      	bhi.n	126fa <mod_pub_va_set+0xae>
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   126e4:	4b52      	ldr	r3, [pc, #328]	; (12830 <mod_pub_va_set+0x1e4>)
   126e6:	63bb      	str	r3, [r7, #56]	; 0x38
   126e8:	2303      	movs	r3, #3
   126ea:	63f8      	str	r0, [r7, #60]	; 0x3c
   126ec:	627b      	str	r3, [r7, #36]	; 0x24
   126ee:	637b      	str	r3, [r7, #52]	; 0x34
   126f0:	f107 0234 	add.w	r2, r7, #52	; 0x34
   126f4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   126f8:	e7d7      	b.n	126aa <mod_pub_va_set+0x5e>
	pub_period = net_buf_simple_pull_u8(buf);
   126fa:	4620      	mov	r0, r4
   126fc:	f019 fb9e 	bl	2be3c <net_buf_simple_pull_u8>
   12700:	6138      	str	r0, [r7, #16]
	retransmit = net_buf_simple_pull_u8(buf);
   12702:	4620      	mov	r0, r4
   12704:	f019 fb9a 	bl	2be3c <net_buf_simple_pull_u8>
	BT_DBG("elem_addr 0x%04x cred_flag %u", elem_addr, cred_flag);
   12708:	46eb      	mov	fp, sp
   1270a:	b088      	sub	sp, #32
   1270c:	aa04      	add	r2, sp, #16
	mod_id = buf->data;
   1270e:	6823      	ldr	r3, [r4, #0]
   12710:	60fb      	str	r3, [r7, #12]
	BT_DBG("elem_addr 0x%04x cred_flag %u", elem_addr, cred_flag);
   12712:	4b48      	ldr	r3, [pc, #288]	; (12834 <mod_pub_va_set+0x1e8>)
   12714:	6113      	str	r3, [r2, #16]
   12716:	4b48      	ldr	r3, [pc, #288]	; (12838 <mod_pub_va_set+0x1ec>)
   12718:	2105      	movs	r1, #5
   1271a:	e9c2 3605 	strd	r3, r6, [r2, #20]
   1271e:	697b      	ldr	r3, [r7, #20]
   12720:	61d3      	str	r3, [r2, #28]
	retransmit = net_buf_simple_pull_u8(buf);
   12722:	4680      	mov	r8, r0
	BT_DBG("elem_addr 0x%04x cred_flag %u", elem_addr, cred_flag);
   12724:	f842 1f0c 	str.w	r1, [r2, #12]!
   12728:	483f      	ldr	r0, [pc, #252]	; (12828 <mod_pub_va_set+0x1dc>)
   1272a:	62b9      	str	r1, [r7, #40]	; 0x28
   1272c:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12730:	f017 fd7a 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	BT_DBG("pub_app_idx 0x%03x, pub_ttl %u pub_period 0x%02x",
   12734:	b082      	sub	sp, #8
   12736:	4b40      	ldr	r3, [pc, #256]	; (12838 <mod_pub_va_set+0x1ec>)
   12738:	9309      	str	r3, [sp, #36]	; 0x24
   1273a:	ad04      	add	r5, sp, #16
   1273c:	69bb      	ldr	r3, [r7, #24]
   1273e:	4a3f      	ldr	r2, [pc, #252]	; (1283c <mod_pub_va_set+0x1f0>)
   12740:	9208      	str	r2, [sp, #32]
   12742:	930a      	str	r3, [sp, #40]	; 0x28
   12744:	462a      	mov	r2, r5
   12746:	69fb      	ldr	r3, [r7, #28]
   12748:	930b      	str	r3, [sp, #44]	; 0x2c
   1274a:	f04f 0a06 	mov.w	sl, #6
   1274e:	693b      	ldr	r3, [r7, #16]
   12750:	930c      	str	r3, [sp, #48]	; 0x30
   12752:	f842 af0c 	str.w	sl, [r2, #12]!
   12756:	4834      	ldr	r0, [pc, #208]	; (12828 <mod_pub_va_set+0x1dc>)
   12758:	603a      	str	r2, [r7, #0]
   1275a:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   1275e:	f8c7 a028 	str.w	sl, [r7, #40]	; 0x28
   12762:	f017 fd61 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	BT_DBG("retransmit 0x%02x (count %u interval %ums)", retransmit,
   12766:	4b34      	ldr	r3, [pc, #208]	; (12838 <mod_pub_va_set+0x1ec>)
   12768:	4935      	ldr	r1, [pc, #212]	; (12840 <mod_pub_va_set+0x1f4>)
   1276a:	6129      	str	r1, [r5, #16]
   1276c:	e9c5 3805 	strd	r3, r8, [r5, #20]
   12770:	f008 0307 	and.w	r3, r8, #7
   12774:	61eb      	str	r3, [r5, #28]
   12776:	ea4f 03d8 	mov.w	r3, r8, lsr #3
   1277a:	3301      	adds	r3, #1
   1277c:	2132      	movs	r1, #50	; 0x32
   1277e:	b2db      	uxtb	r3, r3
   12780:	fb13 f301 	smulbb	r3, r3, r1
   12784:	622b      	str	r3, [r5, #32]
   12786:	683a      	ldr	r2, [r7, #0]
   12788:	4827      	ldr	r0, [pc, #156]	; (12828 <mod_pub_va_set+0x1dc>)
   1278a:	f8c5 a00c 	str.w	sl, [r5, #12]
   1278e:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   12792:	f8c7 a028 	str.w	sl, [r7, #40]	; 0x28
   12796:	f017 fd47 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   1279a:	4630      	mov	r0, r6
   1279c:	46dd      	mov	sp, fp
   1279e:	f7fe fb67 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   127a2:	4605      	mov	r5, r0
   127a4:	b9b0      	cbnz	r0, 127d4 <mod_pub_va_set+0x188>
		vnd = (buf->len == 4U);
   127a6:	88a3      	ldrh	r3, [r4, #4]
		pub_addr = 0U;
   127a8:	8538      	strh	r0, [r7, #40]	; 0x28
		vnd = (buf->len == 4U);
   127aa:	1f1a      	subs	r2, r3, #4
   127ac:	4253      	negs	r3, r2
   127ae:	4153      	adcs	r3, r2
   127b0:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
		status = STATUS_INVALID_ADDRESS;
   127b4:	f04f 0a01 	mov.w	sl, #1
	return send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   127b8:	68fa      	ldr	r2, [r7, #12]
   127ba:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   127bc:	9501      	str	r5, [sp, #4]
   127be:	e9cd a202 	strd	sl, r2, [sp, #8]
   127c2:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
   127c6:	9200      	str	r2, [sp, #0]
   127c8:	e9d7 1001 	ldrd	r1, r0, [r7, #4]
   127cc:	4632      	mov	r2, r6
   127ce:	f7fe fead 	bl	1152c <send_mod_pub_status>
   127d2:	e756      	b.n	12682 <mod_pub_va_set+0x36>
	mod = get_model(elem, buf, &vnd);
   127d4:	f107 0224 	add.w	r2, r7, #36	; 0x24
   127d8:	4621      	mov	r1, r4
   127da:	f7ff f9a3 	bl	11b24 <get_model>
	if (!mod) {
   127de:	4605      	mov	r5, r0
   127e0:	b918      	cbnz	r0, 127ea <mod_pub_va_set+0x19e>
		pub_addr = 0U;
   127e2:	8538      	strh	r0, [r7, #40]	; 0x28
		status = STATUS_INVALID_MODEL;
   127e4:	f04f 0a02 	mov.w	sl, #2
		goto send_status;
   127e8:	e7e6      	b.n	127b8 <mod_pub_va_set+0x16c>
	status = bt_mesh_va_add(label_uuid, &pub_addr);
   127ea:	f107 0128 	add.w	r1, r7, #40	; 0x28
   127ee:	4648      	mov	r0, r9
   127f0:	f7fc faea 	bl	edc8 <bt_mesh_va_add>
   127f4:	4682      	mov	sl, r0
   127f6:	4604      	mov	r4, r0
	if (status != STATUS_SUCCESS) {
   127f8:	2800      	cmp	r0, #0
   127fa:	d1dd      	bne.n	127b8 <mod_pub_va_set+0x16c>
	status = _mod_pub_set(mod, pub_addr, pub_app_idx, cred_flag, pub_ttl,
   127fc:	8d39      	ldrh	r1, [r7, #40]	; 0x28
   127fe:	f8cd 8008 	str.w	r8, [sp, #8]
   12802:	693b      	ldr	r3, [r7, #16]
   12804:	9301      	str	r3, [sp, #4]
   12806:	69fb      	ldr	r3, [r7, #28]
   12808:	9300      	str	r3, [sp, #0]
   1280a:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
   1280e:	4628      	mov	r0, r5
   12810:	f7fe fcee 	bl	111f0 <_mod_pub_set.constprop.0>
	if (status != STATUS_SUCCESS) {
   12814:	4682      	mov	sl, r0
   12816:	2800      	cmp	r0, #0
   12818:	d0ce      	beq.n	127b8 <mod_pub_va_set+0x16c>
		bt_mesh_va_del(label_uuid, NULL);
   1281a:	4621      	mov	r1, r4
   1281c:	4648      	mov	r0, r9
   1281e:	f7fc fb29 	bl	ee74 <bt_mesh_va_del>
   12822:	e7c9      	b.n	127b8 <mod_pub_va_set+0x16c>
   12824:	00031e3c 	.word	0x00031e3c
   12828:	0002dafc 	.word	0x0002dafc
   1282c:	00031ccf 	.word	0x00031ccf
   12830:	00031f66 	.word	0x00031f66
   12834:	00031f7f 	.word	0x00031f7f
   12838:	000326d2 	.word	0x000326d2
   1283c:	00031fa1 	.word	0x00031fa1
   12840:	00031fd6 	.word	0x00031fd6

00012844 <mod_pub_set>:
{
   12844:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12848:	b095      	sub	sp, #84	; 0x54
	if ((buf->len != 11U) && (buf->len != 13U)) {
   1284a:	8893      	ldrh	r3, [r2, #4]
{
   1284c:	af04      	add	r7, sp, #16
	if ((buf->len != 11U) && (buf->len != 13U)) {
   1284e:	2b0b      	cmp	r3, #11
{
   12850:	e9c7 1001 	strd	r1, r0, [r7, #4]
   12854:	4615      	mov	r5, r2
	if ((buf->len != 11U) && (buf->len != 13U)) {
   12856:	d013      	beq.n	12880 <mod_pub_set+0x3c>
   12858:	2b0d      	cmp	r3, #13
   1285a:	d011      	beq.n	12880 <mod_pub_set+0x3c>
		BT_ERR("The message size for the application opcode is incorrect.");
   1285c:	4b64      	ldr	r3, [pc, #400]	; (129f0 <mod_pub_set+0x1ac>)
   1285e:	4865      	ldr	r0, [pc, #404]	; (129f4 <mod_pub_set+0x1b0>)
   12860:	63bb      	str	r3, [r7, #56]	; 0x38
   12862:	f107 0234 	add.w	r2, r7, #52	; 0x34
   12866:	2302      	movs	r3, #2
   12868:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1286c:	627b      	str	r3, [r7, #36]	; 0x24
   1286e:	637b      	str	r3, [r7, #52]	; 0x34
   12870:	f017 fcda 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   12874:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   12878:	3744      	adds	r7, #68	; 0x44
   1287a:	46bd      	mov	sp, r7
   1287c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   12880:	4628      	mov	r0, r5
   12882:	f019 fae3 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12886:	b203      	sxth	r3, r0
   12888:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   1288a:	4606      	mov	r6, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   1288c:	dc0e      	bgt.n	128ac <mod_pub_set+0x68>
		BT_WARN("Prohibited element address");
   1288e:	4b5a      	ldr	r3, [pc, #360]	; (129f8 <mod_pub_set+0x1b4>)
   12890:	63bb      	str	r3, [r7, #56]	; 0x38
   12892:	2302      	movs	r3, #2
   12894:	627b      	str	r3, [r7, #36]	; 0x24
   12896:	637b      	str	r3, [r7, #52]	; 0x34
   12898:	f107 0234 	add.w	r2, r7, #52	; 0x34
   1289c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   128a0:	4854      	ldr	r0, [pc, #336]	; (129f4 <mod_pub_set+0x1b0>)
   128a2:	f017 fcc1 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   128a6:	f06f 0015 	mvn.w	r0, #21
   128aa:	e7e5      	b.n	12878 <mod_pub_set+0x34>
	pub_addr = net_buf_simple_pull_le16(buf);
   128ac:	4628      	mov	r0, r5
   128ae:	f019 facd 	bl	2be4c <net_buf_simple_pull_le16>
   128b2:	4682      	mov	sl, r0
	pub_app_idx = net_buf_simple_pull_le16(buf);
   128b4:	4628      	mov	r0, r5
   128b6:	f019 fac9 	bl	2be4c <net_buf_simple_pull_le16>
	cred_flag = ((pub_app_idx >> 12) & BIT_MASK(1));
   128ba:	f3c0 3300 	ubfx	r3, r0, #12, #1
   128be:	617b      	str	r3, [r7, #20]
	pub_app_idx &= BIT_MASK(12);
   128c0:	f3c0 030b 	ubfx	r3, r0, #0, #12
	pub_ttl = net_buf_simple_pull_u8(buf);
   128c4:	4628      	mov	r0, r5
	pub_app_idx &= BIT_MASK(12);
   128c6:	61bb      	str	r3, [r7, #24]
	pub_ttl = net_buf_simple_pull_u8(buf);
   128c8:	f019 fab8 	bl	2be3c <net_buf_simple_pull_u8>
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   128cc:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
   128d0:	b2db      	uxtb	r3, r3
   128d2:	2b7e      	cmp	r3, #126	; 0x7e
	pub_ttl = net_buf_simple_pull_u8(buf);
   128d4:	61f8      	str	r0, [r7, #28]
	if (pub_ttl > BT_MESH_TTL_MAX && pub_ttl != BT_MESH_TTL_DEFAULT) {
   128d6:	d80a      	bhi.n	128ee <mod_pub_set+0xaa>
		BT_ERR("Invalid TTL value 0x%02x", pub_ttl);
   128d8:	4b48      	ldr	r3, [pc, #288]	; (129fc <mod_pub_set+0x1b8>)
   128da:	63bb      	str	r3, [r7, #56]	; 0x38
   128dc:	2303      	movs	r3, #3
   128de:	63f8      	str	r0, [r7, #60]	; 0x3c
   128e0:	627b      	str	r3, [r7, #36]	; 0x24
   128e2:	637b      	str	r3, [r7, #52]	; 0x34
   128e4:	f107 0234 	add.w	r2, r7, #52	; 0x34
   128e8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   128ec:	e7d8      	b.n	128a0 <mod_pub_set+0x5c>
	pub_period = net_buf_simple_pull_u8(buf);
   128ee:	4628      	mov	r0, r5
   128f0:	f019 faa4 	bl	2be3c <net_buf_simple_pull_u8>
   128f4:	6138      	str	r0, [r7, #16]
	retransmit = net_buf_simple_pull_u8(buf);
   128f6:	4628      	mov	r0, r5
   128f8:	f019 faa0 	bl	2be3c <net_buf_simple_pull_u8>
	BT_DBG("elem_addr 0x%04x pub_addr 0x%04x cred_flag %u",
   128fc:	46eb      	mov	fp, sp
   128fe:	b08a      	sub	sp, #40	; 0x28
	mod_id = buf->data;
   12900:	682b      	ldr	r3, [r5, #0]
   12902:	60fb      	str	r3, [r7, #12]
	BT_DBG("elem_addr 0x%04x pub_addr 0x%04x cred_flag %u",
   12904:	4b3e      	ldr	r3, [pc, #248]	; (12a00 <mod_pub_set+0x1bc>)
   12906:	9308      	str	r3, [sp, #32]
   12908:	ac04      	add	r4, sp, #16
   1290a:	4b3e      	ldr	r3, [pc, #248]	; (12a04 <mod_pub_set+0x1c0>)
   1290c:	f8c4 a01c 	str.w	sl, [r4, #28]
   12910:	4622      	mov	r2, r4
   12912:	f04f 0906 	mov.w	r9, #6
   12916:	e9c4 3605 	strd	r3, r6, [r4, #20]
   1291a:	697b      	ldr	r3, [r7, #20]
   1291c:	6223      	str	r3, [r4, #32]
   1291e:	f842 9f0c 	str.w	r9, [r2, #12]!
	retransmit = net_buf_simple_pull_u8(buf);
   12922:	4680      	mov	r8, r0
	BT_DBG("elem_addr 0x%04x pub_addr 0x%04x cred_flag %u",
   12924:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   12928:	4832      	ldr	r0, [pc, #200]	; (129f4 <mod_pub_set+0x1b0>)
   1292a:	603a      	str	r2, [r7, #0]
   1292c:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
   12930:	f017 fc7a 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	BT_DBG("pub_app_idx 0x%03x, pub_ttl %u pub_period 0x%02x",
   12934:	4b33      	ldr	r3, [pc, #204]	; (12a04 <mod_pub_set+0x1c0>)
   12936:	6163      	str	r3, [r4, #20]
   12938:	69bb      	ldr	r3, [r7, #24]
   1293a:	61a3      	str	r3, [r4, #24]
   1293c:	69fb      	ldr	r3, [r7, #28]
   1293e:	61e3      	str	r3, [r4, #28]
   12940:	4931      	ldr	r1, [pc, #196]	; (12a08 <mod_pub_set+0x1c4>)
   12942:	693b      	ldr	r3, [r7, #16]
   12944:	6121      	str	r1, [r4, #16]
   12946:	6223      	str	r3, [r4, #32]
   12948:	683a      	ldr	r2, [r7, #0]
   1294a:	482a      	ldr	r0, [pc, #168]	; (129f4 <mod_pub_set+0x1b0>)
   1294c:	f8c4 900c 	str.w	r9, [r4, #12]
   12950:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   12954:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
   12958:	f017 fc66 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	BT_DBG("retransmit 0x%02x (count %u interval %ums)", retransmit,
   1295c:	4b29      	ldr	r3, [pc, #164]	; (12a04 <mod_pub_set+0x1c0>)
   1295e:	492b      	ldr	r1, [pc, #172]	; (12a0c <mod_pub_set+0x1c8>)
   12960:	6121      	str	r1, [r4, #16]
   12962:	e9c4 3805 	strd	r3, r8, [r4, #20]
   12966:	f008 0307 	and.w	r3, r8, #7
   1296a:	61e3      	str	r3, [r4, #28]
   1296c:	ea4f 03d8 	mov.w	r3, r8, lsr #3
   12970:	3301      	adds	r3, #1
   12972:	2132      	movs	r1, #50	; 0x32
   12974:	b2db      	uxtb	r3, r3
   12976:	fb13 f301 	smulbb	r3, r3, r1
   1297a:	6223      	str	r3, [r4, #32]
   1297c:	683a      	ldr	r2, [r7, #0]
   1297e:	481d      	ldr	r0, [pc, #116]	; (129f4 <mod_pub_set+0x1b0>)
   12980:	f8c4 900c 	str.w	r9, [r4, #12]
   12984:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   12988:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
   1298c:	f017 fc4c 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12990:	4630      	mov	r0, r6
   12992:	46dd      	mov	sp, fp
   12994:	f7fe fa6c 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   12998:	4604      	mov	r4, r0
   1299a:	b9a0      	cbnz	r0, 129c6 <mod_pub_set+0x182>
		vnd = (buf->len == 4U);
   1299c:	88ab      	ldrh	r3, [r5, #4]
   1299e:	1f1a      	subs	r2, r3, #4
   129a0:	4253      	negs	r3, r2
   129a2:	4153      	adcs	r3, r2
   129a4:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
		status = STATUS_INVALID_ADDRESS;
   129a8:	2001      	movs	r0, #1
	return send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   129aa:	68fb      	ldr	r3, [r7, #12]
   129ac:	9401      	str	r4, [sp, #4]
   129ae:	e9cd 0302 	strd	r0, r3, [sp, #8]
   129b2:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   129b6:	9300      	str	r3, [sp, #0]
   129b8:	e9d7 1001 	ldrd	r1, r0, [r7, #4]
   129bc:	4653      	mov	r3, sl
   129be:	4632      	mov	r2, r6
   129c0:	f7fe fdb4 	bl	1152c <send_mod_pub_status>
   129c4:	e758      	b.n	12878 <mod_pub_set+0x34>
	mod = get_model(elem, buf, &vnd);
   129c6:	f107 0228 	add.w	r2, r7, #40	; 0x28
   129ca:	4629      	mov	r1, r5
   129cc:	f7ff f8aa 	bl	11b24 <get_model>
	if (!mod) {
   129d0:	4604      	mov	r4, r0
   129d2:	b158      	cbz	r0, 129ec <mod_pub_set+0x1a8>
	status = _mod_pub_set(mod, pub_addr, pub_app_idx, cred_flag, pub_ttl,
   129d4:	f8cd 8008 	str.w	r8, [sp, #8]
   129d8:	693b      	ldr	r3, [r7, #16]
   129da:	9301      	str	r3, [sp, #4]
   129dc:	69fb      	ldr	r3, [r7, #28]
   129de:	9300      	str	r3, [sp, #0]
   129e0:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
   129e4:	4651      	mov	r1, sl
   129e6:	f7fe fc03 	bl	111f0 <_mod_pub_set.constprop.0>
   129ea:	e7de      	b.n	129aa <mod_pub_set+0x166>
		status = STATUS_INVALID_MODEL;
   129ec:	2002      	movs	r0, #2
   129ee:	e7dc      	b.n	129aa <mod_pub_set+0x166>
   129f0:	00031e3c 	.word	0x00031e3c
   129f4:	0002dafc 	.word	0x0002dafc
   129f8:	00031ccf 	.word	0x00031ccf
   129fc:	00031f66 	.word	0x00031f66
   12a00:	00032005 	.word	0x00032005
   12a04:	000326c6 	.word	0x000326c6
   12a08:	00031fa1 	.word	0x00031fa1
   12a0c:	00031fd6 	.word	0x00031fd6

00012a10 <mod_pub_get>:
{
   12a10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12a14:	b08d      	sub	sp, #52	; 0x34
	if ((buf->len != 4U) && (buf->len != 6U)) {
   12a16:	f8b2 b004 	ldrh.w	fp, [r2, #4]
   12a1a:	f02b 0b02 	bic.w	fp, fp, #2
   12a1e:	fa1f fb8b 	uxth.w	fp, fp
   12a22:	f1bb 0f04 	cmp.w	fp, #4
{
   12a26:	af04      	add	r7, sp, #16
   12a28:	4606      	mov	r6, r0
   12a2a:	4688      	mov	r8, r1
   12a2c:	4692      	mov	sl, r2
	if ((buf->len != 4U) && (buf->len != 6U)) {
   12a2e:	d011      	beq.n	12a54 <mod_pub_get+0x44>
		BT_ERR("The message size for the application opcode is incorrect.");
   12a30:	4b31      	ldr	r3, [pc, #196]	; (12af8 <mod_pub_get+0xe8>)
   12a32:	4832      	ldr	r0, [pc, #200]	; (12afc <mod_pub_get+0xec>)
   12a34:	61bb      	str	r3, [r7, #24]
   12a36:	f107 0214 	add.w	r2, r7, #20
   12a3a:	2302      	movs	r3, #2
   12a3c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12a40:	607b      	str	r3, [r7, #4]
   12a42:	617b      	str	r3, [r7, #20]
   12a44:	f017 fbf0 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   12a48:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   12a4c:	3724      	adds	r7, #36	; 0x24
   12a4e:	46bd      	mov	sp, r7
   12a50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   12a54:	4610      	mov	r0, r2
   12a56:	f019 f9f9 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12a5a:	b203      	sxth	r3, r0
   12a5c:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   12a5e:	4605      	mov	r5, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   12a60:	dc0e      	bgt.n	12a80 <mod_pub_get+0x70>
		BT_WARN("Prohibited element address");
   12a62:	4b27      	ldr	r3, [pc, #156]	; (12b00 <mod_pub_get+0xf0>)
   12a64:	4825      	ldr	r0, [pc, #148]	; (12afc <mod_pub_get+0xec>)
   12a66:	61bb      	str	r3, [r7, #24]
   12a68:	f107 0214 	add.w	r2, r7, #20
   12a6c:	2302      	movs	r3, #2
   12a6e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   12a72:	607b      	str	r3, [r7, #4]
   12a74:	617b      	str	r3, [r7, #20]
   12a76:	f017 fbd7 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12a7a:	f06f 0015 	mvn.w	r0, #21
   12a7e:	e7e5      	b.n	12a4c <mod_pub_get+0x3c>
	BT_DBG("elem_addr 0x%04x", elem_addr);
   12a80:	466c      	mov	r4, sp
   12a82:	b088      	sub	sp, #32
   12a84:	aa04      	add	r2, sp, #16
   12a86:	4b1f      	ldr	r3, [pc, #124]	; (12b04 <mod_pub_get+0xf4>)
   12a88:	6113      	str	r3, [r2, #16]
   12a8a:	4b1f      	ldr	r3, [pc, #124]	; (12b08 <mod_pub_get+0xf8>)
	mod_id = buf->data;
   12a8c:	f8da 9000 	ldr.w	r9, [sl]
	BT_DBG("elem_addr 0x%04x", elem_addr);
   12a90:	f8c7 b008 	str.w	fp, [r7, #8]
   12a94:	e9c2 3005 	strd	r3, r0, [r2, #20]
   12a98:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   12a9c:	f842 bf0c 	str.w	fp, [r2, #12]!
   12aa0:	4816      	ldr	r0, [pc, #88]	; (12afc <mod_pub_get+0xec>)
   12aa2:	f017 fbc1 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	elem = bt_mesh_elem_find(elem_addr);
   12aa6:	4628      	mov	r0, r5
   12aa8:	46a5      	mov	sp, r4
   12aaa:	f7fe f9e1 	bl	10e70 <bt_mesh_elem_find>
   12aae:	4604      	mov	r4, r0
	if (!elem) {
   12ab0:	b940      	cbnz	r0, 12ac4 <mod_pub_get+0xb4>
		vnd = (buf->len == 4U);
   12ab2:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   12ab6:	1f1a      	subs	r2, r3, #4
   12ab8:	4253      	negs	r3, r2
   12aba:	4153      	adcs	r3, r2
   12abc:	723b      	strb	r3, [r7, #8]
		status = STATUS_INVALID_ADDRESS;
   12abe:	2201      	movs	r2, #1
	uint16_t elem_addr, pub_addr = 0U;
   12ac0:	4623      	mov	r3, r4
   12ac2:	e00a      	b.n	12ada <mod_pub_get+0xca>
	mod = get_model(elem, buf, &vnd);
   12ac4:	f107 0208 	add.w	r2, r7, #8
   12ac8:	4651      	mov	r1, sl
   12aca:	f7ff f82b 	bl	11b24 <get_model>
	if (!mod) {
   12ace:	4604      	mov	r4, r0
   12ad0:	b170      	cbz	r0, 12af0 <mod_pub_get+0xe0>
	if (!mod->pub) {
   12ad2:	6883      	ldr	r3, [r0, #8]
   12ad4:	b173      	cbz	r3, 12af4 <mod_pub_get+0xe4>
	pub_addr = mod->pub->addr;
   12ad6:	889b      	ldrh	r3, [r3, #4]
	status = STATUS_SUCCESS;
   12ad8:	2200      	movs	r2, #0
	return send_mod_pub_status(model, ctx, elem_addr, pub_addr, vnd, mod,
   12ada:	e9cd 2902 	strd	r2, r9, [sp, #8]
   12ade:	9401      	str	r4, [sp, #4]
   12ae0:	7a3a      	ldrb	r2, [r7, #8]
   12ae2:	9200      	str	r2, [sp, #0]
   12ae4:	4641      	mov	r1, r8
   12ae6:	462a      	mov	r2, r5
   12ae8:	4630      	mov	r0, r6
   12aea:	f7fe fd1f 	bl	1152c <send_mod_pub_status>
   12aee:	e7ad      	b.n	12a4c <mod_pub_get+0x3c>
		status = STATUS_INVALID_MODEL;
   12af0:	2202      	movs	r2, #2
   12af2:	e7e5      	b.n	12ac0 <mod_pub_get+0xb0>
		status = STATUS_NVAL_PUB_PARAM;
   12af4:	2207      	movs	r2, #7
   12af6:	e7f0      	b.n	12ada <mod_pub_get+0xca>
   12af8:	00031e3c 	.word	0x00031e3c
   12afc:	0002dafc 	.word	0x0002dafc
   12b00:	00031ccf 	.word	0x00031ccf
   12b04:	00031e76 	.word	0x00031e76
   12b08:	000326ba 	.word	0x000326ba

00012b0c <reset_send_start>:

static void reset_send_start(uint16_t duration, int err, void *cb_data)
{
   12b0c:	b500      	push	{lr}
   12b0e:	b089      	sub	sp, #36	; 0x24
	if (err) {
   12b10:	b181      	cbz	r1, 12b34 <reset_send_start+0x28>
		BT_ERR("Sending Node Reset Status failed (err %d)", err);
   12b12:	4b0a      	ldr	r3, [pc, #40]	; (12b3c <reset_send_start+0x30>)
   12b14:	480a      	ldr	r0, [pc, #40]	; (12b40 <reset_send_start+0x34>)
   12b16:	e9cd 3106 	strd	r3, r1, [sp, #24]
   12b1a:	aa05      	add	r2, sp, #20
   12b1c:	2303      	movs	r3, #3
   12b1e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   12b22:	9301      	str	r3, [sp, #4]
   12b24:	9305      	str	r3, [sp, #20]
   12b26:	f017 fb7f 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		bt_mesh_reset();
	}
}
   12b2a:	b009      	add	sp, #36	; 0x24
   12b2c:	f85d eb04 	ldr.w	lr, [sp], #4
		bt_mesh_reset();
   12b30:	f7f8 bf04 	b.w	b93c <bt_mesh_reset>
}
   12b34:	b009      	add	sp, #36	; 0x24
   12b36:	f85d fb04 	ldr.w	pc, [sp], #4
   12b3a:	bf00      	nop
   12b3c:	00032037 	.word	0x00032037
   12b40:	0002dafc 	.word	0x0002dafc

00012b44 <send_friend_status>:
	return 0;
}

static int send_friend_status(struct bt_mesh_model *model,
			      struct bt_mesh_msg_ctx *ctx)
{
   12b44:	b530      	push	{r4, r5, lr}
   12b46:	b08f      	sub	sp, #60	; 0x3c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_FRIEND_STATUS, 1);
   12b48:	ab03      	add	r3, sp, #12
   12b4a:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   12b4e:	4604      	mov	r4, r0
   12b50:	460d      	mov	r5, r1

	bt_mesh_model_msg_init(&msg, OP_FRIEND_STATUS);
   12b52:	a805      	add	r0, sp, #20
   12b54:	f248 0111 	movw	r1, #32785	; 0x8011
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_FRIEND_STATUS, 1);
   12b58:	e9cd 2306 	strd	r2, r3, [sp, #24]
   12b5c:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_FRIEND_STATUS);
   12b5e:	f017 fae2 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_friend_get());
   12b62:	f7f9 f8c9 	bl	bcf8 <bt_mesh_friend_get>
   12b66:	4601      	mov	r1, r0
   12b68:	a805      	add	r0, sp, #20
   12b6a:	f019 f8f6 	bl	2bd5a <net_buf_simple_add_u8>

	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12b6e:	2300      	movs	r3, #0
   12b70:	9300      	str	r3, [sp, #0]
   12b72:	aa05      	add	r2, sp, #20
   12b74:	4629      	mov	r1, r5
   12b76:	4620      	mov	r0, r4
   12b78:	f7fe f9fc 	bl	10f74 <bt_mesh_model_send>
   12b7c:	b150      	cbz	r0, 12b94 <send_friend_status+0x50>
		BT_ERR("Unable to send Friend Status");
   12b7e:	4b07      	ldr	r3, [pc, #28]	; (12b9c <send_friend_status+0x58>)
   12b80:	930c      	str	r3, [sp, #48]	; 0x30
   12b82:	4807      	ldr	r0, [pc, #28]	; (12ba0 <send_friend_status+0x5c>)
   12b84:	2302      	movs	r3, #2
   12b86:	aa0b      	add	r2, sp, #44	; 0x2c
   12b88:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12b8c:	9302      	str	r3, [sp, #8]
   12b8e:	930b      	str	r3, [sp, #44]	; 0x2c
   12b90:	f017 fb4a 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	}

	return 0;
}
   12b94:	2000      	movs	r0, #0
   12b96:	b00f      	add	sp, #60	; 0x3c
   12b98:	bd30      	pop	{r4, r5, pc}
   12b9a:	bf00      	nop
   12b9c:	00032061 	.word	0x00032061
   12ba0:	0002dafc 	.word	0x0002dafc

00012ba4 <lpn_timeout_get>:
}

static int lpn_timeout_get(struct bt_mesh_model *model,
			   struct bt_mesh_msg_ctx *ctx,
			   struct net_buf_simple *buf)
{
   12ba4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12ba8:	b090      	sub	sp, #64	; 0x40
   12baa:	af02      	add	r7, sp, #8
   12bac:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_LPN_TIMEOUT_STATUS, 5);
   12bae:	f107 0308 	add.w	r3, r7, #8
   12bb2:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
{
   12bb6:	4605      	mov	r5, r0
	struct bt_mesh_friend *frnd;
	int32_t timeout_steps;
	uint16_t lpn_addr;

	lpn_addr = net_buf_simple_pull_le16(buf);
   12bb8:	4610      	mov	r0, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_LPN_TIMEOUT_STATUS, 5);
   12bba:	e9c7 1306 	strd	r1, r3, [r7, #24]
   12bbe:	617b      	str	r3, [r7, #20]

	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x lpn_addr 0x%02x",
   12bc0:	46e8      	mov	r8, sp
	lpn_addr = net_buf_simple_pull_le16(buf);
   12bc2:	f019 f943 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x lpn_addr 0x%02x",
   12bc6:	b08a      	sub	sp, #40	; 0x28
   12bc8:	aa02      	add	r2, sp, #8
   12bca:	8861      	ldrh	r1, [r4, #2]
   12bcc:	88a3      	ldrh	r3, [r4, #4]
   12bce:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 12c94 <lpn_timeout_get+0xf0>
   12bd2:	f8c2 c010 	str.w	ip, [r2, #16]
	lpn_addr = net_buf_simple_pull_le16(buf);
   12bd6:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x lpn_addr 0x%02x",
   12bd8:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 12c98 <lpn_timeout_get+0xf4>
   12bdc:	8820      	ldrh	r0, [r4, #0]
   12bde:	6256      	str	r6, [r2, #36]	; 0x24
   12be0:	e9c2 1307 	strd	r1, r3, [r2, #28]
   12be4:	2307      	movs	r3, #7
   12be6:	e9c2 c005 	strd	ip, r0, [r2, #20]
   12bea:	f44f 5164 	mov.w	r1, #14592	; 0x3900
   12bee:	f842 3f0c 	str.w	r3, [r2, #12]!
   12bf2:	482a      	ldr	r0, [pc, #168]	; (12c9c <lpn_timeout_get+0xf8>)
   12bf4:	623b      	str	r3, [r7, #32]
   12bf6:	f017 fb17 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	       ctx->net_idx, ctx->app_idx, ctx->addr, lpn_addr);

	if (!BT_MESH_ADDR_IS_UNICAST(lpn_addr)) {
   12bfa:	b233      	sxth	r3, r6
   12bfc:	2b00      	cmp	r3, #0
   12bfe:	46c5      	mov	sp, r8
   12c00:	dc11      	bgt.n	12c26 <lpn_timeout_get+0x82>
		BT_WARN("Invalid LPNAddress; ignoring msg");
   12c02:	4b27      	ldr	r3, [pc, #156]	; (12ca0 <lpn_timeout_get+0xfc>)
   12c04:	4825      	ldr	r0, [pc, #148]	; (12c9c <lpn_timeout_get+0xf8>)
   12c06:	633b      	str	r3, [r7, #48]	; 0x30
   12c08:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   12c0c:	2302      	movs	r3, #2
   12c0e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   12c12:	607b      	str	r3, [r7, #4]
   12c14:	62fb      	str	r3, [r7, #44]	; 0x2c
   12c16:	f017 fb07 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12c1a:	f06f 0015 	mvn.w	r0, #21
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
		BT_ERR("Unable to send LPN PollTimeout Status");
	}

	return 0;
}
   12c1e:	3738      	adds	r7, #56	; 0x38
   12c20:	46bd      	mov	sp, r7
   12c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_mesh_model_msg_init(&msg, OP_LPN_TIMEOUT_STATUS);
   12c26:	f248 012e 	movw	r1, #32814	; 0x802e
   12c2a:	f107 0014 	add.w	r0, r7, #20
   12c2e:	f017 fa7a 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_le16(&msg, lpn_addr);
   12c32:	4631      	mov	r1, r6
   12c34:	f107 0014 	add.w	r0, r7, #20
   12c38:	f019 f897 	bl	2bd6a <net_buf_simple_add_le16>
	frnd = bt_mesh_friend_find(BT_MESH_KEY_ANY, lpn_addr, true, true);
   12c3c:	2301      	movs	r3, #1
   12c3e:	461a      	mov	r2, r3
   12c40:	4631      	mov	r1, r6
   12c42:	f64f 70ff 	movw	r0, #65535	; 0xffff
   12c46:	f002 ff71 	bl	15b2c <bt_mesh_friend_find>
	if (!frnd) {
   12c4a:	b300      	cbz	r0, 12c8e <lpn_timeout_get+0xea>
	timeout_steps = frnd->poll_to / 100;
   12c4c:	6841      	ldr	r1, [r0, #4]
   12c4e:	2064      	movs	r0, #100	; 0x64
   12c50:	fb91 f1f0 	sdiv	r1, r1, r0
	net_buf_simple_add_le24(&msg, timeout_steps);
   12c54:	f107 0014 	add.w	r0, r7, #20
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12c58:	2600      	movs	r6, #0
	net_buf_simple_add_le24(&msg, timeout_steps);
   12c5a:	f019 f89a 	bl	2bd92 <net_buf_simple_add_le24>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12c5e:	9600      	str	r6, [sp, #0]
   12c60:	4633      	mov	r3, r6
   12c62:	f107 0214 	add.w	r2, r7, #20
   12c66:	4621      	mov	r1, r4
   12c68:	4628      	mov	r0, r5
   12c6a:	f7fe f983 	bl	10f74 <bt_mesh_model_send>
   12c6e:	2800      	cmp	r0, #0
   12c70:	d0d5      	beq.n	12c1e <lpn_timeout_get+0x7a>
		BT_ERR("Unable to send LPN PollTimeout Status");
   12c72:	4b0c      	ldr	r3, [pc, #48]	; (12ca4 <lpn_timeout_get+0x100>)
   12c74:	4809      	ldr	r0, [pc, #36]	; (12c9c <lpn_timeout_get+0xf8>)
   12c76:	633b      	str	r3, [r7, #48]	; 0x30
   12c78:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   12c7c:	2302      	movs	r3, #2
   12c7e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12c82:	607b      	str	r3, [r7, #4]
   12c84:	62fb      	str	r3, [r7, #44]	; 0x2c
   12c86:	f017 facf 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   12c8a:	4630      	mov	r0, r6
   12c8c:	e7c7      	b.n	12c1e <lpn_timeout_get+0x7a>
		timeout_steps = 0;
   12c8e:	4601      	mov	r1, r0
   12c90:	e7e0      	b.n	12c54 <lpn_timeout_get+0xb0>
   12c92:	bf00      	nop
   12c94:	0003207e 	.word	0x0003207e
   12c98:	00032852 	.word	0x00032852
   12c9c:	0002dafc 	.word	0x0002dafc
   12ca0:	000320bb 	.word	0x000320bb
   12ca4:	000320dc 	.word	0x000320dc

00012ca8 <send_app_key_status>:
{
   12ca8:	b5f0      	push	{r4, r5, r6, r7, lr}
   12caa:	b091      	sub	sp, #68	; 0x44
   12cac:	4604      	mov	r4, r0
   12cae:	460d      	mov	r5, r1
   12cb0:	4617      	mov	r7, r2
   12cb2:	461e      	mov	r6, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   12cb4:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   12cb8:	ab04      	add	r3, sp, #16
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_STATUS);
   12cba:	f248 0103 	movw	r1, #32771	; 0x8003
   12cbe:	a807      	add	r0, sp, #28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_APP_KEY_STATUS, 4);
   12cc0:	e9cd 2308 	strd	r2, r3, [sp, #32]
   12cc4:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&msg, OP_APP_KEY_STATUS);
   12cc6:	f017 fa2e 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   12cca:	4639      	mov	r1, r7
   12ccc:	a807      	add	r0, sp, #28
   12cce:	f019 f844 	bl	2bd5a <net_buf_simple_add_u8>
	key_idx_pack(&msg, net_idx, app_idx);
   12cd2:	f8bd 1058 	ldrh.w	r1, [sp, #88]	; 0x58
   12cd6:	4632      	mov	r2, r6
   12cd8:	a807      	add	r0, sp, #28
   12cda:	f017 fa4d 	bl	2a178 <key_idx_pack>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12cde:	2300      	movs	r3, #0
   12ce0:	9300      	str	r3, [sp, #0]
   12ce2:	aa07      	add	r2, sp, #28
   12ce4:	4629      	mov	r1, r5
   12ce6:	4620      	mov	r0, r4
   12ce8:	f7fe f944 	bl	10f74 <bt_mesh_model_send>
   12cec:	b150      	cbz	r0, 12d04 <send_app_key_status+0x5c>
		BT_ERR("Unable to send App Key Status response");
   12cee:	4b07      	ldr	r3, [pc, #28]	; (12d0c <send_app_key_status+0x64>)
   12cf0:	930e      	str	r3, [sp, #56]	; 0x38
   12cf2:	4807      	ldr	r0, [pc, #28]	; (12d10 <send_app_key_status+0x68>)
   12cf4:	2302      	movs	r3, #2
   12cf6:	aa0d      	add	r2, sp, #52	; 0x34
   12cf8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12cfc:	9303      	str	r3, [sp, #12]
   12cfe:	930d      	str	r3, [sp, #52]	; 0x34
   12d00:	f017 fa92 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   12d04:	2000      	movs	r0, #0
   12d06:	b011      	add	sp, #68	; 0x44
   12d08:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12d0a:	bf00      	nop
   12d0c:	00032102 	.word	0x00032102
   12d10:	0002dafc 	.word	0x0002dafc

00012d14 <app_key_del>:
{
   12d14:	b5f0      	push	{r4, r5, r6, r7, lr}
   12d16:	b085      	sub	sp, #20
   12d18:	af02      	add	r7, sp, #8
   12d1a:	4604      	mov	r4, r0
   12d1c:	460d      	mov	r5, r1
   12d1e:	4610      	mov	r0, r2
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12d20:	4639      	mov	r1, r7
   12d22:	1cba      	adds	r2, r7, #2
   12d24:	f017 fa39 	bl	2a19a <key_idx_unpack>
	BT_DBG("AppIdx 0x%04x NetIdx 0x%04x", key_app_idx, key_net_idx);
   12d28:	466e      	mov	r6, sp
   12d2a:	b088      	sub	sp, #32
   12d2c:	aa02      	add	r2, sp, #8
   12d2e:	4810      	ldr	r0, [pc, #64]	; (12d70 <app_key_del+0x5c>)
   12d30:	6110      	str	r0, [r2, #16]
   12d32:	8879      	ldrh	r1, [r7, #2]
   12d34:	883b      	ldrh	r3, [r7, #0]
   12d36:	480f      	ldr	r0, [pc, #60]	; (12d74 <app_key_del+0x60>)
   12d38:	61d3      	str	r3, [r2, #28]
   12d3a:	2305      	movs	r3, #5
   12d3c:	e9c2 0105 	strd	r0, r1, [r2, #20]
   12d40:	f842 3f0c 	str.w	r3, [r2, #12]!
   12d44:	480c      	ldr	r0, [pc, #48]	; (12d78 <app_key_del+0x64>)
   12d46:	607b      	str	r3, [r7, #4]
   12d48:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12d4c:	f017 fa6c 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   12d50:	46b5      	mov	sp, r6
	status = bt_mesh_app_key_del(key_app_idx, key_net_idx);
   12d52:	8839      	ldrh	r1, [r7, #0]
   12d54:	8878      	ldrh	r0, [r7, #2]
   12d56:	f016 fd90 	bl	2987a <bt_mesh_app_key_del>
	return send_app_key_status(model, ctx, status, key_app_idx, key_net_idx);
   12d5a:	8839      	ldrh	r1, [r7, #0]
   12d5c:	887b      	ldrh	r3, [r7, #2]
   12d5e:	9100      	str	r1, [sp, #0]
	status = bt_mesh_app_key_del(key_app_idx, key_net_idx);
   12d60:	4602      	mov	r2, r0
	return send_app_key_status(model, ctx, status, key_app_idx, key_net_idx);
   12d62:	4629      	mov	r1, r5
   12d64:	4620      	mov	r0, r4
   12d66:	f7ff ff9f 	bl	12ca8 <send_app_key_status>
}
   12d6a:	370c      	adds	r7, #12
   12d6c:	46bd      	mov	sp, r7
   12d6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12d70:	00032129 	.word	0x00032129
   12d74:	000327ae 	.word	0x000327ae
   12d78:	0002dafc 	.word	0x0002dafc

00012d7c <app_key_update>:
{
   12d7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12d80:	b084      	sub	sp, #16
   12d82:	4614      	mov	r4, r2
   12d84:	af02      	add	r7, sp, #8
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12d86:	1cba      	adds	r2, r7, #2
{
   12d88:	4605      	mov	r5, r0
   12d8a:	460e      	mov	r6, r1
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12d8c:	4620      	mov	r0, r4
   12d8e:	4639      	mov	r1, r7
   12d90:	f017 fa03 	bl	2a19a <key_idx_unpack>
	BT_DBG("AppIdx 0x%04x NetIdx 0x%04x", key_app_idx, key_net_idx);
   12d94:	46e8      	mov	r8, sp
   12d96:	b088      	sub	sp, #32
   12d98:	aa02      	add	r2, sp, #8
   12d9a:	8879      	ldrh	r1, [r7, #2]
   12d9c:	883b      	ldrh	r3, [r7, #0]
   12d9e:	f8df 9068 	ldr.w	r9, [pc, #104]	; 12e08 <app_key_update+0x8c>
   12da2:	f8df a068 	ldr.w	sl, [pc, #104]	; 12e0c <app_key_update+0x90>
   12da6:	61d3      	str	r3, [r2, #28]
   12da8:	4819      	ldr	r0, [pc, #100]	; (12e10 <app_key_update+0x94>)
   12daa:	6110      	str	r0, [r2, #16]
   12dac:	2305      	movs	r3, #5
   12dae:	e9c2 9105 	strd	r9, r1, [r2, #20]
   12db2:	4650      	mov	r0, sl
   12db4:	f842 3f0c 	str.w	r3, [r2, #12]!
   12db8:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12dbc:	607b      	str	r3, [r7, #4]
   12dbe:	f017 fa33 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   12dc2:	46c5      	mov	sp, r8
	status = bt_mesh_app_key_update(key_app_idx, key_net_idx, buf->data);
   12dc4:	6822      	ldr	r2, [r4, #0]
   12dc6:	8839      	ldrh	r1, [r7, #0]
   12dc8:	8878      	ldrh	r0, [r7, #2]
   12dca:	f016 fd15 	bl	297f8 <bt_mesh_app_key_update>
	BT_DBG("status 0x%02x", status);
   12dce:	b088      	sub	sp, #32
   12dd0:	4b10      	ldr	r3, [pc, #64]	; (12e14 <app_key_update+0x98>)
   12dd2:	9008      	str	r0, [sp, #32]
   12dd4:	aa02      	add	r2, sp, #8
   12dd6:	e9c2 3904 	strd	r3, r9, [r2, #16]
   12dda:	2304      	movs	r3, #4
   12ddc:	f842 3f0c 	str.w	r3, [r2, #12]!
	status = bt_mesh_app_key_update(key_app_idx, key_net_idx, buf->data);
   12de0:	4604      	mov	r4, r0
	BT_DBG("status 0x%02x", status);
   12de2:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   12de6:	4650      	mov	r0, sl
   12de8:	607b      	str	r3, [r7, #4]
   12dea:	f017 fa1d 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   12dee:	46c5      	mov	sp, r8
	return send_app_key_status(model, ctx, status, key_app_idx, key_net_idx);
   12df0:	883a      	ldrh	r2, [r7, #0]
   12df2:	887b      	ldrh	r3, [r7, #2]
   12df4:	9200      	str	r2, [sp, #0]
   12df6:	4631      	mov	r1, r6
   12df8:	4622      	mov	r2, r4
   12dfa:	4628      	mov	r0, r5
   12dfc:	f7ff ff54 	bl	12ca8 <send_app_key_status>
}
   12e00:	3708      	adds	r7, #8
   12e02:	46bd      	mov	sp, r7
   12e04:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12e08:	000326fc 	.word	0x000326fc
   12e0c:	0002dafc 	.word	0x0002dafc
   12e10:	00032129 	.word	0x00032129
   12e14:	00031eb9 	.word	0x00031eb9

00012e18 <app_key_add>:
{
   12e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12e1c:	b084      	sub	sp, #16
   12e1e:	4614      	mov	r4, r2
   12e20:	af02      	add	r7, sp, #8
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12e22:	1cba      	adds	r2, r7, #2
{
   12e24:	4605      	mov	r5, r0
   12e26:	460e      	mov	r6, r1
	key_idx_unpack(buf, &key_net_idx, &key_app_idx);
   12e28:	4620      	mov	r0, r4
   12e2a:	4639      	mov	r1, r7
   12e2c:	f017 f9b5 	bl	2a19a <key_idx_unpack>
	BT_DBG("AppIdx 0x%04x NetIdx 0x%04x", key_app_idx, key_net_idx);
   12e30:	46e8      	mov	r8, sp
   12e32:	b088      	sub	sp, #32
   12e34:	aa02      	add	r2, sp, #8
   12e36:	4811      	ldr	r0, [pc, #68]	; (12e7c <app_key_add+0x64>)
   12e38:	8879      	ldrh	r1, [r7, #2]
   12e3a:	883b      	ldrh	r3, [r7, #0]
   12e3c:	6110      	str	r0, [r2, #16]
   12e3e:	4810      	ldr	r0, [pc, #64]	; (12e80 <app_key_add+0x68>)
   12e40:	61d3      	str	r3, [r2, #28]
   12e42:	2305      	movs	r3, #5
   12e44:	e9c2 0105 	strd	r0, r1, [r2, #20]
   12e48:	f842 3f0c 	str.w	r3, [r2, #12]!
   12e4c:	480d      	ldr	r0, [pc, #52]	; (12e84 <app_key_add+0x6c>)
   12e4e:	607b      	str	r3, [r7, #4]
   12e50:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   12e54:	f017 f9e8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   12e58:	46c5      	mov	sp, r8
	status = bt_mesh_app_key_add(key_app_idx, key_net_idx, buf->data);
   12e5a:	6822      	ldr	r2, [r4, #0]
   12e5c:	8839      	ldrh	r1, [r7, #0]
   12e5e:	8878      	ldrh	r0, [r7, #2]
   12e60:	f016 fc8c 	bl	2977c <bt_mesh_app_key_add>
	return send_app_key_status(model, ctx, status, key_app_idx, key_net_idx);
   12e64:	8839      	ldrh	r1, [r7, #0]
   12e66:	887b      	ldrh	r3, [r7, #2]
   12e68:	9100      	str	r1, [sp, #0]
	status = bt_mesh_app_key_add(key_app_idx, key_net_idx, buf->data);
   12e6a:	4602      	mov	r2, r0
	return send_app_key_status(model, ctx, status, key_app_idx, key_net_idx);
   12e6c:	4631      	mov	r1, r6
   12e6e:	4628      	mov	r0, r5
   12e70:	f7ff ff1a 	bl	12ca8 <send_app_key_status>
}
   12e74:	3708      	adds	r7, #8
   12e76:	46bd      	mov	sp, r7
   12e78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12e7c:	00032129 	.word	0x00032129
   12e80:	00032669 	.word	0x00032669
   12e84:	0002dafc 	.word	0x0002dafc

00012e88 <send_net_key_status>:
{
   12e88:	b5f0      	push	{r4, r5, r6, r7, lr}
   12e8a:	b091      	sub	sp, #68	; 0x44
   12e8c:	4604      	mov	r4, r0
   12e8e:	460d      	mov	r5, r1
   12e90:	4616      	mov	r6, r2
   12e92:	461f      	mov	r7, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_STATUS, 3);
   12e94:	f44f 2210 	mov.w	r2, #589824	; 0x90000
   12e98:	ab04      	add	r3, sp, #16
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_STATUS);
   12e9a:	f248 0144 	movw	r1, #32836	; 0x8044
   12e9e:	a807      	add	r0, sp, #28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_KEY_STATUS, 3);
   12ea0:	e9cd 2308 	strd	r2, r3, [sp, #32]
   12ea4:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&msg, OP_NET_KEY_STATUS);
   12ea6:	f017 f93e 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   12eaa:	4639      	mov	r1, r7
   12eac:	a807      	add	r0, sp, #28
   12eae:	f018 ff54 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, idx);
   12eb2:	4631      	mov	r1, r6
   12eb4:	a807      	add	r0, sp, #28
   12eb6:	f018 ff58 	bl	2bd6a <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   12eba:	2300      	movs	r3, #0
   12ebc:	9300      	str	r3, [sp, #0]
   12ebe:	aa07      	add	r2, sp, #28
   12ec0:	4629      	mov	r1, r5
   12ec2:	4620      	mov	r0, r4
   12ec4:	f7fe f856 	bl	10f74 <bt_mesh_model_send>
   12ec8:	b150      	cbz	r0, 12ee0 <send_net_key_status+0x58>
		BT_ERR("Unable to send NetKey Status");
   12eca:	4b07      	ldr	r3, [pc, #28]	; (12ee8 <send_net_key_status+0x60>)
   12ecc:	930e      	str	r3, [sp, #56]	; 0x38
   12ece:	4807      	ldr	r0, [pc, #28]	; (12eec <send_net_key_status+0x64>)
   12ed0:	2302      	movs	r3, #2
   12ed2:	aa0d      	add	r2, sp, #52	; 0x34
   12ed4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   12ed8:	9303      	str	r3, [sp, #12]
   12eda:	930d      	str	r3, [sp, #52]	; 0x34
   12edc:	f017 f9a4 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   12ee0:	2000      	movs	r0, #0
   12ee2:	b011      	add	sp, #68	; 0x44
   12ee4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12ee6:	bf00      	nop
   12ee8:	00032149 	.word	0x00032149
   12eec:	0002dafc 	.word	0x0002dafc

00012ef0 <net_key_del>:
{
   12ef0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12ef4:	b088      	sub	sp, #32
   12ef6:	4606      	mov	r6, r0
   12ef8:	af00      	add	r7, sp, #0
	del_idx = net_buf_simple_pull_le16(buf);
   12efa:	4610      	mov	r0, r2
{
   12efc:	460d      	mov	r5, r1
	del_idx = net_buf_simple_pull_le16(buf);
   12efe:	f018 ffa5 	bl	2be4c <net_buf_simple_pull_le16>
	if (del_idx > 0xfff) {
   12f02:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	del_idx = net_buf_simple_pull_le16(buf);
   12f06:	4604      	mov	r4, r0
	if (del_idx > 0xfff) {
   12f08:	d312      	bcc.n	12f30 <net_key_del+0x40>
		BT_ERR("Invalid NetKeyIndex 0x%04x", del_idx);
   12f0a:	4b1a      	ldr	r3, [pc, #104]	; (12f74 <net_key_del+0x84>)
   12f0c:	f107 0214 	add.w	r2, r7, #20
   12f10:	e9c7 3006 	strd	r3, r0, [r7, #24]
   12f14:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   12f18:	2303      	movs	r3, #3
   12f1a:	4817      	ldr	r0, [pc, #92]	; (12f78 <net_key_del+0x88>)
   12f1c:	607b      	str	r3, [r7, #4]
   12f1e:	617b      	str	r3, [r7, #20]
   12f20:	f017 f982 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   12f24:	f06f 0015 	mvn.w	r0, #21
}
   12f28:	3720      	adds	r7, #32
   12f2a:	46bd      	mov	sp, r7
   12f2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	BT_DBG("idx 0x%04x", del_idx);
   12f30:	46e8      	mov	r8, sp
   12f32:	b088      	sub	sp, #32
   12f34:	466a      	mov	r2, sp
   12f36:	4b11      	ldr	r3, [pc, #68]	; (12f7c <net_key_del+0x8c>)
   12f38:	6113      	str	r3, [r2, #16]
   12f3a:	4b11      	ldr	r3, [pc, #68]	; (12f80 <net_key_del+0x90>)
   12f3c:	e9c2 3005 	strd	r3, r0, [r2, #20]
   12f40:	2304      	movs	r3, #4
   12f42:	f842 3f0c 	str.w	r3, [r2, #12]!
   12f46:	480c      	ldr	r0, [pc, #48]	; (12f78 <net_key_del+0x88>)
   12f48:	60bb      	str	r3, [r7, #8]
   12f4a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   12f4e:	f017 f96b 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	if (ctx->net_idx == del_idx) {
   12f52:	882a      	ldrh	r2, [r5, #0]
   12f54:	42a2      	cmp	r2, r4
   12f56:	46c5      	mov	sp, r8
   12f58:	d105      	bne.n	12f66 <net_key_del+0x76>
		return send_net_key_status(model, ctx, del_idx,
   12f5a:	230c      	movs	r3, #12
	return send_net_key_status(model, ctx, del_idx, STATUS_SUCCESS);
   12f5c:	4629      	mov	r1, r5
   12f5e:	4630      	mov	r0, r6
   12f60:	f7ff ff92 	bl	12e88 <send_net_key_status>
   12f64:	e7e0      	b.n	12f28 <net_key_del+0x38>
	(void)bt_mesh_subnet_del(del_idx);
   12f66:	4620      	mov	r0, r4
   12f68:	f016 fb8e 	bl	29688 <bt_mesh_subnet_del>
	return send_net_key_status(model, ctx, del_idx, STATUS_SUCCESS);
   12f6c:	2300      	movs	r3, #0
   12f6e:	4622      	mov	r2, r4
   12f70:	e7f4      	b.n	12f5c <net_key_del+0x6c>
   12f72:	bf00      	nop
   12f74:	00031bf1 	.word	0x00031bf1
   12f78:	0002dafc 	.word	0x0002dafc
   12f7c:	00031c0c 	.word	0x00031c0c
   12f80:	000327ba 	.word	0x000327ba

00012f84 <net_key_update>:
{
   12f84:	b5f0      	push	{r4, r5, r6, r7, lr}
   12f86:	4606      	mov	r6, r0
   12f88:	b089      	sub	sp, #36	; 0x24
	idx = net_buf_simple_pull_le16(buf);
   12f8a:	4610      	mov	r0, r2
{
   12f8c:	460f      	mov	r7, r1
   12f8e:	4615      	mov	r5, r2
	idx = net_buf_simple_pull_le16(buf);
   12f90:	f018 ff5c 	bl	2be4c <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   12f94:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   12f98:	4604      	mov	r4, r0
	if (idx > 0xfff) {
   12f9a:	d20b      	bcs.n	12fb4 <net_key_update+0x30>
	status = bt_mesh_subnet_update(idx, buf->data);
   12f9c:	6829      	ldr	r1, [r5, #0]
   12f9e:	f016 fb42 	bl	29626 <bt_mesh_subnet_update>
	return send_net_key_status(model, ctx, idx, status);
   12fa2:	4622      	mov	r2, r4
	status = bt_mesh_subnet_update(idx, buf->data);
   12fa4:	4603      	mov	r3, r0
	return send_net_key_status(model, ctx, idx, status);
   12fa6:	4639      	mov	r1, r7
   12fa8:	4630      	mov	r0, r6
}
   12faa:	b009      	add	sp, #36	; 0x24
   12fac:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return send_net_key_status(model, ctx, idx, status);
   12fb0:	f7ff bf6a 	b.w	12e88 <send_net_key_status>
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   12fb4:	4b07      	ldr	r3, [pc, #28]	; (12fd4 <net_key_update+0x50>)
   12fb6:	aa05      	add	r2, sp, #20
   12fb8:	e9cd 3006 	strd	r3, r0, [sp, #24]
   12fbc:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   12fc0:	2303      	movs	r3, #3
   12fc2:	4805      	ldr	r0, [pc, #20]	; (12fd8 <net_key_update+0x54>)
   12fc4:	9301      	str	r3, [sp, #4]
   12fc6:	9305      	str	r3, [sp, #20]
   12fc8:	f017 f92e 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   12fcc:	f06f 0015 	mvn.w	r0, #21
   12fd0:	b009      	add	sp, #36	; 0x24
   12fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12fd4:	00031bf1 	.word	0x00031bf1
   12fd8:	0002dafc 	.word	0x0002dafc

00012fdc <net_key_add>:
{
   12fdc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12fe0:	b089      	sub	sp, #36	; 0x24
   12fe2:	4606      	mov	r6, r0
   12fe4:	af00      	add	r7, sp, #0
	idx = net_buf_simple_pull_le16(buf);
   12fe6:	4610      	mov	r0, r2
{
   12fe8:	4688      	mov	r8, r1
   12fea:	4615      	mov	r5, r2
	idx = net_buf_simple_pull_le16(buf);
   12fec:	f018 ff2e 	bl	2be4c <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   12ff0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   12ff4:	4604      	mov	r4, r0
	if (idx > 0xfff) {
   12ff6:	d312      	bcc.n	1301e <net_key_add+0x42>
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   12ff8:	4b17      	ldr	r3, [pc, #92]	; (13058 <net_key_add+0x7c>)
   12ffa:	f107 0214 	add.w	r2, r7, #20
   12ffe:	e9c7 3006 	strd	r3, r0, [r7, #24]
   13002:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   13006:	2303      	movs	r3, #3
   13008:	4814      	ldr	r0, [pc, #80]	; (1305c <net_key_add+0x80>)
   1300a:	607b      	str	r3, [r7, #4]
   1300c:	617b      	str	r3, [r7, #20]
   1300e:	f017 f90b 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13012:	f06f 0015 	mvn.w	r0, #21
}
   13016:	3724      	adds	r7, #36	; 0x24
   13018:	46bd      	mov	sp, r7
   1301a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	BT_DBG("idx 0x%04x", idx);
   1301e:	46e9      	mov	r9, sp
   13020:	b088      	sub	sp, #32
   13022:	466a      	mov	r2, sp
   13024:	4b0e      	ldr	r3, [pc, #56]	; (13060 <net_key_add+0x84>)
   13026:	6113      	str	r3, [r2, #16]
   13028:	4b0e      	ldr	r3, [pc, #56]	; (13064 <net_key_add+0x88>)
   1302a:	e9c2 3005 	strd	r3, r0, [r2, #20]
   1302e:	2304      	movs	r3, #4
   13030:	f842 3f0c 	str.w	r3, [r2, #12]!
   13034:	4809      	ldr	r0, [pc, #36]	; (1305c <net_key_add+0x80>)
   13036:	60bb      	str	r3, [r7, #8]
   13038:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1303c:	f017 f8f4 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	status = bt_mesh_subnet_add(idx, buf->data);
   13040:	4620      	mov	r0, r4
   13042:	6829      	ldr	r1, [r5, #0]
   13044:	46cd      	mov	sp, r9
   13046:	f016 faa7 	bl	29598 <bt_mesh_subnet_add>
	return send_net_key_status(model, ctx, idx, status);
   1304a:	4622      	mov	r2, r4
	status = bt_mesh_subnet_add(idx, buf->data);
   1304c:	4603      	mov	r3, r0
	return send_net_key_status(model, ctx, idx, status);
   1304e:	4641      	mov	r1, r8
   13050:	4630      	mov	r0, r6
   13052:	f7ff ff19 	bl	12e88 <send_net_key_status>
   13056:	e7de      	b.n	13016 <net_key_add+0x3a>
   13058:	00031bf1 	.word	0x00031bf1
   1305c:	0002dafc 	.word	0x0002dafc
   13060:	00031c0c 	.word	0x00031c0c
   13064:	000327a2 	.word	0x000327a2

00013068 <send_node_id_status>:
{
   13068:	b5f0      	push	{r4, r5, r6, r7, lr}
   1306a:	b091      	sub	sp, #68	; 0x44
   1306c:	4604      	mov	r4, r0
   1306e:	460d      	mov	r5, r1
   13070:	4617      	mov	r7, r2
   13072:	461e      	mov	r6, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   13074:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   13078:	ab04      	add	r3, sp, #16
	bt_mesh_model_msg_init(&msg, OP_NODE_IDENTITY_STATUS);
   1307a:	f248 0148 	movw	r1, #32840	; 0x8048
   1307e:	a807      	add	r0, sp, #28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_IDENTITY_STATUS, 4);
   13080:	e9cd 2308 	strd	r2, r3, [sp, #32]
   13084:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&msg, OP_NODE_IDENTITY_STATUS);
   13086:	f017 f84e 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   1308a:	4639      	mov	r1, r7
   1308c:	a807      	add	r0, sp, #28
   1308e:	f018 fe64 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, net_idx);
   13092:	4631      	mov	r1, r6
   13094:	a807      	add	r0, sp, #28
   13096:	f018 fe68 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, node_id);
   1309a:	f89d 1058 	ldrb.w	r1, [sp, #88]	; 0x58
   1309e:	a807      	add	r0, sp, #28
   130a0:	f018 fe5b 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   130a4:	2300      	movs	r3, #0
   130a6:	9300      	str	r3, [sp, #0]
   130a8:	aa07      	add	r2, sp, #28
   130aa:	4629      	mov	r1, r5
   130ac:	4620      	mov	r0, r4
   130ae:	f7fd ff61 	bl	10f74 <bt_mesh_model_send>
   130b2:	b150      	cbz	r0, 130ca <send_node_id_status+0x62>
		BT_ERR("Unable to send Node Identity Status");
   130b4:	4b06      	ldr	r3, [pc, #24]	; (130d0 <send_node_id_status+0x68>)
   130b6:	930e      	str	r3, [sp, #56]	; 0x38
   130b8:	4806      	ldr	r0, [pc, #24]	; (130d4 <send_node_id_status+0x6c>)
   130ba:	2302      	movs	r3, #2
   130bc:	aa0d      	add	r2, sp, #52	; 0x34
   130be:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   130c2:	9303      	str	r3, [sp, #12]
   130c4:	930d      	str	r3, [sp, #52]	; 0x34
   130c6:	f017 f8af 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   130ca:	2000      	movs	r0, #0
   130cc:	b011      	add	sp, #68	; 0x44
   130ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   130d0:	00032166 	.word	0x00032166
   130d4:	0002dafc 	.word	0x0002dafc

000130d8 <send_krp_status>:

static int send_krp_status(struct bt_mesh_model *model,
			   struct bt_mesh_msg_ctx *ctx, uint16_t idx,
			   uint8_t phase, uint8_t status)
{
   130d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   130da:	b091      	sub	sp, #68	; 0x44
   130dc:	4604      	mov	r4, r0
   130de:	460d      	mov	r5, r1
   130e0:	4617      	mov	r7, r2
   130e2:	461e      	mov	r6, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_KRP_STATUS, 4);
   130e4:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   130e8:	ab04      	add	r3, sp, #16

	bt_mesh_model_msg_init(&msg, OP_KRP_STATUS);
   130ea:	f248 0117 	movw	r1, #32791	; 0x8017
   130ee:	a807      	add	r0, sp, #28
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_KRP_STATUS, 4);
   130f0:	e9cd 2308 	strd	r2, r3, [sp, #32]
   130f4:	9307      	str	r3, [sp, #28]
	bt_mesh_model_msg_init(&msg, OP_KRP_STATUS);
   130f6:	f017 f816 	bl	2a126 <bt_mesh_model_msg_init>

	net_buf_simple_add_u8(&msg, status);
   130fa:	f89d 1058 	ldrb.w	r1, [sp, #88]	; 0x58
   130fe:	a807      	add	r0, sp, #28
   13100:	f018 fe2b 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, idx);
   13104:	4639      	mov	r1, r7
   13106:	a807      	add	r0, sp, #28
   13108:	f018 fe2f 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, phase);
   1310c:	4631      	mov	r1, r6
   1310e:	a807      	add	r0, sp, #28
   13110:	f018 fe23 	bl	2bd5a <net_buf_simple_add_u8>

	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13114:	2300      	movs	r3, #0
   13116:	9300      	str	r3, [sp, #0]
   13118:	aa07      	add	r2, sp, #28
   1311a:	4629      	mov	r1, r5
   1311c:	4620      	mov	r0, r4
   1311e:	f7fd ff29 	bl	10f74 <bt_mesh_model_send>
   13122:	b150      	cbz	r0, 1313a <send_krp_status+0x62>
		BT_ERR("Unable to send Key Refresh State Status");
   13124:	4b06      	ldr	r3, [pc, #24]	; (13140 <send_krp_status+0x68>)
   13126:	930e      	str	r3, [sp, #56]	; 0x38
   13128:	4806      	ldr	r0, [pc, #24]	; (13144 <send_krp_status+0x6c>)
   1312a:	2302      	movs	r3, #2
   1312c:	aa0d      	add	r2, sp, #52	; 0x34
   1312e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13132:	9303      	str	r3, [sp, #12]
   13134:	930d      	str	r3, [sp, #52]	; 0x34
   13136:	f017 f877 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	}

	return 0;
}
   1313a:	2000      	movs	r0, #0
   1313c:	b011      	add	sp, #68	; 0x44
   1313e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13140:	0003218a 	.word	0x0003218a
   13144:	0002dafc 	.word	0x0002dafc

00013148 <krp_set>:
	return send_krp_status(model, ctx, idx, kr_phase, status);
}

static int krp_set(struct bt_mesh_model *model, struct bt_mesh_msg_ctx *ctx,
		   struct net_buf_simple *buf)
{
   13148:	b5f0      	push	{r4, r5, r6, r7, lr}
   1314a:	4606      	mov	r6, r0
   1314c:	b08b      	sub	sp, #44	; 0x2c
	uint8_t phase, status;
	uint16_t idx;

	idx = net_buf_simple_pull_le16(buf);
   1314e:	4610      	mov	r0, r2
{
   13150:	4615      	mov	r5, r2
   13152:	460f      	mov	r7, r1
	idx = net_buf_simple_pull_le16(buf);
   13154:	f018 fe7a 	bl	2be4c <net_buf_simple_pull_le16>
   13158:	4604      	mov	r4, r0
	phase = net_buf_simple_pull_u8(buf);
   1315a:	4628      	mov	r0, r5
   1315c:	f018 fe6e 	bl	2be3c <net_buf_simple_pull_u8>

	if (idx > 0xfff) {
   13160:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
	phase = net_buf_simple_pull_u8(buf);
   13164:	f88d 000b 	strb.w	r0, [sp, #11]
	if (idx > 0xfff) {
   13168:	d30f      	bcc.n	1318a <krp_set+0x42>
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   1316a:	4b12      	ldr	r3, [pc, #72]	; (131b4 <krp_set+0x6c>)
   1316c:	e9cd 3408 	strd	r3, r4, [sp, #32]
		return -EINVAL;
	}

	status = bt_mesh_subnet_kr_phase_set(idx, &phase);
	if (status == STATUS_CANNOT_UPDATE) {
		BT_ERR("Invalid kr phase transition 0x%02x", phase);
   13170:	2303      	movs	r3, #3
   13172:	4811      	ldr	r0, [pc, #68]	; (131b8 <krp_set+0x70>)
   13174:	9303      	str	r3, [sp, #12]
   13176:	aa07      	add	r2, sp, #28
   13178:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   1317c:	9307      	str	r3, [sp, #28]
   1317e:	f017 f853 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13182:	f06f 0015 	mvn.w	r0, #21
	}

	return send_krp_status(model, ctx, idx, phase, status);
}
   13186:	b00b      	add	sp, #44	; 0x2c
   13188:	bdf0      	pop	{r4, r5, r6, r7, pc}
	status = bt_mesh_subnet_kr_phase_set(idx, &phase);
   1318a:	f10d 010b 	add.w	r1, sp, #11
   1318e:	4620      	mov	r0, r4
   13190:	f7fa fbd0 	bl	d934 <bt_mesh_subnet_kr_phase_set>
	if (status == STATUS_CANNOT_UPDATE) {
   13194:	280b      	cmp	r0, #11
   13196:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1319a:	d103      	bne.n	131a4 <krp_set+0x5c>
		BT_ERR("Invalid kr phase transition 0x%02x", phase);
   1319c:	4a07      	ldr	r2, [pc, #28]	; (131bc <krp_set+0x74>)
   1319e:	e9cd 2308 	strd	r2, r3, [sp, #32]
   131a2:	e7e5      	b.n	13170 <krp_set+0x28>
	return send_krp_status(model, ctx, idx, phase, status);
   131a4:	9000      	str	r0, [sp, #0]
   131a6:	4622      	mov	r2, r4
   131a8:	4639      	mov	r1, r7
   131aa:	4630      	mov	r0, r6
   131ac:	f7ff ff94 	bl	130d8 <send_krp_status>
   131b0:	e7e9      	b.n	13186 <krp_set+0x3e>
   131b2:	bf00      	nop
   131b4:	00031bf1 	.word	0x00031bf1
   131b8:	0002dafc 	.word	0x0002dafc
   131bc:	000321b2 	.word	0x000321b2

000131c0 <krp_get>:
{
   131c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   131c4:	b08a      	sub	sp, #40	; 0x28
   131c6:	4605      	mov	r5, r0
   131c8:	af02      	add	r7, sp, #8
	idx = net_buf_simple_pull_le16(buf);
   131ca:	4610      	mov	r0, r2
{
   131cc:	460e      	mov	r6, r1
	idx = net_buf_simple_pull_le16(buf);
   131ce:	f018 fe3d 	bl	2be4c <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   131d2:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   131d6:	4604      	mov	r4, r0
	if (idx > 0xfff) {
   131d8:	d312      	bcc.n	13200 <krp_get+0x40>
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   131da:	4b19      	ldr	r3, [pc, #100]	; (13240 <krp_get+0x80>)
   131dc:	f107 0214 	add.w	r2, r7, #20
   131e0:	e9c7 3006 	strd	r3, r0, [r7, #24]
   131e4:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   131e8:	2303      	movs	r3, #3
   131ea:	4816      	ldr	r0, [pc, #88]	; (13244 <krp_get+0x84>)
   131ec:	607b      	str	r3, [r7, #4]
   131ee:	617b      	str	r3, [r7, #20]
   131f0:	f017 f81a 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   131f4:	f06f 0015 	mvn.w	r0, #21
}
   131f8:	3720      	adds	r7, #32
   131fa:	46bd      	mov	sp, r7
   131fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	BT_DBG("idx 0x%04x", idx);
   13200:	46e8      	mov	r8, sp
   13202:	b088      	sub	sp, #32
   13204:	aa02      	add	r2, sp, #8
   13206:	4b10      	ldr	r3, [pc, #64]	; (13248 <krp_get+0x88>)
   13208:	6113      	str	r3, [r2, #16]
   1320a:	4b10      	ldr	r3, [pc, #64]	; (1324c <krp_get+0x8c>)
   1320c:	e9c2 3005 	strd	r3, r0, [r2, #20]
   13210:	2304      	movs	r3, #4
   13212:	f842 3f0c 	str.w	r3, [r2, #12]!
   13216:	480b      	ldr	r0, [pc, #44]	; (13244 <krp_get+0x84>)
   13218:	60bb      	str	r3, [r7, #8]
   1321a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1321e:	f017 f803 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	status = bt_mesh_subnet_kr_phase_get(idx, &kr_phase);
   13222:	f107 0108 	add.w	r1, r7, #8
   13226:	46c5      	mov	sp, r8
   13228:	4620      	mov	r0, r4
   1322a:	f016 fa37 	bl	2969c <bt_mesh_subnet_kr_phase_get>
	return send_krp_status(model, ctx, idx, kr_phase, status);
   1322e:	7a3b      	ldrb	r3, [r7, #8]
   13230:	9000      	str	r0, [sp, #0]
   13232:	4622      	mov	r2, r4
   13234:	4631      	mov	r1, r6
   13236:	4628      	mov	r0, r5
   13238:	f7ff ff4e 	bl	130d8 <send_krp_status>
   1323c:	e7dc      	b.n	131f8 <krp_get+0x38>
   1323e:	bf00      	nop
   13240:	00031bf1 	.word	0x00031bf1
   13244:	0002dafc 	.word	0x0002dafc
   13248:	00031c0c 	.word	0x00031c0c
   1324c:	00032862 	.word	0x00032862

00013250 <cfg_srv_init>:
	{ OP_HEARTBEAT_SUB_SET,        BT_MESH_LEN_EXACT(5),   heartbeat_sub_set },
	BT_MESH_MODEL_OP_END,
};

static int cfg_srv_init(struct bt_mesh_model *model)
{
   13250:	b500      	push	{lr}
   13252:	4603      	mov	r3, r0
	if (!bt_mesh_model_in_primary(model)) {
   13254:	7900      	ldrb	r0, [r0, #4]
{
   13256:	b089      	sub	sp, #36	; 0x24
	if (!bt_mesh_model_in_primary(model)) {
   13258:	b178      	cbz	r0, 1327a <cfg_srv_init+0x2a>
		BT_ERR("Configuration Server only allowed in primary element");
   1325a:	4b0a      	ldr	r3, [pc, #40]	; (13284 <cfg_srv_init+0x34>)
   1325c:	480a      	ldr	r0, [pc, #40]	; (13288 <cfg_srv_init+0x38>)
   1325e:	9306      	str	r3, [sp, #24]
   13260:	aa05      	add	r2, sp, #20
   13262:	2302      	movs	r3, #2
   13264:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13268:	9301      	str	r3, [sp, #4]
   1326a:	9305      	str	r3, [sp, #20]
   1326c:	f016 ffdc 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13270:	f06f 0015 	mvn.w	r0, #21
	 * device-key is allowed to access this model.
	 */
	model->keys[0] = BT_MESH_KEY_DEV_LOCAL;

	return 0;
}
   13274:	b009      	add	sp, #36	; 0x24
   13276:	f85d fb04 	ldr.w	pc, [sp], #4
	model->keys[0] = BT_MESH_KEY_DEV_LOCAL;
   1327a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
   1327e:	819a      	strh	r2, [r3, #12]
	return 0;
   13280:	e7f8      	b.n	13274 <cfg_srv_init+0x24>
   13282:	bf00      	nop
   13284:	000321d5 	.word	0x000321d5
   13288:	0002dafc 	.word	0x0002dafc

0001328c <mod_app_bind>:
{
   1328c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13290:	b095      	sub	sp, #84	; 0x54
   13292:	4614      	mov	r4, r2
   13294:	af02      	add	r7, sp, #8
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_MOD_APP_STATUS, 9);
   13296:	f107 0320 	add.w	r3, r7, #32
   1329a:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   1329e:	e9c7 2306 	strd	r2, r3, [r7, #24]
   132a2:	617b      	str	r3, [r7, #20]
	if ((buf->len != 6U) && (buf->len != 8U)) {
   132a4:	88a3      	ldrh	r3, [r4, #4]
   132a6:	2b06      	cmp	r3, #6
{
   132a8:	4681      	mov	r9, r0
   132aa:	468a      	mov	sl, r1
	if ((buf->len != 6U) && (buf->len != 8U)) {
   132ac:	d013      	beq.n	132d6 <mod_app_bind+0x4a>
   132ae:	2b08      	cmp	r3, #8
   132b0:	d011      	beq.n	132d6 <mod_app_bind+0x4a>
		BT_ERR("The message size for the application opcode is incorrect.");
   132b2:	4b57      	ldr	r3, [pc, #348]	; (13410 <mod_app_bind+0x184>)
   132b4:	4857      	ldr	r0, [pc, #348]	; (13414 <mod_app_bind+0x188>)
   132b6:	643b      	str	r3, [r7, #64]	; 0x40
   132b8:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   132bc:	2302      	movs	r3, #2
   132be:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   132c2:	613b      	str	r3, [r7, #16]
   132c4:	63fb      	str	r3, [r7, #60]	; 0x3c
   132c6:	f016 ffaf 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EMSGSIZE;
   132ca:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   132ce:	374c      	adds	r7, #76	; 0x4c
   132d0:	46bd      	mov	sp, r7
   132d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	elem_addr = net_buf_simple_pull_le16(buf);
   132d6:	4620      	mov	r0, r4
   132d8:	f018 fdb8 	bl	2be4c <net_buf_simple_pull_le16>
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   132dc:	b203      	sxth	r3, r0
   132de:	2b00      	cmp	r3, #0
	elem_addr = net_buf_simple_pull_le16(buf);
   132e0:	4680      	mov	r8, r0
	if (!BT_MESH_ADDR_IS_UNICAST(elem_addr)) {
   132e2:	dc0e      	bgt.n	13302 <mod_app_bind+0x76>
		BT_WARN("Prohibited element address");
   132e4:	4b4c      	ldr	r3, [pc, #304]	; (13418 <mod_app_bind+0x18c>)
   132e6:	484b      	ldr	r0, [pc, #300]	; (13414 <mod_app_bind+0x188>)
   132e8:	643b      	str	r3, [r7, #64]	; 0x40
   132ea:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   132ee:	2302      	movs	r3, #2
   132f0:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   132f4:	613b      	str	r3, [r7, #16]
   132f6:	63fb      	str	r3, [r7, #60]	; 0x3c
   132f8:	f016 ff96 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   132fc:	f06f 0015 	mvn.w	r0, #21
   13300:	e7e5      	b.n	132ce <mod_app_bind+0x42>
	key_app_idx = net_buf_simple_pull_le16(buf);
   13302:	4620      	mov	r0, r4
   13304:	f018 fda2 	bl	2be4c <net_buf_simple_pull_le16>
	mod_id = buf->data;
   13308:	6823      	ldr	r3, [r4, #0]
   1330a:	607b      	str	r3, [r7, #4]
	key_app_idx = net_buf_simple_pull_le16(buf);
   1330c:	4606      	mov	r6, r0
	elem = bt_mesh_elem_find(elem_addr);
   1330e:	4640      	mov	r0, r8
   13310:	f7fd fdae 	bl	10e70 <bt_mesh_elem_find>
	if (!elem) {
   13314:	2800      	cmp	r0, #0
   13316:	d13a      	bne.n	1338e <mod_app_bind+0x102>
		vnd = (buf->len == 4U);
   13318:	88a3      	ldrh	r3, [r4, #4]
   1331a:	1f1a      	subs	r2, r3, #4
   1331c:	4253      	negs	r3, r2
   1331e:	4153      	adcs	r3, r2
   13320:	73fb      	strb	r3, [r7, #15]
		status = STATUS_INVALID_ADDRESS;
   13322:	2401      	movs	r4, #1
	BT_DBG("status 0x%02x", status);
   13324:	466d      	mov	r5, sp
   13326:	b088      	sub	sp, #32
   13328:	aa02      	add	r2, sp, #8
   1332a:	4b3c      	ldr	r3, [pc, #240]	; (1341c <mod_app_bind+0x190>)
   1332c:	6113      	str	r3, [r2, #16]
   1332e:	4b3c      	ldr	r3, [pc, #240]	; (13420 <mod_app_bind+0x194>)
   13330:	4838      	ldr	r0, [pc, #224]	; (13414 <mod_app_bind+0x188>)
   13332:	e9c2 3405 	strd	r3, r4, [r2, #20]
   13336:	2304      	movs	r3, #4
   13338:	f842 3f0c 	str.w	r3, [r2, #12]!
   1333c:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   13340:	633b      	str	r3, [r7, #48]	; 0x30
   13342:	f016 ff71 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   13346:	687b      	ldr	r3, [r7, #4]
   13348:	7bf9      	ldrb	r1, [r7, #15]
   1334a:	46ad      	mov	sp, r5
   1334c:	e9cd 4300 	strd	r4, r3, [sp]
   13350:	4642      	mov	r2, r8
   13352:	4633      	mov	r3, r6
   13354:	f107 0014 	add.w	r0, r7, #20
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13358:	2400      	movs	r4, #0
	create_mod_app_status(&msg, mod, vnd, elem_addr, key_app_idx, status,
   1335a:	f016 ff3a 	bl	2a1d2 <create_mod_app_status.constprop.0>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1335e:	9400      	str	r4, [sp, #0]
   13360:	4623      	mov	r3, r4
   13362:	f107 0214 	add.w	r2, r7, #20
   13366:	4651      	mov	r1, sl
   13368:	4648      	mov	r0, r9
   1336a:	f7fd fe03 	bl	10f74 <bt_mesh_model_send>
   1336e:	2800      	cmp	r0, #0
   13370:	d0ad      	beq.n	132ce <mod_app_bind+0x42>
		BT_ERR("Unable to send Model App Bind Status response");
   13372:	4b2c      	ldr	r3, [pc, #176]	; (13424 <mod_app_bind+0x198>)
   13374:	4827      	ldr	r0, [pc, #156]	; (13414 <mod_app_bind+0x188>)
   13376:	643b      	str	r3, [r7, #64]	; 0x40
   13378:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   1337c:	2302      	movs	r3, #2
   1337e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13382:	613b      	str	r3, [r7, #16]
   13384:	63fb      	str	r3, [r7, #60]	; 0x3c
   13386:	f016 ff4f 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   1338a:	4620      	mov	r0, r4
   1338c:	e79f      	b.n	132ce <mod_app_bind+0x42>
	mod = get_model(elem, buf, &vnd);
   1338e:	f107 020f 	add.w	r2, r7, #15
   13392:	4621      	mov	r1, r4
   13394:	f7fe fbc6 	bl	11b24 <get_model>
	if (!mod) {
   13398:	4605      	mov	r5, r0
   1339a:	2800      	cmp	r0, #0
   1339c:	d033      	beq.n	13406 <mod_app_bind+0x17a>
	if (model == mod) {
   1339e:	4548      	cmp	r0, r9
   133a0:	d10d      	bne.n	133be <mod_app_bind+0x132>
		BT_ERR("Client tried to bind AppKey to Configuration Model");
   133a2:	4b21      	ldr	r3, [pc, #132]	; (13428 <mod_app_bind+0x19c>)
   133a4:	643b      	str	r3, [r7, #64]	; 0x40
   133a6:	481b      	ldr	r0, [pc, #108]	; (13414 <mod_app_bind+0x188>)
   133a8:	2302      	movs	r3, #2
   133aa:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   133ae:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   133b2:	613b      	str	r3, [r7, #16]
   133b4:	63fb      	str	r3, [r7, #60]	; 0x3c
		status = STATUS_CANNOT_BIND;
   133b6:	240d      	movs	r4, #13
		BT_ERR("Client tried to bind AppKey to Configuration Model");
   133b8:	f016 ff36 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		goto send_status;
   133bc:	e7b2      	b.n	13324 <mod_app_bind+0x98>
	BT_DBG("model %p key_idx 0x%03x", model, key_idx);
   133be:	46eb      	mov	fp, sp
   133c0:	b088      	sub	sp, #32
   133c2:	491a      	ldr	r1, [pc, #104]	; (1342c <mod_app_bind+0x1a0>)
   133c4:	9106      	str	r1, [sp, #24]
   133c6:	aa02      	add	r2, sp, #8
   133c8:	4919      	ldr	r1, [pc, #100]	; (13430 <mod_app_bind+0x1a4>)
   133ca:	61d6      	str	r6, [r2, #28]
   133cc:	2405      	movs	r4, #5
   133ce:	e9c2 1005 	strd	r1, r0, [r2, #20]
   133d2:	4810      	ldr	r0, [pc, #64]	; (13414 <mod_app_bind+0x188>)
   133d4:	f842 4f0c 	str.w	r4, [r2, #12]!
   133d8:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   133dc:	633c      	str	r4, [r7, #48]	; 0x30
   133de:	f016 ff23 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	if (!bt_mesh_app_key_exists(key_idx)) {
   133e2:	4630      	mov	r0, r6
   133e4:	46dd      	mov	sp, fp
   133e6:	f7fa fdd1 	bl	df8c <bt_mesh_app_key_exists>
   133ea:	b170      	cbz	r0, 1340a <mod_app_bind+0x17e>
		if (model->keys[i] == key_idx) {
   133ec:	89ab      	ldrh	r3, [r5, #12]
   133ee:	429e      	cmp	r6, r3
   133f0:	d007      	beq.n	13402 <mod_app_bind+0x176>
		if (model->keys[i] == BT_MESH_KEY_UNUSED) {
   133f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   133f6:	4293      	cmp	r3, r2
   133f8:	d194      	bne.n	13324 <mod_app_bind+0x98>
			model->keys[i] = key_idx;
   133fa:	81ae      	strh	r6, [r5, #12]
				bt_mesh_model_bind_store(model);
   133fc:	4628      	mov	r0, r5
   133fe:	f016 fe7d 	bl	2a0fc <bt_mesh_model_bind_store>
			return STATUS_SUCCESS;
   13402:	2400      	movs	r4, #0
   13404:	e78e      	b.n	13324 <mod_app_bind+0x98>
		status = STATUS_INVALID_MODEL;
   13406:	2402      	movs	r4, #2
   13408:	e78c      	b.n	13324 <mod_app_bind+0x98>
		return STATUS_INVALID_APPKEY;
   1340a:	2403      	movs	r4, #3
   1340c:	e78a      	b.n	13324 <mod_app_bind+0x98>
   1340e:	bf00      	nop
   13410:	00031e3c 	.word	0x00031e3c
   13414:	0002dafc 	.word	0x0002dafc
   13418:	00031ccf 	.word	0x00031ccf
   1341c:	00031eb9 	.word	0x00031eb9
   13420:	000327f3 	.word	0x000327f3
   13424:	00032259 	.word	0x00032259
   13428:	0003220a 	.word	0x0003220a
   1342c:	0003223d 	.word	0x0003223d
   13430:	000327ea 	.word	0x000327ea

00013434 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   13434:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   13436:	ab0a      	add	r3, sp, #40	; 0x28
   13438:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   1343a:	9302      	str	r3, [sp, #8]
   1343c:	4b05      	ldr	r3, [pc, #20]	; (13454 <z_log_msg2_runtime_create.constprop.0+0x20>)
   1343e:	9301      	str	r3, [sp, #4]
   13440:	2300      	movs	r3, #0
   13442:	9300      	str	r3, [sp, #0]
   13444:	2204      	movs	r2, #4
   13446:	4618      	mov	r0, r3
   13448:	f7ef ff2e 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   1344c:	b007      	add	sp, #28
   1344e:	f85d fb04 	ldr.w	pc, [sp], #4
   13452:	bf00      	nop
   13454:	00032287 	.word	0x00032287

00013458 <dev_comp_data_get>:
{
   13458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1345c:	4614      	mov	r4, r2
   1345e:	b09f      	sub	sp, #124	; 0x7c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13460:	88a5      	ldrh	r5, [r4, #4]
   13462:	f8b1 8000 	ldrh.w	r8, [r1]
   13466:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   1346a:	f8b1 b004 	ldrh.w	fp, [r1, #4]
{
   1346e:	af08      	add	r7, sp, #32
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   13470:	f107 0334 	add.w	r3, r7, #52	; 0x34
   13474:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
{
   13478:	4681      	mov	r9, r0
   1347a:	460e      	mov	r6, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   1347c:	6820      	ldr	r0, [r4, #0]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   1347e:	60fb      	str	r3, [r7, #12]
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13480:	4629      	mov	r1, r5
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   13482:	e9c7 2304 	strd	r2, r3, [r7, #16]
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13486:	f7f1 fe67 	bl	5158 <bt_hex_real>
   1348a:	4b6b      	ldr	r3, [pc, #428]	; (13638 <dev_comp_data_get+0x1e0>)
   1348c:	9301      	str	r3, [sp, #4]
   1348e:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13492:	2300      	movs	r3, #0
   13494:	4d69      	ldr	r5, [pc, #420]	; (1363c <dev_comp_data_get+0x1e4>)
   13496:	496a      	ldr	r1, [pc, #424]	; (13640 <dev_comp_data_get+0x1e8>)
   13498:	f8cd 800c 	str.w	r8, [sp, #12]
   1349c:	4618      	mov	r0, r3
   1349e:	e9cd ab04 	strd	sl, fp, [sp, #16]
   134a2:	9502      	str	r5, [sp, #8]
   134a4:	9300      	str	r3, [sp, #0]
   134a6:	2204      	movs	r2, #4
   134a8:	f7ff ffc4 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	page = net_buf_simple_pull_u8(buf);
   134ac:	4620      	mov	r0, r4
   134ae:	f018 fcc5 	bl	2be3c <net_buf_simple_pull_u8>
	if (page != 0U) {
   134b2:	b180      	cbz	r0, 134d6 <dev_comp_data_get+0x7e>
		BT_DBG("Composition page %u not available", page);
   134b4:	466c      	mov	r4, sp
   134b6:	4b63      	ldr	r3, [pc, #396]	; (13644 <dev_comp_data_get+0x1ec>)
   134b8:	61a0      	str	r0, [r4, #24]
   134ba:	4622      	mov	r2, r4
   134bc:	e9c4 3504 	strd	r3, r5, [r4, #16]
   134c0:	2304      	movs	r3, #4
   134c2:	b088      	sub	sp, #32
   134c4:	f842 3f0c 	str.w	r3, [r2, #12]!
   134c8:	485d      	ldr	r0, [pc, #372]	; (13640 <dev_comp_data_get+0x1e8>)
   134ca:	61bb      	str	r3, [r7, #24]
   134cc:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   134d0:	f016 feaa 	bl	2a228 <z_log_msg2_static_create.constprop.0>
   134d4:	46a5      	mov	sp, r4
	bt_mesh_model_msg_init(&sdu, OP_DEV_COMP_DATA_STATUS);
   134d6:	2102      	movs	r1, #2
   134d8:	f107 000c 	add.w	r0, r7, #12
   134dc:	f016 fe23 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&sdu, page);
   134e0:	2100      	movs	r1, #0
   134e2:	f107 000c 	add.w	r0, r7, #12
   134e6:	f018 fc38 	bl	2bd5a <net_buf_simple_add_u8>
	comp = bt_mesh_comp_get();
   134ea:	f7fd fd6f 	bl	10fcc <bt_mesh_comp_get>
   134ee:	4605      	mov	r5, r0
	net_buf_simple_add_le16(buf, comp->cid);
   134f0:	8801      	ldrh	r1, [r0, #0]
   134f2:	f107 000c 	add.w	r0, r7, #12
   134f6:	f018 fc38 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, comp->pid);
   134fa:	8869      	ldrh	r1, [r5, #2]
   134fc:	f107 000c 	add.w	r0, r7, #12
   13500:	f018 fc33 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, comp->vid);
   13504:	88a9      	ldrh	r1, [r5, #4]
   13506:	f107 000c 	add.w	r0, r7, #12
   1350a:	f018 fc2e 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, CONFIG_BT_MESH_CRPL);
   1350e:	210a      	movs	r1, #10
   13510:	f107 000c 	add.w	r0, r7, #12
   13514:	f018 fc29 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(buf, feat);
   13518:	2107      	movs	r1, #7
   1351a:	f107 000c 	add.w	r0, r7, #12
   1351e:	f018 fc24 	bl	2bd6a <net_buf_simple_add_le16>
	for (i = 0; i < comp->elem_count; i++) {
   13522:	f04f 0a00 	mov.w	sl, #0
	    4 + (elem->model_count * 2U) + (elem->vnd_model_count * 4U)) {
   13526:	f04f 0802 	mov.w	r8, #2
		net_buf_simple_add_le16(buf, mod->id);
   1352a:	f04f 0b24 	mov.w	fp, #36	; 0x24
	for (i = 0; i < comp->elem_count; i++) {
   1352e:	68ab      	ldr	r3, [r5, #8]
   13530:	459a      	cmp	sl, r3
   13532:	d318      	bcc.n	13566 <dev_comp_data_get+0x10e>
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   13534:	2400      	movs	r4, #0
   13536:	9400      	str	r4, [sp, #0]
   13538:	4623      	mov	r3, r4
   1353a:	f107 020c 	add.w	r2, r7, #12
   1353e:	4631      	mov	r1, r6
   13540:	4648      	mov	r0, r9
   13542:	f7fd fd17 	bl	10f74 <bt_mesh_model_send>
   13546:	2800      	cmp	r0, #0
   13548:	d038      	beq.n	135bc <dev_comp_data_get+0x164>
		BT_ERR("Unable to send Device Composition Status response");
   1354a:	4b3f      	ldr	r3, [pc, #252]	; (13648 <dev_comp_data_get+0x1f0>)
   1354c:	483c      	ldr	r0, [pc, #240]	; (13640 <dev_comp_data_get+0x1e8>)
   1354e:	62bb      	str	r3, [r7, #40]	; 0x28
   13550:	f107 0224 	add.w	r2, r7, #36	; 0x24
   13554:	2302      	movs	r3, #2
   13556:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1355a:	60bb      	str	r3, [r7, #8]
   1355c:	627b      	str	r3, [r7, #36]	; 0x24
   1355e:	f016 fe63 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   13562:	4620      	mov	r0, r4
   13564:	e02a      	b.n	135bc <dev_comp_data_get+0x164>
		err = comp_add_elem(buf, &comp->elem[i], i == 0);
   13566:	68ec      	ldr	r4, [r5, #12]
   13568:	eb04 140a 	add.w	r4, r4, sl, lsl #4
	if (net_buf_simple_tailroom(buf) <
   1356c:	f107 000c 	add.w	r0, r7, #12
   13570:	f018 fc8b 	bl	2be8a <net_buf_simple_tailroom>
	    4 + (elem->model_count * 2U) + (elem->vnd_model_count * 4U)) {
   13574:	7922      	ldrb	r2, [r4, #4]
   13576:	7963      	ldrb	r3, [r4, #5]
   13578:	3202      	adds	r2, #2
   1357a:	fb18 2303 	smlabb	r3, r8, r3, r2
	if (net_buf_simple_tailroom(buf) <
   1357e:	ebb0 0f43 	cmp.w	r0, r3, lsl #1
   13582:	d21f      	bcs.n	135c4 <dev_comp_data_get+0x16c>
		BT_ERR("Too large device composition");
   13584:	4b31      	ldr	r3, [pc, #196]	; (1364c <dev_comp_data_get+0x1f4>)
   13586:	482e      	ldr	r0, [pc, #184]	; (13640 <dev_comp_data_get+0x1e8>)
   13588:	62bb      	str	r3, [r7, #40]	; 0x28
   1358a:	f107 0224 	add.w	r2, r7, #36	; 0x24
   1358e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13592:	f8c7 8008 	str.w	r8, [r7, #8]
   13596:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
   1359a:	f016 fe45 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		BT_ERR("Unable to get composition page 0");
   1359e:	4b2c      	ldr	r3, [pc, #176]	; (13650 <dev_comp_data_get+0x1f8>)
   135a0:	4827      	ldr	r0, [pc, #156]	; (13640 <dev_comp_data_get+0x1e8>)
   135a2:	62bb      	str	r3, [r7, #40]	; 0x28
   135a4:	f107 0224 	add.w	r2, r7, #36	; 0x24
   135a8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   135ac:	f8c7 8008 	str.w	r8, [r7, #8]
   135b0:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
   135b4:	f016 fe38 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return err;
   135b8:	f06f 0006 	mvn.w	r0, #6
}
   135bc:	375c      	adds	r7, #92	; 0x5c
   135be:	46bd      	mov	sp, r7
   135c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	net_buf_simple_add_le16(buf, elem->loc);
   135c4:	8861      	ldrh	r1, [r4, #2]
   135c6:	f107 000c 	add.w	r0, r7, #12
   135ca:	f018 fbce 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(buf, elem->model_count);
   135ce:	7921      	ldrb	r1, [r4, #4]
   135d0:	f107 000c 	add.w	r0, r7, #12
   135d4:	f018 fbc1 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, elem->vnd_model_count);
   135d8:	7961      	ldrb	r1, [r4, #5]
   135da:	f107 000c 	add.w	r0, r7, #12
   135de:	f018 fbbc 	bl	2bd5a <net_buf_simple_add_u8>
	for (i = 0; i < elem->model_count; i++) {
   135e2:	2300      	movs	r3, #0
   135e4:	7922      	ldrb	r2, [r4, #4]
   135e6:	4293      	cmp	r3, r2
   135e8:	db06      	blt.n	135f8 <dev_comp_data_get+0x1a0>
	for (i = 0; i < elem->vnd_model_count; i++) {
   135ea:	2300      	movs	r3, #0
   135ec:	7962      	ldrb	r2, [r4, #5]
   135ee:	4293      	cmp	r3, r2
   135f0:	db0e      	blt.n	13610 <dev_comp_data_get+0x1b8>
	for (i = 0; i < comp->elem_count; i++) {
   135f2:	f10a 0a01 	add.w	sl, sl, #1
   135f6:	e79a      	b.n	1352e <dev_comp_data_get+0xd6>
		net_buf_simple_add_le16(buf, mod->id);
   135f8:	fb0b f203 	mul.w	r2, fp, r3
   135fc:	68a1      	ldr	r1, [r4, #8]
   135fe:	607b      	str	r3, [r7, #4]
   13600:	5a89      	ldrh	r1, [r1, r2]
   13602:	f107 000c 	add.w	r0, r7, #12
   13606:	f018 fbb0 	bl	2bd6a <net_buf_simple_add_le16>
	for (i = 0; i < elem->model_count; i++) {
   1360a:	687b      	ldr	r3, [r7, #4]
   1360c:	3301      	adds	r3, #1
   1360e:	e7e9      	b.n	135e4 <dev_comp_data_get+0x18c>
		mod = &elem->vnd_models[i];
   13610:	fb0b f103 	mul.w	r1, fp, r3
   13614:	68e0      	ldr	r0, [r4, #12]
   13616:	603b      	str	r3, [r7, #0]
   13618:	1842      	adds	r2, r0, r1
		net_buf_simple_add_le16(buf, mod->vnd.company);
   1361a:	5a41      	ldrh	r1, [r0, r1]
		mod = &elem->vnd_models[i];
   1361c:	607a      	str	r2, [r7, #4]
		net_buf_simple_add_le16(buf, mod->vnd.company);
   1361e:	f107 000c 	add.w	r0, r7, #12
   13622:	f018 fba2 	bl	2bd6a <net_buf_simple_add_le16>
		net_buf_simple_add_le16(buf, mod->vnd.id);
   13626:	687a      	ldr	r2, [r7, #4]
   13628:	f107 000c 	add.w	r0, r7, #12
   1362c:	8851      	ldrh	r1, [r2, #2]
   1362e:	f018 fb9c 	bl	2bd6a <net_buf_simple_add_le16>
	for (i = 0; i < elem->vnd_model_count; i++) {
   13632:	683b      	ldr	r3, [r7, #0]
   13634:	3301      	adds	r3, #1
   13636:	e7d9      	b.n	135ec <dev_comp_data_get+0x194>
   13638:	00032287 	.word	0x00032287
   1363c:	00032657 	.word	0x00032657
   13640:	0002dafc 	.word	0x0002dafc
   13644:	000322bf 	.word	0x000322bf
   13648:	00032323 	.word	0x00032323
   1364c:	000322e5 	.word	0x000322e5
   13650:	00032302 	.word	0x00032302

00013654 <beacon_get>:
{
   13654:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13658:	8895      	ldrh	r5, [r2, #4]
{
   1365a:	b095      	sub	sp, #84	; 0x54
   1365c:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   1365e:	ab09      	add	r3, sp, #36	; 0x24
   13660:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   13664:	e9cd 130c 	strd	r1, r3, [sp, #48]	; 0x30
{
   13668:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   1366a:	4629      	mov	r1, r5
   1366c:	6810      	ldr	r0, [r2, #0]
   1366e:	8827      	ldrh	r7, [r4, #0]
   13670:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13674:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   13678:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   1367a:	f7f1 fd6d 	bl	5158 <bt_hex_real>
   1367e:	4b19      	ldr	r3, [pc, #100]	; (136e4 <beacon_get+0x90>)
   13680:	9302      	str	r3, [sp, #8]
   13682:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13686:	4b18      	ldr	r3, [pc, #96]	; (136e8 <beacon_get+0x94>)
   13688:	4918      	ldr	r1, [pc, #96]	; (136ec <beacon_get+0x98>)
   1368a:	9301      	str	r3, [sp, #4]
   1368c:	2500      	movs	r5, #0
   1368e:	462b      	mov	r3, r5
   13690:	2204      	movs	r2, #4
   13692:	4628      	mov	r0, r5
   13694:	e9cd 8904 	strd	r8, r9, [sp, #16]
   13698:	9703      	str	r7, [sp, #12]
   1369a:	9500      	str	r5, [sp, #0]
   1369c:	f7ff feca 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_BEACON_STATUS);
   136a0:	f248 010b 	movw	r1, #32779	; 0x800b
   136a4:	a80b      	add	r0, sp, #44	; 0x2c
   136a6:	f016 fd3e 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_beacon_enabled());
   136aa:	f7f8 faad 	bl	bc08 <bt_mesh_beacon_enabled>
   136ae:	4601      	mov	r1, r0
   136b0:	a80b      	add	r0, sp, #44	; 0x2c
   136b2:	f018 fb52 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   136b6:	9500      	str	r5, [sp, #0]
   136b8:	462b      	mov	r3, r5
   136ba:	aa0b      	add	r2, sp, #44	; 0x2c
   136bc:	4621      	mov	r1, r4
   136be:	4630      	mov	r0, r6
   136c0:	f7fd fc58 	bl	10f74 <bt_mesh_model_send>
   136c4:	b150      	cbz	r0, 136dc <beacon_get+0x88>
		BT_ERR("Unable to send Config Beacon Status response");
   136c6:	4b0a      	ldr	r3, [pc, #40]	; (136f0 <beacon_get+0x9c>)
   136c8:	9312      	str	r3, [sp, #72]	; 0x48
   136ca:	4808      	ldr	r0, [pc, #32]	; (136ec <beacon_get+0x98>)
   136cc:	2302      	movs	r3, #2
   136ce:	aa11      	add	r2, sp, #68	; 0x44
   136d0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   136d4:	9308      	str	r3, [sp, #32]
   136d6:	9311      	str	r3, [sp, #68]	; 0x44
   136d8:	f016 fda6 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   136dc:	2000      	movs	r0, #0
   136de:	b015      	add	sp, #84	; 0x54
   136e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   136e4:	000328d8 	.word	0x000328d8
   136e8:	00032287 	.word	0x00032287
   136ec:	0002dafc 	.word	0x0002dafc
   136f0:	00032355 	.word	0x00032355

000136f4 <beacon_set>:
{
   136f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   136f8:	4616      	mov	r6, r2
   136fa:	b094      	sub	sp, #80	; 0x50
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   136fc:	88b4      	ldrh	r4, [r6, #4]
   136fe:	f8b1 8000 	ldrh.w	r8, [r1]
   13702:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13706:	f8b1 a004 	ldrh.w	sl, [r1, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   1370a:	ab09      	add	r3, sp, #36	; 0x24
   1370c:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   13710:	4607      	mov	r7, r0
   13712:	460d      	mov	r5, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13714:	6830      	ldr	r0, [r6, #0]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   13716:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13718:	4621      	mov	r1, r4
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_BEACON_STATUS, 1);
   1371a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   1371e:	f7f1 fd1b 	bl	5158 <bt_hex_real>
   13722:	4b26      	ldr	r3, [pc, #152]	; (137bc <beacon_set+0xc8>)
   13724:	9302      	str	r3, [sp, #8]
   13726:	e9cd 4006 	strd	r4, r0, [sp, #24]
   1372a:	4b25      	ldr	r3, [pc, #148]	; (137c0 <beacon_set+0xcc>)
   1372c:	9301      	str	r3, [sp, #4]
   1372e:	2400      	movs	r4, #0
   13730:	4623      	mov	r3, r4
   13732:	4620      	mov	r0, r4
   13734:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   13738:	4922      	ldr	r1, [pc, #136]	; (137c4 <beacon_set+0xd0>)
   1373a:	f8cd 800c 	str.w	r8, [sp, #12]
   1373e:	9400      	str	r4, [sp, #0]
   13740:	2204      	movs	r2, #4
   13742:	f7ff fe77 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   13746:	6833      	ldr	r3, [r6, #0]
   13748:	7818      	ldrb	r0, [r3, #0]
   1374a:	2801      	cmp	r0, #1
   1374c:	d911      	bls.n	13772 <beacon_set+0x7e>
		BT_WARN("Invalid Config Beacon value 0x%02x", buf->data[0]);
   1374e:	4a1e      	ldr	r2, [pc, #120]	; (137c8 <beacon_set+0xd4>)
   13750:	9212      	str	r2, [sp, #72]	; 0x48
   13752:	781b      	ldrb	r3, [r3, #0]
   13754:	481b      	ldr	r0, [pc, #108]	; (137c4 <beacon_set+0xd0>)
   13756:	9313      	str	r3, [sp, #76]	; 0x4c
   13758:	aa11      	add	r2, sp, #68	; 0x44
   1375a:	2303      	movs	r3, #3
   1375c:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   13760:	9308      	str	r3, [sp, #32]
   13762:	9311      	str	r3, [sp, #68]	; 0x44
   13764:	f016 fd60 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13768:	f06f 0015 	mvn.w	r0, #21
}
   1376c:	b014      	add	sp, #80	; 0x50
   1376e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_mesh_beacon_set(buf->data[0]);
   13772:	f000 0001 	and.w	r0, r0, #1
   13776:	f7f8 fa19 	bl	bbac <bt_mesh_beacon_set>
	bt_mesh_model_msg_init(&msg, OP_BEACON_STATUS);
   1377a:	f248 010b 	movw	r1, #32779	; 0x800b
   1377e:	a80b      	add	r0, sp, #44	; 0x2c
   13780:	f016 fcd1 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, buf->data[0]);
   13784:	6833      	ldr	r3, [r6, #0]
   13786:	a80b      	add	r0, sp, #44	; 0x2c
   13788:	7819      	ldrb	r1, [r3, #0]
   1378a:	f018 fae6 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   1378e:	9400      	str	r4, [sp, #0]
   13790:	4623      	mov	r3, r4
   13792:	aa0b      	add	r2, sp, #44	; 0x2c
   13794:	4629      	mov	r1, r5
   13796:	4638      	mov	r0, r7
   13798:	f7fd fbec 	bl	10f74 <bt_mesh_model_send>
   1379c:	2800      	cmp	r0, #0
   1379e:	d0e5      	beq.n	1376c <beacon_set+0x78>
		BT_ERR("Unable to send Config Beacon Status response");
   137a0:	4b0a      	ldr	r3, [pc, #40]	; (137cc <beacon_set+0xd8>)
   137a2:	4808      	ldr	r0, [pc, #32]	; (137c4 <beacon_set+0xd0>)
   137a4:	9312      	str	r3, [sp, #72]	; 0x48
   137a6:	aa11      	add	r2, sp, #68	; 0x44
   137a8:	2302      	movs	r3, #2
   137aa:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   137ae:	9308      	str	r3, [sp, #32]
   137b0:	9311      	str	r3, [sp, #68]	; 0x44
   137b2:	f016 fd39 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   137b6:	4620      	mov	r0, r4
   137b8:	e7d8      	b.n	1376c <beacon_set+0x78>
   137ba:	bf00      	nop
   137bc:	000328fb 	.word	0x000328fb
   137c0:	00032287 	.word	0x00032287
   137c4:	0002dafc 	.word	0x0002dafc
   137c8:	00032382 	.word	0x00032382
   137cc:	00032355 	.word	0x00032355

000137d0 <default_ttl_get>:
{
   137d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   137d4:	8895      	ldrh	r5, [r2, #4]
{
   137d6:	b095      	sub	sp, #84	; 0x54
   137d8:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   137da:	ab09      	add	r3, sp, #36	; 0x24
   137dc:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   137e0:	e9cd 130c 	strd	r1, r3, [sp, #48]	; 0x30
{
   137e4:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   137e6:	4629      	mov	r1, r5
   137e8:	6810      	ldr	r0, [r2, #0]
   137ea:	8827      	ldrh	r7, [r4, #0]
   137ec:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   137f0:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   137f4:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   137f6:	f7f1 fcaf 	bl	5158 <bt_hex_real>
   137fa:	4b19      	ldr	r3, [pc, #100]	; (13860 <default_ttl_get+0x90>)
   137fc:	9302      	str	r3, [sp, #8]
   137fe:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13802:	4b18      	ldr	r3, [pc, #96]	; (13864 <default_ttl_get+0x94>)
   13804:	4918      	ldr	r1, [pc, #96]	; (13868 <default_ttl_get+0x98>)
   13806:	9301      	str	r3, [sp, #4]
   13808:	2500      	movs	r5, #0
   1380a:	462b      	mov	r3, r5
   1380c:	2204      	movs	r2, #4
   1380e:	4628      	mov	r0, r5
   13810:	e9cd 8904 	strd	r8, r9, [sp, #16]
   13814:	9703      	str	r7, [sp, #12]
   13816:	9500      	str	r5, [sp, #0]
   13818:	f7ff fe0c 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_DEFAULT_TTL_STATUS);
   1381c:	f248 010e 	movw	r1, #32782	; 0x800e
   13820:	a80b      	add	r0, sp, #44	; 0x2c
   13822:	f016 fc80 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_default_ttl_get());
   13826:	f7f8 fa47 	bl	bcb8 <bt_mesh_default_ttl_get>
   1382a:	4601      	mov	r1, r0
   1382c:	a80b      	add	r0, sp, #44	; 0x2c
   1382e:	f018 fa94 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13832:	9500      	str	r5, [sp, #0]
   13834:	462b      	mov	r3, r5
   13836:	aa0b      	add	r2, sp, #44	; 0x2c
   13838:	4621      	mov	r1, r4
   1383a:	4630      	mov	r0, r6
   1383c:	f7fd fb9a 	bl	10f74 <bt_mesh_model_send>
   13840:	b150      	cbz	r0, 13858 <default_ttl_get+0x88>
		BT_ERR("Unable to send Default TTL Status response");
   13842:	4b0a      	ldr	r3, [pc, #40]	; (1386c <default_ttl_get+0x9c>)
   13844:	9312      	str	r3, [sp, #72]	; 0x48
   13846:	4808      	ldr	r0, [pc, #32]	; (13868 <default_ttl_get+0x98>)
   13848:	2302      	movs	r3, #2
   1384a:	aa11      	add	r2, sp, #68	; 0x44
   1384c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13850:	9308      	str	r3, [sp, #32]
   13852:	9311      	str	r3, [sp, #68]	; 0x44
   13854:	f016 fce8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13858:	2000      	movs	r0, #0
   1385a:	b015      	add	sp, #84	; 0x54
   1385c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13860:	00032906 	.word	0x00032906
   13864:	00032287 	.word	0x00032287
   13868:	0002dafc 	.word	0x0002dafc
   1386c:	000323a5 	.word	0x000323a5

00013870 <default_ttl_set>:
{
   13870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13874:	4614      	mov	r4, r2
   13876:	b094      	sub	sp, #80	; 0x50
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13878:	88a5      	ldrh	r5, [r4, #4]
   1387a:	f8b1 8000 	ldrh.w	r8, [r1]
   1387e:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13882:	f8b1 a004 	ldrh.w	sl, [r1, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   13886:	ab09      	add	r3, sp, #36	; 0x24
   13888:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   1388c:	4607      	mov	r7, r0
   1388e:	460e      	mov	r6, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13890:	6820      	ldr	r0, [r4, #0]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   13892:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13894:	4629      	mov	r1, r5
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_DEFAULT_TTL_STATUS, 1);
   13896:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   1389a:	f7f1 fc5d 	bl	5158 <bt_hex_real>
   1389e:	4b22      	ldr	r3, [pc, #136]	; (13928 <default_ttl_set+0xb8>)
   138a0:	9302      	str	r3, [sp, #8]
   138a2:	4b22      	ldr	r3, [pc, #136]	; (1392c <default_ttl_set+0xbc>)
   138a4:	9301      	str	r3, [sp, #4]
   138a6:	2300      	movs	r3, #0
   138a8:	e9cd 5006 	strd	r5, r0, [sp, #24]
   138ac:	4920      	ldr	r1, [pc, #128]	; (13930 <default_ttl_set+0xc0>)
   138ae:	9300      	str	r3, [sp, #0]
   138b0:	4618      	mov	r0, r3
   138b2:	2204      	movs	r2, #4
   138b4:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   138b8:	f8cd 800c 	str.w	r8, [sp, #12]
   138bc:	f7ff fdba 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	err = bt_mesh_default_ttl_set(buf->data[0]);
   138c0:	6823      	ldr	r3, [r4, #0]
   138c2:	7818      	ldrb	r0, [r3, #0]
   138c4:	f7f8 f9da 	bl	bc7c <bt_mesh_default_ttl_set>
	if (err) {
   138c8:	4605      	mov	r5, r0
   138ca:	b188      	cbz	r0, 138f0 <default_ttl_set+0x80>
		BT_WARN("Prohibited Default TTL value 0x%02x", buf->data[0]);
   138cc:	4a19      	ldr	r2, [pc, #100]	; (13934 <default_ttl_set+0xc4>)
   138ce:	6823      	ldr	r3, [r4, #0]
   138d0:	9212      	str	r2, [sp, #72]	; 0x48
   138d2:	781b      	ldrb	r3, [r3, #0]
   138d4:	9313      	str	r3, [sp, #76]	; 0x4c
   138d6:	2303      	movs	r3, #3
   138d8:	9308      	str	r3, [sp, #32]
   138da:	9311      	str	r3, [sp, #68]	; 0x44
   138dc:	aa11      	add	r2, sp, #68	; 0x44
   138de:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_ERR("Unable to send Default TTL Status response");
   138e2:	4813      	ldr	r0, [pc, #76]	; (13930 <default_ttl_set+0xc0>)
   138e4:	f016 fca0 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   138e8:	4628      	mov	r0, r5
   138ea:	b014      	add	sp, #80	; 0x50
   138ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_mesh_model_msg_init(&msg, OP_DEFAULT_TTL_STATUS);
   138f0:	f248 010e 	movw	r1, #32782	; 0x800e
   138f4:	a80b      	add	r0, sp, #44	; 0x2c
   138f6:	f016 fc16 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, buf->data[0]);
   138fa:	6823      	ldr	r3, [r4, #0]
   138fc:	a80b      	add	r0, sp, #44	; 0x2c
   138fe:	7819      	ldrb	r1, [r3, #0]
   13900:	f018 fa2b 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13904:	9500      	str	r5, [sp, #0]
   13906:	462b      	mov	r3, r5
   13908:	aa0b      	add	r2, sp, #44	; 0x2c
   1390a:	4631      	mov	r1, r6
   1390c:	4638      	mov	r0, r7
   1390e:	f7fd fb31 	bl	10f74 <bt_mesh_model_send>
   13912:	2800      	cmp	r0, #0
   13914:	d0e8      	beq.n	138e8 <default_ttl_set+0x78>
		BT_ERR("Unable to send Default TTL Status response");
   13916:	4b08      	ldr	r3, [pc, #32]	; (13938 <default_ttl_set+0xc8>)
   13918:	9312      	str	r3, [sp, #72]	; 0x48
   1391a:	2302      	movs	r3, #2
   1391c:	9308      	str	r3, [sp, #32]
   1391e:	9311      	str	r3, [sp, #68]	; 0x44
   13920:	aa11      	add	r2, sp, #68	; 0x44
   13922:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13926:	e7dc      	b.n	138e2 <default_ttl_set+0x72>
   13928:	00032916 	.word	0x00032916
   1392c:	00032287 	.word	0x00032287
   13930:	0002dafc 	.word	0x0002dafc
   13934:	000323d0 	.word	0x000323d0
   13938:	000323a5 	.word	0x000323a5

0001393c <gatt_proxy_get>:
{
   1393c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13940:	8896      	ldrh	r6, [r2, #4]
   13942:	880f      	ldrh	r7, [r1, #0]
   13944:	f8b1 8002 	ldrh.w	r8, [r1, #2]
   13948:	f8b1 9004 	ldrh.w	r9, [r1, #4]
{
   1394c:	b089      	sub	sp, #36	; 0x24
   1394e:	4605      	mov	r5, r0
   13950:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13952:	6810      	ldr	r0, [r2, #0]
   13954:	4631      	mov	r1, r6
   13956:	f7f1 fbff 	bl	5158 <bt_hex_real>
   1395a:	4b0b      	ldr	r3, [pc, #44]	; (13988 <gatt_proxy_get+0x4c>)
   1395c:	9302      	str	r3, [sp, #8]
   1395e:	4b0b      	ldr	r3, [pc, #44]	; (1398c <gatt_proxy_get+0x50>)
   13960:	9301      	str	r3, [sp, #4]
   13962:	2300      	movs	r3, #0
   13964:	e9cd 6006 	strd	r6, r0, [sp, #24]
   13968:	e9cd 8904 	strd	r8, r9, [sp, #16]
   1396c:	4618      	mov	r0, r3
   1396e:	4908      	ldr	r1, [pc, #32]	; (13990 <gatt_proxy_get+0x54>)
   13970:	9703      	str	r7, [sp, #12]
   13972:	9300      	str	r3, [sp, #0]
   13974:	2204      	movs	r2, #4
   13976:	f7ff fd5d 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	return send_gatt_proxy_status(model, ctx);
   1397a:	4621      	mov	r1, r4
   1397c:	4628      	mov	r0, r5
}
   1397e:	b009      	add	sp, #36	; 0x24
   13980:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return send_gatt_proxy_status(model, ctx);
   13984:	f7fd bda2 	b.w	114cc <send_gatt_proxy_status>
   13988:	00032926 	.word	0x00032926
   1398c:	00032287 	.word	0x00032287
   13990:	0002dafc 	.word	0x0002dafc

00013994 <gatt_proxy_set>:
{
   13994:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13998:	8897      	ldrh	r7, [r2, #4]
   1399a:	f8b1 8000 	ldrh.w	r8, [r1]
   1399e:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   139a2:	f8b1 a004 	ldrh.w	sl, [r1, #4]
{
   139a6:	b090      	sub	sp, #64	; 0x40
   139a8:	4606      	mov	r6, r0
   139aa:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   139ac:	6810      	ldr	r0, [r2, #0]
   139ae:	4639      	mov	r1, r7
{
   139b0:	4615      	mov	r5, r2
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   139b2:	f7f1 fbd1 	bl	5158 <bt_hex_real>
   139b6:	4b18      	ldr	r3, [pc, #96]	; (13a18 <gatt_proxy_set+0x84>)
   139b8:	9302      	str	r3, [sp, #8]
   139ba:	4b18      	ldr	r3, [pc, #96]	; (13a1c <gatt_proxy_set+0x88>)
   139bc:	9301      	str	r3, [sp, #4]
   139be:	2300      	movs	r3, #0
   139c0:	e9cd 7006 	strd	r7, r0, [sp, #24]
   139c4:	9300      	str	r3, [sp, #0]
   139c6:	4618      	mov	r0, r3
   139c8:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   139cc:	4914      	ldr	r1, [pc, #80]	; (13a20 <gatt_proxy_set+0x8c>)
   139ce:	f8cd 800c 	str.w	r8, [sp, #12]
   139d2:	2204      	movs	r2, #4
   139d4:	f7ff fd2e 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   139d8:	682b      	ldr	r3, [r5, #0]
   139da:	7818      	ldrb	r0, [r3, #0]
   139dc:	2801      	cmp	r0, #1
   139de:	d808      	bhi.n	139f2 <gatt_proxy_set+0x5e>
	(void)bt_mesh_gatt_proxy_set(buf->data[0]);
   139e0:	f7f8 f91c 	bl	bc1c <bt_mesh_gatt_proxy_set>
	return send_gatt_proxy_status(model, ctx);
   139e4:	4621      	mov	r1, r4
   139e6:	4630      	mov	r0, r6
}
   139e8:	b010      	add	sp, #64	; 0x40
   139ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return send_gatt_proxy_status(model, ctx);
   139ee:	f7fd bd6d 	b.w	114cc <send_gatt_proxy_status>
		BT_WARN("Invalid GATT Proxy value 0x%02x", buf->data[0]);
   139f2:	4a0c      	ldr	r2, [pc, #48]	; (13a24 <gatt_proxy_set+0x90>)
   139f4:	920e      	str	r2, [sp, #56]	; 0x38
   139f6:	781b      	ldrb	r3, [r3, #0]
   139f8:	930f      	str	r3, [sp, #60]	; 0x3c
   139fa:	4809      	ldr	r0, [pc, #36]	; (13a20 <gatt_proxy_set+0x8c>)
   139fc:	2303      	movs	r3, #3
   139fe:	aa0d      	add	r2, sp, #52	; 0x34
   13a00:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   13a04:	9309      	str	r3, [sp, #36]	; 0x24
   13a06:	930d      	str	r3, [sp, #52]	; 0x34
   13a08:	f016 fc0e 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13a0c:	f06f 0015 	mvn.w	r0, #21
   13a10:	b010      	add	sp, #64	; 0x40
   13a12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13a16:	bf00      	nop
   13a18:	00032675 	.word	0x00032675
   13a1c:	00032287 	.word	0x00032287
   13a20:	0002dafc 	.word	0x0002dafc
   13a24:	000323f4 	.word	0x000323f4

00013a28 <net_transmit_get>:
{
   13a28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13a2c:	8895      	ldrh	r5, [r2, #4]
{
   13a2e:	b095      	sub	sp, #84	; 0x54
   13a30:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   13a32:	ab09      	add	r3, sp, #36	; 0x24
   13a34:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   13a38:	e9cd 130c 	strd	r1, r3, [sp, #48]	; 0x30
{
   13a3c:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13a3e:	4629      	mov	r1, r5
   13a40:	6810      	ldr	r0, [r2, #0]
   13a42:	8827      	ldrh	r7, [r4, #0]
   13a44:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13a48:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   13a4c:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13a4e:	f7f1 fb83 	bl	5158 <bt_hex_real>
   13a52:	4b19      	ldr	r3, [pc, #100]	; (13ab8 <net_transmit_get+0x90>)
   13a54:	9302      	str	r3, [sp, #8]
   13a56:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13a5a:	4b18      	ldr	r3, [pc, #96]	; (13abc <net_transmit_get+0x94>)
   13a5c:	4918      	ldr	r1, [pc, #96]	; (13ac0 <net_transmit_get+0x98>)
   13a5e:	9301      	str	r3, [sp, #4]
   13a60:	2500      	movs	r5, #0
   13a62:	462b      	mov	r3, r5
   13a64:	2204      	movs	r2, #4
   13a66:	4628      	mov	r0, r5
   13a68:	e9cd 8904 	strd	r8, r9, [sp, #16]
   13a6c:	9703      	str	r7, [sp, #12]
   13a6e:	9500      	str	r5, [sp, #0]
   13a70:	f7ff fce0 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_NET_TRANSMIT_STATUS);
   13a74:	f248 0125 	movw	r1, #32805	; 0x8025
   13a78:	a80b      	add	r0, sp, #44	; 0x2c
   13a7a:	f016 fb54 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_net_transmit_get());
   13a7e:	f7f8 f95b 	bl	bd38 <bt_mesh_net_transmit_get>
   13a82:	4601      	mov	r1, r0
   13a84:	a80b      	add	r0, sp, #44	; 0x2c
   13a86:	f018 f968 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13a8a:	9500      	str	r5, [sp, #0]
   13a8c:	462b      	mov	r3, r5
   13a8e:	aa0b      	add	r2, sp, #44	; 0x2c
   13a90:	4621      	mov	r1, r4
   13a92:	4630      	mov	r0, r6
   13a94:	f7fd fa6e 	bl	10f74 <bt_mesh_model_send>
   13a98:	b150      	cbz	r0, 13ab0 <net_transmit_get+0x88>
		BT_ERR("Unable to send Config Network Transmit Status");
   13a9a:	4b0a      	ldr	r3, [pc, #40]	; (13ac4 <net_transmit_get+0x9c>)
   13a9c:	9312      	str	r3, [sp, #72]	; 0x48
   13a9e:	4808      	ldr	r0, [pc, #32]	; (13ac0 <net_transmit_get+0x98>)
   13aa0:	2302      	movs	r3, #2
   13aa2:	aa11      	add	r2, sp, #68	; 0x44
   13aa4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13aa8:	9308      	str	r3, [sp, #32]
   13aaa:	9311      	str	r3, [sp, #68]	; 0x44
   13aac:	f016 fbbc 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13ab0:	2000      	movs	r0, #0
   13ab2:	b015      	add	sp, #84	; 0x54
   13ab4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13ab8:	00032684 	.word	0x00032684
   13abc:	00032287 	.word	0x00032287
   13ac0:	0002dafc 	.word	0x0002dafc
   13ac4:	00032414 	.word	0x00032414

00013ac8 <net_transmit_set>:
{
   13ac8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13acc:	4615      	mov	r5, r2
   13ace:	b095      	sub	sp, #84	; 0x54
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13ad0:	88ac      	ldrh	r4, [r5, #4]
   13ad2:	f8b1 8000 	ldrh.w	r8, [r1]
   13ad6:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   13ada:	f8b1 b004 	ldrh.w	fp, [r1, #4]
{
   13ade:	af08      	add	r7, sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   13ae0:	1d3b      	adds	r3, r7, #4
   13ae2:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   13ae6:	4681      	mov	r9, r0
   13ae8:	460e      	mov	r6, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13aea:	6828      	ldr	r0, [r5, #0]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   13aec:	60fb      	str	r3, [r7, #12]
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13aee:	4621      	mov	r1, r4
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NET_TRANSMIT_STATUS, 1);
   13af0:	e9c7 2304 	strd	r2, r3, [r7, #16]
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13af4:	f7f1 fb30 	bl	5158 <bt_hex_real>
   13af8:	f8cd 800c 	str.w	r8, [sp, #12]
   13afc:	e9cd 4006 	strd	r4, r0, [sp, #24]
   13b00:	f04f 0800 	mov.w	r8, #0
   13b04:	4c2b      	ldr	r4, [pc, #172]	; (13bb4 <net_transmit_set+0xec>)
   13b06:	4b2c      	ldr	r3, [pc, #176]	; (13bb8 <net_transmit_set+0xf0>)
   13b08:	9402      	str	r4, [sp, #8]
   13b0a:	9301      	str	r3, [sp, #4]
   13b0c:	f8cd 8000 	str.w	r8, [sp]
   13b10:	2204      	movs	r2, #4
   13b12:	e9cd ab04 	strd	sl, fp, [sp, #16]
   13b16:	4929      	ldr	r1, [pc, #164]	; (13bbc <net_transmit_set+0xf4>)
   13b18:	4643      	mov	r3, r8
   13b1a:	4640      	mov	r0, r8
   13b1c:	f7ff fc8a 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	BT_DBG("Transmit 0x%02x (count %u interval %ums)", buf->data[0],
   13b20:	46ea      	mov	sl, sp
   13b22:	4927      	ldr	r1, [pc, #156]	; (13bc0 <net_transmit_set+0xf8>)
   13b24:	682b      	ldr	r3, [r5, #0]
   13b26:	4825      	ldr	r0, [pc, #148]	; (13bbc <net_transmit_set+0xf4>)
   13b28:	b08a      	sub	sp, #40	; 0x28
   13b2a:	aa08      	add	r2, sp, #32
   13b2c:	e9c2 1404 	strd	r1, r4, [r2, #16]
   13b30:	7819      	ldrb	r1, [r3, #0]
   13b32:	6191      	str	r1, [r2, #24]
   13b34:	7819      	ldrb	r1, [r3, #0]
   13b36:	f001 0107 	and.w	r1, r1, #7
   13b3a:	61d1      	str	r1, [r2, #28]
   13b3c:	781c      	ldrb	r4, [r3, #0]
   13b3e:	08e4      	lsrs	r4, r4, #3
   13b40:	3401      	adds	r4, #1
   13b42:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   13b46:	2306      	movs	r3, #6
   13b48:	0064      	lsls	r4, r4, #1
   13b4a:	6214      	str	r4, [r2, #32]
   13b4c:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   13b50:	f842 3f0c 	str.w	r3, [r2, #12]!
   13b54:	61bb      	str	r3, [r7, #24]
   13b56:	f016 fb67 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_net_transmit_set(buf->data[0]);
   13b5a:	682b      	ldr	r3, [r5, #0]
   13b5c:	46d5      	mov	sp, sl
   13b5e:	7818      	ldrb	r0, [r3, #0]
   13b60:	f7f8 f8d4 	bl	bd0c <bt_mesh_net_transmit_set>
	bt_mesh_model_msg_init(&msg, OP_NET_TRANSMIT_STATUS);
   13b64:	f248 0125 	movw	r1, #32805	; 0x8025
   13b68:	f107 000c 	add.w	r0, r7, #12
   13b6c:	f016 fadb 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, buf->data[0]);
   13b70:	682b      	ldr	r3, [r5, #0]
   13b72:	f107 000c 	add.w	r0, r7, #12
   13b76:	7819      	ldrb	r1, [r3, #0]
   13b78:	f018 f8ef 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13b7c:	f8cd 8000 	str.w	r8, [sp]
   13b80:	4643      	mov	r3, r8
   13b82:	f107 020c 	add.w	r2, r7, #12
   13b86:	4631      	mov	r1, r6
   13b88:	4648      	mov	r0, r9
   13b8a:	f7fd f9f3 	bl	10f74 <bt_mesh_model_send>
   13b8e:	b158      	cbz	r0, 13ba8 <net_transmit_set+0xe0>
		BT_ERR("Unable to send Network Transmit Status");
   13b90:	4b0c      	ldr	r3, [pc, #48]	; (13bc4 <net_transmit_set+0xfc>)
   13b92:	62bb      	str	r3, [r7, #40]	; 0x28
   13b94:	4809      	ldr	r0, [pc, #36]	; (13bbc <net_transmit_set+0xf4>)
   13b96:	2302      	movs	r3, #2
   13b98:	f107 0224 	add.w	r2, r7, #36	; 0x24
   13b9c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13ba0:	603b      	str	r3, [r7, #0]
   13ba2:	627b      	str	r3, [r7, #36]	; 0x24
   13ba4:	f016 fb40 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13ba8:	2000      	movs	r0, #0
   13baa:	3734      	adds	r7, #52	; 0x34
   13bac:	46bd      	mov	sp, r7
   13bae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13bb2:	bf00      	nop
   13bb4:	00032695 	.word	0x00032695
   13bb8:	00032287 	.word	0x00032287
   13bbc:	0002dafc 	.word	0x0002dafc
   13bc0:	00032442 	.word	0x00032442
   13bc4:	0003246f 	.word	0x0003246f

00013bc8 <relay_get>:
{
   13bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13bcc:	8895      	ldrh	r5, [r2, #4]
{
   13bce:	b095      	sub	sp, #84	; 0x54
   13bd0:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   13bd2:	ab09      	add	r3, sp, #36	; 0x24
   13bd4:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   13bd8:	e9cd 130c 	strd	r1, r3, [sp, #48]	; 0x30
{
   13bdc:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13bde:	4629      	mov	r1, r5
   13be0:	6810      	ldr	r0, [r2, #0]
   13be2:	8827      	ldrh	r7, [r4, #0]
   13be4:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13be8:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   13bec:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13bee:	f7f1 fab3 	bl	5158 <bt_hex_real>
   13bf2:	4b1c      	ldr	r3, [pc, #112]	; (13c64 <relay_get+0x9c>)
   13bf4:	9302      	str	r3, [sp, #8]
   13bf6:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13bfa:	4b1b      	ldr	r3, [pc, #108]	; (13c68 <relay_get+0xa0>)
   13bfc:	491b      	ldr	r1, [pc, #108]	; (13c6c <relay_get+0xa4>)
   13bfe:	9301      	str	r3, [sp, #4]
   13c00:	2500      	movs	r5, #0
   13c02:	462b      	mov	r3, r5
   13c04:	2204      	movs	r2, #4
   13c06:	4628      	mov	r0, r5
   13c08:	e9cd 8904 	strd	r8, r9, [sp, #16]
   13c0c:	9703      	str	r7, [sp, #12]
   13c0e:	9500      	str	r5, [sp, #0]
   13c10:	f7ff fc10 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_RELAY_STATUS);
   13c14:	f248 0128 	movw	r1, #32808	; 0x8028
   13c18:	a80b      	add	r0, sp, #44	; 0x2c
   13c1a:	f016 fa84 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_get());
   13c1e:	f7f8 f8f5 	bl	be0c <bt_mesh_relay_get>
   13c22:	4601      	mov	r1, r0
   13c24:	a80b      	add	r0, sp, #44	; 0x2c
   13c26:	f018 f898 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_retransmit_get());
   13c2a:	f7f8 f8f9 	bl	be20 <bt_mesh_relay_retransmit_get>
   13c2e:	4601      	mov	r1, r0
   13c30:	a80b      	add	r0, sp, #44	; 0x2c
   13c32:	f018 f892 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13c36:	9500      	str	r5, [sp, #0]
   13c38:	462b      	mov	r3, r5
   13c3a:	aa0b      	add	r2, sp, #44	; 0x2c
   13c3c:	4621      	mov	r1, r4
   13c3e:	4630      	mov	r0, r6
   13c40:	f7fd f998 	bl	10f74 <bt_mesh_model_send>
   13c44:	b150      	cbz	r0, 13c5c <relay_get+0x94>
		BT_ERR("Unable to send Config Relay Status response");
   13c46:	4b0a      	ldr	r3, [pc, #40]	; (13c70 <relay_get+0xa8>)
   13c48:	9312      	str	r3, [sp, #72]	; 0x48
   13c4a:	4808      	ldr	r0, [pc, #32]	; (13c6c <relay_get+0xa4>)
   13c4c:	2302      	movs	r3, #2
   13c4e:	aa11      	add	r2, sp, #68	; 0x44
   13c50:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13c54:	9308      	str	r3, [sp, #32]
   13c56:	9311      	str	r3, [sp, #68]	; 0x44
   13c58:	f016 fae6 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13c5c:	2000      	movs	r0, #0
   13c5e:	b015      	add	sp, #84	; 0x54
   13c60:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13c64:	000326a6 	.word	0x000326a6
   13c68:	00032287 	.word	0x00032287
   13c6c:	0002dafc 	.word	0x0002dafc
   13c70:	00032496 	.word	0x00032496

00013c74 <relay_set>:
{
   13c74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13c78:	4616      	mov	r6, r2
   13c7a:	b094      	sub	sp, #80	; 0x50
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13c7c:	88b4      	ldrh	r4, [r6, #4]
   13c7e:	f8b1 8000 	ldrh.w	r8, [r1]
   13c82:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13c86:	f8b1 a004 	ldrh.w	sl, [r1, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   13c8a:	ab09      	add	r3, sp, #36	; 0x24
   13c8c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
{
   13c90:	4607      	mov	r7, r0
   13c92:	460d      	mov	r5, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13c94:	6830      	ldr	r0, [r6, #0]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   13c96:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13c98:	4621      	mov	r1, r4
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_RELAY_STATUS, 2);
   13c9a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13c9e:	f7f1 fa5b 	bl	5158 <bt_hex_real>
   13ca2:	4b29      	ldr	r3, [pc, #164]	; (13d48 <relay_set+0xd4>)
   13ca4:	9302      	str	r3, [sp, #8]
   13ca6:	e9cd 4006 	strd	r4, r0, [sp, #24]
   13caa:	4b28      	ldr	r3, [pc, #160]	; (13d4c <relay_set+0xd8>)
   13cac:	9301      	str	r3, [sp, #4]
   13cae:	2400      	movs	r4, #0
   13cb0:	4623      	mov	r3, r4
   13cb2:	4620      	mov	r0, r4
   13cb4:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   13cb8:	4925      	ldr	r1, [pc, #148]	; (13d50 <relay_set+0xdc>)
   13cba:	f8cd 800c 	str.w	r8, [sp, #12]
   13cbe:	9400      	str	r4, [sp, #0]
   13cc0:	2204      	movs	r2, #4
   13cc2:	f7ff fbb7 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   13cc6:	6833      	ldr	r3, [r6, #0]
   13cc8:	7818      	ldrb	r0, [r3, #0]
   13cca:	2801      	cmp	r0, #1
   13ccc:	d911      	bls.n	13cf2 <relay_set+0x7e>
		BT_WARN("Invalid Relay value 0x%02x", buf->data[0]);
   13cce:	4a21      	ldr	r2, [pc, #132]	; (13d54 <relay_set+0xe0>)
   13cd0:	9212      	str	r2, [sp, #72]	; 0x48
   13cd2:	781b      	ldrb	r3, [r3, #0]
   13cd4:	481e      	ldr	r0, [pc, #120]	; (13d50 <relay_set+0xdc>)
   13cd6:	9313      	str	r3, [sp, #76]	; 0x4c
   13cd8:	aa11      	add	r2, sp, #68	; 0x44
   13cda:	2303      	movs	r3, #3
   13cdc:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   13ce0:	9308      	str	r3, [sp, #32]
   13ce2:	9311      	str	r3, [sp, #68]	; 0x44
   13ce4:	f016 faa0 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13ce8:	f06f 0015 	mvn.w	r0, #21
}
   13cec:	b014      	add	sp, #80	; 0x50
   13cee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	(void)bt_mesh_relay_set(buf->data[0], buf->data[1]);
   13cf2:	7859      	ldrb	r1, [r3, #1]
   13cf4:	f7f8 f826 	bl	bd44 <bt_mesh_relay_set>
	bt_mesh_model_msg_init(&msg, OP_RELAY_STATUS);
   13cf8:	f248 0128 	movw	r1, #32808	; 0x8028
   13cfc:	a80b      	add	r0, sp, #44	; 0x2c
   13cfe:	f016 fa12 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_get());
   13d02:	f7f8 f883 	bl	be0c <bt_mesh_relay_get>
   13d06:	4601      	mov	r1, r0
   13d08:	a80b      	add	r0, sp, #44	; 0x2c
   13d0a:	f018 f826 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_relay_retransmit_get());
   13d0e:	f7f8 f887 	bl	be20 <bt_mesh_relay_retransmit_get>
   13d12:	4601      	mov	r1, r0
   13d14:	a80b      	add	r0, sp, #44	; 0x2c
   13d16:	f018 f820 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   13d1a:	9400      	str	r4, [sp, #0]
   13d1c:	4623      	mov	r3, r4
   13d1e:	aa0b      	add	r2, sp, #44	; 0x2c
   13d20:	4629      	mov	r1, r5
   13d22:	4638      	mov	r0, r7
   13d24:	f7fd f926 	bl	10f74 <bt_mesh_model_send>
   13d28:	2800      	cmp	r0, #0
   13d2a:	d0df      	beq.n	13cec <relay_set+0x78>
		BT_ERR("Unable to send Relay Status response");
   13d2c:	4b0a      	ldr	r3, [pc, #40]	; (13d58 <relay_set+0xe4>)
   13d2e:	4808      	ldr	r0, [pc, #32]	; (13d50 <relay_set+0xdc>)
   13d30:	9312      	str	r3, [sp, #72]	; 0x48
   13d32:	aa11      	add	r2, sp, #68	; 0x44
   13d34:	2302      	movs	r3, #2
   13d36:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   13d3a:	9308      	str	r3, [sp, #32]
   13d3c:	9311      	str	r3, [sp, #68]	; 0x44
   13d3e:	f016 fa73 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	return 0;
   13d42:	4620      	mov	r0, r4
   13d44:	e7d2      	b.n	13cec <relay_set+0x78>
   13d46:	bf00      	nop
   13d48:	000326b0 	.word	0x000326b0
   13d4c:	00032287 	.word	0x00032287
   13d50:	0002dafc 	.word	0x0002dafc
   13d54:	000324c2 	.word	0x000324c2
   13d58:	000324dd 	.word	0x000324dd

00013d5c <node_identity_get>:
{
   13d5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13d60:	8897      	ldrh	r7, [r2, #4]
   13d62:	f8b1 8000 	ldrh.w	r8, [r1]
   13d66:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13d6a:	f8b1 a004 	ldrh.w	sl, [r1, #4]
{
   13d6e:	b090      	sub	sp, #64	; 0x40
   13d70:	4606      	mov	r6, r0
   13d72:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13d74:	6810      	ldr	r0, [r2, #0]
   13d76:	4639      	mov	r1, r7
{
   13d78:	4615      	mov	r5, r2
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13d7a:	f7f1 f9ed 	bl	5158 <bt_hex_real>
   13d7e:	4b1b      	ldr	r3, [pc, #108]	; (13dec <node_identity_get+0x90>)
   13d80:	9302      	str	r3, [sp, #8]
   13d82:	4b1b      	ldr	r3, [pc, #108]	; (13df0 <node_identity_get+0x94>)
   13d84:	9301      	str	r3, [sp, #4]
   13d86:	2300      	movs	r3, #0
   13d88:	e9cd 7006 	strd	r7, r0, [sp, #24]
   13d8c:	4919      	ldr	r1, [pc, #100]	; (13df4 <node_identity_get+0x98>)
   13d8e:	9300      	str	r3, [sp, #0]
   13d90:	4618      	mov	r0, r3
   13d92:	2204      	movs	r2, #4
   13d94:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   13d98:	f8cd 800c 	str.w	r8, [sp, #12]
   13d9c:	f7ff fb4a 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	idx = net_buf_simple_pull_le16(buf);
   13da0:	4628      	mov	r0, r5
   13da2:	f018 f853 	bl	2be4c <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   13da6:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   13daa:	4605      	mov	r5, r0
	if (idx > 0xfff) {
   13dac:	d310      	bcc.n	13dd0 <node_identity_get+0x74>
		BT_ERR("Invalid NetKeyIndex 0x%04x", idx);
   13dae:	4b12      	ldr	r3, [pc, #72]	; (13df8 <node_identity_get+0x9c>)
   13db0:	aa0d      	add	r2, sp, #52	; 0x34
   13db2:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
   13db6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   13dba:	2303      	movs	r3, #3
   13dbc:	480d      	ldr	r0, [pc, #52]	; (13df4 <node_identity_get+0x98>)
   13dbe:	9309      	str	r3, [sp, #36]	; 0x24
   13dc0:	930d      	str	r3, [sp, #52]	; 0x34
   13dc2:	f016 fa31 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13dc6:	f06f 0015 	mvn.w	r0, #21
}
   13dca:	b010      	add	sp, #64	; 0x40
   13dcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	status = bt_mesh_subnet_node_id_get(idx, &node_id);
   13dd0:	a90a      	add	r1, sp, #40	; 0x28
   13dd2:	f015 fc82 	bl	296da <bt_mesh_subnet_node_id_get>
	return send_node_id_status(model, ctx, status, idx, node_id);
   13dd6:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   13dda:	9300      	str	r3, [sp, #0]
	status = bt_mesh_subnet_node_id_get(idx, &node_id);
   13ddc:	4602      	mov	r2, r0
	return send_node_id_status(model, ctx, status, idx, node_id);
   13dde:	462b      	mov	r3, r5
   13de0:	4621      	mov	r1, r4
   13de2:	4630      	mov	r0, r6
   13de4:	f7ff f940 	bl	13068 <send_node_id_status>
   13de8:	e7ef      	b.n	13dca <node_identity_get+0x6e>
   13dea:	bf00      	nop
   13dec:	000327c6 	.word	0x000327c6
   13df0:	00032287 	.word	0x00032287
   13df4:	0002dafc 	.word	0x0002dafc
   13df8:	00031bf1 	.word	0x00031bf1

00013dfc <node_identity_set>:
{
   13dfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13e00:	8895      	ldrh	r5, [r2, #4]
   13e02:	f8b1 8000 	ldrh.w	r8, [r1]
   13e06:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13e0a:	f8b1 a004 	ldrh.w	sl, [r1, #4]
{
   13e0e:	b090      	sub	sp, #64	; 0x40
   13e10:	4607      	mov	r7, r0
   13e12:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13e14:	6810      	ldr	r0, [r2, #0]
   13e16:	4629      	mov	r1, r5
{
   13e18:	4616      	mov	r6, r2
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13e1a:	f7f1 f99d 	bl	5158 <bt_hex_real>
   13e1e:	4b27      	ldr	r3, [pc, #156]	; (13ebc <node_identity_set+0xc0>)
   13e20:	f8cd 800c 	str.w	r8, [sp, #12]
   13e24:	9302      	str	r3, [sp, #8]
   13e26:	f04f 0800 	mov.w	r8, #0
   13e2a:	4b25      	ldr	r3, [pc, #148]	; (13ec0 <node_identity_set+0xc4>)
   13e2c:	4925      	ldr	r1, [pc, #148]	; (13ec4 <node_identity_set+0xc8>)
   13e2e:	9301      	str	r3, [sp, #4]
   13e30:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13e34:	4643      	mov	r3, r8
   13e36:	2204      	movs	r2, #4
   13e38:	4640      	mov	r0, r8
   13e3a:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   13e3e:	f8cd 8000 	str.w	r8, [sp]
   13e42:	f7ff faf7 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	idx = net_buf_simple_pull_le16(buf);
   13e46:	4630      	mov	r0, r6
   13e48:	f018 f800 	bl	2be4c <net_buf_simple_pull_le16>
	if (idx > 0xfff) {
   13e4c:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
	idx = net_buf_simple_pull_le16(buf);
   13e50:	4605      	mov	r5, r0
	if (idx > 0xfff) {
   13e52:	d310      	bcc.n	13e76 <node_identity_set+0x7a>
		BT_WARN("Invalid NetKeyIndex 0x%04x", idx);
   13e54:	4b1c      	ldr	r3, [pc, #112]	; (13ec8 <node_identity_set+0xcc>)
   13e56:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
		BT_WARN("Invalid Node ID value 0x%02x", node_id);
   13e5a:	2303      	movs	r3, #3
   13e5c:	4819      	ldr	r0, [pc, #100]	; (13ec4 <node_identity_set+0xc8>)
   13e5e:	9309      	str	r3, [sp, #36]	; 0x24
   13e60:	aa0d      	add	r2, sp, #52	; 0x34
   13e62:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   13e66:	930d      	str	r3, [sp, #52]	; 0x34
   13e68:	f016 f9de 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   13e6c:	f06f 0015 	mvn.w	r0, #21
}
   13e70:	b010      	add	sp, #64	; 0x40
   13e72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	node_id = net_buf_simple_pull_u8(buf);
   13e76:	4630      	mov	r0, r6
   13e78:	f017 ffe0 	bl	2be3c <net_buf_simple_pull_u8>
	if (node_id != 0x00 && node_id != 0x01) {
   13e7c:	2801      	cmp	r0, #1
	node_id = net_buf_simple_pull_u8(buf);
   13e7e:	4606      	mov	r6, r0
	if (node_id != 0x00 && node_id != 0x01) {
   13e80:	d903      	bls.n	13e8a <node_identity_set+0x8e>
		BT_WARN("Invalid Node ID value 0x%02x", node_id);
   13e82:	4b12      	ldr	r3, [pc, #72]	; (13ecc <node_identity_set+0xd0>)
   13e84:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
   13e88:	e7e7      	b.n	13e5a <node_identity_set+0x5e>
	status = bt_mesh_subnet_node_id_set(idx, node_id);
   13e8a:	4601      	mov	r1, r0
   13e8c:	4628      	mov	r0, r5
   13e8e:	f015 fc10 	bl	296b2 <bt_mesh_subnet_node_id_set>
	if (status == STATUS_INVALID_NETKEY) {
   13e92:	2804      	cmp	r0, #4
	status = bt_mesh_subnet_node_id_set(idx, node_id);
   13e94:	4602      	mov	r2, r0
	if (status == STATUS_INVALID_NETKEY) {
   13e96:	d103      	bne.n	13ea0 <node_identity_set+0xa4>
		return send_node_id_status(model, ctx, status, idx,
   13e98:	f8cd 8000 	str.w	r8, [sp]
	return send_node_id_status(model, ctx, status, idx, node_id);
   13e9c:	462b      	mov	r3, r5
   13e9e:	e005      	b.n	13eac <node_identity_set+0xb0>
	if (status == STATUS_FEAT_NOT_SUPP) {
   13ea0:	280a      	cmp	r0, #10
   13ea2:	d108      	bne.n	13eb6 <node_identity_set+0xba>
		return send_node_id_status(model, ctx, STATUS_SUCCESS, idx,
   13ea4:	2302      	movs	r3, #2
   13ea6:	9300      	str	r3, [sp, #0]
   13ea8:	4642      	mov	r2, r8
   13eaa:	462b      	mov	r3, r5
	return send_node_id_status(model, ctx, status, idx, node_id);
   13eac:	4621      	mov	r1, r4
   13eae:	4638      	mov	r0, r7
   13eb0:	f7ff f8da 	bl	13068 <send_node_id_status>
   13eb4:	e7dc      	b.n	13e70 <node_identity_set+0x74>
   13eb6:	9600      	str	r6, [sp, #0]
   13eb8:	e7f0      	b.n	13e9c <node_identity_set+0xa0>
   13eba:	bf00      	nop
   13ebc:	000327d8 	.word	0x000327d8
   13ec0:	00032287 	.word	0x00032287
   13ec4:	0002dafc 	.word	0x0002dafc
   13ec8:	00031bf1 	.word	0x00031bf1
   13ecc:	00032502 	.word	0x00032502

00013ed0 <friend_get>:
{
   13ed0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13ed4:	8896      	ldrh	r6, [r2, #4]
   13ed6:	880f      	ldrh	r7, [r1, #0]
   13ed8:	f8b1 8002 	ldrh.w	r8, [r1, #2]
   13edc:	f8b1 9004 	ldrh.w	r9, [r1, #4]
{
   13ee0:	b089      	sub	sp, #36	; 0x24
   13ee2:	4605      	mov	r5, r0
   13ee4:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13ee6:	6810      	ldr	r0, [r2, #0]
   13ee8:	4631      	mov	r1, r6
   13eea:	f7f1 f935 	bl	5158 <bt_hex_real>
   13eee:	4b0b      	ldr	r3, [pc, #44]	; (13f1c <friend_get+0x4c>)
   13ef0:	9302      	str	r3, [sp, #8]
   13ef2:	4b0b      	ldr	r3, [pc, #44]	; (13f20 <friend_get+0x50>)
   13ef4:	9301      	str	r3, [sp, #4]
   13ef6:	2300      	movs	r3, #0
   13ef8:	e9cd 6006 	strd	r6, r0, [sp, #24]
   13efc:	e9cd 8904 	strd	r8, r9, [sp, #16]
   13f00:	4618      	mov	r0, r3
   13f02:	4908      	ldr	r1, [pc, #32]	; (13f24 <friend_get+0x54>)
   13f04:	9703      	str	r7, [sp, #12]
   13f06:	9300      	str	r3, [sp, #0]
   13f08:	2204      	movs	r2, #4
   13f0a:	f7ff fa93 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	return send_friend_status(model, ctx);
   13f0e:	4621      	mov	r1, r4
   13f10:	4628      	mov	r0, r5
}
   13f12:	b009      	add	sp, #36	; 0x24
   13f14:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return send_friend_status(model, ctx);
   13f18:	f7fe be14 	b.w	12b44 <send_friend_status>
   13f1c:	0003283c 	.word	0x0003283c
   13f20:	00032287 	.word	0x00032287
   13f24:	0002dafc 	.word	0x0002dafc

00013f28 <friend_set>:
{
   13f28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13f2c:	8897      	ldrh	r7, [r2, #4]
   13f2e:	f8b1 8000 	ldrh.w	r8, [r1]
   13f32:	f8b1 9002 	ldrh.w	r9, [r1, #2]
   13f36:	f8b1 a004 	ldrh.w	sl, [r1, #4]
{
   13f3a:	b090      	sub	sp, #64	; 0x40
   13f3c:	4606      	mov	r6, r0
   13f3e:	460c      	mov	r4, r1
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13f40:	6810      	ldr	r0, [r2, #0]
   13f42:	4639      	mov	r1, r7
{
   13f44:	4615      	mov	r5, r2
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13f46:	f7f1 f907 	bl	5158 <bt_hex_real>
   13f4a:	4b18      	ldr	r3, [pc, #96]	; (13fac <friend_set+0x84>)
   13f4c:	9302      	str	r3, [sp, #8]
   13f4e:	4b18      	ldr	r3, [pc, #96]	; (13fb0 <friend_set+0x88>)
   13f50:	9301      	str	r3, [sp, #4]
   13f52:	2300      	movs	r3, #0
   13f54:	e9cd 7006 	strd	r7, r0, [sp, #24]
   13f58:	9300      	str	r3, [sp, #0]
   13f5a:	4618      	mov	r0, r3
   13f5c:	e9cd 9a04 	strd	r9, sl, [sp, #16]
   13f60:	4914      	ldr	r1, [pc, #80]	; (13fb4 <friend_set+0x8c>)
   13f62:	f8cd 800c 	str.w	r8, [sp, #12]
   13f66:	2204      	movs	r2, #4
   13f68:	f7ff fa64 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	if (buf->data[0] != 0x00 && buf->data[0] != 0x01) {
   13f6c:	682b      	ldr	r3, [r5, #0]
   13f6e:	7818      	ldrb	r0, [r3, #0]
   13f70:	2801      	cmp	r0, #1
   13f72:	d808      	bhi.n	13f86 <friend_set+0x5e>
	(void)bt_mesh_friend_set(buf->data[0]);
   13f74:	f7f7 fea6 	bl	bcc4 <bt_mesh_friend_set>
	return send_friend_status(model, ctx);
   13f78:	4621      	mov	r1, r4
   13f7a:	4630      	mov	r0, r6
}
   13f7c:	b010      	add	sp, #64	; 0x40
   13f7e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return send_friend_status(model, ctx);
   13f82:	f7fe bddf 	b.w	12b44 <send_friend_status>
		BT_WARN("Invalid Friend value 0x%02x", buf->data[0]);
   13f86:	4a0c      	ldr	r2, [pc, #48]	; (13fb8 <friend_set+0x90>)
   13f88:	920e      	str	r2, [sp, #56]	; 0x38
   13f8a:	781b      	ldrb	r3, [r3, #0]
   13f8c:	930f      	str	r3, [sp, #60]	; 0x3c
   13f8e:	4809      	ldr	r0, [pc, #36]	; (13fb4 <friend_set+0x8c>)
   13f90:	2303      	movs	r3, #3
   13f92:	aa0d      	add	r2, sp, #52	; 0x34
   13f94:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   13f98:	9309      	str	r3, [sp, #36]	; 0x24
   13f9a:	930d      	str	r3, [sp, #52]	; 0x34
   13f9c:	f016 f944 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   13fa0:	f06f 0015 	mvn.w	r0, #21
   13fa4:	b010      	add	sp, #64	; 0x40
   13fa6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13faa:	bf00      	nop
   13fac:	00032847 	.word	0x00032847
   13fb0:	00032287 	.word	0x00032287
   13fb4:	0002dafc 	.word	0x0002dafc
   13fb8:	0003251f 	.word	0x0003251f

00013fbc <node_reset>:
{
   13fbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13fc0:	8895      	ldrh	r5, [r2, #4]
{
   13fc2:	b095      	sub	sp, #84	; 0x54
   13fc4:	460c      	mov	r4, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_RESET_STATUS, 0);
   13fc6:	ab09      	add	r3, sp, #36	; 0x24
   13fc8:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   13fcc:	e9cd 130c 	strd	r1, r3, [sp, #48]	; 0x30
{
   13fd0:	4606      	mov	r6, r0
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13fd2:	4629      	mov	r1, r5
   13fd4:	6810      	ldr	r0, [r2, #0]
   13fd6:	8827      	ldrh	r7, [r4, #0]
   13fd8:	f8b4 8002 	ldrh.w	r8, [r4, #2]
   13fdc:	f8b4 9004 	ldrh.w	r9, [r4, #4]
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_NODE_RESET_STATUS, 0);
   13fe0:	930b      	str	r3, [sp, #44]	; 0x2c
	BT_DBG("net_idx 0x%04x app_idx 0x%04x src 0x%04x len %u: %s",
   13fe2:	f7f1 f8b9 	bl	5158 <bt_hex_real>
   13fe6:	4b16      	ldr	r3, [pc, #88]	; (14040 <node_reset+0x84>)
   13fe8:	9302      	str	r3, [sp, #8]
   13fea:	e9cd 5006 	strd	r5, r0, [sp, #24]
   13fee:	4b15      	ldr	r3, [pc, #84]	; (14044 <node_reset+0x88>)
   13ff0:	4915      	ldr	r1, [pc, #84]	; (14048 <node_reset+0x8c>)
   13ff2:	9301      	str	r3, [sp, #4]
   13ff4:	2500      	movs	r5, #0
   13ff6:	462b      	mov	r3, r5
   13ff8:	2204      	movs	r2, #4
   13ffa:	4628      	mov	r0, r5
   13ffc:	e9cd 8904 	strd	r8, r9, [sp, #16]
   14000:	9703      	str	r7, [sp, #12]
   14002:	9500      	str	r5, [sp, #0]
   14004:	f7ff fa16 	bl	13434 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_NODE_RESET_STATUS);
   14008:	f248 014a 	movw	r1, #32842	; 0x804a
   1400c:	a80b      	add	r0, sp, #44	; 0x2c
   1400e:	f016 f88a 	bl	2a126 <bt_mesh_model_msg_init>
	if (bt_mesh_model_send(model, ctx, &msg, &reset_cb, NULL)) {
   14012:	4b0e      	ldr	r3, [pc, #56]	; (1404c <node_reset+0x90>)
   14014:	9500      	str	r5, [sp, #0]
   14016:	aa0b      	add	r2, sp, #44	; 0x2c
   14018:	4621      	mov	r1, r4
   1401a:	4630      	mov	r0, r6
   1401c:	f7fc ffaa 	bl	10f74 <bt_mesh_model_send>
   14020:	b150      	cbz	r0, 14038 <node_reset+0x7c>
		BT_ERR("Unable to send Node Reset Status");
   14022:	4b0b      	ldr	r3, [pc, #44]	; (14050 <node_reset+0x94>)
   14024:	9312      	str	r3, [sp, #72]	; 0x48
   14026:	4808      	ldr	r0, [pc, #32]	; (14048 <node_reset+0x8c>)
   14028:	2302      	movs	r3, #2
   1402a:	aa11      	add	r2, sp, #68	; 0x44
   1402c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14030:	9308      	str	r3, [sp, #32]
   14032:	9311      	str	r3, [sp, #68]	; 0x44
   14034:	f016 f8f8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   14038:	2000      	movs	r0, #0
   1403a:	b015      	add	sp, #84	; 0x54
   1403c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14040:	00032825 	.word	0x00032825
   14044:	00032287 	.word	0x00032287
   14048:	0002dafc 	.word	0x0002dafc
   1404c:	0002e684 	.word	0x0002e684
   14050:	0003253b 	.word	0x0003253b

00014054 <hb_pub_send_status>:
{
   14054:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14058:	b091      	sub	sp, #68	; 0x44
   1405a:	af02      	add	r7, sp, #8
   1405c:	4690      	mov	r8, r2
   1405e:	461c      	mov	r4, r3
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_PUB_STATUS, 10);
   14060:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   14064:	f107 0310 	add.w	r3, r7, #16
	BT_DBG("src 0x%04x status 0x%02x", ctx->addr, status);
   14068:	46e9      	mov	r9, sp
   1406a:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_PUB_STATUS, 10);
   1406c:	e9c7 2302 	strd	r2, r3, [r7, #8]
   14070:	607b      	str	r3, [r7, #4]
{
   14072:	460d      	mov	r5, r1
	BT_DBG("src 0x%04x status 0x%02x", ctx->addr, status);
   14074:	888b      	ldrh	r3, [r1, #4]
   14076:	4933      	ldr	r1, [pc, #204]	; (14144 <hb_pub_send_status+0xf0>)
   14078:	9106      	str	r1, [sp, #24]
   1407a:	4933      	ldr	r1, [pc, #204]	; (14148 <hb_pub_send_status+0xf4>)
   1407c:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
   14080:	aa02      	add	r2, sp, #8
   14082:	e9c2 1305 	strd	r1, r3, [r2, #20]
   14086:	2305      	movs	r3, #5
   14088:	f842 3f0c 	str.w	r3, [r2, #12]!
   1408c:	f44f 5124 	mov.w	r1, #10496	; 0x2900
{
   14090:	4606      	mov	r6, r0
	BT_DBG("src 0x%04x status 0x%02x", ctx->addr, status);
   14092:	482e      	ldr	r0, [pc, #184]	; (1414c <hb_pub_send_status+0xf8>)
   14094:	623b      	str	r3, [r7, #32]
   14096:	f016 f8c7 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_HEARTBEAT_PUB_STATUS);
   1409a:	2106      	movs	r1, #6
   1409c:	46cd      	mov	sp, r9
   1409e:	1d38      	adds	r0, r7, #4
   140a0:	f016 f841 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, status);
   140a4:	4641      	mov	r1, r8
   140a6:	1d38      	adds	r0, r7, #4
   140a8:	f017 fe57 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, pub->dst);
   140ac:	8821      	ldrh	r1, [r4, #0]
   140ae:	1d38      	adds	r0, r7, #4
   140b0:	f017 fe5b 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, hb_pub_count_log(pub->count));
   140b4:	8861      	ldrh	r1, [r4, #2]
	if (!val) {
   140b6:	b171      	cbz	r1, 140d6 <hb_pub_send_status+0x82>
	} else if (val == 0x01) {
   140b8:	2901      	cmp	r1, #1
   140ba:	d00c      	beq.n	140d6 <hb_pub_send_status+0x82>
	} else if (val == 0xffff) {
   140bc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   140c0:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val - 1) + 1;
   140c2:	bf1f      	itttt	ne
   140c4:	f101 31ff 	addne.w	r1, r1, #4294967295	; 0xffffffff
   140c8:	fab1 f181 	clzne	r1, r1
   140cc:	f1c1 0121 	rsbne	r1, r1, #33	; 0x21
   140d0:	b2c9      	uxtbne	r1, r1
		return 0xff;
   140d2:	bf08      	it	eq
   140d4:	21ff      	moveq	r1, #255	; 0xff
	net_buf_simple_add_u8(&msg, hb_pub_count_log(pub->count));
   140d6:	1d38      	adds	r0, r7, #4
   140d8:	f017 fe3f 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_hb_log(pub->period));
   140dc:	68e1      	ldr	r1, [r4, #12]
	if (!val) {
   140de:	b149      	cbz	r1, 140f4 <hb_pub_send_status+0xa0>
	} else if (val == 0xffff) {
   140e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   140e4:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val);
   140e6:	bf1d      	ittte	ne
   140e8:	fab1 f181 	clzne	r1, r1
   140ec:	f1c1 0120 	rsbne	r1, r1, #32
   140f0:	b2c9      	uxtbne	r1, r1
		return 0xff;
   140f2:	21ff      	moveq	r1, #255	; 0xff
   140f4:	1d38      	adds	r0, r7, #4
   140f6:	f017 fe30 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, pub->ttl);
   140fa:	7921      	ldrb	r1, [r4, #4]
   140fc:	1d38      	adds	r0, r7, #4
   140fe:	f017 fe2c 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, pub->feat);
   14102:	88e1      	ldrh	r1, [r4, #6]
   14104:	1d38      	adds	r0, r7, #4
   14106:	f017 fe30 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, pub->net_idx);
   1410a:	8921      	ldrh	r1, [r4, #8]
   1410c:	1d38      	adds	r0, r7, #4
   1410e:	f017 fe2c 	bl	2bd6a <net_buf_simple_add_le16>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   14112:	2300      	movs	r3, #0
   14114:	9300      	str	r3, [sp, #0]
   14116:	1d3a      	adds	r2, r7, #4
   14118:	4629      	mov	r1, r5
   1411a:	4630      	mov	r0, r6
   1411c:	f7fc ff2a 	bl	10f74 <bt_mesh_model_send>
   14120:	b158      	cbz	r0, 1413a <hb_pub_send_status+0xe6>
		BT_ERR("Unable to send Heartbeat Publication Status");
   14122:	4b0b      	ldr	r3, [pc, #44]	; (14150 <hb_pub_send_status+0xfc>)
   14124:	633b      	str	r3, [r7, #48]	; 0x30
   14126:	4809      	ldr	r0, [pc, #36]	; (1414c <hb_pub_send_status+0xf8>)
   14128:	2302      	movs	r3, #2
   1412a:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   1412e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14132:	603b      	str	r3, [r7, #0]
   14134:	62fb      	str	r3, [r7, #44]	; 0x2c
   14136:	f016 f877 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   1413a:	2000      	movs	r0, #0
   1413c:	373c      	adds	r7, #60	; 0x3c
   1413e:	46bd      	mov	sp, r7
   14140:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14144:	0003255c 	.word	0x0003255c
   14148:	0003287c 	.word	0x0003287c
   1414c:	0002dafc 	.word	0x0002dafc
   14150:	00032579 	.word	0x00032579

00014154 <heartbeat_pub_set>:
{
   14154:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14158:	b08c      	sub	sp, #48	; 0x30
	BT_DBG("src 0x%04x", ctx->addr);
   1415a:	46e8      	mov	r8, sp
{
   1415c:	af00      	add	r7, sp, #0
	BT_DBG("src 0x%04x", ctx->addr);
   1415e:	b088      	sub	sp, #32
	struct hb_pub_param *param = (void *)buf->data;
   14160:	6814      	ldr	r4, [r2, #0]
	BT_DBG("src 0x%04x", ctx->addr);
   14162:	888b      	ldrh	r3, [r1, #4]
   14164:	466a      	mov	r2, sp
{
   14166:	460d      	mov	r5, r1
	BT_DBG("src 0x%04x", ctx->addr);
   14168:	4931      	ldr	r1, [pc, #196]	; (14230 <heartbeat_pub_set+0xdc>)
   1416a:	6111      	str	r1, [r2, #16]
   1416c:	4931      	ldr	r1, [pc, #196]	; (14234 <heartbeat_pub_set+0xe0>)
   1416e:	e9c2 1305 	strd	r1, r3, [r2, #20]
   14172:	2304      	movs	r3, #4
   14174:	f842 3f0c 	str.w	r3, [r2, #12]!
   14178:	f44f 5104 	mov.w	r1, #8448	; 0x2100
{
   1417c:	4606      	mov	r6, r0
	BT_DBG("src 0x%04x", ctx->addr);
   1417e:	482e      	ldr	r0, [pc, #184]	; (14238 <heartbeat_pub_set+0xe4>)
   14180:	61bb      	str	r3, [r7, #24]
   14182:	f016 f851 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	pub.count = bt_mesh_hb_pwr2(param->count_log);
   14186:	78a2      	ldrb	r2, [r4, #2]
	pub.dst = sys_le16_to_cpu(param->dst);
   14188:	8823      	ldrh	r3, [r4, #0]
   1418a:	813b      	strh	r3, [r7, #8]
   1418c:	46c5      	mov	sp, r8
	pub.count = bt_mesh_hb_pwr2(param->count_log);
   1418e:	4610      	mov	r0, r2
	pub.dst = sys_le16_to_cpu(param->dst);
   14190:	b299      	uxth	r1, r3
	pub.count = bt_mesh_hb_pwr2(param->count_log);
   14192:	f016 f810 	bl	2a1b6 <bt_mesh_hb_pwr2>
   14196:	8178      	strh	r0, [r7, #10]
	pub.period = bt_mesh_hb_pwr2(param->period_log);
   14198:	f894 8003 	ldrb.w	r8, [r4, #3]
   1419c:	4640      	mov	r0, r8
   1419e:	f016 f80a 	bl	2a1b6 <bt_mesh_hb_pwr2>
   141a2:	6178      	str	r0, [r7, #20]
	pub.ttl = param->ttl;
   141a4:	7923      	ldrb	r3, [r4, #4]
   141a6:	733b      	strb	r3, [r7, #12]
	pub.feat = sys_le16_to_cpu(param->feat);
   141a8:	7960      	ldrb	r0, [r4, #5]
   141aa:	f894 c006 	ldrb.w	ip, [r4, #6]
   141ae:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
   141b2:	81f8      	strh	r0, [r7, #14]
	pub.net_idx = sys_le16_to_cpu(param->net_idx);
   141b4:	f8b4 4007 	ldrh.w	r4, [r4, #7]
   141b8:	823c      	strh	r4, [r7, #16]
	if (BT_MESH_ADDR_IS_VIRTUAL(pub.dst)) {
   141ba:	f481 4100 	eor.w	r1, r1, #32768	; 0x8000
   141be:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
	pub.net_idx = sys_le16_to_cpu(param->net_idx);
   141c2:	b2a0      	uxth	r0, r4
	if (BT_MESH_ADDR_IS_VIRTUAL(pub.dst)) {
   141c4:	d330      	bcc.n	14228 <heartbeat_pub_set+0xd4>
	if (param->count_log > 0x11 && param->count_log != 0xff) {
   141c6:	3a12      	subs	r2, #18
   141c8:	b2d2      	uxtb	r2, r2
   141ca:	2aec      	cmp	r2, #236	; 0xec
   141cc:	d92e      	bls.n	1422c <heartbeat_pub_set+0xd8>
	if (param->period_log > 0x10) {
   141ce:	f1b8 0f10 	cmp.w	r8, #16
   141d2:	d82b      	bhi.n	1422c <heartbeat_pub_set+0xd8>
	if (param->ttl > BT_MESH_TTL_MAX && param->ttl != BT_MESH_TTL_DEFAULT) {
   141d4:	f083 0280 	eor.w	r2, r3, #128	; 0x80
   141d8:	2a7e      	cmp	r2, #126	; 0x7e
   141da:	d812      	bhi.n	14202 <heartbeat_pub_set+0xae>
		BT_ERR("Invalid TTL value 0x%02x", param->ttl);
   141dc:	4a17      	ldr	r2, [pc, #92]	; (1423c <heartbeat_pub_set+0xe8>)
   141de:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
		BT_ERR("Invalid NetKeyIndex 0x%04x", pub.net_idx);
   141e2:	2303      	movs	r3, #3
   141e4:	4814      	ldr	r0, [pc, #80]	; (14238 <heartbeat_pub_set+0xe4>)
   141e6:	607b      	str	r3, [r7, #4]
   141e8:	f107 0224 	add.w	r2, r7, #36	; 0x24
   141ec:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   141f0:	627b      	str	r3, [r7, #36]	; 0x24
   141f2:	f016 f819 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   141f6:	f06f 0015 	mvn.w	r0, #21
}
   141fa:	3730      	adds	r7, #48	; 0x30
   141fc:	46bd      	mov	sp, r7
   141fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (pub.net_idx > 0xfff) {
   14202:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   14206:	d303      	bcc.n	14210 <heartbeat_pub_set+0xbc>
		BT_ERR("Invalid NetKeyIndex 0x%04x", pub.net_idx);
   14208:	4b0d      	ldr	r3, [pc, #52]	; (14240 <heartbeat_pub_set+0xec>)
   1420a:	e9c7 300a 	strd	r3, r0, [r7, #40]	; 0x28
   1420e:	e7e8      	b.n	141e2 <heartbeat_pub_set+0x8e>
	status = bt_mesh_hb_pub_set(&pub);
   14210:	f107 0008 	add.w	r0, r7, #8
   14214:	f7fb feee 	bl	fff4 <bt_mesh_hb_pub_set>
   14218:	4602      	mov	r2, r0
	return hb_pub_send_status(model, ctx, status, &pub);
   1421a:	f107 0308 	add.w	r3, r7, #8
   1421e:	4629      	mov	r1, r5
   14220:	4630      	mov	r0, r6
   14222:	f7ff ff17 	bl	14054 <hb_pub_send_status>
   14226:	e7e8      	b.n	141fa <heartbeat_pub_set+0xa6>
		status = STATUS_INVALID_ADDRESS;
   14228:	2201      	movs	r2, #1
   1422a:	e7f6      	b.n	1421a <heartbeat_pub_set+0xc6>
		status = STATUS_CANNOT_SET;
   1422c:	220f      	movs	r2, #15
   1422e:	e7f4      	b.n	1421a <heartbeat_pub_set+0xc6>
   14230:	000325a5 	.word	0x000325a5
   14234:	0003288f 	.word	0x0003288f
   14238:	0002dafc 	.word	0x0002dafc
   1423c:	00031f66 	.word	0x00031f66
   14240:	00031bf1 	.word	0x00031bf1

00014244 <heartbeat_pub_get>:
{
   14244:	b5f0      	push	{r4, r5, r6, r7, lr}
   14246:	b085      	sub	sp, #20
	BT_DBG("src 0x%04x", ctx->addr);
   14248:	466e      	mov	r6, sp
{
   1424a:	af00      	add	r7, sp, #0
	BT_DBG("src 0x%04x", ctx->addr);
   1424c:	b088      	sub	sp, #32
   1424e:	466a      	mov	r2, sp
   14250:	888b      	ldrh	r3, [r1, #4]
{
   14252:	460c      	mov	r4, r1
	BT_DBG("src 0x%04x", ctx->addr);
   14254:	490d      	ldr	r1, [pc, #52]	; (1428c <heartbeat_pub_get+0x48>)
   14256:	6111      	str	r1, [r2, #16]
   14258:	490d      	ldr	r1, [pc, #52]	; (14290 <heartbeat_pub_get+0x4c>)
   1425a:	e9c2 1305 	strd	r1, r3, [r2, #20]
   1425e:	2304      	movs	r3, #4
   14260:	f842 3f0c 	str.w	r3, [r2, #12]!
{
   14264:	4605      	mov	r5, r0
	BT_DBG("src 0x%04x", ctx->addr);
   14266:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1426a:	480a      	ldr	r0, [pc, #40]	; (14294 <heartbeat_pub_get+0x50>)
   1426c:	603b      	str	r3, [r7, #0]
   1426e:	f015 ffdb 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_hb_pub_get(&pub);
   14272:	4638      	mov	r0, r7
   14274:	46b5      	mov	sp, r6
   14276:	f7fb ff4f 	bl	10118 <bt_mesh_hb_pub_get>
	return hb_pub_send_status(model, ctx, STATUS_SUCCESS, &pub);
   1427a:	463b      	mov	r3, r7
   1427c:	2200      	movs	r2, #0
   1427e:	4621      	mov	r1, r4
   14280:	4628      	mov	r0, r5
   14282:	f7ff fee7 	bl	14054 <hb_pub_send_status>
}
   14286:	3714      	adds	r7, #20
   14288:	46bd      	mov	sp, r7
   1428a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1428c:	000325a5 	.word	0x000325a5
   14290:	0003286a 	.word	0x0003286a
   14294:	0002dafc 	.word	0x0002dafc

00014298 <hb_sub_send_status>:
{
   14298:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1429c:	b090      	sub	sp, #64	; 0x40
   1429e:	af02      	add	r7, sp, #8
   142a0:	4614      	mov	r4, r2
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_SUB_STATUS, 9);
   142a2:	f107 0310 	add.w	r3, r7, #16
   142a6:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
	BT_DBG("src 0x%04x ", ctx->addr);
   142aa:	46e8      	mov	r8, sp
   142ac:	b088      	sub	sp, #32
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_SUB_STATUS, 9);
   142ae:	e9c7 2302 	strd	r2, r3, [r7, #8]
	BT_DBG("src 0x%04x ", ctx->addr);
   142b2:	aa02      	add	r2, sp, #8
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEARTBEAT_SUB_STATUS, 9);
   142b4:	607b      	str	r3, [r7, #4]
{
   142b6:	460d      	mov	r5, r1
	BT_DBG("src 0x%04x ", ctx->addr);
   142b8:	888b      	ldrh	r3, [r1, #4]
   142ba:	4930      	ldr	r1, [pc, #192]	; (1437c <hb_sub_send_status+0xe4>)
   142bc:	6111      	str	r1, [r2, #16]
   142be:	4930      	ldr	r1, [pc, #192]	; (14380 <hb_sub_send_status+0xe8>)
   142c0:	e9c2 1305 	strd	r1, r3, [r2, #20]
   142c4:	2304      	movs	r3, #4
   142c6:	f842 3f0c 	str.w	r3, [r2, #12]!
   142ca:	f44f 5104 	mov.w	r1, #8448	; 0x2100
{
   142ce:	4606      	mov	r6, r0
	BT_DBG("src 0x%04x ", ctx->addr);
   142d0:	482c      	ldr	r0, [pc, #176]	; (14384 <hb_sub_send_status+0xec>)
   142d2:	623b      	str	r3, [r7, #32]
   142d4:	f015 ffa8 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_HEARTBEAT_SUB_STATUS);
   142d8:	f248 013c 	movw	r1, #32828	; 0x803c
   142dc:	46c5      	mov	sp, r8
   142de:	1d38      	adds	r0, r7, #4
   142e0:	f015 ff21 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, STATUS_SUCCESS);
   142e4:	2100      	movs	r1, #0
   142e6:	1d38      	adds	r0, r7, #4
   142e8:	f017 fd37 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(&msg, sub->src);
   142ec:	8921      	ldrh	r1, [r4, #8]
   142ee:	1d38      	adds	r0, r7, #4
   142f0:	f017 fd3b 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(&msg, sub->dst);
   142f4:	8961      	ldrh	r1, [r4, #10]
   142f6:	1d38      	adds	r0, r7, #4
   142f8:	f017 fd37 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(&msg, bt_mesh_hb_log(sub->remaining));
   142fc:	6861      	ldr	r1, [r4, #4]
	if (!val) {
   142fe:	b149      	cbz	r1, 14314 <hb_sub_send_status+0x7c>
	} else if (val == 0xffff) {
   14300:	f64f 73ff 	movw	r3, #65535	; 0xffff
   14304:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val);
   14306:	bf1d      	ittte	ne
   14308:	fab1 f181 	clzne	r1, r1
   1430c:	f1c1 0120 	rsbne	r1, r1, #32
   14310:	b2c9      	uxtbne	r1, r1
		return 0xff;
   14312:	21ff      	moveq	r1, #255	; 0xff
   14314:	1d38      	adds	r0, r7, #4
   14316:	f017 fd20 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, bt_mesh_hb_log(sub->count));
   1431a:	89a1      	ldrh	r1, [r4, #12]
	if (!val) {
   1431c:	b149      	cbz	r1, 14332 <hb_sub_send_status+0x9a>
	} else if (val == 0xffff) {
   1431e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   14322:	4299      	cmp	r1, r3
		return 32 - __builtin_clz(val);
   14324:	bf1d      	ittte	ne
   14326:	fab1 f181 	clzne	r1, r1
   1432a:	f1c1 0120 	rsbne	r1, r1, #32
   1432e:	b2c9      	uxtbne	r1, r1
		return 0xff;
   14330:	21ff      	moveq	r1, #255	; 0xff
   14332:	1d38      	adds	r0, r7, #4
   14334:	f017 fd11 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, sub->min_hops);
   14338:	7ba1      	ldrb	r1, [r4, #14]
   1433a:	1d38      	adds	r0, r7, #4
   1433c:	f017 fd0d 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&msg, sub->max_hops);
   14340:	7be1      	ldrb	r1, [r4, #15]
   14342:	1d38      	adds	r0, r7, #4
   14344:	f017 fd09 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   14348:	2300      	movs	r3, #0
   1434a:	9300      	str	r3, [sp, #0]
   1434c:	1d3a      	adds	r2, r7, #4
   1434e:	4629      	mov	r1, r5
   14350:	4630      	mov	r0, r6
   14352:	f7fc fe0f 	bl	10f74 <bt_mesh_model_send>
   14356:	b158      	cbz	r0, 14370 <hb_sub_send_status+0xd8>
		BT_ERR("Unable to send Heartbeat Subscription Status");
   14358:	4b0b      	ldr	r3, [pc, #44]	; (14388 <hb_sub_send_status+0xf0>)
   1435a:	633b      	str	r3, [r7, #48]	; 0x30
   1435c:	4809      	ldr	r0, [pc, #36]	; (14384 <hb_sub_send_status+0xec>)
   1435e:	2302      	movs	r3, #2
   14360:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   14364:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14368:	603b      	str	r3, [r7, #0]
   1436a:	62fb      	str	r3, [r7, #44]	; 0x2c
   1436c:	f015 ff5c 	bl	2a228 <z_log_msg2_static_create.constprop.0>
}
   14370:	2000      	movs	r0, #0
   14372:	3738      	adds	r7, #56	; 0x38
   14374:	46bd      	mov	sp, r7
   14376:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1437a:	bf00      	nop
   1437c:	000325b4 	.word	0x000325b4
   14380:	000328b3 	.word	0x000328b3
   14384:	0002dafc 	.word	0x0002dafc
   14388:	000325c4 	.word	0x000325c4

0001438c <heartbeat_sub_set>:
{
   1438c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14390:	b089      	sub	sp, #36	; 0x24
	BT_DBG("src 0x%04x", ctx->addr);
   14392:	888b      	ldrh	r3, [r1, #4]
   14394:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 14478 <heartbeat_sub_set+0xec>
{
   14398:	af00      	add	r7, sp, #0
	BT_DBG("src 0x%04x", ctx->addr);
   1439a:	46ea      	mov	sl, sp
   1439c:	b088      	sub	sp, #32
{
   1439e:	4614      	mov	r4, r2
	BT_DBG("src 0x%04x", ctx->addr);
   143a0:	466a      	mov	r2, sp
   143a2:	e9c2 b305 	strd	fp, r3, [r2, #20]
{
   143a6:	460d      	mov	r5, r1
	BT_DBG("src 0x%04x", ctx->addr);
   143a8:	2304      	movs	r3, #4
   143aa:	4934      	ldr	r1, [pc, #208]	; (1447c <heartbeat_sub_set+0xf0>)
   143ac:	6111      	str	r1, [r2, #16]
{
   143ae:	4681      	mov	r9, r0
	BT_DBG("src 0x%04x", ctx->addr);
   143b0:	f842 3f0c 	str.w	r3, [r2, #12]!
   143b4:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   143b8:	4831      	ldr	r0, [pc, #196]	; (14480 <heartbeat_sub_set+0xf4>)
   143ba:	60bb      	str	r3, [r7, #8]
   143bc:	f015 ff34 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	sub_src = net_buf_simple_pull_le16(buf);
   143c0:	4620      	mov	r0, r4
   143c2:	46d5      	mov	sp, sl
   143c4:	f017 fd42 	bl	2be4c <net_buf_simple_pull_le16>
   143c8:	4606      	mov	r6, r0
	sub_dst = net_buf_simple_pull_le16(buf);
   143ca:	4620      	mov	r0, r4
   143cc:	f017 fd3e 	bl	2be4c <net_buf_simple_pull_le16>
   143d0:	4680      	mov	r8, r0
	period_log = net_buf_simple_pull_u8(buf);
   143d2:	4620      	mov	r0, r4
   143d4:	f017 fd32 	bl	2be3c <net_buf_simple_pull_u8>
	BT_DBG("sub_src 0x%04x sub_dst 0x%04x period 0x%02x",
   143d8:	b08a      	sub	sp, #40	; 0x28
   143da:	4b2a      	ldr	r3, [pc, #168]	; (14484 <heartbeat_sub_set+0xf8>)
   143dc:	466a      	mov	r2, sp
   143de:	e9c2 3b04 	strd	r3, fp, [r2, #16]
   143e2:	2306      	movs	r3, #6
   143e4:	6210      	str	r0, [r2, #32]
   143e6:	e9c2 6806 	strd	r6, r8, [r2, #24]
	period_log = net_buf_simple_pull_u8(buf);
   143ea:	4604      	mov	r4, r0
	BT_DBG("sub_src 0x%04x sub_dst 0x%04x period 0x%02x",
   143ec:	f842 3f0c 	str.w	r3, [r2, #12]!
   143f0:	4823      	ldr	r0, [pc, #140]	; (14480 <heartbeat_sub_set+0xf4>)
   143f2:	60bb      	str	r3, [r7, #8]
   143f4:	f44f 5144 	mov.w	r1, #12544	; 0x3100
   143f8:	f015 ff16 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	if (period_log > 0x11) {
   143fc:	2c11      	cmp	r4, #17
   143fe:	46d5      	mov	sp, sl
   14400:	d90f      	bls.n	14422 <heartbeat_sub_set+0x96>
		BT_WARN("Prohibited subscription period 0x%02x", period_log);
   14402:	4b21      	ldr	r3, [pc, #132]	; (14488 <heartbeat_sub_set+0xfc>)
   14404:	481e      	ldr	r0, [pc, #120]	; (14480 <heartbeat_sub_set+0xf4>)
   14406:	e9c7 3406 	strd	r3, r4, [r7, #24]
   1440a:	f107 0214 	add.w	r2, r7, #20
   1440e:	2303      	movs	r3, #3
   14410:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   14414:	607b      	str	r3, [r7, #4]
   14416:	617b      	str	r3, [r7, #20]
   14418:	f015 ff06 	bl	2a228 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   1441c:	f06f 0415 	mvn.w	r4, #21
   14420:	e024      	b.n	1446c <heartbeat_sub_set+0xe0>
	period = bt_mesh_hb_pwr2(period_log);
   14422:	4620      	mov	r0, r4
   14424:	f015 fec7 	bl	2a1b6 <bt_mesh_hb_pwr2>
	status = bt_mesh_hb_sub_set(sub_src, sub_dst, period);
   14428:	4641      	mov	r1, r8
	period = bt_mesh_hb_pwr2(period_log);
   1442a:	4682      	mov	sl, r0
	status = bt_mesh_hb_sub_set(sub_src, sub_dst, period);
   1442c:	4602      	mov	r2, r0
   1442e:	4630      	mov	r0, r6
   14430:	f7fb fe7c 	bl	1012c <bt_mesh_hb_sub_set>
	if (status != STATUS_SUCCESS) {
   14434:	2800      	cmp	r0, #0
   14436:	d1f1      	bne.n	1441c <heartbeat_sub_set+0x90>
	bt_mesh_hb_sub_get(&sub);
   14438:	f107 0008 	add.w	r0, r7, #8
   1443c:	f7fb feea 	bl	10214 <bt_mesh_hb_sub_get>
	if (sub.src == BT_MESH_ADDR_UNASSIGNED || !period_log) {
   14440:	8a3b      	ldrh	r3, [r7, #16]
   14442:	b103      	cbz	r3, 14446 <heartbeat_sub_set+0xba>
   14444:	b90c      	cbnz	r4, 1444a <heartbeat_sub_set+0xbe>
		sub.min_hops = BT_MESH_TTL_MAX;
   14446:	237f      	movs	r3, #127	; 0x7f
   14448:	75bb      	strb	r3, [r7, #22]
	err = hb_sub_send_status(model, ctx, &sub);
   1444a:	f107 0208 	add.w	r2, r7, #8
   1444e:	4629      	mov	r1, r5
   14450:	4648      	mov	r0, r9
   14452:	f7ff ff21 	bl	14298 <hb_sub_send_status>
	if (err) {
   14456:	4604      	mov	r4, r0
   14458:	b940      	cbnz	r0, 1446c <heartbeat_sub_set+0xe0>
	if (sub.src != BT_MESH_ADDR_UNASSIGNED &&
   1445a:	8a3b      	ldrh	r3, [r7, #16]
   1445c:	b133      	cbz	r3, 1446c <heartbeat_sub_set+0xe0>
   1445e:	8a7b      	ldrh	r3, [r7, #18]
   14460:	b123      	cbz	r3, 1446c <heartbeat_sub_set+0xe0>
	    sub.dst != BT_MESH_ADDR_UNASSIGNED && !period) {
   14462:	f1ba 0f00 	cmp.w	sl, #0
   14466:	d101      	bne.n	1446c <heartbeat_sub_set+0xe0>
		bt_mesh_hb_sub_reset_count();
   14468:	f7fb fece 	bl	10208 <bt_mesh_hb_sub_reset_count>
}
   1446c:	4620      	mov	r0, r4
   1446e:	3724      	adds	r7, #36	; 0x24
   14470:	46bd      	mov	sp, r7
   14472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14476:	bf00      	nop
   14478:	000328c6 	.word	0x000328c6
   1447c:	000325a5 	.word	0x000325a5
   14480:	0002dafc 	.word	0x0002dafc
   14484:	000325f1 	.word	0x000325f1
   14488:	00032621 	.word	0x00032621

0001448c <heartbeat_sub_get>:
{
   1448c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1448e:	b085      	sub	sp, #20
	BT_DBG("src 0x%04x", ctx->addr);
   14490:	466e      	mov	r6, sp
{
   14492:	af00      	add	r7, sp, #0
	BT_DBG("src 0x%04x", ctx->addr);
   14494:	b088      	sub	sp, #32
   14496:	466a      	mov	r2, sp
   14498:	888b      	ldrh	r3, [r1, #4]
{
   1449a:	460c      	mov	r4, r1
	BT_DBG("src 0x%04x", ctx->addr);
   1449c:	490d      	ldr	r1, [pc, #52]	; (144d4 <heartbeat_sub_get+0x48>)
   1449e:	6111      	str	r1, [r2, #16]
   144a0:	490d      	ldr	r1, [pc, #52]	; (144d8 <heartbeat_sub_get+0x4c>)
   144a2:	e9c2 1305 	strd	r1, r3, [r2, #20]
   144a6:	2304      	movs	r3, #4
   144a8:	f842 3f0c 	str.w	r3, [r2, #12]!
{
   144ac:	4605      	mov	r5, r0
	BT_DBG("src 0x%04x", ctx->addr);
   144ae:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   144b2:	480a      	ldr	r0, [pc, #40]	; (144dc <heartbeat_sub_get+0x50>)
   144b4:	603b      	str	r3, [r7, #0]
   144b6:	f015 feb7 	bl	2a228 <z_log_msg2_static_create.constprop.0>
	bt_mesh_hb_sub_get(&sub);
   144ba:	4638      	mov	r0, r7
   144bc:	46b5      	mov	sp, r6
   144be:	f7fb fea9 	bl	10214 <bt_mesh_hb_sub_get>
	return hb_sub_send_status(model, ctx, &sub);
   144c2:	463a      	mov	r2, r7
   144c4:	4621      	mov	r1, r4
   144c6:	4628      	mov	r0, r5
   144c8:	f7ff fee6 	bl	14298 <hb_sub_send_status>
}
   144cc:	3714      	adds	r7, #20
   144ce:	46bd      	mov	sp, r7
   144d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   144d2:	bf00      	nop
   144d4:	000325a5 	.word	0x000325a5
   144d8:	000328a1 	.word	0x000328a1
   144dc:	0002dafc 	.word	0x0002dafc

000144e0 <bt_mesh_model_reset>:
	}
}

void bt_mesh_model_reset(void)
{
	bt_mesh_model_foreach(mod_reset, NULL);
   144e0:	4801      	ldr	r0, [pc, #4]	; (144e8 <bt_mesh_model_reset+0x8>)
   144e2:	2100      	movs	r1, #0
   144e4:	f7fc b9bc 	b.w	10860 <bt_mesh_model_foreach>
   144e8:	0002a241 	.word	0x0002a241

000144ec <health_srv_init>:
		srv->cb->attn_off(srv->model);
	}
}

static int health_srv_init(struct bt_mesh_model *model)
{
   144ec:	b530      	push	{r4, r5, lr}
	struct bt_mesh_health_srv *srv = model->user_data;
   144ee:	6a05      	ldr	r5, [r0, #32]
{
   144f0:	b089      	sub	sp, #36	; 0x24
   144f2:	4604      	mov	r4, r0

	if (!srv) {
   144f4:	b975      	cbnz	r5, 14514 <health_srv_init+0x28>
		BT_ERR("No Health Server context provided");
   144f6:	4b11      	ldr	r3, [pc, #68]	; (1453c <health_srv_init+0x50>)
		return -EINVAL;
	}

	if (!model->pub) {
		BT_ERR("Health Server has no publication support");
   144f8:	4811      	ldr	r0, [pc, #68]	; (14540 <health_srv_init+0x54>)
   144fa:	9306      	str	r3, [sp, #24]
   144fc:	aa05      	add	r2, sp, #20
   144fe:	2302      	movs	r3, #2
   14500:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14504:	9301      	str	r3, [sp, #4]
   14506:	9305      	str	r3, [sp, #20]
   14508:	f015 feab 	bl	2a262 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   1450c:	f06f 0015 	mvn.w	r0, #21
	if (bt_mesh_model_in_primary(model)) {
		health_srv = srv;
	}

	return 0;
}
   14510:	b009      	add	sp, #36	; 0x24
   14512:	bd30      	pop	{r4, r5, pc}
	if (!model->pub) {
   14514:	6883      	ldr	r3, [r0, #8]
   14516:	b90b      	cbnz	r3, 1451c <health_srv_init+0x30>
		BT_ERR("Health Server has no publication support");
   14518:	4b0a      	ldr	r3, [pc, #40]	; (14544 <health_srv_init+0x58>)
   1451a:	e7ed      	b.n	144f8 <health_srv_init+0xc>
	model->pub->update = health_pub_update;
   1451c:	4a0a      	ldr	r2, [pc, #40]	; (14548 <health_srv_init+0x5c>)
	k_work_init_delayable(&srv->attn_timer, attention_off);
   1451e:	490b      	ldr	r1, [pc, #44]	; (1454c <health_srv_init+0x60>)
	model->pub->update = health_pub_update;
   14520:	615a      	str	r2, [r3, #20]
	k_work_init_delayable(&srv->attn_timer, attention_off);
   14522:	f105 0008 	add.w	r0, r5, #8
   14526:	f018 fc60 	bl	2cdea <k_work_init_delayable>
	srv->model = model;
   1452a:	602c      	str	r4, [r5, #0]
	if (bt_mesh_model_in_primary(model)) {
   1452c:	7920      	ldrb	r0, [r4, #4]
   1452e:	b910      	cbnz	r0, 14536 <health_srv_init+0x4a>
		health_srv = srv;
   14530:	4b07      	ldr	r3, [pc, #28]	; (14550 <health_srv_init+0x64>)
   14532:	601d      	str	r5, [r3, #0]
   14534:	e7ec      	b.n	14510 <health_srv_init+0x24>
	return 0;
   14536:	2000      	movs	r0, #0
   14538:	e7ea      	b.n	14510 <health_srv_init+0x24>
   1453a:	bf00      	nop
   1453c:	00032935 	.word	0x00032935
   14540:	0002db24 	.word	0x0002db24
   14544:	00032957 	.word	0x00032957
   14548:	00014555 	.word	0x00014555
   1454c:	00014b01 	.word	0x00014b01
   14550:	20002784 	.word	0x20002784

00014554 <health_pub_update>:
{
   14554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14558:	b08b      	sub	sp, #44	; 0x2c
	struct bt_mesh_model_pub *pub = mod->pub;
   1455a:	f8d0 9008 	ldr.w	r9, [r0, #8]
	BT_DBG("");
   1455e:	4b3d      	ldr	r3, [pc, #244]	; (14654 <health_pub_update+0x100>)
   14560:	9308      	str	r3, [sp, #32]
   14562:	aa07      	add	r2, sp, #28
   14564:	4b3c      	ldr	r3, [pc, #240]	; (14658 <health_pub_update+0x104>)
   14566:	9309      	str	r3, [sp, #36]	; 0x24
{
   14568:	4607      	mov	r7, r0
	BT_DBG("");
   1456a:	f04f 0a03 	mov.w	sl, #3
   1456e:	483b      	ldr	r0, [pc, #236]	; (1465c <health_pub_update+0x108>)
   14570:	f8cd a00c 	str.w	sl, [sp, #12]
   14574:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14578:	f8cd a01c 	str.w	sl, [sp, #28]
   1457c:	f015 fe71 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	count = health_get_current(mod, pub->msg);
   14580:	f8d9 5010 	ldr.w	r5, [r9, #16]
	struct bt_mesh_health_srv *srv = mod->user_data;
   14584:	f8d7 b020 	ldr.w	fp, [r7, #32]
	bt_mesh_model_msg_init(msg, OP_HEALTH_CURRENT_STATUS);
   14588:	2104      	movs	r1, #4
   1458a:	4628      	mov	r0, r5
   1458c:	f015 fdcb 	bl	2a126 <bt_mesh_model_msg_init>
	test_id = net_buf_simple_add(msg, 1);
   14590:	2101      	movs	r1, #1
   14592:	4628      	mov	r0, r5
   14594:	f017 fbd2 	bl	2bd3c <net_buf_simple_add>
	company_ptr = net_buf_simple_add(msg, sizeof(company_id));
   14598:	2102      	movs	r1, #2
	test_id = net_buf_simple_add(msg, 1);
   1459a:	4606      	mov	r6, r0
	company_ptr = net_buf_simple_add(msg, sizeof(company_id));
   1459c:	4628      	mov	r0, r5
   1459e:	f017 fbcd 	bl	2bd3c <net_buf_simple_add>
   145a2:	4604      	mov	r4, r0
	comp = bt_mesh_comp_get();
   145a4:	f7fc fd12 	bl	10fcc <bt_mesh_comp_get>
	if (srv->cb && srv->cb->fault_get_cur) {
   145a8:	f8db 3004 	ldr.w	r3, [fp, #4]
	comp = bt_mesh_comp_get();
   145ac:	4680      	mov	r8, r0
	if (srv->cb && srv->cb->fault_get_cur) {
   145ae:	2b00      	cmp	r3, #0
   145b0:	d047      	beq.n	14642 <health_pub_update+0xee>
   145b2:	681b      	ldr	r3, [r3, #0]
   145b4:	2b00      	cmp	r3, #0
   145b6:	d044      	beq.n	14642 <health_pub_update+0xee>
		fault_count = net_buf_simple_tailroom(msg);
   145b8:	4628      	mov	r0, r5
   145ba:	f017 fc66 	bl	2be8a <net_buf_simple_tailroom>
   145be:	f88d 0009 	strb.w	r0, [sp, #9]
	return buf->data + buf->len;
   145c2:	682a      	ldr	r2, [r5, #0]
		err = srv->cb->fault_get_cur(mod, test_id, &company_id,
   145c4:	f8db 1004 	ldr.w	r1, [fp, #4]
   145c8:	88ab      	ldrh	r3, [r5, #4]
   145ca:	f10d 0009 	add.w	r0, sp, #9
   145ce:	9000      	str	r0, [sp, #0]
   145d0:	f8d1 b000 	ldr.w	fp, [r1]
   145d4:	4413      	add	r3, r2
   145d6:	4631      	mov	r1, r6
   145d8:	f10d 020a 	add.w	r2, sp, #10
   145dc:	4638      	mov	r0, r7
   145de:	47d8      	blx	fp
		if (err) {
   145e0:	b1b0      	cbz	r0, 14610 <health_pub_update+0xbc>
			BT_ERR("Failed to get faults (err %d)", err);
   145e2:	4b1f      	ldr	r3, [pc, #124]	; (14660 <health_pub_update+0x10c>)
   145e4:	f8cd a00c 	str.w	sl, [sp, #12]
   145e8:	e9cd 3008 	strd	r3, r0, [sp, #32]
   145ec:	f8cd a01c 	str.w	sl, [sp, #28]
   145f0:	aa07      	add	r2, sp, #28
   145f2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
		BT_WARN("No callback for getting faults");
   145f6:	4819      	ldr	r0, [pc, #100]	; (1465c <health_pub_update+0x108>)
   145f8:	f015 fe33 	bl	2a262 <z_log_msg2_static_create.constprop.0>
		sys_put_le16(comp->cid, company_ptr);
   145fc:	f8b8 3000 	ldrh.w	r3, [r8]
	dst[0] = val;
   14600:	7023      	strb	r3, [r4, #0]
	dst[1] = val >> 8;
   14602:	0a1b      	lsrs	r3, r3, #8
   14604:	7063      	strb	r3, [r4, #1]
		*test_id = HEALTH_TEST_STANDARD;
   14606:	2300      	movs	r3, #0
   14608:	7033      	strb	r3, [r6, #0]
		fault_count = 0U;
   1460a:	f88d 3009 	strb.w	r3, [sp, #9]
   1460e:	e009      	b.n	14624 <health_pub_update+0xd0>
			sys_put_le16(company_id, company_ptr);
   14610:	f8bd 300a 	ldrh.w	r3, [sp, #10]
	dst[0] = val;
   14614:	7023      	strb	r3, [r4, #0]
	dst[1] = val >> 8;
   14616:	0a1b      	lsrs	r3, r3, #8
			net_buf_simple_add(msg, fault_count);
   14618:	f89d 1009 	ldrb.w	r1, [sp, #9]
   1461c:	7063      	strb	r3, [r4, #1]
   1461e:	4628      	mov	r0, r5
   14620:	f017 fb8c 	bl	2bd3c <net_buf_simple_add>
	return fault_count;
   14624:	f89d 3009 	ldrb.w	r3, [sp, #9]
	if (count) {
   14628:	f899 2007 	ldrb.w	r2, [r9, #7]
   1462c:	3b00      	subs	r3, #0
   1462e:	bf18      	it	ne
   14630:	2301      	movne	r3, #1
   14632:	f363 1286 	bfi	r2, r3, #6, #1
}
   14636:	2000      	movs	r0, #0
   14638:	f889 2007 	strb.w	r2, [r9, #7]
   1463c:	b00b      	add	sp, #44	; 0x2c
   1463e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		BT_WARN("No callback for getting faults");
   14642:	4b08      	ldr	r3, [pc, #32]	; (14664 <health_pub_update+0x110>)
   14644:	9308      	str	r3, [sp, #32]
   14646:	2302      	movs	r3, #2
   14648:	9303      	str	r3, [sp, #12]
   1464a:	9307      	str	r3, [sp, #28]
   1464c:	aa07      	add	r2, sp, #28
   1464e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   14652:	e7d0      	b.n	145f6 <health_pub_update+0xa2>
   14654:	0002ec61 	.word	0x0002ec61
   14658:	00032b15 	.word	0x00032b15
   1465c:	0002db24 	.word	0x0002db24
   14660:	00032980 	.word	0x00032980
   14664:	0003299e 	.word	0x0003299e

00014668 <health_get_registered>:
{
   14668:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1466c:	b08b      	sub	sp, #44	; 0x2c
	BT_DBG("Company ID 0x%04x", company_id);
   1466e:	466d      	mov	r5, sp
{
   14670:	af02      	add	r7, sp, #8
	BT_DBG("Company ID 0x%04x", company_id);
   14672:	b088      	sub	sp, #32
{
   14674:	4614      	mov	r4, r2
	BT_DBG("Company ID 0x%04x", company_id);
   14676:	aa02      	add	r2, sp, #8
   14678:	4b2c      	ldr	r3, [pc, #176]	; (1472c <health_get_registered+0xc4>)
   1467a:	6113      	str	r3, [r2, #16]
   1467c:	4b2c      	ldr	r3, [pc, #176]	; (14730 <health_get_registered+0xc8>)
	struct bt_mesh_health_srv *srv = mod->user_data;
   1467e:	f8d0 9020 	ldr.w	r9, [r0, #32]
	BT_DBG("Company ID 0x%04x", company_id);
   14682:	e9c2 3105 	strd	r3, r1, [r2, #20]
   14686:	2304      	movs	r3, #4
   14688:	f842 3f0c 	str.w	r3, [r2, #12]!
{
   1468c:	460e      	mov	r6, r1
   1468e:	4680      	mov	r8, r0
	BT_DBG("Company ID 0x%04x", company_id);
   14690:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   14694:	4827      	ldr	r0, [pc, #156]	; (14734 <health_get_registered+0xcc>)
   14696:	60bb      	str	r3, [r7, #8]
   14698:	f015 fde3 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	bt_mesh_model_msg_init(msg, OP_HEALTH_FAULT_STATUS);
   1469c:	2105      	movs	r1, #5
   1469e:	46ad      	mov	sp, r5
   146a0:	4620      	mov	r0, r4
   146a2:	f015 fd40 	bl	2a126 <bt_mesh_model_msg_init>
	test_id = net_buf_simple_add(msg, 1);
   146a6:	2101      	movs	r1, #1
   146a8:	4620      	mov	r0, r4
   146aa:	f017 fb47 	bl	2bd3c <net_buf_simple_add>
	net_buf_simple_add_le16(msg, company_id);
   146ae:	4631      	mov	r1, r6
	test_id = net_buf_simple_add(msg, 1);
   146b0:	4605      	mov	r5, r0
	net_buf_simple_add_le16(msg, company_id);
   146b2:	4620      	mov	r0, r4
   146b4:	f017 fb59 	bl	2bd6a <net_buf_simple_add_le16>
	if (srv->cb && srv->cb->fault_get_reg) {
   146b8:	f8d9 3004 	ldr.w	r3, [r9, #4]
   146bc:	b363      	cbz	r3, 14718 <health_get_registered+0xb0>
   146be:	685b      	ldr	r3, [r3, #4]
   146c0:	b353      	cbz	r3, 14718 <health_get_registered+0xb0>
		uint8_t fault_count = net_buf_simple_tailroom(msg) - 4;
   146c2:	4620      	mov	r0, r4
   146c4:	f017 fbe1 	bl	2be8a <net_buf_simple_tailroom>
   146c8:	3804      	subs	r0, #4
   146ca:	6822      	ldr	r2, [r4, #0]
		err = srv->cb->fault_get_reg(mod, company_id, test_id,
   146cc:	f8d9 1004 	ldr.w	r1, [r9, #4]
   146d0:	88a3      	ldrh	r3, [r4, #4]
		uint8_t fault_count = net_buf_simple_tailroom(msg) - 4;
   146d2:	70f8      	strb	r0, [r7, #3]
		err = srv->cb->fault_get_reg(mod, company_id, test_id,
   146d4:	1cf8      	adds	r0, r7, #3
   146d6:	9000      	str	r0, [sp, #0]
   146d8:	f8d1 9004 	ldr.w	r9, [r1, #4]
   146dc:	4413      	add	r3, r2
   146de:	4631      	mov	r1, r6
   146e0:	462a      	mov	r2, r5
   146e2:	4640      	mov	r0, r8
   146e4:	47c8      	blx	r9
		if (err) {
   146e6:	b178      	cbz	r0, 14708 <health_get_registered+0xa0>
			BT_ERR("Failed to get faults (err %d)", err);
   146e8:	4b13      	ldr	r3, [pc, #76]	; (14738 <health_get_registered+0xd0>)
   146ea:	e9c7 3006 	strd	r3, r0, [r7, #24]
   146ee:	2303      	movs	r3, #3
   146f0:	607b      	str	r3, [r7, #4]
   146f2:	617b      	str	r3, [r7, #20]
   146f4:	f107 0214 	add.w	r2, r7, #20
   146f8:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
		BT_WARN("No callback for getting faults");
   146fc:	480d      	ldr	r0, [pc, #52]	; (14734 <health_get_registered+0xcc>)
   146fe:	f015 fdb0 	bl	2a262 <z_log_msg2_static_create.constprop.0>
		*test_id = HEALTH_TEST_STANDARD;
   14702:	2300      	movs	r3, #0
   14704:	702b      	strb	r3, [r5, #0]
}
   14706:	e003      	b.n	14710 <health_get_registered+0xa8>
			net_buf_simple_add(msg, fault_count);
   14708:	78f9      	ldrb	r1, [r7, #3]
   1470a:	4620      	mov	r0, r4
   1470c:	f017 fb16 	bl	2bd3c <net_buf_simple_add>
}
   14710:	3724      	adds	r7, #36	; 0x24
   14712:	46bd      	mov	sp, r7
   14714:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_WARN("No callback for getting faults");
   14718:	4b08      	ldr	r3, [pc, #32]	; (1473c <health_get_registered+0xd4>)
   1471a:	61bb      	str	r3, [r7, #24]
   1471c:	2302      	movs	r3, #2
   1471e:	607b      	str	r3, [r7, #4]
   14720:	617b      	str	r3, [r7, #20]
   14722:	f107 0214 	add.w	r2, r7, #20
   14726:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1472a:	e7e7      	b.n	146fc <health_get_registered+0x94>
   1472c:	000329bd 	.word	0x000329bd
   14730:	00032bc2 	.word	0x00032bc2
   14734:	0002db24 	.word	0x0002db24
   14738:	00032980 	.word	0x00032980
   1473c:	0003299e 	.word	0x0003299e

00014740 <health_fault_test>:
{
   14740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14744:	b099      	sub	sp, #100	; 0x64
   14746:	af02      	add	r7, sp, #8
   14748:	4616      	mov	r6, r2
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   1474a:	f107 0334 	add.w	r3, r7, #52	; 0x34
   1474e:	f44f 1210 	mov.w	r2, #2359296	; 0x240000
   14752:	e9c7 2304 	strd	r2, r3, [r7, #16]
	BT_DBG("");
   14756:	4a38      	ldr	r2, [pc, #224]	; (14838 <health_fault_test+0xf8>)
   14758:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 1483c <health_fault_test+0xfc>
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   1475c:	60fb      	str	r3, [r7, #12]
	BT_DBG("");
   1475e:	62ba      	str	r2, [r7, #40]	; 0x28
	struct bt_mesh_health_srv *srv = model->user_data;
   14760:	6a03      	ldr	r3, [r0, #32]
   14762:	607b      	str	r3, [r7, #4]
	BT_DBG("");
   14764:	f107 0224 	add.w	r2, r7, #36	; 0x24
   14768:	f04f 0803 	mov.w	r8, #3
{
   1476c:	4605      	mov	r5, r0
   1476e:	4689      	mov	r9, r1
	BT_DBG("");
   14770:	4833      	ldr	r0, [pc, #204]	; (14840 <health_fault_test+0x100>)
   14772:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
   14776:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   1477a:	f8c7 8008 	str.w	r8, [r7, #8]
   1477e:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
   14782:	f015 fd6e 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	test_id = net_buf_simple_pull_u8(buf);
   14786:	4630      	mov	r0, r6
   14788:	f017 fb58 	bl	2be3c <net_buf_simple_pull_u8>
   1478c:	4604      	mov	r4, r0
	company_id = net_buf_simple_pull_le16(buf);
   1478e:	4630      	mov	r0, r6
   14790:	f017 fb5c 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("");
   14794:	46eb      	mov	fp, sp
	BT_DBG("test 0x%02x company 0x%04x", test_id, company_id);
   14796:	492b      	ldr	r1, [pc, #172]	; (14844 <health_fault_test+0x104>)
   14798:	b088      	sub	sp, #32
   1479a:	aa02      	add	r2, sp, #8
   1479c:	e9c2 1a04 	strd	r1, sl, [r2, #16]
   147a0:	2105      	movs	r1, #5
   147a2:	e9c2 4006 	strd	r4, r0, [r2, #24]
   147a6:	61b9      	str	r1, [r7, #24]
   147a8:	f842 1f0c 	str.w	r1, [r2, #12]!
	company_id = net_buf_simple_pull_le16(buf);
   147ac:	4606      	mov	r6, r0
	BT_DBG("test 0x%02x company 0x%04x", test_id, company_id);
   147ae:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   147b2:	4823      	ldr	r0, [pc, #140]	; (14840 <health_fault_test+0x100>)
   147b4:	f015 fd55 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if (srv->cb && srv->cb->fault_test) {
   147b8:	687b      	ldr	r3, [r7, #4]
   147ba:	685b      	ldr	r3, [r3, #4]
   147bc:	46dd      	mov	sp, fp
   147be:	b1d3      	cbz	r3, 147f6 <health_fault_test+0xb6>
   147c0:	68db      	ldr	r3, [r3, #12]
   147c2:	b1c3      	cbz	r3, 147f6 <health_fault_test+0xb6>
		err = srv->cb->fault_test(model, test_id, company_id);
   147c4:	4621      	mov	r1, r4
   147c6:	4632      	mov	r2, r6
   147c8:	4628      	mov	r0, r5
   147ca:	4798      	blx	r3
		if (err) {
   147cc:	4604      	mov	r4, r0
   147ce:	b190      	cbz	r0, 147f6 <health_fault_test+0xb6>
			BT_WARN("Running fault test failed with err %d", err);
   147d0:	4b1d      	ldr	r3, [pc, #116]	; (14848 <health_fault_test+0x108>)
   147d2:	f8c7 8008 	str.w	r8, [r7, #8]
   147d6:	e9c7 300a 	strd	r3, r0, [r7, #40]	; 0x28
   147da:	f107 0224 	add.w	r2, r7, #36	; 0x24
   147de:	4818      	ldr	r0, [pc, #96]	; (14840 <health_fault_test+0x100>)
   147e0:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
   147e4:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   147e8:	f015 fd3b 	bl	2a262 <z_log_msg2_static_create.constprop.0>
}
   147ec:	4620      	mov	r0, r4
   147ee:	375c      	adds	r7, #92	; 0x5c
   147f0:	46bd      	mov	sp, r7
   147f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	health_get_registered(model, company_id, &sdu);
   147f6:	4631      	mov	r1, r6
   147f8:	f107 020c 	add.w	r2, r7, #12
   147fc:	4628      	mov	r0, r5
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   147fe:	2600      	movs	r6, #0
	health_get_registered(model, company_id, &sdu);
   14800:	f7ff ff32 	bl	14668 <health_get_registered>
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   14804:	9600      	str	r6, [sp, #0]
   14806:	4633      	mov	r3, r6
   14808:	f107 020c 	add.w	r2, r7, #12
   1480c:	4649      	mov	r1, r9
   1480e:	4628      	mov	r0, r5
   14810:	f7fc fbb0 	bl	10f74 <bt_mesh_model_send>
   14814:	4604      	mov	r4, r0
   14816:	2800      	cmp	r0, #0
   14818:	d0e8      	beq.n	147ec <health_fault_test+0xac>
		BT_ERR("Unable to send Health Current Status response");
   1481a:	4b0c      	ldr	r3, [pc, #48]	; (1484c <health_fault_test+0x10c>)
   1481c:	62bb      	str	r3, [r7, #40]	; 0x28
   1481e:	4808      	ldr	r0, [pc, #32]	; (14840 <health_fault_test+0x100>)
   14820:	2302      	movs	r3, #2
   14822:	f107 0224 	add.w	r2, r7, #36	; 0x24
   14826:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1482a:	60bb      	str	r3, [r7, #8]
   1482c:	627b      	str	r3, [r7, #36]	; 0x24
	return 0;
   1482e:	4634      	mov	r4, r6
		BT_ERR("Unable to send Health Current Status response");
   14830:	f015 fd17 	bl	2a262 <z_log_msg2_static_create.constprop.0>
   14834:	e7da      	b.n	147ec <health_fault_test+0xac>
   14836:	bf00      	nop
   14838:	0002ec61 	.word	0x0002ec61
   1483c:	00032bd8 	.word	0x00032bd8
   14840:	0002db24 	.word	0x0002db24
   14844:	000329d3 	.word	0x000329d3
   14848:	000329f2 	.word	0x000329f2
   1484c:	00032a18 	.word	0x00032a18

00014850 <health_fault_clear>:
{
   14850:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14854:	b097      	sub	sp, #92	; 0x5c
   14856:	af02      	add	r7, sp, #8
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   14858:	f107 032c 	add.w	r3, r7, #44	; 0x2c
	struct bt_mesh_health_srv *srv = model->user_data;
   1485c:	f8d0 8020 	ldr.w	r8, [r0, #32]
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   14860:	607b      	str	r3, [r7, #4]
{
   14862:	4604      	mov	r4, r0
   14864:	460e      	mov	r6, r1
	company_id = net_buf_simple_pull_le16(buf);
   14866:	4610      	mov	r0, r2
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   14868:	f44f 1110 	mov.w	r1, #2359296	; 0x240000
   1486c:	e9c7 1302 	strd	r1, r3, [r7, #8]
	BT_DBG("company_id 0x%04x", company_id);
   14870:	46e9      	mov	r9, sp
	company_id = net_buf_simple_pull_le16(buf);
   14872:	f017 faeb 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("company_id 0x%04x", company_id);
   14876:	b088      	sub	sp, #32
   14878:	aa02      	add	r2, sp, #8
   1487a:	4b1d      	ldr	r3, [pc, #116]	; (148f0 <health_fault_clear+0xa0>)
   1487c:	6113      	str	r3, [r2, #16]
   1487e:	4b1d      	ldr	r3, [pc, #116]	; (148f4 <health_fault_clear+0xa4>)
   14880:	e9c2 3005 	strd	r3, r0, [r2, #20]
   14884:	2304      	movs	r3, #4
   14886:	f842 3f0c 	str.w	r3, [r2, #12]!
	company_id = net_buf_simple_pull_le16(buf);
   1488a:	4605      	mov	r5, r0
	BT_DBG("company_id 0x%04x", company_id);
   1488c:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   14890:	4819      	ldr	r0, [pc, #100]	; (148f8 <health_fault_clear+0xa8>)
   14892:	613b      	str	r3, [r7, #16]
   14894:	f015 fce5 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if (srv->cb && srv->cb->fault_clear) {
   14898:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1489c:	46cd      	mov	sp, r9
   1489e:	b9db      	cbnz	r3, 148d8 <health_fault_clear+0x88>
	health_get_registered(model, company_id, &sdu);
   148a0:	4629      	mov	r1, r5
   148a2:	1d3a      	adds	r2, r7, #4
   148a4:	4620      	mov	r0, r4
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   148a6:	2500      	movs	r5, #0
	health_get_registered(model, company_id, &sdu);
   148a8:	f7ff fede 	bl	14668 <health_get_registered>
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   148ac:	9500      	str	r5, [sp, #0]
   148ae:	462b      	mov	r3, r5
   148b0:	1d3a      	adds	r2, r7, #4
   148b2:	4631      	mov	r1, r6
   148b4:	4620      	mov	r0, r4
   148b6:	f7fc fb5d 	bl	10f74 <bt_mesh_model_send>
   148ba:	b1a8      	cbz	r0, 148e8 <health_fault_clear+0x98>
		BT_ERR("Unable to send Health Current Status response");
   148bc:	4b0f      	ldr	r3, [pc, #60]	; (148fc <health_fault_clear+0xac>)
   148be:	480e      	ldr	r0, [pc, #56]	; (148f8 <health_fault_clear+0xa8>)
   148c0:	623b      	str	r3, [r7, #32]
   148c2:	f107 021c 	add.w	r2, r7, #28
   148c6:	2302      	movs	r3, #2
   148c8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   148cc:	603b      	str	r3, [r7, #0]
   148ce:	61fb      	str	r3, [r7, #28]
   148d0:	f015 fcc7 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	return 0;
   148d4:	4628      	mov	r0, r5
   148d6:	e007      	b.n	148e8 <health_fault_clear+0x98>
	if (srv->cb && srv->cb->fault_clear) {
   148d8:	689b      	ldr	r3, [r3, #8]
   148da:	2b00      	cmp	r3, #0
   148dc:	d0e0      	beq.n	148a0 <health_fault_clear+0x50>
		err = srv->cb->fault_clear(model, company_id);
   148de:	4629      	mov	r1, r5
   148e0:	4620      	mov	r0, r4
   148e2:	4798      	blx	r3
		if (err) {
   148e4:	2800      	cmp	r0, #0
   148e6:	d0db      	beq.n	148a0 <health_fault_clear+0x50>
}
   148e8:	3754      	adds	r7, #84	; 0x54
   148ea:	46bd      	mov	sp, r7
   148ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   148f0:	00032a46 	.word	0x00032a46
   148f4:	00032b96 	.word	0x00032b96
   148f8:	0002db24 	.word	0x0002db24
   148fc:	00032a18 	.word	0x00032a18

00014900 <health_fault_get>:
{
   14900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14904:	b096      	sub	sp, #88	; 0x58
   14906:	af02      	add	r7, sp, #8
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   14908:	f107 032c 	add.w	r3, r7, #44	; 0x2c
{
   1490c:	4604      	mov	r4, r0
   1490e:	460e      	mov	r6, r1
	company_id = net_buf_simple_pull_le16(buf);
   14910:	4610      	mov	r0, r2
	NET_BUF_SIMPLE_DEFINE(sdu, BT_MESH_TX_SDU_MAX);
   14912:	f44f 1110 	mov.w	r1, #2359296	; 0x240000
   14916:	e9c7 1302 	strd	r1, r3, [r7, #8]
   1491a:	607b      	str	r3, [r7, #4]
	BT_DBG("company_id 0x%04x", company_id);
   1491c:	46e8      	mov	r8, sp
	company_id = net_buf_simple_pull_le16(buf);
   1491e:	f017 fa95 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("company_id 0x%04x", company_id);
   14922:	b088      	sub	sp, #32
   14924:	aa02      	add	r2, sp, #8
   14926:	4b17      	ldr	r3, [pc, #92]	; (14984 <health_fault_get+0x84>)
   14928:	6113      	str	r3, [r2, #16]
   1492a:	4b17      	ldr	r3, [pc, #92]	; (14988 <health_fault_get+0x88>)
   1492c:	e9c2 3005 	strd	r3, r0, [r2, #20]
   14930:	2304      	movs	r3, #4
   14932:	f842 3f0c 	str.w	r3, [r2, #12]!
	company_id = net_buf_simple_pull_le16(buf);
   14936:	4605      	mov	r5, r0
	BT_DBG("company_id 0x%04x", company_id);
   14938:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   1493c:	4813      	ldr	r0, [pc, #76]	; (1498c <health_fault_get+0x8c>)
   1493e:	613b      	str	r3, [r7, #16]
   14940:	f015 fc8f 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	health_get_registered(model, company_id, &sdu);
   14944:	1d3a      	adds	r2, r7, #4
   14946:	46c5      	mov	sp, r8
   14948:	4629      	mov	r1, r5
   1494a:	4620      	mov	r0, r4
   1494c:	f7ff fe8c 	bl	14668 <health_get_registered>
	if (bt_mesh_model_send(model, ctx, &sdu, NULL, NULL)) {
   14950:	2300      	movs	r3, #0
   14952:	9300      	str	r3, [sp, #0]
   14954:	1d3a      	adds	r2, r7, #4
   14956:	4631      	mov	r1, r6
   14958:	4620      	mov	r0, r4
   1495a:	f7fc fb0b 	bl	10f74 <bt_mesh_model_send>
   1495e:	b158      	cbz	r0, 14978 <health_fault_get+0x78>
		BT_ERR("Unable to send Health Current Status response");
   14960:	4b0b      	ldr	r3, [pc, #44]	; (14990 <health_fault_get+0x90>)
   14962:	623b      	str	r3, [r7, #32]
   14964:	4809      	ldr	r0, [pc, #36]	; (1498c <health_fault_get+0x8c>)
   14966:	2302      	movs	r3, #2
   14968:	f107 021c 	add.w	r2, r7, #28
   1496c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14970:	603b      	str	r3, [r7, #0]
   14972:	61fb      	str	r3, [r7, #28]
   14974:	f015 fc75 	bl	2a262 <z_log_msg2_static_create.constprop.0>
}
   14978:	2000      	movs	r0, #0
   1497a:	3750      	adds	r7, #80	; 0x50
   1497c:	46bd      	mov	sp, r7
   1497e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14982:	bf00      	nop
   14984:	00032a46 	.word	0x00032a46
   14988:	00032b85 	.word	0x00032b85
   1498c:	0002db24 	.word	0x0002db24
   14990:	00032a18 	.word	0x00032a18

00014994 <health_fault_clear_unrel>:
{
   14994:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14998:	b082      	sub	sp, #8
	struct bt_mesh_health_srv *srv = model->user_data;
   1499a:	6a06      	ldr	r6, [r0, #32]
{
   1499c:	af00      	add	r7, sp, #0
   1499e:	4604      	mov	r4, r0
	company_id = net_buf_simple_pull_le16(buf);
   149a0:	4610      	mov	r0, r2
   149a2:	f017 fa53 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("company_id 0x%04x", company_id);
   149a6:	46e8      	mov	r8, sp
   149a8:	b088      	sub	sp, #32
   149aa:	466a      	mov	r2, sp
   149ac:	4b0e      	ldr	r3, [pc, #56]	; (149e8 <health_fault_clear_unrel+0x54>)
   149ae:	6113      	str	r3, [r2, #16]
   149b0:	4b0e      	ldr	r3, [pc, #56]	; (149ec <health_fault_clear_unrel+0x58>)
   149b2:	e9c2 3005 	strd	r3, r0, [r2, #20]
   149b6:	2304      	movs	r3, #4
   149b8:	f842 3f0c 	str.w	r3, [r2, #12]!
	company_id = net_buf_simple_pull_le16(buf);
   149bc:	4605      	mov	r5, r0
	BT_DBG("company_id 0x%04x", company_id);
   149be:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   149c2:	480b      	ldr	r0, [pc, #44]	; (149f0 <health_fault_clear_unrel+0x5c>)
   149c4:	607b      	str	r3, [r7, #4]
   149c6:	f015 fc4c 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if (srv->cb && srv->cb->fault_clear) {
   149ca:	6870      	ldr	r0, [r6, #4]
   149cc:	46c5      	mov	sp, r8
   149ce:	b120      	cbz	r0, 149da <health_fault_clear_unrel+0x46>
   149d0:	6883      	ldr	r3, [r0, #8]
   149d2:	b133      	cbz	r3, 149e2 <health_fault_clear_unrel+0x4e>
		return srv->cb->fault_clear(model, company_id);
   149d4:	4629      	mov	r1, r5
   149d6:	4620      	mov	r0, r4
   149d8:	4798      	blx	r3
}
   149da:	3708      	adds	r7, #8
   149dc:	46bd      	mov	sp, r7
   149de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return 0;
   149e2:	4618      	mov	r0, r3
   149e4:	e7f9      	b.n	149da <health_fault_clear_unrel+0x46>
   149e6:	bf00      	nop
   149e8:	00032a46 	.word	0x00032a46
   149ec:	00032ba9 	.word	0x00032ba9
   149f0:	0002db24 	.word	0x0002db24

000149f4 <health_fault_test_unrel>:
{
   149f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   149f8:	b083      	sub	sp, #12
	struct bt_mesh_health_srv *srv = model->user_data;
   149fa:	f8d0 8020 	ldr.w	r8, [r0, #32]
{
   149fe:	af00      	add	r7, sp, #0
   14a00:	4604      	mov	r4, r0
	test_id = net_buf_simple_pull_u8(buf);
   14a02:	4610      	mov	r0, r2
{
   14a04:	4616      	mov	r6, r2
	test_id = net_buf_simple_pull_u8(buf);
   14a06:	f017 fa19 	bl	2be3c <net_buf_simple_pull_u8>
   14a0a:	4605      	mov	r5, r0
	company_id = net_buf_simple_pull_le16(buf);
   14a0c:	4630      	mov	r0, r6
   14a0e:	f017 fa1d 	bl	2be4c <net_buf_simple_pull_le16>
	BT_DBG("test 0x%02x company 0x%04x", test_id, company_id);
   14a12:	46e9      	mov	r9, sp
   14a14:	b088      	sub	sp, #32
   14a16:	466a      	mov	r2, sp
   14a18:	4b0f      	ldr	r3, [pc, #60]	; (14a58 <health_fault_test_unrel+0x64>)
   14a1a:	6113      	str	r3, [r2, #16]
   14a1c:	4b0f      	ldr	r3, [pc, #60]	; (14a5c <health_fault_test_unrel+0x68>)
   14a1e:	61d0      	str	r0, [r2, #28]
   14a20:	e9c2 3505 	strd	r3, r5, [r2, #20]
   14a24:	2305      	movs	r3, #5
   14a26:	f842 3f0c 	str.w	r3, [r2, #12]!
	company_id = net_buf_simple_pull_le16(buf);
   14a2a:	4606      	mov	r6, r0
	BT_DBG("test 0x%02x company 0x%04x", test_id, company_id);
   14a2c:	f44f 5124 	mov.w	r1, #10496	; 0x2900
   14a30:	480b      	ldr	r0, [pc, #44]	; (14a60 <health_fault_test_unrel+0x6c>)
   14a32:	607b      	str	r3, [r7, #4]
   14a34:	f015 fc15 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if (srv->cb && srv->cb->fault_test) {
   14a38:	f8d8 0004 	ldr.w	r0, [r8, #4]
   14a3c:	46cd      	mov	sp, r9
   14a3e:	b128      	cbz	r0, 14a4c <health_fault_test_unrel+0x58>
   14a40:	68c3      	ldr	r3, [r0, #12]
   14a42:	b13b      	cbz	r3, 14a54 <health_fault_test_unrel+0x60>
		return srv->cb->fault_test(model, test_id, company_id);
   14a44:	4632      	mov	r2, r6
   14a46:	4629      	mov	r1, r5
   14a48:	4620      	mov	r0, r4
   14a4a:	4798      	blx	r3
}
   14a4c:	370c      	adds	r7, #12
   14a4e:	46bd      	mov	sp, r7
   14a50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return 0;
   14a54:	4618      	mov	r0, r3
   14a56:	e7f9      	b.n	14a4c <health_fault_test_unrel+0x58>
   14a58:	000329d3 	.word	0x000329d3
   14a5c:	00032bea 	.word	0x00032bea
   14a60:	0002db24 	.word	0x0002db24

00014a64 <send_health_period_status>:
{
   14a64:	b530      	push	{r4, r5, lr}
   14a66:	4604      	mov	r4, r0
   14a68:	b08f      	sub	sp, #60	; 0x3c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEALTH_PERIOD_STATUS, 1);
   14a6a:	ab03      	add	r3, sp, #12
   14a6c:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
{
   14a70:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(&msg, OP_HEALTH_PERIOD_STATUS);
   14a72:	a805      	add	r0, sp, #20
   14a74:	f248 0137 	movw	r1, #32823	; 0x8037
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_HEALTH_PERIOD_STATUS, 1);
   14a78:	e9cd 2306 	strd	r2, r3, [sp, #24]
   14a7c:	9305      	str	r3, [sp, #20]
	bt_mesh_model_msg_init(&msg, OP_HEALTH_PERIOD_STATUS);
   14a7e:	f015 fb52 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, model->pub->period_div);
   14a82:	68a3      	ldr	r3, [r4, #8]
   14a84:	7ad9      	ldrb	r1, [r3, #11]
   14a86:	a805      	add	r0, sp, #20
   14a88:	f001 010f 	and.w	r1, r1, #15
   14a8c:	f017 f965 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   14a90:	2300      	movs	r3, #0
   14a92:	9300      	str	r3, [sp, #0]
   14a94:	aa05      	add	r2, sp, #20
   14a96:	4629      	mov	r1, r5
   14a98:	4620      	mov	r0, r4
   14a9a:	f7fc fa6b 	bl	10f74 <bt_mesh_model_send>
   14a9e:	b150      	cbz	r0, 14ab6 <send_health_period_status+0x52>
		BT_ERR("Unable to send Health Period Status");
   14aa0:	4b06      	ldr	r3, [pc, #24]	; (14abc <send_health_period_status+0x58>)
   14aa2:	930c      	str	r3, [sp, #48]	; 0x30
   14aa4:	4806      	ldr	r0, [pc, #24]	; (14ac0 <send_health_period_status+0x5c>)
   14aa6:	2302      	movs	r3, #2
   14aa8:	aa0b      	add	r2, sp, #44	; 0x2c
   14aaa:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14aae:	9302      	str	r3, [sp, #8]
   14ab0:	930b      	str	r3, [sp, #44]	; 0x2c
   14ab2:	f015 fbd6 	bl	2a262 <z_log_msg2_static_create.constprop.0>
}
   14ab6:	2000      	movs	r0, #0
   14ab8:	b00f      	add	sp, #60	; 0x3c
   14aba:	bd30      	pop	{r4, r5, pc}
   14abc:	00032a5c 	.word	0x00032a5c
   14ac0:	0002db24 	.word	0x0002db24

00014ac4 <health_period_get>:
{
   14ac4:	b530      	push	{r4, r5, lr}
   14ac6:	b089      	sub	sp, #36	; 0x24
	BT_DBG("");
   14ac8:	4b0a      	ldr	r3, [pc, #40]	; (14af4 <health_period_get+0x30>)
   14aca:	9306      	str	r3, [sp, #24]
   14acc:	4b0a      	ldr	r3, [pc, #40]	; (14af8 <health_period_get+0x34>)
   14ace:	9307      	str	r3, [sp, #28]
{
   14ad0:	4604      	mov	r4, r0
	BT_DBG("");
   14ad2:	2303      	movs	r3, #3
{
   14ad4:	460d      	mov	r5, r1
	BT_DBG("");
   14ad6:	4809      	ldr	r0, [pc, #36]	; (14afc <health_period_get+0x38>)
   14ad8:	9301      	str	r3, [sp, #4]
   14ada:	aa05      	add	r2, sp, #20
   14adc:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14ae0:	9305      	str	r3, [sp, #20]
   14ae2:	f015 fbbe 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	return send_health_period_status(model, ctx);
   14ae6:	4629      	mov	r1, r5
   14ae8:	4620      	mov	r0, r4
}
   14aea:	b009      	add	sp, #36	; 0x24
   14aec:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return send_health_period_status(model, ctx);
   14af0:	f7ff bfb8 	b.w	14a64 <send_health_period_status>
   14af4:	0002ec61 	.word	0x0002ec61
   14af8:	00032c02 	.word	0x00032c02
   14afc:	0002db24 	.word	0x0002db24

00014b00 <attention_off>:
{
   14b00:	b510      	push	{r4, lr}
   14b02:	b088      	sub	sp, #32
	BT_DBG("");
   14b04:	4b0d      	ldr	r3, [pc, #52]	; (14b3c <attention_off+0x3c>)
   14b06:	9306      	str	r3, [sp, #24]
{
   14b08:	4604      	mov	r4, r0
	BT_DBG("");
   14b0a:	4b0d      	ldr	r3, [pc, #52]	; (14b40 <attention_off+0x40>)
   14b0c:	9307      	str	r3, [sp, #28]
   14b0e:	480d      	ldr	r0, [pc, #52]	; (14b44 <attention_off+0x44>)
   14b10:	2303      	movs	r3, #3
   14b12:	aa05      	add	r2, sp, #20
   14b14:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14b18:	9301      	str	r3, [sp, #4]
   14b1a:	9305      	str	r3, [sp, #20]
   14b1c:	f015 fba1 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if (srv->cb && srv->cb->attn_off) {
   14b20:	f854 3c04 	ldr.w	r3, [r4, #-4]
   14b24:	b13b      	cbz	r3, 14b36 <attention_off+0x36>
   14b26:	695b      	ldr	r3, [r3, #20]
   14b28:	b12b      	cbz	r3, 14b36 <attention_off+0x36>
		srv->cb->attn_off(srv->model);
   14b2a:	f854 0c08 	ldr.w	r0, [r4, #-8]
}
   14b2e:	b008      	add	sp, #32
   14b30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		srv->cb->attn_off(srv->model);
   14b34:	4718      	bx	r3
}
   14b36:	b008      	add	sp, #32
   14b38:	bd10      	pop	{r4, pc}
   14b3a:	bf00      	nop
   14b3c:	0002ec61 	.word	0x0002ec61
   14b40:	00032b07 	.word	0x00032b07
   14b44:	0002db24 	.word	0x0002db24

00014b48 <health_period_set_unrel>:
{
   14b48:	b5f0      	push	{r4, r5, r6, r7, lr}
   14b4a:	b089      	sub	sp, #36	; 0x24
   14b4c:	4605      	mov	r5, r0
   14b4e:	af00      	add	r7, sp, #0
	period = net_buf_simple_pull_u8(buf);
   14b50:	4610      	mov	r0, r2
   14b52:	f017 f973 	bl	2be3c <net_buf_simple_pull_u8>
	if (period > 15) {
   14b56:	280f      	cmp	r0, #15
	period = net_buf_simple_pull_u8(buf);
   14b58:	4604      	mov	r4, r0
	if (period > 15) {
   14b5a:	d911      	bls.n	14b80 <health_period_set_unrel+0x38>
		BT_WARN("Prohibited period value %u", period);
   14b5c:	4b15      	ldr	r3, [pc, #84]	; (14bb4 <health_period_set_unrel+0x6c>)
   14b5e:	f107 0214 	add.w	r2, r7, #20
   14b62:	e9c7 3006 	strd	r3, r0, [r7, #24]
   14b66:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   14b6a:	2303      	movs	r3, #3
   14b6c:	4812      	ldr	r0, [pc, #72]	; (14bb8 <health_period_set_unrel+0x70>)
   14b6e:	607b      	str	r3, [r7, #4]
   14b70:	617b      	str	r3, [r7, #20]
   14b72:	f015 fb76 	bl	2a262 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   14b76:	f06f 0015 	mvn.w	r0, #21
}
   14b7a:	3724      	adds	r7, #36	; 0x24
   14b7c:	46bd      	mov	sp, r7
   14b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_DBG("period %u", period);
   14b80:	466e      	mov	r6, sp
   14b82:	b088      	sub	sp, #32
   14b84:	466a      	mov	r2, sp
   14b86:	4b0d      	ldr	r3, [pc, #52]	; (14bbc <health_period_set_unrel+0x74>)
   14b88:	6113      	str	r3, [r2, #16]
   14b8a:	4b0d      	ldr	r3, [pc, #52]	; (14bc0 <health_period_set_unrel+0x78>)
   14b8c:	e9c2 3005 	strd	r3, r0, [r2, #20]
   14b90:	2304      	movs	r3, #4
   14b92:	f842 3f0c 	str.w	r3, [r2, #12]!
   14b96:	4808      	ldr	r0, [pc, #32]	; (14bb8 <health_period_set_unrel+0x70>)
   14b98:	60bb      	str	r3, [r7, #8]
   14b9a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
   14b9e:	f015 fb60 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	model->pub->period_div = period;
   14ba2:	68ab      	ldr	r3, [r5, #8]
   14ba4:	7ada      	ldrb	r2, [r3, #11]
   14ba6:	f364 0203 	bfi	r2, r4, #0, #4
   14baa:	46b5      	mov	sp, r6
   14bac:	72da      	strb	r2, [r3, #11]
	return 0;
   14bae:	2000      	movs	r0, #0
   14bb0:	e7e3      	b.n	14b7a <health_period_set_unrel+0x32>
   14bb2:	bf00      	nop
   14bb4:	00032a80 	.word	0x00032a80
   14bb8:	0002db24 	.word	0x0002db24
   14bbc:	00032a9b 	.word	0x00032a9b
   14bc0:	00032b27 	.word	0x00032b27

00014bc4 <health_period_set>:
{
   14bc4:	b570      	push	{r4, r5, r6, lr}
   14bc6:	b088      	sub	sp, #32
	BT_DBG("");
   14bc8:	4b0f      	ldr	r3, [pc, #60]	; (14c08 <health_period_set+0x44>)
   14bca:	9306      	str	r3, [sp, #24]
   14bcc:	4b0f      	ldr	r3, [pc, #60]	; (14c0c <health_period_set+0x48>)
   14bce:	9307      	str	r3, [sp, #28]
{
   14bd0:	4604      	mov	r4, r0
	BT_DBG("");
   14bd2:	2303      	movs	r3, #3
   14bd4:	480e      	ldr	r0, [pc, #56]	; (14c10 <health_period_set+0x4c>)
   14bd6:	9301      	str	r3, [sp, #4]
{
   14bd8:	460d      	mov	r5, r1
   14bda:	4616      	mov	r6, r2
	BT_DBG("");
   14bdc:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14be0:	aa05      	add	r2, sp, #20
   14be2:	9305      	str	r3, [sp, #20]
   14be4:	f015 fb3d 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	err = health_period_set_unrel(model, ctx, buf);
   14be8:	4632      	mov	r2, r6
   14bea:	4629      	mov	r1, r5
   14bec:	4620      	mov	r0, r4
   14bee:	f7ff ffab 	bl	14b48 <health_period_set_unrel>
	if (err) {
   14bf2:	b930      	cbnz	r0, 14c02 <health_period_set+0x3e>
	return send_health_period_status(model, ctx);
   14bf4:	4629      	mov	r1, r5
   14bf6:	4620      	mov	r0, r4
}
   14bf8:	b008      	add	sp, #32
   14bfa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return send_health_period_status(model, ctx);
   14bfe:	f7ff bf31 	b.w	14a64 <send_health_period_status>
}
   14c02:	b008      	add	sp, #32
   14c04:	bd70      	pop	{r4, r5, r6, pc}
   14c06:	bf00      	nop
   14c08:	0002ec61 	.word	0x0002ec61
   14c0c:	00032c14 	.word	0x00032c14
   14c10:	0002db24 	.word	0x0002db24

00014c14 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   14c14:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   14c16:	ab0a      	add	r3, sp, #40	; 0x28
   14c18:	9305      	str	r3, [sp, #20]
   14c1a:	9302      	str	r3, [sp, #8]
   14c1c:	4b05      	ldr	r3, [pc, #20]	; (14c34 <z_log_msg2_runtime_create.constprop.0+0x20>)
   14c1e:	9301      	str	r3, [sp, #4]
   14c20:	2300      	movs	r3, #0
   14c22:	9300      	str	r3, [sp, #0]
   14c24:	2204      	movs	r2, #4
   14c26:	4618      	mov	r0, r3
   14c28:	f7ee fb3e 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   14c2c:	b007      	add	sp, #28
   14c2e:	f85d fb04 	ldr.w	pc, [sp], #4
   14c32:	bf00      	nop
   14c34:	00032aa9 	.word	0x00032aa9

00014c38 <send_attention_status>:
{
   14c38:	b5f0      	push	{r4, r5, r6, r7, lr}
   14c3a:	4605      	mov	r5, r0
   14c3c:	6a00      	ldr	r0, [r0, #32]
   14c3e:	b093      	sub	sp, #76	; 0x4c
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_ATTENTION_STATUS, 1);
   14c40:	ab07      	add	r3, sp, #28
   14c42:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
   14c46:	3018      	adds	r0, #24
   14c48:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
{
   14c4c:	460e      	mov	r6, r1
	BT_MESH_MODEL_BUF_DEFINE(msg, OP_ATTENTION_STATUS, 1);
   14c4e:	9309      	str	r3, [sp, #36]	; 0x24
   14c50:	f018 fa40 	bl	2d0d4 <z_timeout_remaining>
			return (uint32_t)((t * to_hz + off) / from_hz);
   14c54:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   14c58:	fba0 4003 	umull	r4, r0, r0, r3
   14c5c:	0be4      	lsrs	r4, r4, #15
	BT_DBG("%u second%s", time, (time == 1U) ? "" : "s");
   14c5e:	4a1b      	ldr	r2, [pc, #108]	; (14ccc <send_attention_status+0x94>)
   14c60:	491b      	ldr	r1, [pc, #108]	; (14cd0 <send_attention_status+0x98>)
   14c62:	ea44 4440 	orr.w	r4, r4, r0, lsl #17
		k_work_delayable_remaining_get(&srv->attn_timer)) / 1000U;
   14c66:	fbb4 f4f3 	udiv	r4, r4, r3
	BT_DBG("%u second%s", time, (time == 1U) ? "" : "s");
   14c6a:	4b1a      	ldr	r3, [pc, #104]	; (14cd4 <send_attention_status+0x9c>)
	time = k_ticks_to_ms_floor32(
   14c6c:	b2e4      	uxtb	r4, r4
	BT_DBG("%u second%s", time, (time == 1U) ? "" : "s");
   14c6e:	2c01      	cmp	r4, #1
   14c70:	bf18      	it	ne
   14c72:	4613      	movne	r3, r2
   14c74:	e9cd 4303 	strd	r4, r3, [sp, #12]
   14c78:	4b17      	ldr	r3, [pc, #92]	; (14cd8 <send_attention_status+0xa0>)
   14c7a:	9302      	str	r3, [sp, #8]
   14c7c:	2700      	movs	r7, #0
   14c7e:	4b17      	ldr	r3, [pc, #92]	; (14cdc <send_attention_status+0xa4>)
   14c80:	9301      	str	r3, [sp, #4]
   14c82:	2204      	movs	r2, #4
   14c84:	463b      	mov	r3, r7
   14c86:	4638      	mov	r0, r7
   14c88:	9700      	str	r7, [sp, #0]
   14c8a:	f7ff ffc3 	bl	14c14 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_model_msg_init(&msg, OP_ATTENTION_STATUS);
   14c8e:	f248 0107 	movw	r1, #32775	; 0x8007
   14c92:	a809      	add	r0, sp, #36	; 0x24
   14c94:	f015 fa47 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(&msg, time);
   14c98:	4621      	mov	r1, r4
   14c9a:	a809      	add	r0, sp, #36	; 0x24
   14c9c:	f017 f85d 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
   14ca0:	9700      	str	r7, [sp, #0]
   14ca2:	463b      	mov	r3, r7
   14ca4:	aa09      	add	r2, sp, #36	; 0x24
   14ca6:	4631      	mov	r1, r6
   14ca8:	4628      	mov	r0, r5
   14caa:	f7fc f963 	bl	10f74 <bt_mesh_model_send>
   14cae:	b150      	cbz	r0, 14cc6 <send_attention_status+0x8e>
		BT_ERR("Unable to send Attention Status");
   14cb0:	4b0b      	ldr	r3, [pc, #44]	; (14ce0 <send_attention_status+0xa8>)
   14cb2:	9310      	str	r3, [sp, #64]	; 0x40
   14cb4:	4806      	ldr	r0, [pc, #24]	; (14cd0 <send_attention_status+0x98>)
   14cb6:	2302      	movs	r3, #2
   14cb8:	aa0f      	add	r2, sp, #60	; 0x3c
   14cba:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   14cbe:	9306      	str	r3, [sp, #24]
   14cc0:	930f      	str	r3, [sp, #60]	; 0x3c
   14cc2:	f015 face 	bl	2a262 <z_log_msg2_static_create.constprop.0>
}
   14cc6:	2000      	movs	r0, #0
   14cc8:	b013      	add	sp, #76	; 0x4c
   14cca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14ccc:	0003170b 	.word	0x0003170b
   14cd0:	0002db24 	.word	0x0002db24
   14cd4:	0003175b 	.word	0x0003175b
   14cd8:	00032b4d 	.word	0x00032b4d
   14cdc:	00032aa9 	.word	0x00032aa9
   14ce0:	00032ab9 	.word	0x00032ab9

00014ce4 <attention_get>:
{
   14ce4:	b530      	push	{r4, r5, lr}
   14ce6:	b089      	sub	sp, #36	; 0x24
	BT_DBG("");
   14ce8:	4b0a      	ldr	r3, [pc, #40]	; (14d14 <attention_get+0x30>)
   14cea:	9306      	str	r3, [sp, #24]
   14cec:	4b0a      	ldr	r3, [pc, #40]	; (14d18 <attention_get+0x34>)
   14cee:	9307      	str	r3, [sp, #28]
{
   14cf0:	4604      	mov	r4, r0
	BT_DBG("");
   14cf2:	2303      	movs	r3, #3
{
   14cf4:	460d      	mov	r5, r1
	BT_DBG("");
   14cf6:	4809      	ldr	r0, [pc, #36]	; (14d1c <attention_get+0x38>)
   14cf8:	9301      	str	r3, [sp, #4]
   14cfa:	aa05      	add	r2, sp, #20
   14cfc:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14d00:	9305      	str	r3, [sp, #20]
   14d02:	f015 faae 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	return send_attention_status(model, ctx);
   14d06:	4629      	mov	r1, r5
   14d08:	4620      	mov	r0, r4
}
   14d0a:	b009      	add	sp, #36	; 0x24
   14d0c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return send_attention_status(model, ctx);
   14d10:	f7ff bf92 	b.w	14c38 <send_attention_status>
   14d14:	0002ec61 	.word	0x0002ec61
   14d18:	00032b3f 	.word	0x00032b3f
   14d1c:	0002db24 	.word	0x0002db24

00014d20 <bt_mesh_attention>:
const struct bt_mesh_model_cb bt_mesh_health_srv_cb = {
	.init = health_srv_init,
};

void bt_mesh_attention(struct bt_mesh_model *model, uint8_t time)
{
   14d20:	b570      	push	{r4, r5, r6, lr}
   14d22:	460c      	mov	r4, r1
   14d24:	b088      	sub	sp, #32
	struct bt_mesh_health_srv *srv;

	if (!model) {
   14d26:	bb70      	cbnz	r0, 14d86 <bt_mesh_attention+0x66>
		srv = health_srv;
   14d28:	4b18      	ldr	r3, [pc, #96]	; (14d8c <bt_mesh_attention+0x6c>)
   14d2a:	681d      	ldr	r5, [r3, #0]
		if (!srv) {
   14d2c:	b965      	cbnz	r5, 14d48 <bt_mesh_attention+0x28>
			BT_WARN("No Health Server available");
   14d2e:	4b18      	ldr	r3, [pc, #96]	; (14d90 <bt_mesh_attention+0x70>)
   14d30:	9306      	str	r3, [sp, #24]
   14d32:	4818      	ldr	r0, [pc, #96]	; (14d94 <bt_mesh_attention+0x74>)
   14d34:	2302      	movs	r3, #2
   14d36:	aa05      	add	r2, sp, #20
   14d38:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   14d3c:	9301      	str	r3, [sp, #4]
   14d3e:	9305      	str	r3, [sp, #20]
   14d40:	f015 fa8f 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	if ((time > 0) && srv->cb && srv->cb->attn_on) {
		srv->cb->attn_on(model);
	}

	k_work_reschedule(&srv->attn_timer, K_SECONDS(time));
}
   14d44:	b008      	add	sp, #32
   14d46:	bd70      	pop	{r4, r5, r6, pc}
		model = srv->model;
   14d48:	6828      	ldr	r0, [r5, #0]
	if ((time > 0) && srv->cb && srv->cb->attn_on) {
   14d4a:	b124      	cbz	r4, 14d56 <bt_mesh_attention+0x36>
   14d4c:	686b      	ldr	r3, [r5, #4]
   14d4e:	b113      	cbz	r3, 14d56 <bt_mesh_attention+0x36>
   14d50:	691b      	ldr	r3, [r3, #16]
   14d52:	b103      	cbz	r3, 14d56 <bt_mesh_attention+0x36>
		srv->cb->attn_on(model);
   14d54:	4798      	blx	r3
	k_work_reschedule(&srv->attn_timer, K_SECONDS(time));
   14d56:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14d5a:	434c      	muls	r4, r1
			return ((t * to_hz + off) / from_hz);
   14d5c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   14d60:	f240 30e7 	movw	r0, #999	; 0x3e7
   14d64:	2100      	movs	r1, #0
   14d66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   14d6a:	2300      	movs	r3, #0
   14d6c:	fbe4 0106 	umlal	r0, r1, r4, r6
   14d70:	f7eb f9b6 	bl	e0 <__aeabi_uldivmod>
   14d74:	4602      	mov	r2, r0
   14d76:	460b      	mov	r3, r1
   14d78:	f105 0008 	add.w	r0, r5, #8
}
   14d7c:	b008      	add	sp, #32
   14d7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_reschedule(&srv->attn_timer, K_SECONDS(time));
   14d82:	f00f baef 	b.w	24364 <k_work_reschedule>
		srv = model->user_data;
   14d86:	6a05      	ldr	r5, [r0, #32]
   14d88:	e7df      	b.n	14d4a <bt_mesh_attention+0x2a>
   14d8a:	bf00      	nop
   14d8c:	20002784 	.word	0x20002784
   14d90:	00032ad9 	.word	0x00032ad9
   14d94:	0002db24 	.word	0x0002db24

00014d98 <attention_set_unrel>:
{
   14d98:	b570      	push	{r4, r5, r6, lr}
   14d9a:	4606      	mov	r6, r0
   14d9c:	b086      	sub	sp, #24
	time = net_buf_simple_pull_u8(buf);
   14d9e:	4610      	mov	r0, r2
   14da0:	f017 f84c 	bl	2be3c <net_buf_simple_pull_u8>
	BT_DBG("%u second%s", time, (time == 1U) ? "" : "s");
   14da4:	4a0d      	ldr	r2, [pc, #52]	; (14ddc <attention_set_unrel+0x44>)
   14da6:	4b0e      	ldr	r3, [pc, #56]	; (14de0 <attention_set_unrel+0x48>)
   14da8:	490e      	ldr	r1, [pc, #56]	; (14de4 <attention_set_unrel+0x4c>)
   14daa:	2801      	cmp	r0, #1
   14dac:	bf18      	it	ne
   14dae:	4613      	movne	r3, r2
   14db0:	e9cd 0303 	strd	r0, r3, [sp, #12]
   14db4:	4b0c      	ldr	r3, [pc, #48]	; (14de8 <attention_set_unrel+0x50>)
   14db6:	9302      	str	r3, [sp, #8]
   14db8:	2500      	movs	r5, #0
   14dba:	4b0c      	ldr	r3, [pc, #48]	; (14dec <attention_set_unrel+0x54>)
   14dbc:	9301      	str	r3, [sp, #4]
	time = net_buf_simple_pull_u8(buf);
   14dbe:	4604      	mov	r4, r0
	BT_DBG("%u second%s", time, (time == 1U) ? "" : "s");
   14dc0:	462b      	mov	r3, r5
   14dc2:	2204      	movs	r2, #4
   14dc4:	4628      	mov	r0, r5
   14dc6:	9500      	str	r5, [sp, #0]
   14dc8:	f7ff ff24 	bl	14c14 <z_log_msg2_runtime_create.constprop.0>
	bt_mesh_attention(model, time);
   14dcc:	4630      	mov	r0, r6
   14dce:	4621      	mov	r1, r4
   14dd0:	f7ff ffa6 	bl	14d20 <bt_mesh_attention>
}
   14dd4:	4628      	mov	r0, r5
   14dd6:	b006      	add	sp, #24
   14dd8:	bd70      	pop	{r4, r5, r6, pc}
   14dda:	bf00      	nop
   14ddc:	0003170b 	.word	0x0003170b
   14de0:	0003175b 	.word	0x0003175b
   14de4:	0002db24 	.word	0x0002db24
   14de8:	00032b71 	.word	0x00032b71
   14dec:	00032aa9 	.word	0x00032aa9

00014df0 <attention_set>:
{
   14df0:	b570      	push	{r4, r5, r6, lr}
   14df2:	b088      	sub	sp, #32
	BT_DBG("");
   14df4:	4b0f      	ldr	r3, [pc, #60]	; (14e34 <attention_set+0x44>)
   14df6:	9306      	str	r3, [sp, #24]
   14df8:	4b0f      	ldr	r3, [pc, #60]	; (14e38 <attention_set+0x48>)
   14dfa:	9307      	str	r3, [sp, #28]
{
   14dfc:	4604      	mov	r4, r0
	BT_DBG("");
   14dfe:	2303      	movs	r3, #3
   14e00:	480e      	ldr	r0, [pc, #56]	; (14e3c <attention_set+0x4c>)
   14e02:	9301      	str	r3, [sp, #4]
{
   14e04:	460d      	mov	r5, r1
   14e06:	4616      	mov	r6, r2
	BT_DBG("");
   14e08:	f44f 51c8 	mov.w	r1, #6400	; 0x1900
   14e0c:	aa05      	add	r2, sp, #20
   14e0e:	9305      	str	r3, [sp, #20]
   14e10:	f015 fa27 	bl	2a262 <z_log_msg2_static_create.constprop.0>
	err = attention_set_unrel(model, ctx, buf);
   14e14:	4632      	mov	r2, r6
   14e16:	4629      	mov	r1, r5
   14e18:	4620      	mov	r0, r4
   14e1a:	f7ff ffbd 	bl	14d98 <attention_set_unrel>
	if (err) {
   14e1e:	b930      	cbnz	r0, 14e2e <attention_set+0x3e>
	return send_attention_status(model, ctx);
   14e20:	4629      	mov	r1, r5
   14e22:	4620      	mov	r0, r4
}
   14e24:	b008      	add	sp, #32
   14e26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return send_attention_status(model, ctx);
   14e2a:	f7ff bf05 	b.w	14c38 <send_attention_status>
}
   14e2e:	b008      	add	sp, #32
   14e30:	bd70      	pop	{r4, r5, r6, pc}
   14e32:	bf00      	nop
   14e34:	0002ec61 	.word	0x0002ec61
   14e38:	00032b63 	.word	0x00032b63
   14e3c:	0002db24 	.word	0x0002db24

00014e40 <adv_thread>:

	BT_DBG("Advertising stopped (%u ms)", (uint32_t) k_uptime_delta(&time));
}

static void adv_thread(void *p1, void *p2, void *p3)
{
   14e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			while (!buf) {

				/* Adv timeout may be set by a call from proxy
				 * to bt_mesh_adv_gatt_start:
				 */
				adv_timeout = SYS_FOREVER_MS;
   14e44:	4e5a      	ldr	r6, [pc, #360]	; (14fb0 <adv_thread+0x170>)
{
   14e46:	b090      	sub	sp, #64	; 0x40
			buf = bt_mesh_adv_buf_get(K_NO_WAIT);
   14e48:	2000      	movs	r0, #0
   14e4a:	2100      	movs	r1, #0
   14e4c:	f7f7 f8f8 	bl	c040 <bt_mesh_adv_buf_get>
				adv_timeout = SYS_FOREVER_MS;
   14e50:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
			buf = bt_mesh_adv_buf_get(K_NO_WAIT);
   14e54:	4604      	mov	r4, r0
			while (!buf) {
   14e56:	2c00      	cmp	r4, #0
   14e58:	d06f      	beq.n	14f3a <adv_thread+0xfa>
		if (!buf) {
			continue;
		}

		/* busy == 0 means this was canceled */
		if (BT_MESH_ADV(buf)->busy) {
   14e5a:	6962      	ldr	r2, [r4, #20]
   14e5c:	7a13      	ldrb	r3, [r2, #8]
   14e5e:	0719      	lsls	r1, r3, #28
   14e60:	d565      	bpl.n	14f2e <adv_thread+0xee>
			BT_MESH_ADV(buf)->busy = 0U;
   14e62:	f36f 03c3 	bfc	r3, #3, #1
   14e66:	7213      	strb	r3, [r2, #8]
		((bt_dev.hci_version >= BT_HCI_VERSION_5_0) ?
   14e68:	4b52      	ldr	r3, [pc, #328]	; (14fb4 <adv_thread+0x174>)
			       ADV_INT_FAST_MS :
   14e6a:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
	struct bt_le_adv_param param = {};
   14e6e:	2214      	movs	r2, #20
			       ADV_INT_FAST_MS :
   14e70:	2b08      	cmp	r3, #8
	struct bt_le_adv_param param = {};
   14e72:	eb0d 0002 	add.w	r0, sp, r2
   14e76:	f04f 0100 	mov.w	r1, #0
			       ADV_INT_FAST_MS :
   14e7a:	bf8c      	ite	hi
   14e7c:	2714      	movhi	r7, #20
   14e7e:	2764      	movls	r7, #100	; 0x64
	struct bt_le_adv_param param = {};
   14e80:	f012 fd01 	bl	27886 <memset>
	adv_int = MAX(adv_int_min,
   14e84:	6960      	ldr	r0, [r4, #20]
   14e86:	7a45      	ldrb	r5, [r0, #9]
   14e88:	08ea      	lsrs	r2, r5, #3
   14e8a:	1c51      	adds	r1, r2, #1
   14e8c:	eb01 0281 	add.w	r2, r1, r1, lsl #2
   14e90:	ebb7 0f42 	cmp.w	r7, r2, lsl #1
   14e94:	bfda      	itte	le
   14e96:	4611      	movle	r1, r2
   14e98:	004b      	lslle	r3, r1, #1
   14e9a:	b2bb      	uxthgt	r3, r7
	duration = adv_int +
   14e9c:	f005 0207 	and.w	r2, r5, #7
   14ea0:	f103 050a 	add.w	r5, r3, #10
   14ea4:	fb02 5505 	mla	r5, r2, r5, r5
	ad.type = bt_mesh_adv_type[BT_MESH_ADV(buf)->type];
   14ea8:	7a02      	ldrb	r2, [r0, #8]
   14eaa:	4943      	ldr	r1, [pc, #268]	; (14fb8 <adv_thread+0x178>)
   14eac:	f002 0203 	and.w	r2, r2, #3
	duration = adv_int +
   14eb0:	441d      	add	r5, r3
	ad.type = bt_mesh_adv_type[BT_MESH_ADV(buf)->type];
   14eb2:	5c8a      	ldrb	r2, [r1, r2]
   14eb4:	f88d 200c 	strb.w	r2, [sp, #12]
	ad.data_len = buf->len;
   14eb8:	89a2      	ldrh	r2, [r4, #12]
   14eba:	f88d 200d 	strb.w	r2, [sp, #13]
	ad.data = buf->data;
   14ebe:	68a2      	ldr	r2, [r4, #8]
   14ec0:	9204      	str	r2, [sp, #16]
	duration = adv_int +
   14ec2:	b2ad      	uxth	r5, r5
	param.interval_min = BT_MESH_ADV_SCAN_UNIT(adv_int);
   14ec4:	2205      	movs	r2, #5
   14ec6:	00db      	lsls	r3, r3, #3
   14ec8:	fbb3 f3f2 	udiv	r3, r3, r2
	param.interval_max = param.interval_min;
   14ecc:	e9cd 3307 	strd	r3, r3, [sp, #28]
   14ed0:	f018 f93e 	bl	2d150 <z_impl_k_uptime_ticks>
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
   14ed4:	2300      	movs	r3, #0
   14ed6:	9300      	str	r3, [sp, #0]
   14ed8:	2201      	movs	r2, #1
   14eda:	a903      	add	r1, sp, #12
   14edc:	a805      	add	r0, sp, #20
   14ede:	f7f2 fd51 	bl	7984 <bt_le_adv_start>
	bt_mesh_adv_send_start(duration, err, BT_MESH_ADV(buf));
   14ee2:	f8d4 8014 	ldr.w	r8, [r4, #20]
			   const struct bt_data *sd, size_t sd_len);

static inline void bt_mesh_adv_send_start(uint16_t duration, int err,
					  struct bt_mesh_adv *adv)
{
	if (!adv->started) {
   14ee6:	f898 3008 	ldrb.w	r3, [r8, #8]
   14eea:	075a      	lsls	r2, r3, #29
	err = bt_le_adv_start(&param, &ad, 1, NULL, 0);
   14eec:	4607      	mov	r7, r0
   14eee:	d442      	bmi.n	14f76 <adv_thread+0x136>
		adv->started = 1;
   14ef0:	f043 0304 	orr.w	r3, r3, #4
   14ef4:	f888 3008 	strb.w	r3, [r8, #8]

		if (adv->cb && adv->cb->start) {
   14ef8:	f8d8 3000 	ldr.w	r3, [r8]
   14efc:	b133      	cbz	r3, 14f0c <adv_thread+0xcc>
   14efe:	681b      	ldr	r3, [r3, #0]
   14f00:	b123      	cbz	r3, 14f0c <adv_thread+0xcc>
			adv->cb->start(duration, err, adv->cb_data);
   14f02:	4601      	mov	r1, r0
   14f04:	f8d8 2004 	ldr.w	r2, [r8, #4]
   14f08:	4628      	mov	r0, r5
   14f0a:	4798      	blx	r3
		}

		if (err) {
   14f0c:	b3af      	cbz	r7, 14f7a <adv_thread+0x13a>
			adv->cb = NULL;
   14f0e:	2300      	movs	r3, #0
   14f10:	f8c8 3000 	str.w	r3, [r8]
		BT_ERR("Advertising failed: err %d", err);
   14f14:	4b29      	ldr	r3, [pc, #164]	; (14fbc <adv_thread+0x17c>)
   14f16:	e9cd 370e 	strd	r3, r7, [sp, #56]	; 0x38
   14f1a:	2303      	movs	r3, #3
   14f1c:	9302      	str	r3, [sp, #8]
   14f1e:	930d      	str	r3, [sp, #52]	; 0x34
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   14f20:	2300      	movs	r3, #0
   14f22:	4827      	ldr	r0, [pc, #156]	; (14fc0 <adv_thread+0x180>)
   14f24:	aa0d      	add	r2, sp, #52	; 0x34
   14f26:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   14f2a:	f010 fed5 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			adv_send(buf);
		}

		net_buf_unref(buf);
   14f2e:	4620      	mov	r0, r4
   14f30:	f00b fcb0 	bl	20894 <net_buf_unref>
	z_impl_k_yield();
   14f34:	f00f fc6a 	bl	2480c <z_impl_k_yield>
}
   14f38:	e786      	b.n	14e48 <adv_thread+0x8>
				adv_timeout = SYS_FOREVER_MS;
   14f3a:	6037      	str	r7, [r6, #0]
				(void)bt_mesh_adv_gatt_send();
   14f3c:	f014 fa66 	bl	2940c <bt_mesh_adv_gatt_send>
				buf = bt_mesh_adv_buf_get(SYS_TIMEOUT_MS(adv_timeout));
   14f40:	6835      	ldr	r5, [r6, #0]
   14f42:	1c68      	adds	r0, r5, #1
   14f44:	d013      	beq.n	14f6e <adv_thread+0x12e>
   14f46:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
   14f4a:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   14f4e:	f240 30e7 	movw	r0, #999	; 0x3e7
   14f52:	4621      	mov	r1, r4
   14f54:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   14f58:	2300      	movs	r3, #0
   14f5a:	fbc5 010c 	smlal	r0, r1, r5, ip
   14f5e:	f7eb f8bf 	bl	e0 <__aeabi_uldivmod>
   14f62:	f7f7 f86d 	bl	c040 <bt_mesh_adv_buf_get>
   14f66:	4604      	mov	r4, r0
				bt_le_adv_stop();
   14f68:	f7f2 fd3e 	bl	79e8 <bt_le_adv_stop>
   14f6c:	e773      	b.n	14e56 <adv_thread+0x16>
				buf = bt_mesh_adv_buf_get(SYS_TIMEOUT_MS(adv_timeout));
   14f6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14f72:	4601      	mov	r1, r0
   14f74:	e7f5      	b.n	14f62 <adv_thread+0x122>
	if (err) {
   14f76:	2800      	cmp	r0, #0
   14f78:	d1cc      	bne.n	14f14 <adv_thread+0xd4>
   14f7a:	2700      	movs	r7, #0
   14f7c:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   14f80:	4639      	mov	r1, r7
   14f82:	f240 30e7 	movw	r0, #999	; 0x3e7
   14f86:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   14f8a:	2300      	movs	r3, #0
   14f8c:	fbec 0105 	umlal	r0, r1, ip, r5
   14f90:	f7eb f8a6 	bl	e0 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
   14f94:	f00f fcc2 	bl	2491c <z_impl_k_sleep>
	err = bt_le_adv_stop();
   14f98:	f7f2 fd26 	bl	79e8 <bt_le_adv_stop>
	if (err) {
   14f9c:	2800      	cmp	r0, #0
   14f9e:	d0c6      	beq.n	14f2e <adv_thread+0xee>
		BT_ERR("Stopping advertising failed: err %d", err);
   14fa0:	4b08      	ldr	r3, [pc, #32]	; (14fc4 <adv_thread+0x184>)
   14fa2:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
   14fa6:	2303      	movs	r3, #3
   14fa8:	9302      	str	r3, [sp, #8]
   14faa:	930d      	str	r3, [sp, #52]	; 0x34
   14fac:	463b      	mov	r3, r7
   14fae:	e7b8      	b.n	14f22 <adv_thread+0xe2>
   14fb0:	20002788 	.word	0x20002788
   14fb4:	20000080 	.word	0x20000080
   14fb8:	000308c5 	.word	0x000308c5
   14fbc:	00032c26 	.word	0x00032c26
   14fc0:	0002dadc 	.word	0x0002dadc
   14fc4:	00032c41 	.word	0x00032c41

00014fc8 <bt_mesh_adv_init>:
{
	bt_mesh_adv_buf_get_cancel();
}

void bt_mesh_adv_init(void)
{
   14fc8:	b510      	push	{r4, lr}
   14fca:	b088      	sub	sp, #32
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   14fcc:	4c0e      	ldr	r4, [pc, #56]	; (15008 <bt_mesh_adv_init+0x40>)
   14fce:	490f      	ldr	r1, [pc, #60]	; (1500c <bt_mesh_adv_init+0x44>)
   14fd0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14fd4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14fd8:	e9cd 2306 	strd	r2, r3, [sp, #24]
   14fdc:	2300      	movs	r3, #0
   14fde:	f06f 0208 	mvn.w	r2, #8
   14fe2:	e9cd 2303 	strd	r2, r3, [sp, #12]
   14fe6:	e9cd 3301 	strd	r3, r3, [sp, #4]
   14fea:	9300      	str	r3, [sp, #0]
   14fec:	f44f 7240 	mov.w	r2, #768	; 0x300
   14ff0:	4b07      	ldr	r3, [pc, #28]	; (15010 <bt_mesh_adv_init+0x48>)
   14ff2:	4620      	mov	r0, r4
   14ff4:	f00e fe1c 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   14ff8:	4906      	ldr	r1, [pc, #24]	; (15014 <bt_mesh_adv_init+0x4c>)
   14ffa:	4620      	mov	r0, r4
	k_thread_create(&adv_thread_data, adv_thread_stack,
			K_KERNEL_STACK_SIZEOF(adv_thread_stack), adv_thread,
			NULL, NULL, NULL, K_PRIO_COOP(CONFIG_BT_MESH_ADV_PRIO),
			0, K_FOREVER);
	k_thread_name_set(&adv_thread_data, "BT Mesh adv");
}
   14ffc:	b008      	add	sp, #32
   14ffe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   15002:	f017 bd32 	b.w	2ca6a <z_impl_k_thread_name_set>
   15006:	bf00      	nop
   15008:	20001e58 	.word	0x20001e58
   1500c:	200049e0 	.word	0x200049e0
   15010:	00014e41 	.word	0x00014e41
   15014:	00032c65 	.word	0x00032c65

00015018 <bt_mesh_adv_enable>:

int bt_mesh_adv_enable(void)
{
   15018:	b508      	push	{r3, lr}
	z_impl_k_thread_start(thread);
   1501a:	4802      	ldr	r0, [pc, #8]	; (15024 <bt_mesh_adv_enable+0xc>)
   1501c:	f017 fd2a 	bl	2ca74 <z_impl_k_thread_start>
	k_thread_start(&adv_thread_data);
	return 0;
}
   15020:	2000      	movs	r0, #0
   15022:	bd08      	pop	{r3, pc}
   15024:	20001e58 	.word	0x20001e58

00015028 <bt_mesh_adv_gatt_start>:

int bt_mesh_adv_gatt_start(const struct bt_le_adv_param *param, int32_t duration,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
   15028:	b430      	push	{r4, r5}
	adv_timeout = duration;
   1502a:	4c05      	ldr	r4, [pc, #20]	; (15040 <bt_mesh_adv_gatt_start+0x18>)
{
   1502c:	460d      	mov	r5, r1
	adv_timeout = duration;
   1502e:	6025      	str	r5, [r4, #0]
	return bt_le_adv_start(param, ad, ad_len, sd, sd_len);
   15030:	9c03      	ldr	r4, [sp, #12]
{
   15032:	4611      	mov	r1, r2
   15034:	461a      	mov	r2, r3
   15036:	9b02      	ldr	r3, [sp, #8]
	return bt_le_adv_start(param, ad, ad_len, sd, sd_len);
   15038:	9402      	str	r4, [sp, #8]
}
   1503a:	bc30      	pop	{r4, r5}
	return bt_le_adv_start(param, ad, ad_len, sd, sd_len);
   1503c:	f7f2 bca2 	b.w	7984 <bt_le_adv_start>
   15040:	20002788 	.word	0x20002788

00015044 <atomic_test_and_clear_bit.constprop.0>:
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
   15044:	b500      	push	{lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
   15046:	2301      	movs	r3, #1
   15048:	fa03 f000 	lsl.w	r0, r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1504c:	4b0a      	ldr	r3, [pc, #40]	; (15078 <atomic_test_and_clear_bit.constprop.0+0x34>)
   1504e:	f3bf 8f5b 	dmb	ish
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   15052:	43c1      	mvns	r1, r0
   15054:	e853 2f00 	ldrex	r2, [r3]
   15058:	ea02 0c01 	and.w	ip, r2, r1
   1505c:	e843 ce00 	strex	lr, ip, [r3]
   15060:	f1be 0f00 	cmp.w	lr, #0
   15064:	d1f6      	bne.n	15054 <atomic_test_and_clear_bit.constprop.0+0x10>
   15066:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   1506a:	4202      	tst	r2, r0
}
   1506c:	bf14      	ite	ne
   1506e:	2001      	movne	r0, #1
   15070:	2000      	moveq	r0, #0
   15072:	f85d fb04 	ldr.w	pc, [sp], #4
   15076:	bf00      	nop
   15078:	2000278c 	.word	0x2000278c

0001507c <mesh_commit>:

	return 0;
}

static int mesh_commit(void)
{
   1507c:	b508      	push	{r3, lr}
	if (!bt_mesh_subnet_next(NULL)) {
   1507e:	2000      	movs	r0, #0
   15080:	f7f8 fd1e 	bl	dac0 <bt_mesh_subnet_next>
   15084:	b1a0      	cbz	r0, 150b0 <mesh_commit+0x34>
		/* Nothing to do since we're not yet provisioned */
		return 0;
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT)) {
		(void)bt_mesh_pb_gatt_disable();
   15086:	f003 faef 	bl	18668 <bt_mesh_pb_gatt_disable>
	}

	bt_mesh_net_settings_commit();
   1508a:	f7f8 fac9 	bl	d620 <bt_mesh_net_settings_commit>
	bt_mesh_model_settings_commit();
   1508e:	f7fc f899 	bl	111c4 <bt_mesh_model_settings_commit>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   15092:	f3bf 8f5b 	dmb	ish
   15096:	4b07      	ldr	r3, [pc, #28]	; (150b4 <mesh_commit+0x38>)
   15098:	e853 2f00 	ldrex	r2, [r3]
   1509c:	f042 0201 	orr.w	r2, r2, #1
   150a0:	e843 2100 	strex	r1, r2, [r3]
   150a4:	2900      	cmp	r1, #0
   150a6:	d1f7      	bne.n	15098 <mesh_commit+0x1c>
   150a8:	f3bf 8f5b 	dmb	ish

	atomic_set_bit(bt_mesh.flags, BT_MESH_VALID);

	bt_mesh_start();
   150ac:	f7f6 fc94 	bl	b9d8 <bt_mesh_start>

	return 0;
}
   150b0:	2000      	movs	r0, #0
   150b2:	bd08      	pop	{r3, pc}
   150b4:	20001ab0 	.word	0x20001ab0

000150b8 <bt_mesh_settings_set>:
{
   150b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   150ba:	b089      	sub	sp, #36	; 0x24
   150bc:	4604      	mov	r4, r0
   150be:	4608      	mov	r0, r1
   150c0:	af00      	add	r7, sp, #0
   150c2:	4611      	mov	r1, r2
	len = read_cb(cb_arg, out, read_len);
   150c4:	461a      	mov	r2, r3
{
   150c6:	461d      	mov	r5, r3
	len = read_cb(cb_arg, out, read_len);
   150c8:	47a0      	blx	r4
	if (len < 0) {
   150ca:	1e04      	subs	r4, r0, #0
   150cc:	da11      	bge.n	150f2 <bt_mesh_settings_set+0x3a>
		BT_ERR("Failed to read value (err %zd)", len);
   150ce:	4b16      	ldr	r3, [pc, #88]	; (15128 <bt_mesh_settings_set+0x70>)
   150d0:	e9c7 3406 	strd	r3, r4, [r7, #24]
   150d4:	2303      	movs	r3, #3
   150d6:	607b      	str	r3, [r7, #4]
   150d8:	617b      	str	r3, [r7, #20]
   150da:	4814      	ldr	r0, [pc, #80]	; (1512c <bt_mesh_settings_set+0x74>)
   150dc:	2300      	movs	r3, #0
   150de:	f107 0214 	add.w	r2, r7, #20
   150e2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   150e6:	f010 fdf7 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   150ea:	4620      	mov	r0, r4
   150ec:	3724      	adds	r7, #36	; 0x24
   150ee:	46bd      	mov	sp, r7
   150f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (len != read_len) {
   150f2:	42a5      	cmp	r5, r4
   150f4:	d015      	beq.n	15122 <bt_mesh_settings_set+0x6a>
		BT_ERR("Unexpected value length (%zd != %zu)", len, read_len);
   150f6:	466e      	mov	r6, sp
   150f8:	b088      	sub	sp, #32
   150fa:	4669      	mov	r1, sp
   150fc:	4b0c      	ldr	r3, [pc, #48]	; (15130 <bt_mesh_settings_set+0x78>)
   150fe:	618d      	str	r5, [r1, #24]
   15100:	460a      	mov	r2, r1
   15102:	e9c1 3404 	strd	r3, r4, [r1, #16]
   15106:	2304      	movs	r3, #4
   15108:	f842 3f0c 	str.w	r3, [r2, #12]!
   1510c:	60bb      	str	r3, [r7, #8]
   1510e:	4807      	ldr	r0, [pc, #28]	; (1512c <bt_mesh_settings_set+0x74>)
   15110:	2300      	movs	r3, #0
   15112:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   15116:	f010 fddf 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   1511a:	f06f 0415 	mvn.w	r4, #21
   1511e:	46b5      	mov	sp, r6
   15120:	e7e3      	b.n	150ea <bt_mesh_settings_set+0x32>
	return 0;
   15122:	2400      	movs	r4, #0
   15124:	e7e1      	b.n	150ea <bt_mesh_settings_set+0x32>
   15126:	bf00      	nop
   15128:	00031a17 	.word	0x00031a17
   1512c:	0002db84 	.word	0x0002db84
   15130:	00032c84 	.word	0x00032c84

00015134 <bt_mesh_settings_store_schedule>:
			      BIT(BT_MESH_SETTINGS_CFG_PENDING)      |      \
			      BIT(BT_MESH_SETTINGS_MOD_PENDING)      |      \
			      BIT(BT_MESH_SETTINGS_VA_PENDING))

void bt_mesh_settings_store_schedule(enum bt_mesh_settings_flag flag)
{
   15134:	b570      	push	{r4, r5, r6, lr}
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   15136:	4b2a      	ldr	r3, [pc, #168]	; (151e0 <bt_mesh_settings_store_schedule+0xac>)
   15138:	f3bf 8f5b 	dmb	ish
   1513c:	0942      	lsrs	r2, r0, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   1513e:	2101      	movs	r1, #1
   15140:	f000 001f 	and.w	r0, r0, #31
   15144:	fa01 f000 	lsl.w	r0, r1, r0
   15148:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   1514c:	e852 1f00 	ldrex	r1, [r2]
   15150:	4301      	orrs	r1, r0
   15152:	e842 1400 	strex	r4, r1, [r2]
   15156:	2c00      	cmp	r4, #0
   15158:	d1f8      	bne.n	1514c <bt_mesh_settings_store_schedule+0x18>
   1515a:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1515e:	f3bf 8f5b 	dmb	ish
   15162:	681a      	ldr	r2, [r3, #0]
   15164:	f3bf 8f5b 	dmb	ish
	uint32_t timeout_ms, remaining_ms;

	atomic_set_bit(pending_flags, flag);

	if (atomic_get(pending_flags) & NO_WAIT_PENDING_BITS) {
   15168:	f412 6f87 	tst.w	r2, #1080	; 0x438
   1516c:	d132      	bne.n	151d4 <bt_mesh_settings_store_schedule+0xa0>
   1516e:	f3bf 8f5b 	dmb	ish
   15172:	681a      	ldr	r2, [r3, #0]
   15174:	f3bf 8f5b 	dmb	ish
		timeout_ms = 0;
	} else if (CONFIG_BT_MESH_RPL_STORE_TIMEOUT >= 0 &&
   15178:	07d2      	lsls	r2, r2, #31
   1517a:	d41f      	bmi.n	151bc <bt_mesh_settings_store_schedule+0x88>
		   atomic_test_bit(pending_flags, BT_MESH_SETTINGS_RPL_PENDING) &&
		   !(atomic_get(pending_flags) & GENERIC_PENDING_BITS)) {
		timeout_ms = CONFIG_BT_MESH_RPL_STORE_TIMEOUT * MSEC_PER_SEC;
	} else {
		timeout_ms = CONFIG_BT_MESH_STORE_TIMEOUT * MSEC_PER_SEC;
   1517c:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   15180:	4818      	ldr	r0, [pc, #96]	; (151e4 <bt_mesh_settings_store_schedule+0xb0>)
   15182:	f017 ffa7 	bl	2d0d4 <z_timeout_remaining>
   15186:	4604      	mov	r4, r0
   15188:	f240 30e7 	movw	r0, #999	; 0x3e7
   1518c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   15190:	2300      	movs	r3, #0
   15192:	eb00 30c5 	add.w	r0, r0, r5, lsl #15
   15196:	2100      	movs	r1, #0
   15198:	f7ea ffa2 	bl	e0 <__aeabi_uldivmod>
   1519c:	4602      	mov	r2, r0
			return (uint32_t)((t * to_hz + off) / from_hz);
   1519e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   151a2:	fba4 4000 	umull	r4, r0, r4, r0
   151a6:	0be4      	lsrs	r4, r4, #15
   151a8:	ea44 4440 	orr.w	r4, r4, r0, lsl #17

	/* If the new deadline is sooner, override any existing
	 * deadline; otherwise schedule without changing any existing
	 * deadline.
	 */
	if (timeout_ms < remaining_ms) {
   151ac:	42a5      	cmp	r5, r4
		k_work_reschedule(&pending_store, K_MSEC(timeout_ms));
   151ae:	480e      	ldr	r0, [pc, #56]	; (151e8 <bt_mesh_settings_store_schedule+0xb4>)
			return ((t * to_hz + off) / from_hz);
   151b0:	460b      	mov	r3, r1
	if (timeout_ms < remaining_ms) {
   151b2:	d211      	bcs.n	151d8 <bt_mesh_settings_store_schedule+0xa4>
	} else {
		k_work_schedule(&pending_store, K_MSEC(timeout_ms));
	}
}
   151b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_reschedule(&pending_store, K_MSEC(timeout_ms));
   151b8:	f00f b8d4 	b.w	24364 <k_work_reschedule>
   151bc:	f3bf 8f5b 	dmb	ish
   151c0:	681a      	ldr	r2, [r3, #0]
   151c2:	f3bf 8f5b 	dmb	ish
		   atomic_test_bit(pending_flags, BT_MESH_SETTINGS_RPL_PENDING) &&
   151c6:	f240 33c6 	movw	r3, #966	; 0x3c6
   151ca:	421a      	tst	r2, r3
   151cc:	d1d6      	bne.n	1517c <bt_mesh_settings_store_schedule+0x48>
		timeout_ms = CONFIG_BT_MESH_RPL_STORE_TIMEOUT * MSEC_PER_SEC;
   151ce:	f241 3588 	movw	r5, #5000	; 0x1388
   151d2:	e7d5      	b.n	15180 <bt_mesh_settings_store_schedule+0x4c>
		timeout_ms = 0;
   151d4:	2500      	movs	r5, #0
   151d6:	e7d3      	b.n	15180 <bt_mesh_settings_store_schedule+0x4c>
}
   151d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_schedule(&pending_store, K_MSEC(timeout_ms));
   151dc:	f00f b88e 	b.w	242fc <k_work_schedule>
   151e0:	2000278c 	.word	0x2000278c
   151e4:	20001ee8 	.word	0x20001ee8
   151e8:	20001ed8 	.word	0x20001ed8

000151ec <bt_mesh_settings_store_cancel>:
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   151ec:	0942      	lsrs	r2, r0, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   151ee:	2301      	movs	r3, #1
   151f0:	f000 001f 	and.w	r0, r0, #31
   151f4:	fa03 f000 	lsl.w	r0, r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   151f8:	4b07      	ldr	r3, [pc, #28]	; (15218 <bt_mesh_settings_store_cancel+0x2c>)
   151fa:	f3bf 8f5b 	dmb	ish
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   151fe:	43c0      	mvns	r0, r0
   15200:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   15204:	e853 2f00 	ldrex	r2, [r3]
   15208:	4002      	ands	r2, r0
   1520a:	e843 2100 	strex	r1, r2, [r3]
   1520e:	2900      	cmp	r1, #0
   15210:	d1f8      	bne.n	15204 <bt_mesh_settings_store_cancel+0x18>
   15212:	f3bf 8f5b 	dmb	ish

void bt_mesh_settings_store_cancel(enum bt_mesh_settings_flag flag)
{
	atomic_clear_bit(pending_flags, flag);
}
   15216:	4770      	bx	lr
   15218:	2000278c 	.word	0x2000278c

0001521c <bt_mesh_settings_init>:
	}
}

void bt_mesh_settings_init(void)
{
	k_work_init_delayable(&pending_store, store_pending);
   1521c:	4901      	ldr	r1, [pc, #4]	; (15224 <bt_mesh_settings_init+0x8>)
   1521e:	4802      	ldr	r0, [pc, #8]	; (15228 <bt_mesh_settings_init+0xc>)
   15220:	f017 bde3 	b.w	2cdea <k_work_init_delayable>
   15224:	0002a26f 	.word	0x0002a26f
   15228:	20001ed8 	.word	0x20001ed8

0001522c <send_friend_clear>:
static const struct bt_mesh_send_cb clear_sent_cb = {
	.end = friend_clear_sent,
};

static void send_friend_clear(struct bt_mesh_friend *frnd)
{
   1522c:	b510      	push	{r4, lr}
	struct bt_mesh_msg_ctx ctx = {
		.net_idx  = frnd->subnet->net_idx,
   1522e:	6902      	ldr	r2, [r0, #16]
{
   15230:	b08a      	sub	sp, #40	; 0x28
	struct bt_mesh_msg_ctx ctx = {
   15232:	8b91      	ldrh	r1, [r2, #28]
   15234:	f8ad 1010 	strh.w	r1, [sp, #16]
   15238:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1523c:	2300      	movs	r3, #0
   1523e:	f8ad 1012 	strh.w	r1, [sp, #18]
   15242:	f8b0 10b4 	ldrh.w	r1, [r0, #180]	; 0xb4
   15246:	f8cd 3016 	str.w	r3, [sp, #22]
   1524a:	f88d 301a 	strb.w	r3, [sp, #26]
   1524e:	f8ad 1014 	strh.w	r1, [sp, #20]
		.app_idx  = BT_MESH_KEY_UNUSED,
		.addr     = frnd->clear.frnd,
		.send_ttl = BT_MESH_TTL_MAX,
	};
	struct bt_mesh_net_tx tx = {
   15252:	9309      	str	r3, [sp, #36]	; 0x24
	struct bt_mesh_msg_ctx ctx = {
   15254:	217f      	movs	r1, #127	; 0x7f
	struct bt_mesh_net_tx tx = {
   15256:	ab04      	add	r3, sp, #16
{
   15258:	4604      	mov	r4, r0
	struct bt_mesh_msg_ctx ctx = {
   1525a:	f88d 101b 	strb.w	r1, [sp, #27]
	struct bt_mesh_net_tx tx = {
   1525e:	9207      	str	r2, [sp, #28]
   15260:	9308      	str	r3, [sp, #32]
		.sub  = frnd->subnet,
		.ctx  = &ctx,
		.src  = bt_mesh_primary_addr(),
   15262:	f7fb fdff 	bl	10e64 <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   15266:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
   1526a:	f7f6 fd65 	bl	bd38 <bt_mesh_net_transmit_get>
	};
	struct bt_mesh_ctl_friend_clear req = {
   1526e:	8823      	ldrh	r3, [r4, #0]
	struct bt_mesh_net_tx tx = {
   15270:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
	struct bt_mesh_ctl_friend_clear req = {
   15274:	ba5b      	rev16	r3, r3
   15276:	f8ad 300c 	strh.w	r3, [sp, #12]
   1527a:	8963      	ldrh	r3, [r4, #10]
		.lpn_counter = sys_cpu_to_be16(frnd->lpn_counter),
	};

	BT_DBG("");

	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR, &req,
   1527c:	9401      	str	r4, [sp, #4]
	struct bt_mesh_ctl_friend_clear req = {
   1527e:	ba5b      	rev16	r3, r3
   15280:	f8ad 300e 	strh.w	r3, [sp, #14]
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR, &req,
   15284:	4b04      	ldr	r3, [pc, #16]	; (15298 <send_friend_clear+0x6c>)
   15286:	9300      	str	r3, [sp, #0]
   15288:	aa03      	add	r2, sp, #12
   1528a:	2304      	movs	r3, #4
   1528c:	2105      	movs	r1, #5
   1528e:	a807      	add	r0, sp, #28
   15290:	f7f9 fc9a 	bl	ebc8 <bt_mesh_ctl_send>
			 sizeof(req), &clear_sent_cb, frnd);
}
   15294:	b00a      	add	sp, #40	; 0x28
   15296:	bd10      	pop	{r4, pc}
   15298:	0002e734 	.word	0x0002e734

0001529c <buf_send_end>:
		frnd->last = NULL;
	}
}

static void buf_send_end(int err, void *user_data)
{
   1529c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_mesh_friend *frnd = user_data;

	BT_DBG("err %d", err);

	if (frnd->pending_req) {
   1529e:	78cb      	ldrb	r3, [r1, #3]
   152a0:	f013 0504 	ands.w	r5, r3, #4
{
   152a4:	b089      	sub	sp, #36	; 0x24
	if (frnd->pending_req) {
   152a6:	d00c      	beq.n	152c2 <buf_send_end+0x26>
		BT_WARN("Another request before previous completed sending");
   152a8:	4b15      	ldr	r3, [pc, #84]	; (15300 <buf_send_end+0x64>)
   152aa:	9306      	str	r3, [sp, #24]
   152ac:	4815      	ldr	r0, [pc, #84]	; (15304 <buf_send_end+0x68>)
   152ae:	2302      	movs	r3, #2
   152b0:	aa05      	add	r2, sp, #20
   152b2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   152b6:	9301      	str	r3, [sp, #4]
   152b8:	9305      	str	r3, [sp, #20]
   152ba:	f015 f88f 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
	} else {
		/* Friend offer timeout is 1 second */
		k_work_reschedule(&frnd->timer, K_SECONDS(1));
		BT_DBG("Waiting for first poll");
	}
}
   152be:	b009      	add	sp, #36	; 0x24
   152c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (frnd->established) {
   152c2:	06db      	lsls	r3, r3, #27
		k_work_reschedule(&frnd->timer, K_MSEC(frnd->poll_to));
   152c4:	f101 0660 	add.w	r6, r1, #96	; 0x60
	if (frnd->established) {
   152c8:	d516      	bpl.n	152f8 <buf_send_end+0x5c>
		k_work_reschedule(&frnd->timer, K_MSEC(frnd->poll_to));
   152ca:	684c      	ldr	r4, [r1, #4]
   152cc:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   152d0:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   152d4:	f240 30e7 	movw	r0, #999	; 0x3e7
   152d8:	4629      	mov	r1, r5
   152da:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   152de:	2300      	movs	r3, #0
   152e0:	fbc4 0107 	smlal	r0, r1, r4, r7
   152e4:	f7ea fefc 	bl	e0 <__aeabi_uldivmod>
   152e8:	4602      	mov	r2, r0
   152ea:	460b      	mov	r3, r1
		k_work_reschedule(&frnd->timer, K_SECONDS(1));
   152ec:	4630      	mov	r0, r6
}
   152ee:	b009      	add	sp, #36	; 0x24
   152f0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		k_work_reschedule(&frnd->timer, K_SECONDS(1));
   152f4:	f00f b836 	b.w	24364 <k_work_reschedule>
   152f8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   152fc:	2300      	movs	r3, #0
   152fe:	e7f5      	b.n	152ec <buf_send_end+0x50>
   15300:	00032cc2 	.word	0x00032cc2
   15304:	0002db0c 	.word	0x0002db0c

00015308 <friend_clear>:
{
   15308:	b570      	push	{r4, r5, r6, lr}
   1530a:	4604      	mov	r4, r0
	(void)k_work_cancel_delayable(&frnd->timer);
   1530c:	3060      	adds	r0, #96	; 0x60
   1530e:	f017 fd7a 	bl	2ce06 <k_work_cancel_delayable>
	memset(frnd->cred, 0, sizeof(frnd->cred));
   15312:	2242      	movs	r2, #66	; 0x42
   15314:	2100      	movs	r1, #0
   15316:	f104 0014 	add.w	r0, r4, #20
   1531a:	f012 fab4 	bl	27886 <memset>
	if (frnd->last) {
   1531e:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   15322:	b120      	cbz	r0, 1532e <friend_clear+0x26>
		net_buf_unref(frnd->last);
   15324:	f00b fab6 	bl	20894 <net_buf_unref>
		frnd->last = NULL;
   15328:	2300      	movs	r3, #0
   1532a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	purge_buffers(&frnd->queue);
   1532e:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   15332:	f015 f869 	bl	2a408 <purge_buffers>
		purge_buffers(&seg->queue);
   15336:	f104 0090 	add.w	r0, r4, #144	; 0x90
   1533a:	f015 f865 	bl	2a408 <purge_buffers>
	STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   1533e:	4d12      	ldr	r5, [pc, #72]	; (15388 <friend_clear+0x80>)
   15340:	4e12      	ldr	r6, [pc, #72]	; (1538c <friend_clear+0x84>)
		seg->seg_count = 0U;
   15342:	2300      	movs	r3, #0
   15344:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
	STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15348:	42b5      	cmp	r5, r6
   1534a:	d311      	bcc.n	15370 <friend_clear+0x68>
	frnd->counter++;
   1534c:	89a3      	ldrh	r3, [r4, #12]
   1534e:	3301      	adds	r3, #1
   15350:	81a3      	strh	r3, [r4, #12]
	frnd->fsn = 0U;
   15352:	78e3      	ldrb	r3, [r4, #3]
	frnd->subnet = NULL;
   15354:	2100      	movs	r1, #0
	frnd->fsn = 0U;
   15356:	f023 031d 	bic.w	r3, r3, #29
	frnd->subnet = NULL;
   1535a:	6121      	str	r1, [r4, #16]
	frnd->queue_size = 0U;
   1535c:	f8c4 10a8 	str.w	r1, [r4, #168]	; 0xa8
	frnd->fsn = 0U;
   15360:	70e3      	strb	r3, [r4, #3]
	(void)memset(frnd->sub_list, 0, sizeof(frnd->sub_list));
   15362:	f104 0056 	add.w	r0, r4, #86	; 0x56
   15366:	2206      	movs	r2, #6
}
   15368:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(void)memset(frnd->sub_list, 0, sizeof(frnd->sub_list));
   1536c:	f012 ba8b 	b.w	27886 <memset>
		if (frnd->established && cb->terminated) {
   15370:	78e3      	ldrb	r3, [r4, #3]
   15372:	06db      	lsls	r3, r3, #27
   15374:	d505      	bpl.n	15382 <friend_clear+0x7a>
   15376:	686b      	ldr	r3, [r5, #4]
   15378:	b11b      	cbz	r3, 15382 <friend_clear+0x7a>
			cb->terminated(frnd->subnet->net_idx, frnd->lpn);
   1537a:	6922      	ldr	r2, [r4, #16]
   1537c:	8821      	ldrh	r1, [r4, #0]
   1537e:	8b90      	ldrh	r0, [r2, #28]
   15380:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15382:	350c      	adds	r5, #12
   15384:	e7e0      	b.n	15348 <friend_clear+0x40>
   15386:	bf00      	nop
   15388:	0002d868 	.word	0x0002d868
   1538c:	0002d868 	.word	0x0002d868

00015390 <enqueue_friend_pdu>:
{
   15390:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15394:	b089      	sub	sp, #36	; 0x24
   15396:	4604      	mov	r4, r0
   15398:	9d10      	ldr	r5, [sp, #64]	; 0x40
   1539a:	4617      	mov	r7, r2
   1539c:	4698      	mov	r8, r3
	if (type == BT_MESH_FRIEND_PDU_SINGLE) {
   1539e:	460e      	mov	r6, r1
   153a0:	b959      	cbnz	r1, 153ba <enqueue_friend_pdu+0x2a>
	net_buf_slist_put(&frnd->queue, buf);
   153a2:	4629      	mov	r1, r5
   153a4:	30a0      	adds	r0, #160	; 0xa0
   153a6:	f016 fc67 	bl	2bc78 <net_buf_slist_put>
	frnd->queue_size++;
   153aa:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   153ae:	3301      	adds	r3, #1
   153b0:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
}
   153b4:	b009      	add	sp, #36	; 0x24
   153b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint16_t seq_zero = (((buf->data[10] << 8 | buf->data[11]) >> 2) & TRANS_SEQ_ZERO_MASK);
   153ba:	68ab      	ldr	r3, [r5, #8]
   153bc:	895a      	ldrh	r2, [r3, #10]
		struct bt_mesh_friend_seg *seg = &frnd->seg[i];
   153be:	f100 0990 	add.w	r9, r0, #144	; 0x90
	uint16_t seq_zero = (((buf->data[10] << 8 | buf->data[11]) >> 2) & TRANS_SEQ_ZERO_MASK);
   153c2:	ba52      	rev16	r2, r2
		if (is_seg(seg, src, seq_zero)) {
   153c4:	f3c2 028c 	ubfx	r2, r2, #2, #13
   153c8:	4639      	mov	r1, r7
   153ca:	4648      	mov	r0, r9
   153cc:	f015 f852 	bl	2a474 <is_seg>
   153d0:	b920      	cbnz	r0, 153dc <enqueue_friend_pdu+0x4c>
		if (!unassigned && !sys_slist_peek_head(&seg->queue)) {
   153d2:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   153d6:	b9eb      	cbnz	r3, 15414 <enqueue_friend_pdu+0x84>
		unassigned->seg_count = seg_count;
   153d8:	f884 8098 	strb.w	r8, [r4, #152]	; 0x98
	net_buf_slist_put(&seg->queue, buf);
   153dc:	4629      	mov	r1, r5
   153de:	4648      	mov	r0, r9
   153e0:	f016 fc4a 	bl	2bc78 <net_buf_slist_put>
	if (type == BT_MESH_FRIEND_PDU_COMPLETE) {
   153e4:	2e02      	cmp	r6, #2
   153e6:	d129      	bne.n	1543c <enqueue_friend_pdu+0xac>
	return list->tail;
   153e8:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
   153ec:	e9d4 2124 	ldrd	r2, r1, [r4, #144]	; 0x90
Z_GENLIST_APPEND_LIST(slist, snode)
   153f0:	bb13      	cbnz	r3, 15438 <enqueue_friend_pdu+0xa8>
	list->head = node;
   153f2:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
		frnd->queue_size += seg->seg_count;
   153f6:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
	list->tail = node;
   153fa:	f8c4 10a4 	str.w	r1, [r4, #164]	; 0xa4
   153fe:	f894 1098 	ldrb.w	r1, [r4, #152]	; 0x98
	list->head = NULL;
   15402:	2300      	movs	r3, #0
   15404:	440a      	add	r2, r1
	list->tail = NULL;
   15406:	e9c4 3324 	strd	r3, r3, [r4, #144]	; 0x90
   1540a:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
		seg->seg_count = 0U;
   1540e:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
   15412:	e7cf      	b.n	153b4 <enqueue_friend_pdu+0x24>
		BT_ERR("No free friend segment RX contexts for 0x%04x", src);
   15414:	4b0c      	ldr	r3, [pc, #48]	; (15448 <enqueue_friend_pdu+0xb8>)
   15416:	480d      	ldr	r0, [pc, #52]	; (1544c <enqueue_friend_pdu+0xbc>)
   15418:	e9cd 3706 	strd	r3, r7, [sp, #24]
   1541c:	aa05      	add	r2, sp, #20
   1541e:	2303      	movs	r3, #3
   15420:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   15424:	9301      	str	r3, [sp, #4]
   15426:	9305      	str	r3, [sp, #20]
   15428:	f014 ffd8 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		net_buf_unref(buf);
   1542c:	4628      	mov	r0, r5
}
   1542e:	b009      	add	sp, #36	; 0x24
   15430:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		net_buf_unref(buf);
   15434:	f00b ba2e 	b.w	20894 <net_buf_unref>
	parent->next = child;
   15438:	601a      	str	r2, [r3, #0]
}
   1543a:	e7dc      	b.n	153f6 <enqueue_friend_pdu+0x66>
		buf->flags |= NET_BUF_FRAGS;
   1543c:	796b      	ldrb	r3, [r5, #5]
   1543e:	f043 0301 	orr.w	r3, r3, #1
   15442:	716b      	strb	r3, [r5, #5]
   15444:	e7b6      	b.n	153b4 <enqueue_friend_pdu+0x24>
   15446:	bf00      	nop
   15448:	00032cf4 	.word	0x00032cf4
   1544c:	0002db0c 	.word	0x0002db0c

00015450 <friend_queue_prepare_space>:
	return someone_has_space;
}

static bool friend_queue_prepare_space(struct bt_mesh_friend *frnd, uint16_t addr,
				       const uint64_t *seq_auth, uint8_t seg_count)
{
   15450:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   15454:	2b10      	cmp	r3, #16
{
   15456:	b088      	sub	sp, #32
   15458:	4605      	mov	r5, r0
   1545a:	461e      	mov	r6, r3
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   1545c:	d905      	bls.n	1546a <friend_queue_prepare_space+0x1a>
	bool pending_segments;
	uint8_t avail_space;

	if (!friend_queue_has_space(frnd, addr, seq_auth, seg_count)) {
		return false;
   1545e:	f04f 0900 	mov.w	r9, #0

		net_buf_unref(buf);
	}

	return true;
}
   15462:	4648      	mov	r0, r9
   15464:	b008      	add	sp, #32
   15466:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1546a:	f015 f833 	bl	2a4d4 <friend_queue_has_space.part.0>
	if (!friend_queue_has_space(frnd, addr, seq_auth, seg_count)) {
   1546e:	4681      	mov	r9, r0
   15470:	2800      	cmp	r0, #0
   15472:	d0f4      	beq.n	1545e <friend_queue_prepare_space+0xe>
	avail_space = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - frnd->queue_size;
   15474:	f8d5 40a8 	ldr.w	r4, [r5, #168]	; 0xa8
	pending_segments = false;
   15478:	2700      	movs	r7, #0
	avail_space = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - frnd->queue_size;
   1547a:	f1c4 0410 	rsb	r4, r4, #16
   1547e:	b2e4      	uxtb	r4, r4
		buf->frags = NULL;
   15480:	46ba      	mov	sl, r7
	while (pending_segments || avail_space < seg_count) {
   15482:	b90f      	cbnz	r7, 15488 <friend_queue_prepare_space+0x38>
   15484:	42a6      	cmp	r6, r4
   15486:	d9ec      	bls.n	15462 <friend_queue_prepare_space+0x12>
	return list->head;
   15488:	f8d5 80a0 	ldr.w	r8, [r5, #160]	; 0xa0
Z_GENLIST_GET(slist, snode)
   1548c:	f1b8 0f00 	cmp.w	r8, #0
   15490:	d10b      	bne.n	154aa <friend_queue_prepare_space+0x5a>
			BT_ERR("Unable to free up enough buffers");
   15492:	4b15      	ldr	r3, [pc, #84]	; (154e8 <friend_queue_prepare_space+0x98>)
   15494:	9306      	str	r3, [sp, #24]
   15496:	4815      	ldr	r0, [pc, #84]	; (154ec <friend_queue_prepare_space+0x9c>)
   15498:	2302      	movs	r3, #2
   1549a:	aa05      	add	r2, sp, #20
   1549c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   154a0:	9301      	str	r3, [sp, #4]
   154a2:	9305      	str	r3, [sp, #20]
   154a4:	f014 ff9a 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
			return false;
   154a8:	e7d9      	b.n	1545e <friend_queue_prepare_space+0xe>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   154aa:	f8d5 20a4 	ldr.w	r2, [r5, #164]	; 0xa4
	return node->next;
   154ae:	f8d8 3000 	ldr.w	r3, [r8]
	list->head = node;
   154b2:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   154b6:	4590      	cmp	r8, r2
   154b8:	d101      	bne.n	154be <friend_queue_prepare_space+0x6e>
	list->tail = node;
   154ba:	f8c5 30a4 	str.w	r3, [r5, #164]	; 0xa4
		frnd->queue_size--;
   154be:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
   154c2:	3b01      	subs	r3, #1
   154c4:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
		pending_segments = (buf->flags & NET_BUF_FRAGS);
   154c8:	f898 2005 	ldrb.w	r2, [r8, #5]
		buf->frags = NULL;
   154cc:	f8c8 a000 	str.w	sl, [r8]
		pending_segments = (buf->flags & NET_BUF_FRAGS);
   154d0:	f002 0701 	and.w	r7, r2, #1
		buf->flags &= ~NET_BUF_FRAGS;
   154d4:	f022 0201 	bic.w	r2, r2, #1
		avail_space++;
   154d8:	3401      	adds	r4, #1
		buf->flags &= ~NET_BUF_FRAGS;
   154da:	f888 2005 	strb.w	r2, [r8, #5]
		net_buf_unref(buf);
   154de:	4640      	mov	r0, r8
		avail_space++;
   154e0:	b2e4      	uxtb	r4, r4
		net_buf_unref(buf);
   154e2:	f00b f9d7 	bl	20894 <net_buf_unref>
   154e6:	e7cc      	b.n	15482 <friend_queue_prepare_space+0x32>
   154e8:	00032d22 	.word	0x00032d22
   154ec:	0002db0c 	.word	0x0002db0c

000154f0 <create_friend_pdu.constprop.0>:
static struct net_buf *create_friend_pdu(struct bt_mesh_friend *frnd,
   154f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return net_buf_alloc_fixed(pool, timeout);
   154f2:	2200      	movs	r2, #0
   154f4:	4604      	mov	r4, r0
   154f6:	2300      	movs	r3, #0
   154f8:	481c      	ldr	r0, [pc, #112]	; (1556c <create_friend_pdu.constprop.0+0x7c>)
   154fa:	460f      	mov	r7, r1
   154fc:	f016 fb93 	bl	2bc26 <net_buf_alloc_fixed>
	if (!buf) {
   15500:	4606      	mov	r6, r0
   15502:	b380      	cbz	r0, 15566 <create_friend_pdu.constprop.0+0x76>
	FRIEND_ADV(buf) = adv_alloc(net_buf_id(buf));
   15504:	f00b f90a 	bl	2071c <net_buf_id>
	adv_pool[id].app_idx = BT_MESH_KEY_UNUSED;
   15508:	4b19      	ldr	r3, [pc, #100]	; (15570 <create_friend_pdu.constprop.0+0x80>)
	net_buf_add_u8(buf, (info->iv_index & 1) << 7); /* Will be reset in encryption */
   1550a:	68a1      	ldr	r1, [r4, #8]
	adv_pool[id].app_idx = BT_MESH_KEY_UNUSED;
   1550c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15510:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
	return net_buf_simple_add_u8(&buf->b, val);
   15514:	f106 0508 	add.w	r5, r6, #8
	return &adv_pool[id];
   15518:	eb03 0340 	add.w	r3, r3, r0, lsl #1
	net_buf_add_u8(buf, (info->iv_index & 1) << 7); /* Will be reset in encryption */
   1551c:	01c9      	lsls	r1, r1, #7
	FRIEND_ADV(buf) = adv_alloc(net_buf_id(buf));
   1551e:	6173      	str	r3, [r6, #20]
   15520:	f001 0180 	and.w	r1, r1, #128	; 0x80
   15524:	4628      	mov	r0, r5
   15526:	f016 fc18 	bl	2bd5a <net_buf_simple_add_u8>
	if (info->ctl) {
   1552a:	f994 3007 	ldrsb.w	r3, [r4, #7]
   1552e:	79e1      	ldrb	r1, [r4, #7]
   15530:	2b00      	cmp	r3, #0
		net_buf_add_u8(buf, info->ttl | 0x80);
   15532:	f001 017f 	and.w	r1, r1, #127	; 0x7f
   15536:	bfb8      	it	lt
   15538:	f041 0180 	orrlt.w	r1, r1, #128	; 0x80
   1553c:	4628      	mov	r0, r5
   1553e:	f016 fc0c 	bl	2bd5a <net_buf_simple_add_u8>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   15542:	2203      	movs	r2, #3
   15544:	1d21      	adds	r1, r4, #4
   15546:	4628      	mov	r0, r5
   15548:	f016 fbfe 	bl	2bd48 <net_buf_simple_add_mem>
	net_buf_simple_add_be16(&buf->b, val);
   1554c:	8821      	ldrh	r1, [r4, #0]
   1554e:	4628      	mov	r0, r5
   15550:	f016 fc15 	bl	2bd7e <net_buf_simple_add_be16>
   15554:	8861      	ldrh	r1, [r4, #2]
   15556:	4628      	mov	r0, r5
   15558:	f016 fc11 	bl	2bd7e <net_buf_simple_add_be16>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1555c:	88ba      	ldrh	r2, [r7, #4]
   1555e:	6839      	ldr	r1, [r7, #0]
   15560:	4628      	mov	r0, r5
   15562:	f016 fbf1 	bl	2bd48 <net_buf_simple_add_mem>
}
   15566:	4630      	mov	r0, r6
   15568:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1556a:	bf00      	nop
   1556c:	2000103c 	.word	0x2000103c
   15570:	200038e4 	.word	0x200038e4

00015574 <encode_friend_ctl>:
{
   15574:	b530      	push	{r4, r5, lr}
   15576:	4605      	mov	r5, r0
   15578:	b085      	sub	sp, #20
	net_buf_simple_push_u8(sdu, TRANS_CTL_HDR(ctl_op, 0));
   1557a:	4610      	mov	r0, r2
{
   1557c:	4614      	mov	r4, r2
	net_buf_simple_push_u8(sdu, TRANS_CTL_HDR(ctl_op, 0));
   1557e:	f016 fc34 	bl	2bdea <net_buf_simple_push_u8>
	info.src = bt_mesh_primary_addr();
   15582:	f7fb fc6f 	bl	10e64 <bt_mesh_primary_addr>
	info.dst = frnd->lpn;
   15586:	882b      	ldrh	r3, [r5, #0]
	info.src = bt_mesh_primary_addr();
   15588:	f8ad 0004 	strh.w	r0, [sp, #4]
	info.dst = frnd->lpn;
   1558c:	f8ad 3006 	strh.w	r3, [sp, #6]
	memset(info.seq, 0, sizeof(info.seq));
   15590:	2203      	movs	r2, #3
	info.ttl = 0U;
   15592:	2380      	movs	r3, #128	; 0x80
	memset(info.seq, 0, sizeof(info.seq));
   15594:	2100      	movs	r1, #0
   15596:	a802      	add	r0, sp, #8
	info.ttl = 0U;
   15598:	f88d 300b 	strb.w	r3, [sp, #11]
	memset(info.seq, 0, sizeof(info.seq));
   1559c:	f012 f973 	bl	27886 <memset>
	info.iv_index = BT_MESH_NET_IVI_TX;
   155a0:	4a08      	ldr	r2, [pc, #32]	; (155c4 <encode_friend_ctl+0x50>)
   155a2:	6813      	ldr	r3, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   155a4:	f3bf 8f5b 	dmb	ish
   155a8:	6892      	ldr	r2, [r2, #8]
   155aa:	f3bf 8f5b 	dmb	ish
   155ae:	f3c2 0280 	ubfx	r2, r2, #2, #1
   155b2:	1a9b      	subs	r3, r3, r2
	return create_friend_pdu(frnd, &info, sdu);
   155b4:	4621      	mov	r1, r4
   155b6:	a801      	add	r0, sp, #4
	info.iv_index = BT_MESH_NET_IVI_TX;
   155b8:	9303      	str	r3, [sp, #12]
	return create_friend_pdu(frnd, &info, sdu);
   155ba:	f7ff ff99 	bl	154f0 <create_friend_pdu.constprop.0>
}
   155be:	b005      	add	sp, #20
   155c0:	bd30      	pop	{r4, r5, pc}
   155c2:	bf00      	nop
   155c4:	20001aa8 	.word	0x20001aa8

000155c8 <enqueue_update.constprop.0>:
static void enqueue_update(struct bt_mesh_friend *frnd, uint8_t md)
   155c8:	b530      	push	{r4, r5, lr}
   155ca:	b089      	sub	sp, #36	; 0x24
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*upd));
   155cc:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
static void enqueue_update(struct bt_mesh_friend *frnd, uint8_t md)
   155d0:	4604      	mov	r4, r0
	net_buf_simple_reserve(&sdu, 1);
   155d2:	2101      	movs	r1, #1
   155d4:	a802      	add	r0, sp, #8
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*upd));
   155d6:	9303      	str	r3, [sp, #12]
   155d8:	f8cd d008 	str.w	sp, [sp, #8]
   155dc:	f8cd d010 	str.w	sp, [sp, #16]
	net_buf_simple_reserve(&sdu, 1);
   155e0:	f016 fb46 	bl	2bc70 <net_buf_simple_reserve>
	upd = net_buf_simple_add(&sdu, sizeof(*upd));
   155e4:	2106      	movs	r1, #6
   155e6:	a802      	add	r0, sp, #8
   155e8:	f016 fba8 	bl	2bd3c <net_buf_simple_add>
   155ec:	4605      	mov	r5, r0
	upd->flags = bt_mesh_net_flags(frnd->subnet);
   155ee:	6920      	ldr	r0, [r4, #16]
   155f0:	f7f8 f8d2 	bl	d798 <bt_mesh_net_flags>
   155f4:	4b12      	ldr	r3, [pc, #72]	; (15640 <enqueue_update.constprop.0+0x78>)
   155f6:	7028      	strb	r0, [r5, #0]
	upd->iv_index = sys_cpu_to_be32(bt_mesh.iv_index);
   155f8:	681b      	ldr	r3, [r3, #0]
   155fa:	ba1b      	rev	r3, r3
   155fc:	f8c5 3001 	str.w	r3, [r5, #1]
	upd->md = md;
   15600:	2300      	movs	r3, #0
	return encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_UPDATE, &sdu);
   15602:	2102      	movs	r1, #2
	upd->md = md;
   15604:	716b      	strb	r3, [r5, #5]
	return encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_UPDATE, &sdu);
   15606:	aa02      	add	r2, sp, #8
   15608:	4620      	mov	r0, r4
   1560a:	f7ff ffb3 	bl	15574 <encode_friend_ctl>
	if (!buf) {
   1560e:	4601      	mov	r1, r0
   15610:	b960      	cbnz	r0, 1562c <enqueue_update.constprop.0+0x64>
		BT_ERR("Unable to encode Friend Update");
   15612:	4b0c      	ldr	r3, [pc, #48]	; (15644 <enqueue_update.constprop.0+0x7c>)
   15614:	9306      	str	r3, [sp, #24]
   15616:	480c      	ldr	r0, [pc, #48]	; (15648 <enqueue_update.constprop.0+0x80>)
   15618:	2302      	movs	r3, #2
   1561a:	aa05      	add	r2, sp, #20
   1561c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   15620:	9300      	str	r3, [sp, #0]
   15622:	9305      	str	r3, [sp, #20]
   15624:	f014 feda 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
}
   15628:	b009      	add	sp, #36	; 0x24
   1562a:	bd30      	pop	{r4, r5, pc}
	net_buf_slist_put(&frnd->queue, buf);
   1562c:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   15630:	f016 fb22 	bl	2bc78 <net_buf_slist_put>
	frnd->queue_size++;
   15634:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   15638:	3301      	adds	r3, #1
   1563a:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
}
   1563e:	e7f3      	b.n	15628 <enqueue_update.constprop.0+0x60>
   15640:	20001aa8 	.word	0x20001aa8
   15644:	00032d43 	.word	0x00032d43
   15648:	0002db0c 	.word	0x0002db0c

0001564c <subnet_evt>:
{
   1564c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15650:	4607      	mov	r7, r0
   15652:	b08b      	sub	sp, #44	; 0x2c
	if (evt == BT_MESH_KEY_ADDED) {
   15654:	2900      	cmp	r1, #0
   15656:	d03e      	beq.n	156d6 <subnet_evt+0x8a>
   15658:	4c28      	ldr	r4, [pc, #160]	; (156fc <subnet_evt+0xb0>)
				BT_ERR("Failed updating friend cred for 0x%04x",
   1565a:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 15700 <subnet_evt+0xb4>
   1565e:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 15704 <subnet_evt+0xb8>
	if (evt == BT_MESH_KEY_ADDED) {
   15662:	f04f 0802 	mov.w	r8, #2
		switch (evt) {
   15666:	1e4d      	subs	r5, r1, #1
		if (frnd->subnet != sub) {
   15668:	f854 3c25 	ldr.w	r3, [r4, #-37]
   1566c:	429f      	cmp	r7, r3
   1566e:	d12d      	bne.n	156cc <subnet_evt+0x80>
   15670:	f1a4 0635 	sub.w	r6, r4, #53	; 0x35
		switch (evt) {
   15674:	2d03      	cmp	r5, #3
   15676:	d829      	bhi.n	156cc <subnet_evt+0x80>
   15678:	e8df f005 	tbb	[pc, r5]
   1567c:	303b0525 	.word	0x303b0525
   15680:	f04f 0801 	mov.w	r8, #1
   15684:	e7f0      	b.n	15668 <subnet_evt+0x1c>
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   15686:	f834 bc35 	ldrh.w	fp, [r4, #-53]
   1568a:	f7fb fbeb 	bl	10e64 <bt_mesh_primary_addr>
					  frnd->subnet->keys[idx].net);
   1568e:	f854 3c25 	ldr.w	r3, [r4, #-37]
   15692:	3387      	adds	r3, #135	; 0x87
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   15694:	9301      	str	r3, [sp, #4]
   15696:	f834 3c29 	ldrh.w	r3, [r4, #-41]
   1569a:	9300      	str	r3, [sp, #0]
   1569c:	4602      	mov	r2, r0
   1569e:	f834 3c2b 	ldrh.w	r3, [r4, #-43]
   156a2:	4659      	mov	r1, fp
   156a4:	4620      	mov	r0, r4
   156a6:	f013 ff15 	bl	294d4 <bt_mesh_friend_cred_create>
			if (err) {
   156aa:	b178      	cbz	r0, 156cc <subnet_evt+0x80>
				BT_ERR("Failed updating friend cred for 0x%04x",
   156ac:	f834 3c35 	ldrh.w	r3, [r4, #-53]
   156b0:	aa07      	add	r2, sp, #28
   156b2:	e9cd 9308 	strd	r9, r3, [sp, #32]
   156b6:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   156ba:	2303      	movs	r3, #3
   156bc:	4650      	mov	r0, sl
   156be:	9303      	str	r3, [sp, #12]
   156c0:	9307      	str	r3, [sp, #28]
   156c2:	f014 fe8b 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
				friend_clear(frnd);
   156c6:	4630      	mov	r0, r6
   156c8:	f7ff fe1e 	bl	15308 <friend_clear>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   156cc:	f1b8 0f01 	cmp.w	r8, #1
   156d0:	f104 04e8 	add.w	r4, r4, #232	; 0xe8
   156d4:	d1d4      	bne.n	15680 <subnet_evt+0x34>
}
   156d6:	b00b      	add	sp, #44	; 0x2c
   156d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			memcpy(&frnd->cred[0], &frnd->cred[1],
   156dc:	2221      	movs	r2, #33	; 0x21
   156de:	4621      	mov	r1, r4
   156e0:	f1a4 0021 	sub.w	r0, r4, #33	; 0x21
   156e4:	f012 f8c4 	bl	27870 <memcpy>
			memset(&frnd->cred[1], 0, sizeof(frnd->cred[1]));
   156e8:	2221      	movs	r2, #33	; 0x21
   156ea:	2100      	movs	r1, #0
   156ec:	4620      	mov	r0, r4
   156ee:	f012 f8ca 	bl	27886 <memset>
			enqueue_update(frnd, 0);
   156f2:	4630      	mov	r0, r6
   156f4:	f7ff ff68 	bl	155c8 <enqueue_update.constprop.0>
			break;
   156f8:	e7e8      	b.n	156cc <subnet_evt+0x80>
   156fa:	bf00      	nop
   156fc:	20001b05 	.word	0x20001b05
   15700:	00032d62 	.word	0x00032d62
   15704:	0002db0c 	.word	0x0002db0c

00015708 <encrypt_friend_pdu>:
{
   15708:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		cred = &frnd->subnet->keys[SUBNET_KEY_TX_IDX(frnd->subnet)]
   1570c:	6903      	ldr	r3, [r0, #16]
   1570e:	7f9d      	ldrb	r5, [r3, #30]
{
   15710:	460e      	mov	r6, r1
		cred = &frnd->subnet->keys[SUBNET_KEY_TX_IDX(frnd->subnet)]
   15712:	1ea9      	subs	r1, r5, #2
   15714:	424d      	negs	r5, r1
{
   15716:	b093      	sub	sp, #76	; 0x4c
   15718:	4604      	mov	r4, r0
		cred = &frnd->subnet->keys[SUBNET_KEY_TX_IDX(frnd->subnet)]
   1571a:	414d      	adcs	r5, r1
	if (flooding_cred) {
   1571c:	2a00      	cmp	r2, #0
   1571e:	d061      	beq.n	157e4 <encrypt_friend_pdu+0xdc>
		cred = &frnd->subnet->keys[SUBNET_KEY_TX_IDX(frnd->subnet)]
   15720:	225a      	movs	r2, #90	; 0x5a
   15722:	fb02 3505 	mla	r5, r2, r5, r3
   15726:	353d      	adds	r5, #61	; 0x3d
	if (bt_mesh_has_addr(src)) {
   15728:	46b0      	mov	r8, r6
   1572a:	f858 3f08 	ldr.w	r3, [r8, #8]!
   1572e:	f8b3 0005 	ldrh.w	r0, [r3, #5]
   15732:	ba40      	rev16	r0, r0
   15734:	b280      	uxth	r0, r0
   15736:	f7fb fbaf 	bl	10e98 <bt_mesh_has_addr>
   1573a:	2800      	cmp	r0, #0
   1573c:	f000 80d9 	beq.w	158f2 <encrypt_friend_pdu+0x1ea>
		if (FRIEND_ADV(buf)->app_idx != BT_MESH_KEY_UNUSED) {
   15740:	6973      	ldr	r3, [r6, #20]
   15742:	881f      	ldrh	r7, [r3, #0]
   15744:	f64f 73ff 	movw	r3, #65535	; 0xffff
   15748:	429f      	cmp	r7, r3
   1574a:	f000 80a0 	beq.w	1588e <encrypt_friend_pdu+0x186>
	err = unseg_app_sdu_unpack(frnd, buf, &meta);
   1574e:	6924      	ldr	r4, [r4, #16]
	struct bt_mesh_net_rx net = {
   15750:	2218      	movs	r2, #24
   15752:	2100      	movs	r1, #0
   15754:	a804      	add	r0, sp, #16
   15756:	f012 f896 	bl	27886 <memset>
   1575a:	8ba3      	ldrh	r3, [r4, #28]
   1575c:	f8ad 3014 	strh.w	r3, [sp, #20]
	bt_mesh_net_header_parse(&buf->b, &net);
   15760:	a904      	add	r1, sp, #16
   15762:	4640      	mov	r0, r8
	meta->subnet = frnd->subnet;
   15764:	9410      	str	r4, [sp, #64]	; 0x40
	struct bt_mesh_net_rx net = {
   15766:	f8ad 7016 	strh.w	r7, [sp, #22]
	bt_mesh_net_header_parse(&buf->b, &net);
   1576a:	f7f7 fc73 	bl	d054 <bt_mesh_net_header_parse>
	err = bt_mesh_keys_resolve(&net.ctx, &net.sub, &meta->key, &meta->aid);
   1576e:	ab11      	add	r3, sp, #68	; 0x44
   15770:	aa0f      	add	r2, sp, #60	; 0x3c
   15772:	a904      	add	r1, sp, #16
   15774:	a805      	add	r0, sp, #20
   15776:	f7f8 fc3d 	bl	dff4 <bt_mesh_keys_resolve>
	if (err) {
   1577a:	4604      	mov	r4, r0
   1577c:	bb70      	cbnz	r0, 157dc <encrypt_friend_pdu+0xd4>
	meta->crypto.src = net.ctx.addr;
   1577e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   15782:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
	meta->crypto.iv_index = BT_MESH_NET_IVI_TX;
   15786:	f8df 9198 	ldr.w	r9, [pc, #408]	; 15920 <encrypt_friend_pdu+0x218>
	meta->crypto.dst = net.ctx.recv_dst;
   1578a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   1578e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
	meta->crypto.iv_index = BT_MESH_NET_IVI_TX;
   15792:	f8d9 3000 	ldr.w	r3, [r9]
   15796:	f3bf 8f5b 	dmb	ish
   1579a:	f8d9 2008 	ldr.w	r2, [r9, #8]
   1579e:	f3bf 8f5b 	dmb	ish
   157a2:	f3c2 0280 	ubfx	r2, r2, #2, #1
   157a6:	1a9b      	subs	r3, r3, r2
	meta->crypto.dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   157a8:	3703      	adds	r7, #3
	meta->crypto.aszmic = 0;
   157aa:	f88d 0029 	strb.w	r0, [sp, #41]	; 0x29
	if (BT_MESH_ADDR_IS_VIRTUAL(meta->crypto.dst)) {
   157ae:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
	meta->crypto.iv_index = BT_MESH_NET_IVI_TX;
   157b2:	930d      	str	r3, [sp, #52]	; 0x34
	meta->crypto.dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   157b4:	b2bf      	uxth	r7, r7
	meta->crypto.seq_num = net.seq;
   157b6:	9b08      	ldr	r3, [sp, #32]
   157b8:	930c      	str	r3, [sp, #48]	; 0x30
	meta->crypto.dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   157ba:	2f01      	cmp	r7, #1
	if (BT_MESH_ADDR_IS_VIRTUAL(meta->crypto.dst)) {
   157bc:	f480 4300 	eor.w	r3, r0, #32768	; 0x8000
	meta->crypto.dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   157c0:	bf8c      	ite	hi
   157c2:	2700      	movhi	r7, #0
   157c4:	2701      	movls	r7, #1
	if (BT_MESH_ADDR_IS_VIRTUAL(meta->crypto.dst)) {
   157c6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
	meta->crypto.dev_key = BT_MESH_IS_DEV_KEY(app_idx);
   157ca:	f88d 7028 	strb.w	r7, [sp, #40]	; 0x28
	if (BT_MESH_ADDR_IS_VIRTUAL(meta->crypto.dst)) {
   157ce:	d20e      	bcs.n	157ee <encrypt_friend_pdu+0xe6>
		meta->crypto.ad = bt_mesh_va_label_get(meta->crypto.dst);
   157d0:	f7f9 fb8c 	bl	eeec <bt_mesh_va_label_get>
   157d4:	900e      	str	r0, [sp, #56]	; 0x38
		if (!meta->crypto.ad) {
   157d6:	b958      	cbnz	r0, 157f0 <encrypt_friend_pdu+0xe8>
			return -ENOENT;
   157d8:	f06f 0401 	mvn.w	r4, #1
}
   157dc:	4620      	mov	r0, r4
   157de:	b013      	add	sp, #76	; 0x4c
   157e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		cred = &frnd->cred[SUBNET_KEY_TX_IDX(frnd->subnet)];
   157e4:	eb05 1545 	add.w	r5, r5, r5, lsl #5
   157e8:	3514      	adds	r5, #20
   157ea:	4405      	add	r5, r0
   157ec:	e79c      	b.n	15728 <encrypt_friend_pdu+0x20>
		meta->crypto.ad = NULL;
   157ee:	940e      	str	r4, [sp, #56]	; 0x38
	if (meta.crypto.seq_num == bt_mesh.seq) {
   157f0:	f8d9 3004 	ldr.w	r3, [r9, #4]
   157f4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   157f6:	429a      	cmp	r2, r3
   157f8:	d049      	beq.n	1588e <encrypt_friend_pdu+0x186>
	net_buf_simple_clone(&buf->b, &in);
   157fa:	a901      	add	r1, sp, #4
   157fc:	4640      	mov	r0, r8
   157fe:	f016 fa97 	bl	2bd30 <net_buf_simple_clone>
	net_buf_simple_pull(&in, BT_MESH_NET_HDR_LEN);
   15802:	2109      	movs	r1, #9
   15804:	a801      	add	r0, sp, #4
   15806:	f016 fb09 	bl	2be1c <net_buf_simple_pull>
	net_buf_simple_pull(&in, 1);
   1580a:	2101      	movs	r1, #1
   1580c:	a801      	add	r0, sp, #4
   1580e:	f016 fb05 	bl	2be1c <net_buf_simple_pull>
	in.len -= BT_MESH_MIC_SHORT;
   15812:	f8bd 3008 	ldrh.w	r3, [sp, #8]
	net_buf_simple_clone(&in, &out);
   15816:	a904      	add	r1, sp, #16
	in.len -= BT_MESH_MIC_SHORT;
   15818:	3b04      	subs	r3, #4
	net_buf_simple_clone(&in, &out);
   1581a:	a801      	add	r0, sp, #4
	in.len -= BT_MESH_MIC_SHORT;
   1581c:	f8ad 3008 	strh.w	r3, [sp, #8]
	net_buf_simple_clone(&in, &out);
   15820:	f016 fa86 	bl	2bd30 <net_buf_simple_clone>
	out.len = 0; /* length will be set by decrypt */
   15824:	2300      	movs	r3, #0
   15826:	f8ad 3014 	strh.w	r3, [sp, #20]
	return bt_mesh_app_decrypt(meta->key, &meta->crypto, &in, &out);
   1582a:	980f      	ldr	r0, [sp, #60]	; 0x3c
   1582c:	ab04      	add	r3, sp, #16
   1582e:	aa01      	add	r2, sp, #4
   15830:	a90a      	add	r1, sp, #40	; 0x28
   15832:	f014 fb34 	bl	29e9e <bt_mesh_app_decrypt>
	if (err) {
   15836:	4604      	mov	r4, r0
   15838:	b160      	cbz	r0, 15854 <encrypt_friend_pdu+0x14c>
		BT_WARN("Decryption failed! %d", err);
   1583a:	4b3a      	ldr	r3, [pc, #232]	; (15924 <encrypt_friend_pdu+0x21c>)
		BT_WARN("Re-encryption failed! %d", err);
   1583c:	483a      	ldr	r0, [pc, #232]	; (15928 <encrypt_friend_pdu+0x220>)
   1583e:	e9cd 3408 	strd	r3, r4, [sp, #32]
   15842:	aa07      	add	r2, sp, #28
   15844:	2303      	movs	r3, #3
   15846:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   1584a:	9301      	str	r3, [sp, #4]
   1584c:	9307      	str	r3, [sp, #28]
   1584e:	f014 fdc5 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
   15852:	e7c3      	b.n	157dc <encrypt_friend_pdu+0xd4>
	meta.crypto.seq_num = bt_mesh.seq;
   15854:	f8d9 3004 	ldr.w	r3, [r9, #4]
   15858:	930c      	str	r3, [sp, #48]	; 0x30
	net_buf_simple_clone(&buf->b, &sdu);
   1585a:	a904      	add	r1, sp, #16
   1585c:	4640      	mov	r0, r8
   1585e:	f016 fa67 	bl	2bd30 <net_buf_simple_clone>
	net_buf_simple_pull(&sdu, BT_MESH_NET_HDR_LEN);
   15862:	2109      	movs	r1, #9
   15864:	a804      	add	r0, sp, #16
   15866:	f016 fad9 	bl	2be1c <net_buf_simple_pull>
	net_buf_simple_pull(&sdu, 1);
   1586a:	2101      	movs	r1, #1
   1586c:	a804      	add	r0, sp, #16
   1586e:	f016 fad5 	bl	2be1c <net_buf_simple_pull>
	sdu.len -= BT_MESH_MIC_SHORT;
   15872:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	return bt_mesh_app_encrypt(meta->key, &meta->crypto, &sdu);
   15876:	980f      	ldr	r0, [sp, #60]	; 0x3c
	sdu.len -= BT_MESH_MIC_SHORT;
   15878:	3b04      	subs	r3, #4
	return bt_mesh_app_encrypt(meta->key, &meta->crypto, &sdu);
   1587a:	aa04      	add	r2, sp, #16
   1587c:	a90a      	add	r1, sp, #40	; 0x28
	sdu.len -= BT_MESH_MIC_SHORT;
   1587e:	f8ad 3014 	strh.w	r3, [sp, #20]
	return bt_mesh_app_encrypt(meta->key, &meta->crypto, &sdu);
   15882:	f014 fae3 	bl	29e4c <bt_mesh_app_encrypt>
	if (err) {
   15886:	4604      	mov	r4, r0
   15888:	b108      	cbz	r0, 1588e <encrypt_friend_pdu+0x186>
		BT_WARN("Re-encryption failed! %d", err);
   1588a:	4b28      	ldr	r3, [pc, #160]	; (1592c <encrypt_friend_pdu+0x224>)
   1588c:	e7d6      	b.n	1583c <encrypt_friend_pdu+0x134>
		seq = bt_mesh_next_seq();
   1588e:	f7f7 fa4f 	bl	cd30 <bt_mesh_next_seq>
		sys_put_be24(seq, &buf->data[2]);
   15892:	68b3      	ldr	r3, [r6, #8]
	dst[0] = val >> 16;
   15894:	0c02      	lsrs	r2, r0, #16
   15896:	709a      	strb	r2, [r3, #2]
	dst[0] = val >> 8;
   15898:	f3c0 2207 	ubfx	r2, r0, #8, #8
   1589c:	70da      	strb	r2, [r3, #3]
	dst[1] = val;
   1589e:	7118      	strb	r0, [r3, #4]
		iv_index = BT_MESH_NET_IVI_TX;
   158a0:	4b1f      	ldr	r3, [pc, #124]	; (15920 <encrypt_friend_pdu+0x218>)
   158a2:	681c      	ldr	r4, [r3, #0]
   158a4:	f3bf 8f5b 	dmb	ish
   158a8:	689b      	ldr	r3, [r3, #8]
   158aa:	f3bf 8f5b 	dmb	ish
   158ae:	f3c3 0380 	ubfx	r3, r3, #2, #1
   158b2:	1ae4      	subs	r4, r4, r3
		FRIEND_ADV(buf)->app_idx = BT_MESH_KEY_UNUSED;
   158b4:	6973      	ldr	r3, [r6, #20]
   158b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   158ba:	801a      	strh	r2, [r3, #0]
	buf->data[0] = (cred->nid | (iv_index & 1) << 7);
   158bc:	4628      	mov	r0, r5
   158be:	68b2      	ldr	r2, [r6, #8]
   158c0:	f810 3b01 	ldrb.w	r3, [r0], #1
   158c4:	ea43 13c4 	orr.w	r3, r3, r4, lsl #7
   158c8:	7013      	strb	r3, [r2, #0]
	if (bt_mesh_net_encrypt(cred->enc, &buf->b, iv_index, false)) {
   158ca:	4641      	mov	r1, r8
   158cc:	2300      	movs	r3, #0
   158ce:	4622      	mov	r2, r4
   158d0:	f014 fa28 	bl	29d24 <bt_mesh_net_encrypt>
   158d4:	b1b8      	cbz	r0, 15906 <encrypt_friend_pdu+0x1fe>
		BT_ERR("Encrypting failed");
   158d6:	4b16      	ldr	r3, [pc, #88]	; (15930 <encrypt_friend_pdu+0x228>)
		BT_ERR("Obfuscating failed");
   158d8:	930e      	str	r3, [sp, #56]	; 0x38
   158da:	4813      	ldr	r0, [pc, #76]	; (15928 <encrypt_friend_pdu+0x220>)
   158dc:	2302      	movs	r3, #2
   158de:	aa0d      	add	r2, sp, #52	; 0x34
   158e0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   158e4:	9304      	str	r3, [sp, #16]
   158e6:	930d      	str	r3, [sp, #52]	; 0x34
		return -EINVAL;
   158e8:	f06f 0415 	mvn.w	r4, #21
		BT_ERR("Obfuscating failed");
   158ec:	f014 fd76 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   158f0:	e774      	b.n	157dc <encrypt_friend_pdu+0xd4>
		iv_index = (bt_mesh.iv_index - ((bt_mesh.iv_index & 1) != ivi));
   158f2:	4b0b      	ldr	r3, [pc, #44]	; (15920 <encrypt_friend_pdu+0x218>)
   158f4:	681c      	ldr	r4, [r3, #0]
		uint8_t ivi = (buf->data[0] >> 7);
   158f6:	68b3      	ldr	r3, [r6, #8]
   158f8:	781a      	ldrb	r2, [r3, #0]
		iv_index = (bt_mesh.iv_index - ((bt_mesh.iv_index & 1) != ivi));
   158fa:	f004 0301 	and.w	r3, r4, #1
   158fe:	ea83 13d2 	eor.w	r3, r3, r2, lsr #7
   15902:	1ae4      	subs	r4, r4, r3
   15904:	e7da      	b.n	158bc <encrypt_friend_pdu+0x1b4>
	if (bt_mesh_net_obfuscate(buf->data, iv_index, cred->privacy)) {
   15906:	4621      	mov	r1, r4
   15908:	68b0      	ldr	r0, [r6, #8]
   1590a:	f105 0211 	add.w	r2, r5, #17
   1590e:	f7fa fdeb 	bl	104e8 <bt_mesh_net_obfuscate>
   15912:	4604      	mov	r4, r0
   15914:	2800      	cmp	r0, #0
   15916:	f43f af61 	beq.w	157dc <encrypt_friend_pdu+0xd4>
		BT_ERR("Obfuscating failed");
   1591a:	4b06      	ldr	r3, [pc, #24]	; (15934 <encrypt_friend_pdu+0x22c>)
   1591c:	e7dc      	b.n	158d8 <encrypt_friend_pdu+0x1d0>
   1591e:	bf00      	nop
   15920:	20001aa8 	.word	0x20001aa8
   15924:	00032d89 	.word	0x00032d89
   15928:	0002db0c 	.word	0x0002db0c
   1592c:	00032d9f 	.word	0x00032d9f
   15930:	00032db8 	.word	0x00032db8
   15934:	00032dca 	.word	0x00032dca

00015938 <enqueue_sub_cfm>:
{
   15938:	b530      	push	{r4, r5, lr}
   1593a:	b08d      	sub	sp, #52	; 0x34
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*cfm));
   1593c:	ab01      	add	r3, sp, #4
   1593e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
{
   15942:	460d      	mov	r5, r1
   15944:	4604      	mov	r4, r0
	net_buf_simple_reserve(&sdu, 1);
   15946:	2101      	movs	r1, #1
   15948:	a803      	add	r0, sp, #12
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*cfm));
   1594a:	e9cd 2304 	strd	r2, r3, [sp, #16]
   1594e:	9303      	str	r3, [sp, #12]
	net_buf_simple_reserve(&sdu, 1);
   15950:	f016 f98e 	bl	2bc70 <net_buf_simple_reserve>
	cfm = net_buf_simple_add(&sdu, sizeof(*cfm));
   15954:	2101      	movs	r1, #1
   15956:	a803      	add	r0, sp, #12
   15958:	f016 f9f0 	bl	2bd3c <net_buf_simple_add>
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_SUB_CFM, &sdu);
   1595c:	aa03      	add	r2, sp, #12
	cfm->xact = xact;
   1595e:	7005      	strb	r5, [r0, #0]
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_SUB_CFM, &sdu);
   15960:	2109      	movs	r1, #9
   15962:	4620      	mov	r0, r4
   15964:	f7ff fe06 	bl	15574 <encode_friend_ctl>
	if (!buf) {
   15968:	4605      	mov	r5, r0
   1596a:	b960      	cbnz	r0, 15986 <enqueue_sub_cfm+0x4e>
		BT_ERR("Unable to encode Subscription List Confirmation");
   1596c:	4b0f      	ldr	r3, [pc, #60]	; (159ac <enqueue_sub_cfm+0x74>)
   1596e:	930a      	str	r3, [sp, #40]	; 0x28
   15970:	480f      	ldr	r0, [pc, #60]	; (159b0 <enqueue_sub_cfm+0x78>)
   15972:	2302      	movs	r3, #2
   15974:	aa09      	add	r2, sp, #36	; 0x24
   15976:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1597a:	9302      	str	r3, [sp, #8]
   1597c:	9309      	str	r3, [sp, #36]	; 0x24
   1597e:	f014 fd2d 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
}
   15982:	b00d      	add	sp, #52	; 0x34
   15984:	bd30      	pop	{r4, r5, pc}
	if (encrypt_friend_pdu(frnd, buf, false)) {
   15986:	4601      	mov	r1, r0
   15988:	2200      	movs	r2, #0
   1598a:	4620      	mov	r0, r4
   1598c:	f7ff febc 	bl	15708 <encrypt_friend_pdu>
   15990:	2800      	cmp	r0, #0
   15992:	d1f6      	bne.n	15982 <enqueue_sub_cfm+0x4a>
	if (frnd->last) {
   15994:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   15998:	b108      	cbz	r0, 1599e <enqueue_sub_cfm+0x66>
		net_buf_unref(frnd->last);
   1599a:	f00a ff7b 	bl	20894 <net_buf_unref>
	frnd->send_last = 1U;
   1599e:	78e3      	ldrb	r3, [r4, #3]
	frnd->last = buf;
   159a0:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
	frnd->send_last = 1U;
   159a4:	f043 0302 	orr.w	r3, r3, #2
   159a8:	70e3      	strb	r3, [r4, #3]
   159aa:	e7ea      	b.n	15982 <enqueue_sub_cfm+0x4a>
   159ac:	00032ddd 	.word	0x00032ddd
   159b0:	0002db0c 	.word	0x0002db0c

000159b4 <friend_timeout>:
{
   159b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!friend_is_allocated(frnd)) {
   159b8:	f850 3c50 	ldr.w	r3, [r0, #-80]
{
   159bc:	b08a      	sub	sp, #40	; 0x28
   159be:	4604      	mov	r4, r0
	struct bt_mesh_friend *frnd = CONTAINER_OF(dwork, struct bt_mesh_friend,
   159c0:	f1a0 0660 	sub.w	r6, r0, #96	; 0x60
	if (!friend_is_allocated(frnd)) {
   159c4:	b303      	cbz	r3, 15a08 <friend_timeout+0x54>
	if (frnd->send_last && frnd->last) {
   159c6:	f810 3c5d 	ldrb.w	r3, [r0, #-93]
   159ca:	079a      	lsls	r2, r3, #30
   159cc:	d51f      	bpl.n	15a0e <friend_timeout+0x5a>
   159ce:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   159d0:	b1ea      	cbz	r2, 15a0e <friend_timeout+0x5a>
		frnd->send_last = 0U;
   159d2:	f36f 0341 	bfc	r3, #1, #1
   159d6:	f800 3c5d 	strb.w	r3, [r0, #-93]
				 FRIEND_XMIT, K_NO_WAIT);
   159da:	2200      	movs	r2, #0
   159dc:	2300      	movs	r3, #0
	buf = bt_mesh_adv_create(BT_MESH_ADV_DATA, BT_MESH_LOCAL_ADV,
   159de:	2101      	movs	r1, #1
   159e0:	e9cd 2300 	strd	r2, r3, [sp]
   159e4:	4608      	mov	r0, r1
   159e6:	2208      	movs	r2, #8
   159e8:	f7f6 fade 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
   159ec:	4605      	mov	r5, r0
   159ee:	2800      	cmp	r0, #0
   159f0:	d179      	bne.n	15ae6 <friend_timeout+0x132>
		BT_ERR("Unable to allocate friend adv buffer");
   159f2:	4b49      	ldr	r3, [pc, #292]	; (15b18 <friend_timeout+0x164>)
   159f4:	9308      	str	r3, [sp, #32]
   159f6:	4849      	ldr	r0, [pc, #292]	; (15b1c <friend_timeout+0x168>)
   159f8:	2302      	movs	r3, #2
   159fa:	aa07      	add	r2, sp, #28
   159fc:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   15a00:	9303      	str	r3, [sp, #12]
   15a02:	9307      	str	r3, [sp, #28]
   15a04:	f014 fcea 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
}
   15a08:	b00a      	add	sp, #40	; 0x28
   15a0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (frnd->established && !frnd->pending_req) {
   15a0e:	f003 0314 	and.w	r3, r3, #20
   15a12:	2b10      	cmp	r3, #16
   15a14:	d113      	bne.n	15a3e <friend_timeout+0x8a>
		BT_WARN("Friendship lost with 0x%04x", frnd->lpn);
   15a16:	f834 3c60 	ldrh.w	r3, [r4, #-96]
   15a1a:	4a41      	ldr	r2, [pc, #260]	; (15b20 <friend_timeout+0x16c>)
		BT_WARN("Friendship not established with 0x%04x",
   15a1c:	483f      	ldr	r0, [pc, #252]	; (15b1c <friend_timeout+0x168>)
   15a1e:	e9cd 2308 	strd	r2, r3, [sp, #32]
   15a22:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   15a26:	2303      	movs	r3, #3
   15a28:	aa07      	add	r2, sp, #28
   15a2a:	9303      	str	r3, [sp, #12]
   15a2c:	9307      	str	r3, [sp, #28]
   15a2e:	f014 fcd5 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		friend_clear(frnd);
   15a32:	4630      	mov	r0, r6
}
   15a34:	b00a      	add	sp, #40	; 0x28
   15a36:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		friend_clear(frnd);
   15a3a:	f7ff bc65 	b.w	15308 <friend_clear>
	return list->head;
   15a3e:	6c25      	ldr	r5, [r4, #64]	; 0x40
Z_GENLIST_GET(slist, snode)
   15a40:	b925      	cbnz	r5, 15a4c <friend_timeout+0x98>
		BT_WARN("Friendship not established with 0x%04x",
   15a42:	f834 3c60 	ldrh.w	r3, [r4, #-96]
   15a46:	4a37      	ldr	r2, [pc, #220]	; (15b24 <friend_timeout+0x170>)
	frnd->last = (void *)sys_slist_get(&frnd->queue);
   15a48:	63e5      	str	r5, [r4, #60]	; 0x3c
		BT_WARN("Friendship not established with 0x%04x",
   15a4a:	e7e7      	b.n	15a1c <friend_timeout+0x68>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   15a4c:	6c63      	ldr	r3, [r4, #68]	; 0x44
	return node->next;
   15a4e:	f8d5 8000 	ldr.w	r8, [r5]
	list->head = node;
   15a52:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   15a56:	429d      	cmp	r5, r3
	if (buf->len != 16) {
   15a58:	89ab      	ldrh	r3, [r5, #12]
	list->tail = node;
   15a5a:	bf08      	it	eq
   15a5c:	f8c4 8044 	streq.w	r8, [r4, #68]	; 0x44
   15a60:	2b10      	cmp	r3, #16
	frnd->last = (void *)sys_slist_get(&frnd->queue);
   15a62:	63e5      	str	r5, [r4, #60]	; 0x3c
	if (buf->len != 16) {
   15a64:	d12e      	bne.n	15ac4 <friend_timeout+0x110>
	net_buf_simple_save(&buf->b, &state);
   15a66:	f105 0908 	add.w	r9, r5, #8
	state->offset = net_buf_simple_headroom(buf);
   15a6a:	4648      	mov	r0, r9
   15a6c:	f016 fa09 	bl	2be82 <net_buf_simple_headroom>
	net_buf_skip(buf, 1); /* skip IVI, NID */
   15a70:	2101      	movs	r1, #1
   15a72:	4607      	mov	r7, r0
   15a74:	4628      	mov	r0, r5
	state->len = buf->len;
   15a76:	f8b5 a00c 	ldrh.w	sl, [r5, #12]
   15a7a:	f014 fcb2 	bl	2a3e2 <net_buf_skip.isra.0>
	return net_buf_simple_pull_u8(&buf->b);
   15a7e:	4648      	mov	r0, r9
   15a80:	f016 f9dc 	bl	2be3c <net_buf_simple_pull_u8>
	if (!(net_buf_pull_u8(buf) >> 7)) {
   15a84:	0603      	lsls	r3, r0, #24
   15a86:	d517      	bpl.n	15ab8 <friend_timeout+0x104>
	net_buf_skip(buf, 7); /* skip seqnum src dec*/
   15a88:	2107      	movs	r1, #7
   15a8a:	4628      	mov	r0, r5
   15a8c:	f014 fca9 	bl	2a3e2 <net_buf_skip.isra.0>
	return net_buf_simple_pull_mem(&buf->b, len);
   15a90:	2101      	movs	r1, #1
   15a92:	4648      	mov	r0, r9
   15a94:	f016 f9ca 	bl	2be2c <net_buf_simple_pull_mem>
	if (TRANS_CTL_OP((uint8_t *) net_buf_pull_mem(buf, 1))
   15a98:	7803      	ldrb	r3, [r0, #0]
   15a9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   15a9e:	2b02      	cmp	r3, #2
   15aa0:	d10a      	bne.n	15ab8 <friend_timeout+0x104>
   15aa2:	2106      	movs	r1, #6
   15aa4:	4648      	mov	r0, r9
   15aa6:	f016 f9c1 	bl	2be2c <net_buf_simple_pull_mem>
	md = (uint8_t)(sys_slist_peek_head(&frnd->queue) != NULL);
   15aaa:	f1b8 0800 	subs.w	r8, r8, #0
   15aae:	bf18      	it	ne
   15ab0:	f04f 0801 	movne.w	r8, #1
   15ab4:	f880 8005 	strb.w	r8, [r0, #5]
	buf->data = buf->__buf + state->offset;
   15ab8:	6928      	ldr	r0, [r5, #16]
	buf->len = state->len;
   15aba:	f8a5 a00c 	strh.w	sl, [r5, #12]
	buf->data = buf->__buf + state->offset;
   15abe:	fa10 f787 	uxtah	r7, r0, r7
   15ac2:	60af      	str	r7, [r5, #8]
	if (encrypt_friend_pdu(frnd, frnd->last, false)) {
   15ac4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   15ac6:	2200      	movs	r2, #0
   15ac8:	4630      	mov	r0, r6
   15aca:	f7ff fe1d 	bl	15708 <encrypt_friend_pdu>
   15ace:	2800      	cmp	r0, #0
   15ad0:	d19a      	bne.n	15a08 <friend_timeout+0x54>
	frnd->last->flags &= ~NET_BUF_FRAGS;
   15ad2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   15ad4:	795a      	ldrb	r2, [r3, #5]
	frnd->last->frags = NULL;
   15ad6:	6018      	str	r0, [r3, #0]
	frnd->last->flags &= ~NET_BUF_FRAGS;
   15ad8:	f022 0201 	bic.w	r2, r2, #1
   15adc:	715a      	strb	r2, [r3, #5]
	frnd->queue_size--;
   15ade:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   15ae0:	3b01      	subs	r3, #1
   15ae2:	64a3      	str	r3, [r4, #72]	; 0x48
   15ae4:	e779      	b.n	159da <friend_timeout+0x26>
	net_buf_add_mem(buf, frnd->last->data, frnd->last->len);
   15ae6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	return net_buf_simple_add_mem(&buf->b, mem, len);
   15ae8:	3008      	adds	r0, #8
   15aea:	899a      	ldrh	r2, [r3, #12]
   15aec:	6899      	ldr	r1, [r3, #8]
   15aee:	f016 f92b 	bl	2bd48 <net_buf_simple_add_mem>
	frnd->pending_req = 0U;
   15af2:	f814 3c5d 	ldrb.w	r3, [r4, #-93]
	bt_mesh_adv_send(buf, &buf_sent_cb, frnd);
   15af6:	490c      	ldr	r1, [pc, #48]	; (15b28 <friend_timeout+0x174>)
	frnd->pending_buf = 1U;
   15af8:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   15afc:	f043 0308 	orr.w	r3, r3, #8
	bt_mesh_adv_send(buf, &buf_sent_cb, frnd);
   15b00:	4628      	mov	r0, r5
	frnd->pending_buf = 1U;
   15b02:	f804 3c5d 	strb.w	r3, [r4, #-93]
	bt_mesh_adv_send(buf, &buf_sent_cb, frnd);
   15b06:	4632      	mov	r2, r6
   15b08:	f7f6 faa8 	bl	c05c <bt_mesh_adv_send>
	net_buf_unref(buf);
   15b0c:	4628      	mov	r0, r5
}
   15b0e:	b00a      	add	sp, #40	; 0x28
   15b10:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	net_buf_unref(buf);
   15b14:	f00a bebe 	b.w	20894 <net_buf_unref>
   15b18:	00032e50 	.word	0x00032e50
   15b1c:	0002db0c 	.word	0x0002db0c
   15b20:	00032e0d 	.word	0x00032e0d
   15b24:	00032e29 	.word	0x00032e29
   15b28:	0002e72c 	.word	0x0002e72c

00015b2c <bt_mesh_friend_find>:
{
   15b2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15b30:	4c16      	ldr	r4, [pc, #88]	; (15b8c <bt_mesh_friend_find+0x60>)
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15b32:	2500      	movs	r5, #0
   15b34:	46a4      	mov	ip, r4
		if (net_idx != BT_MESH_KEY_ANY &&
   15b36:	f64f 7eff 	movw	lr, #65535	; 0xffff
		if (established && !frnd->established) {
   15b3a:	f04f 08e8 	mov.w	r8, #232	; 0xe8
		if (valid && !friend_is_allocated(frnd)) {
   15b3e:	b10a      	cbz	r2, 15b44 <bt_mesh_friend_find+0x18>
   15b40:	6ba6      	ldr	r6, [r4, #56]	; 0x38
   15b42:	b1f6      	cbz	r6, 15b82 <bt_mesh_friend_find+0x56>
		if (established && !frnd->established) {
   15b44:	b12b      	cbz	r3, 15b52 <bt_mesh_friend_find+0x26>
   15b46:	fb08 c605 	mla	r6, r8, r5, ip
   15b4a:	f896 602b 	ldrb.w	r6, [r6, #43]	; 0x2b
   15b4e:	06f6      	lsls	r6, r6, #27
   15b50:	d517      	bpl.n	15b82 <bt_mesh_friend_find+0x56>
		if (net_idx != BT_MESH_KEY_ANY &&
   15b52:	4570      	cmp	r0, lr
   15b54:	d004      	beq.n	15b60 <bt_mesh_friend_find+0x34>
		    (!frnd->subnet || frnd->subnet->net_idx != net_idx)) {
   15b56:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		if (net_idx != BT_MESH_KEY_ANY &&
   15b58:	b19e      	cbz	r6, 15b82 <bt_mesh_friend_find+0x56>
		    (!frnd->subnet || frnd->subnet->net_idx != net_idx)) {
   15b5a:	8bb6      	ldrh	r6, [r6, #28]
   15b5c:	4286      	cmp	r6, r0
   15b5e:	d110      	bne.n	15b82 <bt_mesh_friend_find+0x56>
	if (frnd->lpn == BT_MESH_ADDR_UNASSIGNED) {
   15b60:	8d27      	ldrh	r7, [r4, #40]	; 0x28
   15b62:	b177      	cbz	r7, 15b82 <bt_mesh_friend_find+0x56>
	return (addr >= frnd->lpn && addr < (frnd->lpn + frnd->num_elem));
   15b64:	42b9      	cmp	r1, r7
   15b66:	d30c      	bcc.n	15b82 <bt_mesh_friend_find+0x56>
   15b68:	f894 6030 	ldrb.w	r6, [r4, #48]	; 0x30
   15b6c:	443e      	add	r6, r7
   15b6e:	42b1      	cmp	r1, r6
   15b70:	da07      	bge.n	15b82 <bt_mesh_friend_find+0x56>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   15b72:	20e8      	movs	r0, #232	; 0xe8
   15b74:	fb00 c005 	mla	r0, r0, r5, ip
   15b78:	3028      	adds	r0, #40	; 0x28
}
   15b7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15b7e:	2501      	movs	r5, #1
   15b80:	e7dd      	b.n	15b3e <bt_mesh_friend_find+0x12>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   15b82:	34e8      	adds	r4, #232	; 0xe8
   15b84:	2d00      	cmp	r5, #0
   15b86:	d0fa      	beq.n	15b7e <bt_mesh_friend_find+0x52>
	return NULL;
   15b88:	2000      	movs	r0, #0
   15b8a:	e7f6      	b.n	15b7a <bt_mesh_friend_find+0x4e>
   15b8c:	20001aa8 	.word	0x20001aa8

00015b90 <bt_mesh_friends_clear>:
{
   15b90:	b510      	push	{r4, lr}
	return frnd->subnet != NULL;
   15b92:	4c08      	ldr	r4, [pc, #32]	; (15bb4 <bt_mesh_friends_clear+0x24>)
		if (!friend_is_allocated(frnd)) {
   15b94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   15b96:	b11b      	cbz	r3, 15ba0 <bt_mesh_friends_clear+0x10>
		friend_clear(frnd);
   15b98:	f104 0028 	add.w	r0, r4, #40	; 0x28
   15b9c:	f7ff fbb4 	bl	15308 <friend_clear>
		if (!friend_is_allocated(frnd)) {
   15ba0:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
   15ba4:	b123      	cbz	r3, 15bb0 <bt_mesh_friends_clear+0x20>
}
   15ba6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		friend_clear(frnd);
   15baa:	4803      	ldr	r0, [pc, #12]	; (15bb8 <bt_mesh_friends_clear+0x28>)
   15bac:	f7ff bbac 	b.w	15308 <friend_clear>
}
   15bb0:	bd10      	pop	{r4, pc}
   15bb2:	bf00      	nop
   15bb4:	20001aa8 	.word	0x20001aa8
   15bb8:	20001bb8 	.word	0x20001bb8

00015bbc <bt_mesh_friend_sec_update>:
{
   15bbc:	b538      	push	{r3, r4, r5, lr}
	return frnd->subnet != NULL;
   15bbe:	4d0f      	ldr	r5, [pc, #60]	; (15bfc <bt_mesh_friend_sec_update+0x40>)
   15bc0:	6bab      	ldr	r3, [r5, #56]	; 0x38
{
   15bc2:	4604      	mov	r4, r0
		if (!friend_is_allocated(frnd)) {
   15bc4:	b133      	cbz	r3, 15bd4 <bt_mesh_friend_sec_update+0x18>
		if (net_idx == BT_MESH_KEY_ANY ||
   15bc6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15bca:	4290      	cmp	r0, r2
   15bcc:	d10e      	bne.n	15bec <bt_mesh_friend_sec_update+0x30>
			enqueue_update(frnd, 0x00);
   15bce:	480c      	ldr	r0, [pc, #48]	; (15c00 <bt_mesh_friend_sec_update+0x44>)
   15bd0:	f7ff fcfa 	bl	155c8 <enqueue_update.constprop.0>
	return frnd->subnet != NULL;
   15bd4:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
		if (!friend_is_allocated(frnd)) {
   15bd8:	b17b      	cbz	r3, 15bfa <bt_mesh_friend_sec_update+0x3e>
		if (net_idx == BT_MESH_KEY_ANY ||
   15bda:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15bde:	4294      	cmp	r4, r2
   15be0:	d108      	bne.n	15bf4 <bt_mesh_friend_sec_update+0x38>
}
   15be2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			enqueue_update(frnd, 0x00);
   15be6:	4807      	ldr	r0, [pc, #28]	; (15c04 <bt_mesh_friend_sec_update+0x48>)
   15be8:	f7ff bcee 	b.w	155c8 <enqueue_update.constprop.0>
		if (net_idx == BT_MESH_KEY_ANY ||
   15bec:	8b9b      	ldrh	r3, [r3, #28]
   15bee:	4283      	cmp	r3, r0
   15bf0:	d1f0      	bne.n	15bd4 <bt_mesh_friend_sec_update+0x18>
   15bf2:	e7ec      	b.n	15bce <bt_mesh_friend_sec_update+0x12>
   15bf4:	8b9b      	ldrh	r3, [r3, #28]
   15bf6:	42a3      	cmp	r3, r4
   15bf8:	d0f3      	beq.n	15be2 <bt_mesh_friend_sec_update+0x26>
}
   15bfa:	bd38      	pop	{r3, r4, r5, pc}
   15bfc:	20001aa8 	.word	0x20001aa8
   15c00:	20001ad0 	.word	0x20001ad0
   15c04:	20001bb8 	.word	0x20001bb8

00015c08 <bt_mesh_friend_clear>:
{
   15c08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_mesh_net_tx tx = {
   15c0c:	4603      	mov	r3, r0
{
   15c0e:	b08d      	sub	sp, #52	; 0x34
	struct bt_mesh_net_tx tx = {
   15c10:	f853 2b04 	ldr.w	r2, [r3], #4
	struct bt_mesh_ctl_friend_clear *msg = (void *)buf->data;
   15c14:	f8d1 8000 	ldr.w	r8, [r1]
{
   15c18:	af02      	add	r7, sp, #8
	struct bt_mesh_net_tx tx = {
   15c1a:	2400      	movs	r4, #0
   15c1c:	e9c7 2301 	strd	r2, r3, [r7, #4]
{
   15c20:	460e      	mov	r6, r1
   15c22:	4605      	mov	r5, r0
	struct bt_mesh_net_tx tx = {
   15c24:	60fc      	str	r4, [r7, #12]
		.src  = bt_mesh_primary_addr(),
   15c26:	f7fb f91d 	bl	10e64 <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   15c2a:	81b8      	strh	r0, [r7, #12]
		.xmit = bt_mesh_net_transmit_get(),
   15c2c:	f7f6 f884 	bl	bd38 <bt_mesh_net_transmit_get>
	if (buf->len < sizeof(*msg)) {
   15c30:	88b3      	ldrh	r3, [r6, #4]
	struct bt_mesh_net_tx tx = {
   15c32:	73b8      	strb	r0, [r7, #14]
	if (buf->len < sizeof(*msg)) {
   15c34:	2b03      	cmp	r3, #3
   15c36:	d811      	bhi.n	15c5c <bt_mesh_friend_clear+0x54>
		BT_WARN("Too short Friend Clear");
   15c38:	4b2e      	ldr	r3, [pc, #184]	; (15cf4 <bt_mesh_friend_clear+0xec>)
   15c3a:	482f      	ldr	r0, [pc, #188]	; (15cf8 <bt_mesh_friend_clear+0xf0>)
   15c3c:	623b      	str	r3, [r7, #32]
   15c3e:	f107 021c 	add.w	r2, r7, #28
   15c42:	2302      	movs	r3, #2
   15c44:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15c48:	603b      	str	r3, [r7, #0]
   15c4a:	61fb      	str	r3, [r7, #28]
   15c4c:	f014 fbc6 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   15c50:	f06f 0015 	mvn.w	r0, #21
}
   15c54:	372c      	adds	r7, #44	; 0x2c
   15c56:	46bd      	mov	sp, r7
   15c58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   15c5c:	f8b8 9000 	ldrh.w	r9, [r8]
	frnd = bt_mesh_friend_find(rx->sub->net_idx, lpn_addr, false, false);
   15c60:	6828      	ldr	r0, [r5, #0]
   15c62:	f8b8 8002 	ldrh.w	r8, [r8, #2]
   15c66:	8b80      	ldrh	r0, [r0, #28]
   15c68:	fa99 f199 	rev16.w	r1, r9
   15c6c:	b289      	uxth	r1, r1
   15c6e:	4623      	mov	r3, r4
   15c70:	4622      	mov	r2, r4
   15c72:	f7ff ff5b 	bl	15b2c <bt_mesh_friend_find>
   15c76:	fa98 f698 	rev16.w	r6, r8
   15c7a:	b2b6      	uxth	r6, r6
	if (!frnd) {
   15c7c:	4605      	mov	r5, r0
   15c7e:	b970      	cbnz	r0, 15c9e <bt_mesh_friend_clear+0x96>
		BT_WARN("No matching LPN addr 0x%04x", lpn_addr);
   15c80:	4b1e      	ldr	r3, [pc, #120]	; (15cfc <bt_mesh_friend_clear+0xf4>)
   15c82:	481d      	ldr	r0, [pc, #116]	; (15cf8 <bt_mesh_friend_clear+0xf0>)
   15c84:	e9c7 3108 	strd	r3, r1, [r7, #32]
   15c88:	f107 021c 	add.w	r2, r7, #28
   15c8c:	2303      	movs	r3, #3
   15c8e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   15c92:	603b      	str	r3, [r7, #0]
   15c94:	61fb      	str	r3, [r7, #28]
   15c96:	f014 fba1 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return 0;
   15c9a:	4628      	mov	r0, r5
   15c9c:	e7da      	b.n	15c54 <bt_mesh_friend_clear+0x4c>
	if (lpn_counter - frnd->lpn_counter > 255) {
   15c9e:	8943      	ldrh	r3, [r0, #10]
   15ca0:	1af2      	subs	r2, r6, r3
   15ca2:	2aff      	cmp	r2, #255	; 0xff
   15ca4:	dd12      	ble.n	15ccc <bt_mesh_friend_clear+0xc4>
		BT_WARN("LPN Counter out of range (old %u new %u)",
   15ca6:	4916      	ldr	r1, [pc, #88]	; (15d00 <bt_mesh_friend_clear+0xf8>)
   15ca8:	4813      	ldr	r0, [pc, #76]	; (15cf8 <bt_mesh_friend_clear+0xf0>)
   15caa:	466d      	mov	r5, sp
   15cac:	b088      	sub	sp, #32
   15cae:	aa02      	add	r2, sp, #8
   15cb0:	e9c2 1304 	strd	r1, r3, [r2, #16]
   15cb4:	2304      	movs	r3, #4
   15cb6:	6196      	str	r6, [r2, #24]
   15cb8:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   15cbc:	f842 3f0c 	str.w	r3, [r2, #12]!
   15cc0:	613b      	str	r3, [r7, #16]
   15cc2:	f014 fb8b 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
   15cc6:	46ad      	mov	sp, r5
	return 0;
   15cc8:	4620      	mov	r0, r4
   15cca:	e7c3      	b.n	15c54 <bt_mesh_friend_clear+0x4c>
	tx.ctx->send_ttl = BT_MESH_TTL_MAX;
   15ccc:	68bb      	ldr	r3, [r7, #8]
   15cce:	227f      	movs	r2, #127	; 0x7f
   15cd0:	72da      	strb	r2, [r3, #11]
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR_CFM, &cfm,
   15cd2:	2304      	movs	r3, #4
	cfm.lpn_addr    = msg->lpn_addr;
   15cd4:	f8a7 9010 	strh.w	r9, [r7, #16]
	cfm.lpn_counter = msg->lpn_counter;
   15cd8:	f8a7 8012 	strh.w	r8, [r7, #18]
	bt_mesh_ctl_send(&tx, TRANS_CTL_OP_FRIEND_CLEAR_CFM, &cfm,
   15cdc:	f107 0210 	add.w	r2, r7, #16
   15ce0:	e9cd 4400 	strd	r4, r4, [sp]
   15ce4:	2106      	movs	r1, #6
   15ce6:	18f8      	adds	r0, r7, r3
   15ce8:	f7f8 ff6e 	bl	ebc8 <bt_mesh_ctl_send>
	friend_clear(frnd);
   15cec:	4628      	mov	r0, r5
   15cee:	f7ff fb0b 	bl	15308 <friend_clear>
   15cf2:	e7e9      	b.n	15cc8 <bt_mesh_friend_clear+0xc0>
   15cf4:	00032e75 	.word	0x00032e75
   15cf8:	0002db0c 	.word	0x0002db0c
   15cfc:	00032e8c 	.word	0x00032e8c
   15d00:	00032ea8 	.word	0x00032ea8

00015d04 <bt_mesh_friend_sub_add>:
{
   15d04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   15d08:	888b      	ldrh	r3, [r1, #4]
   15d0a:	2b02      	cmp	r3, #2
{
   15d0c:	b088      	sub	sp, #32
   15d0e:	460d      	mov	r5, r1
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   15d10:	d80f      	bhi.n	15d32 <bt_mesh_friend_sub_add+0x2e>
		BT_WARN("Too short Friend Subscription Add");
   15d12:	4b31      	ldr	r3, [pc, #196]	; (15dd8 <bt_mesh_friend_sub_add+0xd4>)
   15d14:	4831      	ldr	r0, [pc, #196]	; (15ddc <bt_mesh_friend_sub_add+0xd8>)
   15d16:	9306      	str	r3, [sp, #24]
   15d18:	aa05      	add	r2, sp, #20
   15d1a:	2302      	movs	r3, #2
   15d1c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15d20:	9301      	str	r3, [sp, #4]
   15d22:	9305      	str	r3, [sp, #20]
   15d24:	f014 fb5a 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   15d28:	f06f 0015 	mvn.w	r0, #21
}
   15d2c:	b008      	add	sp, #32
   15d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, true);
   15d32:	8901      	ldrh	r1, [r0, #8]
   15d34:	6800      	ldr	r0, [r0, #0]
   15d36:	2301      	movs	r3, #1
   15d38:	8b80      	ldrh	r0, [r0, #28]
   15d3a:	461a      	mov	r2, r3
   15d3c:	f7ff fef6 	bl	15b2c <bt_mesh_friend_find>
	if (!frnd) {
   15d40:	4604      	mov	r4, r0
   15d42:	b968      	cbnz	r0, 15d60 <bt_mesh_friend_sub_add+0x5c>
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   15d44:	4b26      	ldr	r3, [pc, #152]	; (15de0 <bt_mesh_friend_sub_add+0xdc>)
   15d46:	e9cd 3106 	strd	r3, r1, [sp, #24]
   15d4a:	2303      	movs	r3, #3
   15d4c:	9301      	str	r3, [sp, #4]
   15d4e:	9305      	str	r3, [sp, #20]
   15d50:	aa05      	add	r2, sp, #20
   15d52:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_WARN("Previous buffer not yet sent!");
   15d56:	4821      	ldr	r0, [pc, #132]	; (15ddc <bt_mesh_friend_sub_add+0xd8>)
   15d58:	f014 fb40 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
	return 0;
   15d5c:	2000      	movs	r0, #0
   15d5e:	e7e5      	b.n	15d2c <bt_mesh_friend_sub_add+0x28>
	if (frnd->pending_buf) {
   15d60:	78c3      	ldrb	r3, [r0, #3]
   15d62:	071b      	lsls	r3, r3, #28
   15d64:	d508      	bpl.n	15d78 <bt_mesh_friend_sub_add+0x74>
		BT_WARN("Previous buffer not yet sent!");
   15d66:	4b1f      	ldr	r3, [pc, #124]	; (15de4 <bt_mesh_friend_sub_add+0xe0>)
   15d68:	9306      	str	r3, [sp, #24]
   15d6a:	2302      	movs	r3, #2
   15d6c:	9301      	str	r3, [sp, #4]
   15d6e:	9305      	str	r3, [sp, #20]
   15d70:	aa05      	add	r2, sp, #20
   15d72:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15d76:	e7ee      	b.n	15d56 <bt_mesh_friend_sub_add+0x52>
	friend_recv_delay(frnd);
   15d78:	f014 fabb 	bl	2a2f2 <friend_recv_delay>
	xact = net_buf_simple_pull_u8(buf);
   15d7c:	4628      	mov	r0, r5
   15d7e:	f016 f85d 	bl	2be3c <net_buf_simple_pull_u8>
	BT_WARN("No space in friend subscription list");
   15d82:	4f19      	ldr	r7, [pc, #100]	; (15de8 <bt_mesh_friend_sub_add+0xe4>)
   15d84:	f8df 8054 	ldr.w	r8, [pc, #84]	; 15ddc <bt_mesh_friend_sub_add+0xd8>
	xact = net_buf_simple_pull_u8(buf);
   15d88:	4606      	mov	r6, r0
	while (buf->len >= 2U) {
   15d8a:	88ab      	ldrh	r3, [r5, #4]
   15d8c:	2b01      	cmp	r3, #1
   15d8e:	d804      	bhi.n	15d9a <bt_mesh_friend_sub_add+0x96>
	enqueue_sub_cfm(frnd, xact);
   15d90:	4631      	mov	r1, r6
   15d92:	4620      	mov	r0, r4
   15d94:	f7ff fdd0 	bl	15938 <enqueue_sub_cfm>
   15d98:	e7e0      	b.n	15d5c <bt_mesh_friend_sub_add+0x58>
		friend_sub_add(frnd, net_buf_simple_pull_be16(buf));
   15d9a:	4628      	mov	r0, r5
   15d9c:	f016 f85e 	bl	2be5c <net_buf_simple_pull_be16>
		if (frnd->sub_list[i] == BT_MESH_ADDR_UNASSIGNED) {
   15da0:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   15da4:	b133      	cbz	r3, 15db4 <bt_mesh_friend_sub_add+0xb0>
   15da6:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   15daa:	b143      	cbz	r3, 15dbe <bt_mesh_friend_sub_add+0xba>
   15dac:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
   15db0:	2302      	movs	r3, #2
   15db2:	b932      	cbnz	r2, 15dc2 <bt_mesh_friend_sub_add+0xbe>
			frnd->sub_list[i] = addr;
   15db4:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   15db8:	f8a3 0056 	strh.w	r0, [r3, #86]	; 0x56
			return;
   15dbc:	e7e5      	b.n	15d8a <bt_mesh_friend_sub_add+0x86>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   15dbe:	2301      	movs	r3, #1
   15dc0:	e7f8      	b.n	15db4 <bt_mesh_friend_sub_add+0xb0>
	BT_WARN("No space in friend subscription list");
   15dc2:	aa05      	add	r2, sp, #20
   15dc4:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15dc8:	4640      	mov	r0, r8
   15dca:	9706      	str	r7, [sp, #24]
   15dcc:	9301      	str	r3, [sp, #4]
   15dce:	9305      	str	r3, [sp, #20]
   15dd0:	f014 fb04 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
   15dd4:	e7d9      	b.n	15d8a <bt_mesh_friend_sub_add+0x86>
   15dd6:	bf00      	nop
   15dd8:	00032ed1 	.word	0x00032ed1
   15ddc:	0002db0c 	.word	0x0002db0c
   15de0:	00032e8c 	.word	0x00032e8c
   15de4:	00032ef3 	.word	0x00032ef3
   15de8:	00032f11 	.word	0x00032f11

00015dec <bt_mesh_friend_sub_rem>:
{
   15dec:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   15dee:	888b      	ldrh	r3, [r1, #4]
   15df0:	2b02      	cmp	r3, #2
{
   15df2:	b089      	sub	sp, #36	; 0x24
   15df4:	460d      	mov	r5, r1
	if (buf->len < BT_MESH_FRIEND_SUB_MIN_LEN) {
   15df6:	d80e      	bhi.n	15e16 <bt_mesh_friend_sub_rem+0x2a>
		BT_WARN("Too short Friend Subscription Remove");
   15df8:	4b2c      	ldr	r3, [pc, #176]	; (15eac <bt_mesh_friend_sub_rem+0xc0>)
   15dfa:	482d      	ldr	r0, [pc, #180]	; (15eb0 <bt_mesh_friend_sub_rem+0xc4>)
   15dfc:	9306      	str	r3, [sp, #24]
   15dfe:	aa05      	add	r2, sp, #20
   15e00:	2302      	movs	r3, #2
   15e02:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15e06:	9301      	str	r3, [sp, #4]
   15e08:	9305      	str	r3, [sp, #20]
   15e0a:	f014 fae7 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   15e0e:	f06f 0015 	mvn.w	r0, #21
}
   15e12:	b009      	add	sp, #36	; 0x24
   15e14:	bdf0      	pop	{r4, r5, r6, r7, pc}
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, true);
   15e16:	8901      	ldrh	r1, [r0, #8]
   15e18:	6800      	ldr	r0, [r0, #0]
   15e1a:	2301      	movs	r3, #1
   15e1c:	8b80      	ldrh	r0, [r0, #28]
   15e1e:	461a      	mov	r2, r3
   15e20:	f7ff fe84 	bl	15b2c <bt_mesh_friend_find>
	if (!frnd) {
   15e24:	4604      	mov	r4, r0
   15e26:	b968      	cbnz	r0, 15e44 <bt_mesh_friend_sub_rem+0x58>
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   15e28:	4b22      	ldr	r3, [pc, #136]	; (15eb4 <bt_mesh_friend_sub_rem+0xc8>)
   15e2a:	e9cd 3106 	strd	r3, r1, [sp, #24]
   15e2e:	2303      	movs	r3, #3
   15e30:	9301      	str	r3, [sp, #4]
   15e32:	9305      	str	r3, [sp, #20]
   15e34:	aa05      	add	r2, sp, #20
   15e36:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_WARN("Previous buffer not yet sent!");
   15e3a:	481d      	ldr	r0, [pc, #116]	; (15eb0 <bt_mesh_friend_sub_rem+0xc4>)
   15e3c:	f014 face 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
	return 0;
   15e40:	2000      	movs	r0, #0
   15e42:	e7e6      	b.n	15e12 <bt_mesh_friend_sub_rem+0x26>
	if (frnd->pending_buf) {
   15e44:	78c3      	ldrb	r3, [r0, #3]
   15e46:	f013 0708 	ands.w	r7, r3, #8
   15e4a:	d008      	beq.n	15e5e <bt_mesh_friend_sub_rem+0x72>
		BT_WARN("Previous buffer not yet sent!");
   15e4c:	4b1a      	ldr	r3, [pc, #104]	; (15eb8 <bt_mesh_friend_sub_rem+0xcc>)
   15e4e:	9306      	str	r3, [sp, #24]
   15e50:	2302      	movs	r3, #2
   15e52:	9301      	str	r3, [sp, #4]
   15e54:	9305      	str	r3, [sp, #20]
   15e56:	aa05      	add	r2, sp, #20
   15e58:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15e5c:	e7ed      	b.n	15e3a <bt_mesh_friend_sub_rem+0x4e>
	friend_recv_delay(frnd);
   15e5e:	f014 fa48 	bl	2a2f2 <friend_recv_delay>
	xact = net_buf_simple_pull_u8(buf);
   15e62:	4628      	mov	r0, r5
   15e64:	f015 ffea 	bl	2be3c <net_buf_simple_pull_u8>
   15e68:	4606      	mov	r6, r0
	while (buf->len >= 2U) {
   15e6a:	88ab      	ldrh	r3, [r5, #4]
   15e6c:	2b01      	cmp	r3, #1
   15e6e:	d804      	bhi.n	15e7a <bt_mesh_friend_sub_rem+0x8e>
	enqueue_sub_cfm(frnd, xact);
   15e70:	4631      	mov	r1, r6
   15e72:	4620      	mov	r0, r4
   15e74:	f7ff fd60 	bl	15938 <enqueue_sub_cfm>
   15e78:	e7e2      	b.n	15e40 <bt_mesh_friend_sub_rem+0x54>
		friend_sub_rem(frnd, net_buf_simple_pull_be16(buf));
   15e7a:	4628      	mov	r0, r5
   15e7c:	f015 ffee 	bl	2be5c <net_buf_simple_pull_be16>
		if (frnd->sub_list[i] == addr) {
   15e80:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   15e84:	4283      	cmp	r3, r0
   15e86:	d00d      	beq.n	15ea4 <bt_mesh_friend_sub_rem+0xb8>
   15e88:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   15e8c:	4283      	cmp	r3, r0
   15e8e:	d00b      	beq.n	15ea8 <bt_mesh_friend_sub_rem+0xbc>
   15e90:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   15e94:	4283      	cmp	r3, r0
   15e96:	d1e8      	bne.n	15e6a <bt_mesh_friend_sub_rem+0x7e>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   15e98:	2302      	movs	r3, #2
			frnd->sub_list[i] = BT_MESH_ADDR_UNASSIGNED;
   15e9a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   15e9e:	f8a3 7056 	strh.w	r7, [r3, #86]	; 0x56
			return;
   15ea2:	e7e2      	b.n	15e6a <bt_mesh_friend_sub_rem+0x7e>
	for (i = 0; i < ARRAY_SIZE(frnd->sub_list); i++) {
   15ea4:	2300      	movs	r3, #0
   15ea6:	e7f8      	b.n	15e9a <bt_mesh_friend_sub_rem+0xae>
   15ea8:	2301      	movs	r3, #1
   15eaa:	e7f6      	b.n	15e9a <bt_mesh_friend_sub_rem+0xae>
   15eac:	00032f36 	.word	0x00032f36
   15eb0:	0002db0c 	.word	0x0002db0c
   15eb4:	00032e8c 	.word	0x00032e8c
   15eb8:	00032ef3 	.word	0x00032ef3

00015ebc <bt_mesh_friend_poll>:
{
   15ebc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (buf->len < sizeof(*msg)) {
   15ec0:	888b      	ldrh	r3, [r1, #4]
	struct bt_mesh_ctl_friend_poll *msg = (void *)buf->data;
   15ec2:	680f      	ldr	r7, [r1, #0]
{
   15ec4:	b089      	sub	sp, #36	; 0x24
	if (buf->len < sizeof(*msg)) {
   15ec6:	b96b      	cbnz	r3, 15ee4 <bt_mesh_friend_poll+0x28>
		BT_WARN("Too short Friend Poll");
   15ec8:	4b40      	ldr	r3, [pc, #256]	; (15fcc <bt_mesh_friend_poll+0x110>)
		BT_WARN("Prohibited (non-zero) padding bits");
   15eca:	9306      	str	r3, [sp, #24]
   15ecc:	4840      	ldr	r0, [pc, #256]	; (15fd0 <bt_mesh_friend_poll+0x114>)
   15ece:	2302      	movs	r3, #2
   15ed0:	aa05      	add	r2, sp, #20
   15ed2:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15ed6:	9301      	str	r3, [sp, #4]
   15ed8:	9305      	str	r3, [sp, #20]
		return -EINVAL;
   15eda:	f06f 0515 	mvn.w	r5, #21
		BT_WARN("Prohibited (non-zero) padding bits");
   15ede:	f014 fa7d 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   15ee2:	e015      	b.n	15f10 <bt_mesh_friend_poll+0x54>
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, false);
   15ee4:	8901      	ldrh	r1, [r0, #8]
   15ee6:	6800      	ldr	r0, [r0, #0]
   15ee8:	2300      	movs	r3, #0
   15eea:	8b80      	ldrh	r0, [r0, #28]
   15eec:	2201      	movs	r2, #1
   15eee:	f7ff fe1d 	bl	15b2c <bt_mesh_friend_find>
	if (!frnd) {
   15ef2:	4604      	mov	r4, r0
   15ef4:	b980      	cbnz	r0, 15f18 <bt_mesh_friend_poll+0x5c>
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   15ef6:	4b37      	ldr	r3, [pc, #220]	; (15fd4 <bt_mesh_friend_poll+0x118>)
   15ef8:	4835      	ldr	r0, [pc, #212]	; (15fd0 <bt_mesh_friend_poll+0x114>)
   15efa:	e9cd 3106 	strd	r3, r1, [sp, #24]
   15efe:	aa05      	add	r2, sp, #20
   15f00:	2303      	movs	r3, #3
   15f02:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		return 0;
   15f06:	4625      	mov	r5, r4
		BT_WARN("No matching LPN addr 0x%04x", rx->ctx.addr);
   15f08:	9301      	str	r3, [sp, #4]
   15f0a:	9305      	str	r3, [sp, #20]
   15f0c:	f014 fa66 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
}
   15f10:	4628      	mov	r0, r5
   15f12:	b009      	add	sp, #36	; 0x24
   15f14:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (msg->fsn & ~1) {
   15f18:	783d      	ldrb	r5, [r7, #0]
   15f1a:	f035 0501 	bics.w	r5, r5, #1
   15f1e:	d001      	beq.n	15f24 <bt_mesh_friend_poll+0x68>
		BT_WARN("Prohibited (non-zero) padding bits");
   15f20:	4b2d      	ldr	r3, [pc, #180]	; (15fd8 <bt_mesh_friend_poll+0x11c>)
   15f22:	e7d2      	b.n	15eca <bt_mesh_friend_poll+0xe>
	if (frnd->pending_buf) {
   15f24:	78c3      	ldrb	r3, [r0, #3]
   15f26:	0719      	lsls	r1, r3, #28
   15f28:	d50b      	bpl.n	15f42 <bt_mesh_friend_poll+0x86>
		BT_WARN("Previous buffer not yet sent");
   15f2a:	4b2c      	ldr	r3, [pc, #176]	; (15fdc <bt_mesh_friend_poll+0x120>)
   15f2c:	9306      	str	r3, [sp, #24]
   15f2e:	4828      	ldr	r0, [pc, #160]	; (15fd0 <bt_mesh_friend_poll+0x114>)
   15f30:	2302      	movs	r3, #2
   15f32:	aa05      	add	r2, sp, #20
   15f34:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   15f38:	9301      	str	r3, [sp, #4]
   15f3a:	9305      	str	r3, [sp, #20]
   15f3c:	f014 fa4e 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return 0;
   15f40:	e7e6      	b.n	15f10 <bt_mesh_friend_poll+0x54>
	friend_recv_delay(frnd);
   15f42:	f014 f9d6 	bl	2a2f2 <friend_recv_delay>
	STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15f46:	4e26      	ldr	r6, [pc, #152]	; (15fe0 <bt_mesh_friend_poll+0x124>)
   15f48:	f8df 8098 	ldr.w	r8, [pc, #152]	; 15fe4 <bt_mesh_friend_poll+0x128>
   15f4c:	4546      	cmp	r6, r8
   15f4e:	d30f      	bcc.n	15f70 <bt_mesh_friend_poll+0xb4>
	if (!frnd->established) {
   15f50:	78e3      	ldrb	r3, [r4, #3]
   15f52:	06da      	lsls	r2, r3, #27
   15f54:	d514      	bpl.n	15f80 <bt_mesh_friend_poll+0xc4>
	if (msg->fsn == frnd->fsn && frnd->last) {
   15f56:	78e3      	ldrb	r3, [r4, #3]
   15f58:	7839      	ldrb	r1, [r7, #0]
   15f5a:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   15f5e:	f003 0201 	and.w	r2, r3, #1
   15f62:	4291      	cmp	r1, r2
   15f64:	d11f      	bne.n	15fa6 <bt_mesh_friend_poll+0xea>
   15f66:	b320      	cbz	r0, 15fb2 <bt_mesh_friend_poll+0xf6>
		frnd->send_last = 1U;
   15f68:	f043 0302 	orr.w	r3, r3, #2
   15f6c:	70e3      	strb	r3, [r4, #3]
   15f6e:	e7cf      	b.n	15f10 <bt_mesh_friend_poll+0x54>
		if (cb->polled) {
   15f70:	68b3      	ldr	r3, [r6, #8]
   15f72:	b11b      	cbz	r3, 15f7c <bt_mesh_friend_poll+0xc0>
			cb->polled(frnd->subnet->net_idx, frnd->lpn);
   15f74:	6922      	ldr	r2, [r4, #16]
   15f76:	8821      	ldrh	r1, [r4, #0]
   15f78:	8b90      	ldrh	r0, [r2, #28]
   15f7a:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15f7c:	360c      	adds	r6, #12
   15f7e:	e7e5      	b.n	15f4c <bt_mesh_friend_poll+0x90>
		frnd->established = 1U;
   15f80:	f043 0310 	orr.w	r3, r3, #16
		STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15f84:	4e16      	ldr	r6, [pc, #88]	; (15fe0 <bt_mesh_friend_poll+0x124>)
		frnd->established = 1U;
   15f86:	70e3      	strb	r3, [r4, #3]
		STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15f88:	4546      	cmp	r6, r8
   15f8a:	d2e4      	bcs.n	15f56 <bt_mesh_friend_poll+0x9a>
			if (cb->established) {
   15f8c:	f8d6 9000 	ldr.w	r9, [r6]
   15f90:	f1b9 0f00 	cmp.w	r9, #0
   15f94:	d005      	beq.n	15fa2 <bt_mesh_friend_poll+0xe6>
				cb->established(frnd->subnet->net_idx, frnd->lpn, frnd->recv_delay,
   15f96:	6920      	ldr	r0, [r4, #16]
   15f98:	6863      	ldr	r3, [r4, #4]
   15f9a:	78a2      	ldrb	r2, [r4, #2]
   15f9c:	8821      	ldrh	r1, [r4, #0]
   15f9e:	8b80      	ldrh	r0, [r0, #28]
   15fa0:	47c8      	blx	r9
		STRUCT_SECTION_FOREACH(bt_mesh_friend_cb, cb) {
   15fa2:	360c      	adds	r6, #12
   15fa4:	e7f0      	b.n	15f88 <bt_mesh_friend_poll+0xcc>
		if (frnd->last) {
   15fa6:	b120      	cbz	r0, 15fb2 <bt_mesh_friend_poll+0xf6>
			net_buf_unref(frnd->last);
   15fa8:	f00a fc74 	bl	20894 <net_buf_unref>
			frnd->last = NULL;
   15fac:	2300      	movs	r3, #0
   15fae:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		frnd->fsn = msg->fsn;
   15fb2:	78e3      	ldrb	r3, [r4, #3]
   15fb4:	783a      	ldrb	r2, [r7, #0]
   15fb6:	f362 0300 	bfi	r3, r2, #0, #1
   15fba:	70e3      	strb	r3, [r4, #3]
		if (sys_slist_is_empty(&frnd->queue)) {
   15fbc:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   15fc0:	2b00      	cmp	r3, #0
   15fc2:	d1a5      	bne.n	15f10 <bt_mesh_friend_poll+0x54>
			enqueue_update(frnd, 0);
   15fc4:	4620      	mov	r0, r4
   15fc6:	f7ff faff 	bl	155c8 <enqueue_update.constprop.0>
			BT_DBG("Enqueued Friend Update to empty queue");
   15fca:	e7a1      	b.n	15f10 <bt_mesh_friend_poll+0x54>
   15fcc:	00032f5b 	.word	0x00032f5b
   15fd0:	0002db0c 	.word	0x0002db0c
   15fd4:	00032e8c 	.word	0x00032e8c
   15fd8:	00032f71 	.word	0x00032f71
   15fdc:	00032f94 	.word	0x00032f94
   15fe0:	0002d868 	.word	0x0002d868
   15fe4:	0002d868 	.word	0x0002d868

00015fe8 <bt_mesh_friend_clear_cfm>:
{
   15fe8:	b590      	push	{r4, r7, lr}
   15fea:	b089      	sub	sp, #36	; 0x24
	if (buf->len < sizeof(*msg)) {
   15fec:	888b      	ldrh	r3, [r1, #4]
	struct bt_mesh_ctl_friend_clear_confirm *msg = (void *)buf->data;
   15fee:	680a      	ldr	r2, [r1, #0]
	if (buf->len < sizeof(*msg)) {
   15ff0:	2b03      	cmp	r3, #3
{
   15ff2:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*msg)) {
   15ff4:	d810      	bhi.n	16018 <bt_mesh_friend_clear_cfm+0x30>
		BT_WARN("Too short Friend Clear Confirm");
   15ff6:	4b2c      	ldr	r3, [pc, #176]	; (160a8 <bt_mesh_friend_clear_cfm+0xc0>)
   15ff8:	482c      	ldr	r0, [pc, #176]	; (160ac <bt_mesh_friend_clear_cfm+0xc4>)
   15ffa:	61bb      	str	r3, [r7, #24]
   15ffc:	f107 0214 	add.w	r2, r7, #20
   16000:	2302      	movs	r3, #2
   16002:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   16006:	607b      	str	r3, [r7, #4]
   16008:	617b      	str	r3, [r7, #20]
   1600a:	f014 f9e7 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   1600e:	f06f 0015 	mvn.w	r0, #21
}
   16012:	3724      	adds	r7, #36	; 0x24
   16014:	46bd      	mov	sp, r7
   16016:	bd90      	pop	{r4, r7, pc}
		if (frnd->clear.frnd == prev_friend) {
   16018:	4c25      	ldr	r4, [pc, #148]	; (160b0 <bt_mesh_friend_clear_cfm+0xc8>)
	frnd = find_clear(rx->ctx.addr);
   1601a:	8903      	ldrh	r3, [r0, #8]
		if (frnd->clear.frnd == prev_friend) {
   1601c:	f8b4 10dc 	ldrh.w	r1, [r4, #220]	; 0xdc
   16020:	4299      	cmp	r1, r3
   16022:	d025      	beq.n	16070 <bt_mesh_friend_clear_cfm+0x88>
   16024:	f8b4 11c4 	ldrh.w	r1, [r4, #452]	; 0x1c4
   16028:	4299      	cmp	r1, r3
   1602a:	d03a      	beq.n	160a2 <bt_mesh_friend_clear_cfm+0xba>
		BT_WARN("No pending clear procedure for 0x%02x", rx->ctx.addr);
   1602c:	4a21      	ldr	r2, [pc, #132]	; (160b4 <bt_mesh_friend_clear_cfm+0xcc>)
   1602e:	481f      	ldr	r0, [pc, #124]	; (160ac <bt_mesh_friend_clear_cfm+0xc4>)
   16030:	e9c7 2306 	strd	r2, r3, [r7, #24]
   16034:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   16038:	2303      	movs	r3, #3
   1603a:	f107 0214 	add.w	r2, r7, #20
   1603e:	607b      	str	r3, [r7, #4]
   16040:	617b      	str	r3, [r7, #20]
   16042:	f014 f9cb 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return 0;
   16046:	2000      	movs	r0, #0
   16048:	e7e3      	b.n	16012 <bt_mesh_friend_clear_cfm+0x2a>
	lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   1604a:	8853      	ldrh	r3, [r2, #2]
	if (lpn_counter != frnd->lpn_counter) {
   1604c:	8961      	ldrh	r1, [r4, #10]
   1604e:	ba5b      	rev16	r3, r3
   16050:	b29b      	uxth	r3, r3
   16052:	428b      	cmp	r3, r1
   16054:	d004      	beq.n	16060 <bt_mesh_friend_clear_cfm+0x78>
		BT_WARN("LPN counter mismatch (0x%04x != 0x%04x)",
   16056:	466c      	mov	r4, sp
   16058:	b088      	sub	sp, #32
   1605a:	4817      	ldr	r0, [pc, #92]	; (160b8 <bt_mesh_friend_clear_cfm+0xd0>)
   1605c:	466a      	mov	r2, sp
   1605e:	e012      	b.n	16086 <bt_mesh_friend_clear_cfm+0x9e>
	(void)k_work_cancel_delayable(&frnd->clear.timer);
   16060:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   16064:	f016 fecf 	bl	2ce06 <k_work_cancel_delayable>
	frnd->clear.frnd = BT_MESH_ADDR_UNASSIGNED;
   16068:	2000      	movs	r0, #0
   1606a:	f8a4 00b4 	strh.w	r0, [r4, #180]	; 0xb4
	return 0;
   1606e:	e7d0      	b.n	16012 <bt_mesh_friend_clear_cfm+0x2a>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   16070:	3428      	adds	r4, #40	; 0x28
	lpn_addr = sys_be16_to_cpu(msg->lpn_addr);
   16072:	8813      	ldrh	r3, [r2, #0]
	if (lpn_addr != frnd->lpn) {
   16074:	8821      	ldrh	r1, [r4, #0]
   16076:	ba5b      	rev16	r3, r3
   16078:	b29b      	uxth	r3, r3
   1607a:	4299      	cmp	r1, r3
   1607c:	d0e5      	beq.n	1604a <bt_mesh_friend_clear_cfm+0x62>
		BT_WARN("LPN address mismatch (0x%04x != 0x%04x)",
   1607e:	466c      	mov	r4, sp
   16080:	480e      	ldr	r0, [pc, #56]	; (160bc <bt_mesh_friend_clear_cfm+0xd4>)
   16082:	b088      	sub	sp, #32
   16084:	466a      	mov	r2, sp
		BT_WARN("LPN counter mismatch (0x%04x != 0x%04x)",
   16086:	e9c2 0304 	strd	r0, r3, [r2, #16]
   1608a:	2304      	movs	r3, #4
   1608c:	6191      	str	r1, [r2, #24]
   1608e:	4807      	ldr	r0, [pc, #28]	; (160ac <bt_mesh_friend_clear_cfm+0xc4>)
   16090:	60bb      	str	r3, [r7, #8]
   16092:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   16096:	f842 3f0c 	str.w	r3, [r2, #12]!
   1609a:	f014 f99f 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
   1609e:	46a5      	mov	sp, r4
   160a0:	e7d1      	b.n	16046 <bt_mesh_friend_clear_cfm+0x5e>
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   160a2:	f504 7488 	add.w	r4, r4, #272	; 0x110
   160a6:	e7e4      	b.n	16072 <bt_mesh_friend_clear_cfm+0x8a>
   160a8:	00032fb1 	.word	0x00032fb1
   160ac:	0002db0c 	.word	0x0002db0c
   160b0:	20001aa8 	.word	0x20001aa8
   160b4:	00032fd0 	.word	0x00032fd0
   160b8:	0003301e 	.word	0x0003301e
   160bc:	00032ff6 	.word	0x00032ff6

000160c0 <bt_mesh_friend_req>:
{
   160c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   160c4:	b08e      	sub	sp, #56	; 0x38
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   160c6:	7d03      	ldrb	r3, [r0, #20]
   160c8:	f003 0330 	and.w	r3, r3, #48	; 0x30
   160cc:	2b10      	cmp	r3, #16
{
   160ce:	af02      	add	r7, sp, #8
   160d0:	4606      	mov	r6, r0
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   160d2:	d063      	beq.n	1619c <bt_mesh_friend_req+0xdc>
	if (buf->len < sizeof(*msg)) {
   160d4:	888b      	ldrh	r3, [r1, #4]
   160d6:	2b09      	cmp	r3, #9
   160d8:	d809      	bhi.n	160ee <bt_mesh_friend_req+0x2e>
		BT_WARN("Too short Friend Request");
   160da:	4bb1      	ldr	r3, [pc, #708]	; (163a0 <bt_mesh_friend_req+0x2e0>)
		BT_WARN("Prohibited NumElements value (0x00)");
   160dc:	62bb      	str	r3, [r7, #40]	; 0x28
   160de:	2302      	movs	r3, #2
   160e0:	60fb      	str	r3, [r7, #12]
   160e2:	627b      	str	r3, [r7, #36]	; 0x24
   160e4:	f107 0224 	add.w	r2, r7, #36	; 0x24
   160e8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   160ec:	e00f      	b.n	1610e <bt_mesh_friend_req+0x4e>
	struct bt_mesh_ctl_friend_req *msg = (void *)buf->data;
   160ee:	f8d1 8000 	ldr.w	r8, [r1]
	if (msg->recv_delay <= 0x09) {
   160f2:	f898 3001 	ldrb.w	r3, [r8, #1]
   160f6:	2b09      	cmp	r3, #9
   160f8:	d813      	bhi.n	16122 <bt_mesh_friend_req+0x62>
		BT_WARN("Prohibited ReceiveDelay (0x%02x)", msg->recv_delay);
   160fa:	4aaa      	ldr	r2, [pc, #680]	; (163a4 <bt_mesh_friend_req+0x2e4>)
   160fc:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
   16100:	2303      	movs	r3, #3
   16102:	60fb      	str	r3, [r7, #12]
   16104:	627b      	str	r3, [r7, #36]	; 0x24
   16106:	f107 0224 	add.w	r2, r7, #36	; 0x24
   1610a:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   1610e:	48a6      	ldr	r0, [pc, #664]	; (163a8 <bt_mesh_friend_req+0x2e8>)
		return -EINVAL;
   16110:	f06f 0515 	mvn.w	r5, #21
		BT_WARN("Prohibited ReceiveDelay (0x%02x)", msg->recv_delay);
   16114:	f014 f962 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
}
   16118:	4628      	mov	r0, r5
   1611a:	3730      	adds	r7, #48	; 0x30
   1611c:	46bd      	mov	sp, r7
   1611e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return ((uint32_t)src[0] << 16) | sys_get_be16(&src[1]);
   16122:	f8b8 5003 	ldrh.w	r5, [r8, #3]
   16126:	f898 3002 	ldrb.w	r3, [r8, #2]
   1612a:	ba6d      	rev16	r5, r5
   1612c:	b2ad      	uxth	r5, r5
   1612e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
	if (poll_to <= 0x000009 || poll_to >= 0x34bc00) {
   16132:	4b9e      	ldr	r3, [pc, #632]	; (163ac <bt_mesh_friend_req+0x2ec>)
   16134:	f1a5 020a 	sub.w	r2, r5, #10
   16138:	429a      	cmp	r2, r3
   1613a:	d903      	bls.n	16144 <bt_mesh_friend_req+0x84>
		BT_WARN("Prohibited PollTimeout (0x%06x)", poll_to);
   1613c:	4b9c      	ldr	r3, [pc, #624]	; (163b0 <bt_mesh_friend_req+0x2f0>)
   1613e:	e9c7 350a 	strd	r3, r5, [r7, #40]	; 0x28
   16142:	e7dd      	b.n	16100 <bt_mesh_friend_req+0x40>
	if (msg->num_elem == 0x00) {
   16144:	f898 3007 	ldrb.w	r3, [r8, #7]
   16148:	b90b      	cbnz	r3, 1614e <bt_mesh_friend_req+0x8e>
		BT_WARN("Prohibited NumElements value (0x00)");
   1614a:	4b9a      	ldr	r3, [pc, #616]	; (163b4 <bt_mesh_friend_req+0x2f4>)
   1614c:	e7c6      	b.n	160dc <bt_mesh_friend_req+0x1c>
	if (!BT_MESH_ADDR_IS_UNICAST(rx->ctx.addr + msg->num_elem - 1)) {
   1614e:	8901      	ldrh	r1, [r0, #8]
   16150:	440b      	add	r3, r1
   16152:	2b01      	cmp	r3, #1
   16154:	d002      	beq.n	1615c <bt_mesh_friend_req+0x9c>
   16156:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1615a:	dd01      	ble.n	16160 <bt_mesh_friend_req+0xa0>
		BT_WARN("LPN elements stretch outside of unicast range");
   1615c:	4b96      	ldr	r3, [pc, #600]	; (163b8 <bt_mesh_friend_req+0x2f8>)
   1615e:	e7bd      	b.n	160dc <bt_mesh_friend_req+0x1c>
	if (!MIN_QUEUE_SIZE_LOG(msg->criteria)) {
   16160:	f898 3000 	ldrb.w	r3, [r8]
   16164:	f013 0307 	ands.w	r3, r3, #7
   16168:	d101      	bne.n	1616e <bt_mesh_friend_req+0xae>
		BT_WARN("Prohibited Minimum Queue Size in Friend Request");
   1616a:	4b94      	ldr	r3, [pc, #592]	; (163bc <bt_mesh_friend_req+0x2fc>)
   1616c:	e7b6      	b.n	160dc <bt_mesh_friend_req+0x1c>
	if (CONFIG_BT_MESH_FRIEND_QUEUE_SIZE < MIN_QUEUE_SIZE(msg->criteria)) {
   1616e:	2201      	movs	r2, #1
   16170:	fa02 f303 	lsl.w	r3, r2, r3
   16174:	2b10      	cmp	r3, #16
   16176:	d913      	bls.n	161a0 <bt_mesh_friend_req+0xe0>
		BT_WARN("We have a too small Friend Queue size (%u < %u)",
   16178:	466c      	mov	r4, sp
   1617a:	b088      	sub	sp, #32
   1617c:	aa02      	add	r2, sp, #8
   1617e:	4990      	ldr	r1, [pc, #576]	; (163c0 <bt_mesh_friend_req+0x300>)
   16180:	6111      	str	r1, [r2, #16]
   16182:	2110      	movs	r1, #16
   16184:	e9c2 1305 	strd	r1, r3, [r2, #20]
   16188:	2304      	movs	r3, #4
   1618a:	f842 3f0c 	str.w	r3, [r2, #12]!
   1618e:	4886      	ldr	r0, [pc, #536]	; (163a8 <bt_mesh_friend_req+0x2e8>)
   16190:	61bb      	str	r3, [r7, #24]
   16192:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   16196:	f014 f921 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
   1619a:	46a5      	mov	sp, r4
		return 0;
   1619c:	2500      	movs	r5, #0
   1619e:	e7bb      	b.n	16118 <bt_mesh_friend_req+0x58>
	frnd = bt_mesh_friend_find(rx->sub->net_idx, rx->ctx.addr, true, false);
   161a0:	6800      	ldr	r0, [r0, #0]
   161a2:	2300      	movs	r3, #0
   161a4:	8b80      	ldrh	r0, [r0, #28]
   161a6:	f7ff fcc1 	bl	15b2c <bt_mesh_friend_find>
	if (frnd) {
   161aa:	4604      	mov	r4, r0
   161ac:	b960      	cbnz	r0, 161c8 <bt_mesh_friend_req+0x108>
		if (!bt_mesh.frnd[i].subnet) {
   161ae:	4b85      	ldr	r3, [pc, #532]	; (163c4 <bt_mesh_friend_req+0x304>)
   161b0:	6b9c      	ldr	r4, [r3, #56]	; 0x38
   161b2:	b124      	cbz	r4, 161be <bt_mesh_friend_req+0xfe>
   161b4:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   161b8:	2a00      	cmp	r2, #0
   161ba:	d158      	bne.n	1626e <bt_mesh_friend_req+0x1ae>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   161bc:	2401      	movs	r4, #1
			frnd = &bt_mesh.frnd[i];
   161be:	20e8      	movs	r0, #232	; 0xe8
   161c0:	fb00 3404 	mla	r4, r0, r4, r3
   161c4:	3428      	adds	r4, #40	; 0x28
	if (!frnd) {
   161c6:	e00e      	b.n	161e6 <bt_mesh_friend_req+0x126>
		BT_WARN("Existing LPN re-requesting Friendship");
   161c8:	4b7f      	ldr	r3, [pc, #508]	; (163c8 <bt_mesh_friend_req+0x308>)
   161ca:	4877      	ldr	r0, [pc, #476]	; (163a8 <bt_mesh_friend_req+0x2e8>)
   161cc:	62bb      	str	r3, [r7, #40]	; 0x28
   161ce:	f107 0224 	add.w	r2, r7, #36	; 0x24
   161d2:	2302      	movs	r3, #2
   161d4:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   161d8:	60fb      	str	r3, [r7, #12]
   161da:	627b      	str	r3, [r7, #36]	; 0x24
   161dc:	f014 f8fe 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		friend_clear(frnd);
   161e0:	4620      	mov	r0, r4
   161e2:	f7ff f891 	bl	15308 <friend_clear>
	frnd->lpn = rx->ctx.addr;
   161e6:	f8b6 a008 	ldrh.w	sl, [r6, #8]
   161ea:	f8a4 a000 	strh.w	sl, [r4]
	frnd->num_elem = msg->num_elem;
   161ee:	f898 3007 	ldrb.w	r3, [r8, #7]
   161f2:	7223      	strb	r3, [r4, #8]
	frnd->subnet = rx->sub;
   161f4:	6832      	ldr	r2, [r6, #0]
   161f6:	6122      	str	r2, [r4, #16]
	frnd->recv_delay = msg->recv_delay;
   161f8:	f898 3001 	ldrb.w	r3, [r8, #1]
   161fc:	70a3      	strb	r3, [r4, #2]
	frnd->poll_to = poll_to * 100U;
   161fe:	2364      	movs	r3, #100	; 0x64
   16200:	435d      	muls	r5, r3
	frnd->lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   16202:	f8b8 3008 	ldrh.w	r3, [r8, #8]
	frnd->poll_to = poll_to * 100U;
   16206:	6065      	str	r5, [r4, #4]
	frnd->lpn_counter = sys_be16_to_cpu(msg->lpn_counter);
   16208:	ba5b      	rev16	r3, r3
   1620a:	8163      	strh	r3, [r4, #10]
	frnd->clear.frnd = sys_be16_to_cpu(msg->prev_addr);
   1620c:	f8b8 3005 	ldrh.w	r3, [r8, #5]
   16210:	ba5b      	rev16	r3, r3
   16212:	f8a4 30b4 	strh.w	r3, [r4, #180]	; 0xb4
	err = friend_cred_create(frnd, SUBNET_KEY_TX_IDX(frnd->subnet));
   16216:	7f95      	ldrb	r5, [r2, #30]
   16218:	1eab      	subs	r3, r5, #2
   1621a:	425d      	negs	r5, r3
   1621c:	415d      	adcs	r5, r3
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   1621e:	f7fa fe21 	bl	10e64 <bt_mesh_primary_addr>
					  frnd->subnet->keys[idx].net);
   16222:	215a      	movs	r1, #90	; 0x5a
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   16224:	eb05 1945 	add.w	r9, r5, r5, lsl #5
					  frnd->subnet->keys[idx].net);
   16228:	434d      	muls	r5, r1
   1622a:	6921      	ldr	r1, [r4, #16]
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   1622c:	8963      	ldrh	r3, [r4, #10]
					  frnd->subnet->keys[idx].net);
   1622e:	352d      	adds	r5, #45	; 0x2d
   16230:	440d      	add	r5, r1
	return bt_mesh_friend_cred_create(&frnd->cred[idx], frnd->lpn,
   16232:	f109 0914 	add.w	r9, r9, #20
   16236:	9501      	str	r5, [sp, #4]
   16238:	89a1      	ldrh	r1, [r4, #12]
   1623a:	9100      	str	r1, [sp, #0]
   1623c:	44a1      	add	r9, r4
   1623e:	4602      	mov	r2, r0
   16240:	4651      	mov	r1, sl
   16242:	4648      	mov	r0, r9
   16244:	f013 f946 	bl	294d4 <bt_mesh_friend_cred_create>
	if (err) {
   16248:	b300      	cbz	r0, 1628c <bt_mesh_friend_req+0x1cc>
		BT_ERR("Failed to create friend credentials");
   1624a:	4b60      	ldr	r3, [pc, #384]	; (163cc <bt_mesh_friend_req+0x30c>)
   1624c:	4856      	ldr	r0, [pc, #344]	; (163a8 <bt_mesh_friend_req+0x2e8>)
   1624e:	62bb      	str	r3, [r7, #40]	; 0x28
   16250:	f107 0224 	add.w	r2, r7, #36	; 0x24
   16254:	2302      	movs	r3, #2
   16256:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1625a:	60fb      	str	r3, [r7, #12]
   1625c:	627b      	str	r3, [r7, #36]	; 0x24
   1625e:	f014 f8bd 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		friend_clear(frnd);
   16262:	4620      	mov	r0, r4
   16264:	f7ff f850 	bl	15308 <friend_clear>
		return -EIO;
   16268:	f06f 0504 	mvn.w	r5, #4
   1626c:	e754      	b.n	16118 <bt_mesh_friend_req+0x58>
		BT_WARN("No free Friend contexts for new LPN");
   1626e:	4b58      	ldr	r3, [pc, #352]	; (163d0 <bt_mesh_friend_req+0x310>)
   16270:	62bb      	str	r3, [r7, #40]	; 0x28
   16272:	484d      	ldr	r0, [pc, #308]	; (163a8 <bt_mesh_friend_req+0x2e8>)
   16274:	2302      	movs	r3, #2
   16276:	f107 0224 	add.w	r2, r7, #36	; 0x24
   1627a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1627e:	60fb      	str	r3, [r7, #12]
   16280:	627b      	str	r3, [r7, #36]	; 0x24
		return -ENOMEM;
   16282:	f06f 050b 	mvn.w	r5, #11
		BT_WARN("No free Friend contexts for new LPN");
   16286:	f014 f8a9 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return -ENOMEM;
   1628a:	e745      	b.n	16118 <bt_mesh_friend_req+0x58>
	if (BT_MESH_ADDR_IS_UNICAST(frnd->clear.frnd) &&
   1628c:	f9b4 30b4 	ldrsh.w	r3, [r4, #180]	; 0xb4
   16290:	f8b4 00b4 	ldrh.w	r0, [r4, #180]	; 0xb4
   16294:	2b00      	cmp	r3, #0
   16296:	dd15      	ble.n	162c4 <bt_mesh_friend_req+0x204>
	    !bt_mesh_has_addr(frnd->clear.frnd)) {
   16298:	f7fa fdfe 	bl	10e98 <bt_mesh_has_addr>
	if (BT_MESH_ADDR_IS_UNICAST(frnd->clear.frnd) &&
   1629c:	b990      	cbnz	r0, 162c4 <bt_mesh_friend_req+0x204>
	return z_impl_k_uptime_ticks();
   1629e:	f016 ff57 	bl	2d150 <z_impl_k_uptime_ticks>
   162a2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   162a6:	fba0 0302 	umull	r0, r3, r0, r2
   162aa:	fb02 3301 	mla	r3, r2, r1, r3
   162ae:	0bc0      	lsrs	r0, r0, #15
   162b0:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	frnd->clear.repeat_sec = 1U;
   162b4:	2301      	movs	r3, #1
	return (uint32_t)k_uptime_get();
   162b6:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
   162ba:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	send_friend_clear(frnd);
   162be:	4620      	mov	r0, r4
   162c0:	f7fe ffb4 	bl	1522c <send_friend_clear>
	delay = offer_delay(frnd, rx->ctx.recv_rssi, msg->criteria);
   162c4:	f898 3000 	ldrb.w	r3, [r8]
	delay = (int32_t)fact[RECV_WIN_FACT(crit)] * RECV_WIN;
   162c8:	4a42      	ldr	r2, [pc, #264]	; (163d4 <bt_mesh_friend_req+0x314>)
   162ca:	f3c3 01c1 	ubfx	r1, r3, #3, #2
	delay -= (int32_t)fact[RSSI_FACT(crit)] * rssi;
   162ce:	f3c3 1341 	ubfx	r3, r3, #5, #2
	delay = (int32_t)fact[RECV_WIN_FACT(crit)] * RECV_WIN;
   162d2:	5c55      	ldrb	r5, [r2, r1]
	delay -= (int32_t)fact[RSSI_FACT(crit)] * rssi;
   162d4:	5cd2      	ldrb	r2, [r2, r3]
   162d6:	f996 300c 	ldrsb.w	r3, [r6, #12]
	delay = (int32_t)fact[RECV_WIN_FACT(crit)] * RECV_WIN;
   162da:	ebc5 2505 	rsb	r5, r5, r5, lsl #8
	delay -= (int32_t)fact[RSSI_FACT(crit)] * rssi;
   162de:	fb02 5513 	mls	r5, r2, r3, r5
	delay /= 10;
   162e2:	230a      	movs	r3, #10
   162e4:	fb95 f5f3 	sdiv	r5, r5, r3
	return MAX(delay, 100);
   162e8:	2d64      	cmp	r5, #100	; 0x64
   162ea:	bfb8      	it	lt
   162ec:	2564      	movlt	r5, #100	; 0x64
   162ee:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   162f2:	f240 30e7 	movw	r0, #999	; 0x3e7
   162f6:	2100      	movs	r1, #0
   162f8:	fbc5 010c 	smlal	r0, r1, r5, ip
   162fc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   16300:	2300      	movs	r3, #0
   16302:	f7e9 feed 	bl	e0 <__aeabi_uldivmod>
   16306:	4602      	mov	r2, r0
   16308:	460b      	mov	r3, r1
	k_work_reschedule(&frnd->timer, K_MSEC(delay));
   1630a:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1630e:	f00e f829 	bl	24364 <k_work_reschedule>
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*off));
   16312:	1d3b      	adds	r3, r7, #4
   16314:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
	net_buf_simple_reserve(&sdu, 1);
   16318:	2101      	movs	r1, #1
   1631a:	f107 000c 	add.w	r0, r7, #12
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*off));
   1631e:	e9c7 2304 	strd	r2, r3, [r7, #16]
	enqueue_offer(frnd, rx->ctx.recv_rssi);
   16322:	f996 500c 	ldrsb.w	r5, [r6, #12]
	NET_BUF_SIMPLE_DEFINE(sdu, 1 + sizeof(*off));
   16326:	60fb      	str	r3, [r7, #12]
	net_buf_simple_reserve(&sdu, 1);
   16328:	f015 fca2 	bl	2bc70 <net_buf_simple_reserve>
	off = net_buf_simple_add(&sdu, sizeof(*off));
   1632c:	2106      	movs	r1, #6
   1632e:	f107 000c 	add.w	r0, r7, #12
   16332:	f015 fd03 	bl	2bd3c <net_buf_simple_add>
	off->recv_win = CONFIG_BT_MESH_FRIEND_RECV_WIN,
   16336:	23ff      	movs	r3, #255	; 0xff
   16338:	7003      	strb	r3, [r0, #0]
	off->queue_size = CONFIG_BT_MESH_FRIEND_QUEUE_SIZE,
   1633a:	2310      	movs	r3, #16
   1633c:	7043      	strb	r3, [r0, #1]
	off->sub_list_size = ARRAY_SIZE(frnd->sub_list),
   1633e:	2303      	movs	r3, #3
   16340:	7083      	strb	r3, [r0, #2]
	off->rssi = rssi,
   16342:	70c5      	strb	r5, [r0, #3]
	off->frnd_counter = sys_cpu_to_be16(frnd->counter);
   16344:	89a3      	ldrh	r3, [r4, #12]
   16346:	ba5b      	rev16	r3, r3
   16348:	8083      	strh	r3, [r0, #4]
	buf = encode_friend_ctl(frnd, TRANS_CTL_OP_FRIEND_OFFER, &sdu);
   1634a:	f107 020c 	add.w	r2, r7, #12
   1634e:	2104      	movs	r1, #4
   16350:	4620      	mov	r0, r4
   16352:	f7ff f90f 	bl	15574 <encode_friend_ctl>
	if (!buf) {
   16356:	4606      	mov	r6, r0
   16358:	b960      	cbnz	r0, 16374 <bt_mesh_friend_req+0x2b4>
		BT_ERR("Unable to encode Friend Offer");
   1635a:	4b1f      	ldr	r3, [pc, #124]	; (163d8 <bt_mesh_friend_req+0x318>)
   1635c:	62bb      	str	r3, [r7, #40]	; 0x28
   1635e:	4812      	ldr	r0, [pc, #72]	; (163a8 <bt_mesh_friend_req+0x2e8>)
   16360:	2302      	movs	r3, #2
   16362:	f107 0224 	add.w	r2, r7, #36	; 0x24
   16366:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1636a:	603b      	str	r3, [r7, #0]
   1636c:	627b      	str	r3, [r7, #36]	; 0x24
   1636e:	f014 f835 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		return;
   16372:	e713      	b.n	1619c <bt_mesh_friend_req+0xdc>
	if (encrypt_friend_pdu(frnd, buf, true)) {
   16374:	4601      	mov	r1, r0
   16376:	2201      	movs	r2, #1
   16378:	4620      	mov	r0, r4
   1637a:	f7ff f9c5 	bl	15708 <encrypt_friend_pdu>
   1637e:	4605      	mov	r5, r0
   16380:	2800      	cmp	r0, #0
   16382:	f47f af0b 	bne.w	1619c <bt_mesh_friend_req+0xdc>
	if (frnd->last) {
   16386:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1638a:	b108      	cbz	r0, 16390 <bt_mesh_friend_req+0x2d0>
		net_buf_unref(frnd->last);
   1638c:	f00a fa82 	bl	20894 <net_buf_unref>
	frnd->send_last = 1U;
   16390:	78e3      	ldrb	r3, [r4, #3]
	frnd->last = buf;
   16392:	f8c4 609c 	str.w	r6, [r4, #156]	; 0x9c
	frnd->send_last = 1U;
   16396:	f043 0302 	orr.w	r3, r3, #2
   1639a:	70e3      	strb	r3, [r4, #3]
   1639c:	e6bc      	b.n	16118 <bt_mesh_friend_req+0x58>
   1639e:	bf00      	nop
   163a0:	00033046 	.word	0x00033046
   163a4:	0003305f 	.word	0x0003305f
   163a8:	0002db0c 	.word	0x0002db0c
   163ac:	0034bbf5 	.word	0x0034bbf5
   163b0:	00033080 	.word	0x00033080
   163b4:	000330a0 	.word	0x000330a0
   163b8:	000330c4 	.word	0x000330c4
   163bc:	000330f2 	.word	0x000330f2
   163c0:	00033122 	.word	0x00033122
   163c4:	20001aa8 	.word	0x20001aa8
   163c8:	00033152 	.word	0x00033152
   163cc:	0003319c 	.word	0x0003319c
   163d0:	00033178 	.word	0x00033178
   163d4:	00033234 	.word	0x00033234
   163d8:	000331c0 	.word	0x000331c0

000163dc <bt_mesh_friend_init>:
{
   163dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	list->head = NULL;
   163de:	4c11      	ldr	r4, [pc, #68]	; (16424 <bt_mesh_friend_init+0x48>)
		k_work_init_delayable(&frnd->timer, friend_timeout);
   163e0:	4f11      	ldr	r7, [pc, #68]	; (16428 <bt_mesh_friend_init+0x4c>)
		k_work_init_delayable(&frnd->clear.timer, clear_timeout);
   163e2:	4e12      	ldr	r6, [pc, #72]	; (1642c <bt_mesh_friend_init+0x50>)
   163e4:	2500      	movs	r5, #0
		k_work_init_delayable(&frnd->timer, friend_timeout);
   163e6:	4639      	mov	r1, r7
   163e8:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = NULL;
   163ec:	e9c4 5532 	strd	r5, r5, [r4, #200]	; 0xc8
   163f0:	f016 fcfb 	bl	2cdea <k_work_init_delayable>
		k_work_init_delayable(&frnd->clear.timer, clear_timeout);
   163f4:	4631      	mov	r1, r6
   163f6:	f104 00e0 	add.w	r0, r4, #224	; 0xe0
   163fa:	f016 fcf6 	bl	2cdea <k_work_init_delayable>
		k_work_init_delayable(&frnd->timer, friend_timeout);
   163fe:	4639      	mov	r1, r7
   16400:	f504 70b8 	add.w	r0, r4, #368	; 0x170
   16404:	e9c4 552e 	strd	r5, r5, [r4, #184]	; 0xb8
   16408:	e9c4 556c 	strd	r5, r5, [r4, #432]	; 0x1b0
   1640c:	f016 fced 	bl	2cdea <k_work_init_delayable>
		k_work_init_delayable(&frnd->clear.timer, clear_timeout);
   16410:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
   16414:	4631      	mov	r1, r6
   16416:	f016 fce8 	bl	2cdea <k_work_init_delayable>
   1641a:	e9c4 5568 	strd	r5, r5, [r4, #416]	; 0x1a0
}
   1641e:	4628      	mov	r0, r5
   16420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   16422:	bf00      	nop
   16424:	20001aa8 	.word	0x20001aa8
   16428:	000159b5 	.word	0x000159b5
   1642c:	0002a431 	.word	0x0002a431

00016430 <bt_mesh_friend_match>:
{
   16430:	b508      	push	{r3, lr}
   16432:	460a      	mov	r2, r1
		if (friend_lpn_matches(frnd, net_idx, addr)) {
   16434:	4601      	mov	r1, r0
   16436:	4805      	ldr	r0, [pc, #20]	; (1644c <bt_mesh_friend_match+0x1c>)
   16438:	f013 ff94 	bl	2a364 <friend_lpn_matches>
   1643c:	b920      	cbnz	r0, 16448 <bt_mesh_friend_match+0x18>
}
   1643e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		if (friend_lpn_matches(frnd, net_idx, addr)) {
   16442:	4803      	ldr	r0, [pc, #12]	; (16450 <bt_mesh_friend_match+0x20>)
   16444:	f013 bf8e 	b.w	2a364 <friend_lpn_matches>
}
   16448:	bd08      	pop	{r3, pc}
   1644a:	bf00      	nop
   1644c:	20001ad0 	.word	0x20001ad0
   16450:	20001bb8 	.word	0x20001bb8

00016454 <bt_mesh_friend_queue_has_space>:
{
   16454:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16458:	4681      	mov	r9, r0
   1645a:	460e      	mov	r6, r1
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   1645c:	4601      	mov	r1, r0
   1645e:	4817      	ldr	r0, [pc, #92]	; (164bc <bt_mesh_friend_queue_has_space+0x68>)
{
   16460:	f89d 8020 	ldrb.w	r8, [sp, #32]
   16464:	461f      	mov	r7, r3
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   16466:	f013 ff7d 	bl	2a364 <friend_lpn_matches>
{
   1646a:	4692      	mov	sl, r2
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   1646c:	4605      	mov	r5, r0
   1646e:	b1f0      	cbz	r0, 164ae <bt_mesh_friend_queue_has_space+0x5a>
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   16470:	f1b8 0f10 	cmp.w	r8, #16
   16474:	d81b      	bhi.n	164ae <bt_mesh_friend_queue_has_space+0x5a>
   16476:	4811      	ldr	r0, [pc, #68]	; (164bc <bt_mesh_friend_queue_has_space+0x68>)
   16478:	4643      	mov	r3, r8
   1647a:	463a      	mov	r2, r7
   1647c:	4631      	mov	r1, r6
   1647e:	f014 f829 	bl	2a4d4 <friend_queue_has_space.part.0>
   16482:	4604      	mov	r4, r0
		if (!friend_lpn_matches(frnd, net_idx, dst)) {
   16484:	480e      	ldr	r0, [pc, #56]	; (164c0 <bt_mesh_friend_queue_has_space+0x6c>)
   16486:	4652      	mov	r2, sl
   16488:	4649      	mov	r1, r9
   1648a:	f013 ff6b 	bl	2a364 <friend_lpn_matches>
   1648e:	b180      	cbz	r0, 164b2 <bt_mesh_friend_queue_has_space+0x5e>
	if (seg_count > CONFIG_BT_MESH_FRIEND_QUEUE_SIZE) {
   16490:	f1b8 0f10 	cmp.w	r8, #16
   16494:	d808      	bhi.n	164a8 <bt_mesh_friend_queue_has_space+0x54>
   16496:	480a      	ldr	r0, [pc, #40]	; (164c0 <bt_mesh_friend_queue_has_space+0x6c>)
   16498:	4643      	mov	r3, r8
   1649a:	463a      	mov	r2, r7
   1649c:	4631      	mov	r1, r6
   1649e:	f014 f819 	bl	2a4d4 <friend_queue_has_space.part.0>
			someone_has_space = true;
   164a2:	2800      	cmp	r0, #0
   164a4:	bf18      	it	ne
   164a6:	4604      	movne	r4, r0
}
   164a8:	4620      	mov	r0, r4
   164aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bool someone_has_space = false, friend_match = false;
   164ae:	2400      	movs	r4, #0
   164b0:	e7e8      	b.n	16484 <bt_mesh_friend_queue_has_space+0x30>
		return true;
   164b2:	2d00      	cmp	r5, #0
   164b4:	bf08      	it	eq
   164b6:	2401      	moveq	r4, #1
   164b8:	e7f6      	b.n	164a8 <bt_mesh_friend_queue_has_space+0x54>
   164ba:	bf00      	nop
   164bc:	20001ad0 	.word	0x20001ad0
   164c0:	20001bb8 	.word	0x20001bb8

000164c4 <bt_mesh_friend_enqueue_rx>:

void bt_mesh_friend_enqueue_rx(struct bt_mesh_net_rx *rx,
			       enum bt_mesh_friend_pdu_type type,
			       const uint64_t *seq_auth, uint8_t seg_count,
			       struct net_buf_simple *sbuf)
{
   164c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   164c8:	4615      	mov	r5, r2
	int i;

	if (!rx->friend_match ||
   164ca:	f990 2014 	ldrsb.w	r2, [r0, #20]
   164ce:	2a00      	cmp	r2, #0
{
   164d0:	4699      	mov	r9, r3
   164d2:	b08d      	sub	sp, #52	; 0x34
	if (!rx->friend_match ||
   164d4:	7d03      	ldrb	r3, [r0, #20]
{
   164d6:	4604      	mov	r4, r0
   164d8:	4688      	mov	r8, r1
	if (!rx->friend_match ||
   164da:	da6c      	bge.n	165b6 <bt_mesh_friend_enqueue_rx+0xf2>
   164dc:	7b42      	ldrb	r2, [r0, #13]
   164de:	2a01      	cmp	r2, #1
   164e0:	d803      	bhi.n	164ea <bt_mesh_friend_enqueue_rx+0x26>
	    (rx->ctx.recv_ttl <= 1U && rx->net_if != BT_MESH_NET_IF_LOCAL) ||
   164e2:	f003 0330 	and.w	r3, r3, #48	; 0x30
   164e6:	2b10      	cmp	r3, #16
   164e8:	d165      	bne.n	165b6 <bt_mesh_friend_enqueue_rx+0xf2>
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
   164ea:	f7f5 fc05 	bl	bcf8 <bt_mesh_friend_get>
	    (rx->ctx.recv_ttl <= 1U && rx->net_if != BT_MESH_NET_IF_LOCAL) ||
   164ee:	2801      	cmp	r0, #1
   164f0:	d161      	bne.n	165b6 <bt_mesh_friend_enqueue_rx+0xf2>
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   164f2:	4b37      	ldr	r3, [pc, #220]	; (165d0 <bt_mesh_friend_enqueue_rx+0x10c>)
   164f4:	2700      	movs	r7, #0
   164f6:	f1a3 0b28 	sub.w	fp, r3, #40	; 0x28
	BT_DBG("recv_ttl %u net_idx 0x%04x src 0x%04x dst 0x%04x",
	       rx->ctx.recv_ttl, rx->sub->net_idx, rx->ctx.addr,
	       rx->ctx.recv_dst);

	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   164fa:	4b35      	ldr	r3, [pc, #212]	; (165d0 <bt_mesh_friend_enqueue_rx+0x10c>)

		if (!friend_lpn_matches(frnd, rx->sub->net_idx,
   164fc:	8962      	ldrh	r2, [r4, #10]
   164fe:	19de      	adds	r6, r3, r7
   16500:	6823      	ldr	r3, [r4, #0]
   16502:	4630      	mov	r0, r6
   16504:	8b99      	ldrh	r1, [r3, #28]
   16506:	f013 ff2d 	bl	2a364 <friend_lpn_matches>
   1650a:	2800      	cmp	r0, #0
   1650c:	d04f      	beq.n	165ae <bt_mesh_friend_enqueue_rx+0xea>
					rx->ctx.recv_dst)) {
			continue;
		}

		if (friend_lpn_matches(frnd, rx->sub->net_idx,
   1650e:	f8b4 a008 	ldrh.w	sl, [r4, #8]
   16512:	4630      	mov	r0, r6
   16514:	4652      	mov	r2, sl
   16516:	f013 ff25 	bl	2a364 <friend_lpn_matches>
   1651a:	2800      	cmp	r0, #0
   1651c:	d147      	bne.n	165ae <bt_mesh_friend_enqueue_rx+0xea>
					rx->ctx.addr)) {
			continue;
		}

		if (!friend_queue_prepare_space(frnd, rx->ctx.addr, seq_auth,
   1651e:	464b      	mov	r3, r9
   16520:	462a      	mov	r2, r5
   16522:	4651      	mov	r1, sl
   16524:	4630      	mov	r0, r6
   16526:	f7fe ff93 	bl	15450 <friend_queue_prepare_space>
   1652a:	2800      	cmp	r0, #0
   1652c:	d03f      	beq.n	165ae <bt_mesh_friend_enqueue_rx+0xea>
	if (bt_mesh_has_addr(rx->ctx.addr)) {
   1652e:	8920      	ldrh	r0, [r4, #8]
   16530:	f7fa fcb2 	bl	10e98 <bt_mesh_has_addr>
   16534:	2800      	cmp	r0, #0
   16536:	d13a      	bne.n	165ae <bt_mesh_friend_enqueue_rx+0xea>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && seq_auth) {
   16538:	f1b8 0f00 	cmp.w	r8, #0
   1653c:	d105      	bne.n	1654a <bt_mesh_friend_enqueue_rx+0x86>
   1653e:	b125      	cbz	r5, 1654a <bt_mesh_friend_enqueue_rx+0x86>
		friend_purge_old_ack(frnd, seq_auth, rx->ctx.addr);
   16540:	8922      	ldrh	r2, [r4, #8]
   16542:	4629      	mov	r1, r5
   16544:	4630      	mov	r0, r6
   16546:	f013 ffdb 	bl	2a500 <friend_purge_old_ack>
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   1654a:	7d22      	ldrb	r2, [r4, #20]
	info.src = rx->ctx.addr;
   1654c:	68a3      	ldr	r3, [r4, #8]
   1654e:	9303      	str	r3, [sp, #12]
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   16550:	f002 0130 	and.w	r1, r2, #48	; 0x30
		info.ttl = rx->ctx.recv_ttl;
   16554:	7b63      	ldrb	r3, [r4, #13]
	if (rx->net_if == BT_MESH_NET_IF_LOCAL) {
   16556:	2910      	cmp	r1, #16
		info.ttl = rx->ctx.recv_ttl - 1U;
   16558:	bf18      	it	ne
   1655a:	f103 33ff 	addne.w	r3, r3, #4294967295	; 0xffffffff
	info.ctl = rx->ctl;
   1655e:	f3c2 01c0 	ubfx	r1, r2, #3, #1
		info.ttl = rx->ctx.recv_ttl - 1U;
   16562:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	info.ctl = rx->ctl;
   16566:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
   1656a:	f88d 3013 	strb.w	r3, [sp, #19]
	sys_put_be24(rx->seq, info.seq);
   1656e:	6923      	ldr	r3, [r4, #16]
	dst[1] = val;
   16570:	f88d 3012 	strb.w	r3, [sp, #18]
	dst[0] = val >> 16;
   16574:	0c19      	lsrs	r1, r3, #16
   16576:	f88d 1010 	strb.w	r1, [sp, #16]
	dst[0] = val >> 8;
   1657a:	f3c3 2107 	ubfx	r1, r3, #8, #8
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   1657e:	f8db 3000 	ldr.w	r3, [fp]
   16582:	f88d 1011 	strb.w	r1, [sp, #17]
   16586:	f002 0201 	and.w	r2, r2, #1
   1658a:	1a9a      	subs	r2, r3, r2
	buf = create_friend_pdu(frnd, &info, sbuf);
   1658c:	9916      	ldr	r1, [sp, #88]	; 0x58
	info.iv_index = BT_MESH_NET_IVI_RX(rx);
   1658e:	9205      	str	r2, [sp, #20]
	buf = create_friend_pdu(frnd, &info, sbuf);
   16590:	a803      	add	r0, sp, #12
   16592:	f7fe ffad 	bl	154f0 <create_friend_pdu.constprop.0>
	if (!buf) {
   16596:	b988      	cbnz	r0, 165bc <bt_mesh_friend_enqueue_rx+0xf8>
		BT_ERR("Failed to encode Friend buffer");
   16598:	4b0e      	ldr	r3, [pc, #56]	; (165d4 <bt_mesh_friend_enqueue_rx+0x110>)
   1659a:	930a      	str	r3, [sp, #40]	; 0x28
   1659c:	480e      	ldr	r0, [pc, #56]	; (165d8 <bt_mesh_friend_enqueue_rx+0x114>)
   1659e:	2302      	movs	r3, #2
   165a0:	aa09      	add	r2, sp, #36	; 0x24
   165a2:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   165a6:	9302      	str	r3, [sp, #8]
   165a8:	9309      	str	r3, [sp, #36]	; 0x24
   165aa:	f013 ff17 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   165ae:	37e8      	adds	r7, #232	; 0xe8
   165b0:	f5b7 7fe8 	cmp.w	r7, #464	; 0x1d0
   165b4:	d1a1      	bne.n	164fa <bt_mesh_friend_enqueue_rx+0x36>
		}

		friend_lpn_enqueue_rx(frnd, rx, type, seq_auth, seg_count,
				      sbuf);
	}
}
   165b6:	b00d      	add	sp, #52	; 0x34
   165b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	enqueue_friend_pdu(frnd, type, info.src, seg_count, buf);
   165bc:	9000      	str	r0, [sp, #0]
   165be:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   165c2:	464b      	mov	r3, r9
   165c4:	4641      	mov	r1, r8
   165c6:	4630      	mov	r0, r6
   165c8:	f7fe fee2 	bl	15390 <enqueue_friend_pdu>
	BT_DBG("Queued message for LPN 0x%04x, queue_size %u",
   165cc:	e7ef      	b.n	165ae <bt_mesh_friend_enqueue_rx+0xea>
   165ce:	bf00      	nop
   165d0:	20001ad0 	.word	0x20001ad0
   165d4:	000331de 	.word	0x000331de
   165d8:	0002db0c 	.word	0x0002db0c

000165dc <bt_mesh_friend_enqueue_tx>:

bool bt_mesh_friend_enqueue_tx(struct bt_mesh_net_tx *tx,
			       enum bt_mesh_friend_pdu_type type,
			       const uint64_t *seq_auth, uint8_t seg_count,
			       struct net_buf_simple *sbuf)
{
   165dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   165e0:	4617      	mov	r7, r2
   165e2:	469a      	mov	sl, r3
	bool matched = false;
	int i;

	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   165e4:	e9d0 3200 	ldrd	r3, r2, [r0]
{
   165e8:	b08f      	sub	sp, #60	; 0x3c
   165ea:	4604      	mov	r4, r0
   165ec:	460e      	mov	r6, r1
	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   165ee:	8b98      	ldrh	r0, [r3, #28]
   165f0:	8891      	ldrh	r1, [r2, #4]
   165f2:	f7ff ff1d 	bl	16430 <bt_mesh_friend_match>
   165f6:	b928      	cbnz	r0, 16604 <bt_mesh_friend_enqueue_tx+0x28>
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
		return matched;
   165f8:	f04f 0900 	mov.w	r9, #0
				      sbuf);
		matched = true;
	}

	return matched;
}
   165fc:	4648      	mov	r0, r9
   165fe:	b00f      	add	sp, #60	; 0x3c
   16600:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    bt_mesh_friend_get() != BT_MESH_FRIEND_ENABLED) {
   16604:	f7f5 fb78 	bl	bcf8 <bt_mesh_friend_get>
	if (!bt_mesh_friend_match(tx->sub->net_idx, tx->ctx->addr) ||
   16608:	2801      	cmp	r0, #1
   1660a:	d1f5      	bne.n	165f8 <bt_mesh_friend_enqueue_tx+0x1c>
	sys_put_be24(bt_mesh.seq, info.seq);
   1660c:	4b3a      	ldr	r3, [pc, #232]	; (166f8 <bt_mesh_friend_enqueue_tx+0x11c>)
   1660e:	2500      	movs	r5, #0
	bool matched = false;
   16610:	46a9      	mov	r9, r5
	sys_put_be24(bt_mesh.seq, info.seq);
   16612:	f1a3 0828 	sub.w	r8, r3, #40	; 0x28
		struct bt_mesh_friend *frnd = &bt_mesh.frnd[i];
   16616:	4b38      	ldr	r3, [pc, #224]	; (166f8 <bt_mesh_friend_enqueue_tx+0x11c>)
   16618:	eb03 0b05 	add.w	fp, r3, r5
		if (!friend_lpn_matches(frnd, tx->sub->net_idx,
   1661c:	e9d4 3200 	ldrd	r3, r2, [r4]
   16620:	4658      	mov	r0, fp
   16622:	8892      	ldrh	r2, [r2, #4]
   16624:	8b99      	ldrh	r1, [r3, #28]
   16626:	f013 fe9d 	bl	2a364 <friend_lpn_matches>
   1662a:	2800      	cmp	r0, #0
   1662c:	d04c      	beq.n	166c8 <bt_mesh_friend_enqueue_tx+0xec>
		if (!friend_queue_prepare_space(frnd, tx->src, seq_auth,
   1662e:	8921      	ldrh	r1, [r4, #8]
   16630:	4653      	mov	r3, sl
   16632:	463a      	mov	r2, r7
   16634:	4658      	mov	r0, fp
   16636:	f7fe ff0b 	bl	15450 <friend_queue_prepare_space>
   1663a:	9003      	str	r0, [sp, #12]
   1663c:	2800      	cmp	r0, #0
   1663e:	d043      	beq.n	166c8 <bt_mesh_friend_enqueue_tx+0xec>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && seq_auth) {
   16640:	b92e      	cbnz	r6, 1664e <bt_mesh_friend_enqueue_tx+0x72>
   16642:	b127      	cbz	r7, 1664e <bt_mesh_friend_enqueue_tx+0x72>
		friend_purge_old_ack(frnd, seq_auth, tx->src);
   16644:	8922      	ldrh	r2, [r4, #8]
   16646:	4639      	mov	r1, r7
   16648:	4658      	mov	r0, fp
   1664a:	f013 ff59 	bl	2a500 <friend_purge_old_ack>
	info.dst = tx->ctx->addr;
   1664e:	6861      	ldr	r1, [r4, #4]
	info.src = tx->src;
   16650:	8923      	ldrh	r3, [r4, #8]
   16652:	f8ad 3014 	strh.w	r3, [sp, #20]
	info.dst = tx->ctx->addr;
   16656:	888b      	ldrh	r3, [r1, #4]
   16658:	f8ad 3016 	strh.w	r3, [sp, #22]
	info.ctl = (tx->ctx->app_idx == BT_MESH_KEY_UNUSED);
   1665c:	884b      	ldrh	r3, [r1, #2]
   1665e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   16662:	1a9b      	subs	r3, r3, r2
   16664:	425a      	negs	r2, r3
   16666:	415a      	adcs	r2, r3
	info.ttl = tx->ctx->send_ttl;
   16668:	7acb      	ldrb	r3, [r1, #11]
   1666a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1666e:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   16672:	f88d 301b 	strb.w	r3, [sp, #27]
	sys_put_be24(bt_mesh.seq, info.seq);
   16676:	f8d8 3004 	ldr.w	r3, [r8, #4]
	dst[1] = val;
   1667a:	f88d 301a 	strb.w	r3, [sp, #26]
	dst[0] = val >> 16;
   1667e:	0c1a      	lsrs	r2, r3, #16
   16680:	f88d 2018 	strb.w	r2, [sp, #24]
	dst[0] = val >> 8;
   16684:	f3c3 2207 	ubfx	r2, r3, #8, #8
   16688:	f88d 2019 	strb.w	r2, [sp, #25]
   1668c:	4a1b      	ldr	r2, [pc, #108]	; (166fc <bt_mesh_friend_enqueue_tx+0x120>)
	info.iv_index = BT_MESH_NET_IVI_TX;
   1668e:	f8d8 3000 	ldr.w	r3, [r8]
   16692:	f3bf 8f5b 	dmb	ish
   16696:	6812      	ldr	r2, [r2, #0]
   16698:	f3bf 8f5b 	dmb	ish
   1669c:	f3c2 0280 	ubfx	r2, r2, #2, #1
   166a0:	1a9b      	subs	r3, r3, r2
	buf = create_friend_pdu(frnd, &info, sbuf);
   166a2:	9918      	ldr	r1, [sp, #96]	; 0x60
	info.iv_index = BT_MESH_NET_IVI_TX;
   166a4:	9307      	str	r3, [sp, #28]
	buf = create_friend_pdu(frnd, &info, sbuf);
   166a6:	a805      	add	r0, sp, #20
   166a8:	f7fe ff22 	bl	154f0 <create_friend_pdu.constprop.0>
	if (!buf) {
   166ac:	b988      	cbnz	r0, 166d2 <bt_mesh_friend_enqueue_tx+0xf6>
		BT_ERR("Failed to encode Friend buffer");
   166ae:	4b14      	ldr	r3, [pc, #80]	; (16700 <bt_mesh_friend_enqueue_tx+0x124>)
   166b0:	930c      	str	r3, [sp, #48]	; 0x30
   166b2:	4814      	ldr	r0, [pc, #80]	; (16704 <bt_mesh_friend_enqueue_tx+0x128>)
   166b4:	2302      	movs	r3, #2
   166b6:	aa0b      	add	r2, sp, #44	; 0x2c
   166b8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   166bc:	9304      	str	r3, [sp, #16]
   166be:	930b      	str	r3, [sp, #44]	; 0x2c
   166c0:	f013 fe8c 	bl	2a3dc <z_log_msg2_static_create.constprop.0>
		matched = true;
   166c4:	f8dd 900c 	ldr.w	r9, [sp, #12]
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   166c8:	35e8      	adds	r5, #232	; 0xe8
   166ca:	f5b5 7fe8 	cmp.w	r5, #464	; 0x1d0
   166ce:	d1a2      	bne.n	16616 <bt_mesh_friend_enqueue_tx+0x3a>
   166d0:	e794      	b.n	165fc <bt_mesh_friend_enqueue_tx+0x20>
	if (type == BT_MESH_FRIEND_PDU_SINGLE && !info.ctl) {
   166d2:	b93e      	cbnz	r6, 166e4 <bt_mesh_friend_enqueue_tx+0x108>
   166d4:	f99d 301b 	ldrsb.w	r3, [sp, #27]
   166d8:	2b00      	cmp	r3, #0
		FRIEND_ADV(buf)->app_idx = tx->ctx->app_idx;
   166da:	bfa1      	itttt	ge
   166dc:	6862      	ldrge	r2, [r4, #4]
   166de:	6943      	ldrge	r3, [r0, #20]
   166e0:	8852      	ldrhge	r2, [r2, #2]
   166e2:	801a      	strhge	r2, [r3, #0]
	enqueue_friend_pdu(frnd, type, info.src, seg_count, buf);
   166e4:	9000      	str	r0, [sp, #0]
   166e6:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   166ea:	4653      	mov	r3, sl
   166ec:	4631      	mov	r1, r6
   166ee:	4658      	mov	r0, fp
   166f0:	f7fe fe4e 	bl	15390 <enqueue_friend_pdu>
   166f4:	e7e6      	b.n	166c4 <bt_mesh_friend_enqueue_tx+0xe8>
   166f6:	bf00      	nop
   166f8:	20001ad0 	.word	0x20001ad0
   166fc:	20001ab0 	.word	0x20001ab0
   16700:	000331de 	.word	0x000331de
   16704:	0002db0c 	.word	0x0002db0c

00016708 <bt_mesh_friend_clear_incomplete>:
	return 0;
}

void bt_mesh_friend_clear_incomplete(struct bt_mesh_subnet *sub, uint16_t src,
				     uint16_t dst, uint64_t *seq_auth)
{
   16708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1670c:	b08b      	sub	sp, #44	; 0x2c
   1670e:	4c1d      	ldr	r4, [pc, #116]	; (16784 <bt_mesh_friend_clear_incomplete+0x7c>)

			if (!is_seg(seg, src, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
				continue;
			}

			BT_WARN("Clearing incomplete segments for 0x%04x", src);
   16710:	f8df b074 	ldr.w	fp, [pc, #116]	; 16788 <bt_mesh_friend_clear_incomplete+0x80>
{
   16714:	9301      	str	r3, [sp, #4]
   16716:	4682      	mov	sl, r0
   16718:	460d      	mov	r5, r1
   1671a:	4616      	mov	r6, r2
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   1671c:	f04f 0800 	mov.w	r8, #0
			BT_WARN("Clearing incomplete segments for 0x%04x", src);
   16720:	f04f 0903 	mov.w	r9, #3
		if (!friend_lpn_matches(frnd, sub->net_idx, dst)) {
   16724:	f8ba 101c 	ldrh.w	r1, [sl, #28]
   16728:	4632      	mov	r2, r6
   1672a:	4620      	mov	r0, r4
   1672c:	f013 fe1a 	bl	2a364 <friend_lpn_matches>
   16730:	b1e8      	cbz	r0, 1676e <bt_mesh_friend_clear_incomplete+0x66>
			if (!is_seg(seg, src, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   16732:	9b01      	ldr	r3, [sp, #4]
   16734:	881a      	ldrh	r2, [r3, #0]
   16736:	f104 0790 	add.w	r7, r4, #144	; 0x90
   1673a:	f3c2 020c 	ubfx	r2, r2, #0, #13
   1673e:	4629      	mov	r1, r5
   16740:	4638      	mov	r0, r7
   16742:	f013 fe97 	bl	2a474 <is_seg>
   16746:	b190      	cbz	r0, 1676e <bt_mesh_friend_clear_incomplete+0x66>
			BT_WARN("Clearing incomplete segments for 0x%04x", src);
   16748:	4b10      	ldr	r3, [pc, #64]	; (1678c <bt_mesh_friend_clear_incomplete+0x84>)
   1674a:	f8cd 900c 	str.w	r9, [sp, #12]
   1674e:	aa07      	add	r2, sp, #28
   16750:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   16754:	4658      	mov	r0, fp
   16756:	e9cd 3508 	strd	r3, r5, [sp, #32]
   1675a:	f8cd 901c 	str.w	r9, [sp, #28]
   1675e:	f013 fe3d 	bl	2a3dc <z_log_msg2_static_create.constprop.0>

			purge_buffers(&seg->queue);
   16762:	4638      	mov	r0, r7
   16764:	f013 fe50 	bl	2a408 <purge_buffers>
			seg->seg_count = 0U;
   16768:	2300      	movs	r3, #0
   1676a:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
	for (i = 0; i < ARRAY_SIZE(bt_mesh.frnd); i++) {
   1676e:	34e8      	adds	r4, #232	; 0xe8
   16770:	f1b8 0f00 	cmp.w	r8, #0
   16774:	d002      	beq.n	1677c <bt_mesh_friend_clear_incomplete+0x74>
			break;
		}
	}
}
   16776:	b00b      	add	sp, #44	; 0x2c
   16778:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1677c:	f04f 0801 	mov.w	r8, #1
   16780:	e7d0      	b.n	16724 <bt_mesh_friend_clear_incomplete+0x1c>
   16782:	bf00      	nop
   16784:	20001ad0 	.word	0x20001ad0
   16788:	0002db0c 	.word	0x0002db0c
   1678c:	000331fd 	.word	0x000331fd

00016790 <prov_link_closed>:
static void prov_link_closed(const struct prov_bearer *bearer, void *cb_data,
			     enum prov_bearer_link_status reason)
{
	BT_DBG("%u", reason);

	if (bt_mesh_prov_link.role->link_closed) {
   16790:	4b07      	ldr	r3, [pc, #28]	; (167b0 <prov_link_closed+0x20>)
   16792:	689b      	ldr	r3, [r3, #8]
   16794:	685b      	ldr	r3, [r3, #4]
{
   16796:	b510      	push	{r4, lr}
   16798:	4604      	mov	r4, r0
	if (bt_mesh_prov_link.role->link_closed) {
   1679a:	b103      	cbz	r3, 1679e <prov_link_closed+0xe>
		bt_mesh_prov_link.role->link_closed();
   1679c:	4798      	blx	r3
	}

	if (bt_mesh_prov->link_close) {
   1679e:	4b05      	ldr	r3, [pc, #20]	; (167b4 <prov_link_closed+0x24>)
   167a0:	681b      	ldr	r3, [r3, #0]
   167a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   167a4:	b11b      	cbz	r3, 167ae <prov_link_closed+0x1e>
		bt_mesh_prov->link_close(bearer->type);
   167a6:	7820      	ldrb	r0, [r4, #0]
	}
}
   167a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_prov->link_close(bearer->type);
   167ac:	4718      	bx	r3
}
   167ae:	bd10      	pop	{r4, pc}
   167b0:	20002794 	.word	0x20002794
   167b4:	20002790 	.word	0x20002790

000167b8 <prov_bearer_error>:

static void prov_bearer_error(const struct prov_bearer *bearer, void *cb_data,
			      uint8_t err)
{
	if (bt_mesh_prov_link.role->error) {
   167b8:	4b03      	ldr	r3, [pc, #12]	; (167c8 <prov_bearer_error+0x10>)
   167ba:	689b      	ldr	r3, [r3, #8]
   167bc:	689b      	ldr	r3, [r3, #8]
{
   167be:	4610      	mov	r0, r2
	if (bt_mesh_prov_link.role->error) {
   167c0:	b103      	cbz	r3, 167c4 <prov_bearer_error+0xc>
		bt_mesh_prov_link.role->error(err);
   167c2:	4718      	bx	r3
	}
}
   167c4:	4770      	bx	lr
   167c6:	bf00      	nop
   167c8:	20002794 	.word	0x20002794

000167cc <get_auth_string>:
{
   167cc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   167d0:	4607      	mov	r7, r0
   167d2:	460c      	mov	r4, r1
	bt_rand(&value, sizeof(value));
   167d4:	4668      	mov	r0, sp
   167d6:	2108      	movs	r1, #8
   167d8:	f014 fb97 	bl	2af0a <bt_rand>
	for (int i = 0; i < size; i++) {
   167dc:	e9dd 6500 	ldrd	r6, r5, [sp]
   167e0:	2300      	movs	r3, #0
		str[i] = characters[idx];
   167e2:	f8df a060 	ldr.w	sl, [pc, #96]	; 16844 <get_auth_string+0x78>
	for (int i = 0; i < size; i++) {
   167e6:	4698      	mov	r8, r3
   167e8:	4544      	cmp	r4, r8
   167ea:	dc13      	bgt.n	16814 <get_auth_string+0x48>
   167ec:	b10b      	cbz	r3, 167f2 <get_auth_string+0x26>
   167ee:	e9cd 6500 	strd	r6, r5, [sp]
	memcpy(bt_mesh_prov_link.auth, str, size);
   167f2:	4d15      	ldr	r5, [pc, #84]	; (16848 <get_auth_string+0x7c>)
	str[size] = '\0';
   167f4:	2600      	movs	r6, #0
	memcpy(bt_mesh_prov_link.auth, str, size);
   167f6:	4622      	mov	r2, r4
   167f8:	4639      	mov	r1, r7
	str[size] = '\0';
   167fa:	553e      	strb	r6, [r7, r4]
	memcpy(bt_mesh_prov_link.auth, str, size);
   167fc:	4628      	mov	r0, r5
   167fe:	f011 f837 	bl	27870 <memcpy>
	memset(bt_mesh_prov_link.auth + size, 0,
   16802:	f1c4 0210 	rsb	r2, r4, #16
   16806:	4631      	mov	r1, r6
   16808:	1928      	adds	r0, r5, r4
   1680a:	f011 f83c 	bl	27886 <memset>
}
   1680e:	b002      	add	sp, #8
   16810:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		int idx = value % 36;
   16814:	4630      	mov	r0, r6
   16816:	4629      	mov	r1, r5
   16818:	2224      	movs	r2, #36	; 0x24
   1681a:	2300      	movs	r3, #0
   1681c:	f7e9 fc60 	bl	e0 <__aeabi_uldivmod>
		value = value / 36;
   16820:	2300      	movs	r3, #0
		int idx = value % 36;
   16822:	4691      	mov	r9, r2
		value = value / 36;
   16824:	4630      	mov	r0, r6
   16826:	4629      	mov	r1, r5
   16828:	2224      	movs	r2, #36	; 0x24
   1682a:	f7e9 fc59 	bl	e0 <__aeabi_uldivmod>
		str[i] = characters[idx];
   1682e:	f81a 3009 	ldrb.w	r3, [sl, r9]
   16832:	f807 3008 	strb.w	r3, [r7, r8]
		value = value / 36;
   16836:	4606      	mov	r6, r0
   16838:	460d      	mov	r5, r1
	for (int i = 0; i < size; i++) {
   1683a:	f108 0801 	add.w	r8, r8, #1
   1683e:	2301      	movs	r3, #1
   16840:	e7d2      	b.n	167e8 <get_auth_string+0x1c>
   16842:	bf00      	nop
   16844:	00033312 	.word	0x00033312
   16848:	200027a3 	.word	0x200027a3

0001684c <get_auth_number>:
{
   1684c:	b5f0      	push	{r4, r5, r6, r7, lr}
	const uint32_t divider[PROV_IO_OOB_SIZE_MAX] = { 10, 100, 1000, 10000,
   1684e:	f8df c08c 	ldr.w	ip, [pc, #140]	; 168dc <get_auth_number+0x90>
{
   16852:	4607      	mov	r7, r0
   16854:	4614      	mov	r4, r2
   16856:	460e      	mov	r6, r1
	const uint32_t divider[PROV_IO_OOB_SIZE_MAX] = { 10, 100, 1000, 10000,
   16858:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
{
   1685c:	b08b      	sub	sp, #44	; 0x2c
	const uint32_t divider[PROV_IO_OOB_SIZE_MAX] = { 10, 100, 1000, 10000,
   1685e:	ad02      	add	r5, sp, #8
   16860:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   16862:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
   16866:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	bt_rand(&num, sizeof(num));
   1686a:	2104      	movs	r1, #4
	uint32_t num = 0;
   1686c:	2300      	movs	r3, #0
	bt_rand(&num, sizeof(num));
   1686e:	eb0d 0001 	add.w	r0, sp, r1
	uint32_t num = 0;
   16872:	9301      	str	r3, [sp, #4]
	bt_rand(&num, sizeof(num));
   16874:	f014 fb49 	bl	2af0a <bt_rand>
	if (output == BT_MESH_BLINK ||
   16878:	1e7b      	subs	r3, r7, #1
		num %= divider[size - 1];
   1687a:	1e62      	subs	r2, r4, #1
	if (output == BT_MESH_BLINK ||
   1687c:	2b01      	cmp	r3, #1
   1687e:	ea4f 0282 	mov.w	r2, r2, lsl #2
   16882:	9b01      	ldr	r3, [sp, #4]
   16884:	d908      	bls.n	16898 <get_auth_number+0x4c>
		num %= divider[size - 1];
   16886:	a90a      	add	r1, sp, #40	; 0x28
   16888:	4411      	add	r1, r2
	    output == BT_MESH_BEEP ||
   1688a:	2f04      	cmp	r7, #4
		num %= divider[size - 1];
   1688c:	f851 1c20 	ldr.w	r1, [r1, #-32]
	    output == BT_MESH_BEEP ||
   16890:	d002      	beq.n	16898 <get_auth_number+0x4c>
	    output == BT_MESH_VIBRATE ||
   16892:	3e01      	subs	r6, #1
   16894:	2e01      	cmp	r6, #1
   16896:	d81b      	bhi.n	168d0 <get_auth_number+0x84>
		num = (num % (divider[size - 1] - 1)) + 1;
   16898:	a90a      	add	r1, sp, #40	; 0x28
   1689a:	440a      	add	r2, r1
   1689c:	f852 2c20 	ldr.w	r2, [r2, #-32]
   168a0:	3a01      	subs	r2, #1
   168a2:	fbb3 f1f2 	udiv	r1, r3, r2
   168a6:	fb02 3311 	mls	r3, r2, r1, r3
   168aa:	3301      	adds	r3, #1
   168ac:	480c      	ldr	r0, [pc, #48]	; (168e0 <get_auth_number+0x94>)
   168ae:	9301      	str	r3, [sp, #4]
	sys_put_be16(val >> 16, dst);
   168b0:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val >> 8;
   168b2:	0e19      	lsrs	r1, r3, #24
	dst[1] = val;
   168b4:	7702      	strb	r2, [r0, #28]
	dst[0] = val >> 8;
   168b6:	f3c3 2207 	ubfx	r2, r3, #8, #8
   168ba:	76c1      	strb	r1, [r0, #27]
   168bc:	7742      	strb	r2, [r0, #29]
	dst[1] = val;
   168be:	7783      	strb	r3, [r0, #30]
	memset(bt_mesh_prov_link.auth, 0, 12);
   168c0:	220c      	movs	r2, #12
   168c2:	2100      	movs	r1, #0
   168c4:	300f      	adds	r0, #15
   168c6:	f010 ffde 	bl	27886 <memset>
}
   168ca:	9801      	ldr	r0, [sp, #4]
   168cc:	b00b      	add	sp, #44	; 0x2c
   168ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		num %= divider[size - 1];
   168d0:	fbb3 f2f1 	udiv	r2, r3, r1
   168d4:	fb01 3312 	mls	r3, r1, r2, r3
   168d8:	e7e8      	b.n	168ac <get_auth_number+0x60>
   168da:	bf00      	nop
   168dc:	0002dd28 	.word	0x0002dd28
   168e0:	20002794 	.word	0x20002794

000168e4 <atomic_or.constprop.0.isra.0>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   168e4:	4b06      	ldr	r3, [pc, #24]	; (16900 <atomic_or.constprop.0.isra.0+0x1c>)
   168e6:	f3bf 8f5b 	dmb	ish
   168ea:	e853 2f00 	ldrex	r2, [r3]
   168ee:	4302      	orrs	r2, r0
   168f0:	e843 2100 	strex	r1, r2, [r3]
   168f4:	2900      	cmp	r1, #0
   168f6:	d1f8      	bne.n	168ea <atomic_or.constprop.0.isra.0+0x6>
   168f8:	f3bf 8f5b 	dmb	ish
}
   168fc:	4770      	bx	lr
   168fe:	bf00      	nop
   16900:	20002794 	.word	0x20002794

00016904 <prov_link_opened>:
{
   16904:	b510      	push	{r4, lr}
   16906:	4604      	mov	r4, r0
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   16908:	2002      	movs	r0, #2
   1690a:	f7ff ffeb 	bl	168e4 <atomic_or.constprop.0.isra.0>
	if (bt_mesh_prov->link_open) {
   1690e:	4b07      	ldr	r3, [pc, #28]	; (1692c <prov_link_opened+0x28>)
   16910:	681b      	ldr	r3, [r3, #0]
   16912:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   16914:	b10b      	cbz	r3, 1691a <prov_link_opened+0x16>
		bt_mesh_prov->link_open(bearer->type);
   16916:	7820      	ldrb	r0, [r4, #0]
   16918:	4798      	blx	r3
	bt_mesh_prov_link.bearer = bearer;
   1691a:	4b05      	ldr	r3, [pc, #20]	; (16930 <prov_link_opened+0x2c>)
   1691c:	605c      	str	r4, [r3, #4]
	if (bt_mesh_prov_link.role->link_opened) {
   1691e:	689b      	ldr	r3, [r3, #8]
   16920:	681b      	ldr	r3, [r3, #0]
   16922:	b113      	cbz	r3, 1692a <prov_link_opened+0x26>
}
   16924:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_prov_link.role->link_opened();
   16928:	4718      	bx	r3
}
   1692a:	bd10      	pop	{r4, pc}
   1692c:	20002790 	.word	0x20002790
   16930:	20002794 	.word	0x20002794

00016934 <pub_key_ready>:
{
   16934:	b500      	push	{lr}
	if (!pkey) {
   16936:	4603      	mov	r3, r0
{
   16938:	b089      	sub	sp, #36	; 0x24
	if (!pkey) {
   1693a:	b950      	cbnz	r0, 16952 <pub_key_ready+0x1e>
		BT_WARN("Public key not available");
   1693c:	4a06      	ldr	r2, [pc, #24]	; (16958 <pub_key_ready+0x24>)
   1693e:	9206      	str	r2, [sp, #24]
   16940:	2202      	movs	r2, #2
   16942:	9201      	str	r2, [sp, #4]
   16944:	9205      	str	r2, [sp, #20]
   16946:	4805      	ldr	r0, [pc, #20]	; (1695c <pub_key_ready+0x28>)
   16948:	aa05      	add	r2, sp, #20
   1694a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1694e:	f00f f9c3 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   16952:	b009      	add	sp, #36	; 0x24
   16954:	f85d fb04 	ldr.w	pc, [sp], #4
   16958:	00033238 	.word	0x00033238
   1695c:	0002db64 	.word	0x0002db64

00016960 <prov_recv>:
{
   16960:	b5f0      	push	{r4, r5, r6, r7, lr}
   16962:	b089      	sub	sp, #36	; 0x24
	uint8_t type = buf->data[0];
   16964:	6810      	ldr	r0, [r2, #0]
   16966:	4c2d      	ldr	r4, [pc, #180]	; (16a1c <prov_recv+0xbc>)
   16968:	7803      	ldrb	r3, [r0, #0]
	if (type >= ARRAY_SIZE(bt_mesh_prov_link.role->op)) {
   1696a:	2b09      	cmp	r3, #9
{
   1696c:	af00      	add	r7, sp, #0
	if (type >= ARRAY_SIZE(bt_mesh_prov_link.role->op)) {
   1696e:	d914      	bls.n	1699a <prov_recv+0x3a>
		BT_ERR("Unknown provisioning PDU type 0x%02x", type);
   16970:	4a2b      	ldr	r2, [pc, #172]	; (16a20 <prov_recv+0xc0>)
   16972:	e9c7 2306 	strd	r2, r3, [r7, #24]
   16976:	2303      	movs	r3, #3
   16978:	607b      	str	r3, [r7, #4]
   1697a:	617b      	str	r3, [r7, #20]
   1697c:	4829      	ldr	r0, [pc, #164]	; (16a24 <prov_recv+0xc4>)
   1697e:	2300      	movs	r3, #0
   16980:	f107 0214 	add.w	r2, r7, #20
   16984:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   16988:	f00f f9a6 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		bt_mesh_prov_link.role->error(PROV_ERR_NVAL_PDU);
   1698c:	68a3      	ldr	r3, [r4, #8]
   1698e:	689b      	ldr	r3, [r3, #8]
   16990:	2001      	movs	r0, #1
		bt_mesh_prov_link.role->error(PROV_ERR_NVAL_FMT);
   16992:	4798      	blx	r3
}
   16994:	3724      	adds	r7, #36	; 0x24
   16996:	46bd      	mov	sp, r7
   16998:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((type != PROV_FAILED && type != bt_mesh_prov_link.expect) ||
   1699a:	d003      	beq.n	169a4 <prov_recv+0x44>
   1699c:	f894 103f 	ldrb.w	r1, [r4, #63]	; 0x3f
   169a0:	4299      	cmp	r1, r3
   169a2:	d104      	bne.n	169ae <prov_recv+0x4e>
	    !bt_mesh_prov_link.role->op[type]) {
   169a4:	68a1      	ldr	r1, [r4, #8]
   169a6:	1d1d      	adds	r5, r3, #4
   169a8:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
	if ((type != PROV_FAILED && type != bt_mesh_prov_link.expect) ||
   169ac:	b9b9      	cbnz	r1, 169de <prov_recv+0x7e>
		BT_WARN("Unexpected msg 0x%02x != 0x%02x", type, bt_mesh_prov_link.expect);
   169ae:	481e      	ldr	r0, [pc, #120]	; (16a28 <prov_recv+0xc8>)
   169b0:	f894 103f 	ldrb.w	r1, [r4, #63]	; 0x3f
   169b4:	466d      	mov	r5, sp
   169b6:	b088      	sub	sp, #32
   169b8:	466a      	mov	r2, sp
   169ba:	e9c2 0304 	strd	r0, r3, [r2, #16]
   169be:	2304      	movs	r3, #4
   169c0:	6191      	str	r1, [r2, #24]
   169c2:	60bb      	str	r3, [r7, #8]
   169c4:	f842 3f0c 	str.w	r3, [r2, #12]!
   169c8:	4816      	ldr	r0, [pc, #88]	; (16a24 <prov_recv+0xc4>)
   169ca:	2300      	movs	r3, #0
   169cc:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   169d0:	f00f f982 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		bt_mesh_prov_link.role->error(PROV_ERR_UNEXP_PDU);
   169d4:	68a3      	ldr	r3, [r4, #8]
   169d6:	46ad      	mov	sp, r5
   169d8:	689b      	ldr	r3, [r3, #8]
   169da:	2003      	movs	r0, #3
   169dc:	e7d9      	b.n	16992 <prov_recv+0x32>
	if (1 + op_len[type] != buf->len) {
   169de:	8895      	ldrh	r5, [r2, #4]
   169e0:	4a12      	ldr	r2, [pc, #72]	; (16a2c <prov_recv+0xcc>)
   169e2:	5cd2      	ldrb	r2, [r2, r3]
   169e4:	3201      	adds	r2, #1
   169e6:	42aa      	cmp	r2, r5
   169e8:	d015      	beq.n	16a16 <prov_recv+0xb6>
		BT_ERR("Invalid length %u for type 0x%02x", buf->len, type);
   169ea:	466e      	mov	r6, sp
   169ec:	b088      	sub	sp, #32
   169ee:	466a      	mov	r2, sp
   169f0:	490f      	ldr	r1, [pc, #60]	; (16a30 <prov_recv+0xd0>)
   169f2:	6193      	str	r3, [r2, #24]
   169f4:	2304      	movs	r3, #4
   169f6:	e9c2 1504 	strd	r1, r5, [r2, #16]
   169fa:	60bb      	str	r3, [r7, #8]
   169fc:	f842 3f0c 	str.w	r3, [r2, #12]!
   16a00:	4808      	ldr	r0, [pc, #32]	; (16a24 <prov_recv+0xc4>)
   16a02:	2300      	movs	r3, #0
   16a04:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   16a08:	f00f f966 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		bt_mesh_prov_link.role->error(PROV_ERR_NVAL_FMT);
   16a0c:	68a3      	ldr	r3, [r4, #8]
   16a0e:	46b5      	mov	sp, r6
   16a10:	689b      	ldr	r3, [r3, #8]
   16a12:	2002      	movs	r0, #2
   16a14:	e7bd      	b.n	16992 <prov_recv+0x32>
	bt_mesh_prov_link.role->op[type](&buf->data[1]);
   16a16:	3001      	adds	r0, #1
   16a18:	4788      	blx	r1
   16a1a:	e7bb      	b.n	16994 <prov_recv+0x34>
   16a1c:	20002794 	.word	0x20002794
   16a20:	00033251 	.word	0x00033251
   16a24:	0002db64 	.word	0x0002db64
   16a28:	00033276 	.word	0x00033276
   16a2c:	00033336 	.word	0x00033336
   16a30:	00033296 	.word	0x00033296

00016a34 <bt_mesh_prov_reset_state>:
{
   16a34:	b530      	push	{r4, r5, lr}
	pub_key_cb.func = func ? func : pub_key_ready;
   16a36:	4b1a      	ldr	r3, [pc, #104]	; (16aa0 <bt_mesh_prov_reset_state+0x6c>)
   16a38:	4a1a      	ldr	r2, [pc, #104]	; (16aa4 <bt_mesh_prov_reset_state+0x70>)
	if (bt_mesh_prov_link.conf_inputs.invite[0]) {
   16a3a:	4c1b      	ldr	r4, [pc, #108]	; (16aa8 <bt_mesh_prov_reset_state+0x74>)
	pub_key_cb.func = func ? func : pub_key_ready;
   16a3c:	2800      	cmp	r0, #0
   16a3e:	bf18      	it	ne
   16a40:	4603      	movne	r3, r0
   16a42:	6013      	str	r3, [r2, #0]
	if (bt_mesh_prov_link.conf_inputs.invite[0]) {
   16a44:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
{
   16a48:	b089      	sub	sp, #36	; 0x24
	if (bt_mesh_prov_link.conf_inputs.invite[0]) {
   16a4a:	b11b      	cbz	r3, 16a54 <bt_mesh_prov_reset_state+0x20>
		bt_mesh_attention(NULL, 0);
   16a4c:	2100      	movs	r1, #0
   16a4e:	4608      	mov	r0, r1
   16a50:	f7fe f966 	bl	14d20 <bt_mesh_attention>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   16a54:	f3bf 8f5b 	dmb	ish
   16a58:	2500      	movs	r5, #0
   16a5a:	e854 3f00 	ldrex	r3, [r4]
   16a5e:	e844 5200 	strex	r2, r5, [r4]
   16a62:	2a00      	cmp	r2, #0
   16a64:	d1f9      	bne.n	16a5a <bt_mesh_prov_reset_state+0x26>
   16a66:	f3bf 8f5b 	dmb	ish
	(void)memset((uint8_t *)&bt_mesh_prov_link + offset, 0,
   16a6a:	f240 1215 	movw	r2, #277	; 0x115
   16a6e:	4629      	mov	r1, r5
   16a70:	480e      	ldr	r0, [pc, #56]	; (16aac <bt_mesh_prov_reset_state+0x78>)
   16a72:	f010 ff08 	bl	27886 <memset>
	err = bt_pub_key_gen(&pub_key_cb);
   16a76:	480b      	ldr	r0, [pc, #44]	; (16aa4 <bt_mesh_prov_reset_state+0x70>)
   16a78:	f7f1 fa66 	bl	7f48 <bt_pub_key_gen>
	if (err) {
   16a7c:	4604      	mov	r4, r0
   16a7e:	b160      	cbz	r0, 16a9a <bt_mesh_prov_reset_state+0x66>
		BT_ERR("Failed to generate public key (%d)", err);
   16a80:	4b0b      	ldr	r3, [pc, #44]	; (16ab0 <bt_mesh_prov_reset_state+0x7c>)
   16a82:	e9cd 3006 	strd	r3, r0, [sp, #24]
   16a86:	2303      	movs	r3, #3
   16a88:	9301      	str	r3, [sp, #4]
   16a8a:	9305      	str	r3, [sp, #20]
   16a8c:	4809      	ldr	r0, [pc, #36]	; (16ab4 <bt_mesh_prov_reset_state+0x80>)
   16a8e:	462b      	mov	r3, r5
   16a90:	aa05      	add	r2, sp, #20
   16a92:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   16a96:	f00f f91f 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   16a9a:	4620      	mov	r0, r4
   16a9c:	b009      	add	sp, #36	; 0x24
   16a9e:	bd30      	pop	{r4, r5, pc}
   16aa0:	00016935 	.word	0x00016935
   16aa4:	200028b8 	.word	0x200028b8
   16aa8:	20002794 	.word	0x20002794
   16aac:	200027a3 	.word	0x200027a3
   16ab0:	000332b8 	.word	0x000332b8
   16ab4:	0002db64 	.word	0x0002db64

00016ab8 <bt_mesh_prov_auth>:
{
   16ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
   16aba:	4606      	mov	r6, r0
   16abc:	b085      	sub	sp, #20
   16abe:	4614      	mov	r4, r2
   16ac0:	461d      	mov	r5, r3
	switch (method) {
   16ac2:	2903      	cmp	r1, #3
   16ac4:	d878      	bhi.n	16bb8 <bt_mesh_prov_auth+0x100>
   16ac6:	e8df f001 	tbb	[pc, r1]
   16aca:	0c02      	.short	0x0c02
   16acc:	5013      	.short	0x5013
		if (action || size) {
   16ace:	432c      	orrs	r4, r5
   16ad0:	d172      	bne.n	16bb8 <bt_mesh_prov_auth+0x100>
		(void)memset(bt_mesh_prov_link.auth, 0, sizeof(bt_mesh_prov_link.auth));
   16ad2:	4844      	ldr	r0, [pc, #272]	; (16be4 <bt_mesh_prov_auth+0x12c>)
   16ad4:	2210      	movs	r2, #16
   16ad6:	4621      	mov	r1, r4
   16ad8:	f010 fed5 	bl	27886 <memset>
		return 0;
   16adc:	4620      	mov	r0, r4
}
   16ade:	b005      	add	sp, #20
   16ae0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (action || size) {
   16ae2:	432c      	orrs	r4, r5
   16ae4:	d168      	bne.n	16bb8 <bt_mesh_prov_auth+0x100>
   16ae6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   16aea:	f7ff fefb 	bl	168e4 <atomic_or.constprop.0.isra.0>
   16aee:	e7f5      	b.n	16adc <bt_mesh_prov_auth+0x24>
	switch (action) {
   16af0:	2a04      	cmp	r2, #4
   16af2:	d85f      	bhi.n	16bb4 <bt_mesh_prov_auth+0xfc>
   16af4:	4b3c      	ldr	r3, [pc, #240]	; (16be8 <bt_mesh_prov_auth+0x130>)
   16af6:	5c9c      	ldrb	r4, [r3, r2]
		if (is_provisioner) {
   16af8:	b170      	cbz	r0, 16b18 <bt_mesh_prov_auth+0x60>
			if (output == BT_MESH_DISPLAY_STRING) {
   16afa:	2c10      	cmp	r4, #16
   16afc:	d10a      	bne.n	16b14 <bt_mesh_prov_auth+0x5c>
   16afe:	2008      	movs	r0, #8
   16b00:	f7ff fef0 	bl	168e4 <atomic_or.constprop.0.isra.0>
			return bt_mesh_prov->input(input, size);
   16b04:	4b39      	ldr	r3, [pc, #228]	; (16bec <bt_mesh_prov_auth+0x134>)
   16b06:	681b      	ldr	r3, [r3, #0]
   16b08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16b0a:	4629      	mov	r1, r5
}
   16b0c:	b005      	add	sp, #20
   16b0e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			return bt_mesh_prov->input(input, size);
   16b12:	4718      	bx	r3
   16b14:	2004      	movs	r0, #4
   16b16:	e7f3      	b.n	16b00 <bt_mesh_prov_auth+0x48>
	if (!output) {
   16b18:	2c00      	cmp	r4, #0
   16b1a:	d04d      	beq.n	16bb8 <bt_mesh_prov_auth+0x100>
	if (!(bt_mesh_prov->output_actions & output)) {
   16b1c:	4f33      	ldr	r7, [pc, #204]	; (16bec <bt_mesh_prov_auth+0x134>)
   16b1e:	683b      	ldr	r3, [r7, #0]
   16b20:	8b5a      	ldrh	r2, [r3, #26]
   16b22:	4222      	tst	r2, r4
   16b24:	d048      	beq.n	16bb8 <bt_mesh_prov_auth+0x100>
	if (size > bt_mesh_prov->output_size) {
   16b26:	7e5b      	ldrb	r3, [r3, #25]
   16b28:	42ab      	cmp	r3, r5
   16b2a:	d345      	bcc.n	16bb8 <bt_mesh_prov_auth+0x100>
		if (output == BT_MESH_DISPLAY_STRING) {
   16b2c:	2c10      	cmp	r4, #16
   16b2e:	d10b      	bne.n	16b48 <bt_mesh_prov_auth+0x90>
   16b30:	4620      	mov	r0, r4
   16b32:	f7ff fed7 	bl	168e4 <atomic_or.constprop.0.isra.0>
			get_auth_string(str, size);
   16b36:	4629      	mov	r1, r5
   16b38:	a801      	add	r0, sp, #4
   16b3a:	f7ff fe47 	bl	167cc <get_auth_string>
			return bt_mesh_prov->output_string(str);
   16b3e:	683b      	ldr	r3, [r7, #0]
			return bt_mesh_prov->output_string(str);
   16b40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   16b42:	a801      	add	r0, sp, #4
   16b44:	4798      	blx	r3
   16b46:	e7ca      	b.n	16ade <bt_mesh_prov_auth+0x26>
   16b48:	2010      	movs	r0, #16
   16b4a:	f7ff fecb 	bl	168e4 <atomic_or.constprop.0.isra.0>
		return bt_mesh_prov->output_number(output,
   16b4e:	683b      	ldr	r3, [r7, #0]
   16b50:	4631      	mov	r1, r6
   16b52:	462a      	mov	r2, r5
   16b54:	4620      	mov	r0, r4
   16b56:	6a5f      	ldr	r7, [r3, #36]	; 0x24
   16b58:	f7ff fe78 	bl	1684c <get_auth_number>
   16b5c:	463b      	mov	r3, r7
   16b5e:	4601      	mov	r1, r0
   16b60:	4620      	mov	r0, r4
}
   16b62:	b005      	add	sp, #20
   16b64:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return bt_mesh_prov->output_number(output,
   16b68:	4718      	bx	r3
	switch (action) {
   16b6a:	2a03      	cmp	r2, #3
   16b6c:	d827      	bhi.n	16bbe <bt_mesh_prov_auth+0x106>
   16b6e:	4b20      	ldr	r3, [pc, #128]	; (16bf0 <bt_mesh_prov_auth+0x138>)
   16b70:	5c9c      	ldrb	r4, [r3, r2]
		if (!is_provisioner) {
   16b72:	b998      	cbnz	r0, 16b9c <bt_mesh_prov_auth+0xe4>
	if (!input) {
   16b74:	b304      	cbz	r4, 16bb8 <bt_mesh_prov_auth+0x100>
	if (!(bt_mesh_prov->input_actions & input)) {
   16b76:	4e1d      	ldr	r6, [pc, #116]	; (16bec <bt_mesh_prov_auth+0x134>)
   16b78:	6833      	ldr	r3, [r6, #0]
   16b7a:	8bda      	ldrh	r2, [r3, #30]
   16b7c:	4222      	tst	r2, r4
   16b7e:	d01b      	beq.n	16bb8 <bt_mesh_prov_auth+0x100>
	if (size > bt_mesh_prov->input_size) {
   16b80:	7f1b      	ldrb	r3, [r3, #28]
   16b82:	42ab      	cmp	r3, r5
   16b84:	d318      	bcc.n	16bb8 <bt_mesh_prov_auth+0x100>
			if (input == BT_MESH_ENTER_STRING) {
   16b86:	2c08      	cmp	r4, #8
   16b88:	bf0c      	ite	eq
   16b8a:	4620      	moveq	r0, r4
   16b8c:	2004      	movne	r0, #4
   16b8e:	f7ff fea9 	bl	168e4 <atomic_or.constprop.0.isra.0>
			return bt_mesh_prov->input(input, size);
   16b92:	6833      	ldr	r3, [r6, #0]
   16b94:	4629      	mov	r1, r5
   16b96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16b98:	4620      	mov	r0, r4
   16b9a:	e7b7      	b.n	16b0c <bt_mesh_prov_auth+0x54>
		if (input == BT_MESH_ENTER_STRING) {
   16b9c:	2c08      	cmp	r4, #8
   16b9e:	d111      	bne.n	16bc4 <bt_mesh_prov_auth+0x10c>
   16ba0:	2010      	movs	r0, #16
   16ba2:	f7ff fe9f 	bl	168e4 <atomic_or.constprop.0.isra.0>
			get_auth_string(str, size);
   16ba6:	4629      	mov	r1, r5
   16ba8:	a801      	add	r0, sp, #4
   16baa:	f7ff fe0f 	bl	167cc <get_auth_string>
			return bt_mesh_prov->output_string(str);
   16bae:	4b0f      	ldr	r3, [pc, #60]	; (16bec <bt_mesh_prov_auth+0x134>)
   16bb0:	681b      	ldr	r3, [r3, #0]
   16bb2:	e7c5      	b.n	16b40 <bt_mesh_prov_auth+0x88>
		if (is_provisioner) {
   16bb4:	2800      	cmp	r0, #0
   16bb6:	d1ad      	bne.n	16b14 <bt_mesh_prov_auth+0x5c>
			return -EINVAL;
   16bb8:	f06f 0015 	mvn.w	r0, #21
   16bbc:	e78f      	b.n	16ade <bt_mesh_prov_auth+0x26>
		if (!is_provisioner) {
   16bbe:	2800      	cmp	r0, #0
   16bc0:	d0fa      	beq.n	16bb8 <bt_mesh_prov_auth+0x100>
   16bc2:	2400      	movs	r4, #0
   16bc4:	2010      	movs	r0, #16
   16bc6:	f7ff fe8d 	bl	168e4 <atomic_or.constprop.0.isra.0>
		return bt_mesh_prov->output_number(output,
   16bca:	4b08      	ldr	r3, [pc, #32]	; (16bec <bt_mesh_prov_auth+0x134>)
   16bcc:	681b      	ldr	r3, [r3, #0]
   16bce:	4621      	mov	r1, r4
   16bd0:	462a      	mov	r2, r5
   16bd2:	2000      	movs	r0, #0
   16bd4:	6a5e      	ldr	r6, [r3, #36]	; 0x24
   16bd6:	f7ff fe39 	bl	1684c <get_auth_number>
   16bda:	4633      	mov	r3, r6
   16bdc:	4601      	mov	r1, r0
   16bde:	2008      	movs	r0, #8
   16be0:	e7bf      	b.n	16b62 <bt_mesh_prov_auth+0xaa>
   16be2:	bf00      	nop
   16be4:	200027a3 	.word	0x200027a3
   16be8:	00033309 	.word	0x00033309
   16bec:	20002790 	.word	0x20002790
   16bf0:	0003330e 	.word	0x0003330e

00016bf4 <bt_mesh_prov_get>:
}
   16bf4:	4b01      	ldr	r3, [pc, #4]	; (16bfc <bt_mesh_prov_get+0x8>)
   16bf6:	6818      	ldr	r0, [r3, #0]
   16bf8:	4770      	bx	lr
   16bfa:	bf00      	nop
   16bfc:	20002790 	.word	0x20002790

00016c00 <bt_mesh_prov_active>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   16c00:	4b04      	ldr	r3, [pc, #16]	; (16c14 <bt_mesh_prov_active+0x14>)
   16c02:	f3bf 8f5b 	dmb	ish
   16c06:	6818      	ldr	r0, [r3, #0]
   16c08:	f3bf 8f5b 	dmb	ish
}
   16c0c:	f3c0 0040 	ubfx	r0, r0, #1, #1
   16c10:	4770      	bx	lr
   16c12:	bf00      	nop
   16c14:	20002794 	.word	0x20002794

00016c18 <bt_mesh_prov_bearer_cb_get>:
};

const struct prov_bearer_cb *bt_mesh_prov_bearer_cb_get(void)
{
	return &prov_bearer_cb;
}
   16c18:	4800      	ldr	r0, [pc, #0]	; (16c1c <bt_mesh_prov_bearer_cb_get+0x4>)
   16c1a:	4770      	bx	lr
   16c1c:	0002e74c 	.word	0x0002e74c

00016c20 <bt_mesh_prov_complete>:

void bt_mesh_prov_complete(uint16_t net_idx, uint16_t addr)
{
	if (bt_mesh_prov->complete) {
   16c20:	4b02      	ldr	r3, [pc, #8]	; (16c2c <bt_mesh_prov_complete+0xc>)
   16c22:	681b      	ldr	r3, [r3, #0]
   16c24:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16c26:	b103      	cbz	r3, 16c2a <bt_mesh_prov_complete+0xa>
		bt_mesh_prov->complete(net_idx, addr);
   16c28:	4718      	bx	r3
	}
}
   16c2a:	4770      	bx	lr
   16c2c:	20002790 	.word	0x20002790

00016c30 <bt_mesh_prov_reset>:

void bt_mesh_prov_reset(void)
{
   16c30:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV)) {
		pb_adv_reset();
   16c32:	f013 fd03 	bl	2a63c <pb_adv_reset>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT)) {
		pb_gatt_reset();
   16c36:	f013 fd04 	bl	2a642 <pb_gatt_reset>
	}

	bt_mesh_prov_reset_state(NULL);
   16c3a:	2000      	movs	r0, #0
   16c3c:	f7ff fefa 	bl	16a34 <bt_mesh_prov_reset_state>

	if (bt_mesh_prov->reset) {
   16c40:	4b03      	ldr	r3, [pc, #12]	; (16c50 <bt_mesh_prov_reset+0x20>)
   16c42:	681b      	ldr	r3, [r3, #0]
   16c44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   16c46:	b113      	cbz	r3, 16c4e <bt_mesh_prov_reset+0x1e>
		bt_mesh_prov->reset();
	}
}
   16c48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_mesh_prov->reset();
   16c4c:	4718      	bx	r3
}
   16c4e:	bd10      	pop	{r4, pc}
   16c50:	20002790 	.word	0x20002790

00016c54 <bt_mesh_prov_init>:

int bt_mesh_prov_init(const struct bt_mesh_prov *prov_info)
{
   16c54:	b500      	push	{lr}
	if (!prov_info) {
   16c56:	4603      	mov	r3, r0
{
   16c58:	b089      	sub	sp, #36	; 0x24
	if (!prov_info) {
   16c5a:	b158      	cbz	r0, 16c74 <bt_mesh_prov_init+0x20>
		BT_ERR("No provisioning context provided");
		return -EINVAL;
	}

	bt_mesh_prov = prov_info;
   16c5c:	4a0d      	ldr	r2, [pc, #52]	; (16c94 <bt_mesh_prov_init+0x40>)
   16c5e:	6010      	str	r0, [r2, #0]

	if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV)) {
		pb_adv_init();
   16c60:	f001 fb02 	bl	18268 <pb_adv_init>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT)) {
		pb_gatt_init();
   16c64:	f001 fc02 	bl	1846c <pb_gatt_init>
	}

	return bt_mesh_prov_reset_state(NULL);
   16c68:	2000      	movs	r0, #0
}
   16c6a:	b009      	add	sp, #36	; 0x24
   16c6c:	f85d eb04 	ldr.w	lr, [sp], #4
	return bt_mesh_prov_reset_state(NULL);
   16c70:	f7ff bee0 	b.w	16a34 <bt_mesh_prov_reset_state>
		BT_ERR("No provisioning context provided");
   16c74:	4a08      	ldr	r2, [pc, #32]	; (16c98 <bt_mesh_prov_init+0x44>)
   16c76:	9206      	str	r2, [sp, #24]
   16c78:	2202      	movs	r2, #2
   16c7a:	9201      	str	r2, [sp, #4]
   16c7c:	9205      	str	r2, [sp, #20]
   16c7e:	4807      	ldr	r0, [pc, #28]	; (16c9c <bt_mesh_prov_init+0x48>)
   16c80:	aa05      	add	r2, sp, #20
   16c82:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16c86:	f00f f827 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   16c8a:	f06f 0015 	mvn.w	r0, #21
   16c8e:	b009      	add	sp, #36	; 0x24
   16c90:	f85d fb04 	ldr.w	pc, [sp], #4
   16c94:	20002790 	.word	0x20002790
   16c98:	000332db 	.word	0x000332db
   16c9c:	0002db64 	.word	0x0002db64

00016ca0 <bt_mesh_prov_send>:
extern const struct bt_mesh_prov *bt_mesh_prov;

static inline int bt_mesh_prov_send(struct net_buf_simple *buf,
				    prov_bearer_send_complete_t cb)
{
	return bt_mesh_prov_link.bearer->send(buf, cb, NULL);
   16ca0:	4b02      	ldr	r3, [pc, #8]	; (16cac <bt_mesh_prov_send+0xc>)
   16ca2:	685b      	ldr	r3, [r3, #4]
   16ca4:	2200      	movs	r2, #0
   16ca6:	689b      	ldr	r3, [r3, #8]
   16ca8:	4718      	bx	r3
   16caa:	bf00      	nop
   16cac:	20002794 	.word	0x20002794

00016cb0 <prov_link_opened>:
	reset_state();
}

static void prov_link_opened(void)
{
	bt_mesh_prov_link.expect = PROV_INVITE;
   16cb0:	4b02      	ldr	r3, [pc, #8]	; (16cbc <prov_link_opened+0xc>)
   16cb2:	2200      	movs	r2, #0
   16cb4:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
}
   16cb8:	4770      	bx	lr
   16cba:	bf00      	nop
   16cbc:	20002794 	.word	0x20002794

00016cc0 <prov_send_fail_msg>:
{
   16cc0:	b510      	push	{r4, lr}
   16cc2:	b08c      	sub	sp, #48	; 0x30
	PROV_BUF(buf, PDU_LEN_FAILED);
   16cc4:	ab01      	add	r3, sp, #4
   16cc6:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
   16cca:	e9cd 2304 	strd	r2, r3, [sp, #16]
   16cce:	9303      	str	r3, [sp, #12]
	bt_mesh_prov_link.expect = PROV_NO_PDU;
   16cd0:	4b0f      	ldr	r3, [pc, #60]	; (16d10 <prov_send_fail_msg+0x50>)
   16cd2:	22ff      	movs	r2, #255	; 0xff
{
   16cd4:	4604      	mov	r4, r0
	bt_mesh_prov_buf_init(&buf, PROV_FAILED);
   16cd6:	2109      	movs	r1, #9
   16cd8:	a803      	add	r0, sp, #12
	bt_mesh_prov_link.expect = PROV_NO_PDU;
   16cda:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
	bt_mesh_prov_buf_init(&buf, PROV_FAILED);
   16cde:	f013 fc77 	bl	2a5d0 <bt_mesh_prov_buf_init>
	net_buf_simple_add_u8(&buf, err);
   16ce2:	4621      	mov	r1, r4
   16ce4:	a803      	add	r0, sp, #12
   16ce6:	f015 f838 	bl	2bd5a <net_buf_simple_add_u8>
	if (bt_mesh_prov_send(&buf, NULL)) {
   16cea:	2100      	movs	r1, #0
   16cec:	a803      	add	r0, sp, #12
   16cee:	f7ff ffd7 	bl	16ca0 <bt_mesh_prov_send>
   16cf2:	b150      	cbz	r0, 16d0a <prov_send_fail_msg+0x4a>
		BT_ERR("Failed to send Provisioning Failed message");
   16cf4:	4b07      	ldr	r3, [pc, #28]	; (16d14 <prov_send_fail_msg+0x54>)
   16cf6:	930a      	str	r3, [sp, #40]	; 0x28
   16cf8:	4807      	ldr	r0, [pc, #28]	; (16d18 <prov_send_fail_msg+0x58>)
   16cfa:	2302      	movs	r3, #2
   16cfc:	aa09      	add	r2, sp, #36	; 0x24
   16cfe:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16d02:	9300      	str	r3, [sp, #0]
   16d04:	9309      	str	r3, [sp, #36]	; 0x24
   16d06:	f013 fc6f 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
}
   16d0a:	b00c      	add	sp, #48	; 0x30
   16d0c:	bd10      	pop	{r4, pc}
   16d0e:	bf00      	nop
   16d10:	20002794 	.word	0x20002794
   16d14:	00033340 	.word	0x00033340
   16d18:	0002db6c 	.word	0x0002db6c

00016d1c <prov_data>:
{
   16d1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   16d20:	b0a2      	sub	sp, #136	; 0x88
	PROV_BUF(msg, PDU_LEN_COMPLETE);
   16d22:	ab03      	add	r3, sp, #12
   16d24:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
   16d28:	e9cd 2306 	strd	r2, r3, [sp, #24]

static inline int bt_mesh_session_key(const uint8_t dhkey[32],
				      const uint8_t prov_salt[16],
				      uint8_t session_key[16])
{
	return bt_mesh_k1(dhkey, 32, prov_salt, "prsk", session_key);
   16d2c:	4a4d      	ldr	r2, [pc, #308]	; (16e64 <prov_data+0x148>)
   16d2e:	9305      	str	r3, [sp, #20]
   16d30:	ad0c      	add	r5, sp, #48	; 0x30
{
   16d32:	4604      	mov	r4, r0
   16d34:	4b4c      	ldr	r3, [pc, #304]	; (16e68 <prov_data+0x14c>)
   16d36:	9500      	str	r5, [sp, #0]
   16d38:	2120      	movs	r1, #32
   16d3a:	f1a2 00f2 	sub.w	r0, r2, #242	; 0xf2
   16d3e:	f012 ffd9 	bl	29cf4 <bt_mesh_k1>
	if (err) {
   16d42:	b130      	cbz	r0, 16d52 <prov_data+0x36>
		BT_ERR("Unable to generate session key");
   16d44:	4b49      	ldr	r3, [pc, #292]	; (16e6c <prov_data+0x150>)
		BT_ERR("Unable to generate session nonce");
   16d46:	931e      	str	r3, [sp, #120]	; 0x78
   16d48:	2302      	movs	r3, #2
   16d4a:	9314      	str	r3, [sp, #80]	; 0x50
   16d4c:	931d      	str	r3, [sp, #116]	; 0x74
   16d4e:	aa1d      	add	r2, sp, #116	; 0x74
   16d50:	e037      	b.n	16dc2 <prov_data+0xa6>
				      uint8_t nonce[13])
{
	uint8_t tmp[16];
	int err;

	err = bt_mesh_k1(dhkey, 32, prov_salt, "prsn", tmp);
   16d52:	4a44      	ldr	r2, [pc, #272]	; (16e64 <prov_data+0x148>)
   16d54:	4b46      	ldr	r3, [pc, #280]	; (16e70 <prov_data+0x154>)
   16d56:	af1a      	add	r7, sp, #104	; 0x68
   16d58:	9700      	str	r7, [sp, #0]
   16d5a:	2120      	movs	r1, #32
   16d5c:	f1a2 00f2 	sub.w	r0, r2, #242	; 0xf2
   16d60:	f012 ffc8 	bl	29cf4 <bt_mesh_k1>
	if (!err) {
   16d64:	2800      	cmp	r0, #0
   16d66:	d17a      	bne.n	16e5e <prov_data+0x142>
		memcpy(nonce, tmp + 3, 13);
   16d68:	220d      	movs	r2, #13
   16d6a:	f10d 016b 	add.w	r1, sp, #107	; 0x6b
   16d6e:	a808      	add	r0, sp, #32
   16d70:	f010 fd7e 	bl	27870 <memcpy>
	err = bt_mesh_prov_decrypt(session_key, nonce, data, pdu);
   16d74:	463b      	mov	r3, r7
   16d76:	4622      	mov	r2, r4
   16d78:	a908      	add	r1, sp, #32
   16d7a:	4628      	mov	r0, r5
   16d7c:	f013 f8d2 	bl	29f24 <bt_mesh_prov_decrypt>
	if (err) {
   16d80:	b170      	cbz	r0, 16da0 <prov_data+0x84>
		BT_ERR("Unable to decrypt provisioning data");
   16d82:	4b3c      	ldr	r3, [pc, #240]	; (16e74 <prov_data+0x158>)
   16d84:	483c      	ldr	r0, [pc, #240]	; (16e78 <prov_data+0x15c>)
   16d86:	9318      	str	r3, [sp, #96]	; 0x60
   16d88:	aa17      	add	r2, sp, #92	; 0x5c
   16d8a:	2302      	movs	r3, #2
   16d8c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16d90:	9310      	str	r3, [sp, #64]	; 0x40
   16d92:	9317      	str	r3, [sp, #92]	; 0x5c
   16d94:	f013 fc28 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   16d98:	2006      	movs	r0, #6
   16d9a:	f7ff ff91 	bl	16cc0 <prov_send_fail_msg>
		return;
   16d9e:	e034      	b.n	16e0a <prov_data+0xee>

static inline int bt_mesh_dev_key(const uint8_t dhkey[32],
				  const uint8_t prov_salt[16],
				  uint8_t dev_key[16])
{
	return bt_mesh_k1(dhkey, 32, prov_salt, "prdk", dev_key);
   16da0:	4a30      	ldr	r2, [pc, #192]	; (16e64 <prov_data+0x148>)
   16da2:	4b36      	ldr	r3, [pc, #216]	; (16e7c <prov_data+0x160>)
   16da4:	ae10      	add	r6, sp, #64	; 0x40
   16da6:	9600      	str	r6, [sp, #0]
   16da8:	2120      	movs	r1, #32
   16daa:	f1a2 00f2 	sub.w	r0, r2, #242	; 0xf2
   16dae:	f012 ffa1 	bl	29cf4 <bt_mesh_k1>
	if (err) {
   16db2:	4604      	mov	r4, r0
   16db4:	b160      	cbz	r0, 16dd0 <prov_data+0xb4>
		BT_ERR("Unable to generate device key");
   16db6:	4b32      	ldr	r3, [pc, #200]	; (16e80 <prov_data+0x164>)
   16db8:	9318      	str	r3, [sp, #96]	; 0x60
   16dba:	2302      	movs	r3, #2
   16dbc:	9302      	str	r3, [sp, #8]
   16dbe:	9317      	str	r3, [sp, #92]	; 0x5c
   16dc0:	aa17      	add	r2, sp, #92	; 0x5c
		BT_ERR("Unable to generate session nonce");
   16dc2:	482d      	ldr	r0, [pc, #180]	; (16e78 <prov_data+0x15c>)
   16dc4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16dc8:	f013 fc0e 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   16dcc:	2007      	movs	r0, #7
   16dce:	e7e4      	b.n	16d9a <prov_data+0x7e>
	bt_mesh_prov_buf_init(&msg, PROV_COMPLETE);
   16dd0:	2108      	movs	r1, #8
   16dd2:	a805      	add	r0, sp, #20
   16dd4:	f8bd 8078 	ldrh.w	r8, [sp, #120]	; 0x78
	flags = pdu[18];
   16dd8:	f89d 907a 	ldrb.w	r9, [sp, #122]	; 0x7a
	return ((uint16_t)src[0] << 8) | src[1];
   16ddc:	f8dd a07b 	ldr.w	sl, [sp, #123]	; 0x7b
   16de0:	f8bd 507f 	ldrh.w	r5, [sp, #127]	; 0x7f
	bt_mesh_prov_buf_init(&msg, PROV_COMPLETE);
   16de4:	f013 fbf4 	bl	2a5d0 <bt_mesh_prov_buf_init>
	if (bt_mesh_prov_send(&msg, NULL)) {
   16de8:	4621      	mov	r1, r4
   16dea:	a805      	add	r0, sp, #20
   16dec:	f7ff ff58 	bl	16ca0 <bt_mesh_prov_send>
   16df0:	4604      	mov	r4, r0
   16df2:	b168      	cbz	r0, 16e10 <prov_data+0xf4>
		BT_ERR("Failed to send Provisioning Complete");
   16df4:	4b23      	ldr	r3, [pc, #140]	; (16e84 <prov_data+0x168>)
   16df6:	9318      	str	r3, [sp, #96]	; 0x60
   16df8:	2302      	movs	r3, #2
   16dfa:	9302      	str	r3, [sp, #8]
   16dfc:	9317      	str	r3, [sp, #92]	; 0x5c
   16dfe:	aa17      	add	r2, sp, #92	; 0x5c
   16e00:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		BT_ERR("Failed to provision (err %d)", err);
   16e04:	481c      	ldr	r0, [pc, #112]	; (16e78 <prov_data+0x15c>)
   16e06:	f013 fbef 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
}
   16e0a:	b022      	add	sp, #136	; 0x88
   16e0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	bt_mesh_prov_link.expect = PROV_NO_PDU;
   16e10:	4b1d      	ldr	r3, [pc, #116]	; (16e88 <prov_data+0x16c>)
   16e12:	22ff      	movs	r2, #255	; 0xff
   16e14:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
	return bt_mesh_prov_link.bearer &&
   16e18:	685b      	ldr	r3, [r3, #4]
   16e1a:	b11b      	cbz	r3, 16e24 <prov_data+0x108>
   16e1c:	781c      	ldrb	r4, [r3, #0]
   16e1e:	1ea3      	subs	r3, r4, #2
   16e20:	425c      	negs	r4, r3
   16e22:	415c      	adcs	r4, r3
	err = bt_mesh_provision(pdu, net_idx, flags, iv_index, addr, dev_key);
   16e24:	ba6d      	rev16	r5, r5
   16e26:	fa98 f198 	rev16.w	r1, r8
   16e2a:	b2ad      	uxth	r5, r5
   16e2c:	9601      	str	r6, [sp, #4]
   16e2e:	9500      	str	r5, [sp, #0]
   16e30:	fa9a f38a 	rev.w	r3, sl
   16e34:	464a      	mov	r2, r9
   16e36:	b289      	uxth	r1, r1
   16e38:	4638      	mov	r0, r7
   16e3a:	f7f4 fe15 	bl	ba68 <bt_mesh_provision>
	if (err) {
   16e3e:	b148      	cbz	r0, 16e54 <prov_data+0x138>
		BT_ERR("Failed to provision (err %d)", err);
   16e40:	4b12      	ldr	r3, [pc, #72]	; (16e8c <prov_data+0x170>)
   16e42:	e9cd 3018 	strd	r3, r0, [sp, #96]	; 0x60
   16e46:	2303      	movs	r3, #3
   16e48:	9302      	str	r3, [sp, #8]
   16e4a:	9317      	str	r3, [sp, #92]	; 0x5c
   16e4c:	aa17      	add	r2, sp, #92	; 0x5c
   16e4e:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   16e52:	e7d7      	b.n	16e04 <prov_data+0xe8>
	if (IS_ENABLED(CONFIG_BT_MESH_GATT_PROXY) && identity_enable) {
   16e54:	2c00      	cmp	r4, #0
   16e56:	d0d8      	beq.n	16e0a <prov_data+0xee>
		bt_mesh_proxy_identity_enable();
   16e58:	f001 ff58 	bl	18d0c <bt_mesh_proxy_identity_enable>
   16e5c:	e7d5      	b.n	16e0a <prov_data+0xee>
		BT_ERR("Unable to generate session nonce");
   16e5e:	4b0c      	ldr	r3, [pc, #48]	; (16e90 <prov_data+0x174>)
   16e60:	e771      	b.n	16d46 <prov_data+0x2a>
   16e62:	bf00      	nop
   16e64:	200028a5 	.word	0x200028a5
   16e68:	0003336b 	.word	0x0003336b
   16e6c:	00033370 	.word	0x00033370
   16e70:	0003338f 	.word	0x0003338f
   16e74:	00033394 	.word	0x00033394
   16e78:	0002db6c 	.word	0x0002db6c
   16e7c:	000333b8 	.word	0x000333b8
   16e80:	000333bd 	.word	0x000333bd
   16e84:	000333db 	.word	0x000333db
   16e88:	20002794 	.word	0x20002794
   16e8c:	00033400 	.word	0x00033400
   16e90:	0003341d 	.word	0x0003341d

00016e94 <send_confirm>:
{
   16e94:	b500      	push	{lr}
	if (bt_mesh_prov_conf_salt(inputs, bt_mesh_prov_link.conf_salt)) {
   16e96:	492c      	ldr	r1, [pc, #176]	; (16f48 <send_confirm+0xb4>)
{
   16e98:	b091      	sub	sp, #68	; 0x44
	PROV_BUF(cfm, PDU_LEN_CONFIRM);
   16e9a:	ab04      	add	r3, sp, #16
   16e9c:	f44f 12b0 	mov.w	r2, #1441792	; 0x160000
	if (bt_mesh_prov_conf_salt(inputs, bt_mesh_prov_link.conf_salt)) {
   16ea0:	f101 0020 	add.w	r0, r1, #32
	PROV_BUF(cfm, PDU_LEN_CONFIRM);
   16ea4:	e9cd 2302 	strd	r2, r3, [sp, #8]
   16ea8:	9301      	str	r3, [sp, #4]
	if (bt_mesh_prov_conf_salt(inputs, bt_mesh_prov_link.conf_salt)) {
   16eaa:	f013 f81f 	bl	29eec <bt_mesh_prov_conf_salt>
   16eae:	b180      	cbz	r0, 16ed2 <send_confirm+0x3e>
		BT_ERR("Unable to generate confirmation salt");
   16eb0:	4b26      	ldr	r3, [pc, #152]	; (16f4c <send_confirm+0xb8>)
		BT_ERR("Unable to generate confirmation value");
   16eb2:	4827      	ldr	r0, [pc, #156]	; (16f50 <send_confirm+0xbc>)
   16eb4:	930e      	str	r3, [sp, #56]	; 0x38
   16eb6:	aa0d      	add	r2, sp, #52	; 0x34
   16eb8:	2302      	movs	r3, #2
   16eba:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16ebe:	9300      	str	r3, [sp, #0]
   16ec0:	930d      	str	r3, [sp, #52]	; 0x34
   16ec2:	f013 fb91 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   16ec6:	2007      	movs	r0, #7
   16ec8:	f7ff fefa 	bl	16cc0 <prov_send_fail_msg>
}
   16ecc:	b011      	add	sp, #68	; 0x44
   16ece:	f85d fb04 	ldr.w	pc, [sp], #4
	if (bt_mesh_prov_conf_key(bt_mesh_prov_link.dhkey, bt_mesh_prov_link.conf_salt,
   16ed2:	4a20      	ldr	r2, [pc, #128]	; (16f54 <send_confirm+0xc0>)
   16ed4:	f1a2 0110 	sub.w	r1, r2, #16
   16ed8:	f1a2 0051 	sub.w	r0, r2, #81	; 0x51
   16edc:	f7f9 fb7e 	bl	105dc <bt_mesh_prov_conf_key>
   16ee0:	b108      	cbz	r0, 16ee6 <send_confirm+0x52>
		BT_ERR("Unable to generate confirmation key");
   16ee2:	4b1d      	ldr	r3, [pc, #116]	; (16f58 <send_confirm+0xc4>)
   16ee4:	e7e5      	b.n	16eb2 <send_confirm+0x1e>
	if (bt_rand(bt_mesh_prov_link.rand, 16)) {
   16ee6:	481d      	ldr	r0, [pc, #116]	; (16f5c <send_confirm+0xc8>)
   16ee8:	2110      	movs	r1, #16
   16eea:	f014 f80e 	bl	2af0a <bt_rand>
   16eee:	b108      	cbz	r0, 16ef4 <send_confirm+0x60>
		BT_ERR("Unable to generate random number");
   16ef0:	4b1b      	ldr	r3, [pc, #108]	; (16f60 <send_confirm+0xcc>)
   16ef2:	e7de      	b.n	16eb2 <send_confirm+0x1e>
	bt_mesh_prov_buf_init(&cfm, PROV_CONFIRM);
   16ef4:	2105      	movs	r1, #5
   16ef6:	a801      	add	r0, sp, #4
   16ef8:	f013 fb6a 	bl	2a5d0 <bt_mesh_prov_buf_init>
			      bt_mesh_prov_link.auth, net_buf_simple_add(&cfm, 16))) {
   16efc:	2110      	movs	r1, #16
   16efe:	a801      	add	r0, sp, #4
   16f00:	f014 ff1c 	bl	2bd3c <net_buf_simple_add>
	if (bt_mesh_prov_conf(bt_mesh_prov_link.conf_key, bt_mesh_prov_link.rand,
   16f04:	4a17      	ldr	r2, [pc, #92]	; (16f64 <send_confirm+0xd0>)
			      bt_mesh_prov_link.auth, net_buf_simple_add(&cfm, 16))) {
   16f06:	4603      	mov	r3, r0
	if (bt_mesh_prov_conf(bt_mesh_prov_link.conf_key, bt_mesh_prov_link.rand,
   16f08:	f102 0141 	add.w	r1, r2, #65	; 0x41
   16f0c:	f102 0061 	add.w	r0, r2, #97	; 0x61
   16f10:	f012 fffb 	bl	29f0a <bt_mesh_prov_conf>
   16f14:	4601      	mov	r1, r0
   16f16:	b108      	cbz	r0, 16f1c <send_confirm+0x88>
		BT_ERR("Unable to generate confirmation value");
   16f18:	4b13      	ldr	r3, [pc, #76]	; (16f68 <send_confirm+0xd4>)
   16f1a:	e7ca      	b.n	16eb2 <send_confirm+0x1e>
	if (bt_mesh_prov_send(&cfm, NULL)) {
   16f1c:	a801      	add	r0, sp, #4
   16f1e:	f7ff febf 	bl	16ca0 <bt_mesh_prov_send>
   16f22:	b158      	cbz	r0, 16f3c <send_confirm+0xa8>
		BT_ERR("Failed to send Provisioning Confirm");
   16f24:	4b11      	ldr	r3, [pc, #68]	; (16f6c <send_confirm+0xd8>)
   16f26:	930e      	str	r3, [sp, #56]	; 0x38
   16f28:	4809      	ldr	r0, [pc, #36]	; (16f50 <send_confirm+0xbc>)
   16f2a:	2302      	movs	r3, #2
   16f2c:	aa0d      	add	r2, sp, #52	; 0x34
   16f2e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   16f32:	9300      	str	r3, [sp, #0]
   16f34:	930d      	str	r3, [sp, #52]	; 0x34
   16f36:	f013 fb57 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
		return;
   16f3a:	e7c7      	b.n	16ecc <send_confirm+0x38>
	bt_mesh_prov_link.expect = PROV_RANDOM;
   16f3c:	4b0c      	ldr	r3, [pc, #48]	; (16f70 <send_confirm+0xdc>)
   16f3e:	2206      	movs	r2, #6
   16f40:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
   16f44:	e7c2      	b.n	16ecc <send_confirm+0x38>
   16f46:	bf00      	nop
   16f48:	200027f4 	.word	0x200027f4
   16f4c:	0003343e 	.word	0x0003343e
   16f50:	0002db6c 	.word	0x0002db6c
   16f54:	20002804 	.word	0x20002804
   16f58:	00033463 	.word	0x00033463
   16f5c:	200027e4 	.word	0x200027e4
   16f60:	00033487 	.word	0x00033487
   16f64:	200027a3 	.word	0x200027a3
   16f68:	000334a8 	.word	0x000334a8
   16f6c:	000334ce 	.word	0x000334ce
   16f70:	20002794 	.word	0x20002794

00016f74 <prov_invite>:
{
   16f74:	b510      	push	{r4, lr}
   16f76:	b090      	sub	sp, #64	; 0x40
	if (data[0]) {
   16f78:	7801      	ldrb	r1, [r0, #0]
	PROV_BUF(buf, PDU_LEN_CAPABILITIES);
   16f7a:	ab05      	add	r3, sp, #20
   16f7c:	f44f 1288 	mov.w	r2, #1114112	; 0x110000
   16f80:	e9cd 2303 	strd	r2, r3, [sp, #12]
{
   16f84:	4604      	mov	r4, r0
	PROV_BUF(buf, PDU_LEN_CAPABILITIES);
   16f86:	9302      	str	r3, [sp, #8]
	if (data[0]) {
   16f88:	b111      	cbz	r1, 16f90 <prov_invite+0x1c>
		bt_mesh_attention(NULL, data[0]);
   16f8a:	2000      	movs	r0, #0
   16f8c:	f7fd fec8 	bl	14d20 <bt_mesh_attention>
	memcpy(bt_mesh_prov_link.conf_inputs.invite, data, PDU_LEN_INVITE);
   16f90:	2201      	movs	r2, #1
   16f92:	4621      	mov	r1, r4
   16f94:	4828      	ldr	r0, [pc, #160]	; (17038 <prov_invite+0xc4>)
			      bt_mesh_prov->public_key_be == NULL ? PUB_KEY_NO_OOB : PUB_KEY_OOB);
   16f96:	4c29      	ldr	r4, [pc, #164]	; (1703c <prov_invite+0xc8>)
	memcpy(bt_mesh_prov_link.conf_inputs.invite, data, PDU_LEN_INVITE);
   16f98:	f010 fc6a 	bl	27870 <memcpy>
	bt_mesh_prov_buf_init(&buf, PROV_CAPABILITIES);
   16f9c:	2101      	movs	r1, #1
   16f9e:	a802      	add	r0, sp, #8
   16fa0:	f013 fb16 	bl	2a5d0 <bt_mesh_prov_buf_init>
	net_buf_simple_add_u8(&buf, bt_mesh_elem_count());
   16fa4:	f7f9 ffe0 	bl	10f68 <bt_mesh_elem_count>
   16fa8:	4601      	mov	r1, r0
   16faa:	a802      	add	r0, sp, #8
   16fac:	f014 fed5 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_be16(&buf, BIT(PROV_ALG_P256));
   16fb0:	2101      	movs	r1, #1
   16fb2:	a802      	add	r0, sp, #8
   16fb4:	f014 fee3 	bl	2bd7e <net_buf_simple_add_be16>
			      bt_mesh_prov->public_key_be == NULL ? PUB_KEY_NO_OOB : PUB_KEY_OOB);
   16fb8:	6823      	ldr	r3, [r4, #0]
	net_buf_simple_add_u8(&buf,
   16fba:	68d9      	ldr	r1, [r3, #12]
   16fbc:	3900      	subs	r1, #0
   16fbe:	bf18      	it	ne
   16fc0:	2101      	movne	r1, #1
   16fc2:	a802      	add	r0, sp, #8
   16fc4:	f014 fec9 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, bt_mesh_prov->static_val ? BIT(0) : 0x00);
   16fc8:	6823      	ldr	r3, [r4, #0]
   16fca:	6959      	ldr	r1, [r3, #20]
   16fcc:	3900      	subs	r1, #0
   16fce:	bf18      	it	ne
   16fd0:	2101      	movne	r1, #1
   16fd2:	a802      	add	r0, sp, #8
   16fd4:	f014 fec1 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(&buf, bt_mesh_prov->output_size);
   16fd8:	6823      	ldr	r3, [r4, #0]
   16fda:	a802      	add	r0, sp, #8
   16fdc:	7e59      	ldrb	r1, [r3, #25]
   16fde:	f014 febc 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_be16(&buf, bt_mesh_prov->output_actions);
   16fe2:	6823      	ldr	r3, [r4, #0]
   16fe4:	a802      	add	r0, sp, #8
   16fe6:	8b59      	ldrh	r1, [r3, #26]
   16fe8:	f014 fec9 	bl	2bd7e <net_buf_simple_add_be16>
	net_buf_simple_add_u8(&buf, bt_mesh_prov->input_size);
   16fec:	6823      	ldr	r3, [r4, #0]
   16fee:	a802      	add	r0, sp, #8
   16ff0:	7f19      	ldrb	r1, [r3, #28]
   16ff2:	f014 feb2 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_be16(&buf, bt_mesh_prov->input_actions);
   16ff6:	6823      	ldr	r3, [r4, #0]
   16ff8:	a802      	add	r0, sp, #8
   16ffa:	8bd9      	ldrh	r1, [r3, #30]
   16ffc:	f014 febf 	bl	2bd7e <net_buf_simple_add_be16>
	memcpy(bt_mesh_prov_link.conf_inputs.capabilities, &buf.data[1], PDU_LEN_CAPABILITIES);
   17000:	9902      	ldr	r1, [sp, #8]
   17002:	480f      	ldr	r0, [pc, #60]	; (17040 <prov_invite+0xcc>)
   17004:	220b      	movs	r2, #11
   17006:	3101      	adds	r1, #1
   17008:	f010 fc32 	bl	27870 <memcpy>
	if (bt_mesh_prov_send(&buf, NULL)) {
   1700c:	2100      	movs	r1, #0
   1700e:	a802      	add	r0, sp, #8
   17010:	f7ff fe46 	bl	16ca0 <bt_mesh_prov_send>
   17014:	2302      	movs	r3, #2
   17016:	b158      	cbz	r0, 17030 <prov_invite+0xbc>
		BT_ERR("Failed to send capabilities");
   17018:	4a0a      	ldr	r2, [pc, #40]	; (17044 <prov_invite+0xd0>)
   1701a:	920e      	str	r2, [sp, #56]	; 0x38
   1701c:	480a      	ldr	r0, [pc, #40]	; (17048 <prov_invite+0xd4>)
   1701e:	9301      	str	r3, [sp, #4]
   17020:	aa0d      	add	r2, sp, #52	; 0x34
   17022:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17026:	930d      	str	r3, [sp, #52]	; 0x34
   17028:	f013 fade 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
}
   1702c:	b010      	add	sp, #64	; 0x40
   1702e:	bd10      	pop	{r4, pc}
	bt_mesh_prov_link.expect = PROV_START;
   17030:	4a06      	ldr	r2, [pc, #24]	; (1704c <prov_invite+0xd8>)
   17032:	f882 303f 	strb.w	r3, [r2, #63]	; 0x3f
   17036:	e7f9      	b.n	1702c <prov_invite+0xb8>
   17038:	20002814 	.word	0x20002814
   1703c:	20002790 	.word	0x20002790
   17040:	20002815 	.word	0x20002815
   17044:	000334f2 	.word	0x000334f2
   17048:	0002db6c 	.word	0x0002db6c
   1704c:	20002794 	.word	0x20002794

00017050 <send_input_complete>:
{
   17050:	b500      	push	{lr}
   17052:	b08d      	sub	sp, #52	; 0x34
	PROV_BUF(buf, PDU_LEN_INPUT_COMPLETE);
   17054:	ab01      	add	r3, sp, #4
   17056:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
	bt_mesh_prov_buf_init(&buf, PROV_INPUT_COMPLETE);
   1705a:	2104      	movs	r1, #4
   1705c:	a803      	add	r0, sp, #12
	PROV_BUF(buf, PDU_LEN_INPUT_COMPLETE);
   1705e:	e9cd 2304 	strd	r2, r3, [sp, #16]
   17062:	9303      	str	r3, [sp, #12]
	bt_mesh_prov_buf_init(&buf, PROV_INPUT_COMPLETE);
   17064:	f013 fab4 	bl	2a5d0 <bt_mesh_prov_buf_init>
	if (bt_mesh_prov_send(&buf, NULL)) {
   17068:	2100      	movs	r1, #0
   1706a:	a803      	add	r0, sp, #12
   1706c:	f7ff fe18 	bl	16ca0 <bt_mesh_prov_send>
   17070:	b150      	cbz	r0, 17088 <send_input_complete+0x38>
		BT_ERR("Failed to send Provisioning Input Complete");
   17072:	4b09      	ldr	r3, [pc, #36]	; (17098 <send_input_complete+0x48>)
   17074:	930a      	str	r3, [sp, #40]	; 0x28
   17076:	4809      	ldr	r0, [pc, #36]	; (1709c <send_input_complete+0x4c>)
   17078:	2302      	movs	r3, #2
   1707a:	aa09      	add	r2, sp, #36	; 0x24
   1707c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17080:	9300      	str	r3, [sp, #0]
   17082:	9309      	str	r3, [sp, #36]	; 0x24
   17084:	f013 fab0 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	bt_mesh_prov_link.expect = PROV_CONFIRM;
   17088:	4b05      	ldr	r3, [pc, #20]	; (170a0 <send_input_complete+0x50>)
   1708a:	2205      	movs	r2, #5
   1708c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
}
   17090:	b00d      	add	sp, #52	; 0x34
   17092:	f85d fb04 	ldr.w	pc, [sp], #4
   17096:	bf00      	nop
   17098:	0003350e 	.word	0x0003350e
   1709c:	0002db6c 	.word	0x0002db6c
   170a0:	20002794 	.word	0x20002794

000170a4 <prov_random>:
{
   170a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!memcmp(data, bt_mesh_prov_link.rand, 16)) {
   170a6:	4c41      	ldr	r4, [pc, #260]	; (171ac <prov_random+0x108>)
{
   170a8:	b095      	sub	sp, #84	; 0x54
	if (!memcmp(data, bt_mesh_prov_link.rand, 16)) {
   170aa:	2210      	movs	r2, #16
   170ac:	4621      	mov	r1, r4
{
   170ae:	4605      	mov	r5, r0
	if (!memcmp(data, bt_mesh_prov_link.rand, 16)) {
   170b0:	f010 fbcd 	bl	2784e <memcmp>
   170b4:	b980      	cbnz	r0, 170d8 <prov_random+0x34>
		BT_ERR("Random value is identical to ours, rejecting.");
   170b6:	4b3e      	ldr	r3, [pc, #248]	; (171b0 <prov_random+0x10c>)
   170b8:	9312      	str	r3, [sp, #72]	; 0x48
   170ba:	483e      	ldr	r0, [pc, #248]	; (171b4 <prov_random+0x110>)
   170bc:	2302      	movs	r3, #2
   170be:	aa11      	add	r2, sp, #68	; 0x44
   170c0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   170c4:	9308      	str	r3, [sp, #32]
   170c6:	9311      	str	r3, [sp, #68]	; 0x44
   170c8:	f013 fa8e 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   170cc:	2004      	movs	r0, #4
}
   170ce:	b015      	add	sp, #84	; 0x54
   170d0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	prov_send_fail_msg(reason);
   170d4:	f7ff bdf4 	b.w	16cc0 <prov_send_fail_msg>
	if (bt_mesh_prov_conf(bt_mesh_prov_link.conf_key, data,
   170d8:	ab04      	add	r3, sp, #16
   170da:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
   170de:	4629      	mov	r1, r5
   170e0:	f104 0020 	add.w	r0, r4, #32
   170e4:	f012 ff11 	bl	29f0a <bt_mesh_prov_conf>
   170e8:	b160      	cbz	r0, 17104 <prov_random+0x60>
		BT_ERR("Unable to calculate confirmation verification");
   170ea:	4b33      	ldr	r3, [pc, #204]	; (171b8 <prov_random+0x114>)
		BT_ERR("Failed to generate provisioning salt");
   170ec:	4831      	ldr	r0, [pc, #196]	; (171b4 <prov_random+0x110>)
   170ee:	9312      	str	r3, [sp, #72]	; 0x48
   170f0:	aa11      	add	r2, sp, #68	; 0x44
   170f2:	2302      	movs	r3, #2
   170f4:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   170f8:	9308      	str	r3, [sp, #32]
   170fa:	9311      	str	r3, [sp, #68]	; 0x44
   170fc:	f013 fa74 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   17100:	2007      	movs	r0, #7
   17102:	e013      	b.n	1712c <prov_random+0x88>
	if (memcmp(conf_verify, bt_mesh_prov_link.conf, 16)) {
   17104:	2210      	movs	r2, #16
   17106:	f1a4 0110 	sub.w	r1, r4, #16
   1710a:	eb0d 0002 	add.w	r0, sp, r2
   1710e:	f010 fb9e 	bl	2784e <memcmp>
   17112:	b178      	cbz	r0, 17134 <prov_random+0x90>
		BT_ERR("Invalid confirmation value");
   17114:	4b29      	ldr	r3, [pc, #164]	; (171bc <prov_random+0x118>)
   17116:	4827      	ldr	r0, [pc, #156]	; (171b4 <prov_random+0x110>)
   17118:	9312      	str	r3, [sp, #72]	; 0x48
   1711a:	aa11      	add	r2, sp, #68	; 0x44
   1711c:	2302      	movs	r3, #2
   1711e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17122:	9308      	str	r3, [sp, #32]
   17124:	9311      	str	r3, [sp, #68]	; 0x44
   17126:	f013 fa5f 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   1712a:	2004      	movs	r0, #4
   1712c:	f7ff fdc8 	bl	16cc0 <prov_send_fail_msg>
}
   17130:	b015      	add	sp, #84	; 0x54
   17132:	bdf0      	pop	{r4, r5, r6, r7, pc}
				    const uint8_t prov_rand[16],
				    const uint8_t dev_rand[16],
				    uint8_t prov_salt[16])
{
	const uint8_t prov_salt_key[16] = { 0 };
	struct bt_mesh_sg sg[] = {
   17134:	f104 0310 	add.w	r3, r4, #16
		{ conf_salt, 16 },
		{ prov_rand, 16 },
		{ dev_rand, 16 },
	};

	return bt_mesh_aes_cmac(prov_salt_key, sg, ARRAY_SIZE(sg), prov_salt);
   17138:	ae08      	add	r6, sp, #32
	struct bt_mesh_sg sg[] = {
   1713a:	2710      	movs	r7, #16
	const uint8_t prov_salt_key[16] = { 0 };
   1713c:	e9cd 0008 	strd	r0, r0, [sp, #32]
   17140:	e9cd 000a 	strd	r0, r0, [sp, #40]	; 0x28
	struct bt_mesh_sg sg[] = {
   17144:	930e      	str	r3, [sp, #56]	; 0x38
	return bt_mesh_aes_cmac(prov_salt_key, sg, ARRAY_SIZE(sg), prov_salt);
   17146:	2203      	movs	r2, #3
   17148:	f104 03c1 	add.w	r3, r4, #193	; 0xc1
   1714c:	a90e      	add	r1, sp, #56	; 0x38
   1714e:	4630      	mov	r0, r6
	struct bt_mesh_sg sg[] = {
   17150:	e9cd 750f 	strd	r7, r5, [sp, #60]	; 0x3c
   17154:	e9cd 7411 	strd	r7, r4, [sp, #68]	; 0x44
   17158:	9713      	str	r7, [sp, #76]	; 0x4c
	return bt_mesh_aes_cmac(prov_salt_key, sg, ARRAY_SIZE(sg), prov_salt);
   1715a:	f012 fd89 	bl	29c70 <bt_mesh_aes_cmac>
	if (bt_mesh_prov_salt(bt_mesh_prov_link.conf_salt, data,
   1715e:	4605      	mov	r5, r0
   17160:	b108      	cbz	r0, 17166 <prov_random+0xc2>
		BT_ERR("Failed to generate provisioning salt");
   17162:	4b17      	ldr	r3, [pc, #92]	; (171c0 <prov_random+0x11c>)
   17164:	e7c2      	b.n	170ec <prov_random+0x48>
	PROV_BUF(rnd, PDU_LEN_RANDOM);
   17166:	f44f 13b0 	mov.w	r3, #1441792	; 0x160000
	bt_mesh_prov_buf_init(&rnd, PROV_RANDOM);
   1716a:	2106      	movs	r1, #6
   1716c:	a801      	add	r0, sp, #4
	PROV_BUF(rnd, PDU_LEN_RANDOM);
   1716e:	e9cd 3602 	strd	r3, r6, [sp, #8]
   17172:	9601      	str	r6, [sp, #4]
	bt_mesh_prov_buf_init(&rnd, PROV_RANDOM);
   17174:	f013 fa2c 	bl	2a5d0 <bt_mesh_prov_buf_init>
	net_buf_simple_add_mem(&rnd, bt_mesh_prov_link.rand, 16);
   17178:	4621      	mov	r1, r4
   1717a:	463a      	mov	r2, r7
   1717c:	a801      	add	r0, sp, #4
   1717e:	f014 fde3 	bl	2bd48 <net_buf_simple_add_mem>
	if (bt_mesh_prov_send(&rnd, NULL)) {
   17182:	4629      	mov	r1, r5
   17184:	a801      	add	r0, sp, #4
   17186:	f7ff fd8b 	bl	16ca0 <bt_mesh_prov_send>
   1718a:	b158      	cbz	r0, 171a4 <prov_random+0x100>
		BT_ERR("Failed to send Provisioning Random");
   1718c:	4b0d      	ldr	r3, [pc, #52]	; (171c4 <prov_random+0x120>)
   1718e:	9312      	str	r3, [sp, #72]	; 0x48
   17190:	4808      	ldr	r0, [pc, #32]	; (171b4 <prov_random+0x110>)
   17192:	2302      	movs	r3, #2
   17194:	aa11      	add	r2, sp, #68	; 0x44
   17196:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1719a:	9300      	str	r3, [sp, #0]
   1719c:	9311      	str	r3, [sp, #68]	; 0x44
   1719e:	f013 fa23 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
		return;
   171a2:	e7c5      	b.n	17130 <prov_random+0x8c>
	bt_mesh_prov_link.expect = PROV_DATA;
   171a4:	2307      	movs	r3, #7
   171a6:	f804 3c11 	strb.w	r3, [r4, #-17]
   171aa:	e7c1      	b.n	17130 <prov_random+0x8c>
   171ac:	200027e4 	.word	0x200027e4
   171b0:	00033539 	.word	0x00033539
   171b4:	0002db6c 	.word	0x0002db6c
   171b8:	00033567 	.word	0x00033567
   171bc:	00033595 	.word	0x00033595
   171c0:	000335b0 	.word	0x000335b0
   171c4:	000335d5 	.word	0x000335d5

000171c8 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   171c8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   171ca:	ab0a      	add	r3, sp, #40	; 0x28
   171cc:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   171ce:	9302      	str	r3, [sp, #8]
   171d0:	4b05      	ldr	r3, [pc, #20]	; (171e8 <z_log_msg2_runtime_create.constprop.0+0x20>)
   171d2:	9301      	str	r3, [sp, #4]
   171d4:	2300      	movs	r3, #0
   171d6:	9300      	str	r3, [sp, #0]
   171d8:	2203      	movs	r2, #3
   171da:	4618      	mov	r0, r3
   171dc:	f7ec f864 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   171e0:	b007      	add	sp, #28
   171e2:	f85d fb04 	ldr.w	pc, [sp], #4
   171e6:	bf00      	nop
   171e8:	000335f8 	.word	0x000335f8

000171ec <prov_dh_key_gen>:
{
   171ec:	b500      	push	{lr}
	sys_memcpy_swap(remote_pk_le, remote_pk, BT_PUB_KEY_COORD_LEN);
   171ee:	490f      	ldr	r1, [pc, #60]	; (1722c <prov_dh_key_gen+0x40>)
{
   171f0:	b099      	sub	sp, #100	; 0x64
	sys_memcpy_swap(remote_pk_le, remote_pk, BT_PUB_KEY_COORD_LEN);
   171f2:	a808      	add	r0, sp, #32
   171f4:	f013 f9fd 	bl	2a5f2 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&remote_pk_le[BT_PUB_KEY_COORD_LEN], &remote_pk[BT_PUB_KEY_COORD_LEN],
   171f8:	3120      	adds	r1, #32
   171fa:	a810      	add	r0, sp, #64	; 0x40
   171fc:	f013 f9f9 	bl	2a5f2 <sys_memcpy_swap.constprop.0>
	if (bt_dh_key_gen(remote_pk_le, prov_dh_key_cb)) {
   17200:	490b      	ldr	r1, [pc, #44]	; (17230 <prov_dh_key_gen+0x44>)
   17202:	a808      	add	r0, sp, #32
   17204:	f7f0 ff4a 	bl	809c <bt_dh_key_gen>
   17208:	b168      	cbz	r0, 17226 <prov_dh_key_gen+0x3a>
		BT_ERR("Failed to generate DHKey");
   1720a:	4b0a      	ldr	r3, [pc, #40]	; (17234 <prov_dh_key_gen+0x48>)
   1720c:	480a      	ldr	r0, [pc, #40]	; (17238 <prov_dh_key_gen+0x4c>)
   1720e:	9306      	str	r3, [sp, #24]
   17210:	aa05      	add	r2, sp, #20
   17212:	2302      	movs	r3, #2
   17214:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17218:	9301      	str	r3, [sp, #4]
   1721a:	9305      	str	r3, [sp, #20]
   1721c:	f013 f9e4 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   17220:	2007      	movs	r0, #7
   17222:	f7ff fd4d 	bl	16cc0 <prov_send_fail_msg>
}
   17226:	b019      	add	sp, #100	; 0x64
   17228:	f85d fb04 	ldr.w	pc, [sp], #4
   1722c:	20002825 	.word	0x20002825
   17230:	000174f5 	.word	0x000174f5
   17234:	00033608 	.word	0x00033608
   17238:	0002db6c 	.word	0x0002db6c

0001723c <atomic_get.constprop.0>:
   1723c:	4b03      	ldr	r3, [pc, #12]	; (1724c <atomic_get.constprop.0+0x10>)
   1723e:	f3bf 8f5b 	dmb	ish
   17242:	6818      	ldr	r0, [r3, #0]
   17244:	f3bf 8f5b 	dmb	ish
}
   17248:	4770      	bx	lr
   1724a:	bf00      	nop
   1724c:	20002794 	.word	0x20002794

00017250 <prov_start>:
{
   17250:	b5f0      	push	{r4, r5, r6, r7, lr}
   17252:	b089      	sub	sp, #36	; 0x24
	if (data[0] != PROV_ALG_P256) {
   17254:	7803      	ldrb	r3, [r0, #0]
{
   17256:	af00      	add	r7, sp, #0
   17258:	4604      	mov	r4, r0
	if (data[0] != PROV_ALG_P256) {
   1725a:	b193      	cbz	r3, 17282 <prov_start+0x32>
		BT_ERR("Unknown algorithm 0x%02x", data[0]);
   1725c:	4a35      	ldr	r2, [pc, #212]	; (17334 <prov_start+0xe4>)
   1725e:	e9c7 2306 	strd	r2, r3, [r7, #24]
		BT_ERR("Invalid public key type: 0x%02x", data[1]);
   17262:	2303      	movs	r3, #3
   17264:	4834      	ldr	r0, [pc, #208]	; (17338 <prov_start+0xe8>)
   17266:	607b      	str	r3, [r7, #4]
   17268:	f107 0214 	add.w	r2, r7, #20
   1726c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   17270:	617b      	str	r3, [r7, #20]
   17272:	f013 f9b9 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   17276:	2002      	movs	r0, #2
   17278:	f7ff fd22 	bl	16cc0 <prov_send_fail_msg>
}
   1727c:	3724      	adds	r7, #36	; 0x24
   1727e:	46bd      	mov	sp, r7
   17280:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (data[1] > PUB_KEY_OOB ||
   17282:	7846      	ldrb	r6, [r0, #1]
   17284:	b11e      	cbz	r6, 1728e <prov_start+0x3e>
		BT_ERR("Invalid public key type: 0x%02x", data[1]);
   17286:	4b2d      	ldr	r3, [pc, #180]	; (1733c <prov_start+0xec>)
   17288:	e9c7 3606 	strd	r3, r6, [r7, #24]
   1728c:	e7e9      	b.n	17262 <prov_start+0x12>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1728e:	4d2c      	ldr	r5, [pc, #176]	; (17340 <prov_start+0xf0>)
   17290:	f3bf 8f5b 	dmb	ish
   17294:	e855 3f00 	ldrex	r3, [r5]
   17298:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1729c:	e845 3200 	strex	r2, r3, [r5]
   172a0:	2a00      	cmp	r2, #0
   172a2:	d1f7      	bne.n	17294 <prov_start+0x44>
   172a4:	f3bf 8f5b 	dmb	ish
	memcpy(bt_mesh_prov_link.conf_inputs.start, data, PDU_LEN_START);
   172a8:	2205      	movs	r2, #5
   172aa:	4621      	mov	r1, r4
   172ac:	f105 008c 	add.w	r0, r5, #140	; 0x8c
   172b0:	f010 fade 	bl	27870 <memcpy>
	bt_mesh_prov_link.expect = PROV_PUB_KEY;
   172b4:	2303      	movs	r3, #3
   172b6:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
	bt_mesh_prov_link.oob_method = data[2];
   172ba:	78a3      	ldrb	r3, [r4, #2]
   172bc:	732b      	strb	r3, [r5, #12]
	bt_mesh_prov_link.oob_action = data[3];
   172be:	78e3      	ldrb	r3, [r4, #3]
   172c0:	736b      	strb	r3, [r5, #13]
	bt_mesh_prov_link.oob_size = data[4];
   172c2:	7923      	ldrb	r3, [r4, #4]
   172c4:	73ab      	strb	r3, [r5, #14]
	if (bt_mesh_prov_auth(false, data[2], data[3], data[4]) < 0) {
   172c6:	78e2      	ldrb	r2, [r4, #3]
   172c8:	78a1      	ldrb	r1, [r4, #2]
   172ca:	4630      	mov	r0, r6
   172cc:	f7ff fbf4 	bl	16ab8 <bt_mesh_prov_auth>
   172d0:	2800      	cmp	r0, #0
   172d2:	da17      	bge.n	17304 <prov_start+0xb4>
		BT_ERR("Invalid authentication method: 0x%02x; "
   172d4:	78a0      	ldrb	r0, [r4, #2]
   172d6:	78e1      	ldrb	r1, [r4, #3]
   172d8:	7923      	ldrb	r3, [r4, #4]
   172da:	4d1a      	ldr	r5, [pc, #104]	; (17344 <prov_start+0xf4>)
   172dc:	466c      	mov	r4, sp
   172de:	b088      	sub	sp, #32
   172e0:	466a      	mov	r2, sp
   172e2:	e9c2 1306 	strd	r1, r3, [r2, #24]
   172e6:	2305      	movs	r3, #5
   172e8:	e9c2 5004 	strd	r5, r0, [r2, #16]
   172ec:	f44f 5121 	mov.w	r1, #10304	; 0x2840
   172f0:	4811      	ldr	r0, [pc, #68]	; (17338 <prov_start+0xe8>)
   172f2:	f842 3f0c 	str.w	r3, [r2, #12]!
   172f6:	60bb      	str	r3, [r7, #8]
   172f8:	f013 f976 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   172fc:	2002      	movs	r0, #2
   172fe:	46a5      	mov	sp, r4
   17300:	f7ff fcde 	bl	16cc0 <prov_send_fail_msg>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17304:	f7ff ff9a 	bl	1723c <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh_prov_link.flags, OOB_STATIC_KEY)) {
   17308:	04c3      	lsls	r3, r0, #19
   1730a:	d5b7      	bpl.n	1727c <prov_start+0x2c>
		memcpy(bt_mesh_prov_link.auth + 16 - bt_mesh_prov->static_val_len,
   1730c:	4d0e      	ldr	r5, [pc, #56]	; (17348 <prov_start+0xf8>)
   1730e:	4c0f      	ldr	r4, [pc, #60]	; (1734c <prov_start+0xfc>)
   17310:	682b      	ldr	r3, [r5, #0]
   17312:	7e1a      	ldrb	r2, [r3, #24]
   17314:	6959      	ldr	r1, [r3, #20]
   17316:	f1c2 0010 	rsb	r0, r2, #16
   1731a:	4420      	add	r0, r4
   1731c:	f010 faa8 	bl	27870 <memcpy>
			     sizeof(bt_mesh_prov_link.auth) - bt_mesh_prov->static_val_len);
   17320:	682b      	ldr	r3, [r5, #0]
   17322:	7e1a      	ldrb	r2, [r3, #24]
		(void)memset(bt_mesh_prov_link.auth, 0,
   17324:	2100      	movs	r1, #0
   17326:	f1c2 0210 	rsb	r2, r2, #16
   1732a:	4620      	mov	r0, r4
   1732c:	f010 faab 	bl	27886 <memset>
   17330:	e7a4      	b.n	1727c <prov_start+0x2c>
   17332:	bf00      	nop
   17334:	00033621 	.word	0x00033621
   17338:	0002db6c 	.word	0x0002db6c
   1733c:	0003363a 	.word	0x0003363a
   17340:	20002794 	.word	0x20002794
   17344:	0003365a 	.word	0x0003365a
   17348:	20002790 	.word	0x20002790
   1734c:	200027a3 	.word	0x200027a3

00017350 <prov_link_closed>:
	return bt_mesh_prov_reset_state(pub_key_ready);
   17350:	4801      	ldr	r0, [pc, #4]	; (17358 <prov_link_closed+0x8>)
   17352:	f7ff bb6f 	b.w	16a34 <bt_mesh_prov_reset_state>
   17356:	bf00      	nop
   17358:	000173c5 	.word	0x000173c5

0001735c <prov_pub_key>:
{
   1735c:	b510      	push	{r4, lr}
   1735e:	4601      	mov	r1, r0
   17360:	b088      	sub	sp, #32
	memcpy(bt_mesh_prov_link.conf_inputs.pub_key_provisioner, data, PDU_LEN_PUB_KEY);
   17362:	2240      	movs	r2, #64	; 0x40
   17364:	4813      	ldr	r0, [pc, #76]	; (173b4 <prov_pub_key+0x58>)
   17366:	f010 fa83 	bl	27870 <memcpy>
	} else if (!bt_pub_key_get()) {
   1736a:	f7f0 fe87 	bl	807c <bt_pub_key_get>
   1736e:	b9e0      	cbnz	r0, 173aa <prov_pub_key+0x4e>
		bt_mesh_prov_link.bearer->clear_tx();
   17370:	4c11      	ldr	r4, [pc, #68]	; (173b8 <prov_pub_key+0x5c>)
   17372:	6863      	ldr	r3, [r4, #4]
   17374:	68db      	ldr	r3, [r3, #12]
   17376:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   17378:	f3bf 8f5b 	dmb	ish
   1737c:	e854 3f00 	ldrex	r3, [r4]
   17380:	f043 0301 	orr.w	r3, r3, #1
   17384:	e844 3200 	strex	r2, r3, [r4]
   17388:	2a00      	cmp	r2, #0
   1738a:	d1f7      	bne.n	1737c <prov_pub_key+0x20>
   1738c:	f3bf 8f5b 	dmb	ish
		BT_WARN("Waiting for local public key");
   17390:	4b0a      	ldr	r3, [pc, #40]	; (173bc <prov_pub_key+0x60>)
   17392:	9306      	str	r3, [sp, #24]
   17394:	480a      	ldr	r0, [pc, #40]	; (173c0 <prov_pub_key+0x64>)
   17396:	2302      	movs	r3, #2
   17398:	aa05      	add	r2, sp, #20
   1739a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   1739e:	9301      	str	r3, [sp, #4]
   173a0:	9305      	str	r3, [sp, #20]
   173a2:	f013 f921 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
}
   173a6:	b008      	add	sp, #32
   173a8:	bd10      	pop	{r4, pc}
   173aa:	b008      	add	sp, #32
   173ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prov_dh_key_gen();
   173b0:	f7ff bf1c 	b.w	171ec <prov_dh_key_gen>
   173b4:	20002825 	.word	0x20002825
   173b8:	20002794 	.word	0x20002794
   173bc:	0003369e 	.word	0x0003369e
   173c0:	0002db6c 	.word	0x0002db6c

000173c4 <pub_key_ready>:
{
   173c4:	b500      	push	{lr}
   173c6:	b089      	sub	sp, #36	; 0x24
	if (!pkey) {
   173c8:	b968      	cbnz	r0, 173e6 <pub_key_ready+0x22>
		BT_WARN("Public key not available");
   173ca:	4b11      	ldr	r3, [pc, #68]	; (17410 <pub_key_ready+0x4c>)
   173cc:	9306      	str	r3, [sp, #24]
   173ce:	4811      	ldr	r0, [pc, #68]	; (17414 <pub_key_ready+0x50>)
   173d0:	2302      	movs	r3, #2
   173d2:	aa05      	add	r2, sp, #20
   173d4:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   173d8:	9301      	str	r3, [sp, #4]
   173da:	9305      	str	r3, [sp, #20]
   173dc:	f013 f904 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
}
   173e0:	b009      	add	sp, #36	; 0x24
   173e2:	f85d fb04 	ldr.w	pc, [sp], #4
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   173e6:	4b0c      	ldr	r3, [pc, #48]	; (17418 <pub_key_ready+0x54>)
   173e8:	f3bf 8f5b 	dmb	ish
   173ec:	e853 2f00 	ldrex	r2, [r3]
   173f0:	f022 0101 	bic.w	r1, r2, #1
   173f4:	e843 1000 	strex	r0, r1, [r3]
   173f8:	2800      	cmp	r0, #0
   173fa:	d1f7      	bne.n	173ec <pub_key_ready+0x28>
   173fc:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_mesh_prov_link.flags, WAIT_PUB_KEY)) {
   17400:	07d3      	lsls	r3, r2, #31
   17402:	d5ed      	bpl.n	173e0 <pub_key_ready+0x1c>
}
   17404:	b009      	add	sp, #36	; 0x24
   17406:	f85d eb04 	ldr.w	lr, [sp], #4
		prov_dh_key_gen();
   1740a:	f7ff beef 	b.w	171ec <prov_dh_key_gen>
   1740e:	bf00      	nop
   17410:	00033238 	.word	0x00033238
   17414:	0002db6c 	.word	0x0002db6c
   17418:	20002794 	.word	0x20002794

0001741c <public_key_sent>:
{
   1741c:	b508      	push	{r3, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1741e:	4b0b      	ldr	r3, [pc, #44]	; (1744c <public_key_sent+0x30>)
   17420:	f3bf 8f5b 	dmb	ish
   17424:	e853 2f00 	ldrex	r2, [r3]
   17428:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   1742c:	e843 2100 	strex	r1, r2, [r3]
   17430:	2900      	cmp	r1, #0
   17432:	d1f7      	bne.n	17424 <public_key_sent+0x8>
   17434:	f3bf 8f5b 	dmb	ish
   17438:	f7ff ff00 	bl	1723c <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh_prov_link.flags, INPUT_COMPLETE)) {
   1743c:	0583      	lsls	r3, r0, #22
   1743e:	d503      	bpl.n	17448 <public_key_sent+0x2c>
}
   17440:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_input_complete();
   17444:	f7ff be04 	b.w	17050 <send_input_complete>
}
   17448:	bd08      	pop	{r3, pc}
   1744a:	bf00      	nop
   1744c:	20002794 	.word	0x20002794

00017450 <local_input_complete>:
{
   17450:	b508      	push	{r3, lr}
   17452:	f7ff fef3 	bl	1723c <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh_prov_link.flags, PUB_KEY_SENT) ||
   17456:	0602      	lsls	r2, r0, #24
   17458:	d503      	bpl.n	17462 <local_input_complete+0x12>
}
   1745a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		send_input_complete();
   1745e:	f7ff bdf7 	b.w	17050 <send_input_complete>
   17462:	f7ff feeb 	bl	1723c <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh_prov_link.flags, PUB_KEY_SENT) ||
   17466:	0643      	lsls	r3, r0, #25
   17468:	d4f7      	bmi.n	1745a <local_input_complete+0xa>
   1746a:	f3bf 8f5b 	dmb	ish
   1746e:	4b06      	ldr	r3, [pc, #24]	; (17488 <local_input_complete+0x38>)
   17470:	e853 2f00 	ldrex	r2, [r3]
   17474:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   17478:	e843 2100 	strex	r1, r2, [r3]
   1747c:	2900      	cmp	r1, #0
   1747e:	d1f7      	bne.n	17470 <local_input_complete+0x20>
   17480:	f3bf 8f5b 	dmb	ish
}
   17484:	bd08      	pop	{r3, pc}
   17486:	bf00      	nop
   17488:	20002794 	.word	0x20002794

0001748c <prov_confirm>:
{
   1748c:	b510      	push	{r4, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1748e:	4c16      	ldr	r4, [pc, #88]	; (174e8 <prov_confirm+0x5c>)
   17490:	4601      	mov	r1, r0
	memcpy(bt_mesh_prov_link.conf, data, 16);
   17492:	2210      	movs	r2, #16
   17494:	4815      	ldr	r0, [pc, #84]	; (174ec <prov_confirm+0x60>)
   17496:	f010 f9eb 	bl	27870 <memcpy>
   1749a:	f3bf 8f5b 	dmb	ish
   1749e:	e854 2f00 	ldrex	r2, [r4]
   174a2:	f022 0310 	bic.w	r3, r2, #16
   174a6:	e844 3100 	strex	r1, r3, [r4]
   174aa:	2900      	cmp	r1, #0
   174ac:	d1f7      	bne.n	1749e <prov_confirm+0x12>
   174ae:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(bt_mesh_prov_link.flags,
   174b2:	06d2      	lsls	r2, r2, #27
   174b4:	d504      	bpl.n	174c0 <prov_confirm+0x34>
	    bt_mesh_prov->input_complete) {
   174b6:	4b0e      	ldr	r3, [pc, #56]	; (174f0 <prov_confirm+0x64>)
   174b8:	681b      	ldr	r3, [r3, #0]
   174ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
				      NOTIFY_INPUT_COMPLETE) &&
   174bc:	b103      	cbz	r3, 174c0 <prov_confirm+0x34>
		bt_mesh_prov->input_complete();
   174be:	4798      	blx	r3
   174c0:	f3bf 8f5b 	dmb	ish
   174c4:	e854 3f00 	ldrex	r3, [r4]
   174c8:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
   174cc:	e844 2100 	strex	r1, r2, [r4]
   174d0:	2900      	cmp	r1, #0
   174d2:	d1f7      	bne.n	174c4 <prov_confirm+0x38>
   174d4:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_clear_bit(bt_mesh_prov_link.flags, WAIT_DH_KEY)) {
   174d8:	049b      	lsls	r3, r3, #18
   174da:	d403      	bmi.n	174e4 <prov_confirm+0x58>
}
   174dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		send_confirm();
   174e0:	f7ff bcd8 	b.w	16e94 <send_confirm>
}
   174e4:	bd10      	pop	{r4, pc}
   174e6:	bf00      	nop
   174e8:	20002794 	.word	0x20002794
   174ec:	200027d4 	.word	0x200027d4
   174f0:	20002790 	.word	0x20002790

000174f4 <prov_dh_key_cb>:
{
   174f4:	b530      	push	{r4, r5, lr}
	if (!dhkey) {
   174f6:	4601      	mov	r1, r0
{
   174f8:	b09d      	sub	sp, #116	; 0x74
	if (!dhkey) {
   174fa:	b980      	cbnz	r0, 1751e <prov_dh_key_cb+0x2a>
		BT_ERR("DHKey generation failed");
   174fc:	4b40      	ldr	r3, [pc, #256]	; (17600 <prov_dh_key_cb+0x10c>)
   174fe:	930e      	str	r3, [sp, #56]	; 0x38
   17500:	4840      	ldr	r0, [pc, #256]	; (17604 <prov_dh_key_cb+0x110>)
   17502:	2302      	movs	r3, #2
   17504:	aa0d      	add	r2, sp, #52	; 0x34
   17506:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1750a:	9304      	str	r3, [sp, #16]
   1750c:	930d      	str	r3, [sp, #52]	; 0x34
   1750e:	f013 f86b 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   17512:	2007      	movs	r0, #7
}
   17514:	b01d      	add	sp, #116	; 0x74
   17516:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	prov_send_fail_msg(reason);
   1751a:	f7ff bbd1 	b.w	16cc0 <prov_send_fail_msg>
   1751e:	4d3a      	ldr	r5, [pc, #232]	; (17608 <prov_dh_key_cb+0x114>)
	sys_memcpy_swap(bt_mesh_prov_link.dhkey, dhkey, BT_DH_KEY_LEN);
   17520:	483a      	ldr	r0, [pc, #232]	; (1760c <prov_dh_key_cb+0x118>)
   17522:	f013 f866 	bl	2a5f2 <sys_memcpy_swap.constprop.0>
   17526:	f3bf 8f5b 	dmb	ish
   1752a:	e855 3f00 	ldrex	r3, [r5]
   1752e:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
   17532:	e845 2100 	strex	r1, r2, [r5]
   17536:	2900      	cmp	r1, #0
   17538:	d1f7      	bne.n	1752a <prov_dh_key_cb+0x36>
   1753a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_clear_bit(bt_mesh_prov_link.flags, WAIT_DH_KEY) &&
   1753e:	049c      	lsls	r4, r3, #18
   17540:	d408      	bmi.n	17554 <prov_dh_key_cb+0x60>
   17542:	f7ff fe7b 	bl	1723c <atomic_get.constprop.0>
   17546:	0640      	lsls	r0, r0, #25
   17548:	d504      	bpl.n	17554 <prov_dh_key_cb+0x60>
}
   1754a:	b01d      	add	sp, #116	; 0x74
   1754c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		send_confirm();
   17550:	f7ff bca0 	b.w	16e94 <send_confirm>
   17554:	f7ff fe72 	bl	1723c <atomic_get.constprop.0>
	} else if (!atomic_test_bit(bt_mesh_prov_link.flags, OOB_PUB_KEY)) {
   17558:	0641      	lsls	r1, r0, #25
   1755a:	d417      	bmi.n	1758c <prov_dh_key_cb+0x98>
	PROV_BUF(buf, PDU_LEN_PUB_KEY);
   1755c:	ab0a      	add	r3, sp, #40	; 0x28
   1755e:	f44f 028c 	mov.w	r2, #4587520	; 0x460000
   17562:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17566:	9301      	str	r3, [sp, #4]
	key = bt_pub_key_get();
   17568:	f7f0 fd88 	bl	807c <bt_pub_key_get>
	if (!key) {
   1756c:	4604      	mov	r4, r0
   1756e:	b978      	cbnz	r0, 17590 <prov_dh_key_cb+0x9c>
		BT_ERR("No public key available");
   17570:	4b27      	ldr	r3, [pc, #156]	; (17610 <prov_dh_key_cb+0x11c>)
   17572:	4824      	ldr	r0, [pc, #144]	; (17604 <prov_dh_key_cb+0x110>)
   17574:	9308      	str	r3, [sp, #32]
   17576:	aa07      	add	r2, sp, #28
   17578:	2302      	movs	r3, #2
   1757a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1757e:	9300      	str	r3, [sp, #0]
   17580:	9307      	str	r3, [sp, #28]
   17582:	f013 f831 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
	prov_send_fail_msg(reason);
   17586:	2007      	movs	r0, #7
   17588:	f7ff fb9a 	bl	16cc0 <prov_send_fail_msg>
}
   1758c:	b01d      	add	sp, #116	; 0x74
   1758e:	bd30      	pop	{r4, r5, pc}
	bt_mesh_prov_buf_init(&buf, PROV_PUB_KEY);
   17590:	2103      	movs	r1, #3
   17592:	a801      	add	r0, sp, #4
   17594:	f013 f81c 	bl	2a5d0 <bt_mesh_prov_buf_init>
	sys_memcpy_swap(net_buf_simple_add(&buf, BT_PUB_KEY_COORD_LEN), key, BT_PUB_KEY_COORD_LEN);
   17598:	2120      	movs	r1, #32
   1759a:	a801      	add	r0, sp, #4
   1759c:	f014 fbce 	bl	2bd3c <net_buf_simple_add>
   175a0:	4621      	mov	r1, r4
   175a2:	f013 f826 	bl	2a5f2 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(net_buf_simple_add(&buf, BT_PUB_KEY_COORD_LEN), &key[BT_PUB_KEY_COORD_LEN],
   175a6:	2120      	movs	r1, #32
   175a8:	a801      	add	r0, sp, #4
   175aa:	f014 fbc7 	bl	2bd3c <net_buf_simple_add>
   175ae:	f104 0120 	add.w	r1, r4, #32
   175b2:	f013 f81e 	bl	2a5f2 <sys_memcpy_swap.constprop.0>
	memcpy(bt_mesh_prov_link.conf_inputs.pub_key_device, &buf.data[1], PDU_LEN_PUB_KEY);
   175b6:	9901      	ldr	r1, [sp, #4]
   175b8:	4816      	ldr	r0, [pc, #88]	; (17614 <prov_dh_key_cb+0x120>)
   175ba:	3101      	adds	r1, #1
   175bc:	2240      	movs	r2, #64	; 0x40
   175be:	f010 f957 	bl	27870 <memcpy>
	if (bt_mesh_prov_send(&buf, public_key_sent)) {
   175c2:	4915      	ldr	r1, [pc, #84]	; (17618 <prov_dh_key_cb+0x124>)
   175c4:	a801      	add	r0, sp, #4
   175c6:	f7ff fb6b 	bl	16ca0 <bt_mesh_prov_send>
   175ca:	b158      	cbz	r0, 175e4 <prov_dh_key_cb+0xf0>
		BT_ERR("Failed to send Public Key");
   175cc:	4b13      	ldr	r3, [pc, #76]	; (1761c <prov_dh_key_cb+0x128>)
   175ce:	9308      	str	r3, [sp, #32]
   175d0:	480c      	ldr	r0, [pc, #48]	; (17604 <prov_dh_key_cb+0x110>)
   175d2:	2302      	movs	r3, #2
   175d4:	aa07      	add	r2, sp, #28
   175d6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   175da:	9300      	str	r3, [sp, #0]
   175dc:	9307      	str	r3, [sp, #28]
   175de:	f013 f803 	bl	2a5e8 <z_log_msg2_static_create.constprop.0>
		return;
   175e2:	e7d3      	b.n	1758c <prov_dh_key_cb+0x98>
   175e4:	f7ff fe2a 	bl	1723c <atomic_get.constprop.0>
	if (atomic_test_bit(bt_mesh_prov_link.flags, WAIT_NUMBER) ||
   175e8:	0742      	lsls	r2, r0, #29
   175ea:	d403      	bmi.n	175f4 <prov_dh_key_cb+0x100>
   175ec:	f7ff fe26 	bl	1723c <atomic_get.constprop.0>
   175f0:	0703      	lsls	r3, r0, #28
   175f2:	d503      	bpl.n	175fc <prov_dh_key_cb+0x108>
		bt_mesh_prov_link.expect = PROV_NO_PDU; /* Wait for input */
   175f4:	23ff      	movs	r3, #255	; 0xff
   175f6:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
   175fa:	e7c7      	b.n	1758c <prov_dh_key_cb+0x98>
		bt_mesh_prov_link.expect = PROV_CONFIRM;
   175fc:	2305      	movs	r3, #5
   175fe:	e7fa      	b.n	175f6 <prov_dh_key_cb+0x102>
   17600:	000336bb 	.word	0x000336bb
   17604:	0002db6c 	.word	0x0002db6c
   17608:	20002794 	.word	0x20002794
   1760c:	200027b3 	.word	0x200027b3
   17610:	000336d3 	.word	0x000336d3
   17614:	20002865 	.word	0x20002865
   17618:	0001741d 	.word	0x0001741d
   1761c:	000336eb 	.word	0x000336eb

00017620 <bt_mesh_prov_enable>:
		[PROV_DATA] = prov_data,
	},
};

int bt_mesh_prov_enable(bt_mesh_prov_bearer_t bearers)
{
   17620:	b530      	push	{r4, r5, lr}
   17622:	b08b      	sub	sp, #44	; 0x2c
   17624:	4605      	mov	r5, r0
	if (bt_mesh_is_provisioned()) {
   17626:	f7f4 f9cb 	bl	b9c0 <bt_mesh_is_provisioned>
   1762a:	4604      	mov	r4, r0
   1762c:	2800      	cmp	r0, #0
   1762e:	d132      	bne.n	17696 <bt_mesh_prov_enable+0x76>
		return -EALREADY;
	}

	if (IS_ENABLED(CONFIG_BT_DEBUG)) {
		struct bt_uuid_128 uuid = { .uuid = { BT_UUID_TYPE_128 } };
   17630:	4601      	mov	r1, r0
   17632:	2211      	movs	r2, #17
   17634:	a805      	add	r0, sp, #20
   17636:	f010 f926 	bl	27886 <memset>
   1763a:	2302      	movs	r3, #2
   1763c:	f88d 3014 	strb.w	r3, [sp, #20]

		memcpy(uuid.val, bt_mesh_prov->uuid, 16);
   17640:	4b16      	ldr	r3, [pc, #88]	; (1769c <bt_mesh_prov_enable+0x7c>)
   17642:	681b      	ldr	r3, [r3, #0]
   17644:	2210      	movs	r2, #16
   17646:	6819      	ldr	r1, [r3, #0]
   17648:	f10d 0015 	add.w	r0, sp, #21
   1764c:	f010 f910 	bl	27870 <memcpy>
		BT_INFO("Device UUID: %s", bt_uuid_str(&uuid.uuid));
   17650:	a805      	add	r0, sp, #20
   17652:	f7ed fde1 	bl	5218 <bt_uuid_str_real>
   17656:	4b12      	ldr	r3, [pc, #72]	; (176a0 <bt_mesh_prov_enable+0x80>)
   17658:	9002      	str	r0, [sp, #8]
   1765a:	e9cd 4300 	strd	r4, r3, [sp]
   1765e:	2203      	movs	r2, #3
   17660:	4910      	ldr	r1, [pc, #64]	; (176a4 <bt_mesh_prov_enable+0x84>)
   17662:	4623      	mov	r3, r4
   17664:	4620      	mov	r0, r4
   17666:	f7ff fdaf 	bl	171c8 <z_log_msg2_runtime_create.constprop.0>
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_ADV) &&
   1766a:	07ea      	lsls	r2, r5, #31
   1766c:	d505      	bpl.n	1767a <bt_mesh_prov_enable+0x5a>
	    (bearers & BT_MESH_PROV_ADV)) {
		pb_adv.link_accept(bt_mesh_prov_bearer_cb_get(), NULL);
   1766e:	f7ff fad3 	bl	16c18 <bt_mesh_prov_bearer_cb_get>
   17672:	4b0d      	ldr	r3, [pc, #52]	; (176a8 <bt_mesh_prov_enable+0x88>)
   17674:	4621      	mov	r1, r4
   17676:	685b      	ldr	r3, [r3, #4]
   17678:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_BT_MESH_PB_GATT) &&
   1767a:	07ab      	lsls	r3, r5, #30
   1767c:	d505      	bpl.n	1768a <bt_mesh_prov_enable+0x6a>
	    (bearers & BT_MESH_PROV_GATT)) {
		pb_gatt.link_accept(bt_mesh_prov_bearer_cb_get(), NULL);
   1767e:	f7ff facb 	bl	16c18 <bt_mesh_prov_bearer_cb_get>
   17682:	4b0a      	ldr	r3, [pc, #40]	; (176ac <bt_mesh_prov_enable+0x8c>)
   17684:	2100      	movs	r1, #0
   17686:	685b      	ldr	r3, [r3, #4]
   17688:	4798      	blx	r3
	}

	bt_mesh_prov_link.role = &role_device;
   1768a:	4b09      	ldr	r3, [pc, #36]	; (176b0 <bt_mesh_prov_enable+0x90>)
   1768c:	4a09      	ldr	r2, [pc, #36]	; (176b4 <bt_mesh_prov_enable+0x94>)
   1768e:	609a      	str	r2, [r3, #8]

	return 0;
   17690:	2000      	movs	r0, #0
}
   17692:	b00b      	add	sp, #44	; 0x2c
   17694:	bd30      	pop	{r4, r5, pc}
		return -EALREADY;
   17696:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1769a:	e7fa      	b.n	17692 <bt_mesh_prov_enable+0x72>
   1769c:	20002790 	.word	0x20002790
   176a0:	000335f8 	.word	0x000335f8
   176a4:	0002db6c 	.word	0x0002db6c
   176a8:	0002e7bc 	.word	0x0002e7bc
   176ac:	0002e7d4 	.word	0x0002e7d4
   176b0:	20002794 	.word	0x20002794
   176b4:	0002e75c 	.word	0x0002e75c

000176b8 <prov_failed>:
{
	return atomic_test_bit(link.flags, ADV_ACK_PENDING);
}

static void prov_failed(uint8_t err)
{
   176b8:	b510      	push	{r4, lr}
	BT_DBG("%u", err);
	link.cb->error(&pb_adv, link.cb_data, err);
   176ba:	4c06      	ldr	r4, [pc, #24]	; (176d4 <prov_failed+0x1c>)
   176bc:	68a3      	ldr	r3, [r4, #8]
   176be:	68e1      	ldr	r1, [r4, #12]
   176c0:	689b      	ldr	r3, [r3, #8]
{
   176c2:	4602      	mov	r2, r0
	link.cb->error(&pb_adv, link.cb_data, err);
   176c4:	4804      	ldr	r0, [pc, #16]	; (176d8 <prov_failed+0x20>)
   176c6:	4798      	blx	r3
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   176c8:	1d20      	adds	r0, r4, #4
   176ca:	2108      	movs	r1, #8
	atomic_set_bit(link.flags, ADV_LINK_INVALID);
}
   176cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   176d0:	f012 bf99 	b.w	2a606 <atomic_or>
   176d4:	200001d0 	.word	0x200001d0
   176d8:	0002e7bc 	.word	0x0002e7bc

000176dc <send_reliable>:
/*******************************************************************************
 * TX
 ******************************************************************************/

static void send_reliable(void)
{
   176dc:	b570      	push	{r4, r5, r6, lr}
   176de:	4d0c      	ldr	r5, [pc, #48]	; (17710 <send_reliable+0x34>)
	int i;

	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   176e0:	2400      	movs	r4, #0
		struct net_buf *buf = link.tx.buf[i];
   176e2:	f855 0b04 	ldr.w	r0, [r5], #4

		if (!buf) {
   176e6:	b150      	cbz	r0, 176fe <send_reliable+0x22>
			break;
		}

		if (BT_MESH_ADV(buf)->busy) {
   176e8:	6943      	ldr	r3, [r0, #20]
   176ea:	7a1a      	ldrb	r2, [r3, #8]
   176ec:	f012 0208 	ands.w	r2, r2, #8
   176f0:	d102      	bne.n	176f8 <send_reliable+0x1c>
			continue;
		}

		BT_DBG("%u bytes: %s", buf->len, bt_hex(buf->data, buf->len));

		bt_mesh_adv_send(buf, NULL, NULL);
   176f2:	4611      	mov	r1, r2
   176f4:	f7f4 fcb2 	bl	c05c <bt_mesh_adv_send>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   176f8:	3401      	adds	r4, #1
   176fa:	2c03      	cmp	r4, #3
   176fc:	d1f1      	bne.n	176e2 <send_reliable+0x6>
	}

	k_work_reschedule(&link.tx.retransmit, RETRANSMIT_TIMEOUT);
}
   176fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_reschedule(&link.tx.retransmit, RETRANSMIT_TIMEOUT);
   17702:	4804      	ldr	r0, [pc, #16]	; (17714 <send_reliable+0x38>)
   17704:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   17708:	2300      	movs	r3, #0
   1770a:	f00c be2b 	b.w	24364 <k_work_reschedule>
   1770e:	bf00      	nop
   17710:	200001f4 	.word	0x200001f4
   17714:	20000208 	.word	0x20000208

00017718 <free_segments>:
{
   17718:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   1771a:	2400      	movs	r4, #0
   1771c:	4d08      	ldr	r5, [pc, #32]	; (17740 <free_segments+0x28>)
		link.tx.buf[i] = NULL;
   1771e:	4626      	mov	r6, r4
		struct net_buf *buf = link.tx.buf[i];
   17720:	f855 0b04 	ldr.w	r0, [r5], #4
		if (!buf) {
   17724:	b158      	cbz	r0, 1773e <free_segments+0x26>
		BT_MESH_ADV(buf)->busy = 0U;
   17726:	6943      	ldr	r3, [r0, #20]
		link.tx.buf[i] = NULL;
   17728:	f845 6c04 	str.w	r6, [r5, #-4]
		BT_MESH_ADV(buf)->busy = 0U;
   1772c:	7a1a      	ldrb	r2, [r3, #8]
   1772e:	f366 02c3 	bfi	r2, r6, #3, #1
   17732:	721a      	strb	r2, [r3, #8]
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   17734:	3401      	adds	r4, #1
		net_buf_unref(buf);
   17736:	f009 f8ad 	bl	20894 <net_buf_unref>
	for (i = 0; i < ARRAY_SIZE(link.tx.buf); i++) {
   1773a:	2c03      	cmp	r4, #3
   1773c:	d1f0      	bne.n	17720 <free_segments+0x8>
}
   1773e:	bd70      	pop	{r4, r5, r6, pc}
   17740:	200001f4 	.word	0x200001f4

00017744 <prov_clear_tx>:
{
   17744:	b508      	push	{r3, lr}
	(void)k_work_cancel_delayable(&link.tx.retransmit);
   17746:	4803      	ldr	r0, [pc, #12]	; (17754 <prov_clear_tx+0x10>)
   17748:	f015 fb5d 	bl	2ce06 <k_work_cancel_delayable>
}
   1774c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	free_segments();
   17750:	f7ff bfe2 	b.w	17718 <free_segments>
   17754:	20000208 	.word	0x20000208

00017758 <bearer_ctl_send_unacked>:

	return 0;
}

static int bearer_ctl_send_unacked(struct net_buf *buf)
{
   17758:	b510      	push	{r4, lr}
	if (!buf) {
   1775a:	4604      	mov	r4, r0
   1775c:	b188      	cbz	r0, 17782 <bearer_ctl_send_unacked+0x2a>
		return -ENOMEM;
	}

	prov_clear_tx();
   1775e:	f7ff fff1 	bl	17744 <prov_clear_tx>
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   17762:	2300      	movs	r3, #0
   17764:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   17768:	4807      	ldr	r0, [pc, #28]	; (17788 <bearer_ctl_send_unacked+0x30>)
   1776a:	f00c fdfb 	bl	24364 <k_work_reschedule>

	bt_mesh_adv_send(buf, &buf_sent_cb, NULL);
   1776e:	4907      	ldr	r1, [pc, #28]	; (1778c <bearer_ctl_send_unacked+0x34>)
   17770:	2200      	movs	r2, #0
   17772:	4620      	mov	r0, r4
   17774:	f7f4 fc72 	bl	c05c <bt_mesh_adv_send>
	net_buf_unref(buf);
   17778:	4620      	mov	r0, r4
   1777a:	f009 f88b 	bl	20894 <net_buf_unref>

	return 0;
   1777e:	2000      	movs	r0, #0
}
   17780:	bd10      	pop	{r4, pc}
		return -ENOMEM;
   17782:	f06f 000b 	mvn.w	r0, #11
   17786:	e7fb      	b.n	17780 <bearer_ctl_send_unacked+0x28>
   17788:	20000238 	.word	0x20000238
   1778c:	200005e8 	.word	0x200005e8

00017790 <adv_buf_create>:
{
   17790:	b510      	push	{r4, lr}
	buf = bt_mesh_adv_create(BT_MESH_ADV_PROV, BT_MESH_LOCAL_ADV,
   17792:	f243 3234 	movw	r2, #13108	; 0x3334
{
   17796:	b08a      	sub	sp, #40	; 0x28
	buf = bt_mesh_adv_create(BT_MESH_ADV_PROV, BT_MESH_LOCAL_ADV,
   17798:	2300      	movs	r3, #0
   1779a:	e9cd 2300 	strd	r2, r3, [sp]
   1779e:	2101      	movs	r1, #1
   177a0:	f040 0208 	orr.w	r2, r0, #8
   177a4:	2000      	movs	r0, #0
   177a6:	f7f4 fbff 	bl	bfa8 <bt_mesh_adv_create>
	if (!buf) {
   177aa:	4604      	mov	r4, r0
   177ac:	b950      	cbnz	r0, 177c4 <adv_buf_create+0x34>
		BT_ERR("Out of provisioning buffers");
   177ae:	4b07      	ldr	r3, [pc, #28]	; (177cc <adv_buf_create+0x3c>)
   177b0:	9308      	str	r3, [sp, #32]
   177b2:	4807      	ldr	r0, [pc, #28]	; (177d0 <adv_buf_create+0x40>)
   177b4:	2302      	movs	r3, #2
   177b6:	aa07      	add	r2, sp, #28
   177b8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   177bc:	9303      	str	r3, [sp, #12]
   177be:	9307      	str	r3, [sp, #28]
   177c0:	f012 ff30 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   177c4:	4620      	mov	r0, r4
   177c6:	b00a      	add	sp, #40	; 0x28
   177c8:	bd10      	pop	{r4, pc}
   177ca:	bf00      	nop
   177cc:	00033719 	.word	0x00033719
   177d0:	0002db4c 	.word	0x0002db4c

000177d4 <atomic_get.constprop.0>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   177d4:	4b03      	ldr	r3, [pc, #12]	; (177e4 <atomic_get.constprop.0+0x10>)
   177d6:	f3bf 8f5b 	dmb	ish
   177da:	6858      	ldr	r0, [r3, #4]
   177dc:	f3bf 8f5b 	dmb	ish
}
   177e0:	4770      	bx	lr
   177e2:	bf00      	nop
   177e4:	200001d0 	.word	0x200001d0

000177e8 <prov_link_accept>:

	return bearer_ctl_send(ctl_buf_create(LINK_OPEN, uuid, 16, RETRANSMITS_RELIABLE));
}

static int prov_link_accept(const struct prov_bearer_cb *cb, void *cb_data)
{
   177e8:	b570      	push	{r4, r5, r6, lr}
   177ea:	b088      	sub	sp, #32
   177ec:	4606      	mov	r6, r0
   177ee:	460d      	mov	r5, r1
	int err;

	err = bt_mesh_adv_enable();
   177f0:	f7fd fc12 	bl	15018 <bt_mesh_adv_enable>
	if (err) {
   177f4:	4604      	mov	r4, r0
   177f6:	b168      	cbz	r0, 17814 <prov_link_accept+0x2c>
		BT_ERR("Failed enabling advertiser");
   177f8:	4b10      	ldr	r3, [pc, #64]	; (1783c <prov_link_accept+0x54>)
   177fa:	9306      	str	r3, [sp, #24]
   177fc:	4810      	ldr	r0, [pc, #64]	; (17840 <prov_link_accept+0x58>)
   177fe:	2302      	movs	r3, #2
   17800:	aa05      	add	r2, sp, #20
   17802:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17806:	9301      	str	r3, [sp, #4]
   17808:	9305      	str	r3, [sp, #20]
   1780a:	f012 ff0b 	bl	2a624 <z_log_msg2_static_create.constprop.0>
	bt_mesh_scan_enable();
	/* Enable unprovisioned beacon sending */
	bt_mesh_beacon_enable();

	return 0;
}
   1780e:	4620      	mov	r0, r4
   17810:	b008      	add	sp, #32
   17812:	bd70      	pop	{r4, r5, r6, pc}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17814:	f7ff ffde 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17818:	07c3      	lsls	r3, r0, #31
   1781a:	d40c      	bmi.n	17836 <prov_link_accept+0x4e>
	link.rx.id = XACT_ID_MAX;
   1781c:	4b09      	ldr	r3, [pc, #36]	; (17844 <prov_link_accept+0x5c>)
   1781e:	227f      	movs	r2, #127	; 0x7f
   17820:	741a      	strb	r2, [r3, #16]
	link.tx.id = XACT_ID_NVAL;
   17822:	22ff      	movs	r2, #255	; 0xff
	link.cb_data = cb_data;
   17824:	e9c3 6502 	strd	r6, r5, [r3, #8]
	link.tx.id = XACT_ID_NVAL;
   17828:	f883 2020 	strb.w	r2, [r3, #32]
	bt_mesh_scan_enable();
   1782c:	f7f4 fc2c 	bl	c088 <bt_mesh_scan_enable>
	bt_mesh_beacon_enable();
   17830:	f7f4 ff4a 	bl	c6c8 <bt_mesh_beacon_enable>
	return 0;
   17834:	e7eb      	b.n	1780e <prov_link_accept+0x26>
		return -EBUSY;
   17836:	f06f 040f 	mvn.w	r4, #15
   1783a:	e7e8      	b.n	1780e <prov_link_accept+0x26>
   1783c:	00030754 	.word	0x00030754
   17840:	0002db4c 	.word	0x0002db4c
   17844:	200001d0 	.word	0x200001d0

00017848 <gen_prov_ack>:
{
   17848:	b510      	push	{r4, lr}
	if (!link.tx.buf[0]) {
   1784a:	4c0b      	ldr	r4, [pc, #44]	; (17878 <gen_prov_ack+0x30>)
   1784c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1784e:	b18b      	cbz	r3, 17874 <gen_prov_ack+0x2c>
	if (rx->xact_id == link.tx.id) {
   17850:	7902      	ldrb	r2, [r0, #4]
   17852:	f894 3020 	ldrb.w	r3, [r4, #32]
   17856:	429a      	cmp	r2, r3
   17858:	d10c      	bne.n	17874 <gen_prov_ack+0x2c>
   1785a:	f7ff ffbb 	bl	177d4 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, ADV_LINK_CLOSING)) {
   1785e:	0743      	lsls	r3, r0, #29
   17860:	d401      	bmi.n	17866 <gen_prov_ack+0x1e>
			prov_clear_tx();
   17862:	f7ff ff6f 	bl	17744 <prov_clear_tx>
		if (link.tx.cb) {
   17866:	6b23      	ldr	r3, [r4, #48]	; 0x30
   17868:	b123      	cbz	r3, 17874 <gen_prov_ack+0x2c>
			link.tx.cb(0, link.tx.cb_data);
   1786a:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1786c:	2000      	movs	r0, #0
}
   1786e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			link.tx.cb(0, link.tx.cb_data);
   17872:	4718      	bx	r3
}
   17874:	bd10      	pop	{r4, pc}
   17876:	bf00      	nop
   17878:	200001d0 	.word	0x200001d0

0001787c <reset_adv_link>:
{
   1787c:	b510      	push	{r4, lr}
	(void)k_work_cancel_delayable(&link.prot_timer);
   1787e:	4c18      	ldr	r4, [pc, #96]	; (178e0 <reset_adv_link+0x64>)
	prov_clear_tx();
   17880:	f7ff ff60 	bl	17744 <prov_clear_tx>
	(void)k_work_cancel_delayable(&link.prot_timer);
   17884:	f104 0068 	add.w	r0, r4, #104	; 0x68
   17888:	f015 fabd 	bl	2ce06 <k_work_cancel_delayable>
   1788c:	f7ff ffa2 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_PROVISIONER)) {
   17890:	0683      	lsls	r3, r0, #26
   17892:	f3c0 1240 	ubfx	r2, r0, #5, #1
   17896:	d510      	bpl.n	178ba <reset_adv_link+0x3e>
		(void)memset(&link, 0, offsetof(struct pb_adv, tx.retransmit));
   17898:	2238      	movs	r2, #56	; 0x38
   1789a:	2100      	movs	r1, #0
   1789c:	4620      	mov	r0, r4
   1789e:	f00f fff2 	bl	27886 <memset>
		link.rx.id = XACT_ID_NVAL;
   178a2:	23ff      	movs	r3, #255	; 0xff
   178a4:	7423      	strb	r3, [r4, #16]
	link.tx.pending_ack = XACT_ID_NVAL;
   178a6:	23ff      	movs	r3, #255	; 0xff
   178a8:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	link.rx.buf = &rx_buf;
   178ac:	4b0d      	ldr	r3, [pc, #52]	; (178e4 <reset_adv_link+0x68>)
   178ae:	6163      	str	r3, [r4, #20]
	buf->len  = 0U;
   178b0:	2200      	movs	r2, #0
   178b2:	809a      	strh	r2, [r3, #4]
	buf->data = buf->__buf;
   178b4:	689a      	ldr	r2, [r3, #8]
   178b6:	601a      	str	r2, [r3, #0]
}
   178b8:	bd10      	pop	{r4, pc}
		link.id = 0;
   178ba:	4623      	mov	r3, r4
   178bc:	f843 2b04 	str.w	r2, [r3], #4
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   178c0:	f3bf 8f5b 	dmb	ish
   178c4:	e853 1f00 	ldrex	r1, [r3]
   178c8:	e843 2000 	strex	r0, r2, [r3]
   178cc:	2800      	cmp	r0, #0
   178ce:	d1f9      	bne.n	178c4 <reset_adv_link+0x48>
   178d0:	f3bf 8f5b 	dmb	ish
		link.rx.id = XACT_ID_MAX;
   178d4:	237f      	movs	r3, #127	; 0x7f
   178d6:	7423      	strb	r3, [r4, #16]
		link.tx.id = XACT_ID_NVAL;
   178d8:	23ff      	movs	r3, #255	; 0xff
   178da:	f884 3020 	strb.w	r3, [r4, #32]
   178de:	e7e2      	b.n	178a6 <reset_adv_link+0x2a>
   178e0:	200001d0 	.word	0x200001d0
   178e4:	200005f0 	.word	0x200005f0

000178e8 <close_link>:
{
   178e8:	b570      	push	{r4, r5, r6, lr}
	const struct prov_bearer_cb *cb = link.cb;
   178ea:	4b06      	ldr	r3, [pc, #24]	; (17904 <close_link+0x1c>)
	void *cb_data = link.cb_data;
   178ec:	e9d3 6502 	ldrd	r6, r5, [r3, #8]
{
   178f0:	4604      	mov	r4, r0
	reset_adv_link();
   178f2:	f7ff ffc3 	bl	1787c <reset_adv_link>
	cb->link_closed(&pb_adv, cb_data, reason);
   178f6:	6873      	ldr	r3, [r6, #4]
   178f8:	4803      	ldr	r0, [pc, #12]	; (17908 <close_link+0x20>)
   178fa:	4622      	mov	r2, r4
   178fc:	4629      	mov	r1, r5
}
   178fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cb->link_closed(&pb_adv, cb_data, reason);
   17902:	4718      	bx	r3
   17904:	200001d0 	.word	0x200001d0
   17908:	0002e7bc 	.word	0x0002e7bc

0001790c <ctl_buf_create>:
{
   1790c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17910:	4605      	mov	r5, r0
	buf = adv_buf_create(retransmits);
   17912:	4618      	mov	r0, r3
{
   17914:	460f      	mov	r7, r1
   17916:	4690      	mov	r8, r2
	buf = adv_buf_create(retransmits);
   17918:	f7ff ff3a 	bl	17790 <adv_buf_create>
	if (!buf) {
   1791c:	4604      	mov	r4, r0
   1791e:	b1b0      	cbz	r0, 1794e <ctl_buf_create+0x42>
	net_buf_add_be32(buf, link.id);
   17920:	4b0c      	ldr	r3, [pc, #48]	; (17954 <ctl_buf_create+0x48>)
	net_buf_simple_add_be32(&buf->b, val);
   17922:	f100 0608 	add.w	r6, r0, #8
   17926:	6819      	ldr	r1, [r3, #0]
   17928:	4630      	mov	r0, r6
	net_buf_add_u8(buf, GPC_CTL(op));
   1792a:	00ad      	lsls	r5, r5, #2
   1792c:	f014 fa3e 	bl	2bdac <net_buf_simple_add_be32>
   17930:	f045 0503 	orr.w	r5, r5, #3
	net_buf_add_u8(buf, 0x00);
   17934:	2100      	movs	r1, #0
   17936:	4620      	mov	r0, r4
   17938:	f012 fe77 	bl	2a62a <net_buf_add_u8.isra.0>
	net_buf_add_u8(buf, GPC_CTL(op));
   1793c:	b2e9      	uxtb	r1, r5
   1793e:	4620      	mov	r0, r4
   17940:	f012 fe73 	bl	2a62a <net_buf_add_u8.isra.0>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   17944:	4642      	mov	r2, r8
   17946:	4639      	mov	r1, r7
   17948:	4630      	mov	r0, r6
   1794a:	f014 f9fd 	bl	2bd48 <net_buf_simple_add_mem>
}
   1794e:	4620      	mov	r0, r4
   17950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17954:	200001d0 	.word	0x200001d0

00017958 <gen_prov_ctl>:
{
   17958:	b570      	push	{r4, r5, r6, lr}
	switch (BEARER_CTL(rx->gpc)) {
   1795a:	7942      	ldrb	r2, [r0, #5]
   1795c:	0892      	lsrs	r2, r2, #2
   1795e:	2a01      	cmp	r2, #1
{
   17960:	b088      	sub	sp, #32
   17962:	4605      	mov	r5, r0
	switch (BEARER_CTL(rx->gpc)) {
   17964:	d054      	beq.n	17a10 <gen_prov_ctl+0xb8>
   17966:	2a02      	cmp	r2, #2
   17968:	d067      	beq.n	17a3a <gen_prov_ctl+0xe2>
   1796a:	2a00      	cmp	r2, #0
   1796c:	d174      	bne.n	17a58 <gen_prov_ctl+0x100>
	if (buf->len < 16) {
   1796e:	888b      	ldrh	r3, [r1, #4]
   17970:	2b0f      	cmp	r3, #15
   17972:	d80d      	bhi.n	17990 <gen_prov_ctl+0x38>
		BT_ERR("Too short bearer open message (len %u)", buf->len);
   17974:	4a3a      	ldr	r2, [pc, #232]	; (17a60 <gen_prov_ctl+0x108>)
   17976:	e9cd 2306 	strd	r2, r3, [sp, #24]
		BT_ERR("Unknown bearer opcode: 0x%02x", BEARER_CTL(rx->gpc));
   1797a:	2303      	movs	r3, #3
   1797c:	4839      	ldr	r0, [pc, #228]	; (17a64 <gen_prov_ctl+0x10c>)
   1797e:	9301      	str	r3, [sp, #4]
   17980:	aa05      	add	r2, sp, #20
   17982:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   17986:	9305      	str	r3, [sp, #20]
   17988:	f012 fe4c 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   1798c:	b008      	add	sp, #32
   1798e:	bd70      	pop	{r4, r5, r6, pc}
   17990:	f7ff ff20 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17994:	07c4      	lsls	r4, r0, #31
   17996:	d50e      	bpl.n	179b6 <gen_prov_ctl+0x5e>
		if (link.id != rx->link_id) {
   17998:	4b33      	ldr	r3, [pc, #204]	; (17a68 <gen_prov_ctl+0x110>)
   1799a:	6819      	ldr	r1, [r3, #0]
   1799c:	682b      	ldr	r3, [r5, #0]
   1799e:	4299      	cmp	r1, r3
   179a0:	d1f4      	bne.n	1798c <gen_prov_ctl+0x34>
		(void)bearer_ctl_send_unacked(ctl_buf_create(LINK_ACK, NULL, 0, RETRANSMITS_ACK));
   179a2:	2302      	movs	r3, #2
   179a4:	4611      	mov	r1, r2
   179a6:	2001      	movs	r0, #1
   179a8:	f7ff ffb0 	bl	1790c <ctl_buf_create>
}
   179ac:	b008      	add	sp, #32
   179ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		(void)bearer_ctl_send_unacked(ctl_buf_create(LINK_ACK, NULL, 0, RETRANSMITS_ACK));
   179b2:	f7ff bed1 	b.w	17758 <bearer_ctl_send_unacked>
	if (memcmp(buf->data, bt_mesh_prov_get()->uuid, 16)) {
   179b6:	680c      	ldr	r4, [r1, #0]
   179b8:	f7ff f91c 	bl	16bf4 <bt_mesh_prov_get>
   179bc:	2210      	movs	r2, #16
   179be:	6801      	ldr	r1, [r0, #0]
   179c0:	4620      	mov	r0, r4
   179c2:	f00f ff44 	bl	2784e <memcmp>
   179c6:	4604      	mov	r4, r0
   179c8:	2800      	cmp	r0, #0
   179ca:	d1df      	bne.n	1798c <gen_prov_ctl+0x34>
	link.id = rx->link_id;
   179cc:	4e26      	ldr	r6, [pc, #152]	; (17a68 <gen_prov_ctl+0x110>)
   179ce:	682b      	ldr	r3, [r5, #0]
   179d0:	4630      	mov	r0, r6
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   179d2:	2101      	movs	r1, #1
   179d4:	f840 3b04 	str.w	r3, [r0], #4
   179d8:	f012 fe15 	bl	2a606 <atomic_or>
	net_buf_simple_reset(link.rx.buf);
   179dc:	6973      	ldr	r3, [r6, #20]
	buf->data = buf->__buf;
   179de:	689a      	ldr	r2, [r3, #8]
   179e0:	601a      	str	r2, [r3, #0]
	buf->len  = 0U;
   179e2:	809c      	strh	r4, [r3, #4]
	err = bearer_ctl_send_unacked(ctl_buf_create(LINK_ACK, NULL, 0, RETRANSMITS_ACK));
   179e4:	4622      	mov	r2, r4
   179e6:	2302      	movs	r3, #2
   179e8:	4621      	mov	r1, r4
   179ea:	2001      	movs	r0, #1
   179ec:	f7ff ff8e 	bl	1790c <ctl_buf_create>
   179f0:	f7ff feb2 	bl	17758 <bearer_ctl_send_unacked>
	if (err) {
   179f4:	b120      	cbz	r0, 17a00 <gen_prov_ctl+0xa8>
}
   179f6:	b008      	add	sp, #32
   179f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		reset_adv_link();
   179fc:	f7ff bf3e 	b.w	1787c <reset_adv_link>
	link.cb->link_opened(&pb_adv, link.cb_data);
   17a00:	68b3      	ldr	r3, [r6, #8]
   17a02:	68f1      	ldr	r1, [r6, #12]
   17a04:	681b      	ldr	r3, [r3, #0]
		link.cb->link_opened(&pb_adv, link.cb_data);
   17a06:	4819      	ldr	r0, [pc, #100]	; (17a6c <gen_prov_ctl+0x114>)
}
   17a08:	b008      	add	sp, #32
   17a0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		link.cb->link_opened(&pb_adv, link.cb_data);
   17a0e:	4718      	bx	r3
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17a10:	f7ff fee0 	bl	177d4 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17a14:	07c0      	lsls	r0, r0, #31
   17a16:	d5b9      	bpl.n	1798c <gen_prov_ctl+0x34>
   17a18:	f7ff fedc 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_PROVISIONER)) {
   17a1c:	0681      	lsls	r1, r0, #26
   17a1e:	d5b5      	bpl.n	1798c <gen_prov_ctl+0x34>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   17a20:	4c11      	ldr	r4, [pc, #68]	; (17a68 <gen_prov_ctl+0x110>)
   17a22:	2102      	movs	r1, #2
   17a24:	1d20      	adds	r0, r4, #4
   17a26:	f012 fdee 	bl	2a606 <atomic_or>
		if (atomic_test_and_set_bit(link.flags, ADV_LINK_ACK_RECVD)) {
   17a2a:	0782      	lsls	r2, r0, #30
   17a2c:	d4ae      	bmi.n	1798c <gen_prov_ctl+0x34>
		prov_clear_tx();
   17a2e:	f7ff fe89 	bl	17744 <prov_clear_tx>
		link.cb->link_opened(&pb_adv, link.cb_data);
   17a32:	68a3      	ldr	r3, [r4, #8]
   17a34:	68e1      	ldr	r1, [r4, #12]
   17a36:	681b      	ldr	r3, [r3, #0]
   17a38:	e7e5      	b.n	17a06 <gen_prov_ctl+0xae>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17a3a:	f7ff fecb 	bl	177d4 <atomic_get.constprop.0>
		if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17a3e:	07c3      	lsls	r3, r0, #31
   17a40:	d5a4      	bpl.n	1798c <gen_prov_ctl+0x34>
	if (buf->len != 1) {
   17a42:	888b      	ldrh	r3, [r1, #4]
   17a44:	2b01      	cmp	r3, #1
   17a46:	d1a1      	bne.n	1798c <gen_prov_ctl+0x34>
	close_link(net_buf_simple_pull_u8(buf));
   17a48:	4608      	mov	r0, r1
   17a4a:	f014 f9f7 	bl	2be3c <net_buf_simple_pull_u8>
}
   17a4e:	b008      	add	sp, #32
   17a50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	close_link(net_buf_simple_pull_u8(buf));
   17a54:	f7ff bf48 	b.w	178e8 <close_link>
		BT_ERR("Unknown bearer opcode: 0x%02x", BEARER_CTL(rx->gpc));
   17a58:	4b05      	ldr	r3, [pc, #20]	; (17a70 <gen_prov_ctl+0x118>)
	switch (BEARER_CTL(rx->gpc)) {
   17a5a:	e9cd 3206 	strd	r3, r2, [sp, #24]
   17a5e:	e78c      	b.n	1797a <gen_prov_ctl+0x22>
   17a60:	00033735 	.word	0x00033735
   17a64:	0002db4c 	.word	0x0002db4c
   17a68:	200001d0 	.word	0x200001d0
   17a6c:	0002e7bc 	.word	0x0002e7bc
   17a70:	0003375c 	.word	0x0003375c

00017a74 <prov_link_close>:

static void prov_link_close(enum prov_bearer_link_status status)
{
   17a74:	b507      	push	{r0, r1, r2, lr}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   17a76:	2104      	movs	r1, #4
   17a78:	f88d 0007 	strb.w	r0, [sp, #7]
   17a7c:	4808      	ldr	r0, [pc, #32]	; (17aa0 <prov_link_close+0x2c>)
   17a7e:	f012 fdc2 	bl	2a606 <atomic_or>
	if (atomic_test_and_set_bit(link.flags, ADV_LINK_CLOSING)) {
   17a82:	0743      	lsls	r3, r0, #29
   17a84:	d408      	bmi.n	17a98 <prov_link_close+0x24>
		return;
	}

	/* Ignore errors, the link will time out eventually if this doesn't get sent */
	bearer_ctl_send_unacked(ctl_buf_create(LINK_CLOSE, &status, 1, RETRANSMITS_LINK_CLOSE));
   17a86:	2302      	movs	r3, #2
   17a88:	2201      	movs	r2, #1
   17a8a:	f10d 0107 	add.w	r1, sp, #7
   17a8e:	4618      	mov	r0, r3
   17a90:	f7ff ff3c 	bl	1790c <ctl_buf_create>
   17a94:	f7ff fe60 	bl	17758 <bearer_ctl_send_unacked>
}
   17a98:	b003      	add	sp, #12
   17a9a:	f85d fb04 	ldr.w	pc, [sp], #4
   17a9e:	bf00      	nop
   17aa0:	200001d4 	.word	0x200001d4

00017aa4 <protocol_timeout>:
{
   17aa4:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17aa6:	f7ff fe95 	bl	177d4 <atomic_get.constprop.0>
	if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17aaa:	07c3      	lsls	r3, r0, #31
   17aac:	d507      	bpl.n	17abe <protocol_timeout+0x1a>
	link.rx.seg = 0U;
   17aae:	4b04      	ldr	r3, [pc, #16]	; (17ac0 <protocol_timeout+0x1c>)
   17ab0:	2200      	movs	r2, #0
   17ab2:	745a      	strb	r2, [r3, #17]
}
   17ab4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	prov_link_close(PROV_BEARER_LINK_STATUS_TIMEOUT);
   17ab8:	2001      	movs	r0, #1
   17aba:	f7ff bfdb 	b.w	17a74 <prov_link_close>
}
   17abe:	bd08      	pop	{r3, pc}
   17ac0:	200001d0 	.word	0x200001d0

00017ac4 <prov_retransmit>:
{
   17ac4:	b510      	push	{r4, lr}
   17ac6:	b088      	sub	sp, #32
   17ac8:	f7ff fe84 	bl	177d4 <atomic_get.constprop.0>
	if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE)) {
   17acc:	07c3      	lsls	r3, r0, #31
   17ace:	d40c      	bmi.n	17aea <prov_retransmit+0x26>
		BT_WARN("Link not active");
   17ad0:	4b1d      	ldr	r3, [pc, #116]	; (17b48 <prov_retransmit+0x84>)
   17ad2:	9306      	str	r3, [sp, #24]
   17ad4:	481d      	ldr	r0, [pc, #116]	; (17b4c <prov_retransmit+0x88>)
   17ad6:	2302      	movs	r3, #2
   17ad8:	aa05      	add	r2, sp, #20
   17ada:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   17ade:	9301      	str	r3, [sp, #4]
   17ae0:	9305      	str	r3, [sp, #20]
   17ae2:	f012 fd9f 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   17ae6:	b008      	add	sp, #32
   17ae8:	bd10      	pop	{r4, pc}
   17aea:	f015 fb31 	bl	2d150 <z_impl_k_uptime_ticks>
   17aee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   17af2:	fba0 0302 	umull	r0, r3, r0, r2
   17af6:	fb02 3101 	mla	r1, r2, r1, r3
	if (k_uptime_get() - link.tx.start > TRANSACTION_TIMEOUT) {
   17afa:	4a15      	ldr	r2, [pc, #84]	; (17b50 <prov_retransmit+0x8c>)
   17afc:	e9d2 3206 	ldrd	r3, r2, [r2, #24]
   17b00:	0bc0      	lsrs	r0, r0, #15
   17b02:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   17b06:	1ac0      	subs	r0, r0, r3
   17b08:	ea4f 31d1 	mov.w	r1, r1, lsr #15
   17b0c:	f247 5331 	movw	r3, #30001	; 0x7531
   17b10:	eb61 0102 	sbc.w	r1, r1, r2
   17b14:	4298      	cmp	r0, r3
   17b16:	f171 0300 	sbcs.w	r3, r1, #0
   17b1a:	db10      	blt.n	17b3e <prov_retransmit+0x7a>
		BT_WARN("Giving up transaction");
   17b1c:	2402      	movs	r4, #2
   17b1e:	4b0d      	ldr	r3, [pc, #52]	; (17b54 <prov_retransmit+0x90>)
   17b20:	480a      	ldr	r0, [pc, #40]	; (17b4c <prov_retransmit+0x88>)
   17b22:	9306      	str	r3, [sp, #24]
   17b24:	aa05      	add	r2, sp, #20
   17b26:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   17b2a:	9401      	str	r4, [sp, #4]
   17b2c:	9405      	str	r4, [sp, #20]
   17b2e:	f012 fd79 	bl	2a624 <z_log_msg2_static_create.constprop.0>
		prov_link_close(PROV_BEARER_LINK_STATUS_FAIL);
   17b32:	4620      	mov	r0, r4
}
   17b34:	b008      	add	sp, #32
   17b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		prov_link_close(PROV_BEARER_LINK_STATUS_FAIL);
   17b3a:	f7ff bf9b 	b.w	17a74 <prov_link_close>
}
   17b3e:	b008      	add	sp, #32
   17b40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	send_reliable();
   17b44:	f7ff bdca 	b.w	176dc <send_reliable>
   17b48:	0003377a 	.word	0x0003377a
   17b4c:	0002db4c 	.word	0x0002db4c
   17b50:	200001d0 	.word	0x200001d0
   17b54:	0003378a 	.word	0x0003378a

00017b58 <gen_prov_ack_send>:
{
   17b58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   17b5a:	4e1e      	ldr	r6, [pc, #120]	; (17bd4 <gen_prov_ack_send+0x7c>)
   17b5c:	2110      	movs	r1, #16
   17b5e:	4605      	mov	r5, r0
   17b60:	1d30      	adds	r0, r6, #4
   17b62:	f012 fd50 	bl	2a606 <atomic_or>
	if (pending && link.tx.pending_ack == xact_id) {
   17b66:	ea10 0701 	ands.w	r7, r0, r1
   17b6a:	d003      	beq.n	17b74 <gen_prov_ack_send+0x1c>
   17b6c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   17b70:	42ab      	cmp	r3, r5
   17b72:	d011      	beq.n	17b98 <gen_prov_ack_send+0x40>
	buf = adv_buf_create(RETRANSMITS_ACK);
   17b74:	2002      	movs	r0, #2
   17b76:	f7ff fe0b 	bl	17790 <adv_buf_create>
	if (!buf) {
   17b7a:	4604      	mov	r4, r0
   17b7c:	b968      	cbnz	r0, 17b9a <gen_prov_ack_send+0x42>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   17b7e:	4b16      	ldr	r3, [pc, #88]	; (17bd8 <gen_prov_ack_send+0x80>)
   17b80:	f3bf 8f5b 	dmb	ish
   17b84:	e853 2f00 	ldrex	r2, [r3]
   17b88:	f022 0210 	bic.w	r2, r2, #16
   17b8c:	e843 2100 	strex	r1, r2, [r3]
   17b90:	2900      	cmp	r1, #0
   17b92:	d1f7      	bne.n	17b84 <gen_prov_ack_send+0x2c>
   17b94:	f3bf 8f5b 	dmb	ish
}
   17b98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (pending) {
   17b9a:	b9cf      	cbnz	r7, 17bd0 <gen_prov_ack_send+0x78>
		complete = &cb;
   17b9c:	4f0f      	ldr	r7, [pc, #60]	; (17bdc <gen_prov_ack_send+0x84>)
		link.tx.pending_ack = xact_id;
   17b9e:	f886 5021 	strb.w	r5, [r6, #33]	; 0x21
	net_buf_simple_add_be32(&buf->b, val);
   17ba2:	6831      	ldr	r1, [r6, #0]
   17ba4:	f104 0008 	add.w	r0, r4, #8
   17ba8:	f014 f900 	bl	2bdac <net_buf_simple_add_be32>
	net_buf_add_u8(buf, xact_id);
   17bac:	4629      	mov	r1, r5
   17bae:	4620      	mov	r0, r4
   17bb0:	f012 fd3b 	bl	2a62a <net_buf_add_u8.isra.0>
	net_buf_add_u8(buf, GPC_ACK);
   17bb4:	4620      	mov	r0, r4
   17bb6:	2101      	movs	r1, #1
   17bb8:	f012 fd37 	bl	2a62a <net_buf_add_u8.isra.0>
	bt_mesh_adv_send(buf, complete, NULL);
   17bbc:	4620      	mov	r0, r4
   17bbe:	4639      	mov	r1, r7
   17bc0:	2200      	movs	r2, #0
   17bc2:	f7f4 fa4b 	bl	c05c <bt_mesh_adv_send>
	net_buf_unref(buf);
   17bc6:	4620      	mov	r0, r4
}
   17bc8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	net_buf_unref(buf);
   17bcc:	f008 be62 	b.w	20894 <net_buf_unref>
		complete = NULL;
   17bd0:	2700      	movs	r7, #0
   17bd2:	e7e6      	b.n	17ba2 <gen_prov_ack_send+0x4a>
   17bd4:	200001d0 	.word	0x200001d0
   17bd8:	200001d4 	.word	0x200001d4
   17bdc:	0002e794 	.word	0x0002e794

00017be0 <prov_msg_recv>:
{
   17be0:	b510      	push	{r4, lr}
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   17be2:	4c20      	ldr	r4, [pc, #128]	; (17c64 <prov_msg_recv+0x84>)
{
   17be4:	b088      	sub	sp, #32
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   17be6:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   17bea:	2300      	movs	r3, #0
   17bec:	f104 0068 	add.w	r0, r4, #104	; 0x68
   17bf0:	f00c fbb8 	bl	24364 <k_work_reschedule>
	if (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {
   17bf4:	7ce1      	ldrb	r1, [r4, #19]
   17bf6:	6960      	ldr	r0, [r4, #20]
   17bf8:	f7f8 fcba 	bl	10570 <bt_mesh_fcs_check>
   17bfc:	b960      	cbnz	r0, 17c18 <prov_msg_recv+0x38>
		BT_ERR("Incorrect FCS");
   17bfe:	4b1a      	ldr	r3, [pc, #104]	; (17c68 <prov_msg_recv+0x88>)
   17c00:	9306      	str	r3, [sp, #24]
   17c02:	481a      	ldr	r0, [pc, #104]	; (17c6c <prov_msg_recv+0x8c>)
   17c04:	2302      	movs	r3, #2
   17c06:	aa05      	add	r2, sp, #20
   17c08:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17c0c:	9301      	str	r3, [sp, #4]
   17c0e:	9305      	str	r3, [sp, #20]
   17c10:	f012 fd08 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   17c14:	b008      	add	sp, #32
   17c16:	bd10      	pop	{r4, pc}
	gen_prov_ack_send(link.rx.id);
   17c18:	7c20      	ldrb	r0, [r4, #16]
   17c1a:	f7ff ff9d 	bl	17b58 <gen_prov_ack_send>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   17c1e:	f7ff fdd9 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {
   17c22:	0703      	lsls	r3, r0, #28
   17c24:	d514      	bpl.n	17c50 <prov_msg_recv+0x70>
		BT_WARN("Unexpected msg 0x%02x on invalidated link",
   17c26:	6963      	ldr	r3, [r4, #20]
   17c28:	4a11      	ldr	r2, [pc, #68]	; (17c70 <prov_msg_recv+0x90>)
   17c2a:	9206      	str	r2, [sp, #24]
   17c2c:	681b      	ldr	r3, [r3, #0]
   17c2e:	480f      	ldr	r0, [pc, #60]	; (17c6c <prov_msg_recv+0x8c>)
   17c30:	781b      	ldrb	r3, [r3, #0]
   17c32:	9307      	str	r3, [sp, #28]
   17c34:	2403      	movs	r4, #3
   17c36:	aa05      	add	r2, sp, #20
   17c38:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   17c3c:	9401      	str	r4, [sp, #4]
   17c3e:	9405      	str	r4, [sp, #20]
   17c40:	f012 fcf0 	bl	2a624 <z_log_msg2_static_create.constprop.0>
		prov_failed(PROV_ERR_UNEXP_PDU);
   17c44:	4620      	mov	r0, r4
}
   17c46:	b008      	add	sp, #32
   17c48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		prov_failed(PROV_ERR_UNEXP_PDU);
   17c4c:	f7ff bd34 	b.w	176b8 <prov_failed>
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
   17c50:	68a3      	ldr	r3, [r4, #8]
   17c52:	6962      	ldr	r2, [r4, #20]
   17c54:	68db      	ldr	r3, [r3, #12]
   17c56:	68e1      	ldr	r1, [r4, #12]
   17c58:	4806      	ldr	r0, [pc, #24]	; (17c74 <prov_msg_recv+0x94>)
}
   17c5a:	b008      	add	sp, #32
   17c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	link.cb->recv(&pb_adv, link.cb_data, link.rx.buf);
   17c60:	4718      	bx	r3
   17c62:	bf00      	nop
   17c64:	200001d0 	.word	0x200001d0
   17c68:	000337a0 	.word	0x000337a0
   17c6c:	0002db4c 	.word	0x0002db4c
   17c70:	000337ae 	.word	0x000337ae
   17c74:	0002e7bc 	.word	0x0002e7bc

00017c78 <gen_prov_cont>:
{
   17c78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   17c7c:	4d4a      	ldr	r5, [pc, #296]	; (17da8 <gen_prov_cont+0x130>)
{
   17c7e:	b088      	sub	sp, #32
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   17c80:	7c6c      	ldrb	r4, [r5, #17]
	uint8_t seg = CONT_SEG_INDEX(rx->gpc);
   17c82:	f890 8005 	ldrb.w	r8, [r0, #5]
{
   17c86:	4602      	mov	r2, r0
   17c88:	460e      	mov	r6, r1
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   17c8a:	7900      	ldrb	r0, [r0, #4]
   17c8c:	7c29      	ldrb	r1, [r5, #16]
{
   17c8e:	af00      	add	r7, sp, #0
	if (!link.rx.seg && link.rx.id == rx->xact_id) {
   17c90:	2c00      	cmp	r4, #0
   17c92:	d135      	bne.n	17d00 <gen_prov_cont+0x88>
   17c94:	4281      	cmp	r1, r0
   17c96:	d10a      	bne.n	17cae <gen_prov_cont+0x36>
   17c98:	f7ff fd9c 	bl	177d4 <atomic_get.constprop.0>
		if (!ack_pending()) {
   17c9c:	06c0      	lsls	r0, r0, #27
   17c9e:	d402      	bmi.n	17ca6 <gen_prov_cont+0x2e>
			gen_prov_ack_send(rx->xact_id);
   17ca0:	7910      	ldrb	r0, [r2, #4]
   17ca2:	f7ff ff59 	bl	17b58 <gen_prov_ack_send>
}
   17ca6:	3720      	adds	r7, #32
   17ca8:	46bd      	mov	sp, r7
   17caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (((id + 1) & XACT_ID_MAX) | (id & (XACT_ID_MAX+1)));
   17cae:	1c4b      	adds	r3, r1, #1
   17cb0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   17cb4:	f021 027f 	bic.w	r2, r1, #127	; 0x7f
	if (!link.rx.seg &&
   17cb8:	4313      	orrs	r3, r2
   17cba:	4283      	cmp	r3, r0
   17cbc:	d122      	bne.n	17d04 <gen_prov_cont+0x8c>
		link.rx.id = rx->xact_id;
   17cbe:	742b      	strb	r3, [r5, #16]
		net_buf_simple_reset(link.rx.buf);
   17cc0:	696b      	ldr	r3, [r5, #20]
	buf->data = buf->__buf;
   17cc2:	689a      	ldr	r2, [r3, #8]
	buf->len  = 0U;
   17cc4:	809c      	strh	r4, [r3, #4]
	buf->data = buf->__buf;
   17cc6:	601a      	str	r2, [r3, #0]
		link.rx.seg = SEG_NVAL;
   17cc8:	23ff      	movs	r3, #255	; 0xff
   17cca:	746b      	strb	r3, [r5, #17]
		link.rx.last_seg = SEG_NVAL;
   17ccc:	74ab      	strb	r3, [r5, #18]
		prov_clear_tx();
   17cce:	f7ff fd39 	bl	17744 <prov_clear_tx>
	if (seg > link.rx.last_seg) {
   17cd2:	7cab      	ldrb	r3, [r5, #18]
   17cd4:	ebb3 0f98 	cmp.w	r3, r8, lsr #2
	uint8_t seg = CONT_SEG_INDEX(rx->gpc);
   17cd8:	ea4f 0498 	mov.w	r4, r8, lsr #2
	if (seg > link.rx.last_seg) {
   17cdc:	d224      	bcs.n	17d28 <gen_prov_cont+0xb0>
		BT_ERR("Invalid segment index %u", seg);
   17cde:	4b33      	ldr	r3, [pc, #204]	; (17dac <gen_prov_cont+0x134>)
   17ce0:	4833      	ldr	r0, [pc, #204]	; (17db0 <gen_prov_cont+0x138>)
   17ce2:	e9c7 3406 	strd	r3, r4, [r7, #24]
   17ce6:	f107 0214 	add.w	r2, r7, #20
   17cea:	2303      	movs	r3, #3
   17cec:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   17cf0:	607b      	str	r3, [r7, #4]
   17cf2:	617b      	str	r3, [r7, #20]
   17cf4:	f012 fc96 	bl	2a624 <z_log_msg2_static_create.constprop.0>
			prov_failed(PROV_ERR_NVAL_FMT);
   17cf8:	2002      	movs	r0, #2
   17cfa:	f7ff fcdd 	bl	176b8 <prov_failed>
			return;
   17cfe:	e7d2      	b.n	17ca6 <gen_prov_cont+0x2e>
	} else if (rx->xact_id != link.rx.id) {
   17d00:	4281      	cmp	r1, r0
   17d02:	d0e6      	beq.n	17cd2 <gen_prov_cont+0x5a>
		BT_WARN("Data for unknown transaction (0x%x != 0x%x)",
   17d04:	4b2b      	ldr	r3, [pc, #172]	; (17db4 <gen_prov_cont+0x13c>)
   17d06:	466c      	mov	r4, sp
   17d08:	b088      	sub	sp, #32
   17d0a:	466a      	mov	r2, sp
   17d0c:	e9c2 3004 	strd	r3, r0, [r2, #16]
   17d10:	2304      	movs	r3, #4
   17d12:	6191      	str	r1, [r2, #24]
   17d14:	4826      	ldr	r0, [pc, #152]	; (17db0 <gen_prov_cont+0x138>)
   17d16:	f842 3f0c 	str.w	r3, [r2, #12]!
   17d1a:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   17d1e:	60bb      	str	r3, [r7, #8]
   17d20:	f012 fc80 	bl	2a624 <z_log_msg2_static_create.constprop.0>
   17d24:	46a5      	mov	sp, r4
		return;
   17d26:	e7be      	b.n	17ca6 <gen_prov_cont+0x2e>
	if (!(link.rx.seg & BIT(seg))) {
   17d28:	7c6b      	ldrb	r3, [r5, #17]
   17d2a:	40e3      	lsrs	r3, r4
   17d2c:	07d9      	lsls	r1, r3, #31
   17d2e:	d5ba      	bpl.n	17ca6 <gen_prov_cont+0x2e>
	memcpy(XACT_SEG_DATA(seg), buf->data, buf->len);
   17d30:	696a      	ldr	r2, [r5, #20]
   17d32:	6831      	ldr	r1, [r6, #0]
   17d34:	2017      	movs	r0, #23
   17d36:	1e63      	subs	r3, r4, #1
   17d38:	4343      	muls	r3, r0
   17d3a:	6810      	ldr	r0, [r2, #0]
   17d3c:	88b2      	ldrh	r2, [r6, #4]
   17d3e:	3314      	adds	r3, #20
   17d40:	4418      	add	r0, r3
   17d42:	f00f fd95 	bl	27870 <memcpy>
	XACT_SEG_RECV(seg);
   17d46:	7c6a      	ldrb	r2, [r5, #17]
   17d48:	2301      	movs	r3, #1
   17d4a:	40a3      	lsls	r3, r4
   17d4c:	ea22 0303 	bic.w	r3, r2, r3
	if (seg == link.rx.last_seg && !(link.rx.seg & BIT(0))) {
   17d50:	7caa      	ldrb	r2, [r5, #18]
	XACT_SEG_RECV(seg);
   17d52:	746b      	strb	r3, [r5, #17]
	if (seg == link.rx.last_seg && !(link.rx.seg & BIT(0))) {
   17d54:	4294      	cmp	r4, r2
   17d56:	d121      	bne.n	17d9c <gen_prov_cont+0x124>
   17d58:	07da      	lsls	r2, r3, #31
   17d5a:	d4a4      	bmi.n	17ca6 <gen_prov_cont+0x2e>
		expect_len = (link.rx.buf->len - 20U -
   17d5c:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
   17d60:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   17d64:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
   17d68:	696a      	ldr	r2, [r5, #20]
		if (expect_len != buf->len) {
   17d6a:	88b1      	ldrh	r1, [r6, #4]
		expect_len = (link.rx.buf->len - 20U -
   17d6c:	8892      	ldrh	r2, [r2, #4]
   17d6e:	3403      	adds	r4, #3
   17d70:	4414      	add	r4, r2
   17d72:	b2e0      	uxtb	r0, r4
		if (expect_len != buf->len) {
   17d74:	4288      	cmp	r0, r1
   17d76:	d011      	beq.n	17d9c <gen_prov_cont+0x124>
			BT_ERR("Incorrect last seg len: %u != %u", expect_len,
   17d78:	4b0f      	ldr	r3, [pc, #60]	; (17db8 <gen_prov_cont+0x140>)
   17d7a:	466c      	mov	r4, sp
   17d7c:	b088      	sub	sp, #32
   17d7e:	466a      	mov	r2, sp
   17d80:	e9c2 3004 	strd	r3, r0, [r2, #16]
   17d84:	2304      	movs	r3, #4
   17d86:	6191      	str	r1, [r2, #24]
   17d88:	4809      	ldr	r0, [pc, #36]	; (17db0 <gen_prov_cont+0x138>)
   17d8a:	f842 3f0c 	str.w	r3, [r2, #12]!
   17d8e:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   17d92:	60bb      	str	r3, [r7, #8]
   17d94:	f012 fc46 	bl	2a624 <z_log_msg2_static_create.constprop.0>
   17d98:	46a5      	mov	sp, r4
   17d9a:	e7ad      	b.n	17cf8 <gen_prov_cont+0x80>
	if (!link.rx.seg) {
   17d9c:	2b00      	cmp	r3, #0
   17d9e:	d182      	bne.n	17ca6 <gen_prov_cont+0x2e>
		prov_msg_recv();
   17da0:	f7ff ff1e 	bl	17be0 <prov_msg_recv>
   17da4:	e77f      	b.n	17ca6 <gen_prov_cont+0x2e>
   17da6:	bf00      	nop
   17da8:	200001d0 	.word	0x200001d0
   17dac:	00033804 	.word	0x00033804
   17db0:	0002db4c 	.word	0x0002db4c
   17db4:	000337d8 	.word	0x000337d8
   17db8:	0003381d 	.word	0x0003381d

00017dbc <gen_prov_start>:
{
   17dbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (rx->xact_id == link.rx.id) {
   17dc0:	4c4e      	ldr	r4, [pc, #312]	; (17efc <gen_prov_start+0x140>)
{
   17dc2:	b088      	sub	sp, #32
	if (rx->xact_id == link.rx.id) {
   17dc4:	7c22      	ldrb	r2, [r4, #16]
{
   17dc6:	460d      	mov	r5, r1
	if (rx->xact_id == link.rx.id) {
   17dc8:	7901      	ldrb	r1, [r0, #4]
   17dca:	4291      	cmp	r1, r2
{
   17dcc:	af00      	add	r7, sp, #0
   17dce:	4606      	mov	r6, r0
	if (rx->xact_id == link.rx.id) {
   17dd0:	d12f      	bne.n	17e32 <gen_prov_start+0x76>
		if (!link.rx.seg) {
   17dd2:	7c63      	ldrb	r3, [r4, #17]
   17dd4:	b953      	cbnz	r3, 17dec <gen_prov_start+0x30>
   17dd6:	f7ff fcfd 	bl	177d4 <atomic_get.constprop.0>
			if (!ack_pending()) {
   17dda:	06c1      	lsls	r1, r0, #27
   17ddc:	d402      	bmi.n	17de4 <gen_prov_start+0x28>
				gen_prov_ack_send(rx->xact_id);
   17dde:	7930      	ldrb	r0, [r6, #4]
   17de0:	f7ff feba 	bl	17b58 <gen_prov_ack_send>
}
   17de4:	3720      	adds	r7, #32
   17de6:	46bd      	mov	sp, r7
   17de8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!(link.rx.seg & BIT(0))) {
   17dec:	07da      	lsls	r2, r3, #31
   17dee:	d5f9      	bpl.n	17de4 <gen_prov_start+0x28>
	net_buf_simple_reset(link.rx.buf);
   17df0:	f8d4 8014 	ldr.w	r8, [r4, #20]
	buf->len  = 0U;
   17df4:	2300      	movs	r3, #0
   17df6:	f8a8 3004 	strh.w	r3, [r8, #4]
	buf->data = buf->__buf;
   17dfa:	f8d8 3008 	ldr.w	r3, [r8, #8]
   17dfe:	f8c8 3000 	str.w	r3, [r8]
	link.rx.buf->len = net_buf_simple_pull_be16(buf);
   17e02:	4628      	mov	r0, r5
   17e04:	f014 f82a 	bl	2be5c <net_buf_simple_pull_be16>
   17e08:	f8a8 0004 	strh.w	r0, [r8, #4]
	link.rx.id = rx->xact_id;
   17e0c:	7933      	ldrb	r3, [r6, #4]
   17e0e:	7423      	strb	r3, [r4, #16]
	link.rx.fcs = net_buf_simple_pull_u8(buf);
   17e10:	4628      	mov	r0, r5
   17e12:	f014 f813 	bl	2be3c <net_buf_simple_pull_u8>
	if (link.rx.buf->len < 1) {
   17e16:	6962      	ldr	r2, [r4, #20]
	link.rx.fcs = net_buf_simple_pull_u8(buf);
   17e18:	74e0      	strb	r0, [r4, #19]
	if (link.rx.buf->len < 1) {
   17e1a:	8893      	ldrh	r3, [r2, #4]
   17e1c:	bb1b      	cbnz	r3, 17e66 <gen_prov_start+0xaa>
		BT_ERR("Ignoring zero-length provisioning PDU");
   17e1e:	4b38      	ldr	r3, [pc, #224]	; (17f00 <gen_prov_start+0x144>)
		BT_ERR("Too small total length for multi-segment PDU");
   17e20:	61bb      	str	r3, [r7, #24]
   17e22:	2402      	movs	r4, #2
   17e24:	607c      	str	r4, [r7, #4]
   17e26:	617c      	str	r4, [r7, #20]
   17e28:	f107 0214 	add.w	r2, r7, #20
   17e2c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   17e30:	e026      	b.n	17e80 <gen_prov_start+0xc4>
	return (((id + 1) & XACT_ID_MAX) | (id & (XACT_ID_MAX+1)));
   17e32:	1c53      	adds	r3, r2, #1
   17e34:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   17e38:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   17e3c:	4313      	orrs	r3, r2
	} else if (rx->xact_id != next_transaction_id(link.rx.id)) {
   17e3e:	4299      	cmp	r1, r3
   17e40:	d0d6      	beq.n	17df0 <gen_prov_start+0x34>
		BT_WARN("Unexpected xact 0x%x, expected 0x%x", rx->xact_id,
   17e42:	466c      	mov	r4, sp
   17e44:	b088      	sub	sp, #32
   17e46:	466a      	mov	r2, sp
   17e48:	482e      	ldr	r0, [pc, #184]	; (17f04 <gen_prov_start+0x148>)
   17e4a:	6193      	str	r3, [r2, #24]
   17e4c:	2304      	movs	r3, #4
   17e4e:	e9c2 0104 	strd	r0, r1, [r2, #16]
   17e52:	f842 3f0c 	str.w	r3, [r2, #12]!
   17e56:	482c      	ldr	r0, [pc, #176]	; (17f08 <gen_prov_start+0x14c>)
   17e58:	60bb      	str	r3, [r7, #8]
   17e5a:	f44f 5102 	mov.w	r1, #8320	; 0x2080
   17e5e:	f012 fbe1 	bl	2a624 <z_log_msg2_static_create.constprop.0>
   17e62:	46a5      	mov	sp, r4
		return;
   17e64:	e7be      	b.n	17de4 <gen_prov_start+0x28>
	if (link.rx.buf->len > link.rx.buf->size) {
   17e66:	88d2      	ldrh	r2, [r2, #6]
   17e68:	429a      	cmp	r2, r3
   17e6a:	d210      	bcs.n	17e8e <gen_prov_start+0xd2>
		BT_ERR("Too large provisioning PDU (%u bytes)",
   17e6c:	4a27      	ldr	r2, [pc, #156]	; (17f0c <gen_prov_start+0x150>)
   17e6e:	61ba      	str	r2, [r7, #24]
   17e70:	61fb      	str	r3, [r7, #28]
   17e72:	2303      	movs	r3, #3
   17e74:	607b      	str	r3, [r7, #4]
   17e76:	617b      	str	r3, [r7, #20]
   17e78:	f107 0214 	add.w	r2, r7, #20
   17e7c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   17e80:	4821      	ldr	r0, [pc, #132]	; (17f08 <gen_prov_start+0x14c>)
   17e82:	f012 fbcf 	bl	2a624 <z_log_msg2_static_create.constprop.0>
		prov_failed(PROV_ERR_NVAL_FMT);
   17e86:	2002      	movs	r0, #2
   17e88:	f7ff fc16 	bl	176b8 <prov_failed>
		return;
   17e8c:	e7aa      	b.n	17de4 <gen_prov_start+0x28>
	if (START_LAST_SEG(rx->gpc) > 0 && link.rx.buf->len <= 20U) {
   17e8e:	7972      	ldrb	r2, [r6, #5]
   17e90:	0892      	lsrs	r2, r2, #2
   17e92:	d003      	beq.n	17e9c <gen_prov_start+0xe0>
   17e94:	2b14      	cmp	r3, #20
   17e96:	d801      	bhi.n	17e9c <gen_prov_start+0xe0>
		BT_ERR("Too small total length for multi-segment PDU");
   17e98:	4b1d      	ldr	r3, [pc, #116]	; (17f10 <gen_prov_start+0x154>)
   17e9a:	e7c1      	b.n	17e20 <gen_prov_start+0x64>
	prov_clear_tx();
   17e9c:	f7ff fc52 	bl	17744 <prov_clear_tx>
	link.rx.last_seg = START_LAST_SEG(rx->gpc);
   17ea0:	7972      	ldrb	r2, [r6, #5]
	if ((link.rx.seg & BIT(0)) &&
   17ea2:	7c61      	ldrb	r1, [r4, #17]
	link.rx.last_seg = START_LAST_SEG(rx->gpc);
   17ea4:	0892      	lsrs	r2, r2, #2
	if ((link.rx.seg & BIT(0)) &&
   17ea6:	07cb      	lsls	r3, r1, #31
	link.rx.last_seg = START_LAST_SEG(rx->gpc);
   17ea8:	74a2      	strb	r2, [r4, #18]
	if ((link.rx.seg & BIT(0)) &&
   17eaa:	d50d      	bpl.n	17ec8 <gen_prov_start+0x10c>
	    (find_msb_set((~link.rx.seg) & SEG_NVAL) - 1 > link.rx.last_seg)) {
   17eac:	43cb      	mvns	r3, r1
	if (op == 0) {
   17eae:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   17eb2:	d005      	beq.n	17ec0 <gen_prov_start+0x104>
	return 32 - __builtin_clz(op);
   17eb4:	fab3 f383 	clz	r3, r3
   17eb8:	f1c3 031f 	rsb	r3, r3, #31
	if ((link.rx.seg & BIT(0)) &&
   17ebc:	4293      	cmp	r3, r2
   17ebe:	d906      	bls.n	17ece <gen_prov_start+0x112>
		BT_ERR("Invalid segment index %u", seg);
   17ec0:	4b14      	ldr	r3, [pc, #80]	; (17f14 <gen_prov_start+0x158>)
   17ec2:	61bb      	str	r3, [r7, #24]
   17ec4:	23ff      	movs	r3, #255	; 0xff
   17ec6:	e7d3      	b.n	17e70 <gen_prov_start+0xb4>
	uint8_t seg = SEG_NVAL;
   17ec8:	2900      	cmp	r1, #0
   17eca:	bf08      	it	eq
   17ecc:	21ff      	moveq	r1, #255	; 0xff
	link.rx.seg = seg & ((1 << (START_LAST_SEG(rx->gpc) + 1)) - 1);
   17ece:	3201      	adds	r2, #1
   17ed0:	2301      	movs	r3, #1
   17ed2:	4093      	lsls	r3, r2
   17ed4:	3b01      	subs	r3, #1
   17ed6:	400b      	ands	r3, r1
   17ed8:	7463      	strb	r3, [r4, #17]
	memcpy(link.rx.buf->data, buf->data, buf->len);
   17eda:	6963      	ldr	r3, [r4, #20]
   17edc:	88aa      	ldrh	r2, [r5, #4]
   17ede:	6818      	ldr	r0, [r3, #0]
   17ee0:	6829      	ldr	r1, [r5, #0]
   17ee2:	f00f fcc5 	bl	27870 <memcpy>
	XACT_SEG_RECV(0);
   17ee6:	7c63      	ldrb	r3, [r4, #17]
   17ee8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   17eec:	7463      	strb	r3, [r4, #17]
	if (!link.rx.seg) {
   17eee:	2b00      	cmp	r3, #0
   17ef0:	f47f af78 	bne.w	17de4 <gen_prov_start+0x28>
		prov_msg_recv();
   17ef4:	f7ff fe74 	bl	17be0 <prov_msg_recv>
   17ef8:	e774      	b.n	17de4 <gen_prov_start+0x28>
   17efa:	bf00      	nop
   17efc:	200001d0 	.word	0x200001d0
   17f00:	00033862 	.word	0x00033862
   17f04:	0003383e 	.word	0x0003383e
   17f08:	0002db4c 	.word	0x0002db4c
   17f0c:	00033888 	.word	0x00033888
   17f10:	000338ae 	.word	0x000338ae
   17f14:	00033804 	.word	0x00033804

00017f18 <prov_send_adv>:
{
   17f18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   17f1c:	4d59      	ldr	r5, [pc, #356]	; (18084 <prov_send_adv+0x16c>)
{
   17f1e:	b088      	sub	sp, #32
   17f20:	460f      	mov	r7, r1
   17f22:	4604      	mov	r4, r0
   17f24:	4616      	mov	r6, r2
	prov_clear_tx();
   17f26:	f7ff fc0d 	bl	17744 <prov_clear_tx>
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   17f2a:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   17f2e:	2300      	movs	r3, #0
   17f30:	f105 0068 	add.w	r0, r5, #104	; 0x68
   17f34:	f00c fa16 	bl	24364 <k_work_reschedule>
	start = adv_buf_create(RETRANSMITS_RELIABLE);
   17f38:	2000      	movs	r0, #0
   17f3a:	f7ff fc29 	bl	17790 <adv_buf_create>
	if (!start) {
   17f3e:	4681      	mov	r9, r0
   17f40:	2800      	cmp	r0, #0
   17f42:	d077      	beq.n	18034 <prov_send_adv+0x11c>
	link.tx.id = next_transaction_id(link.tx.id);
   17f44:	f895 2020 	ldrb.w	r2, [r5, #32]
	net_buf_simple_add_be32(&buf->b, val);
   17f48:	6829      	ldr	r1, [r5, #0]
	return (((id + 1) & XACT_ID_MAX) | (id & (XACT_ID_MAX+1)));
   17f4a:	1c53      	adds	r3, r2, #1
   17f4c:	f100 0808 	add.w	r8, r0, #8
   17f50:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   17f54:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   17f58:	4313      	orrs	r3, r2
   17f5a:	4640      	mov	r0, r8
	link.tx.id = next_transaction_id(link.tx.id);
   17f5c:	f885 3020 	strb.w	r3, [r5, #32]
   17f60:	f013 ff24 	bl	2bdac <net_buf_simple_add_be32>
	net_buf_add_u8(start, link.tx.id);
   17f64:	f895 1020 	ldrb.w	r1, [r5, #32]
   17f68:	4648      	mov	r0, r9
   17f6a:	f012 fb5e 	bl	2a62a <net_buf_add_u8.isra.0>
	net_buf_add_u8(start, GPC_START(last_seg(msg->len)));
   17f6e:	7923      	ldrb	r3, [r4, #4]
	if (len <= START_PAYLOAD_MAX) {
   17f70:	2b14      	cmp	r3, #20
	len -= START_PAYLOAD_MAX;
   17f72:	bf81      	itttt	hi
   17f74:	3b14      	subhi	r3, #20
	return 1 + (len / CONT_PAYLOAD_MAX);
   17f76:	b2db      	uxtbhi	r3, r3
   17f78:	2117      	movhi	r1, #23
   17f7a:	fbb3 f3f1 	udivhi	r3, r3, r1
   17f7e:	bf86      	itte	hi
   17f80:	3301      	addhi	r3, #1
   17f82:	b2db      	uxtbhi	r3, r3
		return 0;
   17f84:	2300      	movls	r3, #0
	net_buf_add_u8(start, GPC_START(last_seg(msg->len)));
   17f86:	009b      	lsls	r3, r3, #2
   17f88:	f003 01fc 	and.w	r1, r3, #252	; 0xfc
   17f8c:	4648      	mov	r0, r9
   17f8e:	f012 fb4c 	bl	2a62a <net_buf_add_u8.isra.0>
	net_buf_simple_add_be16(&buf->b, val);
   17f92:	88a1      	ldrh	r1, [r4, #4]
   17f94:	4640      	mov	r0, r8
   17f96:	f013 fef2 	bl	2bd7e <net_buf_simple_add_be16>
	net_buf_add_u8(start, bt_mesh_fcs_calc(msg->data, msg->len));
   17f9a:	7921      	ldrb	r1, [r4, #4]
   17f9c:	6820      	ldr	r0, [r4, #0]
   17f9e:	f7f8 fad7 	bl	10550 <bt_mesh_fcs_calc>
   17fa2:	4601      	mov	r1, r0
   17fa4:	4648      	mov	r0, r9
   17fa6:	f012 fb40 	bl	2a62a <net_buf_add_u8.isra.0>
	link.tx.buf[0] = start;
   17faa:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
	link.tx.cb_data = cb_data;
   17fae:	e9c5 760c 	strd	r7, r6, [r5, #48]	; 0x30
   17fb2:	f015 f8cd 	bl	2d150 <z_impl_k_uptime_ticks>
	seg_len = MIN(msg->len, START_PAYLOAD_MAX);
   17fb6:	88a6      	ldrh	r6, [r4, #4]
   17fb8:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 18088 <prov_send_adv+0x170>
   17fbc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   17fc0:	fba0 0302 	umull	r0, r3, r0, r2
   17fc4:	fb02 3101 	mla	r1, r2, r1, r3
	net_buf_add_mem(start, msg->data, seg_len);
   17fc8:	2e14      	cmp	r6, #20
   17fca:	ea4f 30d0 	mov.w	r0, r0, lsr #15
   17fce:	bf28      	it	cs
   17fd0:	2614      	movcs	r6, #20
   17fd2:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   17fd6:	0bc9      	lsrs	r1, r1, #15
	link.tx.start = k_uptime_get();
   17fd8:	e9c5 0106 	strd	r0, r1, [r5, #24]
	return net_buf_simple_add_mem(&buf->b, mem, len);
   17fdc:	4632      	mov	r2, r6
   17fde:	6821      	ldr	r1, [r4, #0]
   17fe0:	4640      	mov	r0, r8
   17fe2:	f013 feb1 	bl	2bd48 <net_buf_simple_add_mem>
	net_buf_simple_pull(msg, seg_len);
   17fe6:	4631      	mov	r1, r6
   17fe8:	4620      	mov	r0, r4
   17fea:	f013 ff17 	bl	2be1c <net_buf_simple_pull>
	for (seg_id = 1U; msg->len > 0; seg_id++) {
   17fee:	2700      	movs	r7, #0
   17ff0:	88a6      	ldrh	r6, [r4, #4]
   17ff2:	b91e      	cbnz	r6, 17ffc <prov_send_adv+0xe4>
	send_reliable();
   17ff4:	f7ff fb72 	bl	176dc <send_reliable>
	return 0;
   17ff8:	4630      	mov	r0, r6
   17ffa:	e010      	b.n	1801e <prov_send_adv+0x106>
		if (seg_id >= ARRAY_SIZE(link.tx.buf)) {
   17ffc:	2f08      	cmp	r7, #8
   17ffe:	d111      	bne.n	18024 <prov_send_adv+0x10c>
			BT_ERR("Too big message");
   18000:	4b22      	ldr	r3, [pc, #136]	; (1808c <prov_send_adv+0x174>)
   18002:	4823      	ldr	r0, [pc, #140]	; (18090 <prov_send_adv+0x178>)
   18004:	9306      	str	r3, [sp, #24]
   18006:	aa05      	add	r2, sp, #20
   18008:	2302      	movs	r3, #2
   1800a:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1800e:	9301      	str	r3, [sp, #4]
   18010:	9305      	str	r3, [sp, #20]
   18012:	f012 fb07 	bl	2a624 <z_log_msg2_static_create.constprop.0>
			free_segments();
   18016:	f7ff fb7f 	bl	17718 <free_segments>
			return -E2BIG;
   1801a:	f06f 0006 	mvn.w	r0, #6
}
   1801e:	b008      	add	sp, #32
   18020:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		buf = adv_buf_create(RETRANSMITS_RELIABLE);
   18024:	2000      	movs	r0, #0
   18026:	f7ff fbb3 	bl	17790 <adv_buf_create>
		if (!buf) {
   1802a:	3704      	adds	r7, #4
   1802c:	4606      	mov	r6, r0
   1802e:	b920      	cbnz	r0, 1803a <prov_send_adv+0x122>
			free_segments();
   18030:	f7ff fb72 	bl	17718 <free_segments>
		return -ENOBUFS;
   18034:	f06f 0068 	mvn.w	r0, #104	; 0x68
   18038:	e7f1      	b.n	1801e <prov_send_adv+0x106>
		seg_len = MIN(msg->len, CONT_PAYLOAD_MAX);
   1803a:	f8b4 8004 	ldrh.w	r8, [r4, #4]
		link.tx.buf[seg_id] = buf;
   1803e:	f849 0b04 	str.w	r0, [r9], #4
	net_buf_simple_add_be32(&buf->b, val);
   18042:	f100 0a08 	add.w	sl, r0, #8
		seg_len = MIN(msg->len, CONT_PAYLOAD_MAX);
   18046:	f1b8 0f17 	cmp.w	r8, #23
   1804a:	6829      	ldr	r1, [r5, #0]
   1804c:	4650      	mov	r0, sl
   1804e:	bf28      	it	cs
   18050:	f04f 0817 	movcs.w	r8, #23
   18054:	f013 feaa 	bl	2bdac <net_buf_simple_add_be32>
		net_buf_add_u8(buf, link.tx.id);
   18058:	f895 1020 	ldrb.w	r1, [r5, #32]
   1805c:	4630      	mov	r0, r6
   1805e:	f012 fae4 	bl	2a62a <net_buf_add_u8.isra.0>
		net_buf_add_u8(buf, GPC_CONT(seg_id));
   18062:	f047 0102 	orr.w	r1, r7, #2
   18066:	4630      	mov	r0, r6
   18068:	b2c9      	uxtb	r1, r1
   1806a:	f012 fade 	bl	2a62a <net_buf_add_u8.isra.0>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1806e:	6821      	ldr	r1, [r4, #0]
   18070:	4642      	mov	r2, r8
   18072:	4650      	mov	r0, sl
   18074:	f013 fe68 	bl	2bd48 <net_buf_simple_add_mem>
		net_buf_simple_pull(msg, seg_len);
   18078:	4641      	mov	r1, r8
   1807a:	4620      	mov	r0, r4
   1807c:	f013 fece 	bl	2be1c <net_buf_simple_pull>
	for (seg_id = 1U; msg->len > 0; seg_id++) {
   18080:	e7b6      	b.n	17ff0 <prov_send_adv+0xd8>
   18082:	bf00      	nop
   18084:	200001d0 	.word	0x200001d0
   18088:	200001f8 	.word	0x200001f8
   1808c:	000338db 	.word	0x000338db
   18090:	0002db4c 	.word	0x0002db4c

00018094 <prov_link_open>:
{
   18094:	b570      	push	{r4, r5, r6, lr}
   18096:	b088      	sub	sp, #32
   18098:	4606      	mov	r6, r0
	err = bt_mesh_adv_enable();
   1809a:	f7fc ffbd 	bl	15018 <bt_mesh_adv_enable>
	if (err) {
   1809e:	4604      	mov	r4, r0
   180a0:	b168      	cbz	r0, 180be <prov_link_open+0x2a>
		BT_ERR("Failed enabling advertiser");
   180a2:	4b2a      	ldr	r3, [pc, #168]	; (1814c <prov_link_open+0xb8>)
   180a4:	9306      	str	r3, [sp, #24]
   180a6:	482a      	ldr	r0, [pc, #168]	; (18150 <prov_link_open+0xbc>)
   180a8:	2302      	movs	r3, #2
   180aa:	aa05      	add	r2, sp, #20
   180ac:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   180b0:	9301      	str	r3, [sp, #4]
   180b2:	9305      	str	r3, [sp, #20]
   180b4:	f012 fab6 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   180b8:	4620      	mov	r0, r4
   180ba:	b008      	add	sp, #32
   180bc:	bd70      	pop	{r4, r5, r6, pc}
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   180be:	4d25      	ldr	r5, [pc, #148]	; (18154 <prov_link_open+0xc0>)
   180c0:	2101      	movs	r1, #1
   180c2:	1d28      	adds	r0, r5, #4
   180c4:	f012 fa9f 	bl	2a606 <atomic_or>
	if (atomic_test_and_set_bit(link.flags, ADV_LINK_ACTIVE)) {
   180c8:	ea10 0401 	ands.w	r4, r0, r1
   180cc:	d13a      	bne.n	18144 <prov_link_open+0xb0>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   180ce:	2120      	movs	r1, #32
   180d0:	1d28      	adds	r0, r5, #4
   180d2:	f012 fa98 	bl	2a606 <atomic_or>
	bt_rand(&link.id, sizeof(link.id));
   180d6:	2104      	movs	r1, #4
   180d8:	4628      	mov	r0, r5
   180da:	f012 ff16 	bl	2af0a <bt_rand>
	link.tx.id = XACT_ID_MAX;
   180de:	237f      	movs	r3, #127	; 0x7f
   180e0:	f885 3020 	strb.w	r3, [r5, #32]
	link.rx.id = XACT_ID_NVAL;
   180e4:	23ff      	movs	r3, #255	; 0xff
   180e6:	742b      	strb	r3, [r5, #16]
	link.cb = cb;
   180e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   180ea:	60ab      	str	r3, [r5, #8]
	link.cb_data = cb_data;
   180ec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   180ee:	60eb      	str	r3, [r5, #12]
	net_buf_simple_reset(link.rx.buf);
   180f0:	696b      	ldr	r3, [r5, #20]
	buf->data = buf->__buf;
   180f2:	689a      	ldr	r2, [r3, #8]
   180f4:	601a      	str	r2, [r3, #0]
	buf->len  = 0U;
   180f6:	809c      	strh	r4, [r3, #4]
	return bearer_ctl_send(ctl_buf_create(LINK_OPEN, uuid, 16, RETRANSMITS_RELIABLE));
   180f8:	4631      	mov	r1, r6
   180fa:	4623      	mov	r3, r4
   180fc:	2210      	movs	r2, #16
   180fe:	4620      	mov	r0, r4
   18100:	f7ff fc04 	bl	1790c <ctl_buf_create>
	if (!buf) {
   18104:	4606      	mov	r6, r0
   18106:	b1d0      	cbz	r0, 1813e <prov_link_open+0xaa>
	prov_clear_tx();
   18108:	f7ff fb1c 	bl	17744 <prov_clear_tx>
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   1810c:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   18110:	2300      	movs	r3, #0
   18112:	f105 0068 	add.w	r0, r5, #104	; 0x68
   18116:	f00c f925 	bl	24364 <k_work_reschedule>
   1811a:	f015 f819 	bl	2d150 <z_impl_k_uptime_ticks>
   1811e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18122:	fba0 3002 	umull	r3, r0, r0, r2
   18126:	fb02 0101 	mla	r1, r2, r1, r0
   1812a:	0bdb      	lsrs	r3, r3, #15
   1812c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
   18130:	0bc9      	lsrs	r1, r1, #15
	link.tx.start = k_uptime_get();
   18132:	e9c5 3106 	strd	r3, r1, [r5, #24]
	link.tx.buf[0] = buf;
   18136:	626e      	str	r6, [r5, #36]	; 0x24
	send_reliable();
   18138:	f7ff fad0 	bl	176dc <send_reliable>
	return 0;
   1813c:	e7bc      	b.n	180b8 <prov_link_open+0x24>
		return -ENOMEM;
   1813e:	f06f 040b 	mvn.w	r4, #11
	return bearer_ctl_send(ctl_buf_create(LINK_OPEN, uuid, 16, RETRANSMITS_RELIABLE));
   18142:	e7b9      	b.n	180b8 <prov_link_open+0x24>
		return -EBUSY;
   18144:	f06f 040f 	mvn.w	r4, #15
   18148:	e7b6      	b.n	180b8 <prov_link_open+0x24>
   1814a:	bf00      	nop
   1814c:	00030754 	.word	0x00030754
   18150:	0002db4c 	.word	0x0002db4c
   18154:	200001d0 	.word	0x200001d0

00018158 <buf_sent>:
   18158:	4b09      	ldr	r3, [pc, #36]	; (18180 <buf_sent+0x28>)
   1815a:	f3bf 8f5b 	dmb	ish
   1815e:	e853 2f00 	ldrex	r2, [r3]
   18162:	f022 0104 	bic.w	r1, r2, #4
   18166:	e843 1000 	strex	r0, r1, [r3]
   1816a:	2800      	cmp	r0, #0
   1816c:	d1f7      	bne.n	1815e <buf_sent+0x6>
   1816e:	f3bf 8f5b 	dmb	ish
	if (atomic_test_and_clear_bit(link.flags, ADV_LINK_CLOSING)) {
   18172:	0753      	lsls	r3, r2, #29
   18174:	d502      	bpl.n	1817c <buf_sent+0x24>
		close_link(PROV_BEARER_LINK_STATUS_SUCCESS);
   18176:	2000      	movs	r0, #0
   18178:	f7ff bbb6 	b.w	178e8 <close_link>
}
   1817c:	4770      	bx	lr
   1817e:	bf00      	nop
   18180:	200001d4 	.word	0x200001d4

00018184 <ack_complete>:
   18184:	4b06      	ldr	r3, [pc, #24]	; (181a0 <ack_complete+0x1c>)
   18186:	f3bf 8f5b 	dmb	ish
   1818a:	e853 2f00 	ldrex	r2, [r3]
   1818e:	f022 0210 	bic.w	r2, r2, #16
   18192:	e843 2100 	strex	r1, r2, [r3]
   18196:	2900      	cmp	r1, #0
   18198:	d1f7      	bne.n	1818a <ack_complete+0x6>
   1819a:	f3bf 8f5b 	dmb	ish
}
   1819e:	4770      	bx	lr
   181a0:	200001d4 	.word	0x200001d4

000181a4 <bt_mesh_pb_adv_recv>:
{
   181a4:	b530      	push	{r4, r5, lr}
	if (!link.cb) {
   181a6:	4d2b      	ldr	r5, [pc, #172]	; (18254 <bt_mesh_pb_adv_recv+0xb0>)
   181a8:	68ab      	ldr	r3, [r5, #8]
{
   181aa:	b08b      	sub	sp, #44	; 0x2c
   181ac:	4604      	mov	r4, r0
	if (!link.cb) {
   181ae:	b173      	cbz	r3, 181ce <bt_mesh_pb_adv_recv+0x2a>
	if (buf->len < 6) {
   181b0:	8883      	ldrh	r3, [r0, #4]
   181b2:	2b05      	cmp	r3, #5
   181b4:	d80d      	bhi.n	181d2 <bt_mesh_pb_adv_recv+0x2e>
		BT_WARN("Too short provisioning packet (len %u)", buf->len);
   181b6:	4a28      	ldr	r2, [pc, #160]	; (18258 <bt_mesh_pb_adv_recv+0xb4>)
   181b8:	e9cd 2308 	strd	r2, r3, [sp, #32]
   181bc:	2303      	movs	r3, #3
   181be:	9302      	str	r3, [sp, #8]
   181c0:	9307      	str	r3, [sp, #28]
   181c2:	aa07      	add	r2, sp, #28
   181c4:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
		BT_ERR("Too short GPC message type %u", GPCF(rx->gpc));
   181c8:	4824      	ldr	r0, [pc, #144]	; (1825c <bt_mesh_pb_adv_recv+0xb8>)
   181ca:	f012 fa2b 	bl	2a624 <z_log_msg2_static_create.constprop.0>
}
   181ce:	b00b      	add	sp, #44	; 0x2c
   181d0:	bd30      	pop	{r4, r5, pc}
	rx.link_id = net_buf_simple_pull_be32(buf);
   181d2:	f013 fe4d 	bl	2be70 <net_buf_simple_pull_be32>
   181d6:	9002      	str	r0, [sp, #8]
	rx.xact_id = net_buf_simple_pull_u8(buf);
   181d8:	4620      	mov	r0, r4
   181da:	f013 fe2f 	bl	2be3c <net_buf_simple_pull_u8>
   181de:	f88d 000c 	strb.w	r0, [sp, #12]
	rx.gpc = net_buf_simple_pull_u8(buf);
   181e2:	4620      	mov	r0, r4
   181e4:	f013 fe2a 	bl	2be3c <net_buf_simple_pull_u8>
   181e8:	f88d 000d 	strb.w	r0, [sp, #13]
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   181ec:	f7ff faf2 	bl	177d4 <atomic_get.constprop.0>
	if (atomic_test_bit(link.flags, ADV_LINK_ACTIVE) && link.id != rx.link_id) {
   181f0:	07c3      	lsls	r3, r0, #31
   181f2:	d503      	bpl.n	181fc <bt_mesh_pb_adv_recv+0x58>
   181f4:	682a      	ldr	r2, [r5, #0]
   181f6:	9b02      	ldr	r3, [sp, #8]
   181f8:	429a      	cmp	r2, r3
   181fa:	d1e8      	bne.n	181ce <bt_mesh_pb_adv_recv+0x2a>
	if (buf->len < gen_prov[GPCF(rx->gpc)].min_len) {
   181fc:	f89d 300d 	ldrb.w	r3, [sp, #13]
   18200:	4a17      	ldr	r2, [pc, #92]	; (18260 <bt_mesh_pb_adv_recv+0xbc>)
   18202:	88a0      	ldrh	r0, [r4, #4]
   18204:	f003 0303 	and.w	r3, r3, #3
   18208:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
   1820c:	7949      	ldrb	r1, [r1, #5]
   1820e:	4288      	cmp	r0, r1
   18210:	d209      	bcs.n	18226 <bt_mesh_pb_adv_recv+0x82>
		BT_ERR("Too short GPC message type %u", GPCF(rx->gpc));
   18212:	4a14      	ldr	r2, [pc, #80]	; (18264 <bt_mesh_pb_adv_recv+0xc0>)
   18214:	e9cd 2308 	strd	r2, r3, [sp, #32]
   18218:	2303      	movs	r3, #3
   1821a:	9301      	str	r3, [sp, #4]
   1821c:	9307      	str	r3, [sp, #28]
   1821e:	aa07      	add	r2, sp, #28
   18220:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   18224:	e7d0      	b.n	181c8 <bt_mesh_pb_adv_recv+0x24>
   18226:	f7ff fad5 	bl	177d4 <atomic_get.constprop.0>
	if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE) &&
   1822a:	f010 0f01 	tst.w	r0, #1
   1822e:	f89d 300d 	ldrb.w	r3, [sp, #13]
   18232:	d106      	bne.n	18242 <bt_mesh_pb_adv_recv+0x9e>
	    gen_prov[GPCF(rx->gpc)].require_link) {
   18234:	f003 0103 	and.w	r1, r3, #3
   18238:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
	if (!atomic_test_bit(link.flags, ADV_LINK_ACTIVE) &&
   1823c:	7909      	ldrb	r1, [r1, #4]
   1823e:	2900      	cmp	r1, #0
   18240:	d1c5      	bne.n	181ce <bt_mesh_pb_adv_recv+0x2a>
	gen_prov[GPCF(rx->gpc)].func(rx, buf);
   18242:	f003 0303 	and.w	r3, r3, #3
   18246:	4621      	mov	r1, r4
   18248:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   1824c:	a802      	add	r0, sp, #8
   1824e:	4798      	blx	r3
   18250:	e7bd      	b.n	181ce <bt_mesh_pb_adv_recv+0x2a>
   18252:	bf00      	nop
   18254:	200001d0 	.word	0x200001d0
   18258:	000338eb 	.word	0x000338eb
   1825c:	0002db4c 	.word	0x0002db4c
   18260:	0002e79c 	.word	0x0002e79c
   18264:	00033912 	.word	0x00033912

00018268 <pb_adv_init>:

void pb_adv_init(void)
{
   18268:	b510      	push	{r4, lr}
	k_work_init_delayable(&link.prot_timer, protocol_timeout);
   1826a:	4c06      	ldr	r4, [pc, #24]	; (18284 <pb_adv_init+0x1c>)
   1826c:	4906      	ldr	r1, [pc, #24]	; (18288 <pb_adv_init+0x20>)
   1826e:	f104 0068 	add.w	r0, r4, #104	; 0x68
   18272:	f014 fdba 	bl	2cdea <k_work_init_delayable>
	k_work_init_delayable(&link.tx.retransmit, prov_retransmit);
   18276:	f104 0038 	add.w	r0, r4, #56	; 0x38
   1827a:	4904      	ldr	r1, [pc, #16]	; (1828c <pb_adv_init+0x24>)
}
   1827c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_init_delayable(&link.tx.retransmit, prov_retransmit);
   18280:	f014 bdb3 	b.w	2cdea <k_work_init_delayable>
   18284:	200001d0 	.word	0x200001d0
   18288:	00017aa5 	.word	0x00017aa5
   1828c:	00017ac5 	.word	0x00017ac5

00018290 <buf_send_end>:
	return 0;
}

static void buf_send_end(struct bt_conn *conn, void *user_data)
{
	if (link.comp.cb) {
   18290:	4a03      	ldr	r2, [pc, #12]	; (182a0 <buf_send_end+0x10>)
   18292:	68d3      	ldr	r3, [r2, #12]
   18294:	b113      	cbz	r3, 1829c <buf_send_end+0xc>
		link.comp.cb(0, link.comp.cb_data);
   18296:	6911      	ldr	r1, [r2, #16]
   18298:	2000      	movs	r0, #0
   1829a:	4718      	bx	r3
	}
}
   1829c:	4770      	bx	lr
   1829e:	bf00      	nop
   182a0:	20001f08 	.word	0x20001f08

000182a4 <reset_state>:
{
   182a4:	b510      	push	{r4, lr}
	if (link.conn) {
   182a6:	4c06      	ldr	r4, [pc, #24]	; (182c0 <reset_state+0x1c>)
   182a8:	6820      	ldr	r0, [r4, #0]
   182aa:	b118      	cbz	r0, 182b4 <reset_state+0x10>
		bt_conn_unref(link.conn);
   182ac:	f010 f81f 	bl	282ee <bt_conn_unref>
		link.conn = NULL;
   182b0:	2300      	movs	r3, #0
   182b2:	6023      	str	r3, [r4, #0]
}
   182b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)k_work_cancel_delayable(&link.prot_timer);
   182b8:	4802      	ldr	r0, [pc, #8]	; (182c4 <reset_state+0x20>)
   182ba:	f014 bda4 	b.w	2ce06 <k_work_cancel_delayable>
   182be:	bf00      	nop
   182c0:	20001f08 	.word	0x20001f08
   182c4:	20001f20 	.word	0x20001f20

000182c8 <link_closed>:
{
   182c8:	b570      	push	{r4, r5, r6, lr}
	const struct prov_bearer_cb *cb = link.cb;
   182ca:	4b06      	ldr	r3, [pc, #24]	; (182e4 <link_closed+0x1c>)
	void *cb_data = link.cb_data;
   182cc:	e9d3 6501 	ldrd	r6, r5, [r3, #4]
{
   182d0:	4604      	mov	r4, r0
	reset_state();
   182d2:	f7ff ffe7 	bl	182a4 <reset_state>
	cb->link_closed(&pb_gatt, cb_data, status);
   182d6:	6873      	ldr	r3, [r6, #4]
   182d8:	4803      	ldr	r0, [pc, #12]	; (182e8 <link_closed+0x20>)
   182da:	4622      	mov	r2, r4
   182dc:	4629      	mov	r1, r5
}
   182de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cb->link_closed(&pb_gatt, cb_data, status);
   182e2:	4718      	bx	r3
   182e4:	20001f08 	.word	0x20001f08
   182e8:	0002e7d4 	.word	0x0002e7d4

000182ec <protocol_timeout>:
	if (!link.conn) {
   182ec:	4b03      	ldr	r3, [pc, #12]	; (182fc <protocol_timeout+0x10>)
   182ee:	681b      	ldr	r3, [r3, #0]
   182f0:	b113      	cbz	r3, 182f8 <protocol_timeout+0xc>
	link_closed(PROV_BEARER_LINK_STATUS_TIMEOUT);
   182f2:	2001      	movs	r0, #1
   182f4:	f7ff bfe8 	b.w	182c8 <link_closed>
}
   182f8:	4770      	bx	lr
   182fa:	bf00      	nop
   182fc:	20001f08 	.word	0x20001f08

00018300 <buf_send>:

static int buf_send(struct net_buf_simple *buf, prov_bearer_send_complete_t cb,
		    void *cb_data)
{
   18300:	b570      	push	{r4, r5, r6, lr}
	if (!link.conn) {
   18302:	4c0c      	ldr	r4, [pc, #48]	; (18334 <buf_send+0x34>)
   18304:	6823      	ldr	r3, [r4, #0]
{
   18306:	4605      	mov	r5, r0
	if (!link.conn) {
   18308:	b183      	cbz	r3, 1832c <buf_send+0x2c>
		return -ENOTCONN;
	}

	link.comp.cb = cb;
	link.comp.cb_data = cb_data;
   1830a:	e9c4 1203 	strd	r1, r2, [r4, #12]

	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   1830e:	2300      	movs	r3, #0
   18310:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   18314:	f104 0018 	add.w	r0, r4, #24
   18318:	f00c f824 	bl	24364 <k_work_reschedule>

	return bt_mesh_pb_gatt_send(link.conn, buf, buf_send_end, NULL);
   1831c:	6820      	ldr	r0, [r4, #0]
   1831e:	4a06      	ldr	r2, [pc, #24]	; (18338 <buf_send+0x38>)
   18320:	4629      	mov	r1, r5
   18322:	2300      	movs	r3, #0
}
   18324:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_mesh_pb_gatt_send(link.conn, buf, buf_send_end, NULL);
   18328:	f000 b9d4 	b.w	186d4 <bt_mesh_pb_gatt_send>
}
   1832c:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   18330:	bd70      	pop	{r4, r5, r6, pc}
   18332:	bf00      	nop
   18334:	20001f08 	.word	0x20001f08
   18338:	00018291 	.word	0x00018291

0001833c <link_accept>:
{
   1833c:	b570      	push	{r4, r5, r6, lr}
   1833e:	b088      	sub	sp, #32
   18340:	4606      	mov	r6, r0
   18342:	460d      	mov	r5, r1
	err = bt_mesh_adv_enable();
   18344:	f7fc fe68 	bl	15018 <bt_mesh_adv_enable>
	if (err) {
   18348:	4604      	mov	r4, r0
   1834a:	b170      	cbz	r0, 1836a <link_accept+0x2e>
		BT_ERR("Failed enabling advertiser");
   1834c:	4b0b      	ldr	r3, [pc, #44]	; (1837c <link_accept+0x40>)
   1834e:	9306      	str	r3, [sp, #24]
   18350:	2302      	movs	r3, #2
   18352:	9301      	str	r3, [sp, #4]
   18354:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   18356:	480a      	ldr	r0, [pc, #40]	; (18380 <link_accept+0x44>)
   18358:	2300      	movs	r3, #0
   1835a:	aa05      	add	r2, sp, #20
   1835c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   18360:	f00d fcba 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   18364:	4620      	mov	r0, r4
   18366:	b008      	add	sp, #32
   18368:	bd70      	pop	{r4, r5, r6, pc}
	(void)bt_mesh_pb_gatt_enable();
   1836a:	f000 f961 	bl	18630 <bt_mesh_pb_gatt_enable>
	bt_mesh_adv_gatt_update();
   1836e:	f011 ff7c 	bl	2a26a <bt_mesh_adv_gatt_update>
	link.cb = cb;
   18372:	4b04      	ldr	r3, [pc, #16]	; (18384 <link_accept+0x48>)
	link.cb_data = cb_data;
   18374:	e9c3 6501 	strd	r6, r5, [r3, #4]
	return 0;
   18378:	e7f4      	b.n	18364 <link_accept+0x28>
   1837a:	bf00      	nop
   1837c:	00030754 	.word	0x00030754
   18380:	0002db54 	.word	0x0002db54
   18384:	20001f08 	.word	0x20001f08

00018388 <bt_mesh_pb_gatt_recv>:
{
   18388:	b530      	push	{r4, r5, lr}
	if (link.conn != conn || !link.cb) {
   1838a:	4c1c      	ldr	r4, [pc, #112]	; (183fc <bt_mesh_pb_gatt_recv+0x74>)
   1838c:	6823      	ldr	r3, [r4, #0]
   1838e:	4283      	cmp	r3, r0
{
   18390:	b089      	sub	sp, #36	; 0x24
   18392:	460d      	mov	r5, r1
	if (link.conn != conn || !link.cb) {
   18394:	d101      	bne.n	1839a <bt_mesh_pb_gatt_recv+0x12>
   18396:	6863      	ldr	r3, [r4, #4]
   18398:	b97b      	cbnz	r3, 183ba <bt_mesh_pb_gatt_recv+0x32>
		BT_WARN("Data for unexpected connection");
   1839a:	4b19      	ldr	r3, [pc, #100]	; (18400 <bt_mesh_pb_gatt_recv+0x78>)
   1839c:	9306      	str	r3, [sp, #24]
   1839e:	2302      	movs	r3, #2
   183a0:	9301      	str	r3, [sp, #4]
   183a2:	9305      	str	r3, [sp, #20]
   183a4:	4817      	ldr	r0, [pc, #92]	; (18404 <bt_mesh_pb_gatt_recv+0x7c>)
   183a6:	2300      	movs	r3, #0
   183a8:	aa05      	add	r2, sp, #20
   183aa:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   183ae:	f00d fc93 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -ENOTCONN;
   183b2:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   183b6:	b009      	add	sp, #36	; 0x24
   183b8:	bd30      	pop	{r4, r5, pc}
	if (buf->len < 1) {
   183ba:	888b      	ldrh	r3, [r1, #4]
   183bc:	b973      	cbnz	r3, 183dc <bt_mesh_pb_gatt_recv+0x54>
		BT_WARN("Too short provisioning packet (len %u)", buf->len);
   183be:	4a12      	ldr	r2, [pc, #72]	; (18408 <bt_mesh_pb_gatt_recv+0x80>)
   183c0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   183c4:	2203      	movs	r2, #3
   183c6:	9201      	str	r2, [sp, #4]
   183c8:	9205      	str	r2, [sp, #20]
   183ca:	480e      	ldr	r0, [pc, #56]	; (18404 <bt_mesh_pb_gatt_recv+0x7c>)
   183cc:	aa05      	add	r2, sp, #20
   183ce:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   183d2:	f00d fc81 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   183d6:	f06f 0015 	mvn.w	r0, #21
   183da:	e7ec      	b.n	183b6 <bt_mesh_pb_gatt_recv+0x2e>
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   183dc:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
   183e0:	2300      	movs	r3, #0
   183e2:	f104 0018 	add.w	r0, r4, #24
   183e6:	f00b ffbd 	bl	24364 <k_work_reschedule>
	link.cb->recv(&pb_gatt, link.cb_data, buf);
   183ea:	6863      	ldr	r3, [r4, #4]
   183ec:	4807      	ldr	r0, [pc, #28]	; (1840c <bt_mesh_pb_gatt_recv+0x84>)
   183ee:	68db      	ldr	r3, [r3, #12]
   183f0:	68a1      	ldr	r1, [r4, #8]
   183f2:	462a      	mov	r2, r5
   183f4:	4798      	blx	r3
	return 0;
   183f6:	2000      	movs	r0, #0
   183f8:	e7dd      	b.n	183b6 <bt_mesh_pb_gatt_recv+0x2e>
   183fa:	bf00      	nop
   183fc:	20001f08 	.word	0x20001f08
   18400:	0003393f 	.word	0x0003393f
   18404:	0002db54 	.word	0x0002db54
   18408:	000338eb 	.word	0x000338eb
   1840c:	0002e7d4 	.word	0x0002e7d4

00018410 <bt_mesh_pb_gatt_open>:
{
   18410:	b538      	push	{r3, r4, r5, lr}
	if (link.conn) {
   18412:	4d0c      	ldr	r5, [pc, #48]	; (18444 <bt_mesh_pb_gatt_open+0x34>)
   18414:	682c      	ldr	r4, [r5, #0]
   18416:	b98c      	cbnz	r4, 1843c <bt_mesh_pb_gatt_open+0x2c>
	link.conn = bt_conn_ref(conn);
   18418:	f00f ff4e 	bl	282b8 <bt_conn_ref>
   1841c:	4603      	mov	r3, r0
   1841e:	4628      	mov	r0, r5
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   18420:	f44f 12f0 	mov.w	r2, #1966080	; 0x1e0000
	link.conn = bt_conn_ref(conn);
   18424:	f840 3b18 	str.w	r3, [r0], #24
	k_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);
   18428:	2300      	movs	r3, #0
   1842a:	f00b ff9b 	bl	24364 <k_work_reschedule>
	link.cb->link_opened(&pb_gatt, link.cb_data);
   1842e:	686b      	ldr	r3, [r5, #4]
   18430:	4805      	ldr	r0, [pc, #20]	; (18448 <bt_mesh_pb_gatt_open+0x38>)
   18432:	681b      	ldr	r3, [r3, #0]
   18434:	68a9      	ldr	r1, [r5, #8]
   18436:	4798      	blx	r3
	return 0;
   18438:	4620      	mov	r0, r4
}
   1843a:	bd38      	pop	{r3, r4, r5, pc}
		return -EBUSY;
   1843c:	f06f 000f 	mvn.w	r0, #15
   18440:	e7fb      	b.n	1843a <bt_mesh_pb_gatt_open+0x2a>
   18442:	bf00      	nop
   18444:	20001f08 	.word	0x20001f08
   18448:	0002e7d4 	.word	0x0002e7d4

0001844c <bt_mesh_pb_gatt_close>:
{
   1844c:	b508      	push	{r3, lr}
	if (link.conn != conn) {
   1844e:	4b06      	ldr	r3, [pc, #24]	; (18468 <bt_mesh_pb_gatt_close+0x1c>)
   18450:	681b      	ldr	r3, [r3, #0]
   18452:	4283      	cmp	r3, r0
   18454:	d104      	bne.n	18460 <bt_mesh_pb_gatt_close+0x14>
	link_closed(PROV_BEARER_LINK_STATUS_SUCCESS);
   18456:	2000      	movs	r0, #0
   18458:	f7ff ff36 	bl	182c8 <link_closed>
	return 0;
   1845c:	2000      	movs	r0, #0
}
   1845e:	bd08      	pop	{r3, pc}
		return -ENOTCONN;
   18460:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   18464:	e7fb      	b.n	1845e <bt_mesh_pb_gatt_close+0x12>
   18466:	bf00      	nop
   18468:	20001f08 	.word	0x20001f08

0001846c <pb_gatt_init>:
	/* No action */
}

void pb_gatt_init(void)
{
	k_work_init_delayable(&link.prot_timer, protocol_timeout);
   1846c:	4901      	ldr	r1, [pc, #4]	; (18474 <pb_gatt_init+0x8>)
   1846e:	4802      	ldr	r0, [pc, #8]	; (18478 <pb_gatt_init+0xc>)
   18470:	f014 bcbb 	b.w	2cdea <k_work_init_delayable>
   18474:	000182ed 	.word	0x000182ed
   18478:	20001f20 	.word	0x20001f20

0001847c <gatt_send>:
}

static int gatt_send(struct bt_conn *conn,
		     const void *data, uint16_t len,
		     bt_gatt_complete_func_t end, void *user_data)
{
   1847c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1847e:	b087      	sub	sp, #28
   18480:	4604      	mov	r4, r0
   18482:	460f      	mov	r7, r1
   18484:	4616      	mov	r6, r2
	BT_DBG("%u bytes: %s", len, bt_hex(data, len));

	struct bt_gatt_notify_params params = {
   18486:	2100      	movs	r1, #0
   18488:	2210      	movs	r2, #16
   1848a:	4668      	mov	r0, sp
{
   1848c:	461d      	mov	r5, r3
	struct bt_gatt_notify_params params = {
   1848e:	f00f f9fa 	bl	27886 <memset>
   18492:	4b07      	ldr	r3, [pc, #28]	; (184b0 <gatt_send+0x34>)
   18494:	f8ad 600c 	strh.w	r6, [sp, #12]
   18498:	e9cd 3701 	strd	r3, r7, [sp, #4]
		.attr = &prov_attrs[3],
		.user_data = user_data,
		.func = end,
	};

	return bt_gatt_notify_cb(conn, &params);
   1849c:	4669      	mov	r1, sp
	struct bt_gatt_notify_params params = {
   1849e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   184a0:	9504      	str	r5, [sp, #16]
	return bt_gatt_notify_cb(conn, &params);
   184a2:	4620      	mov	r0, r4
	struct bt_gatt_notify_params params = {
   184a4:	9305      	str	r3, [sp, #20]
	return bt_gatt_notify_cb(conn, &params);
   184a6:	f7f2 feeb 	bl	b280 <bt_gatt_notify_cb>
}
   184aa:	b007      	add	sp, #28
   184ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
   184ae:	bf00      	nop
   184b0:	20000648 	.word	0x20000648

000184b4 <gatt_connected>:
{
   184b4:	b510      	push	{r4, lr}
   184b6:	b088      	sub	sp, #32
	bt_conn_get_info(conn, &info);
   184b8:	a901      	add	r1, sp, #4
{
   184ba:	4604      	mov	r4, r0
	bt_conn_get_info(conn, &info);
   184bc:	f7f0 fafe 	bl	8abc <bt_conn_get_info>
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   184c0:	f89d 3005 	ldrb.w	r3, [sp, #5]
   184c4:	2b01      	cmp	r3, #1
   184c6:	d10c      	bne.n	184e2 <gatt_connected+0x2e>
	    !service_registered || bt_mesh_is_provisioned()) {
   184c8:	4b07      	ldr	r3, [pc, #28]	; (184e8 <gatt_connected+0x34>)
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   184ca:	781b      	ldrb	r3, [r3, #0]
   184cc:	b14b      	cbz	r3, 184e2 <gatt_connected+0x2e>
	    !service_registered || bt_mesh_is_provisioned()) {
   184ce:	f7f3 fa77 	bl	b9c0 <bt_mesh_is_provisioned>
   184d2:	b930      	cbnz	r0, 184e2 <gatt_connected+0x2e>
	cli = bt_mesh_proxy_role_setup(conn, gatt_send, proxy_msg_recv);
   184d4:	4a05      	ldr	r2, [pc, #20]	; (184ec <gatt_connected+0x38>)
   184d6:	4906      	ldr	r1, [pc, #24]	; (184f0 <gatt_connected+0x3c>)
   184d8:	4620      	mov	r0, r4
   184da:	f000 ff1f 	bl	1931c <bt_mesh_proxy_role_setup>
   184de:	4b05      	ldr	r3, [pc, #20]	; (184f4 <gatt_connected+0x40>)
   184e0:	6018      	str	r0, [r3, #0]
}
   184e2:	b008      	add	sp, #32
   184e4:	bd10      	pop	{r4, pc}
   184e6:	bf00      	nop
   184e8:	20003aed 	.word	0x20003aed
   184ec:	000185ed 	.word	0x000185ed
   184f0:	0001847d 	.word	0x0001847d
   184f4:	200028c0 	.word	0x200028c0

000184f8 <prov_ccc_write>:
	if (cli->conn != conn) {
   184f8:	4b16      	ldr	r3, [pc, #88]	; (18554 <prov_ccc_write+0x5c>)
{
   184fa:	b500      	push	{lr}
	if (cli->conn != conn) {
   184fc:	681b      	ldr	r3, [r3, #0]
   184fe:	681b      	ldr	r3, [r3, #0]
   18500:	4283      	cmp	r3, r0
{
   18502:	b089      	sub	sp, #36	; 0x24
	if (cli->conn != conn) {
   18504:	d010      	beq.n	18528 <prov_ccc_write+0x30>
		BT_ERR("No PB-GATT Client found");
   18506:	4b14      	ldr	r3, [pc, #80]	; (18558 <prov_ccc_write+0x60>)
   18508:	9306      	str	r3, [sp, #24]
   1850a:	2302      	movs	r3, #2
   1850c:	9301      	str	r3, [sp, #4]
   1850e:	9305      	str	r3, [sp, #20]
   18510:	4812      	ldr	r0, [pc, #72]	; (1855c <prov_ccc_write+0x64>)
   18512:	2300      	movs	r3, #0
   18514:	aa05      	add	r2, sp, #20
   18516:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1851a:	f00d fbdd 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -ENOTCONN;
   1851e:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   18522:	b009      	add	sp, #36	; 0x24
   18524:	f85d fb04 	ldr.w	pc, [sp], #4
	if (value != BT_GATT_CCC_NOTIFY) {
   18528:	2a01      	cmp	r2, #1
   1852a:	d00f      	beq.n	1854c <prov_ccc_write+0x54>
		BT_WARN("Client wrote 0x%04x instead enabling notify", value);
   1852c:	4b0c      	ldr	r3, [pc, #48]	; (18560 <prov_ccc_write+0x68>)
   1852e:	e9cd 3206 	strd	r3, r2, [sp, #24]
   18532:	2303      	movs	r3, #3
   18534:	9301      	str	r3, [sp, #4]
   18536:	9305      	str	r3, [sp, #20]
   18538:	4808      	ldr	r0, [pc, #32]	; (1855c <prov_ccc_write+0x64>)
   1853a:	2300      	movs	r3, #0
   1853c:	aa05      	add	r2, sp, #20
   1853e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   18542:	f00d fbc9 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   18546:	f06f 0012 	mvn.w	r0, #18
   1854a:	e7ea      	b.n	18522 <prov_ccc_write+0x2a>
	bt_mesh_pb_gatt_open(conn);
   1854c:	f7ff ff60 	bl	18410 <bt_mesh_pb_gatt_open>
	return sizeof(value);
   18550:	2002      	movs	r0, #2
   18552:	e7e6      	b.n	18522 <prov_ccc_write+0x2a>
   18554:	200028c0 	.word	0x200028c0
   18558:	0003396e 	.word	0x0003396e
   1855c:	0002db5c 	.word	0x0002db5c
   18560:	00033986 	.word	0x00033986

00018564 <gatt_recv>:
{
   18564:	b530      	push	{r4, r5, lr}
   18566:	4604      	mov	r4, r0
	if (cli->conn != conn) {
   18568:	481b      	ldr	r0, [pc, #108]	; (185d8 <gatt_recv+0x74>)
   1856a:	6800      	ldr	r0, [r0, #0]
   1856c:	6805      	ldr	r5, [r0, #0]
   1856e:	42a5      	cmp	r5, r4
{
   18570:	4611      	mov	r1, r2
   18572:	b089      	sub	sp, #36	; 0x24
   18574:	461a      	mov	r2, r3
	if (cli->conn != conn) {
   18576:	d00f      	beq.n	18598 <gatt_recv+0x34>
		BT_ERR("No PB-GATT Client found");
   18578:	4b18      	ldr	r3, [pc, #96]	; (185dc <gatt_recv+0x78>)
   1857a:	9306      	str	r3, [sp, #24]
   1857c:	2302      	movs	r3, #2
   1857e:	9301      	str	r3, [sp, #4]
   18580:	9305      	str	r3, [sp, #20]
   18582:	4817      	ldr	r0, [pc, #92]	; (185e0 <gatt_recv+0x7c>)
   18584:	2300      	movs	r3, #0
   18586:	aa05      	add	r2, sp, #20
   18588:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1858c:	f00d fba4 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -ENOTCONN;
   18590:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   18594:	b009      	add	sp, #36	; 0x24
   18596:	bd30      	pop	{r4, r5, pc}
	if (len < 1) {
   18598:	b96b      	cbnz	r3, 185b6 <gatt_recv+0x52>
		BT_WARN("Too small Proxy PDU");
   1859a:	4a12      	ldr	r2, [pc, #72]	; (185e4 <gatt_recv+0x80>)
   1859c:	9206      	str	r2, [sp, #24]
   1859e:	2202      	movs	r2, #2
   185a0:	9201      	str	r2, [sp, #4]
   185a2:	9205      	str	r2, [sp, #20]
   185a4:	480e      	ldr	r0, [pc, #56]	; (185e0 <gatt_recv+0x7c>)
   185a6:	aa05      	add	r2, sp, #20
   185a8:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   185ac:	f00d fb94 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   185b0:	f06f 0015 	mvn.w	r0, #21
   185b4:	e7ee      	b.n	18594 <gatt_recv+0x30>
	if (PDU_TYPE(data) != BT_MESH_PROXY_PROV) {
   185b6:	780b      	ldrb	r3, [r1, #0]
   185b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   185bc:	2b03      	cmp	r3, #3
   185be:	d006      	beq.n	185ce <gatt_recv+0x6a>
		BT_WARN("Proxy PDU type doesn't match GATT service");
   185c0:	4b09      	ldr	r3, [pc, #36]	; (185e8 <gatt_recv+0x84>)
   185c2:	9306      	str	r3, [sp, #24]
   185c4:	2302      	movs	r3, #2
   185c6:	9301      	str	r3, [sp, #4]
   185c8:	9305      	str	r3, [sp, #20]
   185ca:	2300      	movs	r3, #0
   185cc:	e7ea      	b.n	185a4 <gatt_recv+0x40>
}
   185ce:	b009      	add	sp, #36	; 0x24
   185d0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return bt_mesh_proxy_msg_recv(cli, buf, len);
   185d4:	f000 be22 	b.w	1921c <bt_mesh_proxy_msg_recv>
   185d8:	200028c0 	.word	0x200028c0
   185dc:	0003396e 	.word	0x0003396e
   185e0:	0002db5c 	.word	0x0002db5c
   185e4:	000339b2 	.word	0x000339b2
   185e8:	000339c6 	.word	0x000339c6

000185ec <proxy_msg_recv>:
{
   185ec:	b500      	push	{lr}
	switch (role->msg_type) {
   185ee:	7903      	ldrb	r3, [r0, #4]
   185f0:	2b03      	cmp	r3, #3
{
   185f2:	b089      	sub	sp, #36	; 0x24
	switch (role->msg_type) {
   185f4:	d107      	bne.n	18606 <proxy_msg_recv+0x1a>
		bt_mesh_pb_gatt_recv(role->conn, &role->buf);
   185f6:	f100 0140 	add.w	r1, r0, #64	; 0x40
   185fa:	6800      	ldr	r0, [r0, #0]
}
   185fc:	b009      	add	sp, #36	; 0x24
   185fe:	f85d eb04 	ldr.w	lr, [sp], #4
		bt_mesh_pb_gatt_recv(role->conn, &role->buf);
   18602:	f7ff bec1 	b.w	18388 <bt_mesh_pb_gatt_recv>
		BT_WARN("Unhandled Message Type 0x%02x", role->msg_type);
   18606:	4a08      	ldr	r2, [pc, #32]	; (18628 <proxy_msg_recv+0x3c>)
	switch (role->msg_type) {
   18608:	e9cd 2306 	strd	r2, r3, [sp, #24]
		BT_WARN("Unhandled Message Type 0x%02x", role->msg_type);
   1860c:	2303      	movs	r3, #3
   1860e:	9301      	str	r3, [sp, #4]
   18610:	9305      	str	r3, [sp, #20]
   18612:	4806      	ldr	r0, [pc, #24]	; (1862c <proxy_msg_recv+0x40>)
   18614:	2300      	movs	r3, #0
   18616:	aa05      	add	r2, sp, #20
   18618:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   1861c:	f00d fb5c 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   18620:	b009      	add	sp, #36	; 0x24
   18622:	f85d fb04 	ldr.w	pc, [sp], #4
   18626:	bf00      	nop
   18628:	000339f0 	.word	0x000339f0
   1862c:	0002db5c 	.word	0x0002db5c

00018630 <bt_mesh_pb_gatt_enable>:
{
   18630:	b538      	push	{r3, r4, r5, lr}
	if (bt_mesh_is_provisioned()) {
   18632:	f7f3 f9c5 	bl	b9c0 <bt_mesh_is_provisioned>
   18636:	b958      	cbnz	r0, 18650 <bt_mesh_pb_gatt_enable+0x20>
	if (service_registered) {
   18638:	4d08      	ldr	r5, [pc, #32]	; (1865c <bt_mesh_pb_gatt_enable+0x2c>)
   1863a:	782c      	ldrb	r4, [r5, #0]
   1863c:	b95c      	cbnz	r4, 18656 <bt_mesh_pb_gatt_enable+0x26>
	(void)bt_gatt_service_register(&prov_svc);
   1863e:	4808      	ldr	r0, [pc, #32]	; (18660 <bt_mesh_pb_gatt_enable+0x30>)
   18640:	f7f2 fb36 	bl	acb0 <bt_gatt_service_register>
	prov_fast_adv = true;
   18644:	4a07      	ldr	r2, [pc, #28]	; (18664 <bt_mesh_pb_gatt_enable+0x34>)
	service_registered = true;
   18646:	2301      	movs	r3, #1
   18648:	702b      	strb	r3, [r5, #0]
	prov_fast_adv = true;
   1864a:	7013      	strb	r3, [r2, #0]
	return 0;
   1864c:	4620      	mov	r0, r4
}
   1864e:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   18650:	f06f 0085 	mvn.w	r0, #133	; 0x85
   18654:	e7fb      	b.n	1864e <bt_mesh_pb_gatt_enable+0x1e>
		return -EBUSY;
   18656:	f06f 000f 	mvn.w	r0, #15
   1865a:	e7f8      	b.n	1864e <bt_mesh_pb_gatt_enable+0x1e>
   1865c:	20003aed 	.word	0x20003aed
   18660:	2000069c 	.word	0x2000069c
   18664:	20003aec 	.word	0x20003aec

00018668 <bt_mesh_pb_gatt_disable>:
{
   18668:	b538      	push	{r3, r4, r5, lr}
	if (!service_registered) {
   1866a:	4d07      	ldr	r5, [pc, #28]	; (18688 <bt_mesh_pb_gatt_disable+0x20>)
   1866c:	782b      	ldrb	r3, [r5, #0]
   1866e:	b143      	cbz	r3, 18682 <bt_mesh_pb_gatt_disable+0x1a>
	service_registered = false;
   18670:	2400      	movs	r4, #0
	bt_gatt_service_unregister(&prov_svc);
   18672:	4806      	ldr	r0, [pc, #24]	; (1868c <bt_mesh_pb_gatt_disable+0x24>)
   18674:	f7f3 f81c 	bl	b6b0 <bt_gatt_service_unregister>
	service_registered = false;
   18678:	702c      	strb	r4, [r5, #0]
	bt_mesh_adv_gatt_update();
   1867a:	f011 fdf6 	bl	2a26a <bt_mesh_adv_gatt_update>
	return 0;
   1867e:	4620      	mov	r0, r4
}
   18680:	bd38      	pop	{r3, r4, r5, pc}
		return -EALREADY;
   18682:	f06f 0077 	mvn.w	r0, #119	; 0x77
   18686:	e7fb      	b.n	18680 <bt_mesh_pb_gatt_disable+0x18>
   18688:	20003aed 	.word	0x20003aed
   1868c:	2000069c 	.word	0x2000069c

00018690 <gatt_disconnected>:
{
   18690:	b530      	push	{r4, r5, lr}
   18692:	b089      	sub	sp, #36	; 0x24
	bt_conn_get_info(conn, &info);
   18694:	a901      	add	r1, sp, #4
{
   18696:	4604      	mov	r4, r0
	bt_conn_get_info(conn, &info);
   18698:	f7f0 fa10 	bl	8abc <bt_conn_get_info>
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   1869c:	f89d 3005 	ldrb.w	r3, [sp, #5]
   186a0:	2b01      	cmp	r3, #1
   186a2:	d111      	bne.n	186c8 <gatt_disconnected+0x38>
	    !service_registered) {
   186a4:	4b09      	ldr	r3, [pc, #36]	; (186cc <gatt_disconnected+0x3c>)
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   186a6:	781b      	ldrb	r3, [r3, #0]
   186a8:	b173      	cbz	r3, 186c8 <gatt_disconnected+0x38>
	if (cli) {
   186aa:	4d09      	ldr	r5, [pc, #36]	; (186d0 <gatt_disconnected+0x40>)
   186ac:	6828      	ldr	r0, [r5, #0]
   186ae:	b118      	cbz	r0, 186b8 <gatt_disconnected+0x28>
		bt_mesh_proxy_role_cleanup(cli);
   186b0:	f012 f878 	bl	2a7a4 <bt_mesh_proxy_role_cleanup>
		cli = NULL;
   186b4:	2300      	movs	r3, #0
   186b6:	602b      	str	r3, [r5, #0]
	bt_mesh_pb_gatt_close(conn);
   186b8:	4620      	mov	r0, r4
   186ba:	f7ff fec7 	bl	1844c <bt_mesh_pb_gatt_close>
	if (bt_mesh_is_provisioned()) {
   186be:	f7f3 f97f 	bl	b9c0 <bt_mesh_is_provisioned>
   186c2:	b108      	cbz	r0, 186c8 <gatt_disconnected+0x38>
		(void)bt_mesh_pb_gatt_disable();
   186c4:	f7ff ffd0 	bl	18668 <bt_mesh_pb_gatt_disable>
}
   186c8:	b009      	add	sp, #36	; 0x24
   186ca:	bd30      	pop	{r4, r5, pc}
   186cc:	20003aed 	.word	0x20003aed
   186d0:	200028c0 	.word	0x200028c0

000186d4 <bt_mesh_pb_gatt_send>:
{
   186d4:	b530      	push	{r4, r5, lr}
   186d6:	4604      	mov	r4, r0
	if (!cli || cli->conn != conn) {
   186d8:	480e      	ldr	r0, [pc, #56]	; (18714 <bt_mesh_pb_gatt_send+0x40>)
   186da:	6800      	ldr	r0, [r0, #0]
{
   186dc:	b08b      	sub	sp, #44	; 0x2c
	if (!cli || cli->conn != conn) {
   186de:	b110      	cbz	r0, 186e6 <bt_mesh_pb_gatt_send+0x12>
   186e0:	6805      	ldr	r5, [r0, #0]
   186e2:	42a5      	cmp	r5, r4
   186e4:	d00f      	beq.n	18706 <bt_mesh_pb_gatt_send+0x32>
		BT_ERR("No PB-GATT Client found");
   186e6:	4b0c      	ldr	r3, [pc, #48]	; (18718 <bt_mesh_pb_gatt_send+0x44>)
   186e8:	9308      	str	r3, [sp, #32]
   186ea:	2302      	movs	r3, #2
   186ec:	9303      	str	r3, [sp, #12]
   186ee:	9307      	str	r3, [sp, #28]
   186f0:	480a      	ldr	r0, [pc, #40]	; (1871c <bt_mesh_pb_gatt_send+0x48>)
   186f2:	2300      	movs	r3, #0
   186f4:	aa07      	add	r2, sp, #28
   186f6:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   186fa:	f00d faed 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -ENOTCONN;
   186fe:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   18702:	b00b      	add	sp, #44	; 0x2c
   18704:	bd30      	pop	{r4, r5, pc}
	return bt_mesh_proxy_msg_send(cli, BT_MESH_PROXY_PROV, buf, end, user_data);
   18706:	9300      	str	r3, [sp, #0]
   18708:	4613      	mov	r3, r2
   1870a:	460a      	mov	r2, r1
   1870c:	2103      	movs	r1, #3
   1870e:	f011 fff0 	bl	2a6f2 <bt_mesh_proxy_msg_send>
   18712:	e7f6      	b.n	18702 <bt_mesh_pb_gatt_send+0x2e>
   18714:	200028c0 	.word	0x200028c0
   18718:	0003396e 	.word	0x0003396e
   1871c:	0002db5c 	.word	0x0002db5c

00018720 <bt_mesh_pb_gatt_adv_start>:

int bt_mesh_pb_gatt_adv_start(void)
{
   18720:	b570      	push	{r4, r5, r6, lr}
	BT_DBG("");

	if (!service_registered || bt_mesh_is_provisioned()) {
   18722:	4b36      	ldr	r3, [pc, #216]	; (187fc <bt_mesh_pb_gatt_adv_start+0xdc>)
   18724:	781b      	ldrb	r3, [r3, #0]
{
   18726:	b090      	sub	sp, #64	; 0x40
	if (!service_registered || bt_mesh_is_provisioned()) {
   18728:	b91b      	cbnz	r3, 18732 <bt_mesh_pb_gatt_adv_start+0x12>
		return -ENOTSUP;
   1872a:	f06f 0085 	mvn.w	r0, #133	; 0x85
	if (!err) {
		prov_fast_adv = false;
	}

	return err;
}
   1872e:	b010      	add	sp, #64	; 0x40
   18730:	bd70      	pop	{r4, r5, r6, pc}
	if (!service_registered || bt_mesh_is_provisioned()) {
   18732:	f7f3 f945 	bl	b9c0 <bt_mesh_is_provisioned>
   18736:	4604      	mov	r4, r0
   18738:	2800      	cmp	r0, #0
   1873a:	d1f6      	bne.n	1872a <bt_mesh_pb_gatt_adv_start+0xa>
	struct bt_le_adv_param fast_adv_param = {
   1873c:	2214      	movs	r2, #20
   1873e:	4601      	mov	r1, r0
   18740:	eb0d 0002 	add.w	r0, sp, r2
   18744:	f00f f89f 	bl	27886 <memset>
   18748:	f240 210b 	movw	r1, #523	; 0x20b
   1874c:	23a0      	movs	r3, #160	; 0xa0
   1874e:	e9cd 1306 	strd	r1, r3, [sp, #24]
   18752:	23f0      	movs	r3, #240	; 0xf0
   18754:	9308      	str	r3, [sp, #32]
	const struct bt_mesh_prov *prov = bt_mesh_prov_get();
   18756:	f7fe fa4d 	bl	16bf4 <bt_mesh_prov_get>
	memcpy(prov_svc_data + 2, prov->uuid, 16);
   1875a:	4e29      	ldr	r6, [pc, #164]	; (18800 <bt_mesh_pb_gatt_adv_start+0xe0>)
   1875c:	6801      	ldr	r1, [r0, #0]
	const struct bt_mesh_prov *prov = bt_mesh_prov_get();
   1875e:	4605      	mov	r5, r0
	memcpy(prov_svc_data + 2, prov->uuid, 16);
   18760:	2210      	movs	r2, #16
   18762:	1cb0      	adds	r0, r6, #2
   18764:	f00f f884 	bl	27870 <memcpy>
	sys_put_be16(prov->oob_info, prov_svc_data + 18);
   18768:	892b      	ldrh	r3, [r5, #8]
	dst[1] = val;
   1876a:	74f3      	strb	r3, [r6, #19]
	dst[0] = val >> 8;
   1876c:	0a1a      	lsrs	r2, r3, #8
   1876e:	74b2      	strb	r2, [r6, #18]
	if (!prov->uri) {
   18770:	6868      	ldr	r0, [r5, #4]
   18772:	2800      	cmp	r0, #0
   18774:	d033      	beq.n	187de <bt_mesh_pb_gatt_adv_start+0xbe>
	uri_len = strlen(prov->uri);
   18776:	f00f f83d 	bl	277f4 <strlen>
	if (uri_len > 29) {
   1877a:	281d      	cmp	r0, #29
   1877c:	d926      	bls.n	187cc <bt_mesh_pb_gatt_adv_start+0xac>
		BT_WARN("Too long URI to fit advertising packet");
   1877e:	4b21      	ldr	r3, [pc, #132]	; (18804 <bt_mesh_pb_gatt_adv_start+0xe4>)
   18780:	930e      	str	r3, [sp, #56]	; 0x38
   18782:	2302      	movs	r3, #2
   18784:	9303      	str	r3, [sp, #12]
   18786:	930d      	str	r3, [sp, #52]	; 0x34
   18788:	481f      	ldr	r0, [pc, #124]	; (18808 <bt_mesh_pb_gatt_adv_start+0xe8>)
   1878a:	4623      	mov	r3, r4
   1878c:	aa0d      	add	r2, sp, #52	; 0x34
   1878e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   18792:	f00d faa1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	if (!prov_fast_adv) {
   18796:	4d1d      	ldr	r5, [pc, #116]	; (1880c <bt_mesh_pb_gatt_adv_start+0xec>)
   18798:	7829      	ldrb	r1, [r5, #0]
   1879a:	ae03      	add	r6, sp, #12
   1879c:	bb09      	cbnz	r1, 187e2 <bt_mesh_pb_gatt_adv_start+0xc2>
		struct bt_le_adv_param slow_adv_param = {
   1879e:	2214      	movs	r2, #20
   187a0:	a80a      	add	r0, sp, #40	; 0x28
   187a2:	f00f f870 	bl	27886 <memset>
   187a6:	f240 220b 	movw	r2, #523	; 0x20b
   187aa:	f44f 63c8 	mov.w	r3, #1600	; 0x640
   187ae:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
   187b2:	f44f 63f0 	mov.w	r3, #1920	; 0x780
   187b6:	930d      	str	r3, [sp, #52]	; 0x34
		return bt_mesh_adv_gatt_start(&slow_adv_param, SYS_FOREVER_MS, prov_ad,
   187b8:	e9cd 6400 	strd	r6, r4, [sp]
   187bc:	4a14      	ldr	r2, [pc, #80]	; (18810 <bt_mesh_pb_gatt_adv_start+0xf0>)
   187be:	2303      	movs	r3, #3
   187c0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   187c4:	a80a      	add	r0, sp, #40	; 0x28
   187c6:	f7fc fc2f 	bl	15028 <bt_mesh_adv_gatt_start>
   187ca:	e7b0      	b.n	1872e <bt_mesh_pb_gatt_adv_start+0xe>
	prov_sd[0].type = BT_DATA_URI;
   187cc:	2324      	movs	r3, #36	; 0x24
   187ce:	f88d 300c 	strb.w	r3, [sp, #12]
	prov_sd[0].data_len = uri_len;
   187d2:	f88d 000d 	strb.w	r0, [sp, #13]
	prov_sd[0].data = (const uint8_t *)prov->uri;
   187d6:	686b      	ldr	r3, [r5, #4]
   187d8:	9304      	str	r3, [sp, #16]
	return 1;
   187da:	2401      	movs	r4, #1
   187dc:	e7db      	b.n	18796 <bt_mesh_pb_gatt_adv_start+0x76>
		return 0;
   187de:	4604      	mov	r4, r0
   187e0:	e7d9      	b.n	18796 <bt_mesh_pb_gatt_adv_start+0x76>
	err = bt_mesh_adv_gatt_start(&fast_adv_param, (60 * MSEC_PER_SEC),
   187e2:	e9cd 6400 	strd	r6, r4, [sp]
   187e6:	4a0a      	ldr	r2, [pc, #40]	; (18810 <bt_mesh_pb_gatt_adv_start+0xf0>)
   187e8:	2303      	movs	r3, #3
   187ea:	f64e 2160 	movw	r1, #60000	; 0xea60
   187ee:	a805      	add	r0, sp, #20
   187f0:	f7fc fc1a 	bl	15028 <bt_mesh_adv_gatt_start>
	if (!err) {
   187f4:	2800      	cmp	r0, #0
   187f6:	d19a      	bne.n	1872e <bt_mesh_pb_gatt_adv_start+0xe>
		prov_fast_adv = false;
   187f8:	7028      	strb	r0, [r5, #0]
   187fa:	e798      	b.n	1872e <bt_mesh_pb_gatt_adv_start+0xe>
   187fc:	20003aed 	.word	0x20003aed
   18800:	20000de3 	.word	0x20000de3
   18804:	00033a0e 	.word	0x00033a0e
   18808:	0002db5c 	.word	0x0002db5c
   1880c:	20003aec 	.word	0x20003aec
   18810:	0002e7ec 	.word	0x0002e7ec

00018814 <proxy_send_beacons>:
{
	struct bt_mesh_proxy_client *client;

	client = CONTAINER_OF(work, struct bt_mesh_proxy_client, send_beacons);

	(void)bt_mesh_subnet_find(send_beacon_cb, client);
   18814:	f1a0 010c 	sub.w	r1, r0, #12
   18818:	4801      	ldr	r0, [pc, #4]	; (18820 <proxy_send_beacons+0xc>)
   1881a:	f7f5 b911 	b.w	da40 <bt_mesh_subnet_find>
   1881e:	bf00      	nop
   18820:	0002a681 	.word	0x0002a681

00018824 <proxy_send>:
}

static int proxy_send(struct bt_conn *conn,
		      const void *data, uint16_t len,
		      bt_gatt_complete_func_t end, void *user_data)
{
   18824:	b5f0      	push	{r4, r5, r6, r7, lr}
   18826:	b087      	sub	sp, #28
   18828:	4604      	mov	r4, r0
   1882a:	460f      	mov	r7, r1
   1882c:	4616      	mov	r6, r2
	BT_DBG("%u bytes: %s", len, bt_hex(data, len));

	struct bt_gatt_notify_params params = {
   1882e:	2100      	movs	r1, #0
   18830:	2210      	movs	r2, #16
   18832:	4668      	mov	r0, sp
{
   18834:	461d      	mov	r5, r3
	struct bt_gatt_notify_params params = {
   18836:	f00f f826 	bl	27886 <memset>
   1883a:	4b07      	ldr	r3, [pc, #28]	; (18858 <proxy_send+0x34>)
   1883c:	f8ad 600c 	strh.w	r6, [sp, #12]
   18840:	e9cd 3701 	strd	r3, r7, [sp, #4]
		.attr = &proxy_attrs[3],
		.user_data = user_data,
		.func = end,
	};

	return bt_gatt_notify_cb(conn, &params);
   18844:	4669      	mov	r1, sp
	struct bt_gatt_notify_params params = {
   18846:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   18848:	9504      	str	r5, [sp, #16]
	return bt_gatt_notify_cb(conn, &params);
   1884a:	4620      	mov	r0, r4
	struct bt_gatt_notify_params params = {
   1884c:	9305      	str	r3, [sp, #20]
	return bt_gatt_notify_cb(conn, &params);
   1884e:	f7f2 fd17 	bl	b280 <bt_gatt_notify_cb>
}
   18852:	b007      	add	sp, #28
   18854:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18856:	bf00      	nop
   18858:	20000710 	.word	0x20000710

0001885c <bt_mesh_proxy_beacon_send>:
	if (!sub) {
   1885c:	4601      	mov	r1, r0
   1885e:	b920      	cbnz	r0, 1886a <bt_mesh_proxy_beacon_send+0xe>
		bt_mesh_subnet_foreach(bt_mesh_proxy_beacon_send);
   18860:	4804      	ldr	r0, [pc, #16]	; (18874 <bt_mesh_proxy_beacon_send+0x18>)
   18862:	f7f5 b911 	b.w	da88 <bt_mesh_subnet_foreach>
			beacon_send(&clients[i], sub);
   18866:	f011 bef0 	b.w	2a64a <beacon_send>
		if (clients[i].cli) {
   1886a:	4803      	ldr	r0, [pc, #12]	; (18878 <bt_mesh_proxy_beacon_send+0x1c>)
   1886c:	6803      	ldr	r3, [r0, #0]
   1886e:	2b00      	cmp	r3, #0
   18870:	d1f9      	bne.n	18866 <bt_mesh_proxy_beacon_send+0xa>
}
   18872:	4770      	bx	lr
   18874:	0001885d 	.word	0x0001885d
   18878:	200006b8 	.word	0x200006b8

0001887c <subnet_evt>:
	if (evt == BT_MESH_KEY_DELETED) {
   1887c:	2901      	cmp	r1, #1
   1887e:	d106      	bne.n	1888e <subnet_evt+0x12>
		if (sub == beacon_sub) {
   18880:	4a04      	ldr	r2, [pc, #16]	; (18894 <subnet_evt+0x18>)
   18882:	6811      	ldr	r1, [r2, #0]
   18884:	4288      	cmp	r0, r1
   18886:	d104      	bne.n	18892 <subnet_evt+0x16>
			beacon_sub = NULL;
   18888:	2300      	movs	r3, #0
   1888a:	6013      	str	r3, [r2, #0]
   1888c:	4770      	bx	lr
		bt_mesh_proxy_beacon_send(sub);
   1888e:	f7ff bfe5 	b.w	1885c <bt_mesh_proxy_beacon_send>
}
   18892:	4770      	bx	lr
   18894:	200028c4 	.word	0x200028c4

00018898 <gatt_connected>:
{
   18898:	b5f0      	push	{r4, r5, r6, r7, lr}
   1889a:	b089      	sub	sp, #36	; 0x24
	bt_conn_get_info(conn, &info);
   1889c:	a901      	add	r1, sp, #4
{
   1889e:	4604      	mov	r4, r0
	bt_conn_get_info(conn, &info);
   188a0:	f7f0 f90c 	bl	8abc <bt_conn_get_info>
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   188a4:	f89d 3005 	ldrb.w	r3, [sp, #5]
   188a8:	2b01      	cmp	r3, #1
   188aa:	d122      	bne.n	188f2 <gatt_connected+0x5a>
	    !service_registered) {
   188ac:	4b12      	ldr	r3, [pc, #72]	; (188f8 <gatt_connected+0x60>)
	if (info.role != BT_CONN_ROLE_PERIPHERAL ||
   188ae:	781b      	ldrb	r3, [r3, #0]
   188b0:	b1fb      	cbz	r3, 188f2 <gatt_connected+0x5a>
	conn_count++;
   188b2:	4d12      	ldr	r5, [pc, #72]	; (188fc <gatt_connected+0x64>)
	client->filter_type = NONE;
   188b4:	4e12      	ldr	r6, [pc, #72]	; (18900 <gatt_connected+0x68>)
	conn_count++;
   188b6:	682b      	ldr	r3, [r5, #0]
	return &clients[bt_conn_index(conn)];
   188b8:	4620      	mov	r0, r4
	conn_count++;
   188ba:	3301      	adds	r3, #1
   188bc:	602b      	str	r3, [r5, #0]
	return &clients[bt_conn_index(conn)];
   188be:	f7ef ffc9 	bl	8854 <bt_conn_index>
	client->filter_type = NONE;
   188c2:	231c      	movs	r3, #28
   188c4:	fb03 f700 	mul.w	r7, r3, r0
   188c8:	19f2      	adds	r2, r6, r7
   188ca:	2100      	movs	r1, #0
   188cc:	7291      	strb	r1, [r2, #10]
	(void)memset(client->filter, 0, sizeof(client->filter));
   188ce:	2204      	movs	r2, #4
   188d0:	fb13 2000 	smlabb	r0, r3, r0, r2
   188d4:	4430      	add	r0, r6
   188d6:	2206      	movs	r2, #6
   188d8:	f00e ffd5 	bl	27886 <memset>
	client->cli = bt_mesh_proxy_role_setup(conn, proxy_send,
   188dc:	4a09      	ldr	r2, [pc, #36]	; (18904 <gatt_connected+0x6c>)
   188de:	490a      	ldr	r1, [pc, #40]	; (18908 <gatt_connected+0x70>)
   188e0:	4620      	mov	r0, r4
   188e2:	f000 fd1b 	bl	1931c <bt_mesh_proxy_role_setup>
	if (conn_count < CONFIG_BT_MAX_CONN) {
   188e6:	682b      	ldr	r3, [r5, #0]
	client->cli = bt_mesh_proxy_role_setup(conn, proxy_send,
   188e8:	51f0      	str	r0, [r6, r7]
	if (conn_count < CONFIG_BT_MAX_CONN) {
   188ea:	2b00      	cmp	r3, #0
   188ec:	dc01      	bgt.n	188f2 <gatt_connected+0x5a>
		bt_mesh_adv_gatt_update();
   188ee:	f011 fcbc 	bl	2a26a <bt_mesh_adv_gatt_update>
}
   188f2:	b009      	add	sp, #36	; 0x24
   188f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   188f6:	bf00      	nop
   188f8:	20003aee 	.word	0x20003aee
   188fc:	200028c8 	.word	0x200028c8
   18900:	200006b8 	.word	0x200006b8
   18904:	00018ab5 	.word	0x00018ab5
   18908:	00018825 	.word	0x00018825

0001890c <proxy_ccc_write>:
{
   1890c:	b530      	push	{r4, r5, lr}
	if (value != BT_GATT_CCC_NOTIFY) {
   1890e:	2a01      	cmp	r2, #1
{
   18910:	b089      	sub	sp, #36	; 0x24
   18912:	4614      	mov	r4, r2
	if (value != BT_GATT_CCC_NOTIFY) {
   18914:	d00f      	beq.n	18936 <proxy_ccc_write+0x2a>
		BT_WARN("Client wrote 0x%04x instead enabling notify", value);
   18916:	4b10      	ldr	r3, [pc, #64]	; (18958 <proxy_ccc_write+0x4c>)
   18918:	4810      	ldr	r0, [pc, #64]	; (1895c <proxy_ccc_write+0x50>)
   1891a:	e9cd 3206 	strd	r3, r2, [sp, #24]
   1891e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   18922:	2303      	movs	r3, #3
   18924:	aa05      	add	r2, sp, #20
   18926:	9301      	str	r3, [sp, #4]
   18928:	9305      	str	r3, [sp, #20]
   1892a:	f011 fecb 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   1892e:	f06f 0012 	mvn.w	r0, #18
}
   18932:	b009      	add	sp, #36	; 0x24
   18934:	bd30      	pop	{r4, r5, pc}
	return &clients[bt_conn_index(conn)];
   18936:	f7ef ff8d 	bl	8854 <bt_conn_index>
	if (client->filter_type == NONE) {
   1893a:	4a09      	ldr	r2, [pc, #36]	; (18960 <proxy_ccc_write+0x54>)
   1893c:	231c      	movs	r3, #28
   1893e:	fb03 2100 	mla	r1, r3, r0, r2
   18942:	7a8d      	ldrb	r5, [r1, #10]
   18944:	b935      	cbnz	r5, 18954 <proxy_ccc_write+0x48>
		client->filter_type = ACCEPT;
   18946:	728c      	strb	r4, [r1, #10]
		k_work_submit(&client->send_beacons);
   18948:	210c      	movs	r1, #12
   1894a:	fb13 1000 	smlabb	r0, r3, r0, r1
   1894e:	4410      	add	r0, r2
   18950:	f00b fc6c 	bl	2422c <k_work_submit>
	return sizeof(value);
   18954:	2002      	movs	r0, #2
   18956:	e7ec      	b.n	18932 <proxy_ccc_write+0x26>
   18958:	00033986 	.word	0x00033986
   1895c:	0002db14 	.word	0x0002db14
   18960:	200006b8 	.word	0x200006b8

00018964 <send_filter_status>:
{
   18964:	b570      	push	{r4, r5, r6, lr}
	struct bt_mesh_net_tx tx = {
   18966:	f851 3b04 	ldr.w	r3, [r1], #4
{
   1896a:	b08c      	sub	sp, #48	; 0x30
	struct bt_mesh_net_tx tx = {
   1896c:	2600      	movs	r6, #0
{
   1896e:	4614      	mov	r4, r2
   18970:	4605      	mov	r5, r0
	struct bt_mesh_net_tx tx = {
   18972:	e9cd 3103 	strd	r3, r1, [sp, #12]
   18976:	9605      	str	r6, [sp, #20]
		.src = bt_mesh_primary_addr(),
   18978:	f7f8 fa74 	bl	10e64 <bt_mesh_primary_addr>
	tx.ctx->addr = BT_MESH_ADDR_UNASSIGNED;
   1897c:	9b04      	ldr	r3, [sp, #16]
	struct bt_mesh_net_tx tx = {
   1897e:	f8ad 0014 	strh.w	r0, [sp, #20]
	tx.ctx->addr = BT_MESH_ADDR_UNASSIGNED;
   18982:	809e      	strh	r6, [r3, #4]
	buf->data = buf->__buf;
   18984:	68a3      	ldr	r3, [r4, #8]
   18986:	6023      	str	r3, [r4, #0]
	net_buf_simple_reserve(buf, 10);
   18988:	210a      	movs	r1, #10
   1898a:	4620      	mov	r0, r4
	buf->len  = 0U;
   1898c:	80a6      	strh	r6, [r4, #4]
   1898e:	f013 f96f 	bl	2bc70 <net_buf_simple_reserve>
	net_buf_simple_add_u8(buf, CFG_FILTER_STATUS);
   18992:	2103      	movs	r1, #3
   18994:	4620      	mov	r0, r4
   18996:	f013 f9e0 	bl	2bd5a <net_buf_simple_add_u8>
	if (client->filter_type == ACCEPT) {
   1899a:	7aab      	ldrb	r3, [r5, #10]
   1899c:	2b01      	cmp	r3, #1
		net_buf_simple_add_u8(buf, 0x00);
   1899e:	bf0c      	ite	eq
   189a0:	4631      	moveq	r1, r6
		net_buf_simple_add_u8(buf, 0x01);
   189a2:	2101      	movne	r1, #1
   189a4:	4620      	mov	r0, r4
   189a6:	f013 f9d8 	bl	2bd5a <net_buf_simple_add_u8>
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   189aa:	88a9      	ldrh	r1, [r5, #4]
   189ac:	88eb      	ldrh	r3, [r5, #6]
	for (filter_size = 0U, i = 0; i < ARRAY_SIZE(client->filter); i++) {
   189ae:	3900      	subs	r1, #0
   189b0:	bf18      	it	ne
   189b2:	2101      	movne	r1, #1
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   189b4:	b103      	cbz	r3, 189b8 <send_filter_status+0x54>
			filter_size++;
   189b6:	3101      	adds	r1, #1
		if (client->filter[i] != BT_MESH_ADDR_UNASSIGNED) {
   189b8:	892b      	ldrh	r3, [r5, #8]
   189ba:	b10b      	cbz	r3, 189c0 <send_filter_status+0x5c>
			filter_size++;
   189bc:	3101      	adds	r1, #1
   189be:	b289      	uxth	r1, r1
	net_buf_simple_add_be16(buf, filter_size);
   189c0:	4620      	mov	r0, r4
   189c2:	f013 f9dc 	bl	2bd7e <net_buf_simple_add_be16>
	err = bt_mesh_net_encode(&tx, buf, true);
   189c6:	2201      	movs	r2, #1
   189c8:	4621      	mov	r1, r4
   189ca:	a803      	add	r0, sp, #12
   189cc:	f7f4 fa2c 	bl	ce28 <bt_mesh_net_encode>
	if (err) {
   189d0:	4603      	mov	r3, r0
   189d2:	b168      	cbz	r0, 189f0 <send_filter_status+0x8c>
		BT_ERR("Encoding Proxy cfg message failed (err %d)", err);
   189d4:	4a0c      	ldr	r2, [pc, #48]	; (18a08 <send_filter_status+0xa4>)
   189d6:	e9cd 200a 	strd	r2, r0, [sp, #40]	; 0x28
		BT_ERR("Failed to send proxy cfg message (err %d)", err);
   189da:	2303      	movs	r3, #3
   189dc:	480b      	ldr	r0, [pc, #44]	; (18a0c <send_filter_status+0xa8>)
   189de:	9302      	str	r3, [sp, #8]
   189e0:	aa09      	add	r2, sp, #36	; 0x24
   189e2:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   189e6:	9309      	str	r3, [sp, #36]	; 0x24
   189e8:	f011 fe6c 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
}
   189ec:	b00c      	add	sp, #48	; 0x30
   189ee:	bd70      	pop	{r4, r5, r6, pc}
	err = bt_mesh_proxy_msg_send(client->cli, BT_MESH_PROXY_CONFIG,
   189f0:	9000      	str	r0, [sp, #0]
   189f2:	4622      	mov	r2, r4
   189f4:	6828      	ldr	r0, [r5, #0]
   189f6:	2102      	movs	r1, #2
   189f8:	f011 fe7b 	bl	2a6f2 <bt_mesh_proxy_msg_send>
	if (err) {
   189fc:	2800      	cmp	r0, #0
   189fe:	d0f5      	beq.n	189ec <send_filter_status+0x88>
		BT_ERR("Failed to send proxy cfg message (err %d)", err);
   18a00:	4b03      	ldr	r3, [pc, #12]	; (18a10 <send_filter_status+0xac>)
   18a02:	e9cd 300a 	strd	r3, r0, [sp, #40]	; 0x28
   18a06:	e7e8      	b.n	189da <send_filter_status+0x76>
   18a08:	00033a49 	.word	0x00033a49
   18a0c:	0002db14 	.word	0x0002db14
   18a10:	00033a74 	.word	0x00033a74

00018a14 <gatt_recv>:
{
   18a14:	b530      	push	{r4, r5, lr}
   18a16:	461d      	mov	r5, r3
   18a18:	b089      	sub	sp, #36	; 0x24
   18a1a:	4614      	mov	r4, r2
	return &clients[bt_conn_index(conn)];
   18a1c:	f7ef ff1a 	bl	8854 <bt_conn_index>
	if (len < 1) {
   18a20:	b975      	cbnz	r5, 18a40 <gatt_recv+0x2c>
		BT_WARN("Too small Proxy PDU");
   18a22:	4b10      	ldr	r3, [pc, #64]	; (18a64 <gatt_recv+0x50>)
		BT_WARN("Proxy PDU type doesn't match GATT service");
   18a24:	9306      	str	r3, [sp, #24]
   18a26:	4810      	ldr	r0, [pc, #64]	; (18a68 <gatt_recv+0x54>)
   18a28:	2302      	movs	r3, #2
   18a2a:	aa05      	add	r2, sp, #20
   18a2c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   18a30:	9301      	str	r3, [sp, #4]
   18a32:	9305      	str	r3, [sp, #20]
   18a34:	f011 fe46 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
}
   18a38:	f06f 0015 	mvn.w	r0, #21
   18a3c:	b009      	add	sp, #36	; 0x24
   18a3e:	bd30      	pop	{r4, r5, pc}
	if (PDU_TYPE(data) == BT_MESH_PROXY_PROV) {
   18a40:	7823      	ldrb	r3, [r4, #0]
   18a42:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   18a46:	2b03      	cmp	r3, #3
   18a48:	d101      	bne.n	18a4e <gatt_recv+0x3a>
		BT_WARN("Proxy PDU type doesn't match GATT service");
   18a4a:	4b08      	ldr	r3, [pc, #32]	; (18a6c <gatt_recv+0x58>)
   18a4c:	e7ea      	b.n	18a24 <gatt_recv+0x10>
	return bt_mesh_proxy_msg_recv(client->cli, buf, len);
   18a4e:	231c      	movs	r3, #28
   18a50:	4358      	muls	r0, r3
   18a52:	4b07      	ldr	r3, [pc, #28]	; (18a70 <gatt_recv+0x5c>)
   18a54:	5818      	ldr	r0, [r3, r0]
   18a56:	462a      	mov	r2, r5
   18a58:	4621      	mov	r1, r4
}
   18a5a:	b009      	add	sp, #36	; 0x24
   18a5c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return bt_mesh_proxy_msg_recv(client->cli, buf, len);
   18a60:	f000 bbdc 	b.w	1921c <bt_mesh_proxy_msg_recv>
   18a64:	000339b2 	.word	0x000339b2
   18a68:	0002db14 	.word	0x0002db14
   18a6c:	000339c6 	.word	0x000339c6
   18a70:	200006b8 	.word	0x200006b8

00018a74 <node_id_start>:
	sub->node_id = BT_MESH_NODE_IDENTITY_RUNNING;
   18a74:	2301      	movs	r3, #1
{
   18a76:	b570      	push	{r4, r5, r6, lr}
   18a78:	4604      	mov	r4, r0
	sub->node_id = BT_MESH_NODE_IDENTITY_RUNNING;
   18a7a:	77c3      	strb	r3, [r0, #31]
   18a7c:	f014 fb68 	bl	2d150 <z_impl_k_uptime_ticks>
   18a80:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   18a84:	fba0 3002 	umull	r3, r0, r0, r2
   18a88:	fb02 0001 	mla	r0, r2, r1, r0
   18a8c:	0bdb      	lsrs	r3, r3, #15
   18a8e:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
	STRUCT_SECTION_FOREACH(bt_mesh_proxy_cb, cb) {
   18a92:	4d06      	ldr	r5, [pc, #24]	; (18aac <node_id_start+0x38>)
   18a94:	4e06      	ldr	r6, [pc, #24]	; (18ab0 <node_id_start+0x3c>)
   18a96:	6223      	str	r3, [r4, #32]
   18a98:	42b5      	cmp	r5, r6
   18a9a:	d300      	bcc.n	18a9e <node_id_start+0x2a>
}
   18a9c:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->identity_enabled) {
   18a9e:	682b      	ldr	r3, [r5, #0]
   18aa0:	b10b      	cbz	r3, 18aa6 <node_id_start+0x32>
			cb->identity_enabled(sub->net_idx);
   18aa2:	8ba0      	ldrh	r0, [r4, #28]
   18aa4:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_proxy_cb, cb) {
   18aa6:	3508      	adds	r5, #8
   18aa8:	e7f6      	b.n	18a98 <node_id_start+0x24>
   18aaa:	bf00      	nop
   18aac:	0002d868 	.word	0x0002d868
   18ab0:	0002d868 	.word	0x0002d868

00018ab4 <proxy_msg_recv>:
{
   18ab4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18ab8:	b099      	sub	sp, #100	; 0x64
	switch (role->msg_type) {
   18aba:	7905      	ldrb	r5, [r0, #4]
   18abc:	2d01      	cmp	r5, #1
{
   18abe:	af00      	add	r7, sp, #0
   18ac0:	4604      	mov	r4, r0
	switch (role->msg_type) {
   18ac2:	d00d      	beq.n	18ae0 <proxy_msg_recv+0x2c>
   18ac4:	2d02      	cmp	r5, #2
   18ac6:	d00f      	beq.n	18ae8 <proxy_msg_recv+0x34>
   18ac8:	2d00      	cmp	r5, #0
   18aca:	f040 80e6 	bne.w	18c9a <proxy_msg_recv+0x1e6>
		bt_mesh_net_recv(&role->buf, 0, BT_MESH_NET_IF_PROXY);
   18ace:	2202      	movs	r2, #2
   18ad0:	4629      	mov	r1, r5
   18ad2:	3040      	adds	r0, #64	; 0x40
   18ad4:	f7f4 fbb8 	bl	d248 <bt_mesh_net_recv>
}
   18ad8:	3764      	adds	r7, #100	; 0x64
   18ada:	46bd      	mov	sp, r7
   18adc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bt_mesh_beacon_recv(&role->buf);
   18ae0:	3040      	adds	r0, #64	; 0x40
   18ae2:	f7f3 fd17 	bl	c514 <bt_mesh_beacon_recv>
		break;
   18ae6:	e7f7      	b.n	18ad8 <proxy_msg_recv+0x24>
	NET_BUF_SIMPLE_DEFINE(buf, BT_MESH_NET_MAX_PDU_LEN);
   18ae8:	f107 0340 	add.w	r3, r7, #64	; 0x40
   18aec:	f44f 12e8 	mov.w	r2, #1900544	; 0x1d0000
   18af0:	e9c7 2302 	strd	r2, r3, [r7, #8]
   18af4:	607b      	str	r3, [r7, #4]
	err = bt_mesh_net_decode(&role->buf, BT_MESH_NET_IF_PROXY_CFG,
   18af6:	2103      	movs	r1, #3
   18af8:	1d3b      	adds	r3, r7, #4
   18afa:	f107 0228 	add.w	r2, r7, #40	; 0x28
   18afe:	3040      	adds	r0, #64	; 0x40
   18b00:	f7f4 face 	bl	d0a0 <bt_mesh_net_decode>
	if (err) {
   18b04:	4601      	mov	r1, r0
   18b06:	b168      	cbz	r0, 18b24 <proxy_msg_recv+0x70>
		BT_ERR("Failed to decode Proxy Configuration (err %d)", err);
   18b08:	4b68      	ldr	r3, [pc, #416]	; (18cac <proxy_msg_recv+0x1f8>)
   18b0a:	e9c7 3008 	strd	r3, r0, [r7, #32]
   18b0e:	2303      	movs	r3, #3
   18b10:	603b      	str	r3, [r7, #0]
   18b12:	61fb      	str	r3, [r7, #28]
   18b14:	f107 021c 	add.w	r2, r7, #28
   18b18:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
		BT_WARN("Unhandled Message Type 0x%02x", role->msg_type);
   18b1c:	4864      	ldr	r0, [pc, #400]	; (18cb0 <proxy_msg_recv+0x1fc>)
   18b1e:	f011 fdd1 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
}
   18b22:	e7d9      	b.n	18ad8 <proxy_msg_recv+0x24>
	rx.local_match = 1U;
   18b24:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
	if (bt_mesh_rpl_check(&rx, NULL)) {
   18b28:	f107 0028 	add.w	r0, r7, #40	; 0x28
	rx.local_match = 1U;
   18b2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   18b30:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
	if (bt_mesh_rpl_check(&rx, NULL)) {
   18b34:	f7f7 f82c 	bl	fb90 <bt_mesh_rpl_check>
   18b38:	b1a8      	cbz	r0, 18b66 <proxy_msg_recv+0xb2>
		BT_WARN("Replay: src 0x%04x dst 0x%04x seq 0x%06x",
   18b3a:	466c      	mov	r4, sp
   18b3c:	b088      	sub	sp, #32
   18b3e:	466a      	mov	r2, sp
   18b40:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
   18b42:	8e39      	ldrh	r1, [r7, #48]	; 0x30
   18b44:	6193      	str	r3, [r2, #24]
   18b46:	485b      	ldr	r0, [pc, #364]	; (18cb4 <proxy_msg_recv+0x200>)
   18b48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   18b4a:	61d3      	str	r3, [r2, #28]
   18b4c:	2305      	movs	r3, #5
   18b4e:	e9c2 0104 	strd	r0, r1, [r2, #16]
   18b52:	f842 3f0c 	str.w	r3, [r2, #12]!
   18b56:	4856      	ldr	r0, [pc, #344]	; (18cb0 <proxy_msg_recv+0x1fc>)
   18b58:	613b      	str	r3, [r7, #16]
   18b5a:	f44f 5122 	mov.w	r1, #10368	; 0x2880
   18b5e:	f011 fdb1 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
   18b62:	46a5      	mov	sp, r4
		return;
   18b64:	e7b8      	b.n	18ad8 <proxy_msg_recv+0x24>
	net_buf_simple_pull(&buf, BT_MESH_NET_HDR_LEN);
   18b66:	2109      	movs	r1, #9
   18b68:	1d38      	adds	r0, r7, #4
   18b6a:	f013 f957 	bl	2be1c <net_buf_simple_pull>
	if (buf.len < 1) {
   18b6e:	893b      	ldrh	r3, [r7, #8]
   18b70:	b943      	cbnz	r3, 18b84 <proxy_msg_recv+0xd0>
		BT_WARN("Too short proxy configuration PDU");
   18b72:	4b51      	ldr	r3, [pc, #324]	; (18cb8 <proxy_msg_recv+0x204>)
   18b74:	623b      	str	r3, [r7, #32]
   18b76:	603d      	str	r5, [r7, #0]
   18b78:	61fd      	str	r5, [r7, #28]
   18b7a:	f107 021c 	add.w	r2, r7, #28
   18b7e:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   18b82:	e7cb      	b.n	18b1c <proxy_msg_recv+0x68>
	return &clients[bt_conn_index(conn)];
   18b84:	6820      	ldr	r0, [r4, #0]
   18b86:	f8df 8134 	ldr.w	r8, [pc, #308]	; 18cbc <proxy_msg_recv+0x208>
   18b8a:	f7ef fe63 	bl	8854 <bt_conn_index>
   18b8e:	b204      	sxth	r4, r0
   18b90:	4606      	mov	r6, r0
	opcode = net_buf_simple_pull_u8(buf);
   18b92:	1d38      	adds	r0, r7, #4
   18b94:	f013 f952 	bl	2be3c <net_buf_simple_pull_u8>
   18b98:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
	switch (opcode) {
   18b9c:	2801      	cmp	r0, #1
   18b9e:	ea4f 0984 	mov.w	r9, r4, lsl #2
	return &clients[bt_conn_index(conn)];
   18ba2:	eb08 0484 	add.w	r4, r8, r4, lsl #2
	switch (opcode) {
   18ba6:	d065      	beq.n	18c74 <proxy_msg_recv+0x1c0>
   18ba8:	2802      	cmp	r0, #2
   18baa:	d11c      	bne.n	18be6 <proxy_msg_recv+0x132>
		if (client->filter[i] == addr) {
   18bac:	251c      	movs	r5, #28
   18bae:	fb05 8506 	mla	r5, r5, r6, r8
		while (buf->len >= 2) {
   18bb2:	893b      	ldrh	r3, [r7, #8]
   18bb4:	2b01      	cmp	r3, #1
   18bb6:	d943      	bls.n	18c40 <proxy_msg_recv+0x18c>
			addr = net_buf_simple_pull_be16(buf);
   18bb8:	1d38      	adds	r0, r7, #4
   18bba:	f013 f94f 	bl	2be5c <net_buf_simple_pull_be16>
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   18bbe:	2800      	cmp	r0, #0
   18bc0:	d0f7      	beq.n	18bb2 <proxy_msg_recv+0xfe>
		if (client->filter[i] == addr) {
   18bc2:	88ab      	ldrh	r3, [r5, #4]
   18bc4:	4283      	cmp	r3, r0
   18bc6:	d059      	beq.n	18c7c <proxy_msg_recv+0x1c8>
   18bc8:	88eb      	ldrh	r3, [r5, #6]
   18bca:	4283      	cmp	r3, r0
   18bcc:	d058      	beq.n	18c80 <proxy_msg_recv+0x1cc>
   18bce:	892b      	ldrh	r3, [r5, #8]
   18bd0:	4283      	cmp	r3, r0
   18bd2:	d1ee      	bne.n	18bb2 <proxy_msg_recv+0xfe>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   18bd4:	2302      	movs	r3, #2
			client->filter[i] = BT_MESH_ADDR_UNASSIGNED;
   18bd6:	220e      	movs	r2, #14
   18bd8:	fb02 3306 	mla	r3, r2, r6, r3
   18bdc:	eb08 0343 	add.w	r3, r8, r3, lsl #1
   18be0:	2200      	movs	r2, #0
   18be2:	809a      	strh	r2, [r3, #4]
			return;
   18be4:	e7e5      	b.n	18bb2 <proxy_msg_recv+0xfe>
	switch (opcode) {
   18be6:	2800      	cmp	r0, #0
   18be8:	d14c      	bne.n	18c84 <proxy_msg_recv+0x1d0>
	if (buf->len < 1) {
   18bea:	893b      	ldrh	r3, [r7, #8]
   18bec:	b95b      	cbnz	r3, 18c06 <proxy_msg_recv+0x152>
		BT_WARN("Too short Filter Set message");
   18bee:	4b34      	ldr	r3, [pc, #208]	; (18cc0 <proxy_msg_recv+0x20c>)
   18bf0:	623b      	str	r3, [r7, #32]
   18bf2:	603d      	str	r5, [r7, #0]
   18bf4:	61fd      	str	r5, [r7, #28]
   18bf6:	f107 021c 	add.w	r2, r7, #28
   18bfa:	f44f 5184 	mov.w	r1, #4224	; 0x1080
		BT_WARN("Prohibited Filter Type 0x%02x", type);
   18bfe:	482c      	ldr	r0, [pc, #176]	; (18cb0 <proxy_msg_recv+0x1fc>)
   18c00:	f011 fd60 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
		return -EINVAL;
   18c04:	e01c      	b.n	18c40 <proxy_msg_recv+0x18c>
	type = net_buf_simple_pull_u8(buf);
   18c06:	1d38      	adds	r0, r7, #4
   18c08:	f013 f918 	bl	2be3c <net_buf_simple_pull_u8>
	switch (type) {
   18c0c:	b160      	cbz	r0, 18c28 <proxy_msg_recv+0x174>
   18c0e:	2801      	cmp	r0, #1
   18c10:	d01d      	beq.n	18c4e <proxy_msg_recv+0x19a>
		BT_WARN("Prohibited Filter Type 0x%02x", type);
   18c12:	4b2c      	ldr	r3, [pc, #176]	; (18cc4 <proxy_msg_recv+0x210>)
	switch (type) {
   18c14:	e9c7 3008 	strd	r3, r0, [r7, #32]
		BT_WARN("Prohibited Filter Type 0x%02x", type);
   18c18:	2303      	movs	r3, #3
   18c1a:	603b      	str	r3, [r7, #0]
   18c1c:	61fb      	str	r3, [r7, #28]
   18c1e:	f107 021c 	add.w	r2, r7, #28
   18c22:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   18c26:	e7ea      	b.n	18bfe <proxy_msg_recv+0x14a>
		(void)memset(client->filter, 0, sizeof(client->filter));
   18c28:	f109 0004 	add.w	r0, r9, #4
   18c2c:	2206      	movs	r2, #6
   18c2e:	2100      	movs	r1, #0
   18c30:	4440      	add	r0, r8
   18c32:	f00e fe28 	bl	27886 <memset>
		client->filter_type = ACCEPT;
   18c36:	201c      	movs	r0, #28
   18c38:	fb00 8606 	mla	r6, r0, r6, r8
   18c3c:	2301      	movs	r3, #1
		client->filter_type = REJECT;
   18c3e:	72b3      	strb	r3, [r6, #10]
		send_filter_status(client, rx, buf);
   18c40:	1d3a      	adds	r2, r7, #4
   18c42:	f107 0128 	add.w	r1, r7, #40	; 0x28
   18c46:	4620      	mov	r0, r4
   18c48:	f7ff fe8c 	bl	18964 <send_filter_status>
		break;
   18c4c:	e744      	b.n	18ad8 <proxy_msg_recv+0x24>
		(void)memset(client->filter, 0, sizeof(client->filter));
   18c4e:	f109 0004 	add.w	r0, r9, #4
   18c52:	2206      	movs	r2, #6
   18c54:	2100      	movs	r1, #0
   18c56:	4440      	add	r0, r8
   18c58:	f00e fe15 	bl	27886 <memset>
		client->filter_type = REJECT;
   18c5c:	201c      	movs	r0, #28
   18c5e:	fb00 8606 	mla	r6, r0, r6, r8
   18c62:	2302      	movs	r3, #2
   18c64:	e7eb      	b.n	18c3e <proxy_msg_recv+0x18a>
			addr = net_buf_simple_pull_be16(buf);
   18c66:	1d38      	adds	r0, r7, #4
   18c68:	f013 f8f8 	bl	2be5c <net_buf_simple_pull_be16>
   18c6c:	4601      	mov	r1, r0
			filter_add(client, addr);
   18c6e:	4620      	mov	r0, r4
   18c70:	f011 fd13 	bl	2a69a <filter_add>
		while (buf->len >= 2) {
   18c74:	893b      	ldrh	r3, [r7, #8]
   18c76:	2b01      	cmp	r3, #1
   18c78:	d8f5      	bhi.n	18c66 <proxy_msg_recv+0x1b2>
   18c7a:	e7e1      	b.n	18c40 <proxy_msg_recv+0x18c>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   18c7c:	2300      	movs	r3, #0
   18c7e:	e7aa      	b.n	18bd6 <proxy_msg_recv+0x122>
   18c80:	2301      	movs	r3, #1
   18c82:	e7a8      	b.n	18bd6 <proxy_msg_recv+0x122>
		BT_WARN("Unhandled configuration OpCode 0x%02x", opcode);
   18c84:	4b10      	ldr	r3, [pc, #64]	; (18cc8 <proxy_msg_recv+0x214>)
	switch (opcode) {
   18c86:	e9c7 3008 	strd	r3, r0, [r7, #32]
		BT_WARN("Unhandled configuration OpCode 0x%02x", opcode);
   18c8a:	2303      	movs	r3, #3
   18c8c:	603b      	str	r3, [r7, #0]
   18c8e:	61fb      	str	r3, [r7, #28]
   18c90:	f107 021c 	add.w	r2, r7, #28
		BT_WARN("Unhandled Message Type 0x%02x", role->msg_type);
   18c94:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   18c98:	e740      	b.n	18b1c <proxy_msg_recv+0x68>
   18c9a:	4b0c      	ldr	r3, [pc, #48]	; (18ccc <proxy_msg_recv+0x218>)
	switch (role->msg_type) {
   18c9c:	e9c7 3514 	strd	r3, r5, [r7, #80]	; 0x50
		BT_WARN("Unhandled Message Type 0x%02x", role->msg_type);
   18ca0:	2303      	movs	r3, #3
   18ca2:	62bb      	str	r3, [r7, #40]	; 0x28
   18ca4:	64fb      	str	r3, [r7, #76]	; 0x4c
   18ca6:	f107 024c 	add.w	r2, r7, #76	; 0x4c
   18caa:	e7f3      	b.n	18c94 <proxy_msg_recv+0x1e0>
   18cac:	00033a9e 	.word	0x00033a9e
   18cb0:	0002db14 	.word	0x0002db14
   18cb4:	00031328 	.word	0x00031328
   18cb8:	00033acc 	.word	0x00033acc
   18cbc:	200006b8 	.word	0x200006b8
   18cc0:	00033aee 	.word	0x00033aee
   18cc4:	00033b0b 	.word	0x00033b0b
   18cc8:	00033b29 	.word	0x00033b29
   18ccc:	000339f0 	.word	0x000339f0

00018cd0 <bt_mesh_proxy_identity_start>:
{
   18cd0:	b510      	push	{r4, lr}
   18cd2:	4604      	mov	r4, r0
	node_id_start(sub);
   18cd4:	f7ff fece 	bl	18a74 <node_id_start>
	beacon_sub = sub;
   18cd8:	4b01      	ldr	r3, [pc, #4]	; (18ce0 <bt_mesh_proxy_identity_start+0x10>)
   18cda:	601c      	str	r4, [r3, #0]
}
   18cdc:	bd10      	pop	{r4, pc}
   18cde:	bf00      	nop
   18ce0:	200028c4 	.word	0x200028c4

00018ce4 <bt_mesh_proxy_identity_stop>:
{
   18ce4:	b570      	push	{r4, r5, r6, lr}
	sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   18ce6:	2300      	movs	r3, #0
	STRUCT_SECTION_FOREACH(bt_mesh_proxy_cb, cb) {
   18ce8:	4d06      	ldr	r5, [pc, #24]	; (18d04 <bt_mesh_proxy_identity_stop+0x20>)
   18cea:	4e07      	ldr	r6, [pc, #28]	; (18d08 <bt_mesh_proxy_identity_stop+0x24>)
	sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   18cec:	77c3      	strb	r3, [r0, #31]
{
   18cee:	4604      	mov	r4, r0
	sub->node_id_start = 0U;
   18cf0:	6203      	str	r3, [r0, #32]
	STRUCT_SECTION_FOREACH(bt_mesh_proxy_cb, cb) {
   18cf2:	42b5      	cmp	r5, r6
   18cf4:	d300      	bcc.n	18cf8 <bt_mesh_proxy_identity_stop+0x14>
}
   18cf6:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->identity_disabled) {
   18cf8:	686b      	ldr	r3, [r5, #4]
   18cfa:	b10b      	cbz	r3, 18d00 <bt_mesh_proxy_identity_stop+0x1c>
			cb->identity_disabled(sub->net_idx);
   18cfc:	8ba0      	ldrh	r0, [r4, #28]
   18cfe:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(bt_mesh_proxy_cb, cb) {
   18d00:	3508      	adds	r5, #8
   18d02:	e7f6      	b.n	18cf2 <bt_mesh_proxy_identity_stop+0xe>
   18d04:	0002d868 	.word	0x0002d868
   18d08:	0002d868 	.word	0x0002d868

00018d0c <bt_mesh_proxy_identity_enable>:
{
   18d0c:	b508      	push	{r3, lr}
	if (!bt_mesh_is_provisioned()) {
   18d0e:	f7f2 fe57 	bl	b9c0 <bt_mesh_is_provisioned>
   18d12:	b138      	cbz	r0, 18d24 <bt_mesh_proxy_identity_enable+0x18>
	if (bt_mesh_subnet_foreach(node_id_start)) {
   18d14:	4805      	ldr	r0, [pc, #20]	; (18d2c <bt_mesh_proxy_identity_enable+0x20>)
   18d16:	f7f4 feb7 	bl	da88 <bt_mesh_subnet_foreach>
   18d1a:	b110      	cbz	r0, 18d22 <bt_mesh_proxy_identity_enable+0x16>
		bt_mesh_adv_gatt_update();
   18d1c:	f011 faa5 	bl	2a26a <bt_mesh_adv_gatt_update>
	return 0;
   18d20:	2000      	movs	r0, #0
}
   18d22:	bd08      	pop	{r3, pc}
		return -EAGAIN;
   18d24:	f06f 000a 	mvn.w	r0, #10
   18d28:	e7fb      	b.n	18d22 <bt_mesh_proxy_identity_enable+0x16>
   18d2a:	bf00      	nop
   18d2c:	00018a75 	.word	0x00018a75

00018d30 <bt_mesh_proxy_gatt_enable>:
{
   18d30:	b538      	push	{r3, r4, r5, lr}
	if (!bt_mesh_is_provisioned()) {
   18d32:	f7f2 fe45 	bl	b9c0 <bt_mesh_is_provisioned>
   18d36:	b168      	cbz	r0, 18d54 <bt_mesh_proxy_gatt_enable+0x24>
	if (service_registered) {
   18d38:	4d09      	ldr	r5, [pc, #36]	; (18d60 <bt_mesh_proxy_gatt_enable+0x30>)
   18d3a:	782c      	ldrb	r4, [r5, #0]
   18d3c:	b96c      	cbnz	r4, 18d5a <bt_mesh_proxy_gatt_enable+0x2a>
	(void)bt_gatt_service_register(&proxy_svc);
   18d3e:	4809      	ldr	r0, [pc, #36]	; (18d64 <bt_mesh_proxy_gatt_enable+0x34>)
   18d40:	f7f1 ffb6 	bl	acb0 <bt_gatt_service_register>
		if (clients[i].cli) {
   18d44:	4b08      	ldr	r3, [pc, #32]	; (18d68 <bt_mesh_proxy_gatt_enable+0x38>)
   18d46:	6818      	ldr	r0, [r3, #0]
	service_registered = true;
   18d48:	2201      	movs	r2, #1
   18d4a:	702a      	strb	r2, [r5, #0]
		if (clients[i].cli) {
   18d4c:	b108      	cbz	r0, 18d52 <bt_mesh_proxy_gatt_enable+0x22>
			clients[i].filter_type = ACCEPT;
   18d4e:	729a      	strb	r2, [r3, #10]
	for (i = 0; i < ARRAY_SIZE(clients); i++) {
   18d50:	4620      	mov	r0, r4
}
   18d52:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   18d54:	f06f 0085 	mvn.w	r0, #133	; 0x85
   18d58:	e7fb      	b.n	18d52 <bt_mesh_proxy_gatt_enable+0x22>
		return -EBUSY;
   18d5a:	f06f 000f 	mvn.w	r0, #15
   18d5e:	e7f8      	b.n	18d52 <bt_mesh_proxy_gatt_enable+0x22>
   18d60:	20003aee 	.word	0x20003aee
   18d64:	20000764 	.word	0x20000764
   18d68:	200006b8 	.word	0x200006b8

00018d6c <gatt_disconnected>:
{
   18d6c:	b530      	push	{r4, r5, lr}
   18d6e:	b089      	sub	sp, #36	; 0x24
	bt_conn_get_info(conn, &info);
   18d70:	a901      	add	r1, sp, #4
{
   18d72:	4604      	mov	r4, r0
	bt_conn_get_info(conn, &info);
   18d74:	f7ef fea2 	bl	8abc <bt_conn_get_info>
	if (info.role != BT_CONN_ROLE_PERIPHERAL) {
   18d78:	f89d 3005 	ldrb.w	r3, [sp, #5]
   18d7c:	2b01      	cmp	r3, #1
   18d7e:	d107      	bne.n	18d90 <gatt_disconnected+0x24>
	if (!service_registered && bt_mesh_is_provisioned()) {
   18d80:	4b0d      	ldr	r3, [pc, #52]	; (18db8 <gatt_disconnected+0x4c>)
   18d82:	781b      	ldrb	r3, [r3, #0]
   18d84:	b933      	cbnz	r3, 18d94 <gatt_disconnected+0x28>
   18d86:	f7f2 fe1b 	bl	b9c0 <bt_mesh_is_provisioned>
   18d8a:	b118      	cbz	r0, 18d94 <gatt_disconnected+0x28>
		(void)bt_mesh_proxy_gatt_enable();
   18d8c:	f7ff ffd0 	bl	18d30 <bt_mesh_proxy_gatt_enable>
}
   18d90:	b009      	add	sp, #36	; 0x24
   18d92:	bd30      	pop	{r4, r5, pc}
	return &clients[bt_conn_index(conn)];
   18d94:	4620      	mov	r0, r4
   18d96:	f7ef fd5d 	bl	8854 <bt_conn_index>
	if (client->cli) {
   18d9a:	241c      	movs	r4, #28
   18d9c:	4d07      	ldr	r5, [pc, #28]	; (18dbc <gatt_disconnected+0x50>)
   18d9e:	4344      	muls	r4, r0
   18da0:	5928      	ldr	r0, [r5, r4]
   18da2:	2800      	cmp	r0, #0
   18da4:	d0f4      	beq.n	18d90 <gatt_disconnected+0x24>
		conn_count--;
   18da6:	4a06      	ldr	r2, [pc, #24]	; (18dc0 <gatt_disconnected+0x54>)
   18da8:	6813      	ldr	r3, [r2, #0]
   18daa:	3b01      	subs	r3, #1
   18dac:	6013      	str	r3, [r2, #0]
		bt_mesh_proxy_role_cleanup(client->cli);
   18dae:	f011 fcf9 	bl	2a7a4 <bt_mesh_proxy_role_cleanup>
		client->cli = NULL;
   18db2:	2300      	movs	r3, #0
   18db4:	512b      	str	r3, [r5, r4]
   18db6:	e7eb      	b.n	18d90 <gatt_disconnected+0x24>
   18db8:	20003aee 	.word	0x20003aee
   18dbc:	200006b8 	.word	0x200006b8
   18dc0:	200028c8 	.word	0x200028c8

00018dc4 <bt_mesh_proxy_gatt_disconnect>:
		if (client->cli && (client->filter_type == ACCEPT ||
   18dc4:	4b06      	ldr	r3, [pc, #24]	; (18de0 <bt_mesh_proxy_gatt_disconnect+0x1c>)
   18dc6:	6818      	ldr	r0, [r3, #0]
   18dc8:	b148      	cbz	r0, 18dde <bt_mesh_proxy_gatt_disconnect+0x1a>
   18dca:	7a9a      	ldrb	r2, [r3, #10]
   18dcc:	3a01      	subs	r2, #1
   18dce:	2a01      	cmp	r2, #1
   18dd0:	d805      	bhi.n	18dde <bt_mesh_proxy_gatt_disconnect+0x1a>
			client->filter_type = NONE;
   18dd2:	2200      	movs	r2, #0
			bt_conn_disconnect(client->cli->conn,
   18dd4:	6800      	ldr	r0, [r0, #0]
			client->filter_type = NONE;
   18dd6:	729a      	strb	r2, [r3, #10]
			bt_conn_disconnect(client->cli->conn,
   18dd8:	2113      	movs	r1, #19
   18dda:	f00f bacd 	b.w	28378 <bt_conn_disconnect>
}
   18dde:	4770      	bx	lr
   18de0:	200006b8 	.word	0x200006b8

00018de4 <bt_mesh_proxy_gatt_disable>:
{
   18de4:	b510      	push	{r4, lr}
	if (!service_registered) {
   18de6:	4c07      	ldr	r4, [pc, #28]	; (18e04 <bt_mesh_proxy_gatt_disable+0x20>)
   18de8:	7823      	ldrb	r3, [r4, #0]
   18dea:	b13b      	cbz	r3, 18dfc <bt_mesh_proxy_gatt_disable+0x18>
	bt_mesh_proxy_gatt_disconnect();
   18dec:	f7ff ffea 	bl	18dc4 <bt_mesh_proxy_gatt_disconnect>
	bt_gatt_service_unregister(&proxy_svc);
   18df0:	4805      	ldr	r0, [pc, #20]	; (18e08 <bt_mesh_proxy_gatt_disable+0x24>)
   18df2:	f7f2 fc5d 	bl	b6b0 <bt_gatt_service_unregister>
	service_registered = false;
   18df6:	2000      	movs	r0, #0
   18df8:	7020      	strb	r0, [r4, #0]
}
   18dfa:	bd10      	pop	{r4, pc}
		return -EALREADY;
   18dfc:	f06f 0077 	mvn.w	r0, #119	; 0x77
   18e00:	e7fb      	b.n	18dfa <bt_mesh_proxy_gatt_disable+0x16>
   18e02:	bf00      	nop
   18e04:	20003aee 	.word	0x20003aee
   18e08:	20000764 	.word	0x20000764

00018e0c <bt_mesh_proxy_addr_add>:
{
   18e0c:	b538      	push	{r3, r4, r5, lr}
	return &clients[bt_conn_index(conn)];
   18e0e:	f850 0c40 	ldr.w	r0, [r0, #-64]
	if (client->filter_type == ACCEPT) {
   18e12:	4d16      	ldr	r5, [pc, #88]	; (18e6c <bt_mesh_proxy_addr_add+0x60>)
{
   18e14:	460c      	mov	r4, r1
	return &clients[bt_conn_index(conn)];
   18e16:	f7ef fd1d 	bl	8854 <bt_conn_index>
	if (client->filter_type == ACCEPT) {
   18e1a:	221c      	movs	r2, #28
   18e1c:	fb02 5200 	mla	r2, r2, r0, r5
   18e20:	7a93      	ldrb	r3, [r2, #10]
   18e22:	2b01      	cmp	r3, #1
   18e24:	d109      	bne.n	18e3a <bt_mesh_proxy_addr_add+0x2e>
	return &clients[bt_conn_index(conn)];
   18e26:	b200      	sxth	r0, r0
   18e28:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
		filter_add(client, addr);
   18e2c:	4621      	mov	r1, r4
   18e2e:	eb05 0080 	add.w	r0, r5, r0, lsl #2
}
   18e32:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		filter_add(client, addr);
   18e36:	f011 bc30 	b.w	2a69a <filter_add>
	} else if (client->filter_type == REJECT) {
   18e3a:	2b02      	cmp	r3, #2
   18e3c:	d110      	bne.n	18e60 <bt_mesh_proxy_addr_add+0x54>
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   18e3e:	b17c      	cbz	r4, 18e60 <bt_mesh_proxy_addr_add+0x54>
		if (client->filter[i] == addr) {
   18e40:	8891      	ldrh	r1, [r2, #4]
   18e42:	42a1      	cmp	r1, r4
   18e44:	d00d      	beq.n	18e62 <bt_mesh_proxy_addr_add+0x56>
   18e46:	88d1      	ldrh	r1, [r2, #6]
   18e48:	42a1      	cmp	r1, r4
   18e4a:	d00c      	beq.n	18e66 <bt_mesh_proxy_addr_add+0x5a>
   18e4c:	8912      	ldrh	r2, [r2, #8]
   18e4e:	42a2      	cmp	r2, r4
   18e50:	d106      	bne.n	18e60 <bt_mesh_proxy_addr_add+0x54>
			client->filter[i] = BT_MESH_ADDR_UNASSIGNED;
   18e52:	220e      	movs	r2, #14
   18e54:	fb02 3300 	mla	r3, r2, r0, r3
   18e58:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   18e5c:	2200      	movs	r2, #0
   18e5e:	809a      	strh	r2, [r3, #4]
}
   18e60:	bd38      	pop	{r3, r4, r5, pc}
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   18e62:	2300      	movs	r3, #0
   18e64:	e7f5      	b.n	18e52 <bt_mesh_proxy_addr_add+0x46>
   18e66:	2301      	movs	r3, #1
   18e68:	e7f3      	b.n	18e52 <bt_mesh_proxy_addr_add+0x46>
   18e6a:	bf00      	nop
   18e6c:	200006b8 	.word	0x200006b8

00018e70 <bt_mesh_proxy_relay>:
{
   18e70:	b570      	push	{r4, r5, r6, lr}
		if (!client->cli) {
   18e72:	4c32      	ldr	r4, [pc, #200]	; (18f3c <bt_mesh_proxy_relay+0xcc>)
{
   18e74:	b094      	sub	sp, #80	; 0x50
		NET_BUF_SIMPLE_DEFINE(msg, 32);
   18e76:	ab0c      	add	r3, sp, #48	; 0x30
   18e78:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   18e7c:	e9cd 2304 	strd	r2, r3, [sp, #16]
   18e80:	9303      	str	r3, [sp, #12]
		if (!client->cli) {
   18e82:	6823      	ldr	r3, [r4, #0]
{
   18e84:	4605      	mov	r5, r0
		if (!client->cli) {
   18e86:	b15b      	cbz	r3, 18ea0 <bt_mesh_proxy_relay+0x30>
	if (client->filter_type == REJECT) {
   18e88:	7aa3      	ldrb	r3, [r4, #10]
   18e8a:	2b02      	cmp	r3, #2
   18e8c:	d10a      	bne.n	18ea4 <bt_mesh_proxy_relay+0x34>
			if (client->filter[i] == addr) {
   18e8e:	88a3      	ldrh	r3, [r4, #4]
   18e90:	428b      	cmp	r3, r1
   18e92:	d005      	beq.n	18ea0 <bt_mesh_proxy_relay+0x30>
   18e94:	88e3      	ldrh	r3, [r4, #6]
   18e96:	428b      	cmp	r3, r1
   18e98:	d002      	beq.n	18ea0 <bt_mesh_proxy_relay+0x30>
   18e9a:	8923      	ldrh	r3, [r4, #8]
   18e9c:	428b      	cmp	r3, r1
   18e9e:	d110      	bne.n	18ec2 <bt_mesh_proxy_relay+0x52>
	bool relayed = false;
   18ea0:	2000      	movs	r0, #0
   18ea2:	e048      	b.n	18f36 <bt_mesh_proxy_relay+0xc6>
	if (addr == BT_MESH_ADDR_ALL_NODES) {
   18ea4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18ea8:	4291      	cmp	r1, r2
   18eaa:	d00a      	beq.n	18ec2 <bt_mesh_proxy_relay+0x52>
	if (client->filter_type == ACCEPT) {
   18eac:	2b01      	cmp	r3, #1
   18eae:	d1f7      	bne.n	18ea0 <bt_mesh_proxy_relay+0x30>
			if (client->filter[i] == addr) {
   18eb0:	88a3      	ldrh	r3, [r4, #4]
   18eb2:	428b      	cmp	r3, r1
   18eb4:	d005      	beq.n	18ec2 <bt_mesh_proxy_relay+0x52>
   18eb6:	88e3      	ldrh	r3, [r4, #6]
   18eb8:	428b      	cmp	r3, r1
   18eba:	d002      	beq.n	18ec2 <bt_mesh_proxy_relay+0x52>
   18ebc:	8923      	ldrh	r3, [r4, #8]
   18ebe:	428b      	cmp	r3, r1
   18ec0:	d1ee      	bne.n	18ea0 <bt_mesh_proxy_relay+0x30>
		net_buf_simple_reserve(&msg, 1);
   18ec2:	2101      	movs	r1, #1
   18ec4:	a803      	add	r0, sp, #12
   18ec6:	f012 fed3 	bl	2bc70 <net_buf_simple_reserve>
		net_buf_simple_add_mem(&msg, buf->data, buf->len);
   18eca:	89aa      	ldrh	r2, [r5, #12]
   18ecc:	68a9      	ldr	r1, [r5, #8]
   18ece:	a803      	add	r0, sp, #12
   18ed0:	f012 ff3a 	bl	2bd48 <net_buf_simple_add_mem>
					     &msg, buf_send_end, net_buf_ref(buf));
   18ed4:	4628      	mov	r0, r5
		err = bt_mesh_proxy_msg_send(client->cli, BT_MESH_PROXY_NET_PDU,
   18ed6:	6824      	ldr	r4, [r4, #0]
					     &msg, buf_send_end, net_buf_ref(buf));
   18ed8:	f012 fef8 	bl	2bccc <net_buf_ref>
		err = bt_mesh_proxy_msg_send(client->cli, BT_MESH_PROXY_NET_PDU,
   18edc:	4b18      	ldr	r3, [pc, #96]	; (18f40 <bt_mesh_proxy_relay+0xd0>)
   18ede:	9000      	str	r0, [sp, #0]
   18ee0:	aa03      	add	r2, sp, #12
   18ee2:	4620      	mov	r0, r4
   18ee4:	2100      	movs	r1, #0
   18ee6:	f011 fc04 	bl	2a6f2 <bt_mesh_proxy_msg_send>
		bt_mesh_adv_send_start(0, err, BT_MESH_ADV(buf));
   18eea:	696e      	ldr	r6, [r5, #20]
	if (!adv->started) {
   18eec:	7a33      	ldrb	r3, [r6, #8]
		err = bt_mesh_proxy_msg_send(client->cli, BT_MESH_PROXY_NET_PDU,
   18eee:	4604      	mov	r4, r0
   18ef0:	f013 0004 	ands.w	r0, r3, #4
   18ef4:	d11c      	bne.n	18f30 <bt_mesh_proxy_relay+0xc0>
		adv->started = 1;
   18ef6:	f043 0304 	orr.w	r3, r3, #4
   18efa:	7233      	strb	r3, [r6, #8]
		if (adv->cb && adv->cb->start) {
   18efc:	6833      	ldr	r3, [r6, #0]
   18efe:	b123      	cbz	r3, 18f0a <bt_mesh_proxy_relay+0x9a>
   18f00:	681b      	ldr	r3, [r3, #0]
   18f02:	b113      	cbz	r3, 18f0a <bt_mesh_proxy_relay+0x9a>
			adv->cb->start(duration, err, adv->cb_data);
   18f04:	6872      	ldr	r2, [r6, #4]
   18f06:	4621      	mov	r1, r4
   18f08:	4798      	blx	r3
		if (err) {
   18f0a:	b19c      	cbz	r4, 18f34 <bt_mesh_proxy_relay+0xc4>
			adv->cb = NULL;
   18f0c:	2300      	movs	r3, #0
   18f0e:	6033      	str	r3, [r6, #0]
			BT_ERR("Failed to send proxy message (err %d)", err);
   18f10:	4b0c      	ldr	r3, [pc, #48]	; (18f44 <bt_mesh_proxy_relay+0xd4>)
   18f12:	480d      	ldr	r0, [pc, #52]	; (18f48 <bt_mesh_proxy_relay+0xd8>)
   18f14:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
   18f18:	aa09      	add	r2, sp, #36	; 0x24
   18f1a:	2303      	movs	r3, #3
   18f1c:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   18f20:	9302      	str	r3, [sp, #8]
   18f22:	9309      	str	r3, [sp, #36]	; 0x24
   18f24:	f011 fbce 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
			net_buf_unref(buf);
   18f28:	4628      	mov	r0, r5
   18f2a:	f007 fcb3 	bl	20894 <net_buf_unref>
			continue;
   18f2e:	e7b7      	b.n	18ea0 <bt_mesh_proxy_relay+0x30>
		if (err) {
   18f30:	2c00      	cmp	r4, #0
   18f32:	d1ed      	bne.n	18f10 <bt_mesh_proxy_relay+0xa0>
		relayed = true;
   18f34:	2001      	movs	r0, #1
}
   18f36:	b014      	add	sp, #80	; 0x50
   18f38:	bd70      	pop	{r4, r5, r6, pc}
   18f3a:	bf00      	nop
   18f3c:	200006b8 	.word	0x200006b8
   18f40:	0002a695 	.word	0x0002a695
   18f44:	00033b4f 	.word	0x00033b4f
   18f48:	0002db14 	.word	0x0002db14

00018f4c <bt_mesh_proxy_adv_start>:

int bt_mesh_proxy_adv_start(void)
{
   18f4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BT_DBG("");

	if (!service_registered || !bt_mesh_is_provisioned()) {
   18f50:	4b97      	ldr	r3, [pc, #604]	; (191b0 <bt_mesh_proxy_adv_start+0x264>)
   18f52:	781b      	ldrb	r3, [r3, #0]
{
   18f54:	b097      	sub	sp, #92	; 0x5c
	if (!service_registered || !bt_mesh_is_provisioned()) {
   18f56:	b92b      	cbnz	r3, 18f64 <bt_mesh_proxy_adv_start+0x18>
		return -ENOTSUP;
   18f58:	f06f 0485 	mvn.w	r4, #133	; 0x85
	}

	return gatt_proxy_advertise(next_sub());
}
   18f5c:	4620      	mov	r0, r4
   18f5e:	b017      	add	sp, #92	; 0x5c
   18f60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!service_registered || !bt_mesh_is_provisioned()) {
   18f64:	f7f2 fd2c 	bl	b9c0 <bt_mesh_is_provisioned>
   18f68:	9003      	str	r0, [sp, #12]
   18f6a:	2800      	cmp	r0, #0
   18f6c:	d0f4      	beq.n	18f58 <bt_mesh_proxy_adv_start+0xc>
	if (!beacon_sub) {
   18f6e:	4f91      	ldr	r7, [pc, #580]	; (191b4 <bt_mesh_proxy_adv_start+0x268>)
   18f70:	6838      	ldr	r0, [r7, #0]
   18f72:	b150      	cbz	r0, 18f8a <bt_mesh_proxy_adv_start+0x3e>
	sub = beacon_sub;
   18f74:	683c      	ldr	r4, [r7, #0]
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   18f76:	f64f 75ff 	movw	r5, #65535	; 0xffff
   18f7a:	8ba3      	ldrh	r3, [r4, #28]
   18f7c:	42ab      	cmp	r3, r5
   18f7e:	d027      	beq.n	18fd0 <bt_mesh_proxy_adv_start+0x84>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   18f80:	7fe3      	ldrb	r3, [r4, #31]
   18f82:	2b01      	cmp	r3, #1
   18f84:	d120      	bne.n	18fc8 <bt_mesh_proxy_adv_start+0x7c>
			beacon_sub = sub;
   18f86:	603c      	str	r4, [r7, #0]
			return sub;
   18f88:	e004      	b.n	18f94 <bt_mesh_proxy_adv_start+0x48>
		beacon_sub = bt_mesh_subnet_next(NULL);
   18f8a:	f7f4 fd99 	bl	dac0 <bt_mesh_subnet_next>
   18f8e:	6038      	str	r0, [r7, #0]
		if (!beacon_sub) {
   18f90:	2800      	cmp	r0, #0
   18f92:	d1ef      	bne.n	18f74 <bt_mesh_proxy_adv_start+0x28>
	if (conn_count == CONFIG_BT_MAX_CONN) {
   18f94:	4b88      	ldr	r3, [pc, #544]	; (191b8 <bt_mesh_proxy_adv_start+0x26c>)
   18f96:	681b      	ldr	r3, [r3, #0]
   18f98:	2b01      	cmp	r3, #1
   18f9a:	f000 8106 	beq.w	191aa <bt_mesh_proxy_adv_start+0x25e>
	sub = beacon_sub ? beacon_sub : bt_mesh_subnet_next(beacon_sub);
   18f9e:	683d      	ldr	r5, [r7, #0]
   18fa0:	b9f5      	cbnz	r5, 18fe0 <bt_mesh_proxy_adv_start+0x94>
   18fa2:	4628      	mov	r0, r5
   18fa4:	f7f4 fd8c 	bl	dac0 <bt_mesh_subnet_next>
	if (!sub) {
   18fa8:	4605      	mov	r5, r0
   18faa:	b9c8      	cbnz	r0, 18fe0 <bt_mesh_proxy_adv_start+0x94>
		BT_WARN("No subnets to advertise on");
   18fac:	4b83      	ldr	r3, [pc, #524]	; (191bc <bt_mesh_proxy_adv_start+0x270>)
   18fae:	9314      	str	r3, [sp, #80]	; 0x50
   18fb0:	4883      	ldr	r0, [pc, #524]	; (191c0 <bt_mesh_proxy_adv_start+0x274>)
   18fb2:	2302      	movs	r3, #2
   18fb4:	aa13      	add	r2, sp, #76	; 0x4c
   18fb6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   18fba:	930b      	str	r3, [sp, #44]	; 0x2c
   18fbc:	9313      	str	r3, [sp, #76]	; 0x4c
		return -ENOENT;
   18fbe:	f06f 0401 	mvn.w	r4, #1
		BT_WARN("No subnets to advertise on");
   18fc2:	f011 fb7f 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
		return -ENOENT;
   18fc6:	e7c9      	b.n	18f5c <bt_mesh_proxy_adv_start+0x10>
		bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
   18fc8:	f7f2 fe4e 	bl	bc68 <bt_mesh_gatt_proxy_get>
		if (advertise_subnet(sub)) {
   18fcc:	2801      	cmp	r0, #1
   18fce:	d0da      	beq.n	18f86 <bt_mesh_proxy_adv_start+0x3a>
		sub = bt_mesh_subnet_next(sub);
   18fd0:	4620      	mov	r0, r4
   18fd2:	f7f4 fd75 	bl	dac0 <bt_mesh_subnet_next>
	} while (sub != beacon_sub);
   18fd6:	683b      	ldr	r3, [r7, #0]
   18fd8:	4298      	cmp	r0, r3
		sub = bt_mesh_subnet_next(sub);
   18fda:	4604      	mov	r4, r0
	} while (sub != beacon_sub);
   18fdc:	d1cd      	bne.n	18f7a <bt_mesh_proxy_adv_start+0x2e>
   18fde:	e7d9      	b.n	18f94 <bt_mesh_proxy_adv_start+0x48>
	int count = 0;
   18fe0:	2300      	movs	r3, #0
	(void)bt_mesh_subnet_find(sub_count_cb, &count);
   18fe2:	4878      	ldr	r0, [pc, #480]	; (191c4 <bt_mesh_proxy_adv_start+0x278>)
	int count = 0;
   18fe4:	9310      	str	r3, [sp, #64]	; 0x40
	(void)bt_mesh_subnet_find(sub_count_cb, &count);
   18fe6:	a910      	add	r1, sp, #64	; 0x40
   18fe8:	f7f4 fd2a 	bl	da40 <bt_mesh_subnet_find>
	return count;
   18fec:	9b10      	ldr	r3, [sp, #64]	; 0x40
   18fee:	9304      	str	r3, [sp, #16]
	if (subnet_count > 1) {
   18ff0:	2b01      	cmp	r3, #1
   18ff2:	f340 80d7 	ble.w	191a4 <bt_mesh_proxy_adv_start+0x258>
		max_timeout = NODE_ID_TIMEOUT / MAX(subnet_count, 6);
   18ff6:	2b06      	cmp	r3, #6
   18ff8:	bfb8      	it	lt
   18ffa:	2306      	movlt	r3, #6
   18ffc:	f64e 2660 	movw	r6, #60000	; 0xea60
   19000:	fbb6 f6f3 	udiv	r6, r6, r3
		max_timeout = MAX(max_timeout, 1 * MSEC_PER_SEC);
   19004:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
   19008:	bf38      	it	cc
   1900a:	f44f 767a 	movcc.w	r6, #1000	; 0x3e8
	proxy_svc_data[2] = ID_TYPE_NODE;
   1900e:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 191c8 <bt_mesh_proxy_adv_start+0x27c>
	int32_t remaining = SYS_FOREVER_MS;
   19012:	f04f 0900 	mov.w	r9, #0
   19016:	f06f 040f 	mvn.w	r4, #15
	err = bt_rand(proxy_svc_data + 11, 8);
   1901a:	f10a 0b0b 	add.w	fp, sl, #11
   1901e:	e0b6      	b.n	1918e <bt_mesh_proxy_adv_start+0x242>
		if (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING) {
   19020:	f895 801f 	ldrb.w	r8, [r5, #31]
   19024:	f1b8 0f01 	cmp.w	r8, #1
   19028:	f040 80ba 	bne.w	191a0 <bt_mesh_proxy_adv_start+0x254>
   1902c:	f014 f890 	bl	2d150 <z_impl_k_uptime_ticks>
   19030:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   19034:	fba0 0302 	umull	r0, r3, r0, r2
   19038:	fb02 3301 	mla	r3, r2, r1, r3
   1903c:	0bc0      	lsrs	r0, r0, #15
   1903e:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
			uint32_t active = k_uptime_get_32() - sub->node_id_start;
   19042:	6a2b      	ldr	r3, [r5, #32]
			if (active < NODE_ID_TIMEOUT) {
   19044:	f64e 225f 	movw	r2, #59999	; 0xea5f
			uint32_t active = k_uptime_get_32() - sub->node_id_start;
   19048:	1ac1      	subs	r1, r0, r3
			if (active < NODE_ID_TIMEOUT) {
   1904a:	4291      	cmp	r1, r2
   1904c:	f200 80a5 	bhi.w	1919a <bt_mesh_proxy_adv_start+0x24e>
				remaining = NODE_ID_TIMEOUT - active;
   19050:	f503 466a 	add.w	r6, r3, #59904	; 0xea00
   19054:	3660      	adds	r6, #96	; 0x60
	struct bt_le_adv_param fast_adv_param = {
   19056:	2214      	movs	r2, #20
   19058:	2100      	movs	r1, #0
				remaining = NODE_ID_TIMEOUT - active;
   1905a:	1a36      	subs	r6, r6, r0
	struct bt_le_adv_param fast_adv_param = {
   1905c:	a80b      	add	r0, sp, #44	; 0x2c
   1905e:	f00e fc12 	bl	27886 <memset>
   19062:	f240 2003 	movw	r0, #515	; 0x203
   19066:	23a0      	movs	r3, #160	; 0xa0
   19068:	e9cd 030c 	strd	r0, r3, [sp, #48]	; 0x30
	err = bt_rand(proxy_svc_data + 11, 8);
   1906c:	2108      	movs	r1, #8
	struct bt_le_adv_param fast_adv_param = {
   1906e:	23f0      	movs	r3, #240	; 0xf0
	err = bt_rand(proxy_svc_data + 11, 8);
   19070:	4658      	mov	r0, fp
	struct bt_le_adv_param fast_adv_param = {
   19072:	930e      	str	r3, [sp, #56]	; 0x38
	proxy_svc_data[2] = ID_TYPE_NODE;
   19074:	f88a 8002 	strb.w	r8, [sl, #2]
	err = bt_rand(proxy_svc_data + 11, 8);
   19078:	f011 ff47 	bl	2af0a <bt_rand>
	if (err) {
   1907c:	4604      	mov	r4, r0
   1907e:	2800      	cmp	r0, #0
   19080:	d13a      	bne.n	190f8 <bt_mesh_proxy_adv_start+0x1ac>
	(void)memset(tmp, 0, 6);
   19082:	4601      	mov	r1, r0
   19084:	2206      	movs	r2, #6
   19086:	a807      	add	r0, sp, #28
   19088:	f00e fbfd 	bl	27886 <memset>
	memcpy(tmp + 6, proxy_svc_data + 11, 8);
   1908c:	2208      	movs	r2, #8
   1908e:	4659      	mov	r1, fp
   19090:	f10d 0022 	add.w	r0, sp, #34	; 0x22
   19094:	f00e fbec 	bl	27870 <memcpy>
	sys_put_be16(bt_mesh_primary_addr(), tmp + 14);
   19098:	f7f7 fee4 	bl	10e64 <bt_mesh_primary_addr>
   1909c:	0a03      	lsrs	r3, r0, #8
   1909e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
	dst[1] = val;
   190a2:	f88d 002b 	strb.w	r0, [sp, #43]	; 0x2b
	err = bt_encrypt_be(sub->keys[SUBNET_KEY_TX_IDX(sub)].identity, tmp,
   190a6:	7fa8      	ldrb	r0, [r5, #30]
   190a8:	1e81      	subs	r1, r0, #2
   190aa:	4248      	negs	r0, r1
   190ac:	4148      	adcs	r0, r1
   190ae:	235a      	movs	r3, #90	; 0x5a
   190b0:	fb03 5000 	mla	r0, r3, r0, r5
   190b4:	aa07      	add	r2, sp, #28
   190b6:	4611      	mov	r1, r2
   190b8:	3066      	adds	r0, #102	; 0x66
   190ba:	f011 ff28 	bl	2af0e <bt_encrypt_be>
	if (err) {
   190be:	4604      	mov	r4, r0
   190c0:	b9d0      	cbnz	r0, 190f8 <bt_mesh_proxy_adv_start+0x1ac>
	memcpy(proxy_svc_data + 3, tmp + 8, 8);
   190c2:	2208      	movs	r2, #8
   190c4:	a909      	add	r1, sp, #36	; 0x24
   190c6:	4841      	ldr	r0, [pc, #260]	; (191cc <bt_mesh_proxy_adv_start+0x280>)
   190c8:	f00e fbd2 	bl	27870 <memcpy>
	err = bt_mesh_adv_gatt_start(&fast_adv_param, duration, node_id_ad,
   190cc:	e9cd 4400 	strd	r4, r4, [sp]
   190d0:	4a3f      	ldr	r2, [pc, #252]	; (191d0 <bt_mesh_proxy_adv_start+0x284>)
   190d2:	2303      	movs	r3, #3
   190d4:	4631      	mov	r1, r6
   190d6:	a80b      	add	r0, sp, #44	; 0x2c
   190d8:	f7fb ffa6 	bl	15028 <bt_mesh_adv_gatt_start>
	if (err) {
   190dc:	4604      	mov	r4, r0
   190de:	b158      	cbz	r0, 190f8 <bt_mesh_proxy_adv_start+0x1ac>
		BT_WARN("Failed to advertise using Node ID (err %d)", err);
   190e0:	4b3c      	ldr	r3, [pc, #240]	; (191d4 <bt_mesh_proxy_adv_start+0x288>)
   190e2:	aa13      	add	r2, sp, #76	; 0x4c
   190e4:	e9cd 3014 	strd	r3, r0, [sp, #80]	; 0x50
   190e8:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   190ec:	2303      	movs	r3, #3
   190ee:	4834      	ldr	r0, [pc, #208]	; (191c0 <bt_mesh_proxy_adv_start+0x274>)
   190f0:	9306      	str	r3, [sp, #24]
   190f2:	9313      	str	r3, [sp, #76]	; 0x4c
   190f4:	f011 fae6 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
				planned = true;
   190f8:	9a03      	ldr	r2, [sp, #12]
		if (sub->node_id == BT_MESH_NODE_IDENTITY_STOPPED &&
   190fa:	f895 801f 	ldrb.w	r8, [r5, #31]
   190fe:	f1b8 0f00 	cmp.w	r8, #0
   19102:	d138      	bne.n	19176 <bt_mesh_proxy_adv_start+0x22a>
   19104:	9205      	str	r2, [sp, #20]
		    bt_mesh_gatt_proxy_get() == BT_MESH_FEATURE_ENABLED) {
   19106:	f7f2 fdaf 	bl	bc68 <bt_mesh_gatt_proxy_get>
		if (sub->node_id == BT_MESH_NODE_IDENTITY_STOPPED &&
   1910a:	2801      	cmp	r0, #1
   1910c:	9a05      	ldr	r2, [sp, #20]
   1910e:	d132      	bne.n	19176 <bt_mesh_proxy_adv_start+0x22a>
	struct bt_le_adv_param slow_adv_param = {
   19110:	2214      	movs	r2, #20
   19112:	4641      	mov	r1, r8
   19114:	a80b      	add	r0, sp, #44	; 0x2c
   19116:	f00e fbb6 	bl	27886 <memset>
   1911a:	f240 2303 	movw	r3, #515	; 0x203
   1911e:	f44f 62c8 	mov.w	r2, #1600	; 0x640
   19122:	e9cd 320c 	strd	r3, r2, [sp, #48]	; 0x30
   19126:	f44f 62f0 	mov.w	r2, #1920	; 0x780
   1912a:	920e      	str	r2, [sp, #56]	; 0x38
	memcpy(proxy_svc_data + 3, sub->keys[SUBNET_KEY_TX_IDX(sub)].net_id, 8);
   1912c:	7fa9      	ldrb	r1, [r5, #30]
   1912e:	4827      	ldr	r0, [pc, #156]	; (191cc <bt_mesh_proxy_adv_start+0x280>)
	proxy_svc_data[2] = ID_TYPE_NET;
   19130:	f88a 8002 	strb.w	r8, [sl, #2]
	memcpy(proxy_svc_data + 3, sub->keys[SUBNET_KEY_TX_IDX(sub)].net_id, 8);
   19134:	1e8a      	subs	r2, r1, #2
   19136:	4251      	negs	r1, r2
   19138:	4151      	adcs	r1, r2
   1913a:	225a      	movs	r2, #90	; 0x5a
   1913c:	fb02 5101 	mla	r1, r2, r1, r5
   19140:	315e      	adds	r1, #94	; 0x5e
   19142:	2208      	movs	r2, #8
   19144:	f00e fb94 	bl	27870 <memcpy>
	err = bt_mesh_adv_gatt_start(&slow_adv_param, duration, net_id_ad,
   19148:	e9cd 8800 	strd	r8, r8, [sp]
   1914c:	4a22      	ldr	r2, [pc, #136]	; (191d8 <bt_mesh_proxy_adv_start+0x28c>)
   1914e:	2303      	movs	r3, #3
   19150:	4631      	mov	r1, r6
   19152:	a80b      	add	r0, sp, #44	; 0x2c
   19154:	f7fb ff68 	bl	15028 <bt_mesh_adv_gatt_start>
	if (err) {
   19158:	4604      	mov	r4, r0
   1915a:	b158      	cbz	r0, 19174 <bt_mesh_proxy_adv_start+0x228>
		BT_WARN("Failed to advertise using Network ID (err %d)", err);
   1915c:	4b1f      	ldr	r3, [pc, #124]	; (191dc <bt_mesh_proxy_adv_start+0x290>)
   1915e:	aa13      	add	r2, sp, #76	; 0x4c
   19160:	e9cd 3014 	strd	r3, r0, [sp, #80]	; 0x50
   19164:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   19168:	2303      	movs	r3, #3
   1916a:	4815      	ldr	r0, [pc, #84]	; (191c0 <bt_mesh_proxy_adv_start+0x274>)
   1916c:	9307      	str	r3, [sp, #28]
   1916e:	9313      	str	r3, [sp, #76]	; 0x4c
   19170:	f011 faa8 	bl	2a6c4 <z_log_msg2_static_create.constprop.0>
			planned = true;
   19174:	9a03      	ldr	r2, [sp, #12]
   19176:	9205      	str	r2, [sp, #20]
		beacon_sub = bt_mesh_subnet_next(sub);
   19178:	4628      	mov	r0, r5
   1917a:	f7f4 fca1 	bl	dac0 <bt_mesh_subnet_next>
		if (planned) {
   1917e:	9a05      	ldr	r2, [sp, #20]
		beacon_sub = bt_mesh_subnet_next(sub);
   19180:	6038      	str	r0, [r7, #0]
   19182:	4605      	mov	r5, r0
		if (planned) {
   19184:	2a00      	cmp	r2, #0
   19186:	f47f aee9 	bne.w	18f5c <bt_mesh_proxy_adv_start+0x10>
	for (int i = 0; i < subnet_count; i++) {
   1918a:	f109 0901 	add.w	r9, r9, #1
   1918e:	9b04      	ldr	r3, [sp, #16]
   19190:	4599      	cmp	r9, r3
   19192:	f6ff af45 	blt.w	19020 <bt_mesh_proxy_adv_start+0xd4>
	return 0;
   19196:	2400      	movs	r4, #0
   19198:	e6e0      	b.n	18f5c <bt_mesh_proxy_adv_start+0x10>
				bt_mesh_proxy_identity_stop(sub);
   1919a:	4628      	mov	r0, r5
   1919c:	f7ff fda2 	bl	18ce4 <bt_mesh_proxy_identity_stop>
		if (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING) {
   191a0:	2200      	movs	r2, #0
   191a2:	e7aa      	b.n	190fa <bt_mesh_proxy_adv_start+0x1ae>
	int32_t remaining = SYS_FOREVER_MS;
   191a4:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   191a8:	e731      	b.n	1900e <bt_mesh_proxy_adv_start+0xc2>
		return -ENOMEM;
   191aa:	f06f 040b 	mvn.w	r4, #11
   191ae:	e6d5      	b.n	18f5c <bt_mesh_proxy_adv_start+0x10>
   191b0:	20003aee 	.word	0x20003aee
   191b4:	200028c4 	.word	0x200028c4
   191b8:	200028c8 	.word	0x200028c8
   191bc:	00033b75 	.word	0x00033b75
   191c0:	0002db14 	.word	0x0002db14
   191c4:	0002a6cb 	.word	0x0002a6cb
   191c8:	20000dfd 	.word	0x20000dfd
   191cc:	20000e00 	.word	0x20000e00
   191d0:	0002e81c 	.word	0x0002e81c
   191d4:	00033b90 	.word	0x00033b90
   191d8:	0002e804 	.word	0x0002e804
   191dc:	00033bbb 	.word	0x00033bbb

000191e0 <proxy_sar_timeout>:
static uint8_t __noinit bufs[CONFIG_BT_MAX_CONN * CONFIG_BT_MESH_PROXY_MSG_LEN];

static struct bt_mesh_proxy_role roles[CONFIG_BT_MAX_CONN];

static void proxy_sar_timeout(struct k_work *work)
{
   191e0:	b510      	push	{r4, lr}
   191e2:	b088      	sub	sp, #32
	struct bt_mesh_proxy_role *role;
	struct k_work_delayable *dwork = k_work_delayable_from_work(work);

	BT_WARN("Proxy SAR timeout");
   191e4:	4b0b      	ldr	r3, [pc, #44]	; (19214 <proxy_sar_timeout+0x34>)
   191e6:	9306      	str	r3, [sp, #24]
   191e8:	2302      	movs	r3, #2
{
   191ea:	4604      	mov	r4, r0
	BT_WARN("Proxy SAR timeout");
   191ec:	9301      	str	r3, [sp, #4]
   191ee:	9305      	str	r3, [sp, #20]
   191f0:	4809      	ldr	r0, [pc, #36]	; (19218 <proxy_sar_timeout+0x38>)
   191f2:	2300      	movs	r3, #0
   191f4:	aa05      	add	r2, sp, #20
   191f6:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   191fa:	f00c fd6d 	bl	25cd8 <z_impl_z_log_msg2_static_create>

	role = CONTAINER_OF(dwork, struct bt_mesh_proxy_role, sar_timer);
	if (role->conn) {
   191fe:	f854 0c10 	ldr.w	r0, [r4, #-16]
   19202:	b128      	cbz	r0, 19210 <proxy_sar_timeout+0x30>
		bt_conn_disconnect(role->conn,
   19204:	2113      	movs	r1, #19
				   BT_HCI_ERR_REMOTE_USER_TERM_CONN);
	}
}
   19206:	b008      	add	sp, #32
   19208:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		bt_conn_disconnect(role->conn,
   1920c:	f00f b8b4 	b.w	28378 <bt_conn_disconnect>
}
   19210:	b008      	add	sp, #32
   19212:	bd10      	pop	{r4, pc}
   19214:	00033bf6 	.word	0x00033bf6
   19218:	0002db74 	.word	0x0002db74

0001921c <bt_mesh_proxy_msg_recv>:

ssize_t bt_mesh_proxy_msg_recv(struct bt_mesh_proxy_role *role,
			       const void *buf, uint16_t len)
{
   1921c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1921e:	4616      	mov	r6, r2
	const uint8_t *data = buf;

	switch (PDU_SAR(data)) {
   19220:	780a      	ldrb	r2, [r1, #0]
	case SAR_COMPLETE:
		if (role->buf.len) {
   19222:	f8b0 7044 	ldrh.w	r7, [r0, #68]	; 0x44
	switch (PDU_SAR(data)) {
   19226:	0993      	lsrs	r3, r2, #6
   19228:	2b02      	cmp	r3, #2
{
   1922a:	b089      	sub	sp, #36	; 0x24
   1922c:	4604      	mov	r4, r0
   1922e:	460d      	mov	r5, r1
	switch (PDU_SAR(data)) {
   19230:	d02c      	beq.n	1928c <bt_mesh_proxy_msg_recv+0x70>
   19232:	2b03      	cmp	r3, #3
   19234:	d04a      	beq.n	192cc <bt_mesh_proxy_msg_recv+0xb0>
   19236:	2b01      	cmp	r3, #1
   19238:	d012      	beq.n	19260 <bt_mesh_proxy_msg_recv+0x44>
		if (role->buf.len) {
   1923a:	b11f      	cbz	r7, 19244 <bt_mesh_proxy_msg_recv+0x28>
			BT_WARN("Complete PDU while a pending incomplete one");
   1923c:	4b30      	ldr	r3, [pc, #192]	; (19300 <bt_mesh_proxy_msg_recv+0xe4>)
			BT_WARN("Last SAR PDU with no prior data");
			return -EINVAL;
		}

		if (role->msg_type != PDU_TYPE(data)) {
			BT_WARN("Unexpected message type in last SAR PDU");
   1923e:	9306      	str	r3, [sp, #24]
   19240:	2302      	movs	r3, #2
   19242:	e026      	b.n	19292 <bt_mesh_proxy_msg_recv+0x76>
		role->msg_type = PDU_TYPE(data);
   19244:	7102      	strb	r2, [r0, #4]
		net_buf_simple_add_mem(&role->buf, data + 1, len - 1);
   19246:	3101      	adds	r1, #1
   19248:	1e72      	subs	r2, r6, #1
   1924a:	3040      	adds	r0, #64	; 0x40
   1924c:	f012 fd7c 	bl	2bd48 <net_buf_simple_add_mem>
		role->cb.recv(role);
   19250:	68e3      	ldr	r3, [r4, #12]
   19252:	4620      	mov	r0, r4
   19254:	4798      	blx	r3
   19256:	f8a4 7044 	strh.w	r7, [r4, #68]	; 0x44
	buf->data = buf->__buf;
   1925a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1925c:	6423      	str	r3, [r4, #64]	; 0x40
}
   1925e:	e013      	b.n	19288 <bt_mesh_proxy_msg_recv+0x6c>
		if (role->buf.len) {
   19260:	b10f      	cbz	r7, 19266 <bt_mesh_proxy_msg_recv+0x4a>
			BT_WARN("First PDU while a pending incomplete one");
   19262:	4b28      	ldr	r3, [pc, #160]	; (19304 <bt_mesh_proxy_msg_recv+0xe8>)
   19264:	e7eb      	b.n	1923e <bt_mesh_proxy_msg_recv+0x22>
		k_work_reschedule(&role->sar_timer, PROXY_SAR_TIMEOUT);
   19266:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   1926a:	2300      	movs	r3, #0
   1926c:	3010      	adds	r0, #16
   1926e:	f00b f879 	bl	24364 <k_work_reschedule>
		role->msg_type = PDU_TYPE(data);
   19272:	4629      	mov	r1, r5
		net_buf_simple_add_mem(&role->buf, data + 1, len - 1);
   19274:	1e72      	subs	r2, r6, #1
		role->msg_type = PDU_TYPE(data);
   19276:	f811 3b01 	ldrb.w	r3, [r1], #1
   1927a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1927e:	7123      	strb	r3, [r4, #4]
		net_buf_simple_add_mem(&role->buf, data + 1, len - 1);
   19280:	f104 0040 	add.w	r0, r4, #64	; 0x40
   19284:	f012 fd60 	bl	2bd48 <net_buf_simple_add_mem>
		role->cb.recv(role);
		net_buf_simple_reset(&role->buf);
		break;
	}

	return len;
   19288:	4630      	mov	r0, r6
   1928a:	e00d      	b.n	192a8 <bt_mesh_proxy_msg_recv+0x8c>
		if (!role->buf.len) {
   1928c:	b977      	cbnz	r7, 192ac <bt_mesh_proxy_msg_recv+0x90>
			BT_WARN("Continuation with no prior data");
   1928e:	4a1e      	ldr	r2, [pc, #120]	; (19308 <bt_mesh_proxy_msg_recv+0xec>)
			BT_WARN("Unexpected message type in continuation");
   19290:	9206      	str	r2, [sp, #24]
			BT_WARN("Unexpected message type in last SAR PDU");
   19292:	9301      	str	r3, [sp, #4]
   19294:	9305      	str	r3, [sp, #20]
   19296:	481d      	ldr	r0, [pc, #116]	; (1930c <bt_mesh_proxy_msg_recv+0xf0>)
   19298:	2300      	movs	r3, #0
   1929a:	aa05      	add	r2, sp, #20
   1929c:	f44f 5184 	mov.w	r1, #4224	; 0x1080
   192a0:	f00c fd1a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			return -EINVAL;
   192a4:	f06f 0015 	mvn.w	r0, #21
}
   192a8:	b009      	add	sp, #36	; 0x24
   192aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (role->msg_type != PDU_TYPE(data)) {
   192ac:	7901      	ldrb	r1, [r0, #4]
   192ae:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   192b2:	4291      	cmp	r1, r2
   192b4:	d001      	beq.n	192ba <bt_mesh_proxy_msg_recv+0x9e>
			BT_WARN("Unexpected message type in continuation");
   192b6:	4a16      	ldr	r2, [pc, #88]	; (19310 <bt_mesh_proxy_msg_recv+0xf4>)
   192b8:	e7ea      	b.n	19290 <bt_mesh_proxy_msg_recv+0x74>
		k_work_reschedule(&role->sar_timer, PROXY_SAR_TIMEOUT);
   192ba:	f44f 2220 	mov.w	r2, #655360	; 0xa0000
   192be:	2300      	movs	r3, #0
   192c0:	3010      	adds	r0, #16
   192c2:	f00b f84f 	bl	24364 <k_work_reschedule>
		net_buf_simple_add_mem(&role->buf, data + 1, len - 1);
   192c6:	1e72      	subs	r2, r6, #1
   192c8:	1c69      	adds	r1, r5, #1
   192ca:	e7d9      	b.n	19280 <bt_mesh_proxy_msg_recv+0x64>
		if (!role->buf.len) {
   192cc:	b90f      	cbnz	r7, 192d2 <bt_mesh_proxy_msg_recv+0xb6>
			BT_WARN("Last SAR PDU with no prior data");
   192ce:	4b11      	ldr	r3, [pc, #68]	; (19314 <bt_mesh_proxy_msg_recv+0xf8>)
   192d0:	e7b5      	b.n	1923e <bt_mesh_proxy_msg_recv+0x22>
		if (role->msg_type != PDU_TYPE(data)) {
   192d2:	7903      	ldrb	r3, [r0, #4]
   192d4:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   192d8:	4293      	cmp	r3, r2
   192da:	d001      	beq.n	192e0 <bt_mesh_proxy_msg_recv+0xc4>
			BT_WARN("Unexpected message type in last SAR PDU");
   192dc:	4b0e      	ldr	r3, [pc, #56]	; (19318 <bt_mesh_proxy_msg_recv+0xfc>)
   192de:	e7ae      	b.n	1923e <bt_mesh_proxy_msg_recv+0x22>
		(void)k_work_cancel_delayable(&role->sar_timer);
   192e0:	3010      	adds	r0, #16
   192e2:	f013 fd90 	bl	2ce06 <k_work_cancel_delayable>
		net_buf_simple_add_mem(&role->buf, data + 1, len - 1);
   192e6:	1e72      	subs	r2, r6, #1
   192e8:	1c69      	adds	r1, r5, #1
   192ea:	f104 0040 	add.w	r0, r4, #64	; 0x40
   192ee:	f012 fd2b 	bl	2bd48 <net_buf_simple_add_mem>
		role->cb.recv(role);
   192f2:	68e3      	ldr	r3, [r4, #12]
   192f4:	4620      	mov	r0, r4
   192f6:	4798      	blx	r3
	buf->len  = 0U;
   192f8:	2300      	movs	r3, #0
   192fa:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
   192fe:	e7ac      	b.n	1925a <bt_mesh_proxy_msg_recv+0x3e>
   19300:	00033c08 	.word	0x00033c08
   19304:	00033c34 	.word	0x00033c34
   19308:	00033c5d 	.word	0x00033c5d
   1930c:	0002db74 	.word	0x0002db74
   19310:	00033c7d 	.word	0x00033c7d
   19314:	00033ca5 	.word	0x00033ca5
   19318:	00033cc5 	.word	0x00033cc5

0001931c <bt_mesh_proxy_role_setup>:
}

struct bt_mesh_proxy_role *bt_mesh_proxy_role_setup(struct bt_conn *conn,
						    proxy_send_cb_t send,
						    proxy_recv_cb_t recv)
{
   1931c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19320:	4682      	mov	sl, r0
   19322:	4690      	mov	r8, r2
   19324:	460f      	mov	r7, r1
	struct bt_mesh_proxy_role *role;

	role = &roles[bt_conn_index(conn)];
   19326:	f7ef fa95 	bl	8854 <bt_conn_index>
   1932a:	4606      	mov	r6, r0
   1932c:	b204      	sxth	r4, r0

	role->conn = bt_conn_ref(conn);
   1932e:	4650      	mov	r0, sl
   19330:	f00e ffc2 	bl	282b8 <bt_conn_ref>
	role = &roles[bt_conn_index(conn)];
   19334:	4d1a      	ldr	r5, [pc, #104]	; (193a0 <bt_mesh_proxy_role_setup+0x84>)
	role->conn = bt_conn_ref(conn);
   19336:	2350      	movs	r3, #80	; 0x50
   19338:	4373      	muls	r3, r6
   1933a:	18ea      	adds	r2, r5, r3
   1933c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
	if (role->buf.__buf) {
   19340:	f8d2 a048 	ldr.w	sl, [r2, #72]	; 0x48
	role->conn = bt_conn_ref(conn);
   19344:	50e8      	str	r0, [r5, r3]
   19346:	ea4f 1904 	mov.w	r9, r4, lsl #4
	role = &roles[bt_conn_index(conn)];
   1934a:	eb05 1404 	add.w	r4, r5, r4, lsl #4
	if (role->buf.__buf) {
   1934e:	f1ba 0f00 	cmp.w	sl, #0
   19352:	d00c      	beq.n	1936e <bt_mesh_proxy_role_setup+0x52>
   19354:	2300      	movs	r3, #0
   19356:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	buf->data = buf->__buf;
   1935a:	f8c4 a040 	str.w	sl, [r4, #64]	; 0x40
	proxy_msg_init(role);

	role->cb.recv = recv;
   1935e:	2050      	movs	r0, #80	; 0x50
   19360:	fb00 5506 	mla	r5, r0, r6, r5
	role->cb.send = send;
   19364:	e9c5 7802 	strd	r7, r8, [r5, #8]

	return role;
}
   19368:	4620      	mov	r0, r4
   1936a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				      &bufs[bt_conn_index(role->conn) *
   1936e:	f7ef fa71 	bl	8854 <bt_conn_index>
	net_buf_simple_init_with_data(&role->buf,
   19372:	490c      	ldr	r1, [pc, #48]	; (193a4 <bt_mesh_proxy_role_setup+0x88>)
				      &bufs[bt_conn_index(role->conn) *
   19374:	b203      	sxth	r3, r0
   19376:	eb03 1343 	add.w	r3, r3, r3, lsl #5
	net_buf_simple_init_with_data(&role->buf,
   1937a:	f109 0040 	add.w	r0, r9, #64	; 0x40
   1937e:	eb01 0143 	add.w	r1, r1, r3, lsl #1
   19382:	4428      	add	r0, r5
   19384:	2242      	movs	r2, #66	; 0x42
   19386:	f012 fc6d 	bl	2bc64 <net_buf_simple_init_with_data>
   1938a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
	k_work_init_delayable(&role->sar_timer, proxy_sar_timeout);
   1938c:	4906      	ldr	r1, [pc, #24]	; (193a8 <bt_mesh_proxy_role_setup+0x8c>)
	buf->len  = 0U;
   1938e:	f8a4 a044 	strh.w	sl, [r4, #68]	; 0x44
   19392:	f109 0010 	add.w	r0, r9, #16
	buf->data = buf->__buf;
   19396:	6423      	str	r3, [r4, #64]	; 0x40
   19398:	4428      	add	r0, r5
   1939a:	f013 fd26 	bl	2cdea <k_work_init_delayable>
   1939e:	e7de      	b.n	1935e <bt_mesh_proxy_role_setup+0x42>
   193a0:	20001f50 	.word	0x20001f50
   193a4:	20008579 	.word	0x20008579
   193a8:	000191e1 	.word	0x000191e1

000193ac <mayfly_init>:
#if defined(MAYFLY_UT)
static uint8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
   193ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		uint8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
   193b0:	4f11      	ldr	r7, [pc, #68]	; (193f8 <mayfly_init+0x4c>)
   193b2:	f8df a048 	ldr.w	sl, [pc, #72]	; 193fc <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
   193b6:	2404      	movs	r4, #4
	while (callee_id--) {
   193b8:	3c01      	subs	r4, #1
   193ba:	b2e4      	uxtb	r4, r4
   193bc:	2cff      	cmp	r4, #255	; 0xff
   193be:	d018      	beq.n	193f2 <mayfly_init+0x46>
   193c0:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   193c4:	ea4f 0984 	mov.w	r9, r4, lsl #2
   193c8:	0136      	lsls	r6, r6, #4
		caller_id = MAYFLY_CALLER_COUNT;
   193ca:	2504      	movs	r5, #4
   193cc:	f04f 080c 	mov.w	r8, #12
   193d0:	e00a      	b.n	193e8 <mayfly_init+0x3c>
			memq_init(&mfl[callee_id][caller_id],
   193d2:	fb18 6105 	smlabb	r1, r8, r5, r6
   193d6:	1d0a      	adds	r2, r1, #4
   193d8:	eb05 0009 	add.w	r0, r5, r9
   193dc:	443a      	add	r2, r7
   193de:	4439      	add	r1, r7
   193e0:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   193e4:	f011 fa64 	bl	2a8b0 <memq_init>
		while (caller_id--) {
   193e8:	3d01      	subs	r5, #1
   193ea:	b2ed      	uxtb	r5, r5
   193ec:	2dff      	cmp	r5, #255	; 0xff
   193ee:	d1f0      	bne.n	193d2 <mayfly_init+0x26>
   193f0:	e7e2      	b.n	193b8 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
   193f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   193f6:	bf00      	nop
   193f8:	2000294c 	.word	0x2000294c
   193fc:	200028cc 	.word	0x200028cc

00019400 <mayfly_enable>:

void mayfly_enable(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
   19400:	b4f0      	push	{r4, r5, r6, r7}
   19402:	4b14      	ldr	r3, [pc, #80]	; (19454 <mayfly_enable+0x54>)
   19404:	4607      	mov	r7, r0
   19406:	460e      	mov	r6, r1
   19408:	f04f 0c0c 	mov.w	ip, #12
   1940c:	2430      	movs	r4, #48	; 0x30
	if (enable) {
   1940e:	b17a      	cbz	r2, 19430 <mayfly_enable+0x30>
		if (mft[callee_id][caller_id].enable_req ==
   19410:	fb04 f501 	mul.w	r5, r4, r1
   19414:	fb0c 5500 	mla	r5, ip, r0, r5
   19418:	442b      	add	r3, r5
   1941a:	7a59      	ldrb	r1, [r3, #9]
   1941c:	7a18      	ldrb	r0, [r3, #8]
   1941e:	4281      	cmp	r1, r0
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
   19420:	bf04      	itt	eq
   19422:	3101      	addeq	r1, #1
   19424:	7219      	strbeq	r1, [r3, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
   19426:	4638      	mov	r0, r7
   19428:	4631      	mov	r1, r6

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
   1942a:	bcf0      	pop	{r4, r5, r6, r7}
		mayfly_enable_cb(caller_id, callee_id, enable);
   1942c:	f007 b87c 	b.w	20528 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
   19430:	434c      	muls	r4, r1
   19432:	fb0c 4400 	mla	r4, ip, r0, r4
   19436:	4423      	add	r3, r4
   19438:	7a9c      	ldrb	r4, [r3, #10]
   1943a:	7ada      	ldrb	r2, [r3, #11]
   1943c:	42a2      	cmp	r2, r4
   1943e:	d107      	bne.n	19450 <mayfly_enable+0x50>
			mft[callee_id][caller_id].disable_req++;
   19440:	3201      	adds	r2, #1
   19442:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
   19444:	4b04      	ldr	r3, [pc, #16]	; (19458 <mayfly_enable+0x58>)
   19446:	2201      	movs	r2, #1
   19448:	545a      	strb	r2, [r3, r1]
}
   1944a:	bcf0      	pop	{r4, r5, r6, r7}
			mayfly_pend(caller_id, callee_id);
   1944c:	f007 b8ac 	b.w	205a8 <mayfly_pend>
}
   19450:	bcf0      	pop	{r4, r5, r6, r7}
   19452:	4770      	bx	lr
   19454:	2000294c 	.word	0x2000294c
   19458:	20003aef 	.word	0x20003aef

0001945c <mayfly_enqueue>:

uint32_t mayfly_enqueue(uint8_t caller_id, uint8_t callee_id, uint8_t chain,
			struct mayfly *m)
{
   1945c:	b570      	push	{r4, r5, r6, lr}
   1945e:	4606      	mov	r6, r0
   19460:	460d      	mov	r5, r1
   19462:	461c      	mov	r4, r3
	uint8_t state;
	uint8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
   19464:	b1a2      	cbz	r2, 19490 <mayfly_enqueue+0x34>
   19466:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
   19468:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
   1946a:	7820      	ldrb	r0, [r4, #0]
   1946c:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
   1946e:	f010 0003 	ands.w	r0, r0, #3
   19472:	d02c      	beq.n	194ce <mayfly_enqueue+0x72>
		if (chain) {
   19474:	b31b      	cbz	r3, 194be <mayfly_enqueue+0x62>
			if (state != 1U) {
   19476:	2801      	cmp	r0, #1
   19478:	d028      	beq.n	194cc <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
   1947a:	3201      	adds	r2, #1
   1947c:	b2d2      	uxtb	r2, r2
   1947e:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
   19480:	4b1c      	ldr	r3, [pc, #112]	; (194f4 <mayfly_enqueue+0x98>)
   19482:	2201      	movs	r2, #1
   19484:	555a      	strb	r2, [r3, r5]

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
   19486:	4629      	mov	r1, r5
   19488:	4630      	mov	r0, r6
   1948a:	f007 f88d 	bl	205a8 <mayfly_pend>
   1948e:	e01c      	b.n	194ca <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   19490:	f012 fb14 	bl	2babc <mayfly_prio_is_equal>
   19494:	2800      	cmp	r0, #0
   19496:	d0e6      	beq.n	19466 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
   19498:	4629      	mov	r1, r5
   1949a:	4630      	mov	r0, r6
   1949c:	f007 f864 	bl	20568 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   194a0:	2800      	cmp	r0, #0
   194a2:	d0e0      	beq.n	19466 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
   194a4:	2330      	movs	r3, #48	; 0x30
   194a6:	220c      	movs	r2, #12
   194a8:	436b      	muls	r3, r5
   194aa:	fb02 3306 	mla	r3, r2, r6, r3
   194ae:	4a12      	ldr	r2, [pc, #72]	; (194f8 <mayfly_enqueue+0x9c>)
   194b0:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
   194b2:	7a93      	ldrb	r3, [r2, #10]
   194b4:	7ad2      	ldrb	r2, [r2, #11]
   194b6:	1a9b      	subs	r3, r3, r2
   194b8:	bf18      	it	ne
   194ba:	2301      	movne	r3, #1
   194bc:	e7d4      	b.n	19468 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
   194be:	3202      	adds	r2, #2
   194c0:	b2d2      	uxtb	r2, r2
   194c2:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
   194c4:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
   194c8:	4798      	blx	r3

	return 0;
   194ca:	2000      	movs	r0, #0
}
   194cc:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
   194ce:	2b00      	cmp	r3, #0
   194d0:	d0f8      	beq.n	194c4 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
   194d2:	3201      	adds	r2, #1
   194d4:	b2d2      	uxtb	r2, r2
   194d6:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   194d8:	2304      	movs	r3, #4
   194da:	2230      	movs	r2, #48	; 0x30
   194dc:	fb12 3205 	smlabb	r2, r2, r5, r3
   194e0:	230c      	movs	r3, #12
   194e2:	fb13 2306 	smlabb	r3, r3, r6, r2
   194e6:	4a04      	ldr	r2, [pc, #16]	; (194f8 <mayfly_enqueue+0x9c>)
   194e8:	6860      	ldr	r0, [r4, #4]
   194ea:	441a      	add	r2, r3
   194ec:	4621      	mov	r1, r4
   194ee:	f011 f9ed 	bl	2a8cc <memq_enqueue>
   194f2:	e7c5      	b.n	19480 <mayfly_enqueue+0x24>
   194f4:	20003aef 	.word	0x20003aef
   194f8:	2000294c 	.word	0x2000294c

000194fc <mayfly_run>:
		}
	}
}

void mayfly_run(uint8_t callee_id)
{
   194fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t disable = 0U;
	uint8_t enable = 0U;
	uint8_t caller_id;

	if (!mfp[callee_id]) {
   19500:	4b55      	ldr	r3, [pc, #340]	; (19658 <mayfly_run+0x15c>)
   19502:	5c1a      	ldrb	r2, [r3, r0]
{
   19504:	b089      	sub	sp, #36	; 0x24
   19506:	4604      	mov	r4, r0
	if (!mfp[callee_id]) {
   19508:	2a00      	cmp	r2, #0
   1950a:	f000 809e 	beq.w	1964a <mayfly_run+0x14e>
		return;
	}
	mfp[callee_id] = 0U;
   1950e:	f04f 0800 	mov.w	r8, #0
   19512:	f803 8000 	strb.w	r8, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
   19516:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1951a:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   1951c:	4e4f      	ldr	r6, [pc, #316]	; (1965c <mayfly_run+0x160>)
   1951e:	9304      	str	r3, [sp, #16]
   19520:	2504      	movs	r5, #4
   19522:	233c      	movs	r3, #60	; 0x3c
   19524:	fb13 5300 	smlabb	r3, r3, r0, r5
   19528:	18f3      	adds	r3, r6, r3
   1952a:	9303      	str	r3, [sp, #12]
	uint8_t disable = 0U;
   1952c:	46c3      	mov	fp, r8
	while (caller_id--) {
   1952e:	3d01      	subs	r5, #1
   19530:	b2ed      	uxtb	r5, r5
   19532:	2dff      	cmp	r5, #255	; 0xff
   19534:	d10f      	bne.n	19556 <mayfly_run+0x5a>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
   19536:	f1bb 0f00 	cmp.w	fp, #0
   1953a:	f000 8086 	beq.w	1964a <mayfly_run+0x14e>
   1953e:	f1b8 0f00 	cmp.w	r8, #0
   19542:	f040 8082 	bne.w	1964a <mayfly_run+0x14e>
		mayfly_enable_cb(callee_id, callee_id, 0);
   19546:	4642      	mov	r2, r8
   19548:	4621      	mov	r1, r4
   1954a:	4620      	mov	r0, r4
	}
}
   1954c:	b009      	add	sp, #36	; 0x24
   1954e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		mayfly_enable_cb(callee_id, callee_id, 0);
   19552:	f006 bfe9 	b.w	20528 <mayfly_enable_cb>
		struct mayfly *m = 0;
   19556:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
   19558:	f04f 090c 	mov.w	r9, #12
		struct mayfly *m = 0;
   1955c:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
   1955e:	fb09 fa05 	mul.w	sl, r9, r5
   19562:	2330      	movs	r3, #48	; 0x30
   19564:	fb03 a304 	mla	r3, r3, r4, sl
   19568:	18f1      	adds	r1, r6, r3
   1956a:	58f0      	ldr	r0, [r6, r3]
   1956c:	6849      	ldr	r1, [r1, #4]
   1956e:	aa07      	add	r2, sp, #28
   19570:	f011 f9b3 	bl	2a8da <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
   19574:	9b04      	ldr	r3, [sp, #16]
   19576:	fb19 3905 	smlabb	r9, r9, r5, r3
   1957a:	eb06 0309 	add.w	r3, r6, r9
		link = memq_peek(mft[callee_id][caller_id].head,
   1957e:	4607      	mov	r7, r0
		memq_dequeue(mft[callee_id][caller_id].tail,
   19580:	9302      	str	r3, [sp, #8]
		while (link) {
   19582:	2f00      	cmp	r7, #0
   19584:	d043      	beq.n	1960e <mayfly_run+0x112>
			state = (m->_req - m->_ack) & 0x03;
   19586:	9b07      	ldr	r3, [sp, #28]
   19588:	f893 9000 	ldrb.w	r9, [r3]
   1958c:	785a      	ldrb	r2, [r3, #1]
   1958e:	eba9 0902 	sub.w	r9, r9, r2
   19592:	f009 0903 	and.w	r9, r9, #3
			if (state == 1U) {
   19596:	f1b9 0f01 	cmp.w	r9, #1
   1959a:	d104      	bne.n	195a6 <mayfly_run+0xaa>
				m->_ack--;
   1959c:	3a01      	subs	r2, #1
   1959e:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
   195a0:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
   195a4:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
   195a6:	9b07      	ldr	r3, [sp, #28]
	if (((req - m->_ack) & 0x03) != 1U) {
   195a8:	9305      	str	r3, [sp, #20]
	req = m->_req;
   195aa:	781a      	ldrb	r2, [r3, #0]
   195ac:	b2d1      	uxtb	r1, r2
   195ae:	9101      	str	r1, [sp, #4]
	if (((req - m->_ack) & 0x03) != 1U) {
   195b0:	7859      	ldrb	r1, [r3, #1]
   195b2:	1a52      	subs	r2, r2, r1
   195b4:	f002 0203 	and.w	r2, r2, #3
   195b8:	2a01      	cmp	r2, #1
   195ba:	d019      	beq.n	195f0 <mayfly_run+0xf4>
		memq_dequeue(mft[callee_id][caller_id].tail,
   195bc:	2030      	movs	r0, #48	; 0x30
   195be:	fb00 a004 	mla	r0, r0, r4, sl
   195c2:	4430      	add	r0, r6
   195c4:	9902      	ldr	r1, [sp, #8]
   195c6:	6840      	ldr	r0, [r0, #4]
   195c8:	2200      	movs	r2, #0
   195ca:	f011 f98e 	bl	2a8ea <memq_dequeue>
		m->_link = link;
   195ce:	9b05      	ldr	r3, [sp, #20]
		m->_ack = req;
   195d0:	9a01      	ldr	r2, [sp, #4]
		ack = m->_ack;
   195d2:	7859      	ldrb	r1, [r3, #1]
		m->_ack = req;
   195d4:	705a      	strb	r2, [r3, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   195d6:	781a      	ldrb	r2, [r3, #0]
		m->_link = link;
   195d8:	605f      	str	r7, [r3, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
   195da:	1a52      	subs	r2, r2, r1
   195dc:	f002 0203 	and.w	r2, r2, #3
   195e0:	2a01      	cmp	r2, #1
   195e2:	d105      	bne.n	195f0 <mayfly_run+0xf4>
			m->_ack = ack;
   195e4:	7059      	strb	r1, [r3, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   195e6:	9a03      	ldr	r2, [sp, #12]
   195e8:	4619      	mov	r1, r3
   195ea:	4638      	mov	r0, r7
   195ec:	f011 f96e 	bl	2a8cc <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
   195f0:	2330      	movs	r3, #48	; 0x30
   195f2:	fb03 a304 	mla	r3, r3, r4, sl
   195f6:	18f1      	adds	r1, r6, r3
   195f8:	58f0      	ldr	r0, [r6, r3]
   195fa:	6849      	ldr	r1, [r1, #4]
   195fc:	aa07      	add	r2, sp, #28
   195fe:	f011 f96c 	bl	2a8da <memq_peek>
			if (state == 1U) {
   19602:	f1b9 0f01 	cmp.w	r9, #1
			link = memq_peek(mft[callee_id][caller_id].head,
   19606:	4607      	mov	r7, r0
			if (state == 1U) {
   19608:	d1bb      	bne.n	19582 <mayfly_run+0x86>
				if (caller_id || link) {
   1960a:	b9bd      	cbnz	r5, 1963c <mayfly_run+0x140>
   1960c:	b9b0      	cbnz	r0, 1963c <mayfly_run+0x140>
		if (mft[callee_id][caller_id].disable_req !=
   1960e:	2230      	movs	r2, #48	; 0x30
   19610:	210c      	movs	r1, #12
   19612:	4362      	muls	r2, r4
   19614:	fb01 2205 	mla	r2, r1, r5, r2
   19618:	4432      	add	r2, r6
   1961a:	7a93      	ldrb	r3, [r2, #10]
   1961c:	7ad0      	ldrb	r0, [r2, #11]
   1961e:	4298      	cmp	r0, r3
   19620:	d116      	bne.n	19650 <mayfly_run+0x154>
		if (mft[callee_id][caller_id].enable_req !=
   19622:	2330      	movs	r3, #48	; 0x30
   19624:	4363      	muls	r3, r4
   19626:	fb01 3305 	mla	r3, r1, r5, r3
   1962a:	4433      	add	r3, r6
   1962c:	7a1a      	ldrb	r2, [r3, #8]
   1962e:	7a59      	ldrb	r1, [r3, #9]
   19630:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
   19632:	bf1c      	itt	ne
   19634:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
   19636:	f04f 0801 	movne.w	r8, #1
   1963a:	e778      	b.n	1952e <mayfly_run+0x32>
					mfp[callee_id] = 1U;
   1963c:	4b06      	ldr	r3, [pc, #24]	; (19658 <mayfly_run+0x15c>)
   1963e:	2201      	movs	r2, #1
   19640:	551a      	strb	r2, [r3, r4]
					mayfly_pend(callee_id, callee_id);
   19642:	4621      	mov	r1, r4
   19644:	4620      	mov	r0, r4
   19646:	f006 ffaf 	bl	205a8 <mayfly_pend>
}
   1964a:	b009      	add	sp, #36	; 0x24
   1964c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
   19650:	72d3      	strb	r3, [r2, #11]
			disable = 1U;
   19652:	f04f 0b01 	mov.w	fp, #1
   19656:	e7e4      	b.n	19622 <mayfly_run+0x126>
   19658:	20003aef 	.word	0x20003aef
   1965c:	2000294c 	.word	0x2000294c

00019660 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
   19660:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer job, as worker is running */
	if (instance->worker_trigger) {
   19664:	7fc3      	ldrb	r3, [r0, #31]
{
   19666:	b08b      	sub	sp, #44	; 0x2c
   19668:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
   1966a:	2b00      	cmp	r3, #0
   1966c:	f040 83bd 	bne.w	19dea <ticker_job+0x78a>
		DEBUG_TICKER_JOB(0);
		return;
	}

	/* Defer job, as job is already running */
	if (instance->job_guard) {
   19670:	7f82      	ldrb	r2, [r0, #30]
   19672:	b14a      	cbz	r2, 19688 <ticker_job+0x28>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_JOB, 1,
   19674:	6a45      	ldr	r5, [r0, #36]	; 0x24
   19676:	4603      	mov	r3, r0
   19678:	2201      	movs	r2, #1
   1967a:	2104      	movs	r1, #4
	/* Permit worker to run */
	instance->job_guard = 0U;

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   1967c:	2004      	movs	r0, #4
   1967e:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
   19680:	b00b      	add	sp, #44	; 0x2c
   19682:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   19686:	4760      	bx	ip
	ticks_previous = instance->ticks_current;
   19688:	6943      	ldr	r3, [r0, #20]
   1968a:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
   1968c:	2101      	movs	r1, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   1968e:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
   19690:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   19692:	7ac0      	ldrb	r0, [r0, #11]
   19694:	4298      	cmp	r0, r3
   19696:	d057      	beq.n	19748 <ticker_job+0xe8>
	uint8_t idx = *ticks_elapsed_index + 1;
   19698:	440b      	add	r3, r1
   1969a:	b2db      	uxtb	r3, r3
		idx = 0U;
   1969c:	2b02      	cmp	r3, #2
   1969e:	bf08      	it	eq
   196a0:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   196a2:	72a3      	strb	r3, [r4, #10]
		ticks_elapsed =
   196a4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		flag_elapsed = 1U;
   196a8:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
   196aa:	68db      	ldr	r3, [r3, #12]
   196ac:	9300      	str	r3, [sp, #0]
		instance->ticks_current += ticks_elapsed;
   196ae:	9a00      	ldr	r2, [sp, #0]
   196b0:	9b04      	ldr	r3, [sp, #16]
   196b2:	4413      	add	r3, r2
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   196b4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   196b8:	6163      	str	r3, [r4, #20]
	ticker_id_old_head = instance->ticker_id_head;
   196ba:	7f63      	ldrb	r3, [r4, #29]
   196bc:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
   196be:	6823      	ldr	r3, [r4, #0]
   196c0:	9302      	str	r3, [sp, #8]
	users = &instance->users[0];
   196c2:	6863      	ldr	r3, [r4, #4]
   196c4:	9308      	str	r3, [sp, #32]
	while (count_user--) {
   196c6:	7a63      	ldrb	r3, [r4, #9]
   196c8:	3b01      	subs	r3, #1
   196ca:	fa5f fb83 	uxtb.w	fp, r3
	pending = 0U;
   196ce:	2300      	movs	r3, #0
   196d0:	9305      	str	r3, [sp, #20]
	insert_head = TICKER_NULL;
   196d2:	f04f 09ff 	mov.w	r9, #255	; 0xff
	while (count_user--) {
   196d6:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   196da:	d138      	bne.n	1974e <ticker_job+0xee>
	if (instance->ticker_id_head != ticker_id_old_head) {
   196dc:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   196de:	9a03      	ldr	r2, [sp, #12]
   196e0:	1a9b      	subs	r3, r3, r2
   196e2:	bf18      	it	ne
   196e4:	2301      	movne	r3, #1
   196e6:	9302      	str	r3, [sp, #8]
	if (flag_elapsed) {
   196e8:	9b01      	ldr	r3, [sp, #4]
   196ea:	2b00      	cmp	r3, #0
   196ec:	f000 8223 	beq.w	19b36 <ticker_job+0x4d6>
	ticks_now = cntr_cnt_get();
   196f0:	f006 fb72 	bl	1fdd8 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
uint32_t ticker_ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   196f4:	9b04      	ldr	r3, [sp, #16]
	while (instance->ticker_id_head != TICKER_NULL) {
   196f6:	9f00      	ldr	r7, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   196f8:	eba0 0b03 	sub.w	fp, r0, r3
	node = &instance->nodes[0];
   196fc:	6823      	ldr	r3, [r4, #0]
   196fe:	9306      	str	r3, [sp, #24]
	ticks_expired = 0U;
   19700:	2300      	movs	r3, #0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19702:	f02b 4b7f 	bic.w	fp, fp, #4278190080	; 0xff000000
	ticks_expired = 0U;
   19706:	9307      	str	r3, [sp, #28]
	while (instance->ticker_id_head != TICKER_NULL) {
   19708:	7f66      	ldrb	r6, [r4, #29]
   1970a:	2eff      	cmp	r6, #255	; 0xff
   1970c:	d00d      	beq.n	1972a <ticker_job+0xca>
		ticker = &node[id_expired];
   1970e:	b235      	sxth	r5, r6
   19710:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   19714:	012b      	lsls	r3, r5, #4
   19716:	9308      	str	r3, [sp, #32]
   19718:	9b06      	ldr	r3, [sp, #24]
   1971a:	eb03 1505 	add.w	r5, r3, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
   1971e:	68ab      	ldr	r3, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
   19720:	42bb      	cmp	r3, r7
   19722:	f240 80c8 	bls.w	198b6 <ticker_job+0x256>
			ticker->ticks_to_expire -= ticks_elapsed;
   19726:	1bdb      	subs	r3, r3, r7
   19728:	60ab      	str	r3, [r5, #8]
			flag_compare_update = 1U;
   1972a:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   1972e:	9903      	ldr	r1, [sp, #12]
		ticker_job_list_insert(instance, insert_head);
   19730:	4620      	mov	r0, r4
			flag_compare_update = 1U;
   19732:	42b1      	cmp	r1, r6
   19734:	bf18      	it	ne
   19736:	4613      	movne	r3, r2
		ticker_job_list_insert(instance, insert_head);
   19738:	4649      	mov	r1, r9
			flag_compare_update = 1U;
   1973a:	9302      	str	r3, [sp, #8]
		ticker_job_list_insert(instance, insert_head);
   1973c:	f011 f948 	bl	2a9d0 <ticker_job_list_insert>
	nodes = &instance->nodes[0];
   19740:	6825      	ldr	r5, [r4, #0]
	uint8_t  rescheduled = 0U;
   19742:	2300      	movs	r3, #0
		ticker_id_head = instance->ticker_id_head;
   19744:	7f67      	ldrb	r7, [r4, #29]
		while (ticker_id_head != TICKER_NULL) {
   19746:	e16b      	b.n	19a20 <ticker_job+0x3c0>
		flag_elapsed = 0U;
   19748:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
   1974a:	9200      	str	r2, [sp, #0]
   1974c:	e7b5      	b.n	196ba <ticker_job+0x5a>
		user = &users[count_user];
   1974e:	9b08      	ldr	r3, [sp, #32]
   19750:	eb03 08cb 	add.w	r8, r3, fp, lsl #3
		user_ops = &user->user_op[0];
   19754:	f8d8 3004 	ldr.w	r3, [r8, #4]
   19758:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
   1975a:	f898 1003 	ldrb.w	r1, [r8, #3]
			user_op = &user_ops[user->middle];
   1975e:	2034      	movs	r0, #52	; 0x34
		while (user->middle != user->last) {
   19760:	f898 7002 	ldrb.w	r7, [r8, #2]
   19764:	428f      	cmp	r7, r1
   19766:	f000 82da 	beq.w	19d1e <ticker_job+0x6be>
			user_op = &user_ops[user->middle];
   1976a:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
   1976c:	f898 5000 	ldrb.w	r5, [r8]
			user_op = &user_ops[user->middle];
   19770:	fb17 f200 	smulbb	r2, r7, r0
   19774:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
   19776:	1c7b      	adds	r3, r7, #1
   19778:	b2db      	uxtb	r3, r3
				middle = 0U;
   1977a:	429d      	cmp	r5, r3
   1977c:	bf08      	it	eq
   1977e:	2300      	moveq	r3, #0
			user->middle = middle;
   19780:	f888 3002 	strb.w	r3, [r8, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   19784:	9b06      	ldr	r3, [sp, #24]
   19786:	5c9a      	ldrb	r2, [r3, r2]
   19788:	2a04      	cmp	r2, #4
   1978a:	d9e9      	bls.n	19760 <ticker_job+0x100>
			ticker = &node[user_op->id];
   1978c:	7871      	ldrb	r1, [r6, #1]
   1978e:	eb01 0541 	add.w	r5, r1, r1, lsl #1
   19792:	012b      	lsls	r3, r5, #4
   19794:	9309      	str	r3, [sp, #36]	; 0x24
   19796:	9b02      	ldr	r3, [sp, #8]
   19798:	eb03 1505 	add.w	r5, r3, r5, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   1979c:	2a08      	cmp	r2, #8
			state = (ticker->req - ticker->ack) & 0xff;
   1979e:	786b      	ldrb	r3, [r5, #1]
   197a0:	78a8      	ldrb	r0, [r5, #2]
   197a2:	eba3 0300 	sub.w	r3, r3, r0
   197a6:	b2db      	uxtb	r3, r3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
   197a8:	d818      	bhi.n	197dc <ticker_job+0x17c>
   197aa:	b1bb      	cbz	r3, 197dc <ticker_job+0x17c>
			    (state == 0U) ||
   197ac:	2a05      	cmp	r2, #5
   197ae:	f040 82a9 	bne.w	19d04 <ticker_job+0x6a4>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
   197b2:	6872      	ldr	r2, [r6, #4]
   197b4:	2a00      	cmp	r2, #0
   197b6:	f040 82b7 	bne.w	19d28 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
   197ba:	68b2      	ldr	r2, [r6, #8]
   197bc:	2a00      	cmp	r2, #0
   197be:	f040 82b3 	bne.w	19d28 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
   197c2:	68f2      	ldr	r2, [r6, #12]
   197c4:	2a00      	cmp	r2, #0
   197c6:	f040 82af 	bne.w	19d28 <ticker_job+0x6c8>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
   197ca:	6932      	ldr	r2, [r6, #16]
   197cc:	2a00      	cmp	r2, #0
   197ce:	f040 82ab 	bne.w	19d28 <ticker_job+0x6c8>
			     (user_op->params.update.lazy == 0U) &&
   197d2:	6972      	ldr	r2, [r6, #20]
   197d4:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   197d8:	f040 82a6 	bne.w	19d28 <ticker_job+0x6c8>
				ticker_job_op_cb(user_op,
   197dc:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   197de:	4630      	mov	r0, r6
   197e0:	f011 f8ec 	bl	2a9bc <ticker_job_op_cb>
}
   197e4:	e7b9      	b.n	1975a <ticker_job+0xfa>
	if ((ticker->remainder_current >= BIT(31)) ||
   197e6:	6a69      	ldr	r1, [r5, #36]	; 0x24
   197e8:	4f91      	ldr	r7, [pc, #580]	; (19a30 <ticker_job+0x3d0>)
   197ea:	f8df a248 	ldr.w	sl, [pc, #584]	; 19a34 <ticker_job+0x3d4>
   197ee:	19cf      	adds	r7, r1, r7
   197f0:	4557      	cmp	r7, sl
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
   197f2:	bf81      	itttt	hi
   197f4:	f101 71e8 	addhi.w	r1, r1, #30408704	; 0x1d00000
   197f8:	f501 31d4 	addhi.w	r1, r1, #108544	; 0x1a800
   197fc:	f501 71a5 	addhi.w	r1, r1, #330	; 0x14a
   19800:	6269      	strhi	r1, [r5, #36]	; 0x24
	ticker->remainder_current -= ticker->remainder_periodic;
   19802:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
		decrement++;
   19806:	bf8c      	ite	hi
   19808:	f04f 0a01 	movhi.w	sl, #1
	uint8_t decrement = 0U;
   1980c:	f04f 0a00 	movls.w	sl, #0
	ticker->remainder_current -= ticker->remainder_periodic;
   19810:	1a79      	subs	r1, r7, r1
			ticks_to_expire -= ticker->ticks_periodic +
   19812:	4482      	add	sl, r0
			ticker->lazy_current--;
   19814:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
	ticker->remainder_current -= ticker->remainder_periodic;
   19818:	6269      	str	r1, [r5, #36]	; 0x24
			ticks_to_expire -= ticker->ticks_periodic +
   1981a:	eba3 030a 	sub.w	r3, r3, sl
			ticker->lazy_current--;
   1981e:	f8a5 e01e 	strh.w	lr, [r5, #30]
   19822:	e2a7      	b.n	19d74 <ticker_job+0x714>
	ticker->remainder_current += ticker->remainder_periodic;
   19824:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
   19828:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
   1982a:	4f81      	ldr	r7, [pc, #516]	; (19a30 <ticker_job+0x3d0>)
   1982c:	f8df a204 	ldr.w	sl, [pc, #516]	; 19a34 <ticker_job+0x3d4>
   19830:	19cf      	adds	r7, r1, r7
   19832:	4557      	cmp	r7, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   19834:	bf9d      	ittte	ls
   19836:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
   1983a:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
   1983e:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
	ticker->remainder_current += ticker->remainder_periodic;
   19842:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   19844:	bf96      	itet	ls
   19846:	6269      	strls	r1, [r5, #36]	; 0x24
	return 0;
   19848:	2100      	movhi	r1, #0
		return 1;
   1984a:	2101      	movls	r1, #1
			ticks_to_expire += ticker->ticks_periodic +
   1984c:	4401      	add	r1, r0
			ticker->lazy_current++;
   1984e:	f10e 0e01 	add.w	lr, lr, #1
			ticks_to_expire += ticker->ticks_periodic +
   19852:	440b      	add	r3, r1
			ticker->lazy_current++;
   19854:	f8a5 e01e 	strh.w	lr, [r5, #30]
   19858:	e293      	b.n	19d82 <ticker_job+0x722>
		if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
   1985a:	2a06      	cmp	r2, #6
   1985c:	d005      	beq.n	1986a <ticker_job+0x20a>
			ticker->ticks_to_expire = ticker_dequeue(instance,
   1985e:	4620      	mov	r0, r4
   19860:	f011 f863 	bl	2a92a <ticker_dequeue>
			ticker->req = ticker->ack;
   19864:	78ab      	ldrb	r3, [r5, #2]
			ticker->ticks_to_expire = ticker_dequeue(instance,
   19866:	60a8      	str	r0, [r5, #8]
			ticker->req = ticker->ack;
   19868:	706b      	strb	r3, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
   1986a:	7f22      	ldrb	r2, [r4, #28]
   1986c:	7873      	ldrb	r3, [r6, #1]
   1986e:	429a      	cmp	r2, r3
   19870:	f040 82b9 	bne.w	19de6 <ticker_job+0x786>
			instance->ticker_id_slot_previous = TICKER_NULL;
   19874:	23ff      	movs	r3, #255	; 0xff
   19876:	7723      	strb	r3, [r4, #28]
			if ((user_op->op == TICKER_USER_OP_TYPE_YIELD_ABS) ||
   19878:	7833      	ldrb	r3, [r6, #0]
   1987a:	2b06      	cmp	r3, #6
   1987c:	d001      	beq.n	19882 <ticker_job+0x222>
   1987e:	2b08      	cmp	r3, #8
   19880:	d10d      	bne.n	1989e <ticker_job+0x23e>
				ticks_at_yield =
   19882:	6870      	ldr	r0, [r6, #4]
			ticks_current = instance->ticks_current;
   19884:	6963      	ldr	r3, [r4, #20]
			if (!((ticks_at_yield - ticks_current) &
   19886:	1ac2      	subs	r2, r0, r3
   19888:	0211      	lsls	r1, r2, #8
   1988a:	d40b      	bmi.n	198a4 <ticker_job+0x244>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1988c:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
   19890:	9a00      	ldr	r2, [sp, #0]
   19892:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
   19894:	69a2      	ldr	r2, [r4, #24]
   19896:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
   19898:	bf88      	it	hi
   1989a:	61a3      	strhi	r3, [r4, #24]
   1989c:	e2a3      	b.n	19de6 <ticker_job+0x786>
				ticks_at_yield = cntr_cnt_get();
   1989e:	f006 fa9b 	bl	1fdd8 <cntr_cnt_get>
   198a2:	e7ef      	b.n	19884 <ticker_job+0x224>
				if (ticks_elapsed > ticks_used) {
   198a4:	9a00      	ldr	r2, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   198a6:	1a1b      	subs	r3, r3, r0
   198a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
   198ac:	429a      	cmp	r2, r3
					ticks_used = ticks_elapsed -
   198ae:	bf8c      	ite	hi
   198b0:	1ad3      	subhi	r3, r2, r3
					ticks_used = 0;
   198b2:	2300      	movls	r3, #0
   198b4:	e7ee      	b.n	19894 <ticker_job+0x234>
		ticks_expired += ticks_to_expire;
   198b6:	9a07      	ldr	r2, [sp, #28]
		skip_collision = (ticker->lazy_current != 0U);
   198b8:	f8b5 c01e 	ldrh.w	ip, [r5, #30]
		ticks_expired += ticks_to_expire;
   198bc:	441a      	add	r2, r3
   198be:	9207      	str	r2, [sp, #28]
		if (instance->ticks_slot_previous > ticks_to_expire) {
   198c0:	69a2      	ldr	r2, [r4, #24]
   198c2:	4293      	cmp	r3, r2
		ticks_elapsed -= ticks_to_expire;
   198c4:	eba7 0703 	sub.w	r7, r7, r3
		ticks_latency -= ticks_to_expire;
   198c8:	ebab 0b03 	sub.w	fp, fp, r3
			instance->ticker_id_slot_previous = TICKER_NULL;
   198cc:	bf25      	ittet	cs
   198ce:	23ff      	movcs	r3, #255	; 0xff
   198d0:	7723      	strbcs	r3, [r4, #28]
			instance->ticks_slot_previous -= ticks_to_expire;
   198d2:	1ad3      	subcc	r3, r2, r3
			instance->ticks_slot_previous = 0U;
   198d4:	2300      	movcs	r3, #0
   198d6:	61a3      	str	r3, [r4, #24]
		state = (ticker->req - ticker->ack) & 0xff;
   198d8:	78a9      	ldrb	r1, [r5, #2]
   198da:	786b      	ldrb	r3, [r5, #1]
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   198dc:	69a8      	ldr	r0, [r5, #24]
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
   198de:	6aaa      	ldr	r2, [r5, #40]	; 0x28
		state = (ticker->req - ticker->ack) & 0xff;
   198e0:	1a5b      	subs	r3, r3, r1
   198e2:	b2db      	uxtb	r3, r3
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
   198e4:	b160      	cbz	r0, 19900 <ticker_job+0x2a0>
   198e6:	2b02      	cmp	r3, #2
   198e8:	d10a      	bne.n	19900 <ticker_job+0x2a0>
   198ea:	f1bc 0f00 	cmp.w	ip, #0
   198ee:	d107      	bne.n	19900 <ticker_job+0x2a0>
   198f0:	b122      	cbz	r2, 198fc <ticker_job+0x29c>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
   198f2:	f892 e008 	ldrb.w	lr, [r2, #8]
   198f6:	f1be 0f01 	cmp.w	lr, #1
   198fa:	d001      	beq.n	19900 <ticker_job+0x2a0>
			instance->ticker_id_slot_previous = id_expired;
   198fc:	7726      	strb	r6, [r4, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
   198fe:	61a0      	str	r0, [r4, #24]
		ticker->ticks_to_expire = 0U;
   19900:	2000      	movs	r0, #0
   19902:	60a8      	str	r0, [r5, #8]
		instance->ticker_id_head = ticker->next;
   19904:	f8dd e020 	ldr.w	lr, [sp, #32]
   19908:	9806      	ldr	r0, [sp, #24]
   1990a:	f810 000e 	ldrb.w	r0, [r0, lr]
   1990e:	7760      	strb	r0, [r4, #29]
		if ((ticker->ticks_periodic != 0U) ||
   19910:	f8d5 e004 	ldr.w	lr, [r5, #4]
   19914:	f1be 0f00 	cmp.w	lr, #0
   19918:	d119      	bne.n	1994e <ticker_job+0x2ee>
   1991a:	2a00      	cmp	r2, #0
   1991c:	d063      	beq.n	199e6 <ticker_job+0x386>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
   1991e:	7a10      	ldrb	r0, [r2, #8]
   19920:	2801      	cmp	r0, #1
   19922:	d160      	bne.n	199e6 <ticker_job+0x386>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
   19924:	7a13      	ldrb	r3, [r2, #8]
   19926:	2b01      	cmp	r3, #1
   19928:	d113      	bne.n	19952 <ticker_job+0x2f2>
				ticker->ticks_to_expire = ticks_elapsed;
   1992a:	60af      	str	r7, [r5, #8]
				ticker->req = ticker->ack;
   1992c:	7069      	strb	r1, [r5, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
   1992e:	9b04      	ldr	r3, [sp, #16]
   19930:	9a07      	ldr	r2, [sp, #28]
   19932:	6961      	ldr	r1, [r4, #20]
   19934:	189a      	adds	r2, r3, r2
   19936:	4628      	mov	r0, r5
   19938:	f011 f822 	bl	2a980 <ticks_to_expire_prep>
			ticker->next = *insert_head;
   1993c:	9b06      	ldr	r3, [sp, #24]
   1993e:	9a08      	ldr	r2, [sp, #32]
   19940:	f803 9002 	strb.w	r9, [r3, r2]
			ticker->req++;
   19944:	786b      	ldrb	r3, [r5, #1]
   19946:	3301      	adds	r3, #1
   19948:	706b      	strb	r3, [r5, #1]
			ticker->req = ticker->ack;
   1994a:	46b1      	mov	r9, r6
   1994c:	e6dc      	b.n	19708 <ticker_job+0xa8>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
   1994e:	2a00      	cmp	r2, #0
   19950:	d1e8      	bne.n	19924 <ticker_job+0x2c4>
				if (!ticker->lazy_current) {
   19952:	f1bc 0f00 	cmp.w	ip, #0
   19956:	d124      	bne.n	199a2 <ticker_job+0x342>
					lazy_periodic = ticker->lazy_periodic;
   19958:	8ba8      	ldrh	r0, [r5, #28]
				while (count--) {
   1995a:	4680      	mov	r8, r0
				ticks_to_expire = 0U;
   1995c:	2200      	movs	r2, #0
	ticker->remainder_current += ticker->remainder_periodic;
   1995e:	e9d5 1308 	ldrd	r1, r3, [r5, #32]
   19962:	440b      	add	r3, r1
	if ((ticker->remainder_current < BIT(31)) &&
   19964:	4932      	ldr	r1, [pc, #200]	; (19a30 <ticker_job+0x3d0>)
   19966:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 19a34 <ticker_job+0x3d4>
   1996a:	1859      	adds	r1, r3, r1
   1996c:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1996e:	bf9f      	itttt	ls
   19970:	f1a3 73e8 	subls.w	r3, r3, #30408704	; 0x1d00000
   19974:	f5a3 33d4 	subls.w	r3, r3, #108544	; 0x1a800
   19978:	f5a3 73a5 	subls.w	r3, r3, #330	; 0x14a
   1997c:	626b      	strls	r3, [r5, #36]	; 0x24
		return 1;
   1997e:	bf92      	itee	ls
   19980:	9b01      	ldrls	r3, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
   19982:	626b      	strhi	r3, [r5, #36]	; 0x24
	return 0;
   19984:	2300      	movhi	r3, #0
					ticks_to_expire +=
   19986:	4473      	add	r3, lr
				while (count--) {
   19988:	f1b8 0801 	subs.w	r8, r8, #1
					ticks_to_expire +=
   1998c:	441a      	add	r2, r3
				while (count--) {
   1998e:	d2e6      	bcs.n	1995e <ticker_job+0x2fe>
				} else if (!ticker->must_expire) {
   19990:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   19994:	b32b      	cbz	r3, 199e2 <ticker_job+0x382>
				lazy = 0U;
   19996:	2300      	movs	r3, #0
				ticker->lazy_current += (lazy_periodic + lazy);
   19998:	4460      	add	r0, ip
   1999a:	4418      	add	r0, r3
				ticker->ticks_to_expire = ticks_to_expire;
   1999c:	60aa      	str	r2, [r5, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
   1999e:	83e8      	strh	r0, [r5, #30]
   199a0:	e7c5      	b.n	1992e <ticker_job+0x2ce>
					ticker->req = ticker->ack;
   199a2:	7069      	strb	r1, [r5, #1]
					lazy_periodic = 0U;
   199a4:	2000      	movs	r0, #0
   199a6:	e7d8      	b.n	1995a <ticker_job+0x2fa>
	ticker->remainder_current += ticker->remainder_periodic;
   199a8:	e9d5 1308 	ldrd	r1, r3, [r5, #32]
   199ac:	440b      	add	r3, r1
	if ((ticker->remainder_current < BIT(31)) &&
   199ae:	4920      	ldr	r1, [pc, #128]	; (19a30 <ticker_job+0x3d0>)
   199b0:	f8df a080 	ldr.w	sl, [pc, #128]	; 19a34 <ticker_job+0x3d4>
   199b4:	1859      	adds	r1, r3, r1
   199b6:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   199b8:	bf9f      	itttt	ls
   199ba:	f1a3 73e8 	subls.w	r3, r3, #30408704	; 0x1d00000
   199be:	f5a3 33d4 	subls.w	r3, r3, #108544	; 0x1a800
   199c2:	f5a3 73a5 	subls.w	r3, r3, #330	; 0x14a
   199c6:	626b      	strls	r3, [r5, #36]	; 0x24
		return 1;
   199c8:	bf92      	itee	ls
   199ca:	9b01      	ldrls	r3, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
   199cc:	626b      	strhi	r3, [r5, #36]	; 0x24
	return 0;
   199ce:	2300      	movhi	r3, #0
						ticks_to_expire +=
   199d0:	4473      	add	r3, lr
   199d2:	441a      	add	r2, r3
						lazy++;
   199d4:	f108 0801 	add.w	r8, r8, #1
					while (ticks_to_expire <
   199d8:	4593      	cmp	fp, r2
   199da:	fa1f f388 	uxth.w	r3, r8
   199de:	d8e3      	bhi.n	199a8 <ticker_job+0x348>
   199e0:	e7da      	b.n	19998 <ticker_job+0x338>
   199e2:	4698      	mov	r8, r3
   199e4:	e7f8      	b.n	199d8 <ticker_job+0x378>
			if (state && ((state == 1U) || skip_collision) &&
   199e6:	b14b      	cbz	r3, 199fc <ticker_job+0x39c>
   199e8:	2b01      	cmp	r3, #1
   199ea:	d002      	beq.n	199f2 <ticker_job+0x392>
   199ec:	f1bc 0f00 	cmp.w	ip, #0
   199f0:	d004      	beq.n	199fc <ticker_job+0x39c>
			    ticker->fp_op_func) {
   199f2:	6a2b      	ldr	r3, [r5, #32]
			if (state && ((state == 1U) || skip_collision) &&
   199f4:	b113      	cbz	r3, 199fc <ticker_job+0x39c>
				ticker->fp_op_func(TICKER_STATUS_FAILURE,
   199f6:	6a69      	ldr	r1, [r5, #36]	; 0x24
   199f8:	2001      	movs	r0, #1
   199fa:	4798      	blx	r3
			ticker->req = ticker->ack;
   199fc:	78ab      	ldrb	r3, [r5, #2]
   199fe:	706b      	strb	r3, [r5, #1]
   19a00:	464e      	mov	r6, r9
   19a02:	e7a2      	b.n	1994a <ticker_job+0x2ea>
			ticker = &nodes[ticker_id_head];
   19a04:	eb07 0247 	add.w	r2, r7, r7, lsl #1
   19a08:	0111      	lsls	r1, r2, #4
   19a0a:	eb05 1202 	add.w	r2, r5, r2, lsl #4
			ext_data = ticker->ext_data;
   19a0e:	f815 e001 	ldrb.w	lr, [r5, r1]
   19a12:	6a96      	ldr	r6, [r2, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
   19a14:	b11e      	cbz	r6, 19a1e <ticker_job+0x3be>
   19a16:	7a31      	ldrb	r1, [r6, #8]
   19a18:	2901      	cmp	r1, #1
   19a1a:	f000 816d 	beq.w	19cf8 <ticker_job+0x698>
			ticker_id_head = ticker->next;
   19a1e:	4677      	mov	r7, lr
		while (ticker_id_head != TICKER_NULL) {
   19a20:	2fff      	cmp	r7, #255	; 0xff
   19a22:	d1ef      	bne.n	19a04 <ticker_job+0x3a4>
			flag_compare_update = 1U;
   19a24:	2b00      	cmp	r3, #0
   19a26:	9a02      	ldr	r2, [sp, #8]
   19a28:	bf18      	it	ne
   19a2a:	461a      	movne	r2, r3
   19a2c:	9202      	str	r2, [sp, #8]
   19a2e:	e086      	b.n	19b3e <ticker_job+0x4de>
   19a30:	ff172b5a 	.word	0xff172b5a
   19a34:	7f172b59 	.word	0x7f172b59
			instance->ticks_slot_previous > ticks_elapsed) {
   19a38:	69a0      	ldr	r0, [r4, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
   19a3a:	9b00      	ldr	r3, [sp, #0]
   19a3c:	4283      	cmp	r3, r0
   19a3e:	f080 815f 	bcs.w	19d00 <ticker_job+0x6a0>
			window_start_ticks = instance->ticks_slot_previous -
   19a42:	1ac3      	subs	r3, r0, r3
		window_start_ticks = 0U;
   19a44:	9301      	str	r3, [sp, #4]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
   19a46:	e9d6 3a00 	ldrd	r3, sl, [r6]
   19a4a:	459a      	cmp	sl, r3
   19a4c:	d25b      	bcs.n	19b06 <ticker_job+0x4a6>
			ticks_slot_window = ext_data->ticks_slot_window -
   19a4e:	f04f 0c00 	mov.w	ip, #0
   19a52:	eba3 0b0a 	sub.w	fp, r3, sl
		ticker_id_iter = nodes[ticker_id_head].next;
   19a56:	4671      	mov	r1, lr
			ticks_slot_window = ext_data->ticks_slot_window -
   19a58:	4663      	mov	r3, ip
		while (ticker_id_iter != TICKER_NULL &&
   19a5a:	29ff      	cmp	r1, #255	; 0xff
   19a5c:	d006      	beq.n	19a6c <ticker_job+0x40c>
		       ticks_start_offset + ticker->ticks_slot <=
   19a5e:	f8d2 8018 	ldr.w	r8, [r2, #24]
   19a62:	eb0c 0008 	add.w	r0, ip, r8
		while (ticker_id_iter != TICKER_NULL &&
   19a66:	4583      	cmp	fp, r0
		       ticks_start_offset + ticker->ticks_slot <=
   19a68:	9006      	str	r0, [sp, #24]
		while (ticker_id_iter != TICKER_NULL &&
   19a6a:	d21c      	bcs.n	19aa6 <ticker_job+0x446>
		ticker->ext_data->ticks_drift += ticks_to_expire -
   19a6c:	6891      	ldr	r1, [r2, #8]
   19a6e:	ebaa 0101 	sub.w	r1, sl, r1
   19a72:	4419      	add	r1, r3
   19a74:	6071      	str	r1, [r6, #4]
		ticker->ticks_to_expire = ticks_to_expire;
   19a76:	6093      	str	r3, [r2, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
   19a78:	4671      	mov	r1, lr
		ticker_id_prev = TICKER_NULL;
   19a7a:	23ff      	movs	r3, #255	; 0xff
		while (ticker_id_iter != TICKER_NULL) {
   19a7c:	29ff      	cmp	r1, #255	; 0xff
   19a7e:	d047      	beq.n	19b10 <ticker_job+0x4b0>
			node = &nodes[ticker_id_iter];
   19a80:	eb01 0041 	add.w	r0, r1, r1, lsl #1
   19a84:	ea4f 1900 	mov.w	r9, r0, lsl #4
   19a88:	eb05 1000 	add.w	r0, r5, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
   19a8c:	f8d2 8008 	ldr.w	r8, [r2, #8]
   19a90:	f8d0 c008 	ldr.w	ip, [r0, #8]
   19a94:	45e0      	cmp	r8, ip
   19a96:	d938      	bls.n	19b0a <ticker_job+0x4aa>
				ticker->ticks_to_expire -=
   19a98:	eba8 030c 	sub.w	r3, r8, ip
   19a9c:	6093      	str	r3, [r2, #8]
			ticker_id_iter = node->next;
   19a9e:	460b      	mov	r3, r1
   19aa0:	f815 1009 	ldrb.w	r1, [r5, r9]
   19aa4:	e7ea      	b.n	19a7c <ticker_job+0x41c>
			node = &nodes[ticker_id_iter];
   19aa6:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   19aaa:	0108      	lsls	r0, r1, #4
   19aac:	eb05 1101 	add.w	r1, r5, r1, lsl #4
   19ab0:	9004      	str	r0, [sp, #16]
			if (node->ext_data &&
   19ab2:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
   19ab6:	f1b9 0f00 	cmp.w	r9, #0
   19aba:	d007      	beq.n	19acc <ticker_job+0x46c>
   19abc:	f899 9008 	ldrb.w	r9, [r9, #8]
   19ac0:	f1b9 0f01 	cmp.w	r9, #1
   19ac4:	d102      	bne.n	19acc <ticker_job+0x46c>
				ticker_id_iter = node->next;
   19ac6:	4601      	mov	r1, r0
			ticker_id_iter = node->next;
   19ac8:	5c69      	ldrb	r1, [r5, r1]
   19aca:	e7c6      	b.n	19a5a <ticker_job+0x3fa>
			if (node->ticks_to_expire >
   19acc:	f8d1 9008 	ldr.w	r9, [r1, #8]
   19ad0:	f1b9 0f04 	cmp.w	r9, #4
   19ad4:	d90e      	bls.n	19af4 <ticker_job+0x494>
					MIN(ticks_slot_window,
   19ad6:	f1ac 0304 	sub.w	r3, ip, #4
   19ada:	444b      	add	r3, r9
				window_end_ticks =
   19adc:	455b      	cmp	r3, fp
			if (window_end_ticks > ticks_start_offset +
   19ade:	9806      	ldr	r0, [sp, #24]
				window_end_ticks =
   19ae0:	bf28      	it	cs
   19ae2:	465b      	movcs	r3, fp
			if (window_end_ticks > ticks_start_offset +
   19ae4:	4283      	cmp	r3, r0
   19ae6:	d905      	bls.n	19af4 <ticker_job+0x494>
			if (ticks_to_expire != 0U &&
   19ae8:	ebb3 0308 	subs.w	r3, r3, r8
   19aec:	d002      	beq.n	19af4 <ticker_job+0x494>
   19aee:	9801      	ldr	r0, [sp, #4]
   19af0:	4283      	cmp	r3, r0
   19af2:	d2bb      	bcs.n	19a6c <ticker_job+0x40c>
			window_start_ticks  = node->ticks_to_expire +
   19af4:	6988      	ldr	r0, [r1, #24]
			ticker_id_iter = node->next;
   19af6:	9904      	ldr	r1, [sp, #16]
			window_start_ticks  = node->ticks_to_expire +
   19af8:	eb00 0309 	add.w	r3, r0, r9
   19afc:	9301      	str	r3, [sp, #4]
			ticks_start_offset += node->ticks_to_expire;
   19afe:	44cc      	add	ip, r9
			ticks_to_expire     = ticks_slot_window -
   19b00:	ebab 0308 	sub.w	r3, fp, r8
			ticker_id_iter = node->next;
   19b04:	e7e0      	b.n	19ac8 <ticker_job+0x468>
   19b06:	2300      	movs	r3, #0
   19b08:	e7b0      	b.n	19a6c <ticker_job+0x40c>
				node->ticks_to_expire -=
   19b0a:	ebac 0108 	sub.w	r1, ip, r8
   19b0e:	6081      	str	r1, [r0, #8]
		if (ticker_id_prev != TICKER_NULL) {
   19b10:	2bff      	cmp	r3, #255	; 0xff
   19b12:	d008      	beq.n	19b26 <ticker_job+0x4c6>
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
   19b14:	b21b      	sxth	r3, r3
   19b16:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   19b1a:	011b      	lsls	r3, r3, #4
			instance->ticker_id_head = nodes[ticker_id_head].next;
   19b1c:	f884 e01d 	strb.w	lr, [r4, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
   19b20:	5ce9      	ldrb	r1, [r5, r3]
   19b22:	7011      	strb	r1, [r2, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
   19b24:	54ef      	strb	r7, [r5, r3]
		ticker->lazy_current--;
   19b26:	8bd3      	ldrh	r3, [r2, #30]
   19b28:	3b01      	subs	r3, #1
   19b2a:	83d3      	strh	r3, [r2, #30]
		ext_data->reschedule_state =
   19b2c:	f04f 0302 	mov.w	r3, #2
   19b30:	7233      	strb	r3, [r6, #8]
		rescheduled  = 1U;
   19b32:	2301      	movs	r3, #1
   19b34:	e606      	b.n	19744 <ticker_job+0xe4>
		ticker_job_list_insert(instance, insert_head);
   19b36:	4649      	mov	r1, r9
   19b38:	4620      	mov	r0, r4
   19b3a:	f010 ff49 	bl	2a9d0 <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
   19b3e:	7f63      	ldrb	r3, [r4, #29]
   19b40:	9a03      	ldr	r2, [sp, #12]
   19b42:	4293      	cmp	r3, r2
	if (!pending) {
   19b44:	9b05      	ldr	r3, [sp, #20]
	if (instance->ticker_id_head != ticker_id_old_head) {
   19b46:	f040 80d1 	bne.w	19cec <ticker_job+0x68c>
	if (!pending) {
   19b4a:	b93b      	cbnz	r3, 19b5c <ticker_job+0x4fc>
	users = &instance->users[0];
   19b4c:	7a65      	ldrb	r5, [r4, #9]
   19b4e:	6863      	ldr	r3, [r4, #4]
   19b50:	9300      	str	r3, [sp, #0]
	while (count_user--) {
   19b52:	3d01      	subs	r5, #1
   19b54:	b2ed      	uxtb	r5, r5
		uop->status = TICKER_STATUS_SUCCESS;
   19b56:	2700      	movs	r7, #0
	while (count_user--) {
   19b58:	2dff      	cmp	r5, #255	; 0xff
   19b5a:	d116      	bne.n	19b8a <ticker_job+0x52a>
	if (flag_compare_update) {
   19b5c:	9b02      	ldr	r3, [sp, #8]
   19b5e:	b14b      	cbz	r3, 19b74 <ticker_job+0x514>
	if (instance->ticker_id_head == TICKER_NULL) {
   19b60:	7f63      	ldrb	r3, [r4, #29]
   19b62:	2bff      	cmp	r3, #255	; 0xff
   19b64:	d179      	bne.n	19c5a <ticker_job+0x5fa>
		if (cntr_stop() == 0) {
   19b66:	f006 f911 	bl	1fd8c <cntr_stop>
   19b6a:	b918      	cbnz	r0, 19b74 <ticker_job+0x514>
			instance->ticks_slot_previous = 0U;
   19b6c:	61a0      	str	r0, [r4, #24]
			instance->ticks_current = cntr_cnt_get();
   19b6e:	f006 f933 	bl	1fdd8 <cntr_cnt_get>
   19b72:	6160      	str	r0, [r4, #20]
	instance->job_guard = 0U;
   19b74:	2300      	movs	r3, #0
   19b76:	77a3      	strb	r3, [r4, #30]
	if (instance->worker_trigger) {
   19b78:	7fe3      	ldrb	r3, [r4, #31]
   19b7a:	2b00      	cmp	r3, #0
   19b7c:	f000 8135 	beq.w	19dea <ticker_job+0x78a>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   19b80:	6a65      	ldr	r5, [r4, #36]	; 0x24
   19b82:	4623      	mov	r3, r4
   19b84:	2201      	movs	r2, #1
   19b86:	2103      	movs	r1, #3
   19b88:	e578      	b.n	1967c <ticker_job+0x1c>
		user = &users[count_user];
   19b8a:	9b00      	ldr	r3, [sp, #0]
   19b8c:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
   19b90:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
   19b94:	7873      	ldrb	r3, [r6, #1]
   19b96:	78f2      	ldrb	r2, [r6, #3]
   19b98:	429a      	cmp	r2, r3
   19b9a:	d102      	bne.n	19ba2 <ticker_job+0x542>
   19b9c:	3d01      	subs	r5, #1
   19b9e:	b2ed      	uxtb	r5, r5
   19ba0:	e7da      	b.n	19b58 <ticker_job+0x4f8>
			ticker_job_op_inquire(instance, &user_op[user->first]);
   19ba2:	2234      	movs	r2, #52	; 0x34
   19ba4:	fb13 f202 	smulbb	r2, r3, r2
   19ba8:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
   19bac:	f818 2002 	ldrb.w	r2, [r8, r2]
   19bb0:	2a02      	cmp	r2, #2
   19bb2:	d012      	beq.n	19bda <ticker_job+0x57a>
   19bb4:	2a03      	cmp	r2, #3
   19bb6:	d040      	beq.n	19c3a <ticker_job+0x5da>
   19bb8:	2a01      	cmp	r2, #1
   19bba:	d105      	bne.n	19bc8 <ticker_job+0x568>
			uop->status = TICKER_STATUS_SUCCESS;
   19bbc:	629f      	str	r7, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
   19bbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
   19bc0:	b112      	cbz	r2, 19bc8 <ticker_job+0x568>
		fp_op_func(uop->status, uop->op_context);
   19bc2:	6b19      	ldr	r1, [r3, #48]	; 0x30
   19bc4:	6a98      	ldr	r0, [r3, #40]	; 0x28
   19bc6:	4790      	blx	r2
			first = user->first + 1;
   19bc8:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
   19bca:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
   19bcc:	3301      	adds	r3, #1
   19bce:	b2db      	uxtb	r3, r3
				first = 0U;
   19bd0:	429a      	cmp	r2, r3
   19bd2:	bf08      	it	eq
   19bd4:	2300      	moveq	r3, #0
			user->first = first;
   19bd6:	7073      	strb	r3, [r6, #1]
   19bd8:	e7dc      	b.n	19b94 <ticker_job+0x534>
		ticker_by_next_slot_get(instance,
   19bda:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
   19bde:	f899 2000 	ldrb.w	r2, [r9]
		ticker_by_next_slot_get(instance,
   19be2:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
   19be6:	f8d4 c000 	ldr.w	ip, [r4]
	    (*ticks_current != instance->ticks_current)) {
   19bea:	6961      	ldr	r1, [r4, #20]
	if ((_ticker_id_head == TICKER_NULL) ||
   19bec:	2aff      	cmp	r2, #255	; 0xff
   19bee:	d003      	beq.n	19bf8 <ticker_job+0x598>
   19bf0:	f8d0 a000 	ldr.w	sl, [r0]
   19bf4:	4551      	cmp	r1, sl
   19bf6:	d009      	beq.n	19c0c <ticker_job+0x5ac>
		_ticker_id_head = instance->ticker_id_head;
   19bf8:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
   19bfa:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
   19bfc:	2000      	movs	r0, #0
	while (_ticker_id_head != TICKER_NULL) {
   19bfe:	2aff      	cmp	r2, #255	; 0xff
   19c00:	d10c      	bne.n	19c1c <ticker_job+0x5bc>
	*ticker_id_head = _ticker_id_head;
   19c02:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
   19c06:	f8ce 0000 	str.w	r0, [lr]
}
   19c0a:	e7d7      	b.n	19bbc <ticker_job+0x55c>
		ticker = &node[_ticker_id_head];
   19c0c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   19c10:	0112      	lsls	r2, r2, #4
	_ticks_to_expire = *ticks_to_expire;
   19c12:	f8de 0000 	ldr.w	r0, [lr]
		_ticker_id_head = ticker->next;
   19c16:	f81c 2002 	ldrb.w	r2, [ip, r2]
   19c1a:	e7f0      	b.n	19bfe <ticker_job+0x59e>
		ticker = &node[_ticker_id_head];
   19c1c:	eb02 0142 	add.w	r1, r2, r2, lsl #1
   19c20:	ea4f 1b01 	mov.w	fp, r1, lsl #4
   19c24:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
		_ticks_to_expire += ticker->ticks_to_expire;
   19c28:	f8d1 a008 	ldr.w	sl, [r1, #8]
			if (ticker->ticks_slot) {
   19c2c:	6989      	ldr	r1, [r1, #24]
		_ticks_to_expire += ticker->ticks_to_expire;
   19c2e:	4450      	add	r0, sl
			if (ticker->ticks_slot) {
   19c30:	2900      	cmp	r1, #0
   19c32:	d1e6      	bne.n	19c02 <ticker_job+0x5a2>
		_ticker_id_head = ticker->next;
   19c34:	f81c 200b 	ldrb.w	r2, [ip, fp]
   19c38:	e7e1      	b.n	19bfe <ticker_job+0x59e>
		if (uop->id < instance->count_node) {
   19c3a:	785a      	ldrb	r2, [r3, #1]
   19c3c:	7a21      	ldrb	r1, [r4, #8]
   19c3e:	4291      	cmp	r1, r2
   19c40:	d908      	bls.n	19c54 <ticker_job+0x5f4>
			node[uop->id].priority =
   19c42:	6821      	ldr	r1, [r4, #0]
   19c44:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   19c48:	eb01 1202 	add.w	r2, r1, r2, lsl #4
   19c4c:	7919      	ldrb	r1, [r3, #4]
   19c4e:	f882 102d 	strb.w	r1, [r2, #45]	; 0x2d
   19c52:	e7b3      	b.n	19bbc <ticker_job+0x55c>
			uop->status = TICKER_STATUS_FAILURE;
   19c54:	2201      	movs	r2, #1
   19c56:	629a      	str	r2, [r3, #40]	; 0x28
   19c58:	e7b1      	b.n	19bbe <ticker_job+0x55e>
	if (ticker_id_old_head == TICKER_NULL) {
   19c5a:	9b03      	ldr	r3, [sp, #12]
   19c5c:	2bff      	cmp	r3, #255	; 0xff
   19c5e:	d106      	bne.n	19c6e <ticker_job+0x60e>
		ticks_current = cntr_cnt_get();
   19c60:	f006 f8ba 	bl	1fdd8 <cntr_cnt_get>
   19c64:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
   19c66:	f006 f883 	bl	1fd70 <cntr_start>
   19c6a:	b900      	cbnz	r0, 19c6e <ticker_job+0x60e>
			instance->ticks_current = ticks_current;
   19c6c:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
   19c6e:	7f63      	ldrb	r3, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
   19c70:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
   19c72:	f8df 817c 	ldr.w	r8, [pc, #380]	; 19df0 <ticker_job+0x790>
   19c76:	f8df 917c 	ldr.w	r9, [pc, #380]	; 19df4 <ticker_job+0x794>
   19c7a:	f8df a17c 	ldr.w	sl, [pc, #380]	; 19df8 <ticker_job+0x798>
	ticker = &instance->nodes[instance->ticker_id_head];
   19c7e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	ticks_to_expire = ticker->ticks_to_expire;
   19c82:	eb02 1303 	add.w	r3, r2, r3, lsl #4
	i = 10U;
   19c86:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
   19c88:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
   19c8a:	f006 f8a5 	bl	1fdd8 <cntr_cnt_get>
		cc = instance->ticks_current;
   19c8e:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19c90:	1b43      	subs	r3, r0, r5
   19c92:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
   19c96:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
   19c98:	42bb      	cmp	r3, r7
   19c9a:	bf2c      	ite	cs
   19c9c:	18ed      	addcs	r5, r5, r3
   19c9e:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
   19ca0:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
   19ca4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		ctr = cntr_cnt_get();
   19ca6:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
   19ca8:	4628      	mov	r0, r5
   19caa:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
   19cac:	f006 f894 	bl	1fdd8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19cb0:	eba0 030b 	sub.w	r3, r0, fp
   19cb4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   19cb8:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
   19cbc:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19cbe:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
   19cc2:	42ab      	cmp	r3, r5
		i--;
   19cc4:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
   19cc8:	f67f af54 	bls.w	19b74 <ticker_job+0x514>
		LL_ASSERT(i);
   19ccc:	2e00      	cmp	r6, #0
   19cce:	d1dc      	bne.n	19c8a <ticker_job+0x62a>
   19cd0:	f640 133e 	movw	r3, #2366	; 0x93e
   19cd4:	4642      	mov	r2, r8
   19cd6:	4649      	mov	r1, r9
   19cd8:	4650      	mov	r0, sl
   19cda:	f00b fa6f 	bl	251bc <printk>
   19cde:	4040      	eors	r0, r0
   19ce0:	f380 8811 	msr	BASEPRI, r0
   19ce4:	f04f 0003 	mov.w	r0, #3
   19ce8:	df02      	svc	2
   19cea:	e7ce      	b.n	19c8a <ticker_job+0x62a>
	if (!pending) {
   19cec:	2b00      	cmp	r3, #0
   19cee:	f47f af37 	bne.w	19b60 <ticker_job+0x500>
		flag_compare_update = 1U;
   19cf2:	2301      	movs	r3, #1
   19cf4:	9302      	str	r3, [sp, #8]
   19cf6:	e729      	b.n	19b4c <ticker_job+0x4ec>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
   19cf8:	7f23      	ldrb	r3, [r4, #28]
   19cfa:	2bff      	cmp	r3, #255	; 0xff
   19cfc:	f47f ae9c 	bne.w	19a38 <ticker_job+0x3d8>
		window_start_ticks = 0U;
   19d00:	2300      	movs	r3, #0
   19d02:	e69f      	b.n	19a44 <ticker_job+0x3e4>
			if (state == 1U) {
   19d04:	2b01      	cmp	r3, #1
   19d06:	f43f ada8 	beq.w	1985a <ticker_job+0x1fa>
				instance->sched_cb(TICKER_CALL_ID_JOB,
   19d0a:	2104      	movs	r1, #4
   19d0c:	4623      	mov	r3, r4
   19d0e:	6a65      	ldr	r5, [r4, #36]	; 0x24
   19d10:	2201      	movs	r2, #1
   19d12:	4608      	mov	r0, r1
   19d14:	47a8      	blx	r5
				pending = 1U;
   19d16:	2301      	movs	r3, #1
				user->middle = prev;
   19d18:	f888 7002 	strb.w	r7, [r8, #2]
				pending = 1U;
   19d1c:	9305      	str	r3, [sp, #20]
   19d1e:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   19d22:	fa5f fb83 	uxtb.w	fp, r3
   19d26:	e4d6      	b.n	196d6 <ticker_job+0x76>
			if (state == 1U) {
   19d28:	2b01      	cmp	r3, #1
   19d2a:	d1ee      	bne.n	19d0a <ticker_job+0x6aa>
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   19d2c:	4620      	mov	r0, r4
   19d2e:	f010 fdfc 	bl	2a92a <ticker_dequeue>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
   19d32:	6963      	ldr	r3, [r4, #20]
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   19d34:	60a8      	str	r0, [r5, #8]
   19d36:	4607      	mov	r7, r0
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
   19d38:	9307      	str	r3, [sp, #28]
	ticks_now = cntr_cnt_get();
   19d3a:	f006 f84d 	bl	1fdd8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19d3e:	9b07      	ldr	r3, [sp, #28]
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   19d40:	9900      	ldr	r1, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   19d42:	1ac3      	subs	r3, r0, r3
   19d44:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   19d48:	440b      	add	r3, r1
	if (ticks_to_expire > ticks_elapsed) {
   19d4a:	429f      	cmp	r7, r3
		ticker->ticks_to_expire_minus += ticks_elapsed -
   19d4c:	bf98      	it	ls
   19d4e:	6969      	ldrls	r1, [r5, #20]
	ticks_now = cntr_cnt_get();
   19d50:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
   19d52:	bf98      	it	ls
   19d54:	1bc9      	subls	r1, r1, r7
	if ((ticker->ticks_periodic != 0U) &&
   19d56:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
   19d58:	bf9b      	ittet	ls
   19d5a:	185b      	addls	r3, r3, r1
   19d5c:	616b      	strls	r3, [r5, #20]
		ticks_to_expire -= ticks_elapsed;
   19d5e:	1afb      	subhi	r3, r7, r3
		ticks_to_expire = 0U;
   19d60:	2300      	movls	r3, #0
	if ((ticker->ticks_periodic != 0U) &&
   19d62:	b1a8      	cbz	r0, 19d90 <ticker_job+0x730>
	    (user_op->params.update.lazy != 0U)) {
   19d64:	8ab1      	ldrh	r1, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
   19d66:	b199      	cbz	r1, 19d90 <ticker_job+0x730>
		user_op->params.update.lazy--;
   19d68:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
   19d6c:	fa1f fc8c 	uxth.w	ip, ip
   19d70:	f8a6 c014 	strh.w	ip, [r6, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   19d74:	4298      	cmp	r0, r3
		       (ticker->lazy_current > user_op->params.update.lazy)) {
   19d76:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
   19d7a:	d202      	bcs.n	19d82 <ticker_job+0x722>
   19d7c:	45e6      	cmp	lr, ip
   19d7e:	f63f ad32 	bhi.w	197e6 <ticker_job+0x186>
		while (ticker->lazy_current < user_op->params.update.lazy) {
   19d82:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
   19d86:	45f4      	cmp	ip, lr
   19d88:	f63f ad4c 	bhi.w	19824 <ticker_job+0x1c4>
		ticker->lazy_periodic = user_op->params.update.lazy;
   19d8c:	f8a5 c01c 	strh.w	ip, [r5, #28]
				  user_op->params.update.ticks_drift_plus;
   19d90:	6871      	ldr	r1, [r6, #4]
				user_op->params.update.ticks_drift_minus;
   19d92:	68b0      	ldr	r0, [r6, #8]
	struct ticker_ext *ext_data = ticker->ext_data;
   19d94:	6aaf      	ldr	r7, [r5, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
   19d96:	440b      	add	r3, r1
   19d98:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
   19d9a:	696b      	ldr	r3, [r5, #20]
   19d9c:	4403      	add	r3, r0
   19d9e:	616b      	str	r3, [r5, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
   19da0:	b11f      	cbz	r7, 19daa <ticker_job+0x74a>
   19da2:	683b      	ldr	r3, [r7, #0]
   19da4:	b10b      	cbz	r3, 19daa <ticker_job+0x74a>
			user_op->params.update.ticks_drift_plus -
   19da6:	1a09      	subs	r1, r1, r0
		ext_data->ticks_drift =
   19da8:	6079      	str	r1, [r7, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   19daa:	9907      	ldr	r1, [sp, #28]
   19dac:	4628      	mov	r0, r5
   19dae:	f010 fde7 	bl	2a980 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
   19db2:	68f2      	ldr	r2, [r6, #12]
   19db4:	69ab      	ldr	r3, [r5, #24]
   19db6:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
   19db8:	6932      	ldr	r2, [r6, #16]
   19dba:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
   19dbc:	bf8c      	ite	hi
   19dbe:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
   19dc0:	2300      	movls	r3, #0
   19dc2:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
   19dc4:	7db3      	ldrb	r3, [r6, #22]
   19dc6:	b103      	cbz	r3, 19dca <ticker_job+0x76a>
		ticker->force = user_op->params.update.force;
   19dc8:	70eb      	strb	r3, [r5, #3]
	if (user_op->params.update.must_expire) {
   19dca:	7df3      	ldrb	r3, [r6, #23]
   19dcc:	b113      	cbz	r3, 19dd4 <ticker_job+0x774>
		ticker->must_expire = (user_op->params.update.must_expire - 1);
   19dce:	3b01      	subs	r3, #1
   19dd0:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
	ticker->next = *insert_head;
   19dd4:	9b02      	ldr	r3, [sp, #8]
   19dd6:	9a09      	ldr	r2, [sp, #36]	; 0x24
   19dd8:	f803 9002 	strb.w	r9, [r3, r2]
		ticker->req++;
   19ddc:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
   19dde:	f896 9001 	ldrb.w	r9, [r6, #1]
		ticker->req++;
   19de2:	3301      	adds	r3, #1
   19de4:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   19de6:	2100      	movs	r1, #0
   19de8:	e4f9      	b.n	197de <ticker_job+0x17e>
}
   19dea:	b00b      	add	sp, #44	; 0x2c
   19dec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19df0:	00033cfb 	.word	0x00033cfb
   19df4:	00033fa2 	.word	0x00033fa2
   19df8:	0002f8b5 	.word	0x0002f8b5

00019dfc <ticker_init>:
{
   19dfc:	b5f0      	push	{r4, r5, r6, r7, lr}
   19dfe:	9f05      	ldr	r7, [sp, #20]
   19e00:	f89d 5018 	ldrb.w	r5, [sp, #24]
   19e04:	f8dd c01c 	ldr.w	ip, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
   19e08:	b108      	cbz	r0, 19e0e <ticker_init+0x12>
		return TICKER_STATUS_FAILURE;
   19e0a:	2001      	movs	r0, #1
}
   19e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
   19e0e:	4c18      	ldr	r4, [pc, #96]	; (19e70 <ticker_init+0x74>)
   19e10:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
   19e12:	6022      	str	r2, [r4, #0]
	while (count_node--) {
   19e14:	3901      	subs	r1, #1
   19e16:	b2c9      	uxtb	r1, r1
   19e18:	29ff      	cmp	r1, #255	; 0xff
   19e1a:	d116      	bne.n	19e4a <ticker_init+0x4e>
	instance->count_user = count_user;
   19e1c:	7263      	strb	r3, [r4, #9]
	instance->users = user;
   19e1e:	6067      	str	r7, [r4, #4]
		user_op_ += users[count_user].count_user_op;
   19e20:	2234      	movs	r2, #52	; 0x34
	while (count_user--) {
   19e22:	3b01      	subs	r3, #1
   19e24:	b2db      	uxtb	r3, r3
   19e26:	2bff      	cmp	r3, #255	; 0xff
   19e28:	d116      	bne.n	19e58 <ticker_init+0x5c>
	if (count_op) {
   19e2a:	2d00      	cmp	r5, #0
   19e2c:	d1ed      	bne.n	19e0a <ticker_init+0xe>
	instance->caller_id_get_cb = caller_id_get_cb;
   19e2e:	9b08      	ldr	r3, [sp, #32]
   19e30:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
   19e32:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19e34:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
   19e36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   19e38:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
   19e3a:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
   19e3e:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
   19e42:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
   19e44:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
   19e46:	4628      	mov	r0, r5
   19e48:	e7e0      	b.n	19e0c <ticker_init+0x10>
		instance->nodes[count_node].priority = 0;
   19e4a:	eb01 0641 	add.w	r6, r1, r1, lsl #1
   19e4e:	eb02 1606 	add.w	r6, r2, r6, lsl #4
   19e52:	f886 002d 	strb.w	r0, [r6, #45]	; 0x2d
   19e56:	e7dd      	b.n	19e14 <ticker_init+0x18>
		users[count_user].user_op = user_op_;
   19e58:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
   19e5c:	f8c1 c004 	str.w	ip, [r1, #4]
		user_op_ += users[count_user].count_user_op;
   19e60:	f817 0033 	ldrb.w	r0, [r7, r3, lsl #3]
		count_op -= users[count_user].count_user_op;
   19e64:	1a2d      	subs	r5, r5, r0
		user_op_ += users[count_user].count_user_op;
   19e66:	fb00 cc02 	mla	ip, r0, r2, ip
		count_op -= users[count_user].count_user_op;
   19e6a:	b2ed      	uxtb	r5, r5
   19e6c:	e7d9      	b.n	19e22 <ticker_init+0x26>
   19e6e:	bf00      	nop
   19e70:	20002a0c 	.word	0x20002a0c

00019e74 <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
   19e74:	4b04      	ldr	r3, [pc, #16]	; (19e88 <ticker_is_initialized+0x14>)
   19e76:	222c      	movs	r2, #44	; 0x2c
   19e78:	fb02 3300 	mla	r3, r2, r0, r3
   19e7c:	7a18      	ldrb	r0, [r3, #8]
}
   19e7e:	3800      	subs	r0, #0
   19e80:	bf18      	it	ne
   19e82:	2001      	movne	r0, #1
   19e84:	4770      	bx	lr
   19e86:	bf00      	nop
   19e88:	20002a0c 	.word	0x20002a0c

00019e8c <ticker_trigger>:
	if (instance->sched_cb) {
   19e8c:	4b07      	ldr	r3, [pc, #28]	; (19eac <ticker_trigger+0x20>)
   19e8e:	222c      	movs	r2, #44	; 0x2c
   19e90:	fb02 3100 	mla	r1, r2, r0, r3
{
   19e94:	b410      	push	{r4}
	if (instance->sched_cb) {
   19e96:	6a4c      	ldr	r4, [r1, #36]	; 0x24
   19e98:	b134      	cbz	r4, 19ea8 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   19e9a:	460b      	mov	r3, r1
   19e9c:	46a4      	mov	ip, r4
   19e9e:	2201      	movs	r2, #1
}
   19ea0:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   19ea2:	2103      	movs	r1, #3
   19ea4:	2002      	movs	r0, #2
   19ea6:	4760      	bx	ip
}
   19ea8:	bc10      	pop	{r4}
   19eaa:	4770      	bx	lr
   19eac:	20002a0c 	.word	0x20002a0c

00019eb0 <ticker_start_ext>:
{
   19eb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19eb4:	4606      	mov	r6, r0
   19eb6:	4608      	mov	r0, r1
   19eb8:	4611      	mov	r1, r2
   19eba:	461a      	mov	r2, r3
	struct ticker_instance *instance = &_instance[instance_index];
   19ebc:	4b22      	ldr	r3, [pc, #136]	; (19f48 <ticker_start_ext+0x98>)
   19ebe:	242c      	movs	r4, #44	; 0x2c
   19ec0:	fb06 3904 	mla	r9, r6, r4, r3
	user = &instance->users[user_id];
   19ec4:	f8d9 3004 	ldr.w	r3, [r9, #4]
   19ec8:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
	if (last >= user->count_user_op) {
   19ecc:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
   19ed0:	f89c 7003 	ldrb.w	r7, [ip, #3]
   19ed4:	1c7d      	adds	r5, r7, #1
   19ed6:	b2ed      	uxtb	r5, r5
		last = 0U;
   19ed8:	42ab      	cmp	r3, r5
   19eda:	bf98      	it	ls
   19edc:	2500      	movls	r5, #0
	if (last == user->first) {
   19ede:	f89c 3001 	ldrb.w	r3, [ip, #1]
   19ee2:	42ab      	cmp	r3, r5
   19ee4:	d02e      	beq.n	19f44 <ticker_start_ext+0x94>
	user_op = &user->user_op[user->last];
   19ee6:	2334      	movs	r3, #52	; 0x34
   19ee8:	fb17 f703 	smulbb	r7, r7, r3
   19eec:	f8dc 3004 	ldr.w	r3, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_START;
   19ef0:	f04f 0804 	mov.w	r8, #4
	user_op = &user->user_op[user->last];
   19ef4:	19dc      	adds	r4, r3, r7
	user_op->op = TICKER_USER_OP_TYPE_START;
   19ef6:	f803 8007 	strb.w	r8, [r3, r7]
	user_op->params.start.ticks_first = ticks_first;
   19efa:	9b08      	ldr	r3, [sp, #32]
   19efc:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
   19efe:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19f00:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
   19f02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   19f04:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
   19f06:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   19f08:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
   19f0a:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   19f0e:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.ext_data = ext_data;
   19f10:	9b11      	ldr	r3, [sp, #68]	; 0x44
   19f12:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
   19f14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   19f16:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
   19f18:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   19f1a:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
   19f1c:	2302      	movs	r3, #2
   19f1e:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
   19f20:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   19f22:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
   19f24:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
   19f26:	7061      	strb	r1, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
   19f28:	6062      	str	r2, [r4, #4]
	user_op->op_context = op_context;
   19f2a:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
   19f2c:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   19f30:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
   19f34:	4798      	blx	r3
   19f36:	464b      	mov	r3, r9
   19f38:	2200      	movs	r2, #0
   19f3a:	4641      	mov	r1, r8
   19f3c:	47a8      	blx	r5
	return user_op->status;
   19f3e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
   19f40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   19f44:	2001      	movs	r0, #1
   19f46:	e7fb      	b.n	19f40 <ticker_start_ext+0x90>
   19f48:	20002a0c 	.word	0x20002a0c

00019f4c <ticker_update_ext>:
{
   19f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   19f50:	4c23      	ldr	r4, [pc, #140]	; (19fe0 <ticker_update_ext+0x94>)
{
   19f52:	4606      	mov	r6, r0
   19f54:	4608      	mov	r0, r1
   19f56:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
   19f58:	222c      	movs	r2, #44	; 0x2c
   19f5a:	fb06 4802 	mla	r8, r6, r2, r4
	user = &instance->users[user_id];
   19f5e:	f8d8 4004 	ldr.w	r4, [r8, #4]
   19f62:	eb04 0cc0 	add.w	ip, r4, r0, lsl #3
	if (last >= user->count_user_op) {
   19f66:	f814 2030 	ldrb.w	r2, [r4, r0, lsl #3]
	last = user->last + 1;
   19f6a:	f89c 7003 	ldrb.w	r7, [ip, #3]
   19f6e:	1c7d      	adds	r5, r7, #1
   19f70:	b2ed      	uxtb	r5, r5
		last = 0U;
   19f72:	42aa      	cmp	r2, r5
   19f74:	bf98      	it	ls
   19f76:	2500      	movls	r5, #0
	if (last == user->first) {
   19f78:	f89c 2001 	ldrb.w	r2, [ip, #1]
   19f7c:	42aa      	cmp	r2, r5
   19f7e:	d02c      	beq.n	19fda <ticker_update_ext+0x8e>
	user_op = &user->user_op[user->last];
   19f80:	2234      	movs	r2, #52	; 0x34
   19f82:	fb17 f702 	smulbb	r7, r7, r2
   19f86:	f8dc 2004 	ldr.w	r2, [ip, #4]
   19f8a:	19d4      	adds	r4, r2, r7
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   19f8c:	f04f 0e05 	mov.w	lr, #5
   19f90:	f802 e007 	strb.w	lr, [r2, r7]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
   19f94:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
   19f96:	9b06      	ldr	r3, [sp, #24]
   19f98:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
   19f9a:	9b07      	ldr	r3, [sp, #28]
   19f9c:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
   19f9e:	9b08      	ldr	r3, [sp, #32]
   19fa0:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
   19fa2:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   19fa6:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
   19fa8:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   19fac:	75a3      	strb	r3, [r4, #22]
	user_op->params.update.must_expire = must_expire;
   19fae:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   19fb2:	75e3      	strb	r3, [r4, #23]
	user_op->status = TICKER_STATUS_BUSY;
   19fb4:	2302      	movs	r3, #2
   19fb6:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
   19fb8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   19fba:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
   19fbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
   19fbe:	7061      	strb	r1, [r4, #1]
	user_op->op_context = op_context;
   19fc0:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
   19fc2:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   19fc6:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
   19fca:	4798      	blx	r3
   19fcc:	4643      	mov	r3, r8
   19fce:	2200      	movs	r2, #0
   19fd0:	2104      	movs	r1, #4
   19fd2:	47a8      	blx	r5
	return user_op->status;
   19fd4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
   19fd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   19fda:	2001      	movs	r0, #1
   19fdc:	e7fb      	b.n	19fd6 <ticker_update_ext+0x8a>
   19fde:	bf00      	nop
   19fe0:	20002a0c 	.word	0x20002a0c

00019fe4 <ticker_stop>:
{
   19fe4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   19fe8:	4c1a      	ldr	r4, [pc, #104]	; (1a054 <ticker_stop+0x70>)
{
   19fea:	4605      	mov	r5, r0
   19fec:	4608      	mov	r0, r1
   19fee:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
   19ff0:	222c      	movs	r2, #44	; 0x2c
   19ff2:	fb05 4902 	mla	r9, r5, r2, r4
	user = &instance->users[user_id];
   19ff6:	f8d9 2004 	ldr.w	r2, [r9, #4]
   19ffa:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
	if (last >= user->count_user_op) {
   19ffe:	f812 2030 	ldrb.w	r2, [r2, r0, lsl #3]
	last = user->last + 1;
   1a002:	78fe      	ldrb	r6, [r7, #3]
   1a004:	1c74      	adds	r4, r6, #1
   1a006:	b2e4      	uxtb	r4, r4
		last = 0U;
   1a008:	42a2      	cmp	r2, r4
   1a00a:	bf98      	it	ls
   1a00c:	2400      	movls	r4, #0
	if (last == user->first) {
   1a00e:	787a      	ldrb	r2, [r7, #1]
   1a010:	42a2      	cmp	r2, r4
   1a012:	d01d      	beq.n	1a050 <ticker_stop+0x6c>
	user_op = &user->user_op[user->last];
   1a014:	2234      	movs	r2, #52	; 0x34
   1a016:	fb16 f602 	smulbb	r6, r6, r2
   1a01a:	687a      	ldr	r2, [r7, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP;
   1a01c:	f04f 0c07 	mov.w	ip, #7
   1a020:	f802 c006 	strb.w	ip, [r2, r6]
	user_op = &user->user_op[user->last];
   1a024:	eb02 0806 	add.w	r8, r2, r6
	user_op->status = TICKER_STATUS_BUSY;
   1a028:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
   1a02a:	e9c8 230a 	strd	r2, r3, [r8, #40]	; 0x28
	user_op->op_context = op_context;
   1a02e:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
   1a030:	f888 1001 	strb.w	r1, [r8, #1]
	user_op->op_context = op_context;
   1a034:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
	user->last = last;
   1a038:	70fc      	strb	r4, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   1a03a:	e9d9 3408 	ldrd	r3, r4, [r9, #32]
   1a03e:	4798      	blx	r3
   1a040:	464b      	mov	r3, r9
   1a042:	2200      	movs	r2, #0
   1a044:	2104      	movs	r1, #4
   1a046:	47a0      	blx	r4
	return user_op->status;
   1a048:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
}
   1a04c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   1a050:	2001      	movs	r0, #1
   1a052:	e7fb      	b.n	1a04c <ticker_stop+0x68>
   1a054:	20002a0c 	.word	0x20002a0c

0001a058 <ll_addr_set>:

static uint8_t pub_addr[BDADDR_SIZE];
static uint8_t rnd_addr[BDADDR_SIZE];

uint8_t ll_addr_set(uint8_t addr_type, uint8_t const *const bdaddr)
{
   1a058:	b570      	push	{r4, r5, r6, lr}
   1a05a:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
#else /* !CONFIG_BT_CTLR_ADV_EXT */
		if (ull_adv_is_enabled(0)) {
   1a05c:	2000      	movs	r0, #0
{
   1a05e:	460d      	mov	r5, r1
		if (ull_adv_is_enabled(0)) {
   1a060:	f011 f814 	bl	2b08c <ull_adv_is_enabled>
   1a064:	b110      	cbz	r0, 1a06c <ll_addr_set+0x14>
#endif /* !CONFIG_BT_CTLR_ADV_EXT */
			return BT_HCI_ERR_CMD_DISALLOWED;
   1a066:	240c      	movs	r4, #12
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
}
   1a068:	4620      	mov	r0, r4
   1a06a:	bd70      	pop	{r4, r5, r6, pc}
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
   1a06c:	f011 f903 	bl	2b276 <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
   1a070:	f010 0606 	ands.w	r6, r0, #6
   1a074:	d1f7      	bne.n	1a066 <ll_addr_set+0xe>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   1a076:	2206      	movs	r2, #6
   1a078:	4629      	mov	r1, r5
	if (addr_type) {
   1a07a:	b124      	cbz	r4, 1a086 <ll_addr_set+0x2e>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   1a07c:	4804      	ldr	r0, [pc, #16]	; (1a090 <ll_addr_set+0x38>)
   1a07e:	f00d fbf7 	bl	27870 <memcpy>
	return 0;
   1a082:	4634      	mov	r4, r6
   1a084:	e7f0      	b.n	1a068 <ll_addr_set+0x10>
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   1a086:	4803      	ldr	r0, [pc, #12]	; (1a094 <ll_addr_set+0x3c>)
   1a088:	f00d fbf2 	bl	27870 <memcpy>
   1a08c:	e7ec      	b.n	1a068 <ll_addr_set+0x10>
   1a08e:	bf00      	nop
   1a090:	20003af9 	.word	0x20003af9
   1a094:	20003af3 	.word	0x20003af3

0001a098 <ll_addr_get>:

uint8_t *ll_addr_get(uint8_t addr_type)
{
	if (addr_type > BT_ADDR_LE_RANDOM) {
   1a098:	2801      	cmp	r0, #1
{
   1a09a:	4602      	mov	r2, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
   1a09c:	d805      	bhi.n	1a0aa <ll_addr_get+0x12>
		return NULL;
	}

	if (addr_type) {
		return rnd_addr;
   1a09e:	4b04      	ldr	r3, [pc, #16]	; (1a0b0 <ll_addr_get+0x18>)
   1a0a0:	4804      	ldr	r0, [pc, #16]	; (1a0b4 <ll_addr_get+0x1c>)
   1a0a2:	2a00      	cmp	r2, #0
   1a0a4:	bf08      	it	eq
   1a0a6:	4618      	moveq	r0, r3
   1a0a8:	4770      	bx	lr
		return NULL;
   1a0aa:	2000      	movs	r0, #0
	}

	return pub_addr;
}
   1a0ac:	4770      	bx	lr
   1a0ae:	bf00      	nop
   1a0b0:	20003af3 	.word	0x20003af3
   1a0b4:	20003af9 	.word	0x20003af9

0001a0b8 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(const struct device *unused)
{
   1a0b8:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
   1a0ba:	4802      	ldr	r0, [pc, #8]	; (1a0c4 <hci_driver_init+0xc>)
   1a0bc:	f7ec fc5e 	bl	697c <bt_hci_driver_register>

	return 0;
}
   1a0c0:	2000      	movs	r0, #0
   1a0c2:	bd08      	pop	{r3, pc}
   1a0c4:	0002e834 	.word	0x0002e834

0001a0c8 <recv_thread>:
{
   1a0c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
   1a0ca:	4e2f      	ldr	r6, [pc, #188]	; (1a188 <recv_thread+0xc0>)
	struct net_buf *buf = NULL;
   1a0cc:	2700      	movs	r7, #0
   1a0ce:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a0d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a0d6:	4630      	mov	r0, r6
   1a0d8:	f009 ff08 	bl	23eec <z_impl_k_queue_get>
		if (node_rx && !buf) {
   1a0dc:	2800      	cmp	r0, #0
   1a0de:	d0f6      	beq.n	1a0ce <recv_thread+0x6>
	uint8_t class = node_rx->hdr.user_meta;
   1a0e0:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   1a0e2:	9001      	str	r0, [sp, #4]
	switch (class) {
   1a0e4:	2b04      	cmp	r3, #4
   1a0e6:	d826      	bhi.n	1a136 <recv_thread+0x6e>
   1a0e8:	b33b      	cbz	r3, 1a13a <recv_thread+0x72>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
   1a0ea:	2b02      	cmp	r3, #2
   1a0ec:	d134      	bne.n	1a158 <recv_thread+0x90>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
   1a0ee:	2200      	movs	r2, #0
   1a0f0:	2300      	movs	r3, #0
   1a0f2:	2101      	movs	r1, #1
   1a0f4:	2000      	movs	r0, #0
   1a0f6:	f7eb fc51 	bl	599c <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1a0fa:	4604      	mov	r4, r0
		if (buf) {
   1a0fc:	b118      	cbz	r0, 1a106 <recv_thread+0x3e>
			hci_evt_encode(node_rx, buf);
   1a0fe:	4601      	mov	r1, r0
   1a100:	9801      	ldr	r0, [sp, #4]
   1a102:	f000 fd9d 	bl	1ac40 <hci_evt_encode>
	node_rx->hdr.next = NULL;
   1a106:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
   1a108:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
   1a10a:	601f      	str	r7, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   1a10c:	f001 f9a6 	bl	1b45c <ll_rx_mem_release>
		while (buf) {
   1a110:	2c00      	cmp	r4, #0
   1a112:	d0dc      	beq.n	1a0ce <recv_thread+0x6>
			frag = net_buf_ref(buf);
   1a114:	4620      	mov	r0, r4
   1a116:	f011 fdd9 	bl	2bccc <net_buf_ref>
			buf = net_buf_frag_del(NULL, buf);
   1a11a:	4621      	mov	r1, r4
			frag = net_buf_ref(buf);
   1a11c:	4605      	mov	r5, r0
			buf = net_buf_frag_del(NULL, buf);
   1a11e:	2000      	movs	r0, #0
   1a120:	f011 fdfa 	bl	2bd18 <net_buf_frag_del>
			if (frag->len) {
   1a124:	89ab      	ldrh	r3, [r5, #12]
			buf = net_buf_frag_del(NULL, buf);
   1a126:	4604      	mov	r4, r0
				bt_recv(frag);
   1a128:	4628      	mov	r0, r5
			if (frag->len) {
   1a12a:	b353      	cbz	r3, 1a182 <recv_thread+0xba>
				bt_recv(frag);
   1a12c:	f7ec fb4c 	bl	67c8 <bt_recv>
	z_impl_k_yield();
   1a130:	f00a fb6c 	bl	2480c <z_impl_k_yield>
}
   1a134:	e7ec      	b.n	1a110 <recv_thread+0x48>
	switch (class) {
   1a136:	2b05      	cmp	r3, #5
   1a138:	d016      	beq.n	1a168 <recv_thread+0xa0>
		LL_ASSERT(0);
   1a13a:	4a14      	ldr	r2, [pc, #80]	; (1a18c <recv_thread+0xc4>)
   1a13c:	4914      	ldr	r1, [pc, #80]	; (1a190 <recv_thread+0xc8>)
   1a13e:	4815      	ldr	r0, [pc, #84]	; (1a194 <recv_thread+0xcc>)
   1a140:	f44f 73cd 	mov.w	r3, #410	; 0x19a
   1a144:	f00b f83a 	bl	251bc <printk>
   1a148:	4040      	eors	r0, r0
   1a14a:	f380 8811 	msr	BASEPRI, r0
   1a14e:	f04f 0003 	mov.w	r0, #3
   1a152:	df02      	svc	2
	struct net_buf *buf = NULL;
   1a154:	2400      	movs	r4, #0
		break;
   1a156:	e7d6      	b.n	1a106 <recv_thread+0x3e>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1a158:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a15c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a160:	2001      	movs	r0, #1
   1a162:	f7eb fbf1 	bl	5948 <bt_buf_get_rx>
   1a166:	e7c8      	b.n	1a0fa <recv_thread+0x32>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   1a168:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a16c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a170:	2003      	movs	r0, #3
   1a172:	f7eb fbe9 	bl	5948 <bt_buf_get_rx>
   1a176:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
   1a178:	4601      	mov	r1, r0
   1a17a:	9801      	ldr	r0, [sp, #4]
   1a17c:	f000 fd26 	bl	1abcc <hci_acl_encode>
		break;
   1a180:	e7c1      	b.n	1a106 <recv_thread+0x3e>
				net_buf_unref(frag);
   1a182:	f006 fb87 	bl	20894 <net_buf_unref>
   1a186:	e7d3      	b.n	1a130 <recv_thread+0x68>
   1a188:	20000f74 	.word	0x20000f74
   1a18c:	00033d49 	.word	0x00033d49
   1a190:	00031059 	.word	0x00031059
   1a194:	0002f8b5 	.word	0x0002f8b5

0001a198 <prio_recv_thread>:
{
   1a198:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return z_impl_k_sem_take(sem, timeout);
   1a19c:	4e2b      	ldr	r6, [pc, #172]	; (1a24c <prio_recv_thread+0xb4>)
				k_fifo_put(&recv_fifo, node_rx);
   1a19e:	4f2c      	ldr	r7, [pc, #176]	; (1a250 <prio_recv_thread+0xb8>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   1a1a0:	f10d 0102 	add.w	r1, sp, #2
   1a1a4:	a801      	add	r0, sp, #4
   1a1a6:	f001 f857 	bl	1b258 <ll_rx_get>
   1a1aa:	4604      	mov	r4, r0
   1a1ac:	2800      	cmp	r0, #0
   1a1ae:	d139      	bne.n	1a224 <prio_recv_thread+0x8c>
		if (node_rx) {
   1a1b0:	9b01      	ldr	r3, [sp, #4]
   1a1b2:	b37b      	cbz	r3, 1a214 <prio_recv_thread+0x7c>
			ll_rx_dequeue();
   1a1b4:	f001 f8aa 	bl	1b30c <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   1a1b8:	9d01      	ldr	r5, [sp, #4]
   1a1ba:	4628      	mov	r0, r5
   1a1bc:	f000 feda 	bl	1af74 <hci_get_class>
   1a1c0:	7168      	strb	r0, [r5, #5]
			buf = process_prio_evt(node_rx, &evt_flags);
   1a1c2:	9d01      	ldr	r5, [sp, #4]
	if (node_rx->hdr.user_meta == HCI_CLASS_EVT_CONNECTION) {
   1a1c4:	796b      	ldrb	r3, [r5, #5]
   1a1c6:	2b03      	cmp	r3, #3
   1a1c8:	d11d      	bne.n	1a206 <prio_recv_thread+0x6e>
		if (node_rx->hdr.type == NODE_RX_TYPE_TERMINATE) {
   1a1ca:	792b      	ldrb	r3, [r5, #4]
   1a1cc:	2b17      	cmp	r3, #23
   1a1ce:	d11a      	bne.n	1a206 <prio_recv_thread+0x6e>
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   1a1d0:	4621      	mov	r1, r4
   1a1d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a1d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a1da:	2005      	movs	r0, #5
		handle = node_rx->hdr.handle;
   1a1dc:	f8b5 8006 	ldrh.w	r8, [r5, #6]
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   1a1e0:	f7eb fbdc 	bl	599c <bt_buf_get_evt>
			hci_disconn_complete_encode(pdu_data, handle, buf);
   1a1e4:	4641      	mov	r1, r8
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
   1a1e6:	4604      	mov	r4, r0
			hci_disconn_complete_encode(pdu_data, handle, buf);
   1a1e8:	4602      	mov	r2, r0
   1a1ea:	f105 001c 	add.w	r0, r5, #28
   1a1ee:	f000 fcc7 	bl	1ab80 <hci_disconn_complete_encode>
			hci_disconn_complete_process(handle);
   1a1f2:	4640      	mov	r0, r8
   1a1f4:	f000 fce2 	bl	1abbc <hci_disconn_complete_process>
			if (buf) {
   1a1f8:	b12c      	cbz	r4, 1a206 <prio_recv_thread+0x6e>
				bt_recv_prio(buf);
   1a1fa:	4620      	mov	r0, r4
   1a1fc:	f7ec fba0 	bl	6940 <bt_recv_prio>
					net_buf_unref(buf);
   1a200:	4620      	mov	r0, r4
   1a202:	f006 fb47 	bl	20894 <net_buf_unref>
				k_fifo_put(&recv_fifo, node_rx);
   1a206:	9901      	ldr	r1, [sp, #4]
   1a208:	4638      	mov	r0, r7
   1a20a:	f012 fce7 	bl	2cbdc <k_queue_append>
		if (iso_received || node_rx) {
   1a20e:	9b01      	ldr	r3, [sp, #4]
   1a210:	2b00      	cmp	r3, #0
   1a212:	d1c5      	bne.n	1a1a0 <prio_recv_thread+0x8>
   1a214:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a218:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a21c:	4630      	mov	r0, r6
   1a21e:	f009 febf 	bl	23fa0 <z_impl_k_sem_take>
		BT_DBG("sem taken");
   1a222:	e7bd      	b.n	1a1a0 <prio_recv_thread+0x8>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   1a224:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a228:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1a22c:	2100      	movs	r1, #0
   1a22e:	2013      	movs	r0, #19
   1a230:	f7eb fbb4 	bl	599c <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   1a234:	f8bd 1002 	ldrh.w	r1, [sp, #2]
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   1a238:	4605      	mov	r5, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   1a23a:	4622      	mov	r2, r4
   1a23c:	f010 fe4e 	bl	2aedc <hci_num_cmplt_encode>
			bt_recv_prio(buf);
   1a240:	4628      	mov	r0, r5
   1a242:	f7ec fb7d 	bl	6940 <bt_recv_prio>
	z_impl_k_yield();
   1a246:	f00a fae1 	bl	2480c <z_impl_k_yield>
   1a24a:	e7a9      	b.n	1a1a0 <prio_recv_thread+0x8>
   1a24c:	20000f2c 	.word	0x20000f2c
   1a250:	20000f74 	.word	0x20000f74

0001a254 <hci_driver_open>:
{
   1a254:	b5d0      	push	{r4, r6, r7, lr}
	err = ll_init(&sem_prio_recv);
   1a256:	4821      	ldr	r0, [pc, #132]	; (1a2dc <hci_driver_open+0x88>)
{
   1a258:	b090      	sub	sp, #64	; 0x40
	err = ll_init(&sem_prio_recv);
   1a25a:	f001 fd5f 	bl	1bd1c <ll_init>
	if (err) {
   1a25e:	4604      	mov	r4, r0
   1a260:	b178      	cbz	r0, 1a282 <hci_driver_open+0x2e>
		BT_ERR("LL initialization failed: %d", err);
   1a262:	4b1f      	ldr	r3, [pc, #124]	; (1a2e0 <hci_driver_open+0x8c>)
   1a264:	e9cd 300e 	strd	r3, r0, [sp, #56]	; 0x38
   1a268:	2303      	movs	r3, #3
   1a26a:	9309      	str	r3, [sp, #36]	; 0x24
   1a26c:	930d      	str	r3, [sp, #52]	; 0x34
   1a26e:	481d      	ldr	r0, [pc, #116]	; (1a2e4 <hci_driver_open+0x90>)
   1a270:	2300      	movs	r3, #0
   1a272:	aa0d      	add	r2, sp, #52	; 0x34
   1a274:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   1a278:	f00b fd2e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   1a27c:	4620      	mov	r0, r4
   1a27e:	b010      	add	sp, #64	; 0x40
   1a280:	bdd0      	pop	{r4, r6, r7, pc}
	hci_init(NULL);
   1a282:	f000 fe8d 	bl	1afa0 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
   1a286:	2600      	movs	r6, #0
   1a288:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1a28a:	f06f 0309 	mvn.w	r3, #9
   1a28e:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1a292:	e9cd 6706 	strd	r6, r7, [sp, #24]
   1a296:	e9cd 4400 	strd	r4, r4, [sp]
   1a29a:	4b13      	ldr	r3, [pc, #76]	; (1a2e8 <hci_driver_open+0x94>)
   1a29c:	4913      	ldr	r1, [pc, #76]	; (1a2ec <hci_driver_open+0x98>)
   1a29e:	9404      	str	r4, [sp, #16]
   1a2a0:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   1a2a4:	4812      	ldr	r0, [pc, #72]	; (1a2f0 <hci_driver_open+0x9c>)
   1a2a6:	f009 fcc3 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   1a2aa:	4912      	ldr	r1, [pc, #72]	; (1a2f4 <hci_driver_open+0xa0>)
   1a2ac:	4810      	ldr	r0, [pc, #64]	; (1a2f0 <hci_driver_open+0x9c>)
   1a2ae:	f012 fbdc 	bl	2ca6a <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1a2b2:	f06f 0307 	mvn.w	r3, #7
   1a2b6:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1a2ba:	e9cd 6706 	strd	r6, r7, [sp, #24]
   1a2be:	e9cd 4400 	strd	r4, r4, [sp]
   1a2c2:	4b0d      	ldr	r3, [pc, #52]	; (1a2f8 <hci_driver_open+0xa4>)
   1a2c4:	490d      	ldr	r1, [pc, #52]	; (1a2fc <hci_driver_open+0xa8>)
   1a2c6:	9404      	str	r4, [sp, #16]
   1a2c8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1a2cc:	480c      	ldr	r0, [pc, #48]	; (1a300 <hci_driver_open+0xac>)
   1a2ce:	f009 fcaf 	bl	23c30 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   1a2d2:	490c      	ldr	r1, [pc, #48]	; (1a304 <hci_driver_open+0xb0>)
   1a2d4:	480a      	ldr	r0, [pc, #40]	; (1a300 <hci_driver_open+0xac>)
   1a2d6:	f012 fbc8 	bl	2ca6a <z_impl_k_thread_name_set>
   1a2da:	e7cf      	b.n	1a27c <hci_driver_open+0x28>
   1a2dc:	20000f2c 	.word	0x20000f2c
   1a2e0:	00033d89 	.word	0x00033d89
   1a2e4:	0002da14 	.word	0x0002da14
   1a2e8:	0001a199 	.word	0x0001a199
   1a2ec:	20004d00 	.word	0x20004d00
   1a2f0:	20001fa0 	.word	0x20001fa0
   1a2f4:	00033da6 	.word	0x00033da6
   1a2f8:	0001a0c9 	.word	0x0001a0c9
   1a2fc:	20004ee0 	.word	0x20004ee0
   1a300:	20002020 	.word	0x20002020
   1a304:	00033db0 	.word	0x00033db0

0001a308 <hci_driver_send>:
{
   1a308:	b530      	push	{r4, r5, lr}
	if (!buf->len) {
   1a30a:	8983      	ldrh	r3, [r0, #12]
{
   1a30c:	b089      	sub	sp, #36	; 0x24
   1a30e:	4605      	mov	r5, r0
	if (!buf->len) {
   1a310:	b97b      	cbnz	r3, 1a332 <hci_driver_send+0x2a>
		BT_ERR("Empty HCI packet");
   1a312:	4a21      	ldr	r2, [pc, #132]	; (1a398 <hci_driver_send+0x90>)
   1a314:	9206      	str	r2, [sp, #24]
   1a316:	2202      	movs	r2, #2
   1a318:	9201      	str	r2, [sp, #4]
   1a31a:	9205      	str	r2, [sp, #20]
   1a31c:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1a320:	aa05      	add	r2, sp, #20
   1a322:	481e      	ldr	r0, [pc, #120]	; (1a39c <hci_driver_send+0x94>)
		return -EINVAL;
   1a324:	f06f 0415 	mvn.w	r4, #21
   1a328:	f00b fcd6 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   1a32c:	4620      	mov	r0, r4
   1a32e:	b009      	add	sp, #36	; 0x24
   1a330:	bd30      	pop	{r4, r5, pc}
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   1a332:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
   1a334:	b183      	cbz	r3, 1a358 <hci_driver_send+0x50>
   1a336:	2b02      	cmp	r3, #2
   1a338:	d122      	bne.n	1a380 <hci_driver_send+0x78>
	err = hci_acl_handle(buf, &evt);
   1a33a:	a902      	add	r1, sp, #8
   1a33c:	f000 fb88 	bl	1aa50 <hci_acl_handle>
   1a340:	4604      	mov	r4, r0
	if (evt) {
   1a342:	9802      	ldr	r0, [sp, #8]
   1a344:	b108      	cbz	r0, 1a34a <hci_driver_send+0x42>
		bt_recv_prio(evt);
   1a346:	f7ec fafb 	bl	6940 <bt_recv_prio>
	if (!err) {
   1a34a:	2c00      	cmp	r4, #0
   1a34c:	d1ee      	bne.n	1a32c <hci_driver_send+0x24>
		net_buf_unref(buf);
   1a34e:	4628      	mov	r0, r5
   1a350:	f006 faa0 	bl	20894 <net_buf_unref>
   1a354:	2400      	movs	r4, #0
   1a356:	e7e9      	b.n	1a32c <hci_driver_send+0x24>
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   1a358:	a902      	add	r1, sp, #8
	struct node_rx_pdu *node_rx = NULL;
   1a35a:	9302      	str	r3, [sp, #8]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   1a35c:	f000 f8fc 	bl	1a558 <hci_cmd_handle>
	if (evt) {
   1a360:	2800      	cmp	r0, #0
   1a362:	d0f4      	beq.n	1a34e <hci_driver_send+0x46>
		bt_recv_prio(evt);
   1a364:	f7ec faec 	bl	6940 <bt_recv_prio>
		if (node_rx) {
   1a368:	9c02      	ldr	r4, [sp, #8]
   1a36a:	2c00      	cmp	r4, #0
   1a36c:	d0ef      	beq.n	1a34e <hci_driver_send+0x46>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   1a36e:	4620      	mov	r0, r4
   1a370:	f000 fe00 	bl	1af74 <hci_get_class>
   1a374:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
   1a376:	9902      	ldr	r1, [sp, #8]
   1a378:	4809      	ldr	r0, [pc, #36]	; (1a3a0 <hci_driver_send+0x98>)
   1a37a:	f012 fc2f 	bl	2cbdc <k_queue_append>
	if (!err) {
   1a37e:	e7e6      	b.n	1a34e <hci_driver_send+0x46>
		BT_ERR("Unknown HCI type %u", type);
   1a380:	4a08      	ldr	r2, [pc, #32]	; (1a3a4 <hci_driver_send+0x9c>)
	switch (type) {
   1a382:	e9cd 2306 	strd	r2, r3, [sp, #24]
		BT_ERR("Unknown HCI type %u", type);
   1a386:	2303      	movs	r3, #3
   1a388:	9301      	str	r3, [sp, #4]
   1a38a:	9305      	str	r3, [sp, #20]
   1a38c:	2300      	movs	r3, #0
   1a38e:	aa05      	add	r2, sp, #20
   1a390:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   1a394:	e7c5      	b.n	1a322 <hci_driver_send+0x1a>
   1a396:	bf00      	nop
   1a398:	00033db6 	.word	0x00033db6
   1a39c:	0002da14 	.word	0x0002da14
   1a3a0:	20000f74 	.word	0x20000f74
   1a3a4:	00033dc7 	.word	0x00033dc7

0001a3a8 <cmd_complete_status>:
{
	return bt_hci_cmd_status_create(_opcode, status);
}

static struct net_buf *cmd_complete_status(uint8_t status)
{
   1a3a8:	b538      	push	{r3, r4, r5, lr}
	struct net_buf *buf;
	struct bt_hci_evt_cc_status *ccst;

	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   1a3aa:	4b07      	ldr	r3, [pc, #28]	; (1a3c8 <cmd_complete_status+0x20>)
{
   1a3ac:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
   1a3ae:	2101      	movs	r1, #1
   1a3b0:	8818      	ldrh	r0, [r3, #0]
   1a3b2:	f00d fdc2 	bl	27f3a <bt_hci_cmd_complete_create>
	return net_buf_simple_add(&buf->b, len);
   1a3b6:	2101      	movs	r1, #1
   1a3b8:	4604      	mov	r4, r0
   1a3ba:	3008      	adds	r0, #8
   1a3bc:	f011 fcbe 	bl	2bd3c <net_buf_simple_add>
	ccst = net_buf_add(buf, sizeof(*ccst));
	ccst->status = status;
   1a3c0:	7005      	strb	r5, [r0, #0]

	return buf;
}
   1a3c2:	4620      	mov	r0, r4
   1a3c4:	bd38      	pop	{r3, r4, r5, pc}
   1a3c6:	bf00      	nop
   1a3c8:	20003928 	.word	0x20003928

0001a3cc <cmd_status>:
	return bt_hci_cmd_status_create(_opcode, status);
   1a3cc:	4b02      	ldr	r3, [pc, #8]	; (1a3d8 <cmd_status+0xc>)
{
   1a3ce:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
   1a3d0:	8818      	ldrh	r0, [r3, #0]
   1a3d2:	f00d bdc4 	b.w	27f5e <bt_hci_cmd_status_create>
   1a3d6:	bf00      	nop
   1a3d8:	20003928 	.word	0x20003928

0001a3dc <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(uint8_t status, struct pdu_data *pdu_data,
				    uint16_t handle, struct net_buf *buf)
{
   1a3dc:	b570      	push	{r4, r5, r6, lr}
   1a3de:	4604      	mov	r4, r0
   1a3e0:	4618      	mov	r0, r3
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1a3e2:	4b0f      	ldr	r3, [pc, #60]	; (1a420 <le_remote_feat_complete+0x44>)
   1a3e4:	685b      	ldr	r3, [r3, #4]
{
   1a3e6:	4616      	mov	r6, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1a3e8:	009a      	lsls	r2, r3, #2
{
   1a3ea:	460d      	mov	r5, r1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1a3ec:	d517      	bpl.n	1a41e <le_remote_feat_complete+0x42>
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
   1a3ee:	4b0d      	ldr	r3, [pc, #52]	; (1a424 <le_remote_feat_complete+0x48>)
   1a3f0:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1a3f2:	071b      	lsls	r3, r3, #28
   1a3f4:	d513      	bpl.n	1a41e <le_remote_feat_complete+0x42>
		return;
	}

	sep = meta_evt(buf, BT_HCI_EVT_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
   1a3f6:	220b      	movs	r2, #11
   1a3f8:	2104      	movs	r1, #4
   1a3fa:	f010 fd53 	bl	2aea4 <meta_evt>

	sep->status = status;
	sep->handle = sys_cpu_to_le16(handle);
	if (!status) {
		memcpy(&sep->features[0],
   1a3fe:	2208      	movs	r2, #8
	sep->status = status;
   1a400:	7004      	strb	r4, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1a402:	f8a0 6001 	strh.w	r6, [r0, #1]
	if (!status) {
   1a406:	3003      	adds	r0, #3
   1a408:	b924      	cbnz	r4, 1a414 <le_remote_feat_complete+0x38>
		memcpy(&sep->features[0],
   1a40a:	1d29      	adds	r1, r5, #4
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
   1a40c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(&sep->features[0],
   1a410:	f00d ba2e 	b.w	27870 <memcpy>
}
   1a414:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   1a418:	2100      	movs	r1, #0
   1a41a:	f00d ba34 	b.w	27886 <memset>
}
   1a41e:	bd70      	pop	{r4, r5, r6, pc}
   1a420:	20000268 	.word	0x20000268
   1a424:	20000270 	.word	0x20000270

0001a428 <hci_cmd_complete>:
{
   1a428:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   1a42a:	4b06      	ldr	r3, [pc, #24]	; (1a444 <hci_cmd_complete+0x1c>)
{
   1a42c:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   1a42e:	8818      	ldrh	r0, [r3, #0]
{
   1a430:	460c      	mov	r4, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
   1a432:	f00d fd82 	bl	27f3a <bt_hci_cmd_complete_create>
   1a436:	4621      	mov	r1, r4
   1a438:	6028      	str	r0, [r5, #0]
}
   1a43a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1a43e:	3008      	adds	r0, #8
   1a440:	f011 bc7c 	b.w	2bd3c <net_buf_simple_add>
   1a444:	20003928 	.word	0x20003928

0001a448 <hci_vendor_cmd_handle_common>:
{
   1a448:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
   1a44a:	3801      	subs	r0, #1
{
   1a44c:	b087      	sub	sp, #28
   1a44e:	4614      	mov	r4, r2
	switch (ocf) {
   1a450:	2809      	cmp	r0, #9
   1a452:	d87c      	bhi.n	1a54e <hci_vendor_cmd_handle_common+0x106>
   1a454:	e8df f000 	tbb	[pc, r0]
   1a458:	7b321b05 	.word	0x7b321b05
   1a45c:	3e7b597b 	.word	0x3e7b597b
   1a460:	6f62      	.short	0x6f62
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a462:	210d      	movs	r1, #13
   1a464:	4610      	mov	r0, r2
   1a466:	f7ff ffdf 	bl	1a428 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1a46a:	2302      	movs	r3, #2
	rp->status = 0x00;
   1a46c:	2100      	movs	r1, #0
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1a46e:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   1a470:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
   1a472:	2303      	movs	r3, #3
	rp->status = 0x00;
   1a474:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1a476:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   1a478:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
   1a47a:	7141      	strb	r1, [r0, #5]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
   1a47c:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   1a47e:	71c1      	strb	r1, [r0, #7]
   1a480:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   1a482:	7241      	strb	r1, [r0, #9]
   1a484:	7281      	strb	r1, [r0, #10]
   1a486:	72c1      	strb	r1, [r0, #11]
   1a488:	7301      	strb	r1, [r0, #12]
	return 0;
   1a48a:	2400      	movs	r4, #0
}
   1a48c:	e013      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a48e:	2141      	movs	r1, #65	; 0x41
   1a490:	4610      	mov	r0, r2
   1a492:	f7ff ffc9 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a496:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a498:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1a49a:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   1a49c:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1a4a0:	4621      	mov	r1, r4
   1a4a2:	f00d f9f0 	bl	27886 <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
   1a4a6:	786b      	ldrb	r3, [r5, #1]
   1a4a8:	f063 0358 	orn	r3, r3, #88	; 0x58
   1a4ac:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   1a4ae:	78ab      	ldrb	r3, [r5, #2]
   1a4b0:	f043 0303 	orr.w	r3, r3, #3
   1a4b4:	70ab      	strb	r3, [r5, #2]
}
   1a4b6:	4620      	mov	r0, r4
   1a4b8:	b007      	add	sp, #28
   1a4ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a4bc:	2109      	movs	r1, #9
   1a4be:	4610      	mov	r0, r2
   1a4c0:	f7ff ffb2 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a4c4:	2400      	movs	r4, #0
   1a4c6:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1a4ca:	2208      	movs	r2, #8
   1a4cc:	4621      	mov	r1, r4
   1a4ce:	f00d f9da 	bl	27886 <memset>
}
   1a4d2:	e7f0      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
	const char build_info[] = HCI_VS_BUILD_INFO;
   1a4d4:	4b1f      	ldr	r3, [pc, #124]	; (1a554 <hci_vendor_cmd_handle_common+0x10c>)
   1a4d6:	aa01      	add	r2, sp, #4
   1a4d8:	f103 0710 	add.w	r7, r3, #16
   1a4dc:	4616      	mov	r6, r2
   1a4de:	6818      	ldr	r0, [r3, #0]
   1a4e0:	6859      	ldr	r1, [r3, #4]
   1a4e2:	4615      	mov	r5, r2
   1a4e4:	c503      	stmia	r5!, {r0, r1}
   1a4e6:	3308      	adds	r3, #8
   1a4e8:	42bb      	cmp	r3, r7
   1a4ea:	462a      	mov	r2, r5
   1a4ec:	d1f7      	bne.n	1a4de <hci_vendor_cmd_handle_common+0x96>
   1a4ee:	781b      	ldrb	r3, [r3, #0]
   1a4f0:	702b      	strb	r3, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
   1a4f2:	2112      	movs	r1, #18
   1a4f4:	4620      	mov	r0, r4
   1a4f6:	f7ff ff97 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a4fa:	2400      	movs	r4, #0
   1a4fc:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
   1a500:	2211      	movs	r2, #17
   1a502:	4631      	mov	r1, r6
   1a504:	f00d f9b4 	bl	27870 <memcpy>
}
   1a508:	e7d5      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
   1a50a:	6889      	ldr	r1, [r1, #8]
   1a50c:	2000      	movs	r0, #0
   1a50e:	f7ff fda3 	bl	1a058 <ll_addr_set>
	*evt = cmd_complete_status(0x00);
   1a512:	2000      	movs	r0, #0
   1a514:	f7ff ff48 	bl	1a3a8 <cmd_complete_status>
   1a518:	6020      	str	r0, [r4, #0]
   1a51a:	e7b6      	b.n	1a48a <hci_vendor_cmd_handle_common+0x42>
	rp = hci_cmd_complete(evt, sizeof(*rp) +
   1a51c:	2118      	movs	r1, #24
   1a51e:	4610      	mov	r0, r2
   1a520:	f7ff ff82 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a524:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
   1a526:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   1a528:	2101      	movs	r1, #1
	rp->status = 0x00;
   1a52a:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
   1a52e:	f011 fae3 	bl	2baf8 <hci_vendor_read_static_addr>
   1a532:	7068      	strb	r0, [r5, #1]
}
   1a534:	e7bf      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a536:	2121      	movs	r1, #33	; 0x21
   1a538:	4610      	mov	r0, r2
   1a53a:	f7ff ff75 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a53e:	4601      	mov	r1, r0
   1a540:	2400      	movs	r4, #0
   1a542:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
   1a546:	3001      	adds	r0, #1
   1a548:	f011 fb2c 	bl	2bba4 <hci_vendor_read_key_hierarchy_roots>
}
   1a54c:	e7b3      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
	switch (ocf) {
   1a54e:	f06f 0415 	mvn.w	r4, #21
   1a552:	e7b0      	b.n	1a4b6 <hci_vendor_cmd_handle_common+0x6e>
   1a554:	00033df9 	.word	0x00033df9

0001a558 <hci_cmd_handle>:
{
   1a558:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cmd->len < sizeof(*chdr)) {
   1a55a:	8983      	ldrh	r3, [r0, #12]
{
   1a55c:	b08d      	sub	sp, #52	; 0x34
	struct net_buf *evt = NULL;
   1a55e:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
   1a560:	2b02      	cmp	r3, #2
{
   1a562:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
   1a564:	9504      	str	r5, [sp, #16]
	if (cmd->len < sizeof(*chdr)) {
   1a566:	d80e      	bhi.n	1a586 <hci_cmd_handle+0x2e>
		BT_ERR("No HCI Command header");
   1a568:	4bbc      	ldr	r3, [pc, #752]	; (1a85c <hci_cmd_handle+0x304>)
		BT_ERR("Invalid HCI CMD packet length");
   1a56a:	930a      	str	r3, [sp, #40]	; 0x28
   1a56c:	2302      	movs	r3, #2
   1a56e:	9305      	str	r3, [sp, #20]
   1a570:	9309      	str	r3, [sp, #36]	; 0x24
   1a572:	48bb      	ldr	r0, [pc, #748]	; (1a860 <hci_cmd_handle+0x308>)
   1a574:	462b      	mov	r3, r5
   1a576:	aa09      	add	r2, sp, #36	; 0x24
   1a578:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1a57c:	f00b fbac 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return NULL;
   1a580:	4628      	mov	r0, r5
}
   1a582:	b00d      	add	sp, #52	; 0x34
   1a584:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
   1a586:	2103      	movs	r1, #3
   1a588:	3008      	adds	r0, #8
   1a58a:	f011 fc4f 	bl	2be2c <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
   1a58e:	89a2      	ldrh	r2, [r4, #12]
   1a590:	7883      	ldrb	r3, [r0, #2]
   1a592:	429a      	cmp	r2, r3
   1a594:	d201      	bcs.n	1a59a <hci_cmd_handle+0x42>
		BT_ERR("Invalid HCI CMD packet length");
   1a596:	4bb3      	ldr	r3, [pc, #716]	; (1a864 <hci_cmd_handle+0x30c>)
   1a598:	e7e7      	b.n	1a56a <hci_cmd_handle+0x12>
	_opcode = sys_le16_to_cpu(chdr->opcode);
   1a59a:	8803      	ldrh	r3, [r0, #0]
   1a59c:	4ab2      	ldr	r2, [pc, #712]	; (1a868 <hci_cmd_handle+0x310>)
	ocf = BT_OCF(_opcode);
   1a59e:	f3c3 0009 	ubfx	r0, r3, #0, #10
	_opcode = sys_le16_to_cpu(chdr->opcode);
   1a5a2:	8013      	strh	r3, [r2, #0]
	switch (BT_OGF(_opcode)) {
   1a5a4:	f3c3 2385 	ubfx	r3, r3, #10, #6
   1a5a8:	2b08      	cmp	r3, #8
   1a5aa:	d80d      	bhi.n	1a5c8 <hci_cmd_handle+0x70>
   1a5ac:	b17b      	cbz	r3, 1a5ce <hci_cmd_handle+0x76>
   1a5ae:	3b01      	subs	r3, #1
   1a5b0:	2b07      	cmp	r3, #7
   1a5b2:	d80c      	bhi.n	1a5ce <hci_cmd_handle+0x76>
   1a5b4:	e8df f013 	tbh	[pc, r3, lsl #1]
   1a5b8:	000b000d 	.word	0x000b000d
   1a5bc:	005d001e 	.word	0x005d001e
   1a5c0:	000b000b 	.word	0x000b000b
   1a5c4:	00e4000b 	.word	0x00e4000b
   1a5c8:	2b3f      	cmp	r3, #63	; 0x3f
   1a5ca:	f000 8239 	beq.w	1aa40 <hci_cmd_handle+0x4e8>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
   1a5ce:	2001      	movs	r0, #1
   1a5d0:	e00d      	b.n	1a5ee <hci_cmd_handle+0x96>
	switch (ocf) {
   1a5d2:	2806      	cmp	r0, #6
   1a5d4:	d006      	beq.n	1a5e4 <hci_cmd_handle+0x8c>
   1a5d6:	281d      	cmp	r0, #29
   1a5d8:	d1f9      	bne.n	1a5ce <hci_cmd_handle+0x76>
	handle = sys_le16_to_cpu(cmd->handle);
   1a5da:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
   1a5dc:	8818      	ldrh	r0, [r3, #0]
   1a5de:	f010 ff75 	bl	2b4cc <ll_version_ind_send>
	*evt = cmd_status(status);
   1a5e2:	e004      	b.n	1a5ee <hci_cmd_handle+0x96>
	struct bt_hci_cp_disconnect *cmd = (void *)buf->data;
   1a5e4:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
   1a5e6:	7899      	ldrb	r1, [r3, #2]
   1a5e8:	8818      	ldrh	r0, [r3, #0]
   1a5ea:	f002 fb9d 	bl	1cd28 <ll_terminate_ind_send>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
   1a5ee:	f7ff feed 	bl	1a3cc <cmd_status>
   1a5f2:	e022      	b.n	1a63a <hci_cmd_handle+0xe2>
	switch (ocf) {
   1a5f4:	282d      	cmp	r0, #45	; 0x2d
   1a5f6:	d029      	beq.n	1a64c <hci_cmd_handle+0xf4>
   1a5f8:	d81a      	bhi.n	1a630 <hci_cmd_handle+0xd8>
   1a5fa:	2801      	cmp	r0, #1
   1a5fc:	d01f      	beq.n	1a63e <hci_cmd_handle+0xe6>
   1a5fe:	2803      	cmp	r0, #3
   1a600:	d1e5      	bne.n	1a5ce <hci_cmd_handle+0x76>
	event_mask = DEFAULT_EVENT_MASK;
   1a602:	4b9a      	ldr	r3, [pc, #616]	; (1a86c <hci_cmd_handle+0x314>)
   1a604:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1a608:	f641 71ff 	movw	r1, #8191	; 0x1fff
   1a60c:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   1a610:	4b97      	ldr	r3, [pc, #604]	; (1a870 <hci_cmd_handle+0x318>)
   1a612:	201f      	movs	r0, #31
   1a614:	2100      	movs	r1, #0
   1a616:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
   1a61a:	f001 fbef 	bl	1bdfc <ll_reset>
		*evt = cmd_complete_status(0x00);
   1a61e:	2000      	movs	r0, #0
   1a620:	f7ff fec2 	bl	1a3a8 <cmd_complete_status>
	conn_count = 0U;
   1a624:	4b93      	ldr	r3, [pc, #588]	; (1a874 <hci_cmd_handle+0x31c>)
		*evt = cmd_complete_status(0x00);
   1a626:	9004      	str	r0, [sp, #16]
	conn_count = 0U;
   1a628:	2200      	movs	r2, #0
   1a62a:	601a      	str	r2, [r3, #0]
	return evt;
   1a62c:	9804      	ldr	r0, [sp, #16]
   1a62e:	e7a8      	b.n	1a582 <hci_cmd_handle+0x2a>
	switch (ocf) {
   1a630:	2863      	cmp	r0, #99	; 0x63
   1a632:	d1cc      	bne.n	1a5ce <hci_cmd_handle+0x76>
	*evt = cmd_complete_status(0x00);
   1a634:	2000      	movs	r0, #0
	*evt = cmd_complete_status(status);
   1a636:	f7ff feb7 	bl	1a3a8 <cmd_complete_status>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
   1a63a:	9004      	str	r0, [sp, #16]
   1a63c:	e7f6      	b.n	1a62c <hci_cmd_handle+0xd4>
	event_mask = sys_get_le64(cmd->events);
   1a63e:	68a0      	ldr	r0, [r4, #8]
   1a640:	f010 fc48 	bl	2aed4 <sys_get_le64>
   1a644:	4b89      	ldr	r3, [pc, #548]	; (1a86c <hci_cmd_handle+0x314>)
	le_event_mask = sys_get_le64(cmd->events);
   1a646:	e9c3 0100 	strd	r0, r1, [r3]
   1a64a:	e7f3      	b.n	1a634 <hci_cmd_handle+0xdc>
	struct bt_hci_cp_read_tx_power_level *cmd = (void *)buf->data;
   1a64c:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a64e:	2104      	movs	r1, #4
   1a650:	a804      	add	r0, sp, #16
	handle = sys_le16_to_cpu(cmd->handle);
   1a652:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
   1a654:	789f      	ldrb	r7, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a656:	f7ff fee7 	bl	1a428 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   1a65a:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a65c:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
   1a65e:	1cc3      	adds	r3, r0, #3
   1a660:	463a      	mov	r2, r7
   1a662:	4631      	mov	r1, r6
   1a664:	2002      	movs	r0, #2
   1a666:	f010 fc0a 	bl	2ae7e <ll_tx_pwr_lvl_get>
	rp->status = status;
   1a66a:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
   1a66c:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
   1a670:	e7dc      	b.n	1a62c <hci_cmd_handle+0xd4>
	switch (ocf) {
   1a672:	3801      	subs	r0, #1
   1a674:	2808      	cmp	r0, #8
   1a676:	d8aa      	bhi.n	1a5ce <hci_cmd_handle+0x76>
   1a678:	a301      	add	r3, pc, #4	; (adr r3, 1a680 <hci_cmd_handle+0x128>)
   1a67a:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
   1a67e:	bf00      	nop
   1a680:	0001a6a5 	.word	0x0001a6a5
   1a684:	0001a6cf 	.word	0x0001a6cf
   1a688:	0001a74f 	.word	0x0001a74f
   1a68c:	0001a5cf 	.word	0x0001a5cf
   1a690:	0001a5cf 	.word	0x0001a5cf
   1a694:	0001a5cf 	.word	0x0001a5cf
   1a698:	0001a5cf 	.word	0x0001a5cf
   1a69c:	0001a5cf 	.word	0x0001a5cf
   1a6a0:	0001a76b 	.word	0x0001a76b
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a6a4:	2109      	movs	r1, #9
   1a6a6:	a804      	add	r0, sp, #16
   1a6a8:	f7ff febe 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a6ac:	2300      	movs	r3, #0
   1a6ae:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
   1a6b0:	7083      	strb	r3, [r0, #2]
   1a6b2:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   1a6b4:	f06f 030e 	mvn.w	r3, #14
	rp->hci_version = LL_VERSION_NUMBER;
   1a6b8:	220c      	movs	r2, #12
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   1a6ba:	7143      	strb	r3, [r0, #5]
   1a6bc:	2305      	movs	r3, #5
   1a6be:	7183      	strb	r3, [r0, #6]
	rp->hci_version = LL_VERSION_NUMBER;
   1a6c0:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
   1a6c2:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   1a6c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	dst[0] = val;
   1a6c8:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
   1a6ca:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
   1a6cc:	e7ae      	b.n	1a62c <hci_cmd_handle+0xd4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a6ce:	2141      	movs	r1, #65	; 0x41
   1a6d0:	a804      	add	r0, sp, #16
   1a6d2:	f7ff fea9 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a6d6:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a6d8:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1a6da:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   1a6dc:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1a6e0:	f00d f8d1 	bl	27886 <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
   1a6e4:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[26] |= BIT(6) | BIT(7);
   1a6e6:	7ee2      	ldrb	r2, [r4, #27]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
   1a6e8:	7ea1      	ldrb	r1, [r4, #26]
	rp->commands[28] |= BIT(3);
   1a6ea:	7f60      	ldrb	r0, [r4, #29]
	rp->commands[5] |= BIT(6) | BIT(7);
   1a6ec:	f063 033f 	orn	r3, r3, #63	; 0x3f
   1a6f0:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
   1a6f2:	7ae3      	ldrb	r3, [r4, #11]
   1a6f4:	f043 0304 	orr.w	r3, r3, #4
   1a6f8:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
   1a6fa:	7be3      	ldrb	r3, [r4, #15]
   1a6fc:	f043 0328 	orr.w	r3, r3, #40	; 0x28
   1a700:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
   1a702:	7c23      	ldrb	r3, [r4, #16]
   1a704:	f043 0302 	orr.w	r3, r3, #2
   1a708:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
   1a70a:	7de3      	ldrb	r3, [r4, #23]
   1a70c:	f043 0304 	orr.w	r3, r3, #4
   1a710:	75e3      	strb	r3, [r4, #23]
	rp->commands[27] |= BIT(0) | BIT(1);
   1a712:	7f23      	ldrb	r3, [r4, #28]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
   1a714:	f063 0308 	orn	r3, r3, #8
   1a718:	7723      	strb	r3, [r4, #28]
	rp->commands[33] |= BIT(4) | BIT(5);
   1a71a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	rp->commands[26] |= BIT(2) | BIT(3);
   1a71e:	f062 0230 	orn	r2, r2, #48	; 0x30
	rp->commands[33] |= BIT(4) | BIT(5);
   1a722:	f043 0330 	orr.w	r3, r3, #48	; 0x30
	rp->commands[26] |= BIT(2) | BIT(3);
   1a726:	76e2      	strb	r2, [r4, #27]
	rp->commands[33] |= BIT(4) | BIT(5);
   1a728:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	rp->commands[0] |= BIT(5);
   1a72c:	7862      	ldrb	r2, [r4, #1]
	rp->commands[38] |= BIT(7);
   1a72e:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[28] |= BIT(3);
   1a732:	f040 0008 	orr.w	r0, r0, #8
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1a736:	f061 0108 	orn	r1, r1, #8
	rp->commands[0] |= BIT(5);
   1a73a:	f042 0220 	orr.w	r2, r2, #32
	rp->commands[38] |= BIT(7);
   1a73e:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[28] |= BIT(3);
   1a742:	7760      	strb	r0, [r4, #29]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1a744:	76a1      	strb	r1, [r4, #26]
	rp->commands[0] |= BIT(5);
   1a746:	7062      	strb	r2, [r4, #1]
	rp->commands[38] |= BIT(7);
   1a748:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	if (err == -EINVAL) {
   1a74c:	e76e      	b.n	1a62c <hci_cmd_handle+0xd4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a74e:	2109      	movs	r1, #9
   1a750:	a804      	add	r0, sp, #16
   1a752:	f7ff fe69 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a756:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a758:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1a75a:	2208      	movs	r2, #8
	rp->status = 0x00;
   1a75c:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1a760:	f00d f891 	bl	27886 <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
   1a764:	2360      	movs	r3, #96	; 0x60
   1a766:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
   1a768:	e760      	b.n	1a62c <hci_cmd_handle+0xd4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a76a:	2107      	movs	r1, #7
   1a76c:	a804      	add	r0, sp, #16
   1a76e:	f7ff fe5b 	bl	1a428 <hci_cmd_complete>
   1a772:	4601      	mov	r1, r0
	rp->status = 0x00;
   1a774:	2000      	movs	r0, #0
   1a776:	f801 0b01 	strb.w	r0, [r1], #1
	(void)ll_addr_read(0, &rp->bdaddr.val[0]);
   1a77a:	f010 fb73 	bl	2ae64 <ll_addr_read>
	if (err == -EINVAL) {
   1a77e:	e755      	b.n	1a62c <hci_cmd_handle+0xd4>
	switch (ocf) {
   1a780:	2821      	cmp	r0, #33	; 0x21
   1a782:	d84b      	bhi.n	1a81c <hci_cmd_handle+0x2c4>
   1a784:	2800      	cmp	r0, #0
   1a786:	f43f af22 	beq.w	1a5ce <hci_cmd_handle+0x76>
   1a78a:	3801      	subs	r0, #1
   1a78c:	2820      	cmp	r0, #32
   1a78e:	f63f af1e 	bhi.w	1a5ce <hci_cmd_handle+0x76>
   1a792:	a301      	add	r3, pc, #4	; (adr r3, 1a798 <hci_cmd_handle+0x240>)
   1a794:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
   1a798:	0001a83b 	.word	0x0001a83b
   1a79c:	0001a845 	.word	0x0001a845
   1a7a0:	0001a879 	.word	0x0001a879
   1a7a4:	0001a5cf 	.word	0x0001a5cf
   1a7a8:	0001a8b5 	.word	0x0001a8b5
   1a7ac:	0001a94d 	.word	0x0001a94d
   1a7b0:	0001a969 	.word	0x0001a969
   1a7b4:	0001a979 	.word	0x0001a979
   1a7b8:	0001a985 	.word	0x0001a985
   1a7bc:	0001a991 	.word	0x0001a991
   1a7c0:	0001a99b 	.word	0x0001a99b
   1a7c4:	0001a9b3 	.word	0x0001a9b3
   1a7c8:	0001a5cf 	.word	0x0001a5cf
   1a7cc:	0001a5cf 	.word	0x0001a5cf
   1a7d0:	0001a8bf 	.word	0x0001a8bf
   1a7d4:	0001a8d5 	.word	0x0001a8d5
   1a7d8:	0001a8db 	.word	0x0001a8db
   1a7dc:	0001a8e3 	.word	0x0001a8e3
   1a7e0:	0001a9e7 	.word	0x0001a9e7
   1a7e4:	0001a5cf 	.word	0x0001a5cf
   1a7e8:	0001a9c3 	.word	0x0001a9c3
   1a7ec:	0001a9dd 	.word	0x0001a9dd
   1a7f0:	0001a8eb 	.word	0x0001a8eb
   1a7f4:	0001a911 	.word	0x0001a911
   1a7f8:	0001a5cf 	.word	0x0001a5cf
   1a7fc:	0001a5cf 	.word	0x0001a5cf
   1a800:	0001a5cf 	.word	0x0001a5cf
   1a804:	0001a927 	.word	0x0001a927
   1a808:	0001a5cf 	.word	0x0001a5cf
   1a80c:	0001a5cf 	.word	0x0001a5cf
   1a810:	0001a5cf 	.word	0x0001a5cf
   1a814:	0001aa03 	.word	0x0001aa03
   1a818:	0001aa31 	.word	0x0001aa31
   1a81c:	284b      	cmp	r0, #75	; 0x4b
   1a81e:	f47f aed6 	bne.w	1a5ce <hci_cmd_handle+0x76>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a822:	2103      	movs	r1, #3
   1a824:	a804      	add	r0, sp, #16
   1a826:	f7ff fdff 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a82a:	4601      	mov	r1, r0
   1a82c:	2300      	movs	r3, #0
   1a82e:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
   1a832:	3001      	adds	r0, #1
   1a834:	f010 fb32 	bl	2ae9c <ll_tx_pwr_get>
	if (err == -EINVAL) {
   1a838:	e6f8      	b.n	1a62c <hci_cmd_handle+0xd4>
	le_event_mask = sys_get_le64(cmd->events);
   1a83a:	68a0      	ldr	r0, [r4, #8]
   1a83c:	f010 fb4a 	bl	2aed4 <sys_get_le64>
   1a840:	4b0b      	ldr	r3, [pc, #44]	; (1a870 <hci_cmd_handle+0x318>)
   1a842:	e700      	b.n	1a646 <hci_cmd_handle+0xee>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a844:	2104      	movs	r1, #4
   1a846:	a804      	add	r0, sp, #16
   1a848:	f7ff fdee 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a84c:	2300      	movs	r3, #0
   1a84e:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
   1a850:	221b      	movs	r2, #27
   1a852:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
   1a854:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
   1a856:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
   1a858:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
   1a85a:	e6e7      	b.n	1a62c <hci_cmd_handle+0xd4>
   1a85c:	00033e0a 	.word	0x00033e0a
   1a860:	0002da0c 	.word	0x0002da0c
   1a864:	00033e20 	.word	0x00033e20
   1a868:	20003928 	.word	0x20003928
   1a86c:	20000268 	.word	0x20000268
   1a870:	20000270 	.word	0x20000270
   1a874:	20002a38 	.word	0x20002a38
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a878:	2109      	movs	r1, #9
   1a87a:	a804      	add	r0, sp, #16
   1a87c:	f7ff fdd4 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a880:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a882:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1a884:	2208      	movs	r2, #8
	rp->status = 0x00;
   1a886:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1a88a:	f00c fffc 	bl	27886 <memset>
	sys_put_le64(ll_feat_get(), rp->features);
   1a88e:	f010 fb43 	bl	2af18 <ll_feat_get>
   1a892:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   1a896:	7060      	strb	r0, [r4, #1]
	dst[1] = val >> 8;
   1a898:	70a3      	strb	r3, [r4, #2]
	sys_put_le16(val >> 16, &dst[2]);
   1a89a:	0c00      	lsrs	r0, r0, #16
	dst[1] = val >> 8;
   1a89c:	f3c1 2307 	ubfx	r3, r1, #8, #8
	dst[0] = val;
   1a8a0:	7161      	strb	r1, [r4, #5]
	sys_put_le16(val >> 16, &dst[2]);
   1a8a2:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
   1a8a4:	70e0      	strb	r0, [r4, #3]
   1a8a6:	71e1      	strb	r1, [r4, #7]
	dst[1] = val >> 8;
   1a8a8:	0a00      	lsrs	r0, r0, #8
   1a8aa:	0a09      	lsrs	r1, r1, #8
   1a8ac:	7120      	strb	r0, [r4, #4]
   1a8ae:	71a3      	strb	r3, [r4, #6]
   1a8b0:	7221      	strb	r1, [r4, #8]
	if (err == -EINVAL) {
   1a8b2:	e6bb      	b.n	1a62c <hci_cmd_handle+0xd4>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
   1a8b4:	68a1      	ldr	r1, [r4, #8]
   1a8b6:	2001      	movs	r0, #1
   1a8b8:	f7ff fbce 	bl	1a058 <ll_addr_set>
	*evt = cmd_complete_status(status);
   1a8bc:	e6bb      	b.n	1a636 <hci_cmd_handle+0xde>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a8be:	2102      	movs	r1, #2
   1a8c0:	a804      	add	r0, sp, #16
   1a8c2:	f7ff fdb1 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a8c6:	2300      	movs	r3, #0
   1a8c8:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a8ca:	4604      	mov	r4, r0
	rp->fal_size = ll_fal_size_get();
   1a8cc:	f010 fe80 	bl	2b5d0 <ll_fal_size_get>
   1a8d0:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
   1a8d2:	e6ab      	b.n	1a62c <hci_cmd_handle+0xd4>
	status = ll_fal_clear();
   1a8d4:	f003 faba 	bl	1de4c <ll_fal_clear>
	*evt = cmd_complete_status(status);
   1a8d8:	e6ad      	b.n	1a636 <hci_cmd_handle+0xde>
	status = ll_fal_add(&cmd->addr);
   1a8da:	68a0      	ldr	r0, [r4, #8]
   1a8dc:	f003 fac8 	bl	1de70 <ll_fal_add>
	*evt = cmd_complete_status(status);
   1a8e0:	e6a9      	b.n	1a636 <hci_cmd_handle+0xde>
	status = ll_fal_remove(&cmd->addr);
   1a8e2:	68a0      	ldr	r0, [r4, #8]
   1a8e4:	f003 faf6 	bl	1ded4 <ll_fal_remove>
	*evt = cmd_complete_status(status);
   1a8e8:	e6a5      	b.n	1a636 <hci_cmd_handle+0xde>
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
   1a8ea:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
   1a8ec:	aa06      	add	r2, sp, #24
   1a8ee:	2300      	movs	r3, #0
   1a8f0:	f100 0110 	add.w	r1, r0, #16
   1a8f4:	f011 f894 	bl	2ba20 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a8f8:	2111      	movs	r1, #17
   1a8fa:	a804      	add	r0, sp, #16
   1a8fc:	f7ff fd94 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a900:	2300      	movs	r3, #0
   1a902:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
   1a906:	2210      	movs	r2, #16
   1a908:	a906      	add	r1, sp, #24
   1a90a:	f00c ffb1 	bl	27870 <memcpy>
	if (err == -EINVAL) {
   1a90e:	e68d      	b.n	1a62c <hci_cmd_handle+0xd4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a910:	2109      	movs	r1, #9
   1a912:	a804      	add	r0, sp, #16
   1a914:	f7ff fd88 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a918:	2300      	movs	r3, #0
   1a91a:	f800 3b01 	strb.w	r3, [r0], #1
	lll_csrand_get(rp->rand, count);
   1a91e:	2108      	movs	r1, #8
   1a920:	f003 fd4e 	bl	1e3c0 <lll_csrand_get>
	if (err == -EINVAL) {
   1a924:	e682      	b.n	1a62c <hci_cmd_handle+0xd4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a926:	2109      	movs	r1, #9
   1a928:	a804      	add	r0, sp, #16
   1a92a:	f7ff fd7d 	bl	1a428 <hci_cmd_complete>
	dst[0] = val;
   1a92e:	22bf      	movs	r2, #191	; 0xbf
   1a930:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
   1a932:	22ff      	movs	r2, #255	; 0xff
   1a934:	7082      	strb	r2, [r0, #2]
	dst[0] = val;
   1a936:	2230      	movs	r2, #48	; 0x30
   1a938:	70c2      	strb	r2, [r0, #3]
	dst[1] = val >> 8;
   1a93a:	22ec      	movs	r2, #236	; 0xec
   1a93c:	7102      	strb	r2, [r0, #4]
	dst[0] = val;
   1a93e:	22c0      	movs	r2, #192	; 0xc0
	rp->status = 0x00;
   1a940:	2300      	movs	r3, #0
   1a942:	7142      	strb	r2, [r0, #5]
	dst[1] = val >> 8;
   1a944:	2201      	movs	r2, #1
   1a946:	7003      	strb	r3, [r0, #0]
   1a948:	7182      	strb	r2, [r0, #6]
   1a94a:	e6bd      	b.n	1a6c8 <hci_cmd_handle+0x170>
	struct bt_hci_cp_le_set_adv_param *cmd = (void *)buf->data;
   1a94c:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
   1a94e:	7ba5      	ldrb	r5, [r4, #14]
   1a950:	79a3      	ldrb	r3, [r4, #6]
   1a952:	7962      	ldrb	r2, [r4, #5]
   1a954:	7921      	ldrb	r1, [r4, #4]
   1a956:	8820      	ldrh	r0, [r4, #0]
   1a958:	9502      	str	r5, [sp, #8]
   1a95a:	7b65      	ldrb	r5, [r4, #13]
   1a95c:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
   1a95e:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
   1a960:	9400      	str	r4, [sp, #0]
   1a962:	f001 fd69 	bl	1c438 <ll_adv_params_set>
	*evt = cmd_complete_status(status);
   1a966:	e666      	b.n	1a636 <hci_cmd_handle+0xde>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a968:	2102      	movs	r1, #2
   1a96a:	a804      	add	r0, sp, #16
   1a96c:	f7ff fd5c 	bl	1a428 <hci_cmd_complete>
	rp->status = 0x00;
   1a970:	2300      	movs	r3, #0
   1a972:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
   1a974:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
   1a976:	e659      	b.n	1a62c <hci_cmd_handle+0xd4>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
   1a978:	68a1      	ldr	r1, [r4, #8]
   1a97a:	f811 0b01 	ldrb.w	r0, [r1], #1
   1a97e:	f001 feed 	bl	1c75c <ll_adv_data_set>
	*evt = cmd_complete_status(status);
   1a982:	e658      	b.n	1a636 <hci_cmd_handle+0xde>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
   1a984:	68a1      	ldr	r1, [r4, #8]
   1a986:	f811 0b01 	ldrb.w	r0, [r1], #1
   1a98a:	f001 feef 	bl	1c76c <ll_adv_scan_rsp_set>
	*evt = cmd_complete_status(status);
   1a98e:	e652      	b.n	1a636 <hci_cmd_handle+0xde>
	status = ll_adv_enable(cmd->enable);
   1a990:	68a3      	ldr	r3, [r4, #8]
   1a992:	7818      	ldrb	r0, [r3, #0]
   1a994:	f7e5 fd60 	bl	458 <ll_adv_enable>
	*evt = cmd_complete_status(status);
   1a998:	e64d      	b.n	1a636 <hci_cmd_handle+0xde>
	struct bt_hci_cp_le_set_scan_param *cmd = (void *)buf->data;
   1a99a:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
   1a99c:	7963      	ldrb	r3, [r4, #5]
   1a99e:	f8b4 2003 	ldrh.w	r2, [r4, #3]
   1a9a2:	f8b4 1001 	ldrh.w	r1, [r4, #1]
   1a9a6:	7820      	ldrb	r0, [r4, #0]
   1a9a8:	79a4      	ldrb	r4, [r4, #6]
   1a9aa:	9400      	str	r4, [sp, #0]
   1a9ac:	f7e5 ffcc 	bl	948 <ll_scan_params_set>
	*evt = cmd_complete_status(status);
   1a9b0:	e641      	b.n	1a636 <hci_cmd_handle+0xde>
	status = ll_scan_enable(cmd->enable);
   1a9b2:	68a3      	ldr	r3, [r4, #8]
   1a9b4:	7818      	ldrb	r0, [r3, #0]
   1a9b6:	f010 fc3e 	bl	2b236 <ll_scan_enable>
		status = BT_HCI_ERR_SUCCESS;
   1a9ba:	280c      	cmp	r0, #12
	*evt = cmd_complete_status(status);
   1a9bc:	bf08      	it	eq
   1a9be:	2000      	moveq	r0, #0
   1a9c0:	e639      	b.n	1a636 <hci_cmd_handle+0xde>
	handle = sys_le16_to_cpu(cmd->handle);
   1a9c2:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a9c4:	2108      	movs	r1, #8
   1a9c6:	a804      	add	r0, sp, #16
	handle = sys_le16_to_cpu(cmd->handle);
   1a9c8:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a9ca:	f7ff fd2d 	bl	1a428 <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   1a9ce:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1a9d0:	4604      	mov	r4, r0
	status = ll_chm_get(handle, rp->ch_map);
   1a9d2:	1cc1      	adds	r1, r0, #3
   1a9d4:	4630      	mov	r0, r6
   1a9d6:	f010 fd47 	bl	2b468 <ll_chm_get>
   1a9da:	e646      	b.n	1a66a <hci_cmd_handle+0x112>
	handle = sys_le16_to_cpu(cmd->handle);
   1a9dc:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
   1a9de:	8818      	ldrh	r0, [r3, #0]
   1a9e0:	f010 fd59 	bl	2b496 <ll_feature_req_send>
	*evt = cmd_status(status);
   1a9e4:	e603      	b.n	1a5ee <hci_cmd_handle+0x96>
	struct hci_cp_le_conn_update *cmd = (void *)buf->data;
   1a9e6:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
   1a9e8:	8911      	ldrh	r1, [r2, #8]
   1a9ea:	8853      	ldrh	r3, [r2, #2]
   1a9ec:	8810      	ldrh	r0, [r2, #0]
   1a9ee:	9102      	str	r1, [sp, #8]
   1a9f0:	88d1      	ldrh	r1, [r2, #6]
   1a9f2:	9101      	str	r1, [sp, #4]
   1a9f4:	8892      	ldrh	r2, [r2, #4]
   1a9f6:	9200      	str	r2, [sp, #0]
   1a9f8:	2200      	movs	r2, #0
   1a9fa:	4611      	mov	r1, r2
   1a9fc:	f010 fcaf 	bl	2b35e <ll_conn_update>
	*evt = cmd_status(status);
   1aa00:	e5f5      	b.n	1a5ee <hci_cmd_handle+0x96>
	struct bt_hci_cp_le_conn_param_req_reply *cmd = (void *)buf->data;
   1aa02:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1aa04:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1aa06:	8815      	ldrh	r5, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1aa08:	8853      	ldrh	r3, [r2, #2]
   1aa0a:	9102      	str	r1, [sp, #8]
   1aa0c:	88d1      	ldrh	r1, [r2, #6]
   1aa0e:	9101      	str	r1, [sp, #4]
   1aa10:	8892      	ldrh	r2, [r2, #4]
   1aa12:	9200      	str	r2, [sp, #0]
   1aa14:	2200      	movs	r2, #0
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1aa16:	2102      	movs	r1, #2
   1aa18:	b2a8      	uxth	r0, r5
   1aa1a:	f010 fca0 	bl	2b35e <ll_conn_update>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1aa1e:	2103      	movs	r1, #3
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1aa20:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1aa22:	a804      	add	r0, sp, #16
   1aa24:	f7ff fd00 	bl	1a428 <hci_cmd_complete>
	rp->status = status;
   1aa28:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   1aa2a:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (err == -EINVAL) {
   1aa2e:	e5fd      	b.n	1a62c <hci_cmd_handle+0xd4>
	struct bt_hci_cp_le_conn_param_req_neg_reply *cmd = (void *)buf->data;
   1aa30:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1aa32:	881d      	ldrh	r5, [r3, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1aa34:	789a      	ldrb	r2, [r3, #2]
   1aa36:	2300      	movs	r3, #0
   1aa38:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1aa3c:	9300      	str	r3, [sp, #0]
   1aa3e:	e7ea      	b.n	1aa16 <hci_cmd_handle+0x4be>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
   1aa40:	aa04      	add	r2, sp, #16
   1aa42:	4621      	mov	r1, r4
   1aa44:	f7ff fd00 	bl	1a448 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
   1aa48:	3016      	adds	r0, #22
   1aa4a:	f43f adc0 	beq.w	1a5ce <hci_cmd_handle+0x76>
   1aa4e:	e5ed      	b.n	1a62c <hci_cmd_handle+0xd4>

0001aa50 <hci_acl_handle>:
{
   1aa50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (buf->len < sizeof(*acl)) {
   1aa54:	8983      	ldrh	r3, [r0, #12]
	*evt = NULL;
   1aa56:	2400      	movs	r4, #0
	if (buf->len < sizeof(*acl)) {
   1aa58:	2b03      	cmp	r3, #3
{
   1aa5a:	b089      	sub	sp, #36	; 0x24
   1aa5c:	4605      	mov	r5, r0
   1aa5e:	460e      	mov	r6, r1
	*evt = NULL;
   1aa60:	600c      	str	r4, [r1, #0]
	if (buf->len < sizeof(*acl)) {
   1aa62:	d80e      	bhi.n	1aa82 <hci_acl_handle+0x32>
		BT_ERR("No HCI ACL header");
   1aa64:	4b3f      	ldr	r3, [pc, #252]	; (1ab64 <hci_acl_handle+0x114>)
		BT_ERR("Invalid HCI ACL packet length");
   1aa66:	9306      	str	r3, [sp, #24]
   1aa68:	2302      	movs	r3, #2
   1aa6a:	9301      	str	r3, [sp, #4]
   1aa6c:	9305      	str	r3, [sp, #20]
   1aa6e:	483e      	ldr	r0, [pc, #248]	; (1ab68 <hci_acl_handle+0x118>)
   1aa70:	4623      	mov	r3, r4
   1aa72:	aa05      	add	r2, sp, #20
   1aa74:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1aa78:	f00b f92e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   1aa7c:	f06f 0015 	mvn.w	r0, #21
   1aa80:	e027      	b.n	1aad2 <hci_acl_handle+0x82>
   1aa82:	2104      	movs	r1, #4
   1aa84:	3008      	adds	r0, #8
   1aa86:	f011 f9d1 	bl	2be2c <net_buf_simple_pull_mem>
	if (buf->len < len) {
   1aa8a:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
   1aa8c:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
   1aa8e:	f8b0 9000 	ldrh.w	r9, [r0]
	if (buf->len < len) {
   1aa92:	42bb      	cmp	r3, r7
   1aa94:	d201      	bcs.n	1aa9a <hci_acl_handle+0x4a>
		BT_ERR("Invalid HCI ACL packet length");
   1aa96:	4b35      	ldr	r3, [pc, #212]	; (1ab6c <hci_acl_handle+0x11c>)
   1aa98:	e7e5      	b.n	1aa66 <hci_acl_handle+0x16>
	if (len > LL_LENGTH_OCTETS_TX_MAX) {
   1aa9a:	2f1b      	cmp	r7, #27
   1aa9c:	d901      	bls.n	1aaa2 <hci_acl_handle+0x52>
		BT_ERR("Invalid HCI ACL Data length");
   1aa9e:	4b34      	ldr	r3, [pc, #208]	; (1ab70 <hci_acl_handle+0x120>)
   1aaa0:	e7e1      	b.n	1aa66 <hci_acl_handle+0x16>
	node_tx = ll_tx_mem_acquire();
   1aaa2:	f002 f8fd 	bl	1cca0 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
   1aaa6:	ea4f 3819 	mov.w	r8, r9, lsr #12
	if (!node_tx) {
   1aaaa:	4604      	mov	r4, r0
   1aaac:	bb58      	cbnz	r0, 1ab06 <hci_acl_handle+0xb6>
		BT_ERR("Tx Buffer Overflow");
   1aaae:	2502      	movs	r5, #2
   1aab0:	4b30      	ldr	r3, [pc, #192]	; (1ab74 <hci_acl_handle+0x124>)
   1aab2:	9306      	str	r3, [sp, #24]
   1aab4:	9501      	str	r5, [sp, #4]
   1aab6:	9505      	str	r5, [sp, #20]
   1aab8:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1aabc:	4603      	mov	r3, r0
   1aabe:	aa05      	add	r2, sp, #20
   1aac0:	4829      	ldr	r0, [pc, #164]	; (1ab68 <hci_acl_handle+0x118>)
   1aac2:	f00b f909 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
   1aac6:	4b2c      	ldr	r3, [pc, #176]	; (1ab78 <hci_acl_handle+0x128>)
   1aac8:	681b      	ldr	r3, [r3, #0]
   1aaca:	019b      	lsls	r3, r3, #6
   1aacc:	d404      	bmi.n	1aad8 <hci_acl_handle+0x88>
		return -ENOBUFS;
   1aace:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   1aad2:	b009      	add	sp, #36	; 0x24
   1aad4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1aad8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1aadc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1aae0:	2001      	movs	r0, #1
   1aae2:	f7ea ff31 	bl	5948 <bt_buf_get_rx>
	return net_buf_simple_add(&buf->b, len);
   1aae6:	4629      	mov	r1, r5
   1aae8:	6030      	str	r0, [r6, #0]
   1aaea:	3008      	adds	r0, #8
   1aaec:	f011 f926 	bl	2bd3c <net_buf_simple_add>
	hdr->len = len;
   1aaf0:	2401      	movs	r4, #1
	hdr->evt = evt;
   1aaf2:	231a      	movs	r3, #26
   1aaf4:	7003      	strb	r3, [r0, #0]
	hdr->len = len;
   1aaf6:	7044      	strb	r4, [r0, #1]
   1aaf8:	6830      	ldr	r0, [r6, #0]
   1aafa:	4621      	mov	r1, r4
   1aafc:	3008      	adds	r0, #8
   1aafe:	f011 f91d 	bl	2bd3c <net_buf_simple_add>
	ep->link_type = BT_OVERFLOW_LINK_ACL;
   1ab02:	7004      	strb	r4, [r0, #0]
   1ab04:	e7e3      	b.n	1aace <hci_acl_handle+0x7e>
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
   1ab06:	ea5f 0398 	movs.w	r3, r8, lsr #2
   1ab0a:	d1b7      	bne.n	1aa7c <hci_acl_handle+0x2c>
	switch (bt_acl_flags_pb(flags)) {
   1ab0c:	f1b8 0f00 	cmp.w	r8, #0
   1ab10:	d006      	beq.n	1ab20 <hci_acl_handle+0xd0>
   1ab12:	f1b8 0f01 	cmp.w	r8, #1
   1ab16:	d1b1      	bne.n	1aa7c <hci_acl_handle+0x2c>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1ab18:	7903      	ldrb	r3, [r0, #4]
   1ab1a:	f368 0301 	bfi	r3, r8, #0, #2
   1ab1e:	e003      	b.n	1ab28 <hci_acl_handle+0xd8>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   1ab20:	7903      	ldrb	r3, [r0, #4]
   1ab22:	2202      	movs	r2, #2
   1ab24:	f362 0301 	bfi	r3, r2, #0, #2
	pdu_data->len = len;
   1ab28:	7167      	strb	r7, [r4, #5]
	memcpy(&pdu_data->lldata[0], buf->data, len);
   1ab2a:	68a9      	ldr	r1, [r5, #8]
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1ab2c:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_data->lldata[0], buf->data, len);
   1ab2e:	463a      	mov	r2, r7
   1ab30:	1de0      	adds	r0, r4, #7
   1ab32:	f00c fe9d 	bl	27870 <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
   1ab36:	4621      	mov	r1, r4
   1ab38:	f3c9 000b 	ubfx	r0, r9, #0, #12
   1ab3c:	f002 f8bc 	bl	1ccb8 <ll_tx_mem_enqueue>
   1ab40:	2800      	cmp	r0, #0
   1ab42:	d0c6      	beq.n	1aad2 <hci_acl_handle+0x82>
		BT_ERR("Invalid Tx Enqueue");
   1ab44:	4b0d      	ldr	r3, [pc, #52]	; (1ab7c <hci_acl_handle+0x12c>)
   1ab46:	9306      	str	r3, [sp, #24]
   1ab48:	2302      	movs	r3, #2
   1ab4a:	9301      	str	r3, [sp, #4]
   1ab4c:	9305      	str	r3, [sp, #20]
   1ab4e:	4806      	ldr	r0, [pc, #24]	; (1ab68 <hci_acl_handle+0x118>)
   1ab50:	2300      	movs	r3, #0
   1ab52:	aa05      	add	r2, sp, #20
   1ab54:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   1ab58:	f00b f8be 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		ll_tx_mem_release(node_tx);
   1ab5c:	4620      	mov	r0, r4
   1ab5e:	f002 f8a5 	bl	1ccac <ll_tx_mem_release>
		return -EINVAL;
   1ab62:	e78b      	b.n	1aa7c <hci_acl_handle+0x2c>
   1ab64:	00033e3e 	.word	0x00033e3e
   1ab68:	0002da0c 	.word	0x0002da0c
   1ab6c:	00033e50 	.word	0x00033e50
   1ab70:	00033e6e 	.word	0x00033e6e
   1ab74:	00033e8a 	.word	0x00033e8a
   1ab78:	20000268 	.word	0x20000268
   1ab7c:	00033e9d 	.word	0x00033e9d

0001ab80 <hci_disconn_complete_encode>:
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   1ab80:	4b0d      	ldr	r3, [pc, #52]	; (1abb8 <hci_disconn_complete_encode+0x38>)
   1ab82:	681b      	ldr	r3, [r3, #0]
   1ab84:	06db      	lsls	r3, r3, #27
{
   1ab86:	b570      	push	{r4, r5, r6, lr}
   1ab88:	4605      	mov	r5, r0
   1ab8a:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   1ab8c:	d512      	bpl.n	1abb4 <hci_disconn_complete_encode+0x34>
   1ab8e:	f102 0408 	add.w	r4, r2, #8
   1ab92:	2102      	movs	r1, #2
   1ab94:	4620      	mov	r0, r4
   1ab96:	f011 f8d1 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = evt;
   1ab9a:	2305      	movs	r3, #5
	hdr->len = len;
   1ab9c:	2104      	movs	r1, #4
	hdr->evt = evt;
   1ab9e:	7003      	strb	r3, [r0, #0]
	hdr->len = len;
   1aba0:	7041      	strb	r1, [r0, #1]
   1aba2:	4620      	mov	r0, r4
   1aba4:	f011 f8ca 	bl	2bd3c <net_buf_simple_add>
	ep->status = 0x00;
   1aba8:	2300      	movs	r3, #0
   1abaa:	7003      	strb	r3, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1abac:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->reason = *((uint8_t *)pdu_data);
   1abb0:	782b      	ldrb	r3, [r5, #0]
   1abb2:	70c3      	strb	r3, [r0, #3]
}
   1abb4:	bd70      	pop	{r4, r5, r6, pc}
   1abb6:	bf00      	nop
   1abb8:	20000268 	.word	0x20000268

0001abbc <hci_disconn_complete_process>:
	conn_count--;
   1abbc:	4a02      	ldr	r2, [pc, #8]	; (1abc8 <hci_disconn_complete_process+0xc>)
   1abbe:	6813      	ldr	r3, [r2, #0]
   1abc0:	3b01      	subs	r3, #1
   1abc2:	6013      	str	r3, [r2, #0]
}
   1abc4:	4770      	bx	lr
   1abc6:	bf00      	nop
   1abc8:	20002a38 	.word	0x20002a38

0001abcc <hci_acl_encode>:
	uint16_t handle;
	uint8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
   1abcc:	7f03      	ldrb	r3, [r0, #28]
   1abce:	f003 0303 	and.w	r3, r3, #3
   1abd2:	3b01      	subs	r3, #1
   1abd4:	2b01      	cmp	r3, #1
{
   1abd6:	b570      	push	{r4, r5, r6, lr}
   1abd8:	4604      	mov	r4, r0
	switch (pdu_data->ll_id) {
   1abda:	d81c      	bhi.n	1ac16 <hci_acl_encode+0x4a>
   1abdc:	f101 0508 	add.w	r5, r1, #8
	handle = node_rx->hdr.handle;
   1abe0:	88c6      	ldrh	r6, [r0, #6]
   1abe2:	2104      	movs	r1, #4
   1abe4:	4628      	mov	r0, r5
   1abe6:	f011 f8a9 	bl	2bd3c <net_buf_simple_add>
	case PDU_DATA_LLID_DATA_CONTINUE:
	case PDU_DATA_LLID_DATA_START:
		acl = (void *)net_buf_add(buf, sizeof(*acl));
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
   1abea:	7f23      	ldrb	r3, [r4, #28]
   1abec:	f003 0303 	and.w	r3, r3, #3
   1abf0:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
   1abf2:	bf0c      	ite	eq
   1abf4:	f446 5600 	orreq.w	r6, r6, #8192	; 0x2000
		} else {
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
   1abf8:	f446 5680 	orrne.w	r6, r6, #4096	; 0x1000
		}
		acl->handle = sys_cpu_to_le16(handle_flags);
   1abfc:	8006      	strh	r6, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
   1abfe:	7f61      	ldrb	r1, [r4, #29]
   1ac00:	8041      	strh	r1, [r0, #2]
   1ac02:	4628      	mov	r0, r5
   1ac04:	f011 f89a 	bl	2bd3c <net_buf_simple_add>
		data = (void *)net_buf_add(buf, pdu_data->len);
		memcpy(data, pdu_data->lldata, pdu_data->len);
   1ac08:	7f62      	ldrb	r2, [r4, #29]
   1ac0a:	f104 011f 	add.w	r1, r4, #31

	default:
		LL_ASSERT(0);
		break;
	}
}
   1ac0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
   1ac12:	f00c be2d 	b.w	27870 <memcpy>
		LL_ASSERT(0);
   1ac16:	4a07      	ldr	r2, [pc, #28]	; (1ac34 <hci_acl_encode+0x68>)
   1ac18:	4907      	ldr	r1, [pc, #28]	; (1ac38 <hci_acl_encode+0x6c>)
   1ac1a:	4808      	ldr	r0, [pc, #32]	; (1ac3c <hci_acl_encode+0x70>)
   1ac1c:	f641 53bb 	movw	r3, #7611	; 0x1dbb
   1ac20:	f00a facc 	bl	251bc <printk>
   1ac24:	4040      	eors	r0, r0
   1ac26:	f380 8811 	msr	BASEPRI, r0
   1ac2a:	f04f 0003 	mov.w	r0, #3
   1ac2e:	df02      	svc	2
}
   1ac30:	bd70      	pop	{r4, r5, r6, pc}
   1ac32:	bf00      	nop
   1ac34:	00033eb0 	.word	0x00033eb0
   1ac38:	00031059 	.word	0x00031059
   1ac3c:	0002f8b5 	.word	0x0002f8b5

0001ac40 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   1ac40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct pdu_data *pdu_data = (void *)node_rx->pdu;

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1ac44:	7903      	ldrb	r3, [r0, #4]
	handle = node_rx->hdr.handle;
   1ac46:	88c7      	ldrh	r7, [r0, #6]
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1ac48:	2b03      	cmp	r3, #3
{
   1ac4a:	b08c      	sub	sp, #48	; 0x30
   1ac4c:	4604      	mov	r4, r0
   1ac4e:	460e      	mov	r6, r1
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
   1ac50:	f100 081c 	add.w	r8, r0, #28
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1ac54:	f000 811e 	beq.w	1ae94 <hci_evt_encode+0x254>
	switch (node_rx->hdr.type) {
   1ac58:	2b17      	cmp	r3, #23
   1ac5a:	f000 8113 	beq.w	1ae84 <hci_evt_encode+0x244>
   1ac5e:	d812      	bhi.n	1ac86 <hci_evt_encode+0x46>
   1ac60:	2b05      	cmp	r3, #5
   1ac62:	d03e      	beq.n	1ace2 <hci_evt_encode+0xa2>
   1ac64:	2b16      	cmp	r3, #22
   1ac66:	f000 80bf 	beq.w	1ade8 <hci_evt_encode+0x1a8>
		LL_ASSERT(0);
   1ac6a:	f641 43af 	movw	r3, #7343	; 0x1caf
		LL_ASSERT(0);
   1ac6e:	4aa9      	ldr	r2, [pc, #676]	; (1af14 <hci_evt_encode+0x2d4>)
   1ac70:	49a9      	ldr	r1, [pc, #676]	; (1af18 <hci_evt_encode+0x2d8>)
   1ac72:	48aa      	ldr	r0, [pc, #680]	; (1af1c <hci_evt_encode+0x2dc>)
   1ac74:	f00a faa2 	bl	251bc <printk>
   1ac78:	4040      	eors	r0, r0
   1ac7a:	f380 8811 	msr	BASEPRI, r0
   1ac7e:	f04f 0003 	mov.w	r0, #3
   1ac82:	df02      	svc	2
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
   1ac84:	e078      	b.n	1ad78 <hci_evt_encode+0x138>
	switch (node_rx->hdr.type) {
   1ac86:	2b18      	cmp	r3, #24
   1ac88:	d1ef      	bne.n	1ac6a <hci_evt_encode+0x2a>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ac8a:	4ba5      	ldr	r3, [pc, #660]	; (1af20 <hci_evt_encode+0x2e0>)
   1ac8c:	685b      	ldr	r3, [r3, #4]
   1ac8e:	0098      	lsls	r0, r3, #2
   1ac90:	d572      	bpl.n	1ad78 <hci_evt_encode+0x138>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
   1ac92:	4ba4      	ldr	r3, [pc, #656]	; (1af24 <hci_evt_encode+0x2e4>)
   1ac94:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ac96:	0759      	lsls	r1, r3, #29
   1ac98:	d56e      	bpl.n	1ad78 <hci_evt_encode+0x138>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
   1ac9a:	2209      	movs	r2, #9
   1ac9c:	2103      	movs	r1, #3
   1ac9e:	4630      	mov	r0, r6
   1aca0:	f010 f900 	bl	2aea4 <meta_evt>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   1aca4:	f018 0f01 	tst.w	r8, #1
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
   1aca8:	4605      	mov	r5, r0
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   1acaa:	d00c      	beq.n	1acc6 <hci_evt_encode+0x86>
   1acac:	4a99      	ldr	r2, [pc, #612]	; (1af14 <hci_evt_encode+0x2d4>)
   1acae:	499e      	ldr	r1, [pc, #632]	; (1af28 <hci_evt_encode+0x2e8>)
   1acb0:	489a      	ldr	r0, [pc, #616]	; (1af1c <hci_evt_encode+0x2dc>)
   1acb2:	f641 337a 	movw	r3, #7034	; 0x1b7a
   1acb6:	f00a fa81 	bl	251bc <printk>
   1acba:	4040      	eors	r0, r0
   1acbc:	f380 8811 	msr	BASEPRI, r0
   1acc0:	f04f 0003 	mov.w	r0, #3
   1acc4:	df02      	svc	2
	sep->status = cu->status;
   1acc6:	7f23      	ldrb	r3, [r4, #28]
   1acc8:	702b      	strb	r3, [r5, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
   1acca:	8be3      	ldrh	r3, [r4, #30]
   1accc:	f8a5 3003 	strh.w	r3, [r5, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
   1acd0:	8c23      	ldrh	r3, [r4, #32]
   1acd2:	f8a5 3005 	strh.w	r3, [r5, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   1acd6:	8c63      	ldrh	r3, [r4, #34]	; 0x22
	sep->handle = sys_cpu_to_le16(handle);
   1acd8:	f8a5 7001 	strh.w	r7, [r5, #1]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   1acdc:	f8a5 3007 	strh.w	r3, [r5, #7]
   1ace0:	e04a      	b.n	1ad78 <hci_evt_encode+0x138>
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1ace2:	4b92      	ldr	r3, [pc, #584]	; (1af2c <hci_evt_encode+0x2ec>)
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1ace4:	7e27      	ldrb	r7, [r4, #24]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1ace6:	6818      	ldr	r0, [r3, #0]
   1ace8:	889a      	ldrh	r2, [r3, #4]
   1acea:	799b      	ldrb	r3, [r3, #6]
   1acec:	f88d 301e 	strb.w	r3, [sp, #30]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1acf0:	4b8b      	ldr	r3, [pc, #556]	; (1af20 <hci_evt_encode+0x2e0>)
	direct_report = node_rx->hdr.rx_ftr.direct;
   1acf2:	7e65      	ldrb	r5, [r4, #25]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1acf4:	685b      	ldr	r3, [r3, #4]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1acf6:	9006      	str	r0, [sp, #24]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1acf8:	427f      	negs	r7, r7
	if (direct_report) {
   1acfa:	f015 0501 	ands.w	r5, r5, #1
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1acfe:	f8ad 201c 	strh.w	r2, [sp, #28]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1ad02:	b27f      	sxtb	r7, r7
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ad04:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
	if (direct_report) {
   1ad08:	d039      	beq.n	1ad7e <hci_evt_encode+0x13e>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ad0a:	2b00      	cmp	r3, #0
   1ad0c:	d034      	beq.n	1ad78 <hci_evt_encode+0x138>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
   1ad0e:	4b85      	ldr	r3, [pc, #532]	; (1af24 <hci_evt_encode+0x2e4>)
   1ad10:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ad12:	0559      	lsls	r1, r3, #21
   1ad14:	d530      	bpl.n	1ad78 <hci_evt_encode+0x138>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
   1ad16:	7f23      	ldrb	r3, [r4, #28]
   1ad18:	f003 030f 	and.w	r3, r3, #15
   1ad1c:	2b01      	cmp	r3, #1
   1ad1e:	d00c      	beq.n	1ad3a <hci_evt_encode+0xfa>
   1ad20:	4a7c      	ldr	r2, [pc, #496]	; (1af14 <hci_evt_encode+0x2d4>)
   1ad22:	4983      	ldr	r1, [pc, #524]	; (1af30 <hci_evt_encode+0x2f0>)
   1ad24:	487d      	ldr	r0, [pc, #500]	; (1af1c <hci_evt_encode+0x2dc>)
   1ad26:	f241 435a 	movw	r3, #5210	; 0x145a
   1ad2a:	f00a fa47 	bl	251bc <printk>
   1ad2e:	4040      	eors	r0, r0
   1ad30:	f380 8811 	msr	BASEPRI, r0
   1ad34:	f04f 0003 	mov.w	r0, #3
   1ad38:	df02      	svc	2
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
   1ad3a:	2211      	movs	r2, #17
   1ad3c:	210b      	movs	r1, #11
   1ad3e:	4630      	mov	r0, r6
   1ad40:	f010 f8b0 	bl	2aea4 <meta_evt>
	drp->num_reports = 1U;
   1ad44:	2301      	movs	r3, #1
   1ad46:	7003      	strb	r3, [r0, #0]
	dir_info->evt_type = BT_HCI_ADV_DIRECT_IND;
   1ad48:	7043      	strb	r3, [r0, #1]
		dir_info->addr.type = adv->tx_addr;
   1ad4a:	7f23      	ldrb	r3, [r4, #28]
   1ad4c:	f3c3 1380 	ubfx	r3, r3, #6, #1
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
   1ad50:	4605      	mov	r5, r0
		dir_info->addr.type = adv->tx_addr;
   1ad52:	7083      	strb	r3, [r0, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
   1ad54:	2206      	movs	r2, #6
   1ad56:	f104 011e 	add.w	r1, r4, #30
   1ad5a:	3003      	adds	r0, #3
   1ad5c:	f00c fd88 	bl	27870 <memcpy>
	dir_info->dir_addr.type = adv->rx_addr;
   1ad60:	7f23      	ldrb	r3, [r4, #28]
   1ad62:	f3c3 13c0 	ubfx	r3, r3, #7, #1
   1ad66:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
   1ad68:	2206      	movs	r2, #6
   1ad6a:	f104 0124 	add.w	r1, r4, #36	; 0x24
   1ad6e:	f105 000a 	add.w	r0, r5, #10
   1ad72:	f00c fd7d 	bl	27870 <memcpy>
	dir_info->rssi = rssi;
   1ad76:	742f      	strb	r7, [r5, #16]
}
   1ad78:	b00c      	add	sp, #48	; 0x30
   1ad7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ad7e:	2b00      	cmp	r3, #0
   1ad80:	d0fa      	beq.n	1ad78 <hci_evt_encode+0x138>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
   1ad82:	4b68      	ldr	r3, [pc, #416]	; (1af24 <hci_evt_encode+0x2e4>)
   1ad84:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ad86:	079a      	lsls	r2, r3, #30
   1ad88:	d5f6      	bpl.n	1ad78 <hci_evt_encode+0x138>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
   1ad8a:	7f23      	ldrb	r3, [r4, #28]
   1ad8c:	f003 030f 	and.w	r3, r3, #15
   1ad90:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
   1ad92:	bf1e      	ittt	ne
   1ad94:	7f65      	ldrbne	r5, [r4, #29]
   1ad96:	3d06      	subne	r5, #6
   1ad98:	b2ed      	uxtbne	r5, r5
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   1ad9a:	f105 020b 	add.w	r2, r5, #11
   1ad9e:	b2d2      	uxtb	r2, r2
   1ada0:	2102      	movs	r1, #2
   1ada2:	4630      	mov	r0, r6
   1ada4:	f010 f87e 	bl	2aea4 <meta_evt>
	sep->num_reports = 1U;
   1ada8:	2301      	movs	r3, #1
   1adaa:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
   1adac:	7f23      	ldrb	r3, [r4, #28]
   1adae:	aa0c      	add	r2, sp, #48	; 0x30
   1adb0:	f003 030f 	and.w	r3, r3, #15
   1adb4:	4413      	add	r3, r2
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   1adb6:	4606      	mov	r6, r0
	adv_info->evt_type = c_adv_type[adv->type];
   1adb8:	f813 3c18 	ldrb.w	r3, [r3, #-24]
   1adbc:	7043      	strb	r3, [r0, #1]
		adv_info->addr.type = adv->tx_addr;
   1adbe:	7f23      	ldrb	r3, [r4, #28]
   1adc0:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1adc4:	7083      	strb	r3, [r0, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
   1adc6:	2206      	movs	r2, #6
   1adc8:	f104 011e 	add.w	r1, r4, #30
   1adcc:	3003      	adds	r0, #3
   1adce:	f00c fd4f 	bl	27870 <memcpy>
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   1add2:	360a      	adds	r6, #10
	adv_info->length = data_len;
   1add4:	f806 5c01 	strb.w	r5, [r6, #-1]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   1add8:	462a      	mov	r2, r5
   1adda:	f104 0124 	add.w	r1, r4, #36	; 0x24
   1adde:	4630      	mov	r0, r6
   1ade0:	f00c fd46 	bl	27870 <memcpy>
	*prssi = rssi;
   1ade4:	5577      	strb	r7, [r6, r5]
   1ade6:	e7c7      	b.n	1ad78 <hci_evt_encode+0x138>
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cc));
   1ade8:	f018 0f01 	tst.w	r8, #1
   1adec:	d00c      	beq.n	1ae08 <hci_evt_encode+0x1c8>
   1adee:	4a49      	ldr	r2, [pc, #292]	; (1af14 <hci_evt_encode+0x2d4>)
   1adf0:	4950      	ldr	r1, [pc, #320]	; (1af34 <hci_evt_encode+0x2f4>)
   1adf2:	484a      	ldr	r0, [pc, #296]	; (1af1c <hci_evt_encode+0x2dc>)
   1adf4:	f641 23f5 	movw	r3, #6901	; 0x1af5
   1adf8:	f00a f9e0 	bl	251bc <printk>
   1adfc:	4040      	eors	r0, r0
   1adfe:	f380 8811 	msr	BASEPRI, r0
   1ae02:	f04f 0003 	mov.w	r0, #3
   1ae06:	df02      	svc	2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ae08:	4b45      	ldr	r3, [pc, #276]	; (1af20 <hci_evt_encode+0x2e0>)
   1ae0a:	685b      	ldr	r3, [r3, #4]
   1ae0c:	009b      	lsls	r3, r3, #2
   1ae0e:	d5b3      	bpl.n	1ad78 <hci_evt_encode+0x138>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   1ae10:	4b44      	ldr	r3, [pc, #272]	; (1af24 <hci_evt_encode+0x2e4>)
   1ae12:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1ae14:	07dd      	lsls	r5, r3, #31
   1ae16:	d5af      	bpl.n	1ad78 <hci_evt_encode+0x138>
	status = cc->status;
   1ae18:	f894 801c 	ldrb.w	r8, [r4, #28]
	if (!status) {
   1ae1c:	f1b8 0f00 	cmp.w	r8, #0
   1ae20:	d103      	bne.n	1ae2a <hci_evt_encode+0x1ea>
		conn_count++;
   1ae22:	4a45      	ldr	r2, [pc, #276]	; (1af38 <hci_evt_encode+0x2f8>)
   1ae24:	6813      	ldr	r3, [r2, #0]
   1ae26:	3301      	adds	r3, #1
   1ae28:	6013      	str	r3, [r2, #0]
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
   1ae2a:	2212      	movs	r2, #18
   1ae2c:	2101      	movs	r1, #1
   1ae2e:	4630      	mov	r0, r6
   1ae30:	f010 f838 	bl	2aea4 <meta_evt>
   1ae34:	4605      	mov	r5, r0
	if (status) {
   1ae36:	f1b8 0f00 	cmp.w	r8, #0
   1ae3a:	d006      	beq.n	1ae4a <hci_evt_encode+0x20a>
		(void)memset(lecc, 0x00, sizeof(*lecc));
   1ae3c:	2212      	movs	r2, #18
   1ae3e:	2100      	movs	r1, #0
   1ae40:	f00c fd21 	bl	27886 <memset>
		lecc->status = status;
   1ae44:	f885 8000 	strb.w	r8, [r5]
		return;
   1ae48:	e796      	b.n	1ad78 <hci_evt_encode+0x138>
	lecc->status = 0x00;
   1ae4a:	f880 8000 	strb.w	r8, [r0]
	lecc->handle = sys_cpu_to_le16(handle);
   1ae4e:	f8a0 7001 	strh.w	r7, [r0, #1]
	lecc->role = cc->role;
   1ae52:	7f63      	ldrb	r3, [r4, #29]
   1ae54:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = cc->peer_addr_type & 0x1;
   1ae56:	7fa3      	ldrb	r3, [r4, #30]
   1ae58:	f003 0301 	and.w	r3, r3, #1
   1ae5c:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &cc->peer_addr[0], BDADDR_SIZE);
   1ae5e:	2206      	movs	r2, #6
   1ae60:	f104 011f 	add.w	r1, r4, #31
   1ae64:	3005      	adds	r0, #5
   1ae66:	f00c fd03 	bl	27870 <memcpy>
	lecc->interval = sys_cpu_to_le16(cc->interval);
   1ae6a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1ae6c:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(cc->latency);
   1ae70:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   1ae72:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(cc->timeout);
   1ae76:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   1ae78:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = cc->sca;
   1ae7c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
   1ae80:	746b      	strb	r3, [r5, #17]
   1ae82:	e779      	b.n	1ad78 <hci_evt_encode+0x138>
		hci_disconn_complete_encode(pdu_data, handle, buf);
   1ae84:	460a      	mov	r2, r1
   1ae86:	4640      	mov	r0, r8
   1ae88:	4639      	mov	r1, r7
}
   1ae8a:	b00c      	add	sp, #48	; 0x30
   1ae8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		hci_disconn_complete_encode(pdu_data, handle, buf);
   1ae90:	f7ff be76 	b.w	1ab80 <hci_disconn_complete_encode>
	switch (pdu_data->llctrl.opcode) {
   1ae94:	7fc3      	ldrb	r3, [r0, #31]
   1ae96:	3b07      	subs	r3, #7
   1ae98:	2b0a      	cmp	r3, #10
   1ae9a:	d861      	bhi.n	1af60 <hci_evt_encode+0x320>
   1ae9c:	e8df f003 	tbb	[pc, r3]
   1aea0:	60066030 	.word	0x60066030
   1aea4:	60606060 	.word	0x60606060
   1aea8:	600f      	.short	0x600f
   1aeaa:	5c          	.byte	0x5c
   1aeab:	00          	.byte	0x00
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
   1aeac:	460b      	mov	r3, r1
   1aeae:	463a      	mov	r2, r7
   1aeb0:	4641      	mov	r1, r8
   1aeb2:	2000      	movs	r0, #0
}
   1aeb4:	b00c      	add	sp, #48	; 0x30
   1aeb6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   1aeba:	f7ff ba8f 	b.w	1a3dc <le_remote_feat_complete>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1aebe:	4b18      	ldr	r3, [pc, #96]	; (1af20 <hci_evt_encode+0x2e0>)
   1aec0:	685b      	ldr	r3, [r3, #4]
   1aec2:	009a      	lsls	r2, r3, #2
   1aec4:	d503      	bpl.n	1aece <hci_evt_encode+0x28e>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
   1aec6:	4b17      	ldr	r3, [pc, #92]	; (1af24 <hci_evt_encode+0x2e4>)
   1aec8:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1aeca:	069b      	lsls	r3, r3, #26
   1aecc:	d409      	bmi.n	1aee2 <hci_evt_encode+0x2a2>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
   1aece:	2300      	movs	r3, #0
   1aed0:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1aed4:	9300      	str	r3, [sp, #0]
   1aed6:	221a      	movs	r2, #26
   1aed8:	2102      	movs	r1, #2
   1aeda:	4638      	mov	r0, r7
   1aedc:	f010 fa3f 	bl	2b35e <ll_conn_update>
		return;
   1aee0:	e74a      	b.n	1ad78 <hci_evt_encode+0x138>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
   1aee2:	220a      	movs	r2, #10
   1aee4:	2106      	movs	r1, #6
   1aee6:	4630      	mov	r0, r6
   1aee8:	f00f ffdc 	bl	2aea4 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   1aeec:	8007      	strh	r7, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
   1aeee:	8c23      	ldrh	r3, [r4, #32]
   1aef0:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
   1aef2:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1aef4:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
   1aef6:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1aef8:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
   1aefa:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1aefc:	8103      	strh	r3, [r0, #8]
   1aefe:	e73b      	b.n	1ad78 <hci_evt_encode+0x138>
		le_unknown_rsp(pdu_data, handle, buf);
   1af00:	f890 3020 	ldrb.w	r3, [r0, #32]
	switch (pdu_data->llctrl.unknown_rsp.type) {
   1af04:	2b0e      	cmp	r3, #14
   1af06:	d119      	bne.n	1af3c <hci_evt_encode+0x2fc>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   1af08:	460b      	mov	r3, r1
   1af0a:	463a      	mov	r2, r7
   1af0c:	2100      	movs	r1, #0
   1af0e:	201a      	movs	r0, #26
   1af10:	e7d0      	b.n	1aeb4 <hci_evt_encode+0x274>
   1af12:	bf00      	nop
   1af14:	00033eb0 	.word	0x00033eb0
   1af18:	00031059 	.word	0x00031059
   1af1c:	0002f8b5 	.word	0x0002f8b5
   1af20:	20000268 	.word	0x20000268
   1af24:	20000270 	.word	0x20000270
   1af28:	00033f48 	.word	0x00033f48
   1af2c:	0002dd67 	.word	0x0002dd67
   1af30:	00033ee9 	.word	0x00033ee9
   1af34:	00033f0e 	.word	0x00033f0e
   1af38:	20002a38 	.word	0x20002a38
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
   1af3c:	4a0a      	ldr	r2, [pc, #40]	; (1af68 <hci_evt_encode+0x328>)
		BT_WARN("reject opcode: 0x%02x", pdu->llctrl.reject_ext_ind.reject_opcode);
   1af3e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   1af42:	2303      	movs	r3, #3
   1af44:	9305      	str	r3, [sp, #20]
   1af46:	9309      	str	r3, [sp, #36]	; 0x24
   1af48:	4808      	ldr	r0, [pc, #32]	; (1af6c <hci_evt_encode+0x32c>)
   1af4a:	2300      	movs	r3, #0
   1af4c:	aa09      	add	r2, sp, #36	; 0x24
   1af4e:	f44f 51c4 	mov.w	r1, #6272	; 0x1880
   1af52:	f00a fec1 	bl	25cd8 <z_impl_z_log_msg2_static_create>
}
   1af56:	e70f      	b.n	1ad78 <hci_evt_encode+0x138>
	switch (pdu->llctrl.reject_ext_ind.reject_opcode) {
   1af58:	f890 3020 	ldrb.w	r3, [r0, #32]
		BT_WARN("reject opcode: 0x%02x", pdu->llctrl.reject_ext_ind.reject_opcode);
   1af5c:	4a04      	ldr	r2, [pc, #16]	; (1af70 <hci_evt_encode+0x330>)
   1af5e:	e7ee      	b.n	1af3e <hci_evt_encode+0x2fe>
		LL_ASSERT(0);
   1af60:	f641 538f 	movw	r3, #7567	; 0x1d8f
   1af64:	e683      	b.n	1ac6e <hci_evt_encode+0x2e>
   1af66:	bf00      	nop
   1af68:	0003364d 	.word	0x0003364d
   1af6c:	0002da0c 	.word	0x0002da0c
   1af70:	00033f82 	.word	0x00033f82

0001af74 <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1af74:	7903      	ldrb	r3, [r0, #4]
   1af76:	2b03      	cmp	r3, #3
   1af78:	d006      	beq.n	1af88 <hci_get_class+0x14>

		switch (node_rx->hdr.type) {
   1af7a:	3b05      	subs	r3, #5
   1af7c:	b2db      	uxtb	r3, r3
   1af7e:	2b13      	cmp	r3, #19
   1af80:	d80a      	bhi.n	1af98 <hci_get_class+0x24>
   1af82:	4a06      	ldr	r2, [pc, #24]	; (1af9c <hci_get_class+0x28>)
   1af84:	5cd0      	ldrb	r0, [r2, r3]
   1af86:	4770      	bx	lr
		default:
			return HCI_CLASS_NONE;
		}

#if defined(CONFIG_BT_CONN)
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   1af88:	7f03      	ldrb	r3, [r0, #28]
   1af8a:	f003 0303 	and.w	r3, r3, #3
		return HCI_CLASS_EVT_LLCP;
	} else {
		return HCI_CLASS_ACL_DATA;
   1af8e:	2b03      	cmp	r3, #3
   1af90:	bf0c      	ite	eq
   1af92:	2004      	moveq	r0, #4
   1af94:	2005      	movne	r0, #5
   1af96:	4770      	bx	lr
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1af98:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
   1af9a:	4770      	bx	lr
   1af9c:	00033fa4 	.word	0x00033fa4

0001afa0 <hci_init>:
	event_mask = DEFAULT_EVENT_MASK;
   1afa0:	4b07      	ldr	r3, [pc, #28]	; (1afc0 <hci_init+0x20>)
   1afa2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1afa6:	f641 71ff 	movw	r1, #8191	; 0x1fff
   1afaa:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   1afae:	4b05      	ldr	r3, [pc, #20]	; (1afc4 <hci_init+0x24>)
   1afb0:	201f      	movs	r0, #31
   1afb2:	2100      	movs	r1, #0
   1afb4:	e9c3 0100 	strd	r0, r1, [r3]
	conn_count = 0U;
   1afb8:	4b03      	ldr	r3, [pc, #12]	; (1afc8 <hci_init+0x28>)
   1afba:	2200      	movs	r2, #0
   1afbc:	601a      	str	r2, [r3, #0]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
   1afbe:	4770      	bx	lr
   1afc0:	20000268 	.word	0x20000268
   1afc4:	20000270 	.word	0x20000270
   1afc8:	20002a38 	.word	0x20002a38

0001afcc <ll_rx_link_inc_quota>:
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   1afcc:	2801      	cmp	r0, #1
{
   1afce:	b538      	push	{r3, r4, r5, lr}
   1afd0:	4d0b      	ldr	r5, [pc, #44]	; (1b000 <ll_rx_link_inc_quota+0x34>)
   1afd2:	4604      	mov	r4, r0
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   1afd4:	d10f      	bne.n	1aff6 <ll_rx_link_inc_quota+0x2a>
   1afd6:	782b      	ldrb	r3, [r5, #0]
   1afd8:	2b04      	cmp	r3, #4
   1afda:	d90c      	bls.n	1aff6 <ll_rx_link_inc_quota+0x2a>
   1afdc:	4a09      	ldr	r2, [pc, #36]	; (1b004 <ll_rx_link_inc_quota+0x38>)
   1afde:	490a      	ldr	r1, [pc, #40]	; (1b008 <ll_rx_link_inc_quota+0x3c>)
   1afe0:	480a      	ldr	r0, [pc, #40]	; (1b00c <ll_rx_link_inc_quota+0x40>)
   1afe2:	f240 6306 	movw	r3, #1542	; 0x606
   1afe6:	f00a f8e9 	bl	251bc <printk>
   1afea:	4040      	eors	r0, r0
   1afec:	f380 8811 	msr	BASEPRI, r0
   1aff0:	f04f 0003 	mov.w	r0, #3
   1aff4:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   1aff6:	7828      	ldrb	r0, [r5, #0]
   1aff8:	4404      	add	r4, r0
   1affa:	702c      	strb	r4, [r5, #0]
}
   1affc:	bd38      	pop	{r3, r4, r5, pc}
   1affe:	bf00      	nop
   1b000:	20002aa0 	.word	0x20002aa0
   1b004:	00033fd7 	.word	0x00033fd7
   1b008:	00034012 	.word	0x00034012
   1b00c:	0002f8b5 	.word	0x0002f8b5

0001b010 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
   1b010:	b510      	push	{r4, lr}
   1b012:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
   1b014:	f010 faf4 	bl	2b600 <lll_reset>
	LL_ASSERT(!err);
   1b018:	b160      	cbz	r0, 1b034 <perform_lll_reset+0x24>
   1b01a:	4a21      	ldr	r2, [pc, #132]	; (1b0a0 <perform_lll_reset+0x90>)
   1b01c:	4921      	ldr	r1, [pc, #132]	; (1b0a4 <perform_lll_reset+0x94>)
   1b01e:	4822      	ldr	r0, [pc, #136]	; (1b0a8 <perform_lll_reset+0x98>)
   1b020:	f640 0324 	movw	r3, #2084	; 0x824
   1b024:	f00a f8ca 	bl	251bc <printk>
   1b028:	4040      	eors	r0, r0
   1b02a:	f380 8811 	msr	BASEPRI, r0
   1b02e:	f04f 0003 	mov.w	r0, #3
   1b032:	df02      	svc	2

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
   1b034:	f010 fb41 	bl	2b6ba <lll_adv_reset>
	LL_ASSERT(!err);
   1b038:	b160      	cbz	r0, 1b054 <perform_lll_reset+0x44>
   1b03a:	4a19      	ldr	r2, [pc, #100]	; (1b0a0 <perform_lll_reset+0x90>)
   1b03c:	4919      	ldr	r1, [pc, #100]	; (1b0a4 <perform_lll_reset+0x94>)
   1b03e:	481a      	ldr	r0, [pc, #104]	; (1b0a8 <perform_lll_reset+0x98>)
   1b040:	f640 0329 	movw	r3, #2089	; 0x829
   1b044:	f00a f8ba 	bl	251bc <printk>
   1b048:	4040      	eors	r0, r0
   1b04a:	f380 8811 	msr	BASEPRI, r0
   1b04e:	f04f 0003 	mov.w	r0, #3
   1b052:	df02      	svc	2
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
   1b054:	f010 fc55 	bl	2b902 <lll_scan_reset>
	LL_ASSERT(!err);
   1b058:	b160      	cbz	r0, 1b074 <perform_lll_reset+0x64>
   1b05a:	4a11      	ldr	r2, [pc, #68]	; (1b0a0 <perform_lll_reset+0x90>)
   1b05c:	4911      	ldr	r1, [pc, #68]	; (1b0a4 <perform_lll_reset+0x94>)
   1b05e:	4812      	ldr	r0, [pc, #72]	; (1b0a8 <perform_lll_reset+0x98>)
   1b060:	f640 032f 	movw	r3, #2095	; 0x82f
   1b064:	f00a f8aa 	bl	251bc <printk>
   1b068:	4040      	eors	r0, r0
   1b06a:	f380 8811 	msr	BASEPRI, r0
   1b06e:	f04f 0003 	mov.w	r0, #3
   1b072:	df02      	svc	2
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CONN)
	/* Reset conn role */
	err = lll_conn_reset();
   1b074:	f010 fc51 	bl	2b91a <lll_conn_reset>
	LL_ASSERT(!err);
   1b078:	b160      	cbz	r0, 1b094 <perform_lll_reset+0x84>
   1b07a:	4a09      	ldr	r2, [pc, #36]	; (1b0a0 <perform_lll_reset+0x90>)
   1b07c:	4909      	ldr	r1, [pc, #36]	; (1b0a4 <perform_lll_reset+0x94>)
   1b07e:	480a      	ldr	r0, [pc, #40]	; (1b0a8 <perform_lll_reset+0x98>)
   1b080:	f640 0335 	movw	r3, #2101	; 0x835
   1b084:	f00a f89a 	bl	251bc <printk>
   1b088:	4040      	eors	r0, r0
   1b08a:	f380 8811 	msr	BASEPRI, r0
   1b08e:	f04f 0003 	mov.w	r0, #3
   1b092:	df02      	svc	2
	z_impl_k_sem_give(sem);
   1b094:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CTLR_DF */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
   1b096:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1b09a:	f008 bf5b 	b.w	23f54 <z_impl_k_sem_give>
   1b09e:	bf00      	nop
   1b0a0:	00033fd7 	.word	0x00033fd7
   1b0a4:	0003404c 	.word	0x0003404c
   1b0a8:	0002f8b5 	.word	0x0002f8b5

0001b0ac <rx_alloc>:
{
	return m;
}

static inline void rx_alloc(uint8_t max)
{
   1b0ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t idx;

	if (max > mem_link_rx.quota_pdu) {
   1b0b0:	4e34      	ldr	r6, [pc, #208]	; (1b184 <rx_alloc+0xd8>)
		max = mem_link_rx.quota_pdu;
	}

	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   1b0b2:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 1b188 <rx_alloc+0xdc>
   1b0b6:	46b0      	mov	r8, r6
   1b0b8:	f818 7b04 	ldrb.w	r7, [r8], #4
   1b0bc:	4287      	cmp	r7, r0
   1b0be:	bf28      	it	cs
   1b0c0:	4607      	movcs	r7, r0
   1b0c2:	2f00      	cmp	r7, #0
   1b0c4:	d05b      	beq.n	1b17e <rx_alloc+0xd2>
 */
static inline bool mfifo_enqueue_idx_get(uint8_t count, uint8_t first, uint8_t last,
					 uint8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
   1b0c6:	f899 4003 	ldrb.w	r4, [r9, #3]
	if (last == count) {
   1b0ca:	f899 2001 	ldrb.w	r2, [r9, #1]
   1b0ce:	f899 3002 	ldrb.w	r3, [r9, #2]
	last = last + 1;
   1b0d2:	3401      	adds	r4, #1
   1b0d4:	b2e4      	uxtb	r4, r4
		last = 0U;
   1b0d6:	42a2      	cmp	r2, r4
   1b0d8:	bf08      	it	eq
   1b0da:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
   1b0dc:	42a3      	cmp	r3, r4
   1b0de:	d148      	bne.n	1b172 <rx_alloc+0xc6>

	/* Replenish the ULL to LL/HCI free Rx PDU queue after LLL to ULL free
	 * Rx PDU queue has been filled.
	 */
	while (mem_link_rx.quota_pdu &&
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   1b0e0:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 1b18c <rx_alloc+0xe0>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   1b0e4:	4f2a      	ldr	r7, [pc, #168]	; (1b190 <rx_alloc+0xe4>)
	while (mem_link_rx.quota_pdu &&
   1b0e6:	7833      	ldrb	r3, [r6, #0]
   1b0e8:	2b00      	cmp	r3, #0
   1b0ea:	d048      	beq.n	1b17e <rx_alloc+0xd2>
	last = last + 1;
   1b0ec:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
   1b0f0:	f898 2001 	ldrb.w	r2, [r8, #1]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   1b0f4:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
   1b0f8:	3401      	adds	r4, #1
   1b0fa:	b2e4      	uxtb	r4, r4
		last = 0U;
   1b0fc:	42a2      	cmp	r2, r4
   1b0fe:	bf08      	it	eq
   1b100:	2400      	moveq	r4, #0
	if (last == first) {
   1b102:	429c      	cmp	r4, r3
   1b104:	d03b      	beq.n	1b17e <rx_alloc+0xd2>
		link = mem_acquire(&mem_link_rx.free);
   1b106:	4638      	mov	r0, r7
   1b108:	f00f fb82 	bl	2a810 <mem_acquire>
		if (!link) {
   1b10c:	4605      	mov	r5, r0
   1b10e:	2800      	cmp	r0, #0
   1b110:	d035      	beq.n	1b17e <rx_alloc+0xd2>
			return;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
   1b112:	4820      	ldr	r0, [pc, #128]	; (1b194 <rx_alloc+0xe8>)
   1b114:	f00f fb7c 	bl	2a810 <mem_acquire>
		if (!rx) {
   1b118:	b1a0      	cbz	r0, 1b144 <rx_alloc+0x98>
			mem_release(link, &mem_link_rx.free);
			return;
		}

		link->mem = NULL;
   1b11a:	2300      	movs	r3, #0
   1b11c:	606b      	str	r3, [r5, #4]
		rx->link = link;
   1b11e:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(uint8_t *fifo, uint8_t size, uint8_t idx,
					void *mem, uint8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1b120:	f898 2003 	ldrb.w	r2, [r8, #3]
   1b124:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1b128:	fb02 8303 	mla	r3, r2, r3, r8
   1b12c:	6058      	str	r0, [r3, #4]

		MFIFO_BY_IDX_ENQUEUE(ll_pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
   1b12e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	cpu_dmb(); /* Ensure data accesses are synchronized */
	*last = idx; /* Commit: Update write index */
   1b132:	f888 4003 	strb.w	r4, [r8, #3]
   1b136:	f7ff ff49 	bl	1afcc <ll_rx_link_inc_quota>
   1b13a:	e7d4      	b.n	1b0e6 <rx_alloc+0x3a>
		rx = mem_acquire(&mem_pdu_rx.free);
   1b13c:	4815      	ldr	r0, [pc, #84]	; (1b194 <rx_alloc+0xe8>)
   1b13e:	f00f fb67 	bl	2a810 <mem_acquire>
		if (!rx) {
   1b142:	b928      	cbnz	r0, 1b150 <rx_alloc+0xa4>
			mem_release(link, &mem_link_rx.free);
   1b144:	4628      	mov	r0, r5
   1b146:	4912      	ldr	r1, [pc, #72]	; (1b190 <rx_alloc+0xe4>)
	}
#endif /* CONFIG_BT_CONN */
}
   1b148:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
   1b14c:	f00f bb79 	b.w	2a842 <mem_release>
		rx->link = link;
   1b150:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1b152:	f899 2003 	ldrb.w	r2, [r9, #3]
   1b156:	f899 3000 	ldrb.w	r3, [r9]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1b15a:	fb02 9303 	mla	r3, r2, r3, r9
   1b15e:	6058      	str	r0, [r3, #4]
		ll_rx_link_inc_quota(-1);
   1b160:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		max--;
   1b164:	3f01      	subs	r7, #1
	*last = idx; /* Commit: Update write index */
   1b166:	f889 4003 	strb.w	r4, [r9, #3]
   1b16a:	b2ff      	uxtb	r7, r7
		ll_rx_link_inc_quota(-1);
   1b16c:	f7ff ff2e 	bl	1afcc <ll_rx_link_inc_quota>
		max--;
   1b170:	e7a7      	b.n	1b0c2 <rx_alloc+0x16>
		link = mem_acquire(&mem_link_rx.free);
   1b172:	4640      	mov	r0, r8
   1b174:	f00f fb4c 	bl	2a810 <mem_acquire>
		if (!link) {
   1b178:	4605      	mov	r5, r0
   1b17a:	2800      	cmp	r0, #0
   1b17c:	d1de      	bne.n	1b13c <rx_alloc+0x90>
}
   1b17e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b182:	bf00      	nop
   1b184:	20002aa0 	.word	0x20002aa0
   1b188:	2000086c 	.word	0x2000086c
   1b18c:	20000860 	.word	0x20000860
   1b190:	20002aa4 	.word	0x20002aa4
   1b194:	20002af0 	.word	0x20002af0

0001b198 <tx_cmplt_get>:
}
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL */

#if defined(CONFIG_BT_CONN)
static uint8_t tx_cmplt_get(uint16_t *handle, uint8_t *first, uint8_t last)
{
   1b198:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b19c:	460c      	mov	r4, r1
	struct lll_tx *tx;
	uint8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1b19e:	4e29      	ldr	r6, [pc, #164]	; (1b244 <tx_cmplt_get+0xac>)
					   uint8_t first, uint8_t last, uint8_t *idx)
{
	void *p;
	uint8_t i;

	if (*idx >= count) {
   1b1a0:	7823      	ldrb	r3, [r4, #0]
   1b1a2:	7871      	ldrb	r1, [r6, #1]
   1b1a4:	428b      	cmp	r3, r1
   1b1a6:	bf28      	it	cs
   1b1a8:	78b3      	ldrbcs	r3, [r6, #2]
{
   1b1aa:	4607      	mov	r7, r0
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1b1ac:	7830      	ldrb	r0, [r6, #0]
		*idx = first;
   1b1ae:	bf28      	it	cs
   1b1b0:	7023      	strbcs	r3, [r4, #0]
	}

	if (*idx == last) {
   1b1b2:	7823      	ldrb	r3, [r4, #0]
   1b1b4:	429a      	cmp	r2, r3
{
   1b1b6:	4691      	mov	r9, r2
   1b1b8:	d042      	beq.n	1b240 <tx_cmplt_get+0xa8>
		return NULL;
	}

	i = *idx + 1;
   1b1ba:	1c5a      	adds	r2, r3, #1
   1b1bc:	b2d2      	uxtb	r2, r2
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
   1b1be:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1b248 <tx_cmplt_get+0xb0>
   1b1c2:	fb13 f300 	smulbb	r3, r3, r0
		i = 0U;
   1b1c6:	4291      	cmp	r1, r2
   1b1c8:	bf08      	it	eq
   1b1ca:	2200      	moveq	r2, #0

	*idx = i;
   1b1cc:	7022      	strb	r2, [r4, #0]
	p = (void *)(fifo + (*idx) * size);
   1b1ce:	eb08 0c03 	add.w	ip, r8, r3
				    first);
	if (!tx) {
		return 0;
	}

	*handle = tx->handle;
   1b1d2:	f838 3003 	ldrh.w	r3, [r8, r3]
   1b1d6:	803b      	strh	r3, [r7, #0]
	cmplt = 0U;
   1b1d8:	2500      	movs	r5, #0
	do {
		struct node_tx *node_tx;
		struct pdu_data *p;

		node_tx = tx->node;
   1b1da:	f8dc 0004 	ldr.w	r0, [ip, #4]
		p = (void *)node_tx->pdu;
		if (!node_tx || (node_tx == (void *)1) ||
   1b1de:	2801      	cmp	r0, #1
		    (((uint32_t)node_tx & ~3) &&
   1b1e0:	f020 0203 	bic.w	r2, r0, #3
		if (!node_tx || (node_tx == (void *)1) ||
   1b1e4:	d906      	bls.n	1b1f4 <tx_cmplt_get+0x5c>
   1b1e6:	b34a      	cbz	r2, 1b23c <tx_cmplt_get+0xa4>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
   1b1e8:	7903      	ldrb	r3, [r0, #4]
   1b1ea:	f003 0303 	and.w	r3, r3, #3
		    (((uint32_t)node_tx & ~3) &&
   1b1ee:	3b01      	subs	r3, #1
   1b1f0:	2b01      	cmp	r3, #1
   1b1f2:	d823      	bhi.n	1b23c <tx_cmplt_get+0xa4>
		      p->ll_id == PDU_DATA_LLID_DATA_CONTINUE))) {
			/* data packet, hence count num cmplt */
			tx->node = (void *)1;
			cmplt++;
   1b1f4:	3501      	adds	r5, #1
   1b1f6:	b2ed      	uxtb	r5, r5
			tx->node = (void *)1;
   1b1f8:	2301      	movs	r3, #1
   1b1fa:	f8cc 3004 	str.w	r3, [ip, #4]
		} else {
			/* ctrl packet or flushed, hence dont count num cmplt */
			tx->node = (void *)2;
		}

		if (((uint32_t)node_tx & ~3)) {
   1b1fe:	b10a      	cbz	r2, 1b204 <tx_cmplt_get+0x6c>
			ll_tx_mem_release(node_tx);
   1b200:	f001 fd54 	bl	1ccac <ll_tx_mem_release>
	if (*idx >= count) {
   1b204:	7823      	ldrb	r3, [r4, #0]
		}

		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1b206:	7872      	ldrb	r2, [r6, #1]
   1b208:	7830      	ldrb	r0, [r6, #0]
   1b20a:	4293      	cmp	r3, r2
   1b20c:	bf24      	itt	cs
   1b20e:	78b3      	ldrbcs	r3, [r6, #2]
		*idx = first;
   1b210:	7023      	strbcs	r3, [r4, #0]
	if (*idx == last) {
   1b212:	7823      	ldrb	r3, [r4, #0]
   1b214:	4599      	cmp	r9, r3
   1b216:	d00e      	beq.n	1b236 <tx_cmplt_get+0x9e>
	i = *idx + 1;
   1b218:	1c59      	adds	r1, r3, #1
   1b21a:	b2c9      	uxtb	r1, r1
		i = 0U;
   1b21c:	428a      	cmp	r2, r1
   1b21e:	bf08      	it	eq
   1b220:	2100      	moveq	r1, #0
	p = (void *)(fifo + (*idx) * size);
   1b222:	fb13 f300 	smulbb	r3, r3, r0
	*idx = i;
   1b226:	7021      	strb	r1, [r4, #0]
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);
   1b228:	f838 2003 	ldrh.w	r2, [r8, r3]
	p = (void *)(fifo + (*idx) * size);
   1b22c:	eb08 0c03 	add.w	ip, r8, r3
   1b230:	883b      	ldrh	r3, [r7, #0]
   1b232:	429a      	cmp	r2, r3
   1b234:	d0d1      	beq.n	1b1da <tx_cmplt_get+0x42>

	return cmplt;
}
   1b236:	4628      	mov	r0, r5
   1b238:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			tx->node = (void *)2;
   1b23c:	2302      	movs	r3, #2
   1b23e:	e7dc      	b.n	1b1fa <tx_cmplt_get+0x62>
		return 0;
   1b240:	2500      	movs	r5, #0
   1b242:	e7f8      	b.n	1b236 <tx_cmplt_get+0x9e>
   1b244:	20000988 	.word	0x20000988
   1b248:	2000098c 	.word	0x2000098c

0001b24c <ull_ticker_status_give>:
	*((uint32_t volatile *)param) = status;
   1b24c:	6008      	str	r0, [r1, #0]
   1b24e:	4801      	ldr	r0, [pc, #4]	; (1b254 <ull_ticker_status_give+0x8>)
   1b250:	f008 be80 	b.w	23f54 <z_impl_k_sem_give>
   1b254:	20002cec 	.word	0x20002cec

0001b258 <ll_rx_get>:
{
   1b258:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1b25c:	4f26      	ldr	r7, [pc, #152]	; (1b2f8 <ll_rx_get+0xa0>)
   1b25e:	f8df 809c 	ldr.w	r8, [pc, #156]	; 1b2fc <ll_rx_get+0xa4>
{
   1b262:	4605      	mov	r5, r0
   1b264:	460c      	mov	r4, r1
	*node_rx = NULL;
   1b266:	2300      	movs	r3, #0
   1b268:	602b      	str	r3, [r5, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1b26a:	e9d7 0100 	ldrd	r0, r1, [r7]
   1b26e:	aa01      	add	r2, sp, #4
   1b270:	f00f fb33 	bl	2a8da <memq_peek>
	if (link) {
   1b274:	4606      	mov	r6, r0
   1b276:	2800      	cmp	r0, #0
   1b278:	d036      	beq.n	1b2e8 <ll_rx_get+0x90>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   1b27a:	9b01      	ldr	r3, [sp, #4]
   1b27c:	4920      	ldr	r1, [pc, #128]	; (1b300 <ll_rx_get+0xa8>)
   1b27e:	781a      	ldrb	r2, [r3, #0]
   1b280:	4620      	mov	r0, r4
   1b282:	f7ff ff89 	bl	1b198 <tx_cmplt_get>
		if (!cmplt) {
   1b286:	bb60      	cbnz	r0, 1b2e2 <ll_rx_get+0x8a>
			f = mfifo_tx_ack.f;
   1b288:	f898 3002 	ldrb.w	r3, [r8, #2]
   1b28c:	f88d 3001 	strb.w	r3, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
   1b290:	f898 2003 	ldrb.w	r2, [r8, #3]
   1b294:	4681      	mov	r9, r0
   1b296:	f10d 0101 	add.w	r1, sp, #1
   1b29a:	f10d 0002 	add.w	r0, sp, #2
   1b29e:	f7ff ff7b 	bl	1b198 <tx_cmplt_get>
			} while ((cmplt_prev != 0U) ||
   1b2a2:	ea49 0200 	orr.w	r2, r9, r0
   1b2a6:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
   1b2aa:	d1f1      	bne.n	1b290 <ll_rx_get+0x38>
			} else if (rx->type == NODE_RX_TYPE_RELEASE) {
   1b2ac:	9b01      	ldr	r3, [sp, #4]
   1b2ae:	f893 9004 	ldrb.w	r9, [r3, #4]
   1b2b2:	f1b9 0f01 	cmp.w	r9, #1
   1b2b6:	d112      	bne.n	1b2de <ll_rx_get+0x86>
				(void)memq_dequeue(memq_ll_rx.tail,
   1b2b8:	4639      	mov	r1, r7
   1b2ba:	6878      	ldr	r0, [r7, #4]
   1b2bc:	f00f fb15 	bl	2a8ea <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
   1b2c0:	4910      	ldr	r1, [pc, #64]	; (1b304 <ll_rx_get+0xac>)
   1b2c2:	4630      	mov	r0, r6
   1b2c4:	f00f fabd 	bl	2a842 <mem_release>
				ll_rx_link_inc_quota(1);
   1b2c8:	4648      	mov	r0, r9
   1b2ca:	f7ff fe7f 	bl	1afcc <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
   1b2ce:	9801      	ldr	r0, [sp, #4]
   1b2d0:	490d      	ldr	r1, [pc, #52]	; (1b308 <ll_rx_get+0xb0>)
   1b2d2:	f00f fab6 	bl	2a842 <mem_release>
				rx_alloc(1);
   1b2d6:	4648      	mov	r0, r9
   1b2d8:	f7ff fee8 	bl	1b0ac <rx_alloc>
				goto ll_rx_get_again;
   1b2dc:	e7c3      	b.n	1b266 <ll_rx_get+0xe>
			*node_rx = rx;
   1b2de:	602b      	str	r3, [r5, #0]
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   1b2e0:	4610      	mov	r0, r2
}
   1b2e2:	b003      	add	sp, #12
   1b2e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   1b2e8:	f898 2003 	ldrb.w	r2, [r8, #3]
   1b2ec:	4904      	ldr	r1, [pc, #16]	; (1b300 <ll_rx_get+0xa8>)
   1b2ee:	4620      	mov	r0, r4
   1b2f0:	f7ff ff52 	bl	1b198 <tx_cmplt_get>
   1b2f4:	e7f5      	b.n	1b2e2 <ll_rx_get+0x8a>
   1b2f6:	bf00      	nop
   1b2f8:	20002cd0 	.word	0x20002cd0
   1b2fc:	20000988 	.word	0x20000988
   1b300:	2000098a 	.word	0x2000098a
   1b304:	20002aa4 	.word	0x20002aa4
   1b308:	20002af0 	.word	0x20002af0

0001b30c <ll_rx_dequeue>:
{
   1b30c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1b30e:	4948      	ldr	r1, [pc, #288]	; (1b430 <ll_rx_dequeue+0x124>)
	struct node_rx_hdr *rx = NULL;
   1b310:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1b312:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   1b314:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1b316:	aa01      	add	r2, sp, #4
   1b318:	f00f fae7 	bl	2a8ea <memq_dequeue>
	LL_ASSERT(link);
   1b31c:	4604      	mov	r4, r0
   1b31e:	b960      	cbnz	r0, 1b33a <ll_rx_dequeue+0x2e>
   1b320:	4a44      	ldr	r2, [pc, #272]	; (1b434 <ll_rx_dequeue+0x128>)
   1b322:	4945      	ldr	r1, [pc, #276]	; (1b438 <ll_rx_dequeue+0x12c>)
   1b324:	4845      	ldr	r0, [pc, #276]	; (1b43c <ll_rx_dequeue+0x130>)
   1b326:	f240 33a1 	movw	r3, #929	; 0x3a1
   1b32a:	f009 ff47 	bl	251bc <printk>
   1b32e:	4040      	eors	r0, r0
   1b330:	f380 8811 	msr	BASEPRI, r0
   1b334:	f04f 0003 	mov.w	r0, #3
   1b338:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
   1b33a:	4941      	ldr	r1, [pc, #260]	; (1b440 <ll_rx_dequeue+0x134>)
   1b33c:	4620      	mov	r0, r4
   1b33e:	f00f fa80 	bl	2a842 <mem_release>
	switch (rx->type) {
   1b342:	9b01      	ldr	r3, [sp, #4]
   1b344:	7919      	ldrb	r1, [r3, #4]
   1b346:	291b      	cmp	r1, #27
   1b348:	d86f      	bhi.n	1b42a <ll_rx_dequeue+0x11e>
   1b34a:	483e      	ldr	r0, [pc, #248]	; (1b444 <ll_rx_dequeue+0x138>)
   1b34c:	2201      	movs	r2, #1
   1b34e:	408a      	lsls	r2, r1
   1b350:	4202      	tst	r2, r0
   1b352:	d15a      	bne.n	1b40a <ll_rx_dequeue+0xfe>
   1b354:	0252      	lsls	r2, r2, #9
   1b356:	d568      	bpl.n	1b42a <ll_rx_dequeue+0x11e>
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   1b358:	7f1a      	ldrb	r2, [r3, #28]
   1b35a:	2a3c      	cmp	r2, #60	; 0x3c
   1b35c:	d002      	beq.n	1b364 <ll_rx_dequeue+0x58>
   1b35e:	7f59      	ldrb	r1, [r3, #29]
   1b360:	2900      	cmp	r1, #0
   1b362:	d04d      	beq.n	1b400 <ll_rx_dequeue+0xf4>
			lll = ftr->param;
   1b364:	689e      	ldr	r6, [r3, #8]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1b366:	2a3c      	cmp	r2, #60	; 0x3c
			adv = HDR_LLL2ULL(lll);
   1b368:	6835      	ldr	r5, [r6, #0]
			if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1b36a:	d140      	bne.n	1b3ee <ll_rx_dequeue+0xe2>
				conn_lll = lll->conn;
   1b36c:	6874      	ldr	r4, [r6, #4]
				LL_ASSERT(conn_lll);
   1b36e:	b964      	cbnz	r4, 1b38a <ll_rx_dequeue+0x7e>
   1b370:	4a30      	ldr	r2, [pc, #192]	; (1b434 <ll_rx_dequeue+0x128>)
   1b372:	4935      	ldr	r1, [pc, #212]	; (1b448 <ll_rx_dequeue+0x13c>)
   1b374:	4831      	ldr	r0, [pc, #196]	; (1b43c <ll_rx_dequeue+0x130>)
   1b376:	f240 4317 	movw	r3, #1047	; 0x417
   1b37a:	f009 ff1f 	bl	251bc <printk>
   1b37e:	4040      	eors	r0, r0
   1b380:	f380 8811 	msr	BASEPRI, r0
   1b384:	f04f 0003 	mov.w	r0, #3
   1b388:	df02      	svc	2
				lll->conn = NULL;
   1b38a:	2300      	movs	r3, #0
   1b38c:	6073      	str	r3, [r6, #4]
				LL_ASSERT(!conn_lll->link_tx_free);
   1b38e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   1b390:	b163      	cbz	r3, 1b3ac <ll_rx_dequeue+0xa0>
   1b392:	4a28      	ldr	r2, [pc, #160]	; (1b434 <ll_rx_dequeue+0x128>)
   1b394:	492d      	ldr	r1, [pc, #180]	; (1b44c <ll_rx_dequeue+0x140>)
   1b396:	4829      	ldr	r0, [pc, #164]	; (1b43c <ll_rx_dequeue+0x130>)
   1b398:	f240 431a 	movw	r3, #1050	; 0x41a
   1b39c:	f009 ff0e 	bl	251bc <printk>
   1b3a0:	4040      	eors	r0, r0
   1b3a2:	f380 8811 	msr	BASEPRI, r0
   1b3a6:	f04f 0003 	mov.w	r0, #3
   1b3aa:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   1b3ac:	f104 0140 	add.w	r1, r4, #64	; 0x40
   1b3b0:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   1b3b4:	f00f fa7f 	bl	2a8b6 <memq_deinit>
				LL_ASSERT(link);
   1b3b8:	4606      	mov	r6, r0
   1b3ba:	b960      	cbnz	r0, 1b3d6 <ll_rx_dequeue+0xca>
   1b3bc:	4a1d      	ldr	r2, [pc, #116]	; (1b434 <ll_rx_dequeue+0x128>)
   1b3be:	491e      	ldr	r1, [pc, #120]	; (1b438 <ll_rx_dequeue+0x12c>)
   1b3c0:	481e      	ldr	r0, [pc, #120]	; (1b43c <ll_rx_dequeue+0x130>)
   1b3c2:	f240 431d 	movw	r3, #1053	; 0x41d
   1b3c6:	f009 fef9 	bl	251bc <printk>
   1b3ca:	4040      	eors	r0, r0
   1b3cc:	f380 8811 	msr	BASEPRI, r0
   1b3d0:	f04f 0003 	mov.w	r0, #3
   1b3d4:	df02      	svc	2
				ll_conn_release(conn);
   1b3d6:	6820      	ldr	r0, [r4, #0]
				conn_lll->link_tx_free = link;
   1b3d8:	64e6      	str	r6, [r4, #76]	; 0x4c
				ll_conn_release(conn);
   1b3da:	f001 fbdd 	bl	1cb98 <ll_conn_release>
			adv->is_enabled = 0U;
   1b3de:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
   1b3e2:	f36f 0300 	bfc	r3, #0, #1
   1b3e6:	f885 306a 	strb.w	r3, [r5, #106]	; 0x6a
}
   1b3ea:	b002      	add	sp, #8
   1b3ec:	bd70      	pop	{r4, r5, r6, pc}
				if (adv->node_rx_cc_free) {
   1b3ee:	6e68      	ldr	r0, [r5, #100]	; 0x64
   1b3f0:	2800      	cmp	r0, #0
   1b3f2:	d0f4      	beq.n	1b3de <ll_rx_dequeue+0xd2>
					adv->node_rx_cc_free = NULL;
   1b3f4:	2300      	movs	r3, #0
					mem_release(rx_free, &mem_pdu_rx.free);
   1b3f6:	4916      	ldr	r1, [pc, #88]	; (1b450 <ll_rx_dequeue+0x144>)
					adv->node_rx_cc_free = NULL;
   1b3f8:	666b      	str	r3, [r5, #100]	; 0x64
					mem_release(rx_free, &mem_pdu_rx.free);
   1b3fa:	f00f fa22 	bl	2a842 <mem_release>
   1b3fe:	e7ee      	b.n	1b3de <ll_rx_dequeue+0xd2>
			LL_ASSERT(0);
   1b400:	f240 4354 	movw	r3, #1108	; 0x454
		LL_ASSERT(0);
   1b404:	4a0b      	ldr	r2, [pc, #44]	; (1b434 <ll_rx_dequeue+0x128>)
   1b406:	4913      	ldr	r1, [pc, #76]	; (1b454 <ll_rx_dequeue+0x148>)
   1b408:	e005      	b.n	1b416 <ll_rx_dequeue+0x10a>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   1b40a:	2900      	cmp	r1, #0
   1b40c:	d1ed      	bne.n	1b3ea <ll_rx_dequeue+0xde>
   1b40e:	4a09      	ldr	r2, [pc, #36]	; (1b434 <ll_rx_dequeue+0x128>)
   1b410:	4911      	ldr	r1, [pc, #68]	; (1b458 <ll_rx_dequeue+0x14c>)
   1b412:	f240 43c3 	movw	r3, #1219	; 0x4c3
		LL_ASSERT(0);
   1b416:	4809      	ldr	r0, [pc, #36]	; (1b43c <ll_rx_dequeue+0x130>)
   1b418:	f009 fed0 	bl	251bc <printk>
   1b41c:	4040      	eors	r0, r0
   1b41e:	f380 8811 	msr	BASEPRI, r0
   1b422:	f04f 0003 	mov.w	r0, #3
   1b426:	df02      	svc	2
}
   1b428:	e7df      	b.n	1b3ea <ll_rx_dequeue+0xde>
		LL_ASSERT(0);
   1b42a:	f240 43c7 	movw	r3, #1223	; 0x4c7
   1b42e:	e7e9      	b.n	1b404 <ll_rx_dequeue+0xf8>
   1b430:	20002cd0 	.word	0x20002cd0
   1b434:	00033fd7 	.word	0x00033fd7
   1b438:	000337d3 	.word	0x000337d3
   1b43c:	0002f8b5 	.word	0x0002f8b5
   1b440:	20002aa4 	.word	0x20002aa4
   1b444:	0b800029 	.word	0x0b800029
   1b448:	00034051 	.word	0x00034051
   1b44c:	0003405a 	.word	0x0003405a
   1b450:	20002af0 	.word	0x20002af0
   1b454:	00031059 	.word	0x00031059
   1b458:	00034072 	.word	0x00034072

0001b45c <ll_rx_mem_release>:
{
   1b45c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
   1b460:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
   1b462:	4d4a      	ldr	r5, [pc, #296]	; (1b58c <ll_rx_mem_release+0x130>)
   1b464:	f8df 8128 	ldr.w	r8, [pc, #296]	; 1b590 <ll_rx_mem_release+0x134>
   1b468:	4e4a      	ldr	r6, [pc, #296]	; (1b594 <ll_rx_mem_release+0x138>)
{
   1b46a:	4607      	mov	r7, r0
	while (rx) {
   1b46c:	b92c      	cbnz	r4, 1b47a <ll_rx_mem_release+0x1e>
	*node_rx = rx;
   1b46e:	603c      	str	r4, [r7, #0]
	rx_alloc(UINT8_MAX);
   1b470:	20ff      	movs	r0, #255	; 0xff
}
   1b472:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_alloc(UINT8_MAX);
   1b476:	f7ff be19 	b.w	1b0ac <rx_alloc>
		switch (rx_free->type) {
   1b47a:	7923      	ldrb	r3, [r4, #4]
		rx = rx->next;
   1b47c:	f8d4 9000 	ldr.w	r9, [r4]
		switch (rx_free->type) {
   1b480:	2b05      	cmp	r3, #5
   1b482:	d813      	bhi.n	1b4ac <ll_rx_mem_release+0x50>
   1b484:	2201      	movs	r2, #1
   1b486:	fa02 f303 	lsl.w	r3, r2, r3
   1b48a:	f013 0f29 	tst.w	r3, #41	; 0x29
   1b48e:	d13a      	bne.n	1b506 <ll_rx_mem_release+0xaa>
			LL_ASSERT(0);
   1b490:	f240 53fa 	movw	r3, #1530	; 0x5fa
   1b494:	462a      	mov	r2, r5
   1b496:	4641      	mov	r1, r8
   1b498:	4630      	mov	r0, r6
   1b49a:	f009 fe8f 	bl	251bc <printk>
   1b49e:	4040      	eors	r0, r0
   1b4a0:	f380 8811 	msr	BASEPRI, r0
   1b4a4:	f04f 0003 	mov.w	r0, #3
   1b4a8:	df02      	svc	2
			break;
   1b4aa:	e01c      	b.n	1b4e6 <ll_rx_mem_release+0x8a>
		switch (rx_free->type) {
   1b4ac:	3b16      	subs	r3, #22
   1b4ae:	b2da      	uxtb	r2, r3
   1b4b0:	2a05      	cmp	r2, #5
   1b4b2:	d8ed      	bhi.n	1b490 <ll_rx_mem_release+0x34>
   1b4b4:	2b05      	cmp	r3, #5
   1b4b6:	d8eb      	bhi.n	1b490 <ll_rx_mem_release+0x34>
   1b4b8:	a201      	add	r2, pc, #4	; (adr r2, 1b4c0 <ll_rx_mem_release+0x64>)
   1b4ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1b4be:	bf00      	nop
   1b4c0:	0001b4d9 	.word	0x0001b4d9
   1b4c4:	0001b52d 	.word	0x0001b52d
   1b4c8:	0001b507 	.word	0x0001b507
   1b4cc:	0001b507 	.word	0x0001b507
   1b4d0:	0001b491 	.word	0x0001b491
   1b4d4:	0001b507 	.word	0x0001b507
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
   1b4d8:	7f23      	ldrb	r3, [r4, #28]
   1b4da:	2b3c      	cmp	r3, #60	; 0x3c
   1b4dc:	d105      	bne.n	1b4ea <ll_rx_mem_release+0x8e>
			mem_release(rx_free, &mem_pdu_rx.free);
   1b4de:	492e      	ldr	r1, [pc, #184]	; (1b598 <ll_rx_mem_release+0x13c>)
   1b4e0:	4620      	mov	r0, r4
   1b4e2:	f00f f9ae 	bl	2a842 <mem_release>
{
   1b4e6:	464c      	mov	r4, r9
   1b4e8:	e7c0      	b.n	1b46c <ll_rx_mem_release+0x10>
				LL_ASSERT(!cc->status);
   1b4ea:	b163      	cbz	r3, 1b506 <ll_rx_mem_release+0xaa>
   1b4ec:	492b      	ldr	r1, [pc, #172]	; (1b59c <ll_rx_mem_release+0x140>)
   1b4ee:	f240 532b 	movw	r3, #1323	; 0x52b
   1b4f2:	462a      	mov	r2, r5
   1b4f4:	4630      	mov	r0, r6
   1b4f6:	f009 fe61 	bl	251bc <printk>
   1b4fa:	4040      	eors	r0, r0
   1b4fc:	f380 8811 	msr	BASEPRI, r0
   1b500:	f04f 0003 	mov.w	r0, #3
   1b504:	df02      	svc	2
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   1b506:	7923      	ldrb	r3, [r4, #4]
   1b508:	b963      	cbnz	r3, 1b524 <ll_rx_mem_release+0xc8>
   1b50a:	4925      	ldr	r1, [pc, #148]	; (1b5a0 <ll_rx_mem_release+0x144>)
   1b50c:	f240 537d 	movw	r3, #1405	; 0x57d
   1b510:	462a      	mov	r2, r5
   1b512:	4630      	mov	r0, r6
   1b514:	f009 fe52 	bl	251bc <printk>
   1b518:	4040      	eors	r0, r0
   1b51a:	f380 8811 	msr	BASEPRI, r0
   1b51e:	f04f 0003 	mov.w	r0, #3
   1b522:	df02      	svc	2
			ll_rx_link_inc_quota(1);
   1b524:	2001      	movs	r0, #1
   1b526:	f7ff fd51 	bl	1afcc <ll_rx_link_inc_quota>
   1b52a:	e7d8      	b.n	1b4de <ll_rx_mem_release+0x82>
			if (IS_ACL_HANDLE(rx_free->handle)) {
   1b52c:	88e0      	ldrh	r0, [r4, #6]
   1b52e:	2800      	cmp	r0, #0
   1b530:	d1d9      	bne.n	1b4e6 <ll_rx_mem_release+0x8a>
				conn = ll_conn_get(rx_free->handle);
   1b532:	f001 fbad 	bl	1cc90 <ll_conn_get>
				LL_ASSERT(!conn->lll.link_tx_free);
   1b536:	6e83      	ldr	r3, [r0, #104]	; 0x68
				conn = ll_conn_get(rx_free->handle);
   1b538:	4604      	mov	r4, r0
				LL_ASSERT(!conn->lll.link_tx_free);
   1b53a:	b163      	cbz	r3, 1b556 <ll_rx_mem_release+0xfa>
   1b53c:	4919      	ldr	r1, [pc, #100]	; (1b5a4 <ll_rx_mem_release+0x148>)
   1b53e:	f240 53ec 	movw	r3, #1516	; 0x5ec
   1b542:	462a      	mov	r2, r5
   1b544:	4630      	mov	r0, r6
   1b546:	f009 fe39 	bl	251bc <printk>
   1b54a:	4040      	eors	r0, r0
   1b54c:	f380 8811 	msr	BASEPRI, r0
   1b550:	f04f 0003 	mov.w	r0, #3
   1b554:	df02      	svc	2
				link = memq_deinit(&conn->lll.memq_tx.head,
   1b556:	f104 015c 	add.w	r1, r4, #92	; 0x5c
   1b55a:	f104 0058 	add.w	r0, r4, #88	; 0x58
   1b55e:	f00f f9aa 	bl	2a8b6 <memq_deinit>
				LL_ASSERT(link);
   1b562:	4682      	mov	sl, r0
   1b564:	b960      	cbnz	r0, 1b580 <ll_rx_mem_release+0x124>
   1b566:	4910      	ldr	r1, [pc, #64]	; (1b5a8 <ll_rx_mem_release+0x14c>)
   1b568:	f240 53ef 	movw	r3, #1519	; 0x5ef
   1b56c:	462a      	mov	r2, r5
   1b56e:	4630      	mov	r0, r6
   1b570:	f009 fe24 	bl	251bc <printk>
   1b574:	4040      	eors	r0, r0
   1b576:	f380 8811 	msr	BASEPRI, r0
   1b57a:	f04f 0003 	mov.w	r0, #3
   1b57e:	df02      	svc	2
				conn->lll.link_tx_free = link;
   1b580:	f8c4 a068 	str.w	sl, [r4, #104]	; 0x68
				ll_conn_release(conn);
   1b584:	4620      	mov	r0, r4
   1b586:	f001 fb07 	bl	1cb98 <ll_conn_release>
   1b58a:	e7ac      	b.n	1b4e6 <ll_rx_mem_release+0x8a>
   1b58c:	00033fd7 	.word	0x00033fd7
   1b590:	00031059 	.word	0x00031059
   1b594:	0002f8b5 	.word	0x0002f8b5
   1b598:	20002af0 	.word	0x20002af0
   1b59c:	00034090 	.word	0x00034090
   1b5a0:	0003409c 	.word	0x0003409c
   1b5a4:	000340bf 	.word	0x000340bf
   1b5a8:	000337d3 	.word	0x000337d3

0001b5ac <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   1b5ac:	4801      	ldr	r0, [pc, #4]	; (1b5b4 <ll_rx_link_alloc+0x8>)
   1b5ae:	f00f b92f 	b.w	2a810 <mem_acquire>
   1b5b2:	bf00      	nop
   1b5b4:	20002aa4 	.word	0x20002aa4

0001b5b8 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   1b5b8:	4901      	ldr	r1, [pc, #4]	; (1b5c0 <ll_rx_link_release+0x8>)
   1b5ba:	f00f b942 	b.w	2a842 <mem_release>
   1b5be:	bf00      	nop
   1b5c0:	20002aa4 	.word	0x20002aa4

0001b5c4 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   1b5c4:	4801      	ldr	r0, [pc, #4]	; (1b5cc <ll_rx_alloc+0x8>)
   1b5c6:	f00f b923 	b.w	2a810 <mem_acquire>
   1b5ca:	bf00      	nop
   1b5cc:	20002af0 	.word	0x20002af0

0001b5d0 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   1b5d0:	4901      	ldr	r1, [pc, #4]	; (1b5d8 <ll_rx_release+0x8>)
   1b5d2:	f00f b936 	b.w	2a842 <mem_release>
   1b5d6:	bf00      	nop
   1b5d8:	20002af0 	.word	0x20002af0

0001b5dc <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1b5dc:	4b02      	ldr	r3, [pc, #8]	; (1b5e8 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1b5de:	4a03      	ldr	r2, [pc, #12]	; (1b5ec <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1b5e0:	78db      	ldrb	r3, [r3, #3]
   1b5e2:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1b5e4:	f00f b972 	b.w	2a8cc <memq_enqueue>
   1b5e8:	20000988 	.word	0x20000988
   1b5ec:	20002cd4 	.word	0x20002cd4

0001b5f0 <ll_rx_sched>:
	k_sem_give(sem_recv);
   1b5f0:	4b01      	ldr	r3, [pc, #4]	; (1b5f8 <ll_rx_sched+0x8>)
   1b5f2:	6818      	ldr	r0, [r3, #0]
   1b5f4:	f008 bcae 	b.w	23f54 <z_impl_k_sem_give>
   1b5f8:	20002ce8 	.word	0x20002ce8

0001b5fc <rx_demux>:
{
   1b5fc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   1b5fe:	4c3c      	ldr	r4, [pc, #240]	; (1b6f0 <rx_demux+0xf4>)
#if defined(CONFIG_BT_CTLR_USER_EXT)
		/* Try proprietary demuxing */
		rx_demux_rx_proprietary(link, rx, memq_ull_rx.tail,
					&memq_ull_rx.head);
#else
		LL_ASSERT(0);
   1b600:	4e3c      	ldr	r6, [pc, #240]	; (1b6f4 <rx_demux+0xf8>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   1b602:	e9d4 0100 	ldrd	r0, r1, [r4]
   1b606:	aa01      	add	r2, sp, #4
   1b608:	f00f f967 	bl	2a8da <memq_peek>
		if (link) {
   1b60c:	4605      	mov	r5, r0
   1b60e:	2800      	cmp	r0, #0
   1b610:	d05d      	beq.n	1b6ce <rx_demux+0xd2>
			LL_ASSERT(rx);
   1b612:	9b01      	ldr	r3, [sp, #4]
   1b614:	b963      	cbnz	r3, 1b630 <rx_demux+0x34>
   1b616:	4938      	ldr	r1, [pc, #224]	; (1b6f8 <rx_demux+0xfc>)
   1b618:	4838      	ldr	r0, [pc, #224]	; (1b6fc <rx_demux+0x100>)
   1b61a:	f44f 630b 	mov.w	r3, #2224	; 0x8b0
   1b61e:	4632      	mov	r2, r6
   1b620:	f009 fdcc 	bl	251bc <printk>
   1b624:	4040      	eors	r0, r0
   1b626:	f380 8811 	msr	BASEPRI, r0
   1b62a:	f04f 0003 	mov.w	r0, #3
   1b62e:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   1b630:	9b01      	ldr	r3, [sp, #4]
   1b632:	aa02      	add	r2, sp, #8
   1b634:	7818      	ldrb	r0, [r3, #0]
   1b636:	f10d 0102 	add.w	r1, sp, #2
   1b63a:	f002 fa61 	bl	1db00 <ull_conn_ack_by_last_peek>
			if (link_tx) {
   1b63e:	4602      	mov	r2, r0
   1b640:	9801      	ldr	r0, [sp, #4]
   1b642:	b132      	cbz	r2, 1b652 <rx_demux+0x56>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   1b644:	9b02      	ldr	r3, [sp, #8]
   1b646:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1b64a:	7800      	ldrb	r0, [r0, #0]
				rx_demux_conn_tx_ack(ack_last, handle,
   1b64c:	f00f fc69 	bl	2af22 <rx_demux_conn_tx_ack>
	} while (link);
   1b650:	e7d7      	b.n	1b602 <rx_demux+0x6>
				nack = rx_demux_rx(link, rx);
   1b652:	9003      	str	r0, [sp, #12]
	switch (rx->type) {
   1b654:	7903      	ldrb	r3, [r0, #4]
   1b656:	2b05      	cmp	r3, #5
   1b658:	d016      	beq.n	1b688 <rx_demux+0x8c>
   1b65a:	d811      	bhi.n	1b680 <rx_demux+0x84>
   1b65c:	2b01      	cmp	r3, #1
   1b65e:	d013      	beq.n	1b688 <rx_demux+0x8c>
   1b660:	2b03      	cmp	r3, #3
   1b662:	d021      	beq.n	1b6a8 <rx_demux+0xac>
		LL_ASSERT(0);
   1b664:	4926      	ldr	r1, [pc, #152]	; (1b700 <rx_demux+0x104>)
   1b666:	4825      	ldr	r0, [pc, #148]	; (1b6fc <rx_demux+0x100>)
   1b668:	f640 13ff 	movw	r3, #2559	; 0x9ff
   1b66c:	4632      	mov	r2, r6
   1b66e:	f009 fda5 	bl	251bc <printk>
   1b672:	4040      	eors	r0, r0
   1b674:	f380 8811 	msr	BASEPRI, r0
   1b678:	f04f 0003 	mov.w	r0, #3
   1b67c:	df02      	svc	2
			if (nack) {
   1b67e:	e7c0      	b.n	1b602 <rx_demux+0x6>
	switch (rx->type) {
   1b680:	2b16      	cmp	r3, #22
   1b682:	d008      	beq.n	1b696 <rx_demux+0x9a>
   1b684:	2b17      	cmp	r3, #23
   1b686:	d1ed      	bne.n	1b664 <rx_demux+0x68>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1b688:	4621      	mov	r1, r4
   1b68a:	6860      	ldr	r0, [r4, #4]
   1b68c:	2200      	movs	r2, #0
   1b68e:	f00f f92c 	bl	2a8ea <memq_dequeue>
		ll_rx_put(link, rx);
   1b692:	9903      	ldr	r1, [sp, #12]
   1b694:	e015      	b.n	1b6c2 <rx_demux+0xc6>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1b696:	4621      	mov	r1, r4
   1b698:	6860      	ldr	r0, [r4, #4]
   1b69a:	f00f f926 	bl	2a8ea <memq_dequeue>
		ull_conn_setup(link, rx);
   1b69e:	9903      	ldr	r1, [sp, #12]
   1b6a0:	4628      	mov	r0, r5
   1b6a2:	f001 fba7 	bl	1cdf4 <ull_conn_setup>
			if (nack) {
   1b6a6:	e7ac      	b.n	1b602 <rx_demux+0x6>
		nack = ull_conn_rx(link, (void *)&rx);
   1b6a8:	a903      	add	r1, sp, #12
   1b6aa:	4628      	mov	r0, r5
   1b6ac:	f001 fbca 	bl	1ce44 <ull_conn_rx>
		if (nack) {
   1b6b0:	4602      	mov	r2, r0
   1b6b2:	b9d0      	cbnz	r0, 1b6ea <rx_demux+0xee>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1b6b4:	4621      	mov	r1, r4
   1b6b6:	6860      	ldr	r0, [r4, #4]
   1b6b8:	f00f f917 	bl	2a8ea <memq_dequeue>
		if (rx) {
   1b6bc:	9903      	ldr	r1, [sp, #12]
   1b6be:	2900      	cmp	r1, #0
   1b6c0:	d09f      	beq.n	1b602 <rx_demux+0x6>
		ll_rx_put(link, rx);
   1b6c2:	4628      	mov	r0, r5
   1b6c4:	f7ff ff8a 	bl	1b5dc <ll_rx_put>
		ll_rx_sched();
   1b6c8:	f7ff ff92 	bl	1b5f0 <ll_rx_sched>
			if (nack) {
   1b6cc:	e799      	b.n	1b602 <rx_demux+0x6>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   1b6ce:	aa03      	add	r2, sp, #12
   1b6d0:	a902      	add	r1, sp, #8
   1b6d2:	f10d 0002 	add.w	r0, sp, #2
   1b6d6:	f002 f9fd 	bl	1dad4 <ull_conn_ack_peek>
			if (link) {
   1b6da:	4602      	mov	r2, r0
   1b6dc:	b128      	cbz	r0, 1b6ea <rx_demux+0xee>
				rx_demux_conn_tx_ack(ack_last, handle,
   1b6de:	9b03      	ldr	r3, [sp, #12]
   1b6e0:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1b6e4:	f89d 0002 	ldrb.w	r0, [sp, #2]
   1b6e8:	e7b0      	b.n	1b64c <rx_demux+0x50>
}
   1b6ea:	b004      	add	sp, #16
   1b6ec:	bd70      	pop	{r4, r5, r6, pc}
   1b6ee:	bf00      	nop
   1b6f0:	20002ce0 	.word	0x20002ce0
   1b6f4:	00033fd7 	.word	0x00033fd7
   1b6f8:	00034790 	.word	0x00034790
   1b6fc:	0002f8b5 	.word	0x0002f8b5
   1b700:	00031059 	.word	0x00031059

0001b704 <ll_pdu_rx_alloc_peek>:
{
   1b704:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   1b706:	4a0a      	ldr	r2, [pc, #40]	; (1b730 <ll_pdu_rx_alloc_peek+0x2c>)
   1b708:	7891      	ldrb	r1, [r2, #2]
   1b70a:	78d4      	ldrb	r4, [r2, #3]
   1b70c:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1b70e:	42a1      	cmp	r1, r4
		return count - first + last;
   1b710:	bf8a      	itet	hi
   1b712:	191b      	addhi	r3, r3, r4
		return last - first;
   1b714:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1b716:	1a5b      	subhi	r3, r3, r1
   1b718:	b2db      	uxtb	r3, r3
   1b71a:	4298      	cmp	r0, r3
   1b71c:	d806      	bhi.n	1b72c <ll_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1b71e:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   1b720:	7813      	ldrb	r3, [r2, #0]
   1b722:	d003      	beq.n	1b72c <ll_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1b724:	fb01 2203 	mla	r2, r1, r3, r2
   1b728:	6850      	ldr	r0, [r2, #4]
}
   1b72a:	bd10      	pop	{r4, pc}
		return NULL;
   1b72c:	2000      	movs	r0, #0
   1b72e:	e7fc      	b.n	1b72a <ll_pdu_rx_alloc_peek+0x26>
   1b730:	20000860 	.word	0x20000860

0001b734 <ll_pdu_rx_alloc>:
{
   1b734:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1b736:	4a09      	ldr	r2, [pc, #36]	; (1b75c <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(uint8_t *fifo, uint8_t size, uint8_t count,
				  uint8_t last, uint8_t *first)
{
	uint8_t _first = *first; /* Copy read-index */
   1b738:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   1b73a:	78d0      	ldrb	r0, [r2, #3]
   1b73c:	7811      	ldrb	r1, [r2, #0]
   1b73e:	7854      	ldrb	r4, [r2, #1]
   1b740:	4298      	cmp	r0, r3
   1b742:	d009      	beq.n	1b758 <ll_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
   1b744:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   1b748:	3301      	adds	r3, #1
   1b74a:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
   1b74c:	429c      	cmp	r4, r3
   1b74e:	bf08      	it	eq
   1b750:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1b752:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
   1b754:	7093      	strb	r3, [r2, #2]
}
   1b756:	bd10      	pop	{r4, pc}
		return NULL;
   1b758:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1b75a:	e7fc      	b.n	1b756 <ll_pdu_rx_alloc+0x22>
   1b75c:	20000860 	.word	0x20000860

0001b760 <ll_tx_ack_put>:
{
   1b760:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   1b762:	4a12      	ldr	r2, [pc, #72]	; (1b7ac <ll_tx_ack_put+0x4c>)
   1b764:	78d6      	ldrb	r6, [r2, #3]
	if (last == count) {
   1b766:	7855      	ldrb	r5, [r2, #1]
   1b768:	7894      	ldrb	r4, [r2, #2]
	last = last + 1;
   1b76a:	1c73      	adds	r3, r6, #1
   1b76c:	b2db      	uxtb	r3, r3
		last = 0U;
   1b76e:	429d      	cmp	r5, r3
   1b770:	bf08      	it	eq
   1b772:	2300      	moveq	r3, #0
	if (last == first) {
   1b774:	429c      	cmp	r4, r3
   1b776:	d10f      	bne.n	1b798 <ll_tx_ack_put+0x38>
	LL_ASSERT(tx);
   1b778:	4a0d      	ldr	r2, [pc, #52]	; (1b7b0 <ll_tx_ack_put+0x50>)
   1b77a:	490e      	ldr	r1, [pc, #56]	; (1b7b4 <ll_tx_ack_put+0x54>)
   1b77c:	480e      	ldr	r0, [pc, #56]	; (1b7b8 <ll_tx_ack_put+0x58>)
   1b77e:	f240 634e 	movw	r3, #1614	; 0x64e
   1b782:	f009 fd1b 	bl	251bc <printk>
   1b786:	4040      	eors	r0, r0
   1b788:	f380 8811 	msr	BASEPRI, r0
   1b78c:	f04f 0003 	mov.w	r0, #3
   1b790:	df02      	svc	2
	tx->handle = handle;
   1b792:	2300      	movs	r3, #0
   1b794:	801b      	strh	r3, [r3, #0]
   1b796:	deff      	udf	#255	; 0xff
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1b798:	4615      	mov	r5, r2
   1b79a:	f815 4b04 	ldrb.w	r4, [r5], #4
   1b79e:	fb14 f406 	smulbb	r4, r4, r6
   1b7a2:	192e      	adds	r6, r5, r4
   1b7a4:	5328      	strh	r0, [r5, r4]
	tx->node = node_tx;
   1b7a6:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
   1b7a8:	70d3      	strb	r3, [r2, #3]
}
   1b7aa:	bd70      	pop	{r4, r5, r6, pc}
   1b7ac:	20000988 	.word	0x20000988
   1b7b0:	00033fd7 	.word	0x00033fd7
   1b7b4:	000343f6 	.word	0x000343f6
   1b7b8:	0002f8b5 	.word	0x0002f8b5

0001b7bc <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1b7bc:	2200      	movs	r2, #0
{
   1b7be:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1b7c0:	4611      	mov	r1, r2
   1b7c2:	4b09      	ldr	r3, [pc, #36]	; (1b7e8 <ll_radio_state_abort+0x2c>)
   1b7c4:	2001      	movs	r0, #1
   1b7c6:	f7fd fe49 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1b7ca:	b160      	cbz	r0, 1b7e6 <ll_radio_state_abort+0x2a>
   1b7cc:	4a07      	ldr	r2, [pc, #28]	; (1b7ec <ll_radio_state_abort+0x30>)
   1b7ce:	4908      	ldr	r1, [pc, #32]	; (1b7f0 <ll_radio_state_abort+0x34>)
   1b7d0:	4808      	ldr	r0, [pc, #32]	; (1b7f4 <ll_radio_state_abort+0x38>)
   1b7d2:	f240 6366 	movw	r3, #1638	; 0x666
   1b7d6:	f009 fcf1 	bl	251bc <printk>
   1b7da:	4040      	eors	r0, r0
   1b7dc:	f380 8811 	msr	BASEPRI, r0
   1b7e0:	f04f 0003 	mov.w	r0, #3
   1b7e4:	df02      	svc	2
}
   1b7e6:	bd08      	pop	{r3, pc}
   1b7e8:	200009fc 	.word	0x200009fc
   1b7ec:	00033fd7 	.word	0x00033fd7
   1b7f0:	000340d7 	.word	0x000340d7
   1b7f4:	0002f8b5 	.word	0x0002f8b5

0001b7f8 <ull_ticker_status_take>:
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1b7f8:	f030 0302 	bics.w	r3, r0, #2
{
   1b7fc:	b510      	push	{r4, lr}
   1b7fe:	460c      	mov	r4, r1
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1b800:	d00f      	beq.n	1b822 <ull_ticker_status_take+0x2a>
   1b802:	680b      	ldr	r3, [r1, #0]
   1b804:	2b02      	cmp	r3, #2
   1b806:	d10c      	bne.n	1b822 <ull_ticker_status_take+0x2a>
   1b808:	4a0a      	ldr	r2, [pc, #40]	; (1b834 <ull_ticker_status_take+0x3c>)
   1b80a:	490b      	ldr	r1, [pc, #44]	; (1b838 <ull_ticker_status_take+0x40>)
   1b80c:	480b      	ldr	r0, [pc, #44]	; (1b83c <ull_ticker_status_take+0x44>)
   1b80e:	f240 6382 	movw	r3, #1666	; 0x682
   1b812:	f009 fcd3 	bl	251bc <printk>
   1b816:	4040      	eors	r0, r0
   1b818:	f380 8811 	msr	BASEPRI, r0
   1b81c:	f04f 0003 	mov.w	r0, #3
   1b820:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1b822:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1b826:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1b82a:	4805      	ldr	r0, [pc, #20]	; (1b840 <ull_ticker_status_take+0x48>)
   1b82c:	f008 fbb8 	bl	23fa0 <z_impl_k_sem_take>
	return *ret_cb;
   1b830:	6820      	ldr	r0, [r4, #0]
}
   1b832:	bd10      	pop	{r4, pc}
   1b834:	00033fd7 	.word	0x00033fd7
   1b838:	000340dc 	.word	0x000340dc
   1b83c:	0002f8b5 	.word	0x0002f8b5
   1b840:	20002cec 	.word	0x20002cec

0001b844 <ull_disable_mark>:
	if (!*m) {
   1b844:	4b02      	ldr	r3, [pc, #8]	; (1b850 <ull_disable_mark+0xc>)
   1b846:	681a      	ldr	r2, [r3, #0]
   1b848:	b902      	cbnz	r2, 1b84c <ull_disable_mark+0x8>
		*m = param;
   1b84a:	6018      	str	r0, [r3, #0]
}
   1b84c:	6818      	ldr	r0, [r3, #0]
   1b84e:	4770      	bx	lr
   1b850:	20002a6c 	.word	0x20002a6c

0001b854 <ull_disable_unmark>:
	if (*m && *m == param) {
   1b854:	4a05      	ldr	r2, [pc, #20]	; (1b86c <ull_disable_unmark+0x18>)
{
   1b856:	4603      	mov	r3, r0
	if (*m && *m == param) {
   1b858:	6810      	ldr	r0, [r2, #0]
   1b85a:	b130      	cbz	r0, 1b86a <ull_disable_unmark+0x16>
   1b85c:	4283      	cmp	r3, r0
   1b85e:	f04f 0300 	mov.w	r3, #0
   1b862:	d101      	bne.n	1b868 <ull_disable_unmark+0x14>
		*m = NULL;
   1b864:	6013      	str	r3, [r2, #0]
		return param;
   1b866:	4770      	bx	lr
	return NULL;
   1b868:	4618      	mov	r0, r3
}
   1b86a:	4770      	bx	lr
   1b86c:	20002a6c 	.word	0x20002a6c

0001b870 <ull_disable_mark_get>:
}
   1b870:	4b01      	ldr	r3, [pc, #4]	; (1b878 <ull_disable_mark_get+0x8>)
   1b872:	6818      	ldr	r0, [r3, #0]
   1b874:	4770      	bx	lr
   1b876:	bf00      	nop
   1b878:	20002a6c 	.word	0x20002a6c

0001b87c <ull_update_mark>:
	if (!*m) {
   1b87c:	4b02      	ldr	r3, [pc, #8]	; (1b888 <ull_update_mark+0xc>)
   1b87e:	681a      	ldr	r2, [r3, #0]
   1b880:	b902      	cbnz	r2, 1b884 <ull_update_mark+0x8>
		*m = param;
   1b882:	6018      	str	r0, [r3, #0]
}
   1b884:	6818      	ldr	r0, [r3, #0]
   1b886:	4770      	bx	lr
   1b888:	20002a70 	.word	0x20002a70

0001b88c <ull_update_unmark>:
	if (*m && *m == param) {
   1b88c:	4a05      	ldr	r2, [pc, #20]	; (1b8a4 <ull_update_unmark+0x18>)
{
   1b88e:	4603      	mov	r3, r0
	if (*m && *m == param) {
   1b890:	6810      	ldr	r0, [r2, #0]
   1b892:	b130      	cbz	r0, 1b8a2 <ull_update_unmark+0x16>
   1b894:	4283      	cmp	r3, r0
   1b896:	f04f 0300 	mov.w	r3, #0
   1b89a:	d101      	bne.n	1b8a0 <ull_update_unmark+0x14>
		*m = NULL;
   1b89c:	6013      	str	r3, [r2, #0]
		return param;
   1b89e:	4770      	bx	lr
	return NULL;
   1b8a0:	4618      	mov	r0, r3
}
   1b8a2:	4770      	bx	lr
   1b8a4:	20002a70 	.word	0x20002a70

0001b8a8 <ull_update_mark_get>:
}
   1b8a8:	4b01      	ldr	r3, [pc, #4]	; (1b8b0 <ull_update_mark_get+0x8>)
   1b8aa:	6818      	ldr	r0, [r3, #0]
   1b8ac:	4770      	bx	lr
   1b8ae:	bf00      	nop
   1b8b0:	20002a70 	.word	0x20002a70

0001b8b4 <ull_disable>:
{
   1b8b4:	b530      	push	{r4, r5, lr}
	hdr = HDR_LLL2ULL(lll);
   1b8b6:	6805      	ldr	r5, [r0, #0]
	return hdr->ref;
   1b8b8:	782b      	ldrb	r3, [r5, #0]
{
   1b8ba:	b087      	sub	sp, #28
   1b8bc:	4604      	mov	r4, r0
	if (!ull_ref_get(hdr)) {
   1b8be:	b91b      	cbnz	r3, 1b8c8 <ull_disable+0x14>
		return -EALREADY;
   1b8c0:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   1b8c4:	b007      	add	sp, #28
   1b8c6:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_sem_init(sem, initial_count, limit);
   1b8c8:	2201      	movs	r2, #1
   1b8ca:	2100      	movs	r1, #0
   1b8cc:	4668      	mov	r0, sp
   1b8ce:	f011 f9d6 	bl	2cc7e <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
   1b8d2:	4b12      	ldr	r3, [pc, #72]	; (1b91c <ull_disable+0x68>)
   1b8d4:	616b      	str	r3, [r5, #20]
   1b8d6:	782b      	ldrb	r3, [r5, #0]
	hdr->disabled_param = &sem;
   1b8d8:	f8c5 d018 	str.w	sp, [r5, #24]
	if (!ull_ref_get(hdr)) {
   1b8dc:	2b00      	cmp	r3, #0
   1b8de:	d0ef      	beq.n	1b8c0 <ull_disable+0xc>
	mfy.param = lll;
   1b8e0:	4b0f      	ldr	r3, [pc, #60]	; (1b920 <ull_disable+0x6c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1b8e2:	2200      	movs	r2, #0
   1b8e4:	4611      	mov	r1, r2
   1b8e6:	2003      	movs	r0, #3
	mfy.param = lll;
   1b8e8:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1b8ea:	f7fd fdb7 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1b8ee:	b160      	cbz	r0, 1b90a <ull_disable+0x56>
   1b8f0:	4a0c      	ldr	r2, [pc, #48]	; (1b924 <ull_disable+0x70>)
   1b8f2:	490d      	ldr	r1, [pc, #52]	; (1b928 <ull_disable+0x74>)
   1b8f4:	480d      	ldr	r0, [pc, #52]	; (1b92c <ull_disable+0x78>)
   1b8f6:	f240 63ff 	movw	r3, #1791	; 0x6ff
   1b8fa:	f009 fc5f 	bl	251bc <printk>
   1b8fe:	4040      	eors	r0, r0
   1b900:	f380 8811 	msr	BASEPRI, r0
   1b904:	f04f 0003 	mov.w	r0, #3
   1b908:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1b90a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1b90e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1b912:	4668      	mov	r0, sp
   1b914:	f008 fb44 	bl	23fa0 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
   1b918:	e7d4      	b.n	1b8c4 <ull_disable+0x10>
   1b91a:	bf00      	nop
   1b91c:	0002af1f 	.word	0x0002af1f
   1b920:	200009ec 	.word	0x200009ec
   1b924:	00033fd7 	.word	0x00033fd7
   1b928:	000340d7 	.word	0x000340d7
   1b92c:	0002f8b5 	.word	0x0002f8b5

0001b930 <ull_ticker_stop_with_mark>:
{
   1b930:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b932:	4606      	mov	r6, r0
   1b934:	b085      	sub	sp, #20
	mark = ull_disable_mark(param);
   1b936:	4608      	mov	r0, r1
{
   1b938:	4614      	mov	r4, r2
	mark = ull_disable_mark(param);
   1b93a:	f7ff ff83 	bl	1b844 <ull_disable_mark>
	if (mark != param) {
   1b93e:	4281      	cmp	r1, r0
{
   1b940:	460d      	mov	r5, r1
	if (mark != param) {
   1b942:	d004      	beq.n	1b94e <ull_ticker_stop_with_mark+0x1e>
		return -ENOLCK;
   1b944:	f06f 042d 	mvn.w	r4, #45	; 0x2d
}
   1b948:	4620      	mov	r0, r4
   1b94a:	b005      	add	sp, #20
   1b94c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ret_cb = TICKER_STATUS_BUSY;
   1b94e:	2302      	movs	r3, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1b950:	af03      	add	r7, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
   1b952:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1b954:	2103      	movs	r1, #3
   1b956:	4b11      	ldr	r3, [pc, #68]	; (1b99c <ull_ticker_stop_with_mark+0x6c>)
   1b958:	9700      	str	r7, [sp, #0]
   1b95a:	4632      	mov	r2, r6
   1b95c:	2000      	movs	r0, #0
   1b95e:	f7fe fb41 	bl	19fe4 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1b962:	4639      	mov	r1, r7
   1b964:	f7ff ff48 	bl	1b7f8 <ull_ticker_status_take>
	if (ret) {
   1b968:	b138      	cbz	r0, 1b97a <ull_ticker_stop_with_mark+0x4a>
		mark = ull_disable_unmark(param);
   1b96a:	4628      	mov	r0, r5
   1b96c:	f7ff ff72 	bl	1b854 <ull_disable_unmark>
		if (mark != param) {
   1b970:	4285      	cmp	r5, r0
   1b972:	d1e7      	bne.n	1b944 <ull_ticker_stop_with_mark+0x14>
		return -EALREADY;
   1b974:	f06f 0477 	mvn.w	r4, #119	; 0x77
   1b978:	e7e6      	b.n	1b948 <ull_ticker_stop_with_mark+0x18>
	err = ull_disable(lll_disable);
   1b97a:	4620      	mov	r0, r4
   1b97c:	f7ff ff9a 	bl	1b8b4 <ull_disable>
   1b980:	4604      	mov	r4, r0
	mark = ull_disable_unmark(param);
   1b982:	4628      	mov	r0, r5
   1b984:	f7ff ff66 	bl	1b854 <ull_disable_unmark>
	if (mark != param) {
   1b988:	4285      	cmp	r5, r0
   1b98a:	d1db      	bne.n	1b944 <ull_ticker_stop_with_mark+0x14>
	if (err && (err != -EALREADY)) {
   1b98c:	2c00      	cmp	r4, #0
   1b98e:	d0db      	beq.n	1b948 <ull_ticker_stop_with_mark+0x18>
	return 0;
   1b990:	f114 0f78 	cmn.w	r4, #120	; 0x78
   1b994:	bf08      	it	eq
   1b996:	2400      	moveq	r4, #0
   1b998:	e7d6      	b.n	1b948 <ull_ticker_stop_with_mark+0x18>
   1b99a:	bf00      	nop
   1b99c:	0001b24d 	.word	0x0001b24d

0001b9a0 <ull_pdu_rx_alloc_peek>:
{
   1b9a0:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   1b9a2:	4a0a      	ldr	r2, [pc, #40]	; (1b9cc <ull_pdu_rx_alloc_peek+0x2c>)
   1b9a4:	7891      	ldrb	r1, [r2, #2]
   1b9a6:	78d4      	ldrb	r4, [r2, #3]
   1b9a8:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1b9aa:	42a1      	cmp	r1, r4
		return count - first + last;
   1b9ac:	bf8a      	itet	hi
   1b9ae:	191b      	addhi	r3, r3, r4
		return last - first;
   1b9b0:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1b9b2:	1a5b      	subhi	r3, r3, r1
   1b9b4:	b2db      	uxtb	r3, r3
   1b9b6:	4298      	cmp	r0, r3
   1b9b8:	d806      	bhi.n	1b9c8 <ull_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1b9ba:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   1b9bc:	7813      	ldrb	r3, [r2, #0]
   1b9be:	d003      	beq.n	1b9c8 <ull_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1b9c0:	fb01 2203 	mla	r2, r1, r3, r2
   1b9c4:	6850      	ldr	r0, [r2, #4]
}
   1b9c6:	bd10      	pop	{r4, pc}
		return NULL;
   1b9c8:	2000      	movs	r0, #0
   1b9ca:	e7fc      	b.n	1b9c6 <ull_pdu_rx_alloc_peek+0x26>
   1b9cc:	2000086c 	.word	0x2000086c

0001b9d0 <ull_pdu_rx_alloc>:
{
   1b9d0:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
   1b9d2:	4a09      	ldr	r2, [pc, #36]	; (1b9f8 <ull_pdu_rx_alloc+0x28>)
	uint8_t _first = *first; /* Copy read-index */
   1b9d4:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1b9d6:	78d0      	ldrb	r0, [r2, #3]
   1b9d8:	7811      	ldrb	r1, [r2, #0]
   1b9da:	7854      	ldrb	r4, [r2, #1]
   1b9dc:	4298      	cmp	r0, r3
   1b9de:	d009      	beq.n	1b9f4 <ull_pdu_rx_alloc+0x24>
	mem = *((void **)(fifo + _first * size));
   1b9e0:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1b9e4:	3301      	adds	r3, #1
   1b9e6:	b2db      	uxtb	r3, r3
		_first = 0U;
   1b9e8:	429c      	cmp	r4, r3
   1b9ea:	bf08      	it	eq
   1b9ec:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1b9ee:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   1b9f0:	7093      	strb	r3, [r2, #2]
}
   1b9f2:	bd10      	pop	{r4, pc}
		return NULL;
   1b9f4:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
   1b9f6:	e7fc      	b.n	1b9f2 <ull_pdu_rx_alloc+0x22>
   1b9f8:	2000086c 	.word	0x2000086c

0001b9fc <ull_rx_put>:
{
   1b9fc:	b538      	push	{r3, r4, r5, lr}
   1b9fe:	460c      	mov	r4, r1
   1ba00:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1ba02:	f002 f861 	bl	1dac8 <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1ba06:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1ba08:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1ba0a:	4a03      	ldr	r2, [pc, #12]	; (1ba18 <ull_rx_put+0x1c>)
   1ba0c:	4628      	mov	r0, r5
}
   1ba0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1ba12:	f00e bf5b 	b.w	2a8cc <memq_enqueue>
   1ba16:	bf00      	nop
   1ba18:	20002ce4 	.word	0x20002ce4

0001ba1c <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   1ba1c:	2201      	movs	r2, #1
   1ba1e:	4b02      	ldr	r3, [pc, #8]	; (1ba28 <ull_rx_sched+0xc>)
   1ba20:	4611      	mov	r1, r2
   1ba22:	2000      	movs	r0, #0
   1ba24:	f7fd bd1a 	b.w	1945c <mayfly_enqueue>
   1ba28:	200009dc 	.word	0x200009dc

0001ba2c <ull_rx_put_done>:
	memq_enqueue(link, done, &memq_ull_done.tail);
   1ba2c:	4a01      	ldr	r2, [pc, #4]	; (1ba34 <ull_rx_put_done+0x8>)
   1ba2e:	f00e bf4d 	b.w	2a8cc <memq_enqueue>
   1ba32:	bf00      	nop
   1ba34:	20002cdc 	.word	0x20002cdc

0001ba38 <ull_rx_sched_done>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   1ba38:	2201      	movs	r2, #1
   1ba3a:	4b02      	ldr	r3, [pc, #8]	; (1ba44 <ull_rx_sched_done+0xc>)
   1ba3c:	4611      	mov	r1, r2
   1ba3e:	2000      	movs	r0, #0
   1ba40:	f7fd bd0c 	b.w	1945c <mayfly_enqueue>
   1ba44:	200009cc 	.word	0x200009cc

0001ba48 <ull_prepare_enqueue>:
{
   1ba48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1ba4c:	4e14      	ldr	r6, [pc, #80]	; (1baa0 <ull_prepare_enqueue+0x58>)
{
   1ba4e:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1ba50:	78f3      	ldrb	r3, [r6, #3]
	if (last == count) {
   1ba52:	7874      	ldrb	r4, [r6, #1]
	last = last + 1;
   1ba54:	1c5d      	adds	r5, r3, #1
{
   1ba56:	4680      	mov	r8, r0
   1ba58:	b2ed      	uxtb	r5, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1ba5a:	78b0      	ldrb	r0, [r6, #2]
		last = 0U;
   1ba5c:	42ac      	cmp	r4, r5
   1ba5e:	bf08      	it	eq
   1ba60:	2500      	moveq	r5, #0
	if (last == first) {
   1ba62:	42a8      	cmp	r0, r5
{
   1ba64:	460f      	mov	r7, r1
   1ba66:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1ba68:	7832      	ldrb	r2, [r6, #0]
   1ba6a:	d016      	beq.n	1ba9a <ull_prepare_enqueue+0x52>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1ba6c:	1d34      	adds	r4, r6, #4
   1ba6e:	fb03 4402 	mla	r4, r3, r2, r4
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
   1ba72:	4620      	mov	r0, r4
   1ba74:	2210      	movs	r2, #16
   1ba76:	f00b fefb 	bl	27870 <memcpy>
	e->is_resume = is_resume;
   1ba7a:	7f23      	ldrb	r3, [r4, #28]
   1ba7c:	f89d 2020 	ldrb.w	r2, [sp, #32]
	e->abort_cb = abort_cb;
   1ba80:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
   1ba82:	f002 0201 	and.w	r2, r2, #1
   1ba86:	f023 0303 	bic.w	r3, r3, #3
   1ba8a:	4313      	orrs	r3, r2
	e->is_abort_cb = is_abort_cb;
   1ba8c:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
   1ba90:	7723      	strb	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
   1ba92:	70f5      	strb	r5, [r6, #3]
}
   1ba94:	4620      	mov	r0, r4
   1ba96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
   1ba9a:	2400      	movs	r4, #0
   1ba9c:	e7fa      	b.n	1ba94 <ull_prepare_enqueue+0x4c>
   1ba9e:	bf00      	nop
   1baa0:	20000884 	.word	0x20000884

0001baa4 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   1baa4:	4b05      	ldr	r3, [pc, #20]	; (1babc <ull_prepare_dequeue_get+0x18>)
   1baa6:	7898      	ldrb	r0, [r3, #2]
	if (first == last) {
   1baa8:	78d9      	ldrb	r1, [r3, #3]
   1baaa:	781a      	ldrb	r2, [r3, #0]
   1baac:	4281      	cmp	r1, r0
	return (void *)(fifo + first * size);
   1baae:	bf1a      	itte	ne
   1bab0:	3304      	addne	r3, #4
   1bab2:	fb00 3002 	mlane	r0, r0, r2, r3
		return NULL;
   1bab6:	2000      	moveq	r0, #0
}
   1bab8:	4770      	bx	lr
   1baba:	bf00      	nop
   1babc:	20000884 	.word	0x20000884

0001bac0 <ull_prepare_dequeue_iter>:
{
   1bac0:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1bac2:	4a0c      	ldr	r2, [pc, #48]	; (1baf4 <ull_prepare_dequeue_iter+0x34>)
{
   1bac4:	4603      	mov	r3, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1bac6:	7854      	ldrb	r4, [r2, #1]
	if (*idx >= count) {
   1bac8:	7819      	ldrb	r1, [r3, #0]
   1baca:	78d0      	ldrb	r0, [r2, #3]
   1bacc:	7815      	ldrb	r5, [r2, #0]
   1bace:	42a1      	cmp	r1, r4
   1bad0:	bf24      	itt	cs
   1bad2:	7892      	ldrbcs	r2, [r2, #2]
		*idx = first;
   1bad4:	701a      	strbcs	r2, [r3, #0]
	if (*idx == last) {
   1bad6:	7819      	ldrb	r1, [r3, #0]
   1bad8:	4288      	cmp	r0, r1
   1bada:	d009      	beq.n	1baf0 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
   1badc:	1c4a      	adds	r2, r1, #1
	p = (void *)(fifo + (*idx) * size);
   1bade:	4806      	ldr	r0, [pc, #24]	; (1baf8 <ull_prepare_dequeue_iter+0x38>)
	i = *idx + 1;
   1bae0:	b2d2      	uxtb	r2, r2
		i = 0U;
   1bae2:	4294      	cmp	r4, r2
   1bae4:	bf08      	it	eq
   1bae6:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
   1bae8:	fb01 0005 	mla	r0, r1, r5, r0
	*idx = i;
   1baec:	701a      	strb	r2, [r3, #0]
}
   1baee:	bd30      	pop	{r4, r5, pc}
		return NULL;
   1baf0:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1baf2:	e7fc      	b.n	1baee <ull_prepare_dequeue_iter+0x2e>
   1baf4:	20000884 	.word	0x20000884
   1baf8:	20000888 	.word	0x20000888

0001bafc <ull_prepare_dequeue>:
{
   1bafc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bb00:	4605      	mov	r5, r0
	next = ull_prepare_dequeue_get();
   1bb02:	f7ff ffcf 	bl	1baa4 <ull_prepare_dequeue_get>
			mfy.param = next;
   1bb06:	4f1c      	ldr	r7, [pc, #112]	; (1bb78 <ull_prepare_dequeue+0x7c>)
		MFIFO_DEQUEUE(prep);
   1bb08:	4c1c      	ldr	r4, [pc, #112]	; (1bb7c <ull_prepare_dequeue+0x80>)
	while (next) {
   1bb0a:	2800      	cmp	r0, #0
   1bb0c:	d031      	beq.n	1bb72 <ull_prepare_dequeue+0x76>
		uint8_t is_aborted = next->is_aborted;
   1bb0e:	7f03      	ldrb	r3, [r0, #28]
		if (!is_aborted) {
   1bb10:	079a      	lsls	r2, r3, #30
		uint8_t is_aborted = next->is_aborted;
   1bb12:	f3c3 0640 	ubfx	r6, r3, #1, #1
		uint8_t is_resume = next->is_resume;
   1bb16:	f003 0801 	and.w	r8, r3, #1
		if (!is_aborted) {
   1bb1a:	d414      	bmi.n	1bb46 <ull_prepare_dequeue+0x4a>
			mfy.param = next;
   1bb1c:	60b8      	str	r0, [r7, #8]
			ret = mayfly_enqueue(caller_id, TICKER_USER_ID_LLL, 0,
   1bb1e:	4b16      	ldr	r3, [pc, #88]	; (1bb78 <ull_prepare_dequeue+0x7c>)
   1bb20:	4632      	mov	r2, r6
   1bb22:	4631      	mov	r1, r6
   1bb24:	4628      	mov	r0, r5
   1bb26:	f7fd fc99 	bl	1945c <mayfly_enqueue>
			LL_ASSERT(!ret);
   1bb2a:	b160      	cbz	r0, 1bb46 <ull_prepare_dequeue+0x4a>
   1bb2c:	4a14      	ldr	r2, [pc, #80]	; (1bb80 <ull_prepare_dequeue+0x84>)
   1bb2e:	4915      	ldr	r1, [pc, #84]	; (1bb84 <ull_prepare_dequeue+0x88>)
   1bb30:	4815      	ldr	r0, [pc, #84]	; (1bb88 <ull_prepare_dequeue+0x8c>)
   1bb32:	f240 7376 	movw	r3, #1910	; 0x776
   1bb36:	f009 fb41 	bl	251bc <printk>
   1bb3a:	4040      	eors	r0, r0
   1bb3c:	f380 8811 	msr	BASEPRI, r0
   1bb40:	f04f 0003 	mov.w	r0, #3
   1bb44:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
   1bb46:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
   1bb48:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(prep);
   1bb4a:	7862      	ldrb	r2, [r4, #1]
   1bb4c:	4299      	cmp	r1, r3
   1bb4e:	d005      	beq.n	1bb5c <ull_prepare_dequeue+0x60>
	_first += 1U;
   1bb50:	3301      	adds	r3, #1
   1bb52:	b2db      	uxtb	r3, r3
		_first = 0U;
   1bb54:	429a      	cmp	r2, r3
   1bb56:	bf08      	it	eq
   1bb58:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1bb5a:	70a3      	strb	r3, [r4, #2]
		next = ull_prepare_dequeue_get();
   1bb5c:	f7ff ffa2 	bl	1baa4 <ull_prepare_dequeue_get>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1bb60:	b138      	cbz	r0, 1bb72 <ull_prepare_dequeue+0x76>
   1bb62:	2e00      	cmp	r6, #0
   1bb64:	d1d1      	bne.n	1bb0a <ull_prepare_dequeue+0xe>
   1bb66:	f1b8 0f00 	cmp.w	r8, #0
   1bb6a:	d002      	beq.n	1bb72 <ull_prepare_dequeue+0x76>
   1bb6c:	7f03      	ldrb	r3, [r0, #28]
   1bb6e:	07db      	lsls	r3, r3, #31
   1bb70:	d5cb      	bpl.n	1bb0a <ull_prepare_dequeue+0xe>
}
   1bb72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bb76:	bf00      	nop
   1bb78:	200009ac 	.word	0x200009ac
   1bb7c:	20000884 	.word	0x20000884
   1bb80:	00033fd7 	.word	0x00033fd7
   1bb84:	000340d7 	.word	0x000340d7
   1bb88:	0002f8b5 	.word	0x0002f8b5

0001bb8c <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   1bb8c:	4b06      	ldr	r3, [pc, #24]	; (1bba8 <ull_event_done_extra_get+0x1c>)
   1bb8e:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
   1bb90:	78d8      	ldrb	r0, [r3, #3]
   1bb92:	7819      	ldrb	r1, [r3, #0]
   1bb94:	4290      	cmp	r0, r2
   1bb96:	d005      	beq.n	1bba4 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   1bb98:	fb02 3301 	mla	r3, r2, r1, r3
   1bb9c:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
   1bb9e:	b110      	cbz	r0, 1bba6 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   1bba0:	3020      	adds	r0, #32
   1bba2:	4770      	bx	lr
		return NULL;
   1bba4:	2000      	movs	r0, #0
}
   1bba6:	4770      	bx	lr
   1bba8:	20000848 	.word	0x20000848

0001bbac <ull_event_done>:
{
   1bbac:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   1bbae:	4a10      	ldr	r2, [pc, #64]	; (1bbf0 <ull_event_done+0x44>)
	uint8_t _first = *first; /* Copy read-index */
   1bbb0:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1bbb2:	78d4      	ldrb	r4, [r2, #3]
   1bbb4:	7855      	ldrb	r5, [r2, #1]
   1bbb6:	429c      	cmp	r4, r3
{
   1bbb8:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
   1bbba:	7810      	ldrb	r0, [r2, #0]
   1bbbc:	d016      	beq.n	1bbec <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
   1bbbe:	fb03 2000 	mla	r0, r3, r0, r2
	_first += 1U;
   1bbc2:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   1bbc4:	6844      	ldr	r4, [r0, #4]
	_first += 1U;
   1bbc6:	b2db      	uxtb	r3, r3
		_first = 0U;
   1bbc8:	429d      	cmp	r5, r3
   1bbca:	bf08      	it	eq
   1bbcc:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1bbce:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
   1bbd0:	b154      	cbz	r4, 1bbe8 <ull_event_done+0x3c>
	evdone->hdr.link = NULL;
   1bbd2:	2300      	movs	r3, #0
	link = evdone->hdr.link;
   1bbd4:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
   1bbd6:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   1bbd8:	2302      	movs	r3, #2
   1bbda:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
   1bbdc:	61e1      	str	r1, [r4, #28]
	ull_rx_put_done(link, evdone);
   1bbde:	4621      	mov	r1, r4
   1bbe0:	f7ff ff24 	bl	1ba2c <ull_rx_put_done>
	ull_rx_sched_done();
   1bbe4:	f7ff ff28 	bl	1ba38 <ull_rx_sched_done>
}
   1bbe8:	4620      	mov	r0, r4
   1bbea:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   1bbec:	2400      	movs	r4, #0
   1bbee:	e7fb      	b.n	1bbe8 <ull_event_done+0x3c>
   1bbf0:	20000848 	.word	0x20000848

0001bbf4 <init_reset>:
{
   1bbf4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	RXFIFO_INIT_ALLOC(done);
   1bbf6:	4c3d      	ldr	r4, [pc, #244]	; (1bcec <init_reset+0xf8>)
   1bbf8:	4d3d      	ldr	r5, [pc, #244]	; (1bcf0 <init_reset+0xfc>)
   1bbfa:	79a2      	ldrb	r2, [r4, #6]
   1bbfc:	88a1      	ldrh	r1, [r4, #4]
   1bbfe:	4e3d      	ldr	r6, [pc, #244]	; (1bcf4 <init_reset+0x100>)
   1bc00:	2300      	movs	r3, #0
   1bc02:	f104 0008 	add.w	r0, r4, #8
   1bc06:	806b      	strh	r3, [r5, #2]
   1bc08:	4623      	mov	r3, r4
   1bc0a:	f00e fdd9 	bl	2a7c0 <mem_init>
   1bc0e:	79a1      	ldrb	r1, [r4, #6]
   1bc10:	79e2      	ldrb	r2, [r4, #7]
   1bc12:	4633      	mov	r3, r6
   1bc14:	440a      	add	r2, r1
   1bc16:	1d30      	adds	r0, r6, #4
   1bc18:	2108      	movs	r1, #8
   1bc1a:	f00e fdd1 	bl	2a7c0 <mem_init>
   1bc1e:	462a      	mov	r2, r5
   1bc20:	79a3      	ldrb	r3, [r4, #6]
   1bc22:	f812 0b04 	ldrb.w	r0, [r2], #4
   1bc26:	7869      	ldrb	r1, [r5, #1]
   1bc28:	e9cd 2400 	strd	r2, r4, [sp]
   1bc2c:	e9cd 6302 	strd	r6, r3, [sp, #8]
   1bc30:	78aa      	ldrb	r2, [r5, #2]
   1bc32:	1ceb      	adds	r3, r5, #3
   1bc34:	f00f f998 	bl	2af68 <ull_rxfifo_alloc>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
   1bc38:	4b2f      	ldr	r3, [pc, #188]	; (1bcf8 <init_reset+0x104>)
   1bc3a:	2207      	movs	r2, #7
   1bc3c:	1d18      	adds	r0, r3, #4
   1bc3e:	2144      	movs	r1, #68	; 0x44
   1bc40:	f00e fdbe 	bl	2a7c0 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
   1bc44:	4b2d      	ldr	r3, [pc, #180]	; (1bcfc <init_reset+0x108>)
   1bc46:	2209      	movs	r2, #9
   1bc48:	1d18      	adds	r0, r3, #4
   1bc4a:	2108      	movs	r1, #8
   1bc4c:	f00e fdb8 	bl	2a7c0 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
   1bc50:	482a      	ldr	r0, [pc, #168]	; (1bcfc <init_reset+0x108>)
   1bc52:	f00e fddd 	bl	2a810 <mem_acquire>
	LL_ASSERT(link);
   1bc56:	4604      	mov	r4, r0
   1bc58:	b960      	cbnz	r0, 1bc74 <init_reset+0x80>
   1bc5a:	4a29      	ldr	r2, [pc, #164]	; (1bd00 <init_reset+0x10c>)
   1bc5c:	4929      	ldr	r1, [pc, #164]	; (1bd04 <init_reset+0x110>)
   1bc5e:	482a      	ldr	r0, [pc, #168]	; (1bd08 <init_reset+0x114>)
   1bc60:	f640 0302 	movw	r3, #2050	; 0x802
   1bc64:	f009 faaa 	bl	251bc <printk>
   1bc68:	4040      	eors	r0, r0
   1bc6a:	f380 8811 	msr	BASEPRI, r0
   1bc6e:	f04f 0003 	mov.w	r0, #3
   1bc72:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
   1bc74:	4a25      	ldr	r2, [pc, #148]	; (1bd0c <init_reset+0x118>)
   1bc76:	4620      	mov	r0, r4
   1bc78:	1f11      	subs	r1, r2, #4
   1bc7a:	f00e fe19 	bl	2a8b0 <memq_init>
	link = mem_acquire(&mem_link_done.free);
   1bc7e:	481d      	ldr	r0, [pc, #116]	; (1bcf4 <init_reset+0x100>)
   1bc80:	f00e fdc6 	bl	2a810 <mem_acquire>
	LL_ASSERT(link);
   1bc84:	4604      	mov	r4, r0
   1bc86:	b960      	cbnz	r0, 1bca2 <init_reset+0xae>
   1bc88:	4a1d      	ldr	r2, [pc, #116]	; (1bd00 <init_reset+0x10c>)
   1bc8a:	491e      	ldr	r1, [pc, #120]	; (1bd04 <init_reset+0x110>)
   1bc8c:	481e      	ldr	r0, [pc, #120]	; (1bd08 <init_reset+0x114>)
   1bc8e:	f640 030a 	movw	r3, #2058	; 0x80a
   1bc92:	f009 fa93 	bl	251bc <printk>
   1bc96:	4040      	eors	r0, r0
   1bc98:	f380 8811 	msr	BASEPRI, r0
   1bc9c:	f04f 0003 	mov.w	r0, #3
   1bca0:	df02      	svc	2
	MEMQ_INIT(ull_done, link);
   1bca2:	4a1b      	ldr	r2, [pc, #108]	; (1bd10 <init_reset+0x11c>)
   1bca4:	4620      	mov	r0, r4
   1bca6:	1f11      	subs	r1, r2, #4
   1bca8:	f00e fe02 	bl	2a8b0 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
   1bcac:	4813      	ldr	r0, [pc, #76]	; (1bcfc <init_reset+0x108>)
   1bcae:	f00e fdaf 	bl	2a810 <mem_acquire>
	LL_ASSERT(link);
   1bcb2:	4604      	mov	r4, r0
   1bcb4:	b960      	cbnz	r0, 1bcd0 <init_reset+0xdc>
   1bcb6:	4a12      	ldr	r2, [pc, #72]	; (1bd00 <init_reset+0x10c>)
   1bcb8:	4912      	ldr	r1, [pc, #72]	; (1bd04 <init_reset+0x110>)
   1bcba:	4813      	ldr	r0, [pc, #76]	; (1bd08 <init_reset+0x114>)
   1bcbc:	f640 0312 	movw	r3, #2066	; 0x812
   1bcc0:	f009 fa7c 	bl	251bc <printk>
   1bcc4:	4040      	eors	r0, r0
   1bcc6:	f380 8811 	msr	BASEPRI, r0
   1bcca:	f04f 0003 	mov.w	r0, #3
   1bcce:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
   1bcd0:	4a10      	ldr	r2, [pc, #64]	; (1bd14 <init_reset+0x120>)
   1bcd2:	4620      	mov	r0, r4
   1bcd4:	1f11      	subs	r1, r2, #4
   1bcd6:	f00e fdeb 	bl	2a8b0 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
   1bcda:	4b0f      	ldr	r3, [pc, #60]	; (1bd18 <init_reset+0x124>)
   1bcdc:	2205      	movs	r2, #5
	rx_alloc(UINT8_MAX);
   1bcde:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
   1bce0:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
   1bce2:	f7ff f9e3 	bl	1b0ac <rx_alloc>
}
   1bce6:	2000      	movs	r0, #0
   1bce8:	b004      	add	sp, #16
   1bcea:	bd70      	pop	{r4, r5, r6, pc}
   1bcec:	20000770 	.word	0x20000770
   1bcf0:	20000848 	.word	0x20000848
   1bcf4:	20002a74 	.word	0x20002a74
   1bcf8:	20002af0 	.word	0x20002af0
   1bcfc:	20002aa4 	.word	0x20002aa4
   1bd00:	00033fd7 	.word	0x00033fd7
   1bd04:	000337d3 	.word	0x000337d3
   1bd08:	0002f8b5 	.word	0x0002f8b5
   1bd0c:	20002ce4 	.word	0x20002ce4
   1bd10:	20002cdc 	.word	0x20002cdc
   1bd14:	20002cd4 	.word	0x20002cd4
   1bd18:	20002aa0 	.word	0x20002aa0

0001bd1c <ll_init>:
{
   1bd1c:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
   1bd1e:	4b2c      	ldr	r3, [pc, #176]	; (1bdd0 <ll_init+0xb4>)
{
   1bd20:	b086      	sub	sp, #24
	sem_recv = sem_rx;
   1bd22:	6018      	str	r0, [r3, #0]
	cntr_init();
   1bd24:	f004 f816 	bl	1fd54 <cntr_init>
	mayfly_init();
   1bd28:	f7fd fb40 	bl	193ac <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   1bd2c:	4a29      	ldr	r2, [pc, #164]	; (1bdd4 <ll_init+0xb8>)
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
   1bd2e:	2105      	movs	r1, #5
   1bd30:	7211      	strb	r1, [r2, #8]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   1bd32:	2102      	movs	r1, #2
   1bd34:	7411      	strb	r1, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_THREAD_OPS;
   1bd36:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   1bd38:	2304      	movs	r3, #4
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   1bd3a:	4927      	ldr	r1, [pc, #156]	; (1bdd8 <ll_init+0xbc>)
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   1bd3c:	7013      	strb	r3, [r2, #0]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   1bd3e:	9105      	str	r1, [sp, #20]
   1bd40:	4926      	ldr	r1, [pc, #152]	; (1bddc <ll_init+0xc0>)
   1bd42:	9104      	str	r1, [sp, #16]
   1bd44:	4926      	ldr	r1, [pc, #152]	; (1bde0 <ll_init+0xc4>)
   1bd46:	9103      	str	r1, [sp, #12]
   1bd48:	4926      	ldr	r1, [pc, #152]	; (1bde4 <ll_init+0xc8>)
   1bd4a:	9102      	str	r1, [sp, #8]
   1bd4c:	210d      	movs	r1, #13
   1bd4e:	e9cd 2100 	strd	r2, r1, [sp]
   1bd52:	2000      	movs	r0, #0
   1bd54:	4a24      	ldr	r2, [pc, #144]	; (1bde8 <ll_init+0xcc>)
   1bd56:	2108      	movs	r1, #8
   1bd58:	f7fe f850 	bl	19dfc <ticker_init>
	LL_ASSERT(!err);
   1bd5c:	b160      	cbz	r0, 1bd78 <ll_init+0x5c>
   1bd5e:	4a23      	ldr	r2, [pc, #140]	; (1bdec <ll_init+0xd0>)
   1bd60:	4923      	ldr	r1, [pc, #140]	; (1bdf0 <ll_init+0xd4>)
   1bd62:	4824      	ldr	r0, [pc, #144]	; (1bdf4 <ll_init+0xd8>)
   1bd64:	f240 230d 	movw	r3, #525	; 0x20d
   1bd68:	f009 fa28 	bl	251bc <printk>
   1bd6c:	4040      	eors	r0, r0
   1bd6e:	f380 8811 	msr	BASEPRI, r0
   1bd72:	f04f 0003 	mov.w	r0, #3
   1bd76:	df02      	svc	2
	return z_impl_k_sem_init(sem, initial_count, limit);
   1bd78:	2201      	movs	r2, #1
   1bd7a:	2100      	movs	r1, #0
   1bd7c:	481e      	ldr	r0, [pc, #120]	; (1bdf8 <ll_init+0xdc>)
   1bd7e:	f010 ff7e 	bl	2cc7e <z_impl_k_sem_init>
	err = lll_init();
   1bd82:	f002 fae9 	bl	1e358 <lll_init>
	if (err) {
   1bd86:	4604      	mov	r4, r0
   1bd88:	b9f0      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = init_reset();
   1bd8a:	f7ff ff33 	bl	1bbf4 <init_reset>
	if (err) {
   1bd8e:	4604      	mov	r4, r0
   1bd90:	b9d0      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = lll_adv_init();
   1bd92:	f002 fe37 	bl	1ea04 <lll_adv_init>
	if (err) {
   1bd96:	4604      	mov	r4, r0
   1bd98:	b9b0      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = ull_adv_init();
   1bd9a:	f00f f970 	bl	2b07e <ull_adv_init>
	if (err) {
   1bd9e:	4604      	mov	r4, r0
   1bda0:	b990      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = lll_scan_init();
   1bda2:	f00f fdac 	bl	2b8fe <lll_scan_init>
	if (err) {
   1bda6:	4604      	mov	r4, r0
   1bda8:	b970      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = ull_scan_init();
   1bdaa:	f00f fa29 	bl	2b200 <ull_scan_init>
	if (err) {
   1bdae:	4604      	mov	r4, r0
   1bdb0:	b950      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = lll_conn_init();
   1bdb2:	f00f fda8 	bl	2b906 <lll_conn_init>
	if (err) {
   1bdb6:	4604      	mov	r4, r0
   1bdb8:	b930      	cbnz	r0, 1bdc8 <ll_init+0xac>
	err = ull_conn_init();
   1bdba:	f00f fba2 	bl	2b502 <ull_conn_init>
	if (err) {
   1bdbe:	4604      	mov	r4, r0
   1bdc0:	b910      	cbnz	r0, 1bdc8 <ll_init+0xac>
		ull_filter_reset(true);
   1bdc2:	2001      	movs	r0, #1
   1bdc4:	f002 f8b2 	bl	1df2c <ull_filter_reset>
}
   1bdc8:	4620      	mov	r0, r4
   1bdca:	b006      	add	sp, #24
   1bdcc:	bd10      	pop	{r4, pc}
   1bdce:	bf00      	nop
   1bdd0:	20002ce8 	.word	0x20002ce8
   1bdd4:	20003128 	.word	0x20003128
   1bdd8:	0002badf 	.word	0x0002badf
   1bddc:	0002064d 	.word	0x0002064d
   1bde0:	000205f5 	.word	0x000205f5
   1bde4:	20002e84 	.word	0x20002e84
   1bde8:	20002d04 	.word	0x20002d04
   1bdec:	00033fd7 	.word	0x00033fd7
   1bdf0:	0003404c 	.word	0x0003404c
   1bdf4:	0002f8b5 	.word	0x0002f8b5
   1bdf8:	20002cec 	.word	0x20002cec

0001bdfc <ll_reset>:
{
   1bdfc:	b510      	push	{r4, lr}
   1bdfe:	b086      	sub	sp, #24
	err = ull_adv_reset();
   1be00:	f00f f93f 	bl	2b082 <ull_adv_reset>
	LL_ASSERT(!err);
   1be04:	b160      	cbz	r0, 1be20 <ll_reset+0x24>
   1be06:	4a3e      	ldr	r2, [pc, #248]	; (1bf00 <ll_reset+0x104>)
   1be08:	493e      	ldr	r1, [pc, #248]	; (1bf04 <ll_reset+0x108>)
   1be0a:	483f      	ldr	r0, [pc, #252]	; (1bf08 <ll_reset+0x10c>)
   1be0c:	f240 23ad 	movw	r3, #685	; 0x2ad
   1be10:	f009 f9d4 	bl	251bc <printk>
   1be14:	4040      	eors	r0, r0
   1be16:	f380 8811 	msr	BASEPRI, r0
   1be1a:	f04f 0003 	mov.w	r0, #3
   1be1e:	df02      	svc	2
	err = ull_scan_reset();
   1be20:	f00f fa04 	bl	2b22c <ull_scan_reset>
	LL_ASSERT(!err);
   1be24:	b160      	cbz	r0, 1be40 <ll_reset+0x44>
   1be26:	4a36      	ldr	r2, [pc, #216]	; (1bf00 <ll_reset+0x104>)
   1be28:	4936      	ldr	r1, [pc, #216]	; (1bf04 <ll_reset+0x108>)
   1be2a:	4837      	ldr	r0, [pc, #220]	; (1bf08 <ll_reset+0x10c>)
   1be2c:	f240 23b3 	movw	r3, #691	; 0x2b3
   1be30:	f009 f9c4 	bl	251bc <printk>
   1be34:	4040      	eors	r0, r0
   1be36:	f380 8811 	msr	BASEPRI, r0
   1be3a:	f04f 0003 	mov.w	r0, #3
   1be3e:	df02      	svc	2
	err = ull_conn_reset();
   1be40:	f000 ffa2 	bl	1cd88 <ull_conn_reset>
	LL_ASSERT(!err);
   1be44:	b160      	cbz	r0, 1be60 <ll_reset+0x64>
   1be46:	4a2e      	ldr	r2, [pc, #184]	; (1bf00 <ll_reset+0x104>)
   1be48:	492e      	ldr	r1, [pc, #184]	; (1bf04 <ll_reset+0x108>)
   1be4a:	482f      	ldr	r0, [pc, #188]	; (1bf08 <ll_reset+0x10c>)
   1be4c:	f240 23de 	movw	r3, #734	; 0x2de
   1be50:	f009 f9b4 	bl	251bc <printk>
   1be54:	4040      	eors	r0, r0
   1be56:	f380 8811 	msr	BASEPRI, r0
   1be5a:	f04f 0003 	mov.w	r0, #3
   1be5e:	df02      	svc	2
	MFIFO_INIT(tx_ack);
   1be60:	4b2a      	ldr	r3, [pc, #168]	; (1bf0c <ll_reset+0x110>)
   1be62:	2400      	movs	r4, #0
   1be64:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
   1be66:	4620      	mov	r0, r4
   1be68:	f002 f860 	bl	1df2c <ull_filter_reset>
	MFIFO_INIT(prep);
   1be6c:	4b28      	ldr	r3, [pc, #160]	; (1bf10 <ll_reset+0x114>)
   1be6e:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
   1be70:	4b28      	ldr	r3, [pc, #160]	; (1bf14 <ll_reset+0x118>)
   1be72:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(ll_pdu_rx_free);
   1be74:	4b28      	ldr	r3, [pc, #160]	; (1bf18 <ll_reset+0x11c>)
   1be76:	805c      	strh	r4, [r3, #2]
   1be78:	2201      	movs	r2, #1
   1be7a:	4621      	mov	r1, r4
   1be7c:	4668      	mov	r0, sp
   1be7e:	f010 fefe 	bl	2cc7e <z_impl_k_sem_init>
		mfy.param = &sem;
   1be82:	4b26      	ldr	r3, [pc, #152]	; (1bf1c <ll_reset+0x120>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1be84:	4622      	mov	r2, r4
   1be86:	4621      	mov	r1, r4
   1be88:	2003      	movs	r0, #3
		mfy.param = &sem;
   1be8a:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1be8e:	f7fd fae5 	bl	1945c <mayfly_enqueue>
		LL_ASSERT(!retval);
   1be92:	b160      	cbz	r0, 1beae <ll_reset+0xb2>
   1be94:	4a1a      	ldr	r2, [pc, #104]	; (1bf00 <ll_reset+0x104>)
   1be96:	4922      	ldr	r1, [pc, #136]	; (1bf20 <ll_reset+0x124>)
   1be98:	481b      	ldr	r0, [pc, #108]	; (1bf08 <ll_reset+0x10c>)
   1be9a:	f240 330d 	movw	r3, #781	; 0x30d
   1be9e:	f009 f98d 	bl	251bc <printk>
   1bea2:	4040      	eors	r0, r0
   1bea4:	f380 8811 	msr	BASEPRI, r0
   1bea8:	f04f 0003 	mov.w	r0, #3
   1beac:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1beae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1beb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1beb6:	4668      	mov	r0, sp
   1beb8:	f008 f872 	bl	23fa0 <z_impl_k_sem_take>
	err = ull_adv_reset_finalize();
   1bebc:	f000 fb7a 	bl	1c5b4 <ull_adv_reset_finalize>
	LL_ASSERT(!err);
   1bec0:	b160      	cbz	r0, 1bedc <ll_reset+0xe0>
   1bec2:	4a0f      	ldr	r2, [pc, #60]	; (1bf00 <ll_reset+0x104>)
   1bec4:	490f      	ldr	r1, [pc, #60]	; (1bf04 <ll_reset+0x108>)
   1bec6:	4810      	ldr	r0, [pc, #64]	; (1bf08 <ll_reset+0x10c>)
   1bec8:	f240 331a 	movw	r3, #794	; 0x31a
   1becc:	f009 f976 	bl	251bc <printk>
   1bed0:	4040      	eors	r0, r0
   1bed2:	f380 8811 	msr	BASEPRI, r0
   1bed6:	f04f 0003 	mov.w	r0, #3
   1beda:	df02      	svc	2
	err = init_reset();
   1bedc:	f7ff fe8a 	bl	1bbf4 <init_reset>
	LL_ASSERT(!err);
   1bee0:	b160      	cbz	r0, 1befc <ll_reset+0x100>
   1bee2:	4a07      	ldr	r2, [pc, #28]	; (1bf00 <ll_reset+0x104>)
   1bee4:	4907      	ldr	r1, [pc, #28]	; (1bf04 <ll_reset+0x108>)
   1bee6:	4808      	ldr	r0, [pc, #32]	; (1bf08 <ll_reset+0x10c>)
   1bee8:	f240 3327 	movw	r3, #807	; 0x327
   1beec:	f009 f966 	bl	251bc <printk>
   1bef0:	4040      	eors	r0, r0
   1bef2:	f380 8811 	msr	BASEPRI, r0
   1bef6:	f04f 0003 	mov.w	r0, #3
   1befa:	df02      	svc	2
}
   1befc:	b006      	add	sp, #24
   1befe:	bd10      	pop	{r4, pc}
   1bf00:	00033fd7 	.word	0x00033fd7
   1bf04:	0003404c 	.word	0x0003404c
   1bf08:	0002f8b5 	.word	0x0002f8b5
   1bf0c:	20000988 	.word	0x20000988
   1bf10:	20000884 	.word	0x20000884
   1bf14:	2000086c 	.word	0x2000086c
   1bf18:	20000860 	.word	0x20000860
   1bf1c:	200009bc 	.word	0x200009bc
   1bf20:	000340f9 	.word	0x000340f9

0001bf24 <ull_done>:
{
   1bf24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		break;
	}

	/* Release done */
	done->extra.type = 0U;
	release = RXFIFO_RELEASE(done, link, done);
   1bf28:	4f33      	ldr	r7, [pc, #204]	; (1bff8 <ull_done+0xd4>)
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
   1bf2a:	4e34      	ldr	r6, [pc, #208]	; (1bffc <ull_done+0xd8>)
{
   1bf2c:	b087      	sub	sp, #28
	release = RXFIFO_RELEASE(done, link, done);
   1bf2e:	f107 0904 	add.w	r9, r7, #4
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
   1bf32:	e9d6 0100 	ldrd	r0, r1, [r6]
   1bf36:	aa05      	add	r2, sp, #20
   1bf38:	f00e fccf 	bl	2a8da <memq_peek>
		if (link) {
   1bf3c:	4680      	mov	r8, r0
   1bf3e:	2800      	cmp	r0, #0
   1bf40:	d057      	beq.n	1bff2 <ull_done+0xce>
			(void)memq_dequeue(memq_ull_done.tail,
   1bf42:	6870      	ldr	r0, [r6, #4]
   1bf44:	2200      	movs	r2, #0
   1bf46:	4631      	mov	r1, r6
   1bf48:	f00e fccf 	bl	2a8ea <memq_dequeue>
			rx_demux_event_done(link, done);
   1bf4c:	9d05      	ldr	r5, [sp, #20]
	ull_hdr = done->param;
   1bf4e:	69ec      	ldr	r4, [r5, #28]
	if (ull_hdr) {
   1bf50:	b194      	cbz	r4, 1bf78 <ull_done+0x54>
   1bf52:	7823      	ldrb	r3, [r4, #0]
		LL_ASSERT(ull_ref_get(ull_hdr));
   1bf54:	b963      	cbnz	r3, 1bf70 <ull_done+0x4c>
   1bf56:	4a2a      	ldr	r2, [pc, #168]	; (1c000 <ull_done+0xdc>)
   1bf58:	492a      	ldr	r1, [pc, #168]	; (1c004 <ull_done+0xe0>)
   1bf5a:	482b      	ldr	r0, [pc, #172]	; (1c008 <ull_done+0xe4>)
   1bf5c:	f640 2312 	movw	r3, #2578	; 0xa12
   1bf60:	f009 f92c 	bl	251bc <printk>
   1bf64:	4040      	eors	r0, r0
   1bf66:	f380 8811 	msr	BASEPRI, r0
   1bf6a:	f04f 0003 	mov.w	r0, #3
   1bf6e:	df02      	svc	2
	return hdr->ref--;
   1bf70:	7823      	ldrb	r3, [r4, #0]
   1bf72:	3b01      	subs	r3, #1
   1bf74:	b2db      	uxtb	r3, r3
   1bf76:	7023      	strb	r3, [r4, #0]
	switch (done->extra.type) {
   1bf78:	f895 3020 	ldrb.w	r3, [r5, #32]
   1bf7c:	b123      	cbz	r3, 1bf88 <ull_done+0x64>
   1bf7e:	2b01      	cmp	r3, #1
   1bf80:	d129      	bne.n	1bfd6 <ull_done+0xb2>
		ull_conn_done(done);
   1bf82:	4628      	mov	r0, r5
   1bf84:	f001 fc6a 	bl	1d85c <ull_conn_done>
	done->extra.type = 0U;
   1bf88:	2300      	movs	r3, #0
   1bf8a:	f885 3020 	strb.w	r3, [r5, #32]
	release = RXFIFO_RELEASE(done, link, done);
   1bf8e:	78ba      	ldrb	r2, [r7, #2]
   1bf90:	4b1e      	ldr	r3, [pc, #120]	; (1c00c <ull_done+0xe8>)
   1bf92:	7879      	ldrb	r1, [r7, #1]
   1bf94:	7838      	ldrb	r0, [r7, #0]
   1bf96:	f8cd 9000 	str.w	r9, [sp]
   1bf9a:	e9cd 8501 	strd	r8, r5, [sp, #4]
   1bf9e:	f00f f81b 	bl	2afd8 <ull_rxfifo_release>
	LL_ASSERT(release == done);
   1bfa2:	4285      	cmp	r5, r0
   1bfa4:	d00c      	beq.n	1bfc0 <ull_done+0x9c>
   1bfa6:	4a16      	ldr	r2, [pc, #88]	; (1c000 <ull_done+0xdc>)
   1bfa8:	4919      	ldr	r1, [pc, #100]	; (1c010 <ull_done+0xec>)
   1bfaa:	4817      	ldr	r0, [pc, #92]	; (1c008 <ull_done+0xe4>)
   1bfac:	f44f 6327 	mov.w	r3, #2672	; 0xa70
   1bfb0:	f009 f904 	bl	251bc <printk>
   1bfb4:	4040      	eors	r0, r0
   1bfb6:	f380 8811 	msr	BASEPRI, r0
   1bfba:	f04f 0003 	mov.w	r0, #3
   1bfbe:	df02      	svc	2
	/* LLL done synchronize count */
	lll_done_ull_inc();
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL_DONE */

	/* If disable initiated, signal the semaphore */
	if (ull_hdr && !ull_ref_get(ull_hdr) && ull_hdr->disabled_cb) {
   1bfc0:	2c00      	cmp	r4, #0
   1bfc2:	d0b6      	beq.n	1bf32 <ull_done+0xe>
	return hdr->ref;
   1bfc4:	7823      	ldrb	r3, [r4, #0]
   1bfc6:	2b00      	cmp	r3, #0
   1bfc8:	d1b3      	bne.n	1bf32 <ull_done+0xe>
   1bfca:	6963      	ldr	r3, [r4, #20]
   1bfcc:	2b00      	cmp	r3, #0
   1bfce:	d0b0      	beq.n	1bf32 <ull_done+0xe>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   1bfd0:	69a0      	ldr	r0, [r4, #24]
   1bfd2:	4798      	blx	r3
   1bfd4:	e7ad      	b.n	1bf32 <ull_done+0xe>
		LL_ASSERT(0);
   1bfd6:	4a0a      	ldr	r2, [pc, #40]	; (1c000 <ull_done+0xdc>)
   1bfd8:	490e      	ldr	r1, [pc, #56]	; (1c014 <ull_done+0xf0>)
   1bfda:	480b      	ldr	r0, [pc, #44]	; (1c008 <ull_done+0xe4>)
   1bfdc:	f640 2369 	movw	r3, #2665	; 0xa69
   1bfe0:	f009 f8ec 	bl	251bc <printk>
   1bfe4:	4040      	eors	r0, r0
   1bfe6:	f380 8811 	msr	BASEPRI, r0
   1bfea:	f04f 0003 	mov.w	r0, #3
   1bfee:	df02      	svc	2
		break;
   1bff0:	e7ca      	b.n	1bf88 <ull_done+0x64>
}
   1bff2:	b007      	add	sp, #28
   1bff4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1bff8:	20000848 	.word	0x20000848
   1bffc:	20002cd8 	.word	0x20002cd8
   1c000:	00033fd7 	.word	0x00033fd7
   1c004:	00034101 	.word	0x00034101
   1c008:	0002f8b5 	.word	0x0002f8b5
   1c00c:	2000084b 	.word	0x2000084b
   1c010:	00034116 	.word	0x00034116
   1c014:	00031059 	.word	0x00031059

0001c018 <lll_resume>:
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
				   prepare_param, 0, 0);
}

void lll_resume(void *param)
{
   1c018:	b507      	push	{r0, r1, r2, lr}
	struct lll_event *next;
	int ret;

	next = param;
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
   1c01a:	2201      	movs	r2, #1
   1c01c:	9201      	str	r2, [sp, #4]
				  next->prepare_cb, &next->prepare_param,
				  next->is_resume, 1);
   1c01e:	7f02      	ldrb	r2, [r0, #28]
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
   1c020:	f002 0201 	and.w	r2, r2, #1
   1c024:	9200      	str	r2, [sp, #0]
   1c026:	6902      	ldr	r2, [r0, #16]
{
   1c028:	4603      	mov	r3, r0
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
   1c02a:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
   1c02e:	f002 fb05 	bl	1e63c <lll_prepare_resolve>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   1c032:	b168      	cbz	r0, 1c050 <lll_resume+0x38>
   1c034:	3077      	adds	r0, #119	; 0x77
   1c036:	d00b      	beq.n	1c050 <lll_resume+0x38>
   1c038:	4a07      	ldr	r2, [pc, #28]	; (1c058 <lll_resume+0x40>)
   1c03a:	4908      	ldr	r1, [pc, #32]	; (1c05c <lll_resume+0x44>)
   1c03c:	4808      	ldr	r0, [pc, #32]	; (1c060 <lll_resume+0x48>)
   1c03e:	234f      	movs	r3, #79	; 0x4f
   1c040:	f009 f8bc 	bl	251bc <printk>
   1c044:	4040      	eors	r0, r0
   1c046:	f380 8811 	msr	BASEPRI, r0
   1c04a:	f04f 0003 	mov.w	r0, #3
   1c04e:	df02      	svc	2
}
   1c050:	b003      	add	sp, #12
   1c052:	f85d fb04 	ldr.w	pc, [sp], #4
   1c056:	bf00      	nop
   1c058:	00034132 	.word	0x00034132
   1c05c:	00034174 	.word	0x00034174
   1c060:	0002f8b5 	.word	0x0002f8b5

0001c064 <ticker_stop_cb>:
{
   1c064:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c066:	9d07      	ldr	r5, [sp, #28]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   1c068:	4a17      	ldr	r2, [pc, #92]	; (1c0c8 <ticker_stop_cb+0x64>)
   1c06a:	236c      	movs	r3, #108	; 0x6c
   1c06c:	1aaa      	subs	r2, r5, r2
   1c06e:	fbb2 f2f3 	udiv	r2, r2, r3
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
   1c072:	f012 04ff 	ands.w	r4, r2, #255	; 0xff
   1c076:	d00c      	beq.n	1c092 <ticker_stop_cb+0x2e>
   1c078:	4a14      	ldr	r2, [pc, #80]	; (1c0cc <ticker_stop_cb+0x68>)
   1c07a:	4915      	ldr	r1, [pc, #84]	; (1c0d0 <ticker_stop_cb+0x6c>)
   1c07c:	4815      	ldr	r0, [pc, #84]	; (1c0d4 <ticker_stop_cb+0x70>)
   1c07e:	f640 03cd 	movw	r3, #2253	; 0x8cd
   1c082:	f009 f89b 	bl	251bc <printk>
   1c086:	4040      	eors	r0, r0
   1c088:	f380 8811 	msr	BASEPRI, r0
   1c08c:	f04f 0003 	mov.w	r0, #3
   1c090:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   1c092:	1ca2      	adds	r2, r4, #2
   1c094:	4b10      	ldr	r3, [pc, #64]	; (1c0d8 <ticker_stop_cb+0x74>)
   1c096:	9500      	str	r5, [sp, #0]
   1c098:	b2d2      	uxtb	r2, r2
   1c09a:	2101      	movs	r1, #1
   1c09c:	2000      	movs	r0, #0
   1c09e:	f7fd ffa1 	bl	19fe4 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1c0a2:	f030 0302 	bics.w	r3, r0, #2
   1c0a6:	d00c      	beq.n	1c0c2 <ticker_stop_cb+0x5e>
   1c0a8:	4a08      	ldr	r2, [pc, #32]	; (1c0cc <ticker_stop_cb+0x68>)
   1c0aa:	490c      	ldr	r1, [pc, #48]	; (1c0dc <ticker_stop_cb+0x78>)
   1c0ac:	4809      	ldr	r0, [pc, #36]	; (1c0d4 <ticker_stop_cb+0x70>)
   1c0ae:	f640 03d2 	movw	r3, #2258	; 0x8d2
   1c0b2:	f009 f883 	bl	251bc <printk>
   1c0b6:	4040      	eors	r0, r0
   1c0b8:	f380 8811 	msr	BASEPRI, r0
   1c0bc:	f04f 0003 	mov.w	r0, #3
   1c0c0:	df02      	svc	2
}
   1c0c2:	b003      	add	sp, #12
   1c0c4:	bd30      	pop	{r4, r5, pc}
   1c0c6:	bf00      	nop
   1c0c8:	20003160 	.word	0x20003160
   1c0cc:	0003419b 	.word	0x0003419b
   1c0d0:	000341da 	.word	0x000341da
   1c0d4:	0002f8b5 	.word	0x0002f8b5
   1c0d8:	0001c1e5 	.word	0x0001c1e5
   1c0dc:	000341e5 	.word	0x000341e5

0001c0e0 <disabled_cb>:
{
   1c0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
   1c0e2:	6805      	ldr	r5, [r0, #0]
	LL_ASSERT(adv->link_cc_free);
   1c0e4:	6e2b      	ldr	r3, [r5, #96]	; 0x60
{
   1c0e6:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   1c0e8:	b963      	cbnz	r3, 1c104 <disabled_cb+0x24>
   1c0ea:	4a1b      	ldr	r2, [pc, #108]	; (1c158 <disabled_cb+0x78>)
   1c0ec:	491b      	ldr	r1, [pc, #108]	; (1c15c <disabled_cb+0x7c>)
   1c0ee:	481c      	ldr	r0, [pc, #112]	; (1c160 <disabled_cb+0x80>)
   1c0f0:	f640 131a 	movw	r3, #2330	; 0x91a
   1c0f4:	f009 f862 	bl	251bc <printk>
   1c0f8:	4040      	eors	r0, r0
   1c0fa:	f380 8811 	msr	BASEPRI, r0
   1c0fe:	f04f 0003 	mov.w	r0, #3
   1c102:	df02      	svc	2
	adv->link_cc_free = NULL;
   1c104:	2300      	movs	r3, #0
	link = adv->link_cc_free;
   1c106:	6e2f      	ldr	r7, [r5, #96]	; 0x60
	adv->link_cc_free = NULL;
   1c108:	662b      	str	r3, [r5, #96]	; 0x60
	LL_ASSERT(adv->node_rx_cc_free);
   1c10a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   1c10c:	b963      	cbnz	r3, 1c128 <disabled_cb+0x48>
   1c10e:	4a12      	ldr	r2, [pc, #72]	; (1c158 <disabled_cb+0x78>)
   1c110:	4914      	ldr	r1, [pc, #80]	; (1c164 <disabled_cb+0x84>)
   1c112:	4813      	ldr	r0, [pc, #76]	; (1c160 <disabled_cb+0x80>)
   1c114:	f640 131e 	movw	r3, #2334	; 0x91e
   1c118:	f009 f850 	bl	251bc <printk>
   1c11c:	4040      	eors	r0, r0
   1c11e:	f380 8811 	msr	BASEPRI, r0
   1c122:	f04f 0003 	mov.w	r0, #3
   1c126:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   1c128:	6e6c      	ldr	r4, [r5, #100]	; 0x64
	adv->node_rx_cc_free = NULL;
   1c12a:	2100      	movs	r1, #0
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1c12c:	2316      	movs	r3, #22
	adv->node_rx_cc_free = NULL;
   1c12e:	6669      	str	r1, [r5, #100]	; 0x64
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1c130:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   1c132:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1c136:	80e3      	strh	r3, [r4, #6]
	memset(cc, 0x00, sizeof(struct node_rx_cc));
   1c138:	2212      	movs	r2, #18
   1c13a:	f104 001c 	add.w	r0, r4, #28
   1c13e:	f00b fba2 	bl	27886 <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
   1c142:	233c      	movs	r3, #60	; 0x3c
   1c144:	7723      	strb	r3, [r4, #28]
	rx->hdr.rx_ftr.param = param;
   1c146:	60a6      	str	r6, [r4, #8]
	ll_rx_put(link, rx);
   1c148:	4621      	mov	r1, r4
   1c14a:	4638      	mov	r0, r7
   1c14c:	f7ff fa46 	bl	1b5dc <ll_rx_put>
}
   1c150:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   1c154:	f7ff ba4c 	b.w	1b5f0 <ll_rx_sched>
   1c158:	0003419b 	.word	0x0003419b
   1c15c:	000341fe 	.word	0x000341fe
   1c160:	0002f8b5 	.word	0x0002f8b5
   1c164:	00034210 	.word	0x00034210

0001c168 <conn_release>:
{
   1c168:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   1c16a:	6a05      	ldr	r5, [r0, #32]
	LL_ASSERT(!lll->link_tx_free);
   1c16c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
{
   1c16e:	4604      	mov	r4, r0
	LL_ASSERT(!lll->link_tx_free);
   1c170:	b163      	cbz	r3, 1c18c <conn_release+0x24>
   1c172:	4a18      	ldr	r2, [pc, #96]	; (1c1d4 <conn_release+0x6c>)
   1c174:	4918      	ldr	r1, [pc, #96]	; (1c1d8 <conn_release+0x70>)
   1c176:	4819      	ldr	r0, [pc, #100]	; (1c1dc <conn_release+0x74>)
   1c178:	f640 1348 	movw	r3, #2376	; 0x948
   1c17c:	f009 f81e 	bl	251bc <printk>
   1c180:	4040      	eors	r0, r0
   1c182:	f380 8811 	msr	BASEPRI, r0
   1c186:	f04f 0003 	mov.w	r0, #3
   1c18a:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   1c18c:	f105 0140 	add.w	r1, r5, #64	; 0x40
   1c190:	f105 003c 	add.w	r0, r5, #60	; 0x3c
   1c194:	f00e fb8f 	bl	2a8b6 <memq_deinit>
	LL_ASSERT(link);
   1c198:	4606      	mov	r6, r0
   1c19a:	b960      	cbnz	r0, 1c1b6 <conn_release+0x4e>
   1c19c:	4a0d      	ldr	r2, [pc, #52]	; (1c1d4 <conn_release+0x6c>)
   1c19e:	4910      	ldr	r1, [pc, #64]	; (1c1e0 <conn_release+0x78>)
   1c1a0:	480e      	ldr	r0, [pc, #56]	; (1c1dc <conn_release+0x74>)
   1c1a2:	f640 134a 	movw	r3, #2378	; 0x94a
   1c1a6:	f009 f809 	bl	251bc <printk>
   1c1aa:	4040      	eors	r0, r0
   1c1ac:	f380 8811 	msr	BASEPRI, r0
   1c1b0:	f04f 0003 	mov.w	r0, #3
   1c1b4:	df02      	svc	2
	ll_conn_release(lll->hdr.parent);
   1c1b6:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   1c1b8:	64ee      	str	r6, [r5, #76]	; 0x4c
	adv->lll.conn = NULL;
   1c1ba:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   1c1bc:	f000 fcec 	bl	1cb98 <ll_conn_release>
	ll_rx_release(adv->node_rx_cc_free);
   1c1c0:	6e60      	ldr	r0, [r4, #100]	; 0x64
	adv->lll.conn = NULL;
   1c1c2:	6225      	str	r5, [r4, #32]
	ll_rx_release(adv->node_rx_cc_free);
   1c1c4:	f7ff fa04 	bl	1b5d0 <ll_rx_release>
	ll_rx_link_release(adv->link_cc_free);
   1c1c8:	6e20      	ldr	r0, [r4, #96]	; 0x60
	adv->node_rx_cc_free = NULL;
   1c1ca:	6665      	str	r5, [r4, #100]	; 0x64
	ll_rx_link_release(adv->link_cc_free);
   1c1cc:	f7ff f9f4 	bl	1b5b8 <ll_rx_link_release>
	adv->link_cc_free = NULL;
   1c1d0:	6625      	str	r5, [r4, #96]	; 0x60
}
   1c1d2:	bd70      	pop	{r4, r5, r6, pc}
   1c1d4:	0003419b 	.word	0x0003419b
   1c1d8:	00034225 	.word	0x00034225
   1c1dc:	0002f8b5 	.word	0x0002f8b5
   1c1e0:	000337d3 	.word	0x000337d3

0001c1e4 <ticker_stop_op_cb>:
{
   1c1e4:	b508      	push	{r3, lr}
	if (status != TICKER_STATUS_SUCCESS) {
   1c1e6:	4602      	mov	r2, r0
   1c1e8:	b998      	cbnz	r0, 1c212 <ticker_stop_op_cb+0x2e>
	mfy.param = param;
   1c1ea:	4b0a      	ldr	r3, [pc, #40]	; (1c214 <ticker_stop_op_cb+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1c1ec:	2002      	movs	r0, #2
	mfy.param = param;
   1c1ee:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1c1f0:	2101      	movs	r1, #1
   1c1f2:	f7fd f933 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1c1f6:	b160      	cbz	r0, 1c212 <ticker_stop_op_cb+0x2e>
   1c1f8:	4a07      	ldr	r2, [pc, #28]	; (1c218 <ticker_stop_op_cb+0x34>)
   1c1fa:	4908      	ldr	r1, [pc, #32]	; (1c21c <ticker_stop_op_cb+0x38>)
   1c1fc:	4808      	ldr	r0, [pc, #32]	; (1c220 <ticker_stop_op_cb+0x3c>)
   1c1fe:	f640 03ee 	movw	r3, #2286	; 0x8ee
   1c202:	f008 ffdb 	bl	251bc <printk>
   1c206:	4040      	eors	r0, r0
   1c208:	f380 8811 	msr	BASEPRI, r0
   1c20c:	f04f 0003 	mov.w	r0, #3
   1c210:	df02      	svc	2
}
   1c212:	bd08      	pop	{r3, pc}
   1c214:	20000a2c 	.word	0x20000a2c
   1c218:	0003419b 	.word	0x0003419b
   1c21c:	000340d7 	.word	0x000340d7
   1c220:	0002f8b5 	.word	0x0002f8b5

0001c224 <adv_disable>:
{
   1c224:	b538      	push	{r3, r4, r5, lr}
   1c226:	4604      	mov	r4, r0
   1c228:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
   1c22c:	b34b      	cbz	r3, 1c282 <adv_disable+0x5e>
		mfy.param = &adv->lll;
   1c22e:	4d17      	ldr	r5, [pc, #92]	; (1c28c <adv_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
   1c230:	6963      	ldr	r3, [r4, #20]
		mfy.param = &adv->lll;
   1c232:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
   1c234:	b163      	cbz	r3, 1c250 <adv_disable+0x2c>
   1c236:	4a16      	ldr	r2, [pc, #88]	; (1c290 <adv_disable+0x6c>)
   1c238:	4916      	ldr	r1, [pc, #88]	; (1c294 <adv_disable+0x70>)
   1c23a:	4817      	ldr	r0, [pc, #92]	; (1c298 <adv_disable+0x74>)
   1c23c:	f640 1303 	movw	r3, #2307	; 0x903
   1c240:	f008 ffbc 	bl	251bc <printk>
   1c244:	4040      	eors	r0, r0
   1c246:	f380 8811 	msr	BASEPRI, r0
   1c24a:	f04f 0003 	mov.w	r0, #3
   1c24e:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   1c250:	68ab      	ldr	r3, [r5, #8]
   1c252:	61a3      	str	r3, [r4, #24]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c254:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   1c256:	4b11      	ldr	r3, [pc, #68]	; (1c29c <adv_disable+0x78>)
   1c258:	6163      	str	r3, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c25a:	4611      	mov	r1, r2
   1c25c:	4b0b      	ldr	r3, [pc, #44]	; (1c28c <adv_disable+0x68>)
   1c25e:	2001      	movs	r0, #1
   1c260:	f7fd f8fc 	bl	1945c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1c264:	b160      	cbz	r0, 1c280 <adv_disable+0x5c>
   1c266:	4a0a      	ldr	r2, [pc, #40]	; (1c290 <adv_disable+0x6c>)
   1c268:	490d      	ldr	r1, [pc, #52]	; (1c2a0 <adv_disable+0x7c>)
   1c26a:	480b      	ldr	r0, [pc, #44]	; (1c298 <adv_disable+0x74>)
   1c26c:	f640 130a 	movw	r3, #2314	; 0x90a
   1c270:	f008 ffa4 	bl	251bc <printk>
   1c274:	4040      	eors	r0, r0
   1c276:	f380 8811 	msr	BASEPRI, r0
   1c27a:	f04f 0003 	mov.w	r0, #3
   1c27e:	df02      	svc	2
}
   1c280:	bd38      	pop	{r3, r4, r5, pc}
   1c282:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&adv->lll);
   1c286:	f7ff bf2b 	b.w	1c0e0 <disabled_cb>
   1c28a:	bf00      	nop
   1c28c:	20000a1c 	.word	0x20000a1c
   1c290:	0003419b 	.word	0x0003419b
   1c294:	00034238 	.word	0x00034238
   1c298:	0002f8b5 	.word	0x0002f8b5
   1c29c:	0001c0e1 	.word	0x0001c0e1
   1c2a0:	000340d7 	.word	0x000340d7

0001c2a4 <ticker_update_op_cb>:
{
   1c2a4:	b510      	push	{r4, lr}
   1c2a6:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   1c2a8:	b180      	cbz	r0, 1c2cc <ticker_update_op_cb+0x28>
   1c2aa:	f7ff fae1 	bl	1b870 <ull_disable_mark_get>
   1c2ae:	4284      	cmp	r4, r0
   1c2b0:	d00c      	beq.n	1c2cc <ticker_update_op_cb+0x28>
   1c2b2:	4a07      	ldr	r2, [pc, #28]	; (1c2d0 <ticker_update_op_cb+0x2c>)
   1c2b4:	4907      	ldr	r1, [pc, #28]	; (1c2d4 <ticker_update_op_cb+0x30>)
   1c2b6:	4808      	ldr	r0, [pc, #32]	; (1c2d8 <ticker_update_op_cb+0x34>)
   1c2b8:	f640 03bf 	movw	r3, #2239	; 0x8bf
   1c2bc:	f008 ff7e 	bl	251bc <printk>
   1c2c0:	4040      	eors	r0, r0
   1c2c2:	f380 8811 	msr	BASEPRI, r0
   1c2c6:	f04f 0003 	mov.w	r0, #3
   1c2ca:	df02      	svc	2
}
   1c2cc:	bd10      	pop	{r4, pc}
   1c2ce:	bf00      	nop
   1c2d0:	0003419b 	.word	0x0003419b
   1c2d4:	0003424a 	.word	0x0003424a
   1c2d8:	0002f8b5 	.word	0x0002f8b5

0001c2dc <init_reset>:
{
   1c2dc:	b510      	push	{r4, lr}
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
   1c2de:	4c13      	ldr	r4, [pc, #76]	; (1c32c <init_reset+0x50>)
   1c2e0:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1c2e4:	f002 fba6 	bl	1ea34 <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
   1c2e8:	f104 0034 	add.w	r0, r4, #52	; 0x34
   1c2ec:	f002 fba2 	bl	1ea34 <lll_adv_data_init>
	pdu->len = BDADDR_SIZE;
}

static void init_set(struct ll_adv_set *adv)
{
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
   1c2f0:	f44f 6300 	mov.w	r3, #2048	; 0x800
   1c2f4:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
#if defined(CONFIG_BT_CTLR_PRIVACY)
	adv->own_addr_type = BT_ADDR_LE_PUBLIC;
#endif /* CONFIG_BT_CTLR_PRIVACY */
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
   1c2f8:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1c2fa:	f423 7343 	bic.w	r3, r3, #780	; 0x30c
   1c2fe:	f023 0302 	bic.w	r3, r3, #2
   1c302:	f043 030e 	orr.w	r3, r3, #14
   1c306:	84a3      	strh	r3, [r4, #36]	; 0x24
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1c308:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   1c30c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	pdu->len = BDADDR_SIZE;
   1c310:	2206      	movs	r2, #6
   1c312:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	pdu->type = pdu_type;
   1c314:	2000      	movs	r0, #0
	pdu->len = BDADDR_SIZE;
   1c316:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
   1c318:	7018      	strb	r0, [r3, #0]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1c31a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
   1c31e:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   1c322:	2104      	movs	r1, #4
   1c324:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	pdu->len = BDADDR_SIZE;
   1c326:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
   1c328:	7019      	strb	r1, [r3, #0]
}
   1c32a:	bd10      	pop	{r4, pc}
   1c32c:	20003160 	.word	0x20003160

0001c330 <ticker_cb>:
{
   1c330:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c332:	461c      	mov	r4, r3
   1c334:	b08b      	sub	sp, #44	; 0x2c
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
   1c336:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1c33a:	429c      	cmp	r4, r3
{
   1c33c:	9d11      	ldr	r5, [sp, #68]	; 0x44
   1c33e:	4607      	mov	r7, r0
   1c340:	4616      	mov	r6, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
   1c342:	d030      	beq.n	1c3a6 <ticker_cb+0x76>
	return ++hdr->ref;
   1c344:	7829      	ldrb	r1, [r5, #0]
   1c346:	3101      	adds	r1, #1
   1c348:	b2c9      	uxtb	r1, r1
   1c34a:	7029      	strb	r1, [r5, #0]
		LL_ASSERT(ref);
   1c34c:	b961      	cbnz	r1, 1c368 <ticker_cb+0x38>
   1c34e:	4a31      	ldr	r2, [pc, #196]	; (1c414 <ticker_cb+0xe4>)
   1c350:	4931      	ldr	r1, [pc, #196]	; (1c418 <ticker_cb+0xe8>)
   1c352:	4832      	ldr	r0, [pc, #200]	; (1c41c <ticker_cb+0xec>)
   1c354:	f640 0385 	movw	r3, #2181	; 0x885
   1c358:	f008 ff30 	bl	251bc <printk>
   1c35c:	4040      	eors	r0, r0
   1c35e:	f380 8811 	msr	BASEPRI, r0
   1c362:	f04f 0003 	mov.w	r0, #3
   1c366:	df02      	svc	2
		p.ticks_at_expire = ticks_at_expire;
   1c368:	492d      	ldr	r1, [pc, #180]	; (1c420 <ticker_cb+0xf0>)
		p.force = force;
   1c36a:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c36e:	728b      	strb	r3, [r1, #10]
	lll = &adv->lll;
   1c370:	f105 031c 	add.w	r3, r5, #28
		p.param = lll;
   1c374:	60cb      	str	r3, [r1, #12]
		mfy.param = &p;
   1c376:	4b2b      	ldr	r3, [pc, #172]	; (1c424 <ticker_cb+0xf4>)
		p.lazy = lazy;
   1c378:	810c      	strh	r4, [r1, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c37a:	2200      	movs	r2, #0
		p.remainder = remainder;
   1c37c:	e9c1 7600 	strd	r7, r6, [r1]
		mfy.param = &p;
   1c380:	6099      	str	r1, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c382:	2001      	movs	r0, #1
   1c384:	4611      	mov	r1, r2
   1c386:	f7fd f869 	bl	1945c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1c38a:	b160      	cbz	r0, 1c3a6 <ticker_cb+0x76>
   1c38c:	4a21      	ldr	r2, [pc, #132]	; (1c414 <ticker_cb+0xe4>)
   1c38e:	4926      	ldr	r1, [pc, #152]	; (1c428 <ticker_cb+0xf8>)
   1c390:	4822      	ldr	r0, [pc, #136]	; (1c41c <ticker_cb+0xec>)
   1c392:	f640 0392 	movw	r3, #2194	; 0x892
   1c396:	f008 ff11 	bl	251bc <printk>
   1c39a:	4040      	eors	r0, r0
   1c39c:	f380 8811 	msr	BASEPRI, r0
   1c3a0:	f04f 0003 	mov.w	r0, #3
   1c3a4:	df02      	svc	2
	if (!lll->is_hdcd)
   1c3a6:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
   1c3aa:	f014 0401 	ands.w	r4, r4, #1
   1c3ae:	d12f      	bne.n	1c410 <ticker_cb+0xe0>
	lll_rand_isr_get(&random_delay, sizeof(random_delay));
   1c3b0:	2104      	movs	r1, #4
   1c3b2:	a809      	add	r0, sp, #36	; 0x24
   1c3b4:	f00f f922 	bl	2b5fc <lll_rand_isr_get>
	random_delay %= ticks_delay_window;
   1c3b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c3ba:	9506      	str	r5, [sp, #24]
	random_delay %= ticks_delay_window;
   1c3bc:	f240 1247 	movw	r2, #327	; 0x147
   1c3c0:	fbb3 f1f2 	udiv	r1, r3, r2
   1c3c4:	fb02 3311 	mls	r3, r2, r1, r3
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   1c3c8:	4a18      	ldr	r2, [pc, #96]	; (1c42c <ticker_cb+0xfc>)
   1c3ca:	216c      	movs	r1, #108	; 0x6c
   1c3cc:	1aaa      	subs	r2, r5, r2
   1c3ce:	fbb2 f2f1 	udiv	r2, r2, r1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c3d2:	4917      	ldr	r1, [pc, #92]	; (1c430 <ticker_cb+0x100>)
   1c3d4:	3202      	adds	r2, #2
	random_delay += (ticks_delay_window_offset + 1);
   1c3d6:	3301      	adds	r3, #1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c3d8:	e9cd 4104 	strd	r4, r1, [sp, #16]
   1c3dc:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1c3e0:	e9cd 4400 	strd	r4, r4, [sp]
   1c3e4:	b2d2      	uxtb	r2, r2
   1c3e6:	2101      	movs	r1, #1
   1c3e8:	4620      	mov	r0, r4
	random_delay += (ticks_delay_window_offset + 1);
   1c3ea:	9309      	str	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1c3ec:	f00e fd1c 	bl	2ae28 <ticker_update>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1c3f0:	f030 0302 	bics.w	r3, r0, #2
   1c3f4:	d00c      	beq.n	1c410 <ticker_cb+0xe0>
   1c3f6:	4a07      	ldr	r2, [pc, #28]	; (1c414 <ticker_cb+0xe4>)
   1c3f8:	490e      	ldr	r1, [pc, #56]	; (1c434 <ticker_cb+0x104>)
   1c3fa:	4808      	ldr	r0, [pc, #32]	; (1c41c <ticker_cb+0xec>)
   1c3fc:	f240 732c 	movw	r3, #1836	; 0x72c
   1c400:	f008 fedc 	bl	251bc <printk>
   1c404:	4040      	eors	r0, r0
   1c406:	f380 8811 	msr	BASEPRI, r0
   1c40a:	f04f 0003 	mov.w	r0, #3
   1c40e:	df02      	svc	2
}
   1c410:	b00b      	add	sp, #44	; 0x2c
   1c412:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c414:	0003419b 	.word	0x0003419b
   1c418:	00034279 	.word	0x00034279
   1c41c:	0002f8b5 	.word	0x0002f8b5
   1c420:	200031d8 	.word	0x200031d8
   1c424:	20000a0c 	.word	0x20000a0c
   1c428:	000340d7 	.word	0x000340d7
   1c42c:	20003160 	.word	0x20003160
   1c430:	0001c2a5 	.word	0x0001c2a5
   1c434:	000341e5 	.word	0x000341e5

0001c438 <ll_adv_params_set>:
{
   1c438:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!adv || adv->is_enabled) {
   1c43c:	4d57      	ldr	r5, [pc, #348]	; (1c59c <ll_adv_params_set+0x164>)
{
   1c43e:	4698      	mov	r8, r3
	if (!adv || adv->is_enabled) {
   1c440:	f895 606a 	ldrb.w	r6, [r5, #106]	; 0x6a
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1c444:	4b56      	ldr	r3, [pc, #344]	; (1c5a0 <ll_adv_params_set+0x168>)
{
   1c446:	4604      	mov	r4, r0
	if (!adv || adv->is_enabled) {
   1c448:	f016 0601 	ands.w	r6, r6, #1
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1c44c:	6818      	ldr	r0, [r3, #0]
   1c44e:	791b      	ldrb	r3, [r3, #4]
   1c450:	9000      	str	r0, [sp, #0]
{
   1c452:	4617      	mov	r7, r2
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1c454:	f88d 3004 	strb.w	r3, [sp, #4]
	if (!adv || adv->is_enabled) {
   1c458:	f040 809d 	bne.w	1c596 <ll_adv_params_set+0x15e>
		adv->interval = 0;
   1c45c:	2901      	cmp	r1, #1
   1c45e:	bf08      	it	eq
   1c460:	2400      	moveq	r4, #0
   1c462:	f8a5 4068 	strh.w	r4, [r5, #104]	; 0x68
	adv->lll.chan_map = chan_map;
   1c466:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
   1c46a:	f004 0303 	and.w	r3, r4, #3
   1c46e:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
   1c472:	f004 0407 	and.w	r4, r4, #7
   1c476:	0064      	lsls	r4, r4, #1
   1c478:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
   1c47c:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   1c47e:	f423 7343 	bic.w	r3, r3, #780	; 0x30c
   1c482:	f023 0302 	bic.w	r3, r3, #2
   1c486:	431c      	orrs	r4, r3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1c488:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   1c48c:	84ac      	strh	r4, [r5, #36]	; 0x24
   1c48e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   1c492:	ea4f 1a87 	mov.w	sl, r7, lsl #6
   1c496:	6adc      	ldr	r4, [r3, #44]	; 0x2c
	pdu->type = pdu_adv_type[adv_type];
   1c498:	ab02      	add	r3, sp, #8
   1c49a:	4419      	add	r1, r3
	pdu_type_prev = pdu->type;
   1c49c:	7822      	ldrb	r2, [r4, #0]
	pdu->type = pdu_adv_type[adv_type];
   1c49e:	f811 3c08 	ldrb.w	r3, [r1, #-8]
	pdu_type_prev = pdu->type;
   1c4a2:	f002 090f 	and.w	r9, r2, #15
	pdu->type = pdu_adv_type[adv_type];
   1c4a6:	f003 030f 	and.w	r3, r3, #15
   1c4aa:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
   1c4ae:	4313      	orrs	r3, r2
   1c4b0:	7023      	strb	r3, [r4, #0]
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
   1c4b2:	f003 030f 	and.w	r3, r3, #15
   1c4b6:	2b01      	cmp	r3, #1
   1c4b8:	d137      	bne.n	1c52a <ll_adv_params_set+0xf2>
	    (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&
   1c4ba:	f1b9 0f01 	cmp.w	r9, #1
   1c4be:	f104 0b08 	add.w	fp, r4, #8
   1c4c2:	d003      	beq.n	1c4cc <ll_adv_params_set+0x94>
		if (pdu->len == 0U) {
   1c4c4:	7863      	ldrb	r3, [r4, #1]
   1c4c6:	b99b      	cbnz	r3, 1c4f0 <ll_adv_params_set+0xb8>
			adv->ad_data_backup.len = 0U;
   1c4c8:	f885 6040 	strb.w	r6, [r5, #64]	; 0x40
		pdu->tx_addr = own_addr_type & 0x1;
   1c4cc:	f00a 0340 	and.w	r3, sl, #64	; 0x40
   1c4d0:	ea43 18c8 	orr.w	r8, r3, r8, lsl #7
   1c4d4:	7823      	ldrb	r3, [r4, #0]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   1c4d6:	990c      	ldr	r1, [sp, #48]	; 0x30
		pdu->tx_addr = own_addr_type & 0x1;
   1c4d8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1c4dc:	ea48 0803 	orr.w	r8, r8, r3
   1c4e0:	f884 8000 	strb.w	r8, [r4]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   1c4e4:	2206      	movs	r2, #6
   1c4e6:	4658      	mov	r0, fp
   1c4e8:	f00b f9c2 	bl	27870 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   1c4ec:	230c      	movs	r3, #12
   1c4ee:	e027      	b.n	1c540 <ll_adv_params_set+0x108>
			LL_ASSERT(pdu->len >=
   1c4f0:	2b05      	cmp	r3, #5
   1c4f2:	d80c      	bhi.n	1c50e <ll_adv_params_set+0xd6>
   1c4f4:	4a2b      	ldr	r2, [pc, #172]	; (1c5a4 <ll_adv_params_set+0x16c>)
   1c4f6:	492c      	ldr	r1, [pc, #176]	; (1c5a8 <ll_adv_params_set+0x170>)
   1c4f8:	482c      	ldr	r0, [pc, #176]	; (1c5ac <ll_adv_params_set+0x174>)
   1c4fa:	f44f 73ce 	mov.w	r3, #412	; 0x19c
   1c4fe:	f008 fe5d 	bl	251bc <printk>
   1c502:	4040      	eors	r0, r0
   1c504:	f380 8811 	msr	BASEPRI, r0
   1c508:	f04f 0003 	mov.w	r0, #3
   1c50c:	df02      	svc	2
			adv->ad_data_backup.len = pdu->len -
   1c50e:	7862      	ldrb	r2, [r4, #1]
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
   1c510:	4827      	ldr	r0, [pc, #156]	; (1c5b0 <ll_adv_params_set+0x178>)
			adv->ad_data_backup.len = pdu->len -
   1c512:	3a06      	subs	r2, #6
   1c514:	b2d2      	uxtb	r2, r2
   1c516:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
   1c51a:	4659      	mov	r1, fp
   1c51c:	f00b f9a8 	bl	27870 <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1c520:	7823      	ldrb	r3, [r4, #0]
   1c522:	f003 030f 	and.w	r3, r3, #15
   1c526:	2b01      	cmp	r3, #1
   1c528:	d0d0      	beq.n	1c4cc <ll_adv_params_set+0x94>
	} else if (pdu->len == 0) {
   1c52a:	7862      	ldrb	r2, [r4, #1]
		pdu->tx_addr = own_addr_type & 0x1;
   1c52c:	f007 0701 	and.w	r7, r7, #1
	} else if (pdu->len == 0) {
   1c530:	b942      	cbnz	r2, 1c544 <ll_adv_params_set+0x10c>
		pdu->tx_addr = own_addr_type & 0x1;
   1c532:	7823      	ldrb	r3, [r4, #0]
   1c534:	f367 1386 	bfi	r3, r7, #6, #1
		pdu->rx_addr = 0;
   1c538:	f362 13c7 	bfi	r3, r2, #7, #1
   1c53c:	7023      	strb	r3, [r4, #0]
		pdu->len = BDADDR_SIZE;
   1c53e:	2306      	movs	r3, #6
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   1c540:	7063      	strb	r3, [r4, #1]
   1c542:	e013      	b.n	1c56c <ll_adv_params_set+0x134>
		if (((pdu_type_prev == PDU_ADV_TYPE_DIRECT_IND) ||
   1c544:	f1b9 0f01 	cmp.w	r9, #1
   1c548:	d10a      	bne.n	1c560 <ll_adv_params_set+0x128>
			memcpy(pdu->adv_ind.data, adv->ad_data_backup.data,
   1c54a:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
   1c54e:	4918      	ldr	r1, [pc, #96]	; (1c5b0 <ll_adv_params_set+0x178>)
   1c550:	f104 0008 	add.w	r0, r4, #8
   1c554:	f00b f98c 	bl	27870 <memcpy>
			pdu->len = offsetof(struct pdu_adv_adv_ind, data) +
   1c558:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
   1c55c:	3306      	adds	r3, #6
   1c55e:	7063      	strb	r3, [r4, #1]
		pdu->tx_addr = own_addr_type & 0x1;
   1c560:	7823      	ldrb	r3, [r4, #0]
   1c562:	f367 1386 	bfi	r3, r7, #6, #1
		pdu->rx_addr = 0;
   1c566:	f36f 13c7 	bfc	r3, #7, #1
   1c56a:	7023      	strb	r3, [r4, #0]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1c56c:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   1c570:	61ed      	str	r5, [r5, #28]
   1c572:	eb05 0583 	add.w	r5, r5, r3, lsl #2
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1c576:	f00a 0a40 	and.w	sl, sl, #64	; 0x40
   1c57a:	6bab      	ldr	r3, [r5, #56]	; 0x38
		if (pdu->len == 0) {
   1c57c:	785a      	ldrb	r2, [r3, #1]
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1c57e:	f04a 0a04 	orr.w	sl, sl, #4
   1c582:	f883 a000 	strb.w	sl, [r3]
		if (pdu->len == 0) {
   1c586:	b912      	cbnz	r2, 1c58e <ll_adv_params_set+0x156>
			pdu->len = BDADDR_SIZE;
   1c588:	2106      	movs	r1, #6
   1c58a:	7059      	strb	r1, [r3, #1]
	return 0;
   1c58c:	4616      	mov	r6, r2
}
   1c58e:	4630      	mov	r0, r6
   1c590:	b003      	add	sp, #12
   1c592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1c596:	260c      	movs	r6, #12
   1c598:	e7f9      	b.n	1c58e <ll_adv_params_set+0x156>
   1c59a:	bf00      	nop
   1c59c:	20003160 	.word	0x20003160
   1c5a0:	0002dd6e 	.word	0x0002dd6e
   1c5a4:	0003419b 	.word	0x0003419b
   1c5a8:	0003427d 	.word	0x0003427d
   1c5ac:	0002f8b5 	.word	0x0002f8b5
   1c5b0:	200031a1 	.word	0x200031a1

0001c5b4 <ull_adv_reset_finalize>:
{
   1c5b4:	b510      	push	{r4, lr}
		lll_adv_data_reset(&lll->adv_data);
   1c5b6:	4c06      	ldr	r4, [pc, #24]	; (1c5d0 <ull_adv_reset_finalize+0x1c>)
   1c5b8:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1c5bc:	f00f f87f 	bl	2b6be <lll_adv_data_reset>
		lll_adv_data_reset(&lll->scan_rsp);
   1c5c0:	f104 0034 	add.w	r0, r4, #52	; 0x34
   1c5c4:	f00f f87b 	bl	2b6be <lll_adv_data_reset>
}
   1c5c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	err = init_reset();
   1c5cc:	f7ff be86 	b.w	1c2dc <init_reset>
   1c5d0:	20003160 	.word	0x20003160

0001c5d4 <ull_adv_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   1c5d4:	4b03      	ldr	r3, [pc, #12]	; (1c5e4 <ull_adv_handle_get+0x10>)
   1c5d6:	1ac0      	subs	r0, r0, r3
   1c5d8:	236c      	movs	r3, #108	; 0x6c
   1c5da:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1c5de:	b280      	uxth	r0, r0
   1c5e0:	4770      	bx	lr
   1c5e2:	bf00      	nop
   1c5e4:	20003160 	.word	0x20003160

0001c5e8 <ull_adv_lll_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
   1c5e8:	6800      	ldr	r0, [r0, #0]
   1c5ea:	4b03      	ldr	r3, [pc, #12]	; (1c5f8 <ull_adv_lll_handle_get+0x10>)
   1c5ec:	1ac0      	subs	r0, r0, r3
   1c5ee:	236c      	movs	r3, #108	; 0x6c
   1c5f0:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1c5f4:	b280      	uxth	r0, r0
   1c5f6:	4770      	bx	lr
   1c5f8:	20003160 	.word	0x20003160

0001c5fc <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_SET) {
   1c5fc:	b938      	cbnz	r0, 1c60e <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
   1c5fe:	4805      	ldr	r0, [pc, #20]	; (1c614 <ull_adv_is_enabled_get+0x18>)
   1c600:	f890 306a 	ldrb.w	r3, [r0, #106]	; 0x6a
	return &ll_adv[handle];
   1c604:	f013 0f01 	tst.w	r3, #1
   1c608:	bf08      	it	eq
   1c60a:	2000      	moveq	r0, #0
   1c60c:	4770      	bx	lr
		return NULL;
   1c60e:	2000      	movs	r0, #0
}
   1c610:	4770      	bx	lr
   1c612:	bf00      	nop
   1c614:	20003160 	.word	0x20003160

0001c618 <disable.constprop.0>:
static inline uint8_t disable(uint8_t handle)
   1c618:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	adv = ull_adv_is_enabled_get(handle);
   1c61a:	2000      	movs	r0, #0
   1c61c:	f7ff ffee 	bl	1c5fc <ull_adv_is_enabled_get>
	if (!adv) {
   1c620:	4604      	mov	r4, r0
   1c622:	2800      	cmp	r0, #0
   1c624:	d037      	beq.n	1c696 <disable.constprop.0+0x7e>
	if (adv->lll.conn) {
   1c626:	6a03      	ldr	r3, [r0, #32]
   1c628:	bb4b      	cbnz	r3, 1c67e <disable.constprop.0+0x66>
	mark = ull_disable_mark(adv);
   1c62a:	4620      	mov	r0, r4
   1c62c:	f7ff f90a 	bl	1b844 <ull_disable_mark>
	LL_ASSERT(mark == adv);
   1c630:	4284      	cmp	r4, r0
   1c632:	d132      	bne.n	1c69a <disable.constprop.0+0x82>
	if (adv->lll.is_hdcd) {
   1c634:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1c638:	07db      	lsls	r3, r3, #31
   1c63a:	d53c      	bpl.n	1c6b6 <disable.constprop.0+0x9e>
		ret_cb = TICKER_STATUS_BUSY;
   1c63c:	2302      	movs	r3, #2
   1c63e:	9303      	str	r3, [sp, #12]
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1c640:	ab03      	add	r3, sp, #12
   1c642:	9300      	str	r3, [sp, #0]
   1c644:	2103      	movs	r1, #3
   1c646:	4b40      	ldr	r3, [pc, #256]	; (1c748 <disable.constprop.0+0x130>)
   1c648:	2201      	movs	r2, #1
   1c64a:	2000      	movs	r0, #0
   1c64c:	f7fd fcca 	bl	19fe4 <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   1c650:	a903      	add	r1, sp, #12
   1c652:	f7ff f8d1 	bl	1b7f8 <ull_ticker_status_take>
		if (ret) {
   1c656:	b370      	cbz	r0, 1c6b6 <disable.constprop.0+0x9e>
			mark = ull_disable_unmark(adv);
   1c658:	4620      	mov	r0, r4
   1c65a:	f7ff f8fb 	bl	1b854 <ull_disable_unmark>
			LL_ASSERT(mark == adv);
   1c65e:	4284      	cmp	r4, r0
   1c660:	d018      	beq.n	1c694 <disable.constprop.0+0x7c>
   1c662:	f640 230a 	movw	r3, #2570	; 0xa0a
		LL_ASSERT(mark == adv);
   1c666:	4a39      	ldr	r2, [pc, #228]	; (1c74c <disable.constprop.0+0x134>)
   1c668:	4939      	ldr	r1, [pc, #228]	; (1c750 <disable.constprop.0+0x138>)
   1c66a:	483a      	ldr	r0, [pc, #232]	; (1c754 <disable.constprop.0+0x13c>)
   1c66c:	f008 fda6 	bl	251bc <printk>
   1c670:	4040      	eors	r0, r0
   1c672:	f380 8811 	msr	BASEPRI, r0
   1c676:	f04f 0003 	mov.w	r0, #3
   1c67a:	df02      	svc	2
   1c67c:	e00a      	b.n	1c694 <disable.constprop.0+0x7c>
		adv->lll.conn->periph.cancelled = 1U;
   1c67e:	f893 2020 	ldrb.w	r2, [r3, #32]
   1c682:	f042 0202 	orr.w	r2, r2, #2
   1c686:	f883 2020 	strb.w	r2, [r3, #32]
		if (unlikely(adv->lll.conn->periph.initiated)) {
   1c68a:	6a03      	ldr	r3, [r0, #32]
   1c68c:	f893 3020 	ldrb.w	r3, [r3, #32]
   1c690:	07da      	lsls	r2, r3, #31
   1c692:	d5ca      	bpl.n	1c62a <disable.constprop.0+0x12>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1c694:	200c      	movs	r0, #12
}
   1c696:	b004      	add	sp, #16
   1c698:	bd10      	pop	{r4, pc}
	LL_ASSERT(mark == adv);
   1c69a:	4a2c      	ldr	r2, [pc, #176]	; (1c74c <disable.constprop.0+0x134>)
   1c69c:	492c      	ldr	r1, [pc, #176]	; (1c750 <disable.constprop.0+0x138>)
   1c69e:	482d      	ldr	r0, [pc, #180]	; (1c754 <disable.constprop.0+0x13c>)
   1c6a0:	f640 13ff 	movw	r3, #2559	; 0x9ff
   1c6a4:	f008 fd8a 	bl	251bc <printk>
   1c6a8:	4040      	eors	r0, r0
   1c6aa:	f380 8811 	msr	BASEPRI, r0
   1c6ae:	f04f 0003 	mov.w	r0, #3
   1c6b2:	df02      	svc	2
   1c6b4:	e7be      	b.n	1c634 <disable.constprop.0+0x1c>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1c6b6:	ab03      	add	r3, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
   1c6b8:	2202      	movs	r2, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1c6ba:	9300      	str	r3, [sp, #0]
   1c6bc:	2103      	movs	r1, #3
   1c6be:	4b22      	ldr	r3, [pc, #136]	; (1c748 <disable.constprop.0+0x130>)
	ret_cb = TICKER_STATUS_BUSY;
   1c6c0:	9203      	str	r2, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1c6c2:	2000      	movs	r0, #0
   1c6c4:	f7fd fc8e 	bl	19fe4 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1c6c8:	a903      	add	r1, sp, #12
   1c6ca:	f7ff f895 	bl	1b7f8 <ull_ticker_status_take>
	if (ret) {
   1c6ce:	b138      	cbz	r0, 1c6e0 <disable.constprop.0+0xc8>
		mark = ull_disable_unmark(adv);
   1c6d0:	4620      	mov	r0, r4
   1c6d2:	f7ff f8bf 	bl	1b854 <ull_disable_unmark>
		LL_ASSERT(mark == adv);
   1c6d6:	4284      	cmp	r4, r0
   1c6d8:	d0dc      	beq.n	1c694 <disable.constprop.0+0x7c>
   1c6da:	f640 2318 	movw	r3, #2584	; 0xa18
   1c6de:	e7c2      	b.n	1c666 <disable.constprop.0+0x4e>
	err = ull_disable(&adv->lll);
   1c6e0:	f104 001c 	add.w	r0, r4, #28
   1c6e4:	f7ff f8e6 	bl	1b8b4 <ull_disable>
	LL_ASSERT(!err || (err == -EALREADY));
   1c6e8:	b170      	cbz	r0, 1c708 <disable.constprop.0+0xf0>
   1c6ea:	3078      	adds	r0, #120	; 0x78
   1c6ec:	d00c      	beq.n	1c708 <disable.constprop.0+0xf0>
   1c6ee:	4a17      	ldr	r2, [pc, #92]	; (1c74c <disable.constprop.0+0x134>)
   1c6f0:	4919      	ldr	r1, [pc, #100]	; (1c758 <disable.constprop.0+0x140>)
   1c6f2:	4818      	ldr	r0, [pc, #96]	; (1c754 <disable.constprop.0+0x13c>)
   1c6f4:	f640 231e 	movw	r3, #2590	; 0xa1e
   1c6f8:	f008 fd60 	bl	251bc <printk>
   1c6fc:	4040      	eors	r0, r0
   1c6fe:	f380 8811 	msr	BASEPRI, r0
   1c702:	f04f 0003 	mov.w	r0, #3
   1c706:	df02      	svc	2
	mark = ull_disable_unmark(adv);
   1c708:	4620      	mov	r0, r4
   1c70a:	f7ff f8a3 	bl	1b854 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   1c70e:	4284      	cmp	r4, r0
   1c710:	d00c      	beq.n	1c72c <disable.constprop.0+0x114>
   1c712:	4a0e      	ldr	r2, [pc, #56]	; (1c74c <disable.constprop.0+0x134>)
   1c714:	490e      	ldr	r1, [pc, #56]	; (1c750 <disable.constprop.0+0x138>)
   1c716:	480f      	ldr	r0, [pc, #60]	; (1c754 <disable.constprop.0+0x13c>)
   1c718:	f640 2321 	movw	r3, #2593	; 0xa21
   1c71c:	f008 fd4e 	bl	251bc <printk>
   1c720:	4040      	eors	r0, r0
   1c722:	f380 8811 	msr	BASEPRI, r0
   1c726:	f04f 0003 	mov.w	r0, #3
   1c72a:	df02      	svc	2
	if (adv->lll.conn) {
   1c72c:	6a23      	ldr	r3, [r4, #32]
   1c72e:	b113      	cbz	r3, 1c736 <disable.constprop.0+0x11e>
		conn_release(adv);
   1c730:	4620      	mov	r0, r4
   1c732:	f7ff fd19 	bl	1c168 <conn_release>
	adv->is_enabled = 0U;
   1c736:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   1c73a:	f36f 0300 	bfc	r3, #0, #1
   1c73e:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
	return 0;
   1c742:	2000      	movs	r0, #0
   1c744:	e7a7      	b.n	1c696 <disable.constprop.0+0x7e>
   1c746:	bf00      	nop
   1c748:	0001b24d 	.word	0x0001b24d
   1c74c:	0003419b 	.word	0x0003419b
   1c750:	000342bb 	.word	0x000342bb
   1c754:	0002f8b5 	.word	0x0002f8b5
   1c758:	000342c7 	.word	0x000342c7

0001c75c <ll_adv_data_set>:
{
   1c75c:	460a      	mov	r2, r1
	return ull_adv_data_set(adv, len, data);
   1c75e:	4601      	mov	r1, r0
   1c760:	4801      	ldr	r0, [pc, #4]	; (1c768 <ll_adv_data_set+0xc>)
   1c762:	f00e bcb2 	b.w	2b0ca <ull_adv_data_set>
   1c766:	bf00      	nop
   1c768:	20003160 	.word	0x20003160

0001c76c <ll_adv_scan_rsp_set>:
{
   1c76c:	460a      	mov	r2, r1
	return ull_scan_rsp_set(adv, len, data);
   1c76e:	4601      	mov	r1, r0
   1c770:	4801      	ldr	r0, [pc, #4]	; (1c778 <ll_adv_scan_rsp_set+0xc>)
   1c772:	f00e bcfd 	b.w	2b170 <ull_scan_rsp_set>
   1c776:	bf00      	nop
   1c778:	20003160 	.word	0x20003160

0001c77c <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
   1c77c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c77e:	461d      	mov	r5, r3
   1c780:	9b07      	ldr	r3, [sp, #28]
	uint8_t ref;

	DEBUG_RADIO_PREPARE_O(1);

	scan = param;
	lll = &scan->lll;
   1c782:	461c      	mov	r4, r3
{
   1c784:	4607      	mov	r7, r0
   1c786:	f814 1b1c 	ldrb.w	r1, [r4], #28
   1c78a:	3101      	adds	r1, #1
   1c78c:	b2c9      	uxtb	r1, r1
   1c78e:	4616      	mov	r6, r2
   1c790:	7019      	strb	r1, [r3, #0]

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
   1c792:	b961      	cbnz	r1, 1c7ae <ticker_cb+0x32>
   1c794:	4a15      	ldr	r2, [pc, #84]	; (1c7ec <ticker_cb+0x70>)
   1c796:	4916      	ldr	r1, [pc, #88]	; (1c7f0 <ticker_cb+0x74>)
   1c798:	4816      	ldr	r0, [pc, #88]	; (1c7f4 <ticker_cb+0x78>)
   1c79a:	f240 23db 	movw	r3, #731	; 0x2db
   1c79e:	f008 fd0d 	bl	251bc <printk>
   1c7a2:	4040      	eors	r0, r0
   1c7a4:	f380 8811 	msr	BASEPRI, r0
   1c7a8:	f04f 0003 	mov.w	r0, #3
   1c7ac:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
   1c7ae:	4912      	ldr	r1, [pc, #72]	; (1c7f8 <ticker_cb+0x7c>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = lll;
	p.force = force;
   1c7b0:	f89d 3018 	ldrb.w	r3, [sp, #24]
   1c7b4:	728b      	strb	r3, [r1, #10]
	mfy.param = &p;
   1c7b6:	4b11      	ldr	r3, [pc, #68]	; (1c7fc <ticker_cb+0x80>)
	p.lazy = lazy;
   1c7b8:	810d      	strh	r5, [r1, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1c7ba:	2200      	movs	r2, #0
	p.remainder = remainder;
   1c7bc:	e9c1 7600 	strd	r7, r6, [r1]
	p.param = lll;
   1c7c0:	60cc      	str	r4, [r1, #12]
	mfy.param = &p;
   1c7c2:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1c7c4:	2001      	movs	r0, #1
   1c7c6:	4611      	mov	r1, r2
   1c7c8:	f7fc fe48 	bl	1945c <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   1c7cc:	b160      	cbz	r0, 1c7e8 <ticker_cb+0x6c>
   1c7ce:	4a07      	ldr	r2, [pc, #28]	; (1c7ec <ticker_cb+0x70>)
   1c7d0:	490b      	ldr	r1, [pc, #44]	; (1c800 <ticker_cb+0x84>)
   1c7d2:	4808      	ldr	r0, [pc, #32]	; (1c7f4 <ticker_cb+0x78>)
   1c7d4:	f44f 733a 	mov.w	r3, #744	; 0x2e8
   1c7d8:	f008 fcf0 	bl	251bc <printk>
   1c7dc:	4040      	eors	r0, r0
   1c7de:	f380 8811 	msr	BASEPRI, r0
   1c7e2:	f04f 0003 	mov.w	r0, #3
   1c7e6:	df02      	svc	2
			  (ret == TICKER_STATUS_BUSY));
	}
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	DEBUG_RADIO_PREPARE_O(1);
}
   1c7e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c7ea:	bf00      	nop
   1c7ec:	000342ed 	.word	0x000342ed
   1c7f0:	00034279 	.word	0x00034279
   1c7f4:	0002f8b5 	.word	0x0002f8b5
   1c7f8:	20003224 	.word	0x20003224
   1c7fc:	20000a3c 	.word	0x20000a3c
   1c800:	000340d7 	.word	0x000340d7

0001c804 <ull_scan_disable>:
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
   1c804:	3004      	adds	r0, #4
{
   1c806:	b508      	push	{r3, lr}
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
   1c808:	f101 021c 	add.w	r2, r1, #28
   1c80c:	b2c0      	uxtb	r0, r0
   1c80e:	f7ff f88f 	bl	1b930 <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
   1c812:	b178      	cbz	r0, 1c834 <ull_scan_disable+0x30>
   1c814:	3078      	adds	r0, #120	; 0x78
   1c816:	d00c      	beq.n	1c832 <ull_scan_disable+0x2e>
   1c818:	4a07      	ldr	r2, [pc, #28]	; (1c838 <ull_scan_disable+0x34>)
   1c81a:	4908      	ldr	r1, [pc, #32]	; (1c83c <ull_scan_disable+0x38>)
   1c81c:	4808      	ldr	r0, [pc, #32]	; (1c840 <ull_scan_disable+0x3c>)
   1c81e:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
   1c822:	f008 fccb 	bl	251bc <printk>
   1c826:	4040      	eors	r0, r0
   1c828:	f380 8811 	msr	BASEPRI, r0
   1c82c:	f04f 0003 	mov.w	r0, #3
   1c830:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
   1c832:	200c      	movs	r0, #12
}
   1c834:	bd08      	pop	{r3, pc}
   1c836:	bf00      	nop
   1c838:	000342ed 	.word	0x000342ed
   1c83c:	0003432d 	.word	0x0003432d
   1c840:	0002f8b5 	.word	0x0002f8b5

0001c844 <ull_scan_lll_handle_get>:
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
   1c844:	6800      	ldr	r0, [r0, #0]
   1c846:	4b03      	ldr	r3, [pc, #12]	; (1c854 <ull_scan_lll_handle_get+0x10>)
   1c848:	1ac0      	subs	r0, r0, r3
   1c84a:	2334      	movs	r3, #52	; 0x34
   1c84c:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1c850:	b2c0      	uxtb	r0, r0
   1c852:	4770      	bx	lr
   1c854:	200031f0 	.word	0x200031f0

0001c858 <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_SET) {
   1c858:	b938      	cbnz	r0, 1c86a <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
   1c85a:	4805      	ldr	r0, [pc, #20]	; (1c870 <ull_scan_is_enabled_get+0x18>)
   1c85c:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
	return &ll_scan[handle];
   1c860:	f013 0f01 	tst.w	r3, #1
   1c864:	bf08      	it	eq
   1c866:	2000      	moveq	r0, #0
   1c868:	4770      	bx	lr
		return NULL;
   1c86a:	2000      	movs	r0, #0
}
   1c86c:	4770      	bx	lr
   1c86e:	bf00      	nop
   1c870:	200031f0 	.word	0x200031f0

0001c874 <ull_scan_is_disabled_get>:
	if (!scan || scan->is_enabled) {
   1c874:	4a04      	ldr	r2, [pc, #16]	; (1c888 <ull_scan_is_disabled_get+0x14>)
   1c876:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
   1c87a:	f003 0301 	and.w	r3, r3, #1
		return NULL;
   1c87e:	4303      	orrs	r3, r0
}
   1c880:	bf0c      	ite	eq
   1c882:	4610      	moveq	r0, r2
   1c884:	2000      	movne	r0, #0
   1c886:	4770      	bx	lr
   1c888:	200031f0 	.word	0x200031f0

0001c88c <cpr_active_check_and_set>:
	if (!conn_upd_curr) {
   1c88c:	4b02      	ldr	r3, [pc, #8]	; (1c898 <cpr_active_check_and_set+0xc>)
   1c88e:	681a      	ldr	r2, [r3, #0]
   1c890:	b902      	cbnz	r2, 1c894 <cpr_active_check_and_set+0x8>
		conn_upd_curr = conn;
   1c892:	6018      	str	r0, [r3, #0]
}
   1c894:	4770      	bx	lr
   1c896:	bf00      	nop
   1c898:	20003238 	.word	0x20003238

0001c89c <ctrl_tx_rsp_mem_acquire>:
{
   1c89c:	b538      	push	{r3, r4, r5, lr}
	if (conn->common.txn_lock) {
   1c89e:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
   1c8a2:	079b      	lsls	r3, r3, #30
{
   1c8a4:	4604      	mov	r4, r0
   1c8a6:	4615      	mov	r5, r2
	if (conn->common.txn_lock) {
   1c8a8:	d504      	bpl.n	1c8b4 <ctrl_tx_rsp_mem_acquire+0x18>
		rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1c8aa:	2301      	movs	r3, #1
		*err = 0U;
   1c8ac:	2000      	movs	r0, #0
		rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1c8ae:	710b      	strb	r3, [r1, #4]
		*err = 0U;
   1c8b0:	6010      	str	r0, [r2, #0]
}
   1c8b2:	bd38      	pop	{r3, r4, r5, pc}
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1c8b4:	4807      	ldr	r0, [pc, #28]	; (1c8d4 <ctrl_tx_rsp_mem_acquire+0x38>)
   1c8b6:	f00d ffab 	bl	2a810 <mem_acquire>
	if (!tx) {
   1c8ba:	b918      	cbnz	r0, 1c8c4 <ctrl_tx_rsp_mem_acquire+0x28>
		*err = -ENOBUFS;
   1c8bc:	f06f 0368 	mvn.w	r3, #104	; 0x68
   1c8c0:	602b      	str	r3, [r5, #0]
		return NULL;
   1c8c2:	e7f6      	b.n	1c8b2 <ctrl_tx_rsp_mem_acquire+0x16>
	conn->common.txn_lock = 1U;
   1c8c4:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
   1c8c8:	f043 0302 	orr.w	r3, r3, #2
   1c8cc:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
	return tx;
   1c8d0:	e7ef      	b.n	1c8b2 <ctrl_tx_rsp_mem_acquire+0x16>
   1c8d2:	bf00      	nop
   1c8d4:	200032cc 	.word	0x200032cc

0001c8d8 <init_reset>:
{
   1c8d8:	b508      	push	{r3, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   1c8da:	480d      	ldr	r0, [pc, #52]	; (1c910 <init_reset+0x38>)
   1c8dc:	4b0d      	ldr	r3, [pc, #52]	; (1c914 <init_reset+0x3c>)
   1c8de:	2201      	movs	r2, #1
   1c8e0:	f44f 719c 	mov.w	r1, #312	; 0x138
   1c8e4:	f00d ff6c 	bl	2a7c0 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_BUF_ACL_TX_COUNT,
   1c8e8:	4b0b      	ldr	r3, [pc, #44]	; (1c918 <init_reset+0x40>)
   1c8ea:	2203      	movs	r2, #3
   1c8ec:	1d18      	adds	r0, r3, #4
   1c8ee:	2124      	movs	r1, #36	; 0x24
   1c8f0:	f00d ff66 	bl	2a7c0 <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   1c8f4:	4b09      	ldr	r3, [pc, #36]	; (1c91c <init_reset+0x44>)
   1c8f6:	2204      	movs	r2, #4
   1c8f8:	1898      	adds	r0, r3, r2
   1c8fa:	212c      	movs	r1, #44	; 0x2c
   1c8fc:	f00d ff60 	bl	2a7c0 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   1c900:	4b07      	ldr	r3, [pc, #28]	; (1c920 <init_reset+0x48>)
   1c902:	2207      	movs	r2, #7
   1c904:	1d18      	adds	r0, r3, #4
   1c906:	2108      	movs	r1, #8
   1c908:	f00d ff5a 	bl	2a7c0 <mem_init>
}
   1c90c:	2000      	movs	r0, #0
   1c90e:	bd08      	pop	{r3, pc}
   1c910:	200020a0 	.word	0x200020a0
   1c914:	20003234 	.word	0x20003234
   1c918:	2000325c 	.word	0x2000325c
   1c91c:	200032cc 	.word	0x200032cc
   1c920:	20003380 	.word	0x20003380

0001c924 <ticker_stop_op_cb>:
{
   1c924:	b510      	push	{r4, lr}
   1c926:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1c928:	b160      	cbz	r0, 1c944 <ticker_stop_op_cb+0x20>
   1c92a:	4a11      	ldr	r2, [pc, #68]	; (1c970 <ticker_stop_op_cb+0x4c>)
   1c92c:	4911      	ldr	r1, [pc, #68]	; (1c974 <ticker_stop_op_cb+0x50>)
   1c92e:	4812      	ldr	r0, [pc, #72]	; (1c978 <ticker_stop_op_cb+0x54>)
   1c930:	f640 137a 	movw	r3, #2426	; 0x97a
   1c934:	f008 fc42 	bl	251bc <printk>
   1c938:	4040      	eors	r0, r0
   1c93a:	f380 8811 	msr	BASEPRI, r0
   1c93e:	f04f 0003 	mov.w	r0, #3
   1c942:	df02      	svc	2
	mfy.param = param;
   1c944:	4b0d      	ldr	r3, [pc, #52]	; (1c97c <ticker_stop_op_cb+0x58>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1c946:	2200      	movs	r2, #0
   1c948:	2101      	movs	r1, #1
   1c94a:	2002      	movs	r0, #2
	mfy.param = param;
   1c94c:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1c94e:	f7fc fd85 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1c952:	b160      	cbz	r0, 1c96e <ticker_stop_op_cb+0x4a>
   1c954:	4a06      	ldr	r2, [pc, #24]	; (1c970 <ticker_stop_op_cb+0x4c>)
   1c956:	490a      	ldr	r1, [pc, #40]	; (1c980 <ticker_stop_op_cb+0x5c>)
   1c958:	4807      	ldr	r0, [pc, #28]	; (1c978 <ticker_stop_op_cb+0x54>)
   1c95a:	f44f 6318 	mov.w	r3, #2432	; 0x980
   1c95e:	f008 fc2d 	bl	251bc <printk>
   1c962:	4040      	eors	r0, r0
   1c964:	f380 8811 	msr	BASEPRI, r0
   1c968:	f04f 0003 	mov.w	r0, #3
   1c96c:	df02      	svc	2
}
   1c96e:	bd10      	pop	{r4, pc}
   1c970:	00034356 	.word	0x00034356
   1c974:	0003452f 	.word	0x0003452f
   1c978:	0002f8b5 	.word	0x0002f8b5
   1c97c:	20000ad4 	.word	0x20000ad4
   1c980:	000340d7 	.word	0x000340d7

0001c984 <disabled_cb>:
{
   1c984:	b508      	push	{r3, lr}
	mfy.param = param;
   1c986:	4b0b      	ldr	r3, [pc, #44]	; (1c9b4 <disabled_cb+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c988:	2200      	movs	r2, #0
	mfy.param = param;
   1c98a:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c98c:	4611      	mov	r1, r2
   1c98e:	2001      	movs	r0, #1
   1c990:	f7fc fd64 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1c994:	b160      	cbz	r0, 1c9b0 <disabled_cb+0x2c>
   1c996:	4a08      	ldr	r2, [pc, #32]	; (1c9b8 <disabled_cb+0x34>)
   1c998:	4908      	ldr	r1, [pc, #32]	; (1c9bc <disabled_cb+0x38>)
   1c99a:	4809      	ldr	r0, [pc, #36]	; (1c9c0 <disabled_cb+0x3c>)
   1c99c:	f640 13ac 	movw	r3, #2476	; 0x9ac
   1c9a0:	f008 fc0c 	bl	251bc <printk>
   1c9a4:	4040      	eors	r0, r0
   1c9a6:	f380 8811 	msr	BASEPRI, r0
   1c9aa:	f04f 0003 	mov.w	r0, #3
   1c9ae:	df02      	svc	2
}
   1c9b0:	bd08      	pop	{r3, pc}
   1c9b2:	bf00      	nop
   1c9b4:	20000ab4 	.word	0x20000ab4
   1c9b8:	00034356 	.word	0x00034356
   1c9bc:	000340d7 	.word	0x000340d7
   1c9c0:	0002f8b5 	.word	0x0002f8b5

0001c9c4 <conn_disable>:
{
   1c9c4:	b538      	push	{r3, r4, r5, lr}
   1c9c6:	4604      	mov	r4, r0
	return hdr->ref;
   1c9c8:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
   1c9cc:	b34b      	cbz	r3, 1ca22 <conn_disable+0x5e>
		mfy.param = &conn->lll;
   1c9ce:	4d17      	ldr	r5, [pc, #92]	; (1ca2c <conn_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
   1c9d0:	6963      	ldr	r3, [r4, #20]
		mfy.param = &conn->lll;
   1c9d2:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
   1c9d4:	b163      	cbz	r3, 1c9f0 <conn_disable+0x2c>
   1c9d6:	4a16      	ldr	r2, [pc, #88]	; (1ca30 <conn_disable+0x6c>)
   1c9d8:	4916      	ldr	r1, [pc, #88]	; (1ca34 <conn_disable+0x70>)
   1c9da:	4817      	ldr	r0, [pc, #92]	; (1ca38 <conn_disable+0x74>)
   1c9dc:	f640 1395 	movw	r3, #2453	; 0x995
   1c9e0:	f008 fbec 	bl	251bc <printk>
   1c9e4:	4040      	eors	r0, r0
   1c9e6:	f380 8811 	msr	BASEPRI, r0
   1c9ea:	f04f 0003 	mov.w	r0, #3
   1c9ee:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   1c9f0:	68ab      	ldr	r3, [r5, #8]
   1c9f2:	61a3      	str	r3, [r4, #24]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c9f4:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
   1c9f6:	4b11      	ldr	r3, [pc, #68]	; (1ca3c <conn_disable+0x78>)
   1c9f8:	6163      	str	r3, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1c9fa:	4611      	mov	r1, r2
   1c9fc:	4b0b      	ldr	r3, [pc, #44]	; (1ca2c <conn_disable+0x68>)
   1c9fe:	2001      	movs	r0, #1
   1ca00:	f7fc fd2c 	bl	1945c <mayfly_enqueue>
		LL_ASSERT(!ret);
   1ca04:	b160      	cbz	r0, 1ca20 <conn_disable+0x5c>
   1ca06:	4a0a      	ldr	r2, [pc, #40]	; (1ca30 <conn_disable+0x6c>)
   1ca08:	490d      	ldr	r1, [pc, #52]	; (1ca40 <conn_disable+0x7c>)
   1ca0a:	480b      	ldr	r0, [pc, #44]	; (1ca38 <conn_disable+0x74>)
   1ca0c:	f640 139c 	movw	r3, #2460	; 0x99c
   1ca10:	f008 fbd4 	bl	251bc <printk>
   1ca14:	4040      	eors	r0, r0
   1ca16:	f380 8811 	msr	BASEPRI, r0
   1ca1a:	f04f 0003 	mov.w	r0, #3
   1ca1e:	df02      	svc	2
}
   1ca20:	bd38      	pop	{r3, r4, r5, pc}
   1ca22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		disabled_cb(&conn->lll);
   1ca26:	f7ff bfad 	b.w	1c984 <disabled_cb>
   1ca2a:	bf00      	nop
   1ca2c:	20000ac4 	.word	0x20000ac4
   1ca30:	00034356 	.word	0x00034356
   1ca34:	00034238 	.word	0x00034238
   1ca38:	0002f8b5 	.word	0x0002f8b5
   1ca3c:	0001c985 	.word	0x0001c985
   1ca40:	000340d7 	.word	0x000340d7

0001ca44 <conn_setup_adv_scan_disabled_cb>:
{
   1ca44:	b508      	push	{r3, lr}
	lll = *((struct lll_conn **)((uint8_t *)ftr->param +
   1ca46:	6883      	ldr	r3, [r0, #8]
   1ca48:	685a      	ldr	r2, [r3, #4]
	switch (lll->role) {
   1ca4a:	7f53      	ldrb	r3, [r2, #29]
   1ca4c:	09db      	lsrs	r3, r3, #7
{
   1ca4e:	4601      	mov	r1, r0
	switch (lll->role) {
   1ca50:	d004      	beq.n	1ca5c <conn_setup_adv_scan_disabled_cb+0x18>
}
   1ca52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		ull_periph_setup(rx, ftr, lll);
   1ca56:	3108      	adds	r1, #8
   1ca58:	f7e4 bc7a 	b.w	1350 <ull_periph_setup>
		LL_ASSERT(0);
   1ca5c:	4a06      	ldr	r2, [pc, #24]	; (1ca78 <conn_setup_adv_scan_disabled_cb+0x34>)
   1ca5e:	4907      	ldr	r1, [pc, #28]	; (1ca7c <conn_setup_adv_scan_disabled_cb+0x38>)
   1ca60:	4807      	ldr	r0, [pc, #28]	; (1ca80 <conn_setup_adv_scan_disabled_cb+0x3c>)
   1ca62:	f640 03d5 	movw	r3, #2261	; 0x8d5
   1ca66:	f008 fba9 	bl	251bc <printk>
   1ca6a:	4040      	eors	r0, r0
   1ca6c:	f380 8811 	msr	BASEPRI, r0
   1ca70:	f04f 0003 	mov.w	r0, #3
   1ca74:	df02      	svc	2
}
   1ca76:	bd08      	pop	{r3, pc}
   1ca78:	00034356 	.word	0x00034356
   1ca7c:	00031059 	.word	0x00031059
   1ca80:	0002f8b5 	.word	0x0002f8b5

0001ca84 <ticker_start_conn_op_cb>:
{
   1ca84:	b510      	push	{r4, lr}
   1ca86:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1ca88:	b160      	cbz	r0, 1caa4 <ticker_start_conn_op_cb+0x20>
   1ca8a:	4a10      	ldr	r2, [pc, #64]	; (1cacc <ticker_start_conn_op_cb+0x48>)
   1ca8c:	4910      	ldr	r1, [pc, #64]	; (1cad0 <ticker_start_conn_op_cb+0x4c>)
   1ca8e:	4811      	ldr	r0, [pc, #68]	; (1cad4 <ticker_start_conn_op_cb+0x50>)
   1ca90:	f640 03b4 	movw	r3, #2228	; 0x8b4
   1ca94:	f008 fb92 	bl	251bc <printk>
   1ca98:	4040      	eors	r0, r0
   1ca9a:	f380 8811 	msr	BASEPRI, r0
   1ca9e:	f04f 0003 	mov.w	r0, #3
   1caa2:	df02      	svc	2
	p = ull_update_unmark(param);
   1caa4:	4620      	mov	r0, r4
   1caa6:	f7fe fef1 	bl	1b88c <ull_update_unmark>
	LL_ASSERT(p == param);
   1caaa:	4284      	cmp	r4, r0
   1caac:	d00c      	beq.n	1cac8 <ticker_start_conn_op_cb+0x44>
   1caae:	4a07      	ldr	r2, [pc, #28]	; (1cacc <ticker_start_conn_op_cb+0x48>)
   1cab0:	4909      	ldr	r1, [pc, #36]	; (1cad8 <ticker_start_conn_op_cb+0x54>)
   1cab2:	4808      	ldr	r0, [pc, #32]	; (1cad4 <ticker_start_conn_op_cb+0x50>)
   1cab4:	f640 03b7 	movw	r3, #2231	; 0x8b7
   1cab8:	f008 fb80 	bl	251bc <printk>
   1cabc:	4040      	eors	r0, r0
   1cabe:	f380 8811 	msr	BASEPRI, r0
   1cac2:	f04f 0003 	mov.w	r0, #3
   1cac6:	df02      	svc	2
}
   1cac8:	bd10      	pop	{r4, pc}
   1caca:	bf00      	nop
   1cacc:	00034356 	.word	0x00034356
   1cad0:	0003452f 	.word	0x0003452f
   1cad4:	0002f8b5 	.word	0x0002f8b5
   1cad8:	00034396 	.word	0x00034396

0001cadc <ticker_stop_conn_op_cb>:
{
   1cadc:	b510      	push	{r4, lr}
   1cade:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1cae0:	b160      	cbz	r0, 1cafc <ticker_stop_conn_op_cb+0x20>
   1cae2:	4a10      	ldr	r2, [pc, #64]	; (1cb24 <ticker_stop_conn_op_cb+0x48>)
   1cae4:	4910      	ldr	r1, [pc, #64]	; (1cb28 <ticker_stop_conn_op_cb+0x4c>)
   1cae6:	4811      	ldr	r0, [pc, #68]	; (1cb2c <ticker_stop_conn_op_cb+0x50>)
   1cae8:	f640 03aa 	movw	r3, #2218	; 0x8aa
   1caec:	f008 fb66 	bl	251bc <printk>
   1caf0:	4040      	eors	r0, r0
   1caf2:	f380 8811 	msr	BASEPRI, r0
   1caf6:	f04f 0003 	mov.w	r0, #3
   1cafa:	df02      	svc	2
	p = ull_update_mark(param);
   1cafc:	4620      	mov	r0, r4
   1cafe:	f7fe febd 	bl	1b87c <ull_update_mark>
	LL_ASSERT(p == param);
   1cb02:	4284      	cmp	r4, r0
   1cb04:	d00c      	beq.n	1cb20 <ticker_stop_conn_op_cb+0x44>
   1cb06:	4a07      	ldr	r2, [pc, #28]	; (1cb24 <ticker_stop_conn_op_cb+0x48>)
   1cb08:	4909      	ldr	r1, [pc, #36]	; (1cb30 <ticker_stop_conn_op_cb+0x54>)
   1cb0a:	4808      	ldr	r0, [pc, #32]	; (1cb2c <ticker_stop_conn_op_cb+0x50>)
   1cb0c:	f640 03ad 	movw	r3, #2221	; 0x8ad
   1cb10:	f008 fb54 	bl	251bc <printk>
   1cb14:	4040      	eors	r0, r0
   1cb16:	f380 8811 	msr	BASEPRI, r0
   1cb1a:	f04f 0003 	mov.w	r0, #3
   1cb1e:	df02      	svc	2
}
   1cb20:	bd10      	pop	{r4, pc}
   1cb22:	bf00      	nop
   1cb24:	00034356 	.word	0x00034356
   1cb28:	0003452f 	.word	0x0003452f
   1cb2c:	0002f8b5 	.word	0x0002f8b5
   1cb30:	00034396 	.word	0x00034396

0001cb34 <ticker_update_conn_op_cb>:
{
   1cb34:	b510      	push	{r4, lr}
   1cb36:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   1cb38:	b1a0      	cbz	r0, 1cb64 <ticker_update_conn_op_cb+0x30>
   1cb3a:	f7fe feb5 	bl	1b8a8 <ull_update_mark_get>
   1cb3e:	4284      	cmp	r4, r0
   1cb40:	d010      	beq.n	1cb64 <ticker_update_conn_op_cb+0x30>
   1cb42:	f7fe fe95 	bl	1b870 <ull_disable_mark_get>
   1cb46:	4284      	cmp	r4, r0
   1cb48:	d00c      	beq.n	1cb64 <ticker_update_conn_op_cb+0x30>
   1cb4a:	4a07      	ldr	r2, [pc, #28]	; (1cb68 <ticker_update_conn_op_cb+0x34>)
   1cb4c:	4907      	ldr	r1, [pc, #28]	; (1cb6c <ticker_update_conn_op_cb+0x38>)
   1cb4e:	4808      	ldr	r0, [pc, #32]	; (1cb70 <ticker_update_conn_op_cb+0x3c>)
   1cb50:	f640 03a1 	movw	r3, #2209	; 0x8a1
   1cb54:	f008 fb32 	bl	251bc <printk>
   1cb58:	4040      	eors	r0, r0
   1cb5a:	f380 8811 	msr	BASEPRI, r0
   1cb5e:	f04f 0003 	mov.w	r0, #3
   1cb62:	df02      	svc	2
}
   1cb64:	bd10      	pop	{r4, pc}
   1cb66:	bf00      	nop
   1cb68:	00034356 	.word	0x00034356
   1cb6c:	000343a1 	.word	0x000343a1
   1cb70:	0002f8b5 	.word	0x0002f8b5

0001cb74 <feat_get>:
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   1cb74:	6841      	ldr	r1, [r0, #4]
   1cb76:	6803      	ldr	r3, [r0, #0]

	feat = sys_get_le64(features) | ~LL_FEAT_BIT_MASK_VALID;
	feat &= LL_FEAT_BIT_MASK;

	return feat;
}
   1cb78:	4803      	ldr	r0, [pc, #12]	; (1cb88 <feat_get+0x14>)
	feat &= LL_FEAT_BIT_MASK;
   1cb7a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
}
   1cb7e:	4318      	orrs	r0, r3
   1cb80:	f041 0110 	orr.w	r1, r1, #16
   1cb84:	4770      	bx	lr
   1cb86:	bf00      	nop
   1cb88:	087830d0 	.word	0x087830d0

0001cb8c <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   1cb8c:	4801      	ldr	r0, [pc, #4]	; (1cb94 <ll_conn_acquire+0x8>)
   1cb8e:	f00d be3f 	b.w	2a810 <mem_acquire>
   1cb92:	bf00      	nop
   1cb94:	20003234 	.word	0x20003234

0001cb98 <ll_conn_release>:
	mem_release(conn, &conn_free);
   1cb98:	4901      	ldr	r1, [pc, #4]	; (1cba0 <ll_conn_release+0x8>)
   1cb9a:	f00d be52 	b.w	2a842 <mem_release>
   1cb9e:	bf00      	nop
   1cba0:	20003234 	.word	0x20003234

0001cba4 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   1cba4:	4902      	ldr	r1, [pc, #8]	; (1cbb0 <ll_conn_handle_get+0xc>)
   1cba6:	f44f 729c 	mov.w	r2, #312	; 0x138
   1cbaa:	f00d be62 	b.w	2a872 <mem_index_get>
   1cbae:	bf00      	nop
   1cbb0:	200020a0 	.word	0x200020a0

0001cbb4 <tx_lll_flush>:
{
   1cbb4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	conn = HDR_LLL2ULL(lll);
   1cbb8:	6806      	ldr	r6, [r0, #0]
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1cbba:	4d30      	ldr	r5, [pc, #192]	; (1cc7c <tx_lll_flush+0xc8>)
{
   1cbbc:	4604      	mov	r4, r0
	handle = ll_conn_handle_get(conn);
   1cbbe:	4630      	mov	r0, r6
   1cbc0:	f7ff fff0 	bl	1cba4 <ll_conn_handle_get>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1cbc4:	f104 073c 	add.w	r7, r4, #60	; 0x3c
	lll_conn_flush(handle, lll);
   1cbc8:	4621      	mov	r1, r4
   1cbca:	f00e fea8 	bl	2b91e <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1cbce:	6c20      	ldr	r0, [r4, #64]	; 0x40
   1cbd0:	aa01      	add	r2, sp, #4
   1cbd2:	4639      	mov	r1, r7
   1cbd4:	f00d fe89 	bl	2a8ea <memq_dequeue>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1cbd8:	f105 0804 	add.w	r8, r5, #4
	while (link) {
   1cbdc:	b9f0      	cbnz	r0, 1cc1c <tx_lll_flush+0x68>
	LL_ASSERT(rx->hdr.link);
   1cbde:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
	rx = (void *)&conn->llcp_terminate.node_rx;
   1cbe2:	f106 04d4 	add.w	r4, r6, #212	; 0xd4
	LL_ASSERT(rx->hdr.link);
   1cbe6:	b963      	cbnz	r3, 1cc02 <tx_lll_flush+0x4e>
   1cbe8:	4a25      	ldr	r2, [pc, #148]	; (1cc80 <tx_lll_flush+0xcc>)
   1cbea:	4926      	ldr	r1, [pc, #152]	; (1cc84 <tx_lll_flush+0xd0>)
   1cbec:	4826      	ldr	r0, [pc, #152]	; (1cc88 <tx_lll_flush+0xd4>)
   1cbee:	f640 13da 	movw	r3, #2522	; 0x9da
   1cbf2:	f008 fae3 	bl	251bc <printk>
   1cbf6:	4040      	eors	r0, r0
   1cbf8:	f380 8811 	msr	BASEPRI, r0
   1cbfc:	f04f 0003 	mov.w	r0, #3
   1cc00:	df02      	svc	2
	rx->hdr.link = NULL;
   1cc02:	2300      	movs	r3, #0
	link = rx->hdr.link;
   1cc04:	f8d6 00d4 	ldr.w	r0, [r6, #212]	; 0xd4
	rx->hdr.link = NULL;
   1cc08:	f8c6 30d4 	str.w	r3, [r6, #212]	; 0xd4
	ull_rx_put(link, rx);
   1cc0c:	4621      	mov	r1, r4
   1cc0e:	f7fe fef5 	bl	1b9fc <ull_rx_put>
	ull_rx_sched();
   1cc12:	f7fe ff03 	bl	1ba1c <ull_rx_sched>
}
   1cc16:	b002      	add	sp, #8
   1cc18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1cc1c:	78ea      	ldrb	r2, [r5, #3]
	if (last == count) {
   1cc1e:	f895 c001 	ldrb.w	ip, [r5, #1]
   1cc22:	78ab      	ldrb	r3, [r5, #2]
	last = last + 1;
   1cc24:	1c51      	adds	r1, r2, #1
   1cc26:	b2c9      	uxtb	r1, r1
		last = 0U;
   1cc28:	458c      	cmp	ip, r1
   1cc2a:	bf08      	it	eq
   1cc2c:	2100      	moveq	r1, #0
	if (last == first) {
   1cc2e:	428b      	cmp	r3, r1
   1cc30:	d10f      	bne.n	1cc52 <tx_lll_flush+0x9e>
		LL_ASSERT(lll_tx);
   1cc32:	4a13      	ldr	r2, [pc, #76]	; (1cc80 <tx_lll_flush+0xcc>)
   1cc34:	4915      	ldr	r1, [pc, #84]	; (1cc8c <tx_lll_flush+0xd8>)
   1cc36:	4814      	ldr	r0, [pc, #80]	; (1cc88 <tx_lll_flush+0xd4>)
   1cc38:	f640 13c6 	movw	r3, #2502	; 0x9c6
   1cc3c:	f008 fabe 	bl	251bc <printk>
   1cc40:	4040      	eors	r0, r0
   1cc42:	f380 8811 	msr	BASEPRI, r0
   1cc46:	f04f 0003 	mov.w	r0, #3
   1cc4a:	df02      	svc	2
		lll_tx->handle = LLL_HANDLE_INVALID;
   1cc4c:	2300      	movs	r3, #0
   1cc4e:	801b      	strh	r3, [r3, #0]
   1cc50:	deff      	udf	#255	; 0xff
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1cc52:	782b      	ldrb	r3, [r5, #0]
   1cc54:	fb13 f302 	smulbb	r3, r3, r2
   1cc58:	f64f 7cff 	movw	ip, #65535	; 0xffff
   1cc5c:	f828 c003 	strh.w	ip, [r8, r3]
   1cc60:	eb08 0203 	add.w	r2, r8, r3
		lll_tx->node = tx;
   1cc64:	9b01      	ldr	r3, [sp, #4]
   1cc66:	6053      	str	r3, [r2, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   1cc68:	681a      	ldr	r2, [r3, #0]
   1cc6a:	6002      	str	r2, [r0, #0]
		tx->next = link;
   1cc6c:	6018      	str	r0, [r3, #0]
	*last = idx; /* Commit: Update write index */
   1cc6e:	70e9      	strb	r1, [r5, #3]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   1cc70:	6c20      	ldr	r0, [r4, #64]	; 0x40
   1cc72:	aa01      	add	r2, sp, #4
   1cc74:	4639      	mov	r1, r7
   1cc76:	f00d fe38 	bl	2a8ea <memq_dequeue>
   1cc7a:	e7af      	b.n	1cbdc <tx_lll_flush+0x28>
   1cc7c:	20000a4c 	.word	0x20000a4c
   1cc80:	00034356 	.word	0x00034356
   1cc84:	00034426 	.word	0x00034426
   1cc88:	0002f8b5 	.word	0x0002f8b5
   1cc8c:	000343f2 	.word	0x000343f2

0001cc90 <ll_conn_get>:
{
   1cc90:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   1cc92:	f44f 719c 	mov.w	r1, #312	; 0x138
   1cc96:	4801      	ldr	r0, [pc, #4]	; (1cc9c <ll_conn_get+0xc>)
   1cc98:	f00d bde8 	b.w	2a86c <mem_get>
   1cc9c:	200020a0 	.word	0x200020a0

0001cca0 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   1cca0:	4801      	ldr	r0, [pc, #4]	; (1cca8 <ll_tx_mem_acquire+0x8>)
   1cca2:	f00d bdb5 	b.w	2a810 <mem_acquire>
   1cca6:	bf00      	nop
   1cca8:	2000325c 	.word	0x2000325c

0001ccac <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   1ccac:	4901      	ldr	r1, [pc, #4]	; (1ccb4 <ll_tx_mem_release+0x8>)
   1ccae:	f00d bdc8 	b.w	2a842 <mem_release>
   1ccb2:	bf00      	nop
   1ccb4:	2000325c 	.word	0x2000325c

0001ccb8 <ll_tx_mem_enqueue>:
{
   1ccb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ccba:	4606      	mov	r6, r0
   1ccbc:	460f      	mov	r7, r1
	conn = ll_connected_get(handle);
   1ccbe:	f00e fb46 	bl	2b34e <ll_connected_get>
	if (!conn) {
   1ccc2:	4604      	mov	r4, r0
   1ccc4:	b330      	cbz	r0, 1cd14 <ll_tx_mem_enqueue+0x5c>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   1ccc6:	4a16      	ldr	r2, [pc, #88]	; (1cd20 <ll_tx_mem_enqueue+0x68>)
   1ccc8:	78d5      	ldrb	r5, [r2, #3]
	if (last == count) {
   1ccca:	f892 c001 	ldrb.w	ip, [r2, #1]
   1ccce:	7891      	ldrb	r1, [r2, #2]
   1ccd0:	7810      	ldrb	r0, [r2, #0]
	last = last + 1;
   1ccd2:	1c6b      	adds	r3, r5, #1
   1ccd4:	b2db      	uxtb	r3, r3
		last = 0U;
   1ccd6:	459c      	cmp	ip, r3
   1ccd8:	bf08      	it	eq
   1ccda:	2300      	moveq	r3, #0
	if (last == first) {
   1ccdc:	4299      	cmp	r1, r3
   1ccde:	d01c      	beq.n	1cd1a <ll_tx_mem_enqueue+0x62>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1cce0:	1d11      	adds	r1, r2, #4
   1cce2:	fb15 f500 	smulbb	r5, r5, r0
   1cce6:	1948      	adds	r0, r1, r5
	lll_tx->handle = handle;
   1cce8:	534e      	strh	r6, [r1, r5]
	lll_tx->node = tx;
   1ccea:	6047      	str	r7, [r0, #4]
	*last = idx; /* Commit: Update write index */
   1ccec:	70d3      	strb	r3, [r2, #3]
   1ccee:	7823      	ldrb	r3, [r4, #0]
	if (ull_ref_get(&conn->ull)) {
   1ccf0:	b133      	cbz	r3, 1cd00 <ll_tx_mem_enqueue+0x48>
		mfy.param = conn;
   1ccf2:	4b0c      	ldr	r3, [pc, #48]	; (1cd24 <ll_tx_mem_enqueue+0x6c>)
		mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH,
   1ccf4:	2200      	movs	r2, #0
   1ccf6:	2101      	movs	r1, #1
   1ccf8:	2003      	movs	r0, #3
		mfy.param = conn;
   1ccfa:	609c      	str	r4, [r3, #8]
		mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_ULL_HIGH,
   1ccfc:	f7fc fbae 	bl	1945c <mayfly_enqueue>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   1cd00:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1cd04:	2b00      	cmp	r3, #0
   1cd06:	da03      	bge.n	1cd10 <ll_tx_mem_enqueue+0x58>
		ull_periph_latency_cancel(conn, handle);
   1cd08:	4631      	mov	r1, r6
   1cd0a:	4620      	mov	r0, r4
   1cd0c:	f001 f866 	bl	1dddc <ull_periph_latency_cancel>
	return 0;
   1cd10:	2000      	movs	r0, #0
   1cd12:	e001      	b.n	1cd18 <ll_tx_mem_enqueue+0x60>
		return -EINVAL;
   1cd14:	f06f 0015 	mvn.w	r0, #21
}
   1cd18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   1cd1a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1cd1e:	e7fb      	b.n	1cd18 <ll_tx_mem_enqueue+0x60>
   1cd20:	20000a90 	.word	0x20000a90
   1cd24:	20000ae4 	.word	0x20000ae4

0001cd28 <ll_terminate_ind_send>:
{
   1cd28:	b538      	push	{r3, r4, r5, lr}
   1cd2a:	4605      	mov	r5, r0
   1cd2c:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   1cd2e:	f00e fb0e 	bl	2b34e <ll_connected_get>
	if (!conn) {
   1cd32:	b310      	cbz	r0, 1cd7a <ll_terminate_ind_send+0x52>
	if (conn->llcp_terminate.req != conn->llcp_terminate.ack) {
   1cd34:	f890 30d0 	ldrb.w	r3, [r0, #208]	; 0xd0
   1cd38:	f890 20d1 	ldrb.w	r2, [r0, #209]	; 0xd1
   1cd3c:	429a      	cmp	r2, r3
   1cd3e:	d11e      	bne.n	1cd7e <ll_terminate_ind_send+0x56>
	switch (reason) {
   1cd40:	2c1a      	cmp	r4, #26
   1cd42:	d808      	bhi.n	1cd56 <ll_terminate_ind_send+0x2e>
   1cd44:	2c04      	cmp	r4, #4
   1cd46:	d904      	bls.n	1cd52 <ll_terminate_ind_send+0x2a>
   1cd48:	490e      	ldr	r1, [pc, #56]	; (1cd84 <ll_terminate_ind_send+0x5c>)
   1cd4a:	2201      	movs	r2, #1
   1cd4c:	40a2      	lsls	r2, r4
   1cd4e:	420a      	tst	r2, r1
   1cd50:	d105      	bne.n	1cd5e <ll_terminate_ind_send+0x36>
   1cd52:	2012      	movs	r0, #18
   1cd54:	e012      	b.n	1cd7c <ll_terminate_ind_send+0x54>
   1cd56:	2c29      	cmp	r4, #41	; 0x29
   1cd58:	d001      	beq.n	1cd5e <ll_terminate_ind_send+0x36>
   1cd5a:	2c3b      	cmp	r4, #59	; 0x3b
   1cd5c:	d1f9      	bne.n	1cd52 <ll_terminate_ind_send+0x2a>
	conn->llcp_terminate.req++; /* (req - ack) == 1, TERM_REQ */
   1cd5e:	3301      	adds	r3, #1
   1cd60:	f880 30d0 	strb.w	r3, [r0, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   1cd64:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
	conn->llcp_terminate.reason_own = reason;
   1cd68:	f880 40d2 	strb.w	r4, [r0, #210]	; 0xd2
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   1cd6c:	2b00      	cmp	r3, #0
   1cd6e:	da02      	bge.n	1cd76 <ll_terminate_ind_send+0x4e>
		ull_periph_latency_cancel(conn, handle);
   1cd70:	4629      	mov	r1, r5
   1cd72:	f001 f833 	bl	1dddc <ull_periph_latency_cancel>
	return 0;
   1cd76:	2000      	movs	r0, #0
   1cd78:	e000      	b.n	1cd7c <ll_terminate_ind_send+0x54>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   1cd7a:	2002      	movs	r0, #2
}
   1cd7c:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1cd7e:	200c      	movs	r0, #12
   1cd80:	e7fc      	b.n	1cd7c <ll_terminate_ind_send+0x54>
   1cd82:	bf00      	nop
   1cd84:	04380020 	.word	0x04380020

0001cd88 <ull_conn_reset>:
{
   1cd88:	b510      	push	{r4, lr}
	conn = ll_conn_get(handle);
   1cd8a:	2000      	movs	r0, #0
   1cd8c:	f7ff ff80 	bl	1cc90 <ll_conn_get>
   1cd90:	4604      	mov	r4, r0
	err = ull_ticker_stop_with_mark(TICKER_ID_CONN_BASE + handle,
   1cd92:	f100 021c 	add.w	r2, r0, #28
   1cd96:	4601      	mov	r1, r0
   1cd98:	2005      	movs	r0, #5
   1cd9a:	f7fe fdc9 	bl	1b930 <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
   1cd9e:	b170      	cbz	r0, 1cdbe <ull_conn_reset+0x36>
   1cda0:	3078      	adds	r0, #120	; 0x78
   1cda2:	d00c      	beq.n	1cdbe <ull_conn_reset+0x36>
   1cda4:	4a0d      	ldr	r2, [pc, #52]	; (1cddc <ull_conn_reset+0x54>)
   1cda6:	490e      	ldr	r1, [pc, #56]	; (1cde0 <ull_conn_reset+0x58>)
   1cda8:	480e      	ldr	r0, [pc, #56]	; (1cde4 <ull_conn_reset+0x5c>)
   1cdaa:	f640 03e3 	movw	r3, #2275	; 0x8e3
   1cdae:	f008 fa05 	bl	251bc <printk>
   1cdb2:	4040      	eors	r0, r0
   1cdb4:	f380 8811 	msr	BASEPRI, r0
   1cdb8:	f04f 0003 	mov.w	r0, #3
   1cdbc:	df02      	svc	2
	MFIFO_INIT(conn_tx);
   1cdbe:	4a0a      	ldr	r2, [pc, #40]	; (1cde8 <ull_conn_reset+0x60>)
	conn->lll.handle = LLL_HANDLE_INVALID;
   1cdc0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1cdc4:	8523      	strh	r3, [r4, #40]	; 0x28
	conn->lll.link_tx_free = NULL;
   1cdc6:	2300      	movs	r3, #0
	MFIFO_INIT(conn_tx);
   1cdc8:	8053      	strh	r3, [r2, #2]
	MFIFO_INIT(conn_ack);
   1cdca:	4a08      	ldr	r2, [pc, #32]	; (1cdec <ull_conn_reset+0x64>)
	conn->lll.link_tx_free = NULL;
   1cdcc:	66a3      	str	r3, [r4, #104]	; 0x68
	MFIFO_INIT(conn_ack);
   1cdce:	8053      	strh	r3, [r2, #2]
	conn_upd_curr = NULL;
   1cdd0:	4a07      	ldr	r2, [pc, #28]	; (1cdf0 <ull_conn_reset+0x68>)
}
   1cdd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	conn_upd_curr = NULL;
   1cdd6:	6013      	str	r3, [r2, #0]
	err = init_reset();
   1cdd8:	f7ff bd7e 	b.w	1c8d8 <init_reset>
   1cddc:	00034356 	.word	0x00034356
   1cde0:	0003432d 	.word	0x0003432d
   1cde4:	0002f8b5 	.word	0x0002f8b5
   1cde8:	20000a90 	.word	0x20000a90
   1cdec:	20000a4c 	.word	0x20000a4c
   1cdf0:	20003238 	.word	0x20003238

0001cdf4 <ull_conn_setup>:
{
   1cdf4:	b538      	push	{r3, r4, r5, lr}
	hdr = HDR_LLL2ULL(ftr->param);
   1cdf6:	688b      	ldr	r3, [r1, #8]
	rx->link = rx_link;
   1cdf8:	6008      	str	r0, [r1, #0]
	hdr = HDR_LLL2ULL(ftr->param);
   1cdfa:	681d      	ldr	r5, [r3, #0]
   1cdfc:	782b      	ldrb	r3, [r5, #0]
{
   1cdfe:	460c      	mov	r4, r1
	if (ull_ref_get(hdr)) {
   1ce00:	b193      	cbz	r3, 1ce28 <ull_conn_setup+0x34>
		LL_ASSERT(!hdr->disabled_cb);
   1ce02:	696b      	ldr	r3, [r5, #20]
   1ce04:	b163      	cbz	r3, 1ce20 <ull_conn_setup+0x2c>
   1ce06:	4a0b      	ldr	r2, [pc, #44]	; (1ce34 <ull_conn_setup+0x40>)
   1ce08:	490b      	ldr	r1, [pc, #44]	; (1ce38 <ull_conn_setup+0x44>)
   1ce0a:	480c      	ldr	r0, [pc, #48]	; (1ce3c <ull_conn_setup+0x48>)
   1ce0c:	f240 33ed 	movw	r3, #1005	; 0x3ed
   1ce10:	f008 f9d4 	bl	251bc <printk>
   1ce14:	4040      	eors	r0, r0
   1ce16:	f380 8811 	msr	BASEPRI, r0
   1ce1a:	f04f 0003 	mov.w	r0, #3
   1ce1e:	df02      	svc	2
		hdr->disabled_cb = conn_setup_adv_scan_disabled_cb;
   1ce20:	4b07      	ldr	r3, [pc, #28]	; (1ce40 <ull_conn_setup+0x4c>)
		hdr->disabled_param = rx;
   1ce22:	61ac      	str	r4, [r5, #24]
		hdr->disabled_cb = conn_setup_adv_scan_disabled_cb;
   1ce24:	616b      	str	r3, [r5, #20]
}
   1ce26:	bd38      	pop	{r3, r4, r5, pc}
   1ce28:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		conn_setup_adv_scan_disabled_cb(rx);
   1ce2c:	4608      	mov	r0, r1
   1ce2e:	f7ff be09 	b.w	1ca44 <conn_setup_adv_scan_disabled_cb>
   1ce32:	bf00      	nop
   1ce34:	00034356 	.word	0x00034356
   1ce38:	00034238 	.word	0x00034238
   1ce3c:	0002f8b5 	.word	0x0002f8b5
   1ce40:	0001ca45 	.word	0x0001ca45

0001ce44 <ull_conn_rx>:
	conn = ll_connected_get((*rx)->hdr.handle);
   1ce44:	680b      	ldr	r3, [r1, #0]
{
   1ce46:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1ce4a:	4607      	mov	r7, r0
	conn = ll_connected_get((*rx)->hdr.handle);
   1ce4c:	88d8      	ldrh	r0, [r3, #6]
{
   1ce4e:	460e      	mov	r6, r1
	conn = ll_connected_get((*rx)->hdr.handle);
   1ce50:	f00e fa7d 	bl	2b34e <ll_connected_get>
	if (!conn) {
   1ce54:	6835      	ldr	r5, [r6, #0]
   1ce56:	4604      	mov	r4, r0
   1ce58:	b910      	cbnz	r0, 1ce60 <ull_conn_rx+0x1c>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1ce5a:	2301      	movs	r3, #1
   1ce5c:	712b      	strb	r3, [r5, #4]
	return 0;
   1ce5e:	e007      	b.n	1ce70 <ull_conn_rx+0x2c>
	switch (pdu_rx->ll_id) {
   1ce60:	7f28      	ldrb	r0, [r5, #28]
   1ce62:	f000 0003 	and.w	r0, r0, #3
   1ce66:	2803      	cmp	r0, #3
   1ce68:	d004      	beq.n	1ce74 <ull_conn_rx+0x30>
   1ce6a:	2800      	cmp	r0, #0
   1ce6c:	f000 83a9 	beq.w	1d5c2 <ull_conn_rx+0x77e>
   1ce70:	2000      	movs	r0, #0
   1ce72:	e14a      	b.n	1d10a <ull_conn_rx+0x2c6>
			  struct pdu_data *pdu_rx, struct ll_conn *conn)
{
	int nack = 0;
	uint8_t opcode;

	opcode = pdu_rx->llctrl.opcode;
   1ce74:	f895 801f 	ldrb.w	r8, [r5, #31]
	pdu_rx = (void *)(*rx)->pdu;
   1ce78:	f105 021c 	add.w	r2, r5, #28

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   1ce7c:	f1b8 0f11 	cmp.w	r8, #17
   1ce80:	f200 83c4 	bhi.w	1d60c <ull_conn_rx+0x7c8>
   1ce84:	e8df f018 	tbh	[pc, r8, lsl #1]
   1ce88:	00830012 	.word	0x00830012
   1ce8c:	03c200b3 	.word	0x03c200b3
   1ce90:	03c203c2 	.word	0x03c203c2
   1ce94:	033a03c2 	.word	0x033a03c2
   1ce98:	011400bc 	.word	0x011400bc
   1ce9c:	03c203c2 	.word	0x03c203c2
   1cea0:	03c20144 	.word	0x03c20144
   1cea4:	019503c2 	.word	0x019503c2
   1cea8:	02e203c2 	.word	0x02e203c2
#if defined(CONFIG_BT_PERIPHERAL)
	case PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND:
	{
		uint8_t err;

		if (!conn->lll.role ||
   1ceac:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1ceb0:	2b00      	cmp	r3, #0
   1ceb2:	f280 83ab 	bge.w	1d60c <ull_conn_rx+0x7c8>
   1ceb6:	7f6b      	ldrb	r3, [r5, #29]
   1ceb8:	2b0c      	cmp	r3, #12
   1ceba:	f040 83a7 	bne.w	1d60c <ull_conn_rx+0x7c8>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   1cebe:	f8b5 1029 	ldrh.w	r1, [r5, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   1cec2:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1cec4:	1acb      	subs	r3, r1, r3
   1cec6:	041b      	lsls	r3, r3, #16
   1cec8:	d503      	bpl.n	1ced2 <ull_conn_rx+0x8e>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1ceca:	2301      	movs	r3, #1
   1cecc:	712b      	strb	r3, [r5, #4]
		err = BT_HCI_ERR_INSTANT_PASSED;
   1cece:	2328      	movs	r3, #40	; 0x28
   1ced0:	e00b      	b.n	1ceea <ull_conn_rx+0xa6>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   1ced2:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   1ced6:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
   1ceda:	1a9b      	subs	r3, r3, r2
   1cedc:	f003 0303 	and.w	r3, r3, #3
   1cee0:	2b02      	cmp	r3, #2
   1cee2:	d105      	bne.n	1cef0 <ull_conn_rx+0xac>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1cee4:	2301      	movs	r3, #1
   1cee6:	712b      	strb	r3, [r5, #4]
		err = BT_HCI_ERR_DIFF_TRANS_COLLISION;
   1cee8:	232a      	movs	r3, #42	; 0x2a
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = chan_map_upd_recv(conn, *rx, pdu_rx);
		if (err) {
			conn->llcp_terminate.reason_final = err;
   1ceea:	f884 30d3 	strb.w	r3, [r4, #211]	; 0xd3
   1ceee:	e7bf      	b.n	1ce70 <ull_conn_rx+0x2c>
	cpr_active_check_and_set(conn);
   1cef0:	4620      	mov	r0, r4
   1cef2:	f7ff fccb 	bl	1c88c <cpr_active_check_and_set>
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   1cef6:	f895 3020 	ldrb.w	r3, [r5, #32]
   1cefa:	f884 30ac 	strb.w	r3, [r4, #172]	; 0xac
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) *
   1cefe:	f8b5 3021 	ldrh.w	r3, [r5, #33]	; 0x21
   1cf02:	f240 42e2 	movw	r2, #1250	; 0x4e2
   1cf06:	4353      	muls	r3, r2
	conn->llcp_cu.win_offset_us =
   1cf08:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   1cf0c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   1cf10:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   1cf14:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.interval =
   1cf18:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   1cf1c:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   1cf20:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   1cf24:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.latency =
   1cf28:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   1cf2c:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   1cf30:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
	conn->llcp.conn_upd.instant = instant;
   1cf34:	f8a4 108c 	strh.w	r1, [r4, #140]	; 0x8c
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   1cf38:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.timeout =
   1cf3c:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   1cf40:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   1cf44:	f023 030f 	bic.w	r3, r3, #15
   1cf48:	f043 0308 	orr.w	r3, r3, #8
   1cf4c:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
	conn->llcp_cu.ack--;
   1cf50:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1cf54:	3b01      	subs	r3, #1
   1cf56:	f884 309d 	strb.w	r3, [r4, #157]	; 0x9d
	link->mem = conn->llcp_rx;
   1cf5a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   1cf5e:	607b      	str	r3, [r7, #4]
	(*rx)->hdr.link = link;
   1cf60:	6833      	ldr	r3, [r6, #0]
   1cf62:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
   1cf64:	6833      	ldr	r3, [r6, #0]
   1cf66:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*rx = NULL;
   1cf6a:	2300      	movs	r3, #0
   1cf6c:	6033      	str	r3, [r6, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1cf6e:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
   1cf72:	f894 30f5 	ldrb.w	r3, [r4, #245]	; 0xf5
   1cf76:	4293      	cmp	r3, r2
   1cf78:	d007      	beq.n	1cf8a <ull_conn_rx+0x146>
	    ((conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) ||
   1cf7a:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   1cf7e:	f003 030e 	and.w	r3, r3, #14
   1cf82:	2b04      	cmp	r3, #4
   1cf84:	d101      	bne.n	1cf8a <ull_conn_rx+0x146>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1cf86:	f884 20f5 	strb.w	r2, [r4, #245]	; 0xf5
				break;
			}
		}

		/* Procedure complete */
		conn->procedure_expire = 0U;
   1cf8a:	2000      	movs	r0, #0
   1cf8c:	e0bb      	b.n	1d106 <ull_conn_rx+0x2c2>
		if (!conn->lll.role ||
   1cf8e:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1cf92:	2b00      	cmp	r3, #0
   1cf94:	f280 833a 	bge.w	1d60c <ull_conn_rx+0x7c8>
   1cf98:	7f6b      	ldrb	r3, [r5, #29]
   1cf9a:	2b08      	cmp	r3, #8
   1cf9c:	f040 8336 	bne.w	1d60c <ull_conn_rx+0x7c8>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   1cfa0:	f8b5 6025 	ldrh.w	r6, [r5, #37]	; 0x25
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   1cfa4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1cfa6:	1af3      	subs	r3, r6, r3
   1cfa8:	041f      	lsls	r7, r3, #16
   1cfaa:	d48e      	bmi.n	1ceca <ull_conn_rx+0x86>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   1cfac:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   1cfb0:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
   1cfb4:	1a9b      	subs	r3, r3, r2
   1cfb6:	f003 0303 	and.w	r3, r3, #3
   1cfba:	2b02      	cmp	r3, #2
   1cfbc:	d092      	beq.n	1cee4 <ull_conn_rx+0xa0>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
   1cfbe:	2205      	movs	r2, #5
   1cfc0:	f105 0120 	add.w	r1, r5, #32
   1cfc4:	f104 008d 	add.w	r0, r4, #141	; 0x8d
   1cfc8:	f00a fc52 	bl	27870 <memcpy>
	conn->llcp.chan_map.initiate = 0U;
   1cfcc:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
	conn->llcp.chan_map.instant = instant;
   1cfd0:	f8a4 6092 	strh.w	r6, [r4, #146]	; 0x92
	conn->llcp.chan_map.initiate = 0U;
   1cfd4:	f36f 0300 	bfc	r3, #0, #1
   1cfd8:	f884 308c 	strb.w	r3, [r4, #140]	; 0x8c
	conn->llcp_type = LLCP_CHAN_MAP;
   1cfdc:	2302      	movs	r3, #2
   1cfde:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
	conn->llcp_ack -= 2U;
   1cfe2:	f894 3089 	ldrb.w	r3, [r4, #137]	; 0x89
   1cfe6:	3b02      	subs	r3, #2
   1cfe8:	f884 3089 	strb.w	r3, [r4, #137]	; 0x89
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1cfec:	e735      	b.n	1ce5a <ull_conn_rx+0x16>
		if (PDU_DATA_LLCTRL_LEN(terminate_ind) != pdu_rx->len) {
   1cfee:	7f6b      	ldrb	r3, [r5, #29]
   1cff0:	2b02      	cmp	r3, #2
   1cff2:	f040 830b 	bne.w	1d60c <ull_conn_rx+0x7c8>
	conn->llcp_terminate.reason_final =
   1cff6:	f895 3020 	ldrb.w	r3, [r5, #32]
   1cffa:	f884 30d3 	strb.w	r3, [r4, #211]	; 0xd3
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1cffe:	e72c      	b.n	1ce5a <ull_conn_rx+0x16>
		if (!conn->lll.role ||
   1d000:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1d004:	2b00      	cmp	r3, #0
   1d006:	f280 8301 	bge.w	1d60c <ull_conn_rx+0x7c8>
   1d00a:	f895 901d 	ldrb.w	r9, [r5, #29]
   1d00e:	f1b9 0f09 	cmp.w	r9, #9
   1d012:	f040 82fb 	bne.w	1d60c <ull_conn_rx+0x7c8>
	tx = ctrl_tx_rsp_mem_acquire(conn, rx, &err);
   1d016:	aa01      	add	r2, sp, #4
   1d018:	4629      	mov	r1, r5
   1d01a:	4620      	mov	r0, r4
   1d01c:	f7ff fc3e 	bl	1c89c <ctrl_tx_rsp_mem_acquire>
	if (!tx) {
   1d020:	4606      	mov	r6, r0
   1d022:	b908      	cbnz	r0, 1d028 <ull_conn_rx+0x1e4>
		return err;
   1d024:	9801      	ldr	r0, [sp, #4]
   1d026:	e070      	b.n	1d10a <ull_conn_rx+0x2c6>
	conn->llcp_feature.features_conn &= feat_get(&req->features[0]);
   1d028:	f105 0720 	add.w	r7, r5, #32
   1d02c:	4638      	mov	r0, r7
   1d02e:	f7ff fda1 	bl	1cb74 <feat_get>
   1d032:	e9d4 232e 	ldrd	r2, r3, [r4, #184]	; 0xb8
   1d036:	4002      	ands	r2, r0
   1d038:	400b      	ands	r3, r1
   1d03a:	e9c4 232e 	strd	r2, r3, [r4, #184]	; 0xb8
		feat_land_octet0(feat_get(&req->features[0]), ll_feat_get());
   1d03e:	4638      	mov	r0, r7
   1d040:	f7ff fd98 	bl	1cb74 <feat_get>
   1d044:	4607      	mov	r7, r0
   1d046:	4688      	mov	r8, r1
   1d048:	f00d ff66 	bl	2af18 <ll_feat_get>
	conn->common.fex_valid = 1U;
   1d04c:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
	feat_result = feat_to_keep & feat_octet0;
   1d050:	4038      	ands	r0, r7
	conn->common.fex_valid = 1U;
   1d052:	f043 0301 	orr.w	r3, r3, #1
   1d056:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
	feat_result &= 0xFF;
   1d05a:	f000 00ff 	and.w	r0, r0, #255	; 0xff
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d05e:	7933      	ldrb	r3, [r6, #4]
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   1d060:	f027 07ff 	bic.w	r7, r7, #255	; 0xff
   1d064:	f008 01ff 	and.w	r1, r8, #255	; 0xff
   1d068:	4307      	orrs	r7, r0
	conn->llcp_feature.features_peer =
   1d06a:	e9c4 7130 	strd	r7, r1, [r4, #192]	; 0xc0
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d06e:	f043 0303 	orr.w	r3, r3, #3
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1d072:	f106 0708 	add.w	r7, r6, #8
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d076:	7133      	strb	r3, [r6, #4]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1d078:	2208      	movs	r2, #8
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   1d07a:	f886 9005 	strb.w	r9, [r6, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   1d07e:	f886 9007 	strb.w	r9, [r6, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   1d082:	2100      	movs	r1, #0
   1d084:	4638      	mov	r0, r7
   1d086:	f00a fbfe 	bl	27886 <memset>
	feat = feat_land_octet0(ll_feat_get(),
   1d08a:	f00d ff45 	bl	2af18 <ll_feat_get>
	feat_result = feat_to_keep & feat_octet0;
   1d08e:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   1d092:	4003      	ands	r3, r0
	feat_result &= 0xFF;
   1d094:	f003 03ff 	and.w	r3, r3, #255	; 0xff
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   1d098:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
	sys_put_le64(feat, pdu_tx->llctrl.feature_rsp.features);
   1d09c:	4318      	orrs	r0, r3
   1d09e:	463a      	mov	r2, r7
   1d0a0:	b2c9      	uxtb	r1, r1
   1d0a2:	f00e f900 	bl	2b2a6 <sys_put_le64>
	ctrl_tx_sec_enqueue(conn, tx);
   1d0a6:	4631      	mov	r1, r6
   1d0a8:	4620      	mov	r0, r4
   1d0aa:	f00e f90d 	bl	2b2c8 <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1d0ae:	e6d4      	b.n	1ce5a <ull_conn_rx+0x16>
		if ((!IS_ENABLED(CONFIG_BT_CTLR_PER_INIT_FEAT_XCHG) &&
   1d0b0:	7f6b      	ldrb	r3, [r5, #29]
   1d0b2:	2b09      	cmp	r3, #9
   1d0b4:	f040 82aa 	bne.w	1d60c <ull_conn_rx+0x7c8>
	conn->llcp_feature.features_conn &= feat_get(&rsp->features[0]);
   1d0b8:	3520      	adds	r5, #32
   1d0ba:	4628      	mov	r0, r5
   1d0bc:	f7ff fd5a 	bl	1cb74 <feat_get>
   1d0c0:	e9d4 232e 	ldrd	r2, r3, [r4, #184]	; 0xb8
   1d0c4:	400b      	ands	r3, r1
   1d0c6:	4002      	ands	r2, r0
   1d0c8:	e9c4 232e 	strd	r2, r3, [r4, #184]	; 0xb8
		feat_land_octet0(feat_get(&rsp->features[0]), ll_feat_get());
   1d0cc:	4628      	mov	r0, r5
   1d0ce:	f7ff fd51 	bl	1cb74 <feat_get>
   1d0d2:	4605      	mov	r5, r0
   1d0d4:	460e      	mov	r6, r1
   1d0d6:	f00d ff1f 	bl	2af18 <ll_feat_get>
	feat_result = feat_to_keep & feat_octet0;
   1d0da:	ea05 0300 	and.w	r3, r5, r0
	feat_result &= 0xFF;
   1d0de:	f003 03ff 	and.w	r3, r3, #255	; 0xff
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   1d0e2:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
   1d0e6:	431d      	orrs	r5, r3
	conn->common.fex_valid = 1U;
   1d0e8:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
	feat_result |= feat_to_keep & LL_FEAT_FILTER_OCTET0;
   1d0ec:	f006 06ff 	and.w	r6, r6, #255	; 0xff
	conn->common.fex_valid = 1U;
   1d0f0:	f043 0301 	orr.w	r3, r3, #1
	conn->llcp_feature.features_peer =
   1d0f4:	e9c4 5630 	strd	r5, r6, [r4, #192]	; 0xc0
	conn->common.fex_valid = 1U;
   1d0f8:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
	conn->llcp_feature.ack = conn->llcp_feature.req;
   1d0fc:	f894 30b0 	ldrb.w	r3, [r4, #176]	; 0xb0
   1d100:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
	feat_result &= 0xFF;
   1d104:	2000      	movs	r0, #0
	conn->procedure_expire = 0U;
   1d106:	f8a4 0078 	strh.w	r0, [r4, #120]	; 0x78
}
   1d10a:	b003      	add	sp, #12
   1d10c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (PDU_DATA_LLCTRL_LEN(version_ind) != pdu_rx->len) {
   1d110:	7f6e      	ldrb	r6, [r5, #29]
   1d112:	2e06      	cmp	r6, #6
   1d114:	f040 827a 	bne.w	1d60c <ull_conn_rx+0x7c8>
	if (!conn->llcp_version.tx) {
   1d118:	f894 30ca 	ldrb.w	r3, [r4, #202]	; 0xca
   1d11c:	07d8      	lsls	r0, r3, #31
   1d11e:	d43d      	bmi.n	1d19c <ull_conn_rx+0x358>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   1d120:	48c8      	ldr	r0, [pc, #800]	; (1d444 <ull_conn_rx+0x600>)
   1d122:	f00d fb75 	bl	2a810 <mem_acquire>
		if (!tx) {
   1d126:	4601      	mov	r1, r0
   1d128:	2800      	cmp	r0, #0
   1d12a:	f000 8286 	beq.w	1d63a <ull_conn_rx+0x7f6>
		conn->llcp_version.tx = 1U;
   1d12e:	f894 30ca 	ldrb.w	r3, [r4, #202]	; 0xca
   1d132:	f043 0301 	orr.w	r3, r3, #1
   1d136:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d13a:	7903      	ldrb	r3, [r0, #4]
		pdu_tx->len =
   1d13c:	7146      	strb	r6, [r0, #5]
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   1d13e:	f043 0303 	orr.w	r3, r3, #3
   1d142:	7103      	strb	r3, [r0, #4]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   1d144:	230c      	movs	r3, #12
   1d146:	71c3      	strb	r3, [r0, #7]
		v->version_number = LL_VERSION_NUMBER;
   1d148:	7203      	strb	r3, [r0, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   1d14a:	f06f 030e 	mvn.w	r3, #14
   1d14e:	7243      	strb	r3, [r0, #9]
   1d150:	2305      	movs	r3, #5
   1d152:	7283      	strb	r3, [r0, #10]
		v->sub_version_number =
   1d154:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1d158:	72c3      	strb	r3, [r0, #11]
   1d15a:	7303      	strb	r3, [r0, #12]
		ctrl_tx_sec_enqueue(conn, tx);
   1d15c:	4620      	mov	r0, r4
   1d15e:	f00e f8b3 	bl	2b2c8 <ctrl_tx_enqueue>
		rx->hdr.type = NODE_RX_TYPE_RELEASE;
   1d162:	2301      	movs	r3, #1
   1d164:	712b      	strb	r3, [r5, #4]
	conn->llcp_version.version_number = v->version_number;
   1d166:	f895 3020 	ldrb.w	r3, [r5, #32]
   1d16a:	f884 30cb 	strb.w	r3, [r4, #203]	; 0xcb
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   1d16e:	f895 2022 	ldrb.w	r2, [r5, #34]	; 0x22
   1d172:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
   1d176:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1d17a:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		sys_le16_to_cpu(v->sub_version_number);
   1d17e:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   1d182:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   1d186:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_version.sub_version_number =
   1d18a:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
	conn->llcp_version.rx = 1U;
   1d18e:	f894 30ca 	ldrb.w	r3, [r4, #202]	; 0xca
   1d192:	f043 0302 	orr.w	r3, r3, #2
   1d196:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
	return 0;
   1d19a:	e669      	b.n	1ce70 <ull_conn_rx+0x2c>
	} else if (!conn->llcp_version.rx) {
   1d19c:	f013 0302 	ands.w	r3, r3, #2
   1d1a0:	f47f ae5b 	bne.w	1ce5a <ull_conn_rx+0x16>
		conn->llcp_version.ack = conn->llcp_version.req;
   1d1a4:	f894 20c8 	ldrb.w	r2, [r4, #200]	; 0xc8
   1d1a8:	f884 20c9 	strb.w	r2, [r4, #201]	; 0xc9
		conn->procedure_expire = 0U;
   1d1ac:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
   1d1b0:	e7d9      	b.n	1d166 <ull_conn_rx+0x322>
		if (PDU_DATA_LLCTRL_LEN(conn_param_req) != pdu_rx->len) {
   1d1b2:	7f6b      	ldrb	r3, [r5, #29]
   1d1b4:	2b18      	cmp	r3, #24
   1d1b6:	f040 8229 	bne.w	1d60c <ull_conn_rx+0x7c8>
	return conn_upd_curr && (conn_upd_curr != conn);
   1d1ba:	4ba3      	ldr	r3, [pc, #652]	; (1d448 <ull_conn_rx+0x604>)
   1d1bc:	681b      	ldr	r3, [r3, #0]
   1d1be:	b14b      	cbz	r3, 1d1d4 <ull_conn_rx+0x390>
		if (cpr_active_is_set(conn)) {
   1d1c0:	429c      	cmp	r4, r3
   1d1c2:	d007      	beq.n	1d1d4 <ull_conn_rx+0x390>
			nack = reject_ext_ind_send(conn, *rx,
   1d1c4:	2220      	movs	r2, #32
				nack = reject_ext_ind_send(conn, *rx,
   1d1c6:	4629      	mov	r1, r5
   1d1c8:	4620      	mov	r0, r4
}
   1d1ca:	b003      	add	sp, #12
   1d1cc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
				nack = reject_ext_ind_send(conn, *rx,
   1d1d0:	f00e b89f 	b.w	2b312 <reject_ext_ind_send.constprop.0>
		if (!conn->lll.role) {
   1d1d4:	f994 2039 	ldrsb.w	r2, [r4, #57]	; 0x39
					conn->llcp_conn_param.ack) &&
   1d1d8:	f894 10f5 	ldrb.w	r1, [r4, #245]	; 0xf5
			if ((conn->llcp_conn_param.req !=
   1d1dc:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
		if (!conn->lll.role) {
   1d1e0:	2a00      	cmp	r2, #0
   1d1e2:	f2c0 80a9 	blt.w	1d338 <ull_conn_rx+0x4f4>
			if ((conn->llcp_conn_param.req !=
   1d1e6:	4299      	cmp	r1, r3
   1d1e8:	d00a      	beq.n	1d200 <ull_conn_rx+0x3bc>
			    ((conn->llcp_conn_param.state ==
   1d1ea:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
					conn->llcp_conn_param.ack) &&
   1d1ee:	f013 0f0b 	tst.w	r3, #11
   1d1f2:	d003      	beq.n	1d1fc <ull_conn_rx+0x3b8>
			      LLCP_CPR_STATE_RSP_WAIT) ||
   1d1f4:	f003 030f 	and.w	r3, r3, #15
   1d1f8:	2b06      	cmp	r3, #6
   1d1fa:	d101      	bne.n	1d200 <ull_conn_rx+0x3bc>
				nack = reject_ext_ind_send(conn, *rx,
   1d1fc:	2223      	movs	r2, #35	; 0x23
   1d1fe:	e7e2      	b.n	1d1c6 <ull_conn_rx+0x382>
			} else if (((conn->llcp_req - conn->llcp_ack) &
   1d200:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   1d204:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
   1d208:	1a9b      	subs	r3, r3, r2
   1d20a:	f003 0303 	and.w	r3, r3, #3
   1d20e:	2b02      	cmp	r3, #2
   1d210:	d101      	bne.n	1d216 <ull_conn_rx+0x3d2>
				nack = reject_ext_ind_send(conn, *rx,
   1d212:	222a      	movs	r2, #42	; 0x2a
   1d214:	e7d7      	b.n	1d1c6 <ull_conn_rx+0x382>
				uint16_t interval_min =
   1d216:	f8b5 8020 	ldrh.w	r8, [r5, #32]
   1d21a:	fa1f f388 	uxth.w	r3, r8
				if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   1d21e:	2b05      	cmp	r3, #5
   1d220:	d922      	bls.n	1d268 <ull_conn_rx+0x424>
				uint16_t interval_max =
   1d222:	f8b5 e022 	ldrh.w	lr, [r5, #34]	; 0x22
   1d226:	fa1f f08e 	uxth.w	r0, lr
				if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   1d22a:	f5b0 6f48 	cmp.w	r0, #3200	; 0xc80
   1d22e:	d81b      	bhi.n	1d268 <ull_conn_rx+0x424>
				    (interval_max > 3200) ||
   1d230:	4283      	cmp	r3, r0
   1d232:	d819      	bhi.n	1d268 <ull_conn_rx+0x424>
				uint16_t latency =
   1d234:	f8b5 c024 	ldrh.w	ip, [r5, #36]	; 0x24
   1d238:	fa1f f68c 	uxth.w	r6, ip
				    (interval_min > interval_max) ||
   1d23c:	f5b6 7ffa 	cmp.w	r6, #500	; 0x1f4
   1d240:	d212      	bcs.n	1d268 <ull_conn_rx+0x424>
				uint16_t timeout =
   1d242:	8cef      	ldrh	r7, [r5, #38]	; 0x26
   1d244:	b2bb      	uxth	r3, r7
				    (latency > 499) ||
   1d246:	f1a3 020a 	sub.w	r2, r3, #10
   1d24a:	b292      	uxth	r2, r2
   1d24c:	f640 4976 	movw	r9, #3190	; 0xc76
   1d250:	454a      	cmp	r2, r9
   1d252:	d809      	bhi.n	1d268 <ull_conn_rx+0x424>
				     ((latency + 1) * interval_max)) ||
   1d254:	1c72      	adds	r2, r6, #1
   1d256:	b292      	uxth	r2, r2
   1d258:	4342      	muls	r2, r0
				    (timeout > 3200) ||
   1d25a:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
   1d25e:	d203      	bcs.n	1d268 <ull_conn_rx+0x424>
					cpr->preferred_periodicity;
   1d260:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
				     ((latency + 1) * interval_max)) ||
   1d264:	4290      	cmp	r0, r2
   1d266:	d201      	bcs.n	1d26c <ull_conn_rx+0x428>
				nack = reject_ext_ind_send(conn, *rx,
   1d268:	221e      	movs	r2, #30
   1d26a:	e7ac      	b.n	1d1c6 <ull_conn_rx+0x382>
				conn->llcp_conn_param.interval_min =
   1d26c:	f8a4 80f8 	strh.w	r8, [r4, #248]	; 0xf8
				conn->llcp_conn_param.interval_max =
   1d270:	f8a4 e0fa 	strh.w	lr, [r4, #250]	; 0xfa
				conn->llcp_conn_param.latency =	latency;
   1d274:	f8a4 c0fc 	strh.w	ip, [r4, #252]	; 0xfc
				conn->llcp_conn_param.timeout =	timeout;
   1d278:	f8a4 70fe 	strh.w	r7, [r4, #254]	; 0xfe
				conn->llcp_conn_param.preferred_periodicity =
   1d27c:	f884 2100 	strb.w	r2, [r4, #256]	; 0x100
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   1d280:	f895 702a 	ldrb.w	r7, [r5, #42]	; 0x2a
   1d284:	f895 2029 	ldrb.w	r2, [r5, #41]	; 0x29
   1d288:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
   1d28c:	f8a4 2102 	strh.w	r2, [r4, #258]	; 0x102
					sys_le16_to_cpu(cpr->offset0);
   1d290:	f895 702c 	ldrb.w	r7, [r5, #44]	; 0x2c
   1d294:	f895 202b 	ldrb.w	r2, [r5, #43]	; 0x2b
   1d298:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset0 =
   1d29c:	f8a4 2104 	strh.w	r2, [r4, #260]	; 0x104
					sys_le16_to_cpu(cpr->offset1);
   1d2a0:	f895 702e 	ldrb.w	r7, [r5, #46]	; 0x2e
   1d2a4:	f895 202d 	ldrb.w	r2, [r5, #45]	; 0x2d
   1d2a8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset1 =
   1d2ac:	f8a4 2106 	strh.w	r2, [r4, #262]	; 0x106
					sys_le16_to_cpu(cpr->offset2);
   1d2b0:	f895 7030 	ldrb.w	r7, [r5, #48]	; 0x30
   1d2b4:	f895 202f 	ldrb.w	r2, [r5, #47]	; 0x2f
   1d2b8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset2 =
   1d2bc:	f8a4 2108 	strh.w	r2, [r4, #264]	; 0x108
					sys_le16_to_cpu(cpr->offset3);
   1d2c0:	f895 7032 	ldrb.w	r7, [r5, #50]	; 0x32
   1d2c4:	f895 2031 	ldrb.w	r2, [r5, #49]	; 0x31
   1d2c8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset3 =
   1d2cc:	f8a4 210a 	strh.w	r2, [r4, #266]	; 0x10a
					sys_le16_to_cpu(cpr->offset4);
   1d2d0:	f895 7034 	ldrb.w	r7, [r5, #52]	; 0x34
   1d2d4:	f895 2033 	ldrb.w	r2, [r5, #51]	; 0x33
   1d2d8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset4 =
   1d2dc:	f8a4 210c 	strh.w	r2, [r4, #268]	; 0x10c
					sys_le16_to_cpu(cpr->offset5);
   1d2e0:	f895 2035 	ldrb.w	r2, [r5, #53]	; 0x35
   1d2e4:	f895 7036 	ldrb.w	r7, [r5, #54]	; 0x36
   1d2e8:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
				conn->llcp_conn_param.offset5 =
   1d2ec:	f8a4 210e 	strh.w	r2, [r4, #270]	; 0x10e
				     lll->interval) ||
   1d2f0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
				if ((conn->llcp_conn_param.interval_max !=
   1d2f2:	4290      	cmp	r0, r2
			if ((conn->llcp_conn_param.interval_max !=
   1d2f4:	d112      	bne.n	1d31c <ull_conn_rx+0x4d8>
			     lll->interval) ||
   1d2f6:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
   1d2f8:	42b0      	cmp	r0, r6
   1d2fa:	d10f      	bne.n	1d31c <ull_conn_rx+0x4d8>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   1d2fc:	f240 40e2 	movw	r0, #1250	; 0x4e2
   1d300:	4342      	muls	r2, r0
   1d302:	f242 7010 	movw	r0, #10000	; 0x2710
   1d306:	fb00 2303 	mla	r3, r0, r3, r2
   1d30a:	3b01      	subs	r3, #1
   1d30c:	fbb3 f3f2 	udiv	r3, r3, r2
			    (conn->llcp_conn_param.latency != lll->latency) ||
   1d310:	f8b4 2072 	ldrh.w	r2, [r4, #114]	; 0x72
   1d314:	b29b      	uxth	r3, r3
   1d316:	429a      	cmp	r2, r3
   1d318:	f000 8088 	beq.w	1d42c <ull_conn_rx+0x5e8>
				conn->llcp_conn_param.state =
   1d31c:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
   1d320:	2203      	movs	r2, #3
   1d322:	f362 0303 	bfi	r3, r2, #0, #4
   1d326:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
			conn->llcp_conn_param.ack--;
   1d32a:	3901      	subs	r1, #1
   1d32c:	f884 10f5 	strb.w	r1, [r4, #245]	; 0xf5
			cpr_active_check_and_set(conn);
   1d330:	4620      	mov	r0, r4
   1d332:	f7ff faab 	bl	1c88c <cpr_active_check_and_set>
   1d336:	e59b      	b.n	1ce70 <ull_conn_rx+0x2c>
		} else if ((conn->llcp_conn_param.req ==
   1d338:	4299      	cmp	r1, r3
   1d33a:	d005      	beq.n	1d348 <ull_conn_rx+0x504>
			    conn->llcp_conn_param.ack) ||
   1d33c:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
   1d340:	f013 0f0b 	tst.w	r3, #11
   1d344:	f47f ad89 	bne.w	1ce5a <ull_conn_rx+0x16>
			uint16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   1d348:	f8b5 8020 	ldrh.w	r8, [r5, #32]
   1d34c:	fa1f f388 	uxth.w	r3, r8
			if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   1d350:	2b05      	cmp	r3, #5
   1d352:	d989      	bls.n	1d268 <ull_conn_rx+0x424>
			uint16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   1d354:	f8b5 e022 	ldrh.w	lr, [r5, #34]	; 0x22
   1d358:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < CONN_INTERVAL_MIN(conn)) ||
   1d35c:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
   1d360:	d882      	bhi.n	1d268 <ull_conn_rx+0x424>
			    (interval_max > 3200) ||
   1d362:	4293      	cmp	r3, r2
   1d364:	d880      	bhi.n	1d268 <ull_conn_rx+0x424>
			uint16_t latency = sys_le16_to_cpu(cpr->latency);
   1d366:	f8b5 c024 	ldrh.w	ip, [r5, #36]	; 0x24
   1d36a:	fa1f f68c 	uxth.w	r6, ip
			    (interval_min > interval_max) ||
   1d36e:	f5b6 7ffa 	cmp.w	r6, #500	; 0x1f4
   1d372:	f4bf af79 	bcs.w	1d268 <ull_conn_rx+0x424>
			uint16_t timeout = sys_le16_to_cpu(cpr->timeout);
   1d376:	8cef      	ldrh	r7, [r5, #38]	; 0x26
   1d378:	b2bb      	uxth	r3, r7
			    (latency > 499) ||
   1d37a:	f1a3 000a 	sub.w	r0, r3, #10
   1d37e:	b280      	uxth	r0, r0
   1d380:	f640 4976 	movw	r9, #3190	; 0xc76
   1d384:	4548      	cmp	r0, r9
   1d386:	f63f af6f 	bhi.w	1d268 <ull_conn_rx+0x424>
			     ((latency + 1) * interval_max)) ||
   1d38a:	1c70      	adds	r0, r6, #1
   1d38c:	b280      	uxth	r0, r0
   1d38e:	4350      	muls	r0, r2
			    (timeout < 10) || (timeout > 3200) ||
   1d390:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
   1d394:	f4bf af68 	bcs.w	1d268 <ull_conn_rx+0x424>
				cpr->preferred_periodicity;
   1d398:	f895 0028 	ldrb.w	r0, [r5, #40]	; 0x28
			     ((latency + 1) * interval_max)) ||
   1d39c:	4282      	cmp	r2, r0
   1d39e:	f4ff af63 	bcc.w	1d268 <ull_conn_rx+0x424>
			conn->llcp_conn_param.interval_min = interval_min;
   1d3a2:	f8a4 80f8 	strh.w	r8, [r4, #248]	; 0xf8
			conn->llcp_conn_param.interval_max = interval_max;
   1d3a6:	f8a4 e0fa 	strh.w	lr, [r4, #250]	; 0xfa
			conn->llcp_conn_param.latency =	latency;
   1d3aa:	f8a4 c0fc 	strh.w	ip, [r4, #252]	; 0xfc
			conn->llcp_conn_param.timeout =	timeout;
   1d3ae:	f8a4 70fe 	strh.w	r7, [r4, #254]	; 0xfe
			conn->llcp_conn_param.preferred_periodicity =
   1d3b2:	f884 0100 	strb.w	r0, [r4, #256]	; 0x100
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   1d3b6:	f895 702a 	ldrb.w	r7, [r5, #42]	; 0x2a
   1d3ba:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
   1d3be:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   1d3c2:	f8a4 0102 	strh.w	r0, [r4, #258]	; 0x102
				sys_le16_to_cpu(cpr->offset0);
   1d3c6:	f895 702c 	ldrb.w	r7, [r5, #44]	; 0x2c
   1d3ca:	f895 002b 	ldrb.w	r0, [r5, #43]	; 0x2b
   1d3ce:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset0 =
   1d3d2:	f8a4 0104 	strh.w	r0, [r4, #260]	; 0x104
				sys_le16_to_cpu(cpr->offset1);
   1d3d6:	f895 702e 	ldrb.w	r7, [r5, #46]	; 0x2e
   1d3da:	f895 002d 	ldrb.w	r0, [r5, #45]	; 0x2d
   1d3de:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset1 =
   1d3e2:	f8a4 0106 	strh.w	r0, [r4, #262]	; 0x106
				sys_le16_to_cpu(cpr->offset2);
   1d3e6:	f895 7030 	ldrb.w	r7, [r5, #48]	; 0x30
   1d3ea:	f895 002f 	ldrb.w	r0, [r5, #47]	; 0x2f
   1d3ee:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset2 =
   1d3f2:	f8a4 0108 	strh.w	r0, [r4, #264]	; 0x108
				sys_le16_to_cpu(cpr->offset3);
   1d3f6:	f895 7032 	ldrb.w	r7, [r5, #50]	; 0x32
   1d3fa:	f895 0031 	ldrb.w	r0, [r5, #49]	; 0x31
   1d3fe:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset3 =
   1d402:	f8a4 010a 	strh.w	r0, [r4, #266]	; 0x10a
				sys_le16_to_cpu(cpr->offset4);
   1d406:	f895 7034 	ldrb.w	r7, [r5, #52]	; 0x34
   1d40a:	f895 0033 	ldrb.w	r0, [r5, #51]	; 0x33
   1d40e:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset4 =
   1d412:	f8a4 010c 	strh.w	r0, [r4, #268]	; 0x10c
				sys_le16_to_cpu(cpr->offset5);
   1d416:	f895 0035 	ldrb.w	r0, [r5, #53]	; 0x35
   1d41a:	f895 7036 	ldrb.w	r7, [r5, #54]	; 0x36
   1d41e:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
			conn->llcp_conn_param.offset5 =
   1d422:	f8a4 010e 	strh.w	r0, [r4, #270]	; 0x10e
			     lll->interval) ||
   1d426:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
			if ((conn->llcp_conn_param.interval_max !=
   1d428:	4282      	cmp	r2, r0
   1d42a:	e763      	b.n	1d2f4 <ull_conn_rx+0x4b0>
				conn->llcp_conn_param.state =
   1d42c:	f8b4 30f6 	ldrh.w	r3, [r4, #246]	; 0xf6
   1d430:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   1d434:	f043 0301 	orr.w	r3, r3, #1
   1d438:	f8a4 30f6 	strh.w	r3, [r4, #246]	; 0xf6
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   1d43c:	2301      	movs	r3, #1
   1d43e:	712b      	strb	r3, [r5, #4]
   1d440:	e773      	b.n	1d32a <ull_conn_rx+0x4e6>
   1d442:	bf00      	nop
   1d444:	200032cc 	.word	0x200032cc
   1d448:	20003238 	.word	0x20003238
		if (PDU_DATA_LLCTRL_LEN(reject_ext_ind) != pdu_rx->len) {
   1d44c:	7f6b      	ldrb	r3, [r5, #29]
   1d44e:	2b03      	cmp	r3, #3
   1d450:	f040 80dc 	bne.w	1d60c <ull_conn_rx+0x7c8>
	switch (rej_ext_ind->reject_opcode) {
   1d454:	f895 3020 	ldrb.w	r3, [r5, #32]
   1d458:	2b0f      	cmp	r3, #15
   1d45a:	f47f acfe 	bne.w	1ce5a <ull_conn_rx+0x16>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   1d45e:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
   1d462:	f894 10f5 	ldrb.w	r1, [r4, #245]	; 0xf5
   1d466:	4299      	cmp	r1, r3
   1d468:	f43f acf7 	beq.w	1ce5a <ull_conn_rx+0x16>
	if (!lll->role && (rej_ext_ind->error_code ==
   1d46c:	f994 0039 	ldrsb.w	r0, [r4, #57]	; 0x39
   1d470:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   1d474:	2800      	cmp	r0, #0
   1d476:	f2c0 80e3 	blt.w	1d640 <ull_conn_rx+0x7fc>
   1d47a:	291a      	cmp	r1, #26
   1d47c:	f040 80e6 	bne.w	1d64c <ull_conn_rx+0x808>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   1d480:	f894 209c 	ldrb.w	r2, [r4, #156]	; 0x9c
   1d484:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1d488:	429a      	cmp	r2, r3
   1d48a:	d00c      	beq.n	1d4a6 <ull_conn_rx+0x662>
   1d48c:	4a89      	ldr	r2, [pc, #548]	; (1d6b4 <ull_conn_rx+0x870>)
   1d48e:	498a      	ldr	r1, [pc, #552]	; (1d6b8 <ull_conn_rx+0x874>)
   1d490:	488a      	ldr	r0, [pc, #552]	; (1d6bc <ull_conn_rx+0x878>)
   1d492:	f241 43af 	movw	r3, #5295	; 0x14af
   1d496:	f007 fe91 	bl	251bc <printk>
   1d49a:	4040      	eors	r0, r0
   1d49c:	f380 8811 	msr	BASEPRI, r0
   1d4a0:	f04f 0003 	mov.w	r0, #3
   1d4a4:	df02      	svc	2
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   1d4a6:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
   1d4aa:	2206      	movs	r2, #6
   1d4ac:	f362 0303 	bfi	r3, r2, #0, #4
		conn->llcp_cu.win_size = 1U;
   1d4b0:	2201      	movs	r2, #1
   1d4b2:	f884 20ac 	strb.w	r2, [r4, #172]	; 0xac
		conn->llcp_cu.win_offset_us = 0U;
   1d4b6:	2200      	movs	r2, #0
   1d4b8:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   1d4bc:	f8b4 20fa 	ldrh.w	r2, [r4, #250]	; 0xfa
   1d4c0:	f8a4 20a0 	strh.w	r2, [r4, #160]	; 0xa0
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   1d4c4:	f8b4 20fc 	ldrh.w	r2, [r4, #252]	; 0xfc
   1d4c8:	f8a4 20a2 	strh.w	r2, [r4, #162]	; 0xa2
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   1d4cc:	f8b4 20fe 	ldrh.w	r2, [r4, #254]	; 0xfe
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   1d4d0:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   1d4d4:	f8a4 20a4 	strh.w	r2, [r4, #164]	; 0xa4
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   1d4d8:	f3c3 1300 	ubfx	r3, r3, #4, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d4dc:	f894 209e 	ldrb.w	r2, [r4, #158]	; 0x9e
   1d4e0:	00db      	lsls	r3, r3, #3
   1d4e2:	f043 0301 	orr.w	r3, r3, #1
   1d4e6:	f022 020f 	bic.w	r2, r2, #15
   1d4ea:	4313      	orrs	r3, r2
   1d4ec:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
		conn->llcp_cu.ack--;
   1d4f0:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1d4f4:	3b01      	subs	r3, #1
   1d4f6:	f884 309d 	strb.w	r3, [r4, #157]	; 0x9d
	if (err) {
   1d4fa:	e4ae      	b.n	1ce5a <ull_conn_rx+0x16>
		if (PDU_DATA_LLCTRL_LEN(unknown_rsp) != pdu_rx->len) {
   1d4fc:	7f6b      	ldrb	r3, [r5, #29]
   1d4fe:	2b02      	cmp	r3, #2
   1d500:	f040 8084 	bne.w	1d60c <ull_conn_rx+0x7c8>
			    conn->llcp_conn_param.req) &&
   1d504:	f894 10f4 	ldrb.w	r1, [r4, #244]	; 0xf4
		} else if ((conn->llcp_conn_param.ack !=
   1d508:	f894 30f5 	ldrb.w	r3, [r4, #245]	; 0xf5
   1d50c:	428b      	cmp	r3, r1
   1d50e:	f43f ad3c 	beq.w	1cf8a <ull_conn_rx+0x146>
			    conn->llcp_conn_param.req) &&
   1d512:	f895 3020 	ldrb.w	r3, [r5, #32]
   1d516:	2b0f      	cmp	r3, #15
   1d518:	f47f ad37 	bne.w	1cf8a <ull_conn_rx+0x146>
			conn->llcp_conn_param.disabled = 1U;
   1d51c:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
   1d520:	f043 0320 	orr.w	r3, r3, #32
   1d524:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
			if (!conn->lll.role) {
   1d528:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1d52c:	2b00      	cmp	r3, #0
   1d52e:	db3e      	blt.n	1d5ae <ull_conn_rx+0x76a>
				LL_ASSERT(conn->llcp_cu.req ==
   1d530:	f894 209c 	ldrb.w	r2, [r4, #156]	; 0x9c
   1d534:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1d538:	429a      	cmp	r2, r3
   1d53a:	d00c      	beq.n	1d556 <ull_conn_rx+0x712>
   1d53c:	4a5d      	ldr	r2, [pc, #372]	; (1d6b4 <ull_conn_rx+0x870>)
   1d53e:	495e      	ldr	r1, [pc, #376]	; (1d6b8 <ull_conn_rx+0x874>)
   1d540:	485e      	ldr	r0, [pc, #376]	; (1d6bc <ull_conn_rx+0x878>)
   1d542:	f641 33f5 	movw	r3, #7157	; 0x1bf5
   1d546:	f007 fe39 	bl	251bc <printk>
   1d54a:	4040      	eors	r0, r0
   1d54c:	f380 8811 	msr	BASEPRI, r0
   1d550:	f04f 0003 	mov.w	r0, #3
   1d554:	df02      	svc	2
				conn->llcp_conn_param.state =
   1d556:	f894 30f6 	ldrb.w	r3, [r4, #246]	; 0xf6
   1d55a:	2206      	movs	r2, #6
   1d55c:	f362 0303 	bfi	r3, r2, #0, #4
				conn->llcp_cu.interval =
   1d560:	f8b4 20fa 	ldrh.w	r2, [r4, #250]	; 0xfa
   1d564:	f8a4 20a0 	strh.w	r2, [r4, #160]	; 0xa0
				conn->llcp_cu.latency =
   1d568:	f8b4 20fc 	ldrh.w	r2, [r4, #252]	; 0xfc
   1d56c:	f8a4 20a2 	strh.w	r2, [r4, #162]	; 0xa2
				conn->llcp_cu.timeout =
   1d570:	f8b4 20fe 	ldrh.w	r2, [r4, #254]	; 0xfe
				conn->llcp_conn_param.state =
   1d574:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
				conn->llcp_cu.timeout =
   1d578:	f8a4 20a4 	strh.w	r2, [r4, #164]	; 0xa4
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   1d57c:	f3c3 1300 	ubfx	r3, r3, #4, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d580:	f894 209e 	ldrb.w	r2, [r4, #158]	; 0x9e
				conn->llcp_cu.win_size = 1U;
   1d584:	2101      	movs	r1, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   1d586:	00db      	lsls	r3, r3, #3
   1d588:	430b      	orrs	r3, r1
   1d58a:	f022 020f 	bic.w	r2, r2, #15
   1d58e:	4313      	orrs	r3, r2
   1d590:	f884 309e 	strb.w	r3, [r4, #158]	; 0x9e
				conn->llcp_cu.ack--;
   1d594:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
				conn->llcp_cu.win_size = 1U;
   1d598:	f884 10ac 	strb.w	r1, [r4, #172]	; 0xac
				conn->llcp_cu.ack--;
   1d59c:	3b01      	subs	r3, #1
   1d59e:	f884 309d 	strb.w	r3, [r4, #157]	; 0x9d
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   1d5a2:	6833      	ldr	r3, [r6, #0]
				conn->llcp_cu.win_offset_us = 0U;
   1d5a4:	2000      	movs	r0, #0
   1d5a6:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8
				(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   1d5aa:	7119      	strb	r1, [r3, #4]
				break;
   1d5ac:	e5ad      	b.n	1d10a <ull_conn_rx+0x2c6>
	conn_upd_curr = NULL;
   1d5ae:	4b44      	ldr	r3, [pc, #272]	; (1d6c0 <ull_conn_rx+0x87c>)
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1d5b0:	f884 10f5 	strb.w	r1, [r4, #245]	; 0xf5
	conn_upd_curr = NULL;
   1d5b4:	2000      	movs	r0, #0
   1d5b6:	6018      	str	r0, [r3, #0]
			if (!conn->llcp_conn_param.cmd) {
   1d5b8:	f894 00f6 	ldrb.w	r0, [r4, #246]	; 0xf6
   1d5bc:	f010 0010 	ands.w	r0, r0, #16
   1d5c0:	d102      	bne.n	1d5c8 <ull_conn_rx+0x784>
		(*rx)->hdr.type = NODE_RX_TYPE_RELEASE;
   1d5c2:	2301      	movs	r3, #1
   1d5c4:	712b      	strb	r3, [r5, #4]
		break;
   1d5c6:	e5a0      	b.n	1d10a <ull_conn_rx+0x2c6>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1d5c8:	2318      	movs	r3, #24
   1d5ca:	712b      	strb	r3, [r5, #4]
			LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   1d5cc:	07d3      	lsls	r3, r2, #31
   1d5ce:	d50c      	bpl.n	1d5ea <ull_conn_rx+0x7a6>
   1d5d0:	4a38      	ldr	r2, [pc, #224]	; (1d6b4 <ull_conn_rx+0x870>)
   1d5d2:	493c      	ldr	r1, [pc, #240]	; (1d6c4 <ull_conn_rx+0x880>)
   1d5d4:	4839      	ldr	r0, [pc, #228]	; (1d6bc <ull_conn_rx+0x878>)
   1d5d6:	f641 4322 	movw	r3, #7202	; 0x1c22
   1d5da:	f007 fdef 	bl	251bc <printk>
   1d5de:	4040      	eors	r0, r0
   1d5e0:	f380 8811 	msr	BASEPRI, r0
   1d5e4:	f04f 0003 	mov.w	r0, #3
   1d5e8:	df02      	svc	2
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   1d5ea:	231a      	movs	r3, #26
   1d5ec:	772b      	strb	r3, [r5, #28]
			cu->latency = lll->latency;
   1d5ee:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			cu->interval = lll->interval;
   1d5f0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
			cu->latency = lll->latency;
   1d5f2:	842b      	strh	r3, [r5, #32]
			cu->timeout = conn->supervision_reload *
   1d5f4:	f8b4 3072 	ldrh.w	r3, [r4, #114]	; 0x72
			cu->interval = lll->interval;
   1d5f8:	83ea      	strh	r2, [r5, #30]
			cu->timeout = conn->supervision_reload *
   1d5fa:	4353      	muls	r3, r2
				      lll->interval * 125U / 1000;
   1d5fc:	227d      	movs	r2, #125	; 0x7d
   1d5fe:	4353      	muls	r3, r2
   1d600:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1d604:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   1d608:	846b      	strh	r3, [r5, #34]	; 0x22
			    PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ)) {
   1d60a:	e4be      	b.n	1cf8a <ull_conn_rx+0x146>
	tx = ctrl_tx_rsp_mem_acquire(conn, rx, &err);
   1d60c:	4629      	mov	r1, r5
   1d60e:	aa01      	add	r2, sp, #4
   1d610:	4620      	mov	r0, r4
   1d612:	f7ff f943 	bl	1c89c <ctrl_tx_rsp_mem_acquire>
	if (!tx) {
   1d616:	4601      	mov	r1, r0
   1d618:	2800      	cmp	r0, #0
   1d61a:	f43f ad03 	beq.w	1d024 <ull_conn_rx+0x1e0>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   1d61e:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   1d620:	f880 8008 	strb.w	r8, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   1d624:	f043 0303 	orr.w	r3, r3, #3
   1d628:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   1d62a:	2302      	movs	r3, #2
   1d62c:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   1d62e:	2307      	movs	r3, #7
   1d630:	71c3      	strb	r3, [r0, #7]
	ctrl_tx_enqueue(conn, tx);
   1d632:	4620      	mov	r0, r4
   1d634:	f00d fe48 	bl	2b2c8 <ctrl_tx_enqueue>
   1d638:	e40f      	b.n	1ce5a <ull_conn_rx+0x16>
			return -ENOBUFS;
   1d63a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1d63e:	e564      	b.n	1d10a <ull_conn_rx+0x2c6>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   1d640:	2923      	cmp	r1, #35	; 0x23
   1d642:	d003      	beq.n	1d64c <ull_conn_rx+0x808>
			conn->periph.ticks_to_offset =
   1d644:	f8d4 1118 	ldr.w	r1, [r4, #280]	; 0x118
   1d648:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   1d64c:	f894 10f6 	ldrb.w	r1, [r4, #246]	; 0xf6
   1d650:	f001 000f 	and.w	r0, r1, #15
   1d654:	2804      	cmp	r0, #4
   1d656:	d106      	bne.n	1d666 <ull_conn_rx+0x822>
	conn_upd_curr = NULL;
   1d658:	4e19      	ldr	r6, [pc, #100]	; (1d6c0 <ull_conn_rx+0x87c>)
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   1d65a:	f884 30f5 	strb.w	r3, [r4, #245]	; 0xf5
	conn_upd_curr = NULL;
   1d65e:	2000      	movs	r0, #0
   1d660:	6030      	str	r0, [r6, #0]
		conn->procedure_expire = 0U;
   1d662:	f8a4 0078 	strh.w	r0, [r4, #120]	; 0x78
	if (!conn->llcp_conn_param.cmd) {
   1d666:	06c9      	lsls	r1, r1, #27
   1d668:	f57f abf7 	bpl.w	1ce5a <ull_conn_rx+0x16>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1d66c:	2318      	movs	r3, #24
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   1d66e:	07d2      	lsls	r2, r2, #31
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   1d670:	712b      	strb	r3, [r5, #4]
	LL_ASSERT(IS_PTR_ALIGNED(node, struct node_rx_cu));
   1d672:	d50c      	bpl.n	1d68e <ull_conn_rx+0x84a>
   1d674:	4a0f      	ldr	r2, [pc, #60]	; (1d6b4 <ull_conn_rx+0x870>)
   1d676:	4913      	ldr	r1, [pc, #76]	; (1d6c4 <ull_conn_rx+0x880>)
   1d678:	4810      	ldr	r0, [pc, #64]	; (1d6bc <ull_conn_rx+0x878>)
   1d67a:	f44f 53a7 	mov.w	r3, #5344	; 0x14e0
   1d67e:	f007 fd9d 	bl	251bc <printk>
   1d682:	4040      	eors	r0, r0
   1d684:	f380 8811 	msr	BASEPRI, r0
   1d688:	f04f 0003 	mov.w	r0, #3
   1d68c:	df02      	svc	2
	cu->status = rej_ext_ind->error_code;
   1d68e:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
   1d692:	772b      	strb	r3, [r5, #28]
	cu->latency = lll->latency;
   1d694:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
	cu->interval = lll->interval;
   1d696:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
	cu->latency = lll->latency;
   1d698:	842b      	strh	r3, [r5, #32]
	cu->timeout = conn->supervision_reload *
   1d69a:	f8b4 3072 	ldrh.w	r3, [r4, #114]	; 0x72
	cu->interval = lll->interval;
   1d69e:	83ea      	strh	r2, [r5, #30]
	cu->timeout = conn->supervision_reload *
   1d6a0:	4353      	muls	r3, r2
		      lll->interval * 125U / 1000;
   1d6a2:	227d      	movs	r2, #125	; 0x7d
   1d6a4:	4353      	muls	r3, r2
   1d6a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1d6aa:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   1d6ae:	846b      	strh	r3, [r5, #34]	; 0x22
	if (err) {
   1d6b0:	f7ff bbde 	b.w	1ce70 <ull_conn_rx+0x2c>
   1d6b4:	00034356 	.word	0x00034356
   1d6b8:	000343f9 	.word	0x000343f9
   1d6bc:	0002f8b5 	.word	0x0002f8b5
   1d6c0:	20003238 	.word	0x20003238
   1d6c4:	00033f48 	.word	0x00033f48

0001d6c8 <ull_conn_tx_demux>:
{
   1d6c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   1d6ca:	4c1e      	ldr	r4, [pc, #120]	; (1d744 <ull_conn_tx_demux+0x7c>)
{
   1d6cc:	4605      	mov	r5, r0
	return (void *)(fifo + first * size);
   1d6ce:	1d26      	adds	r6, r4, #4
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   1d6d0:	78a3      	ldrb	r3, [r4, #2]
	if (first == last) {
   1d6d2:	78e1      	ldrb	r1, [r4, #3]
   1d6d4:	7822      	ldrb	r2, [r4, #0]
   1d6d6:	4299      	cmp	r1, r3
   1d6d8:	d02a      	beq.n	1d730 <ull_conn_tx_demux+0x68>
	return (void *)(fifo + first * size);
   1d6da:	fb13 f302 	smulbb	r3, r3, r2
   1d6de:	18f7      	adds	r7, r6, r3
		conn = ll_connected_get(lll_tx->handle);
   1d6e0:	5af0      	ldrh	r0, [r6, r3]
   1d6e2:	f00d fe34 	bl	2b34e <ll_connected_get>
		if (conn) {
   1d6e6:	6879      	ldr	r1, [r7, #4]
   1d6e8:	b318      	cbz	r0, 1d732 <ull_conn_tx_demux+0x6a>
			tx->next = NULL;
   1d6ea:	2300      	movs	r3, #0
   1d6ec:	600b      	str	r3, [r1, #0]
			if (!conn->tx_data) {
   1d6ee:	f8d0 3128 	ldr.w	r3, [r0, #296]	; 0x128
   1d6f2:	b943      	cbnz	r3, 1d706 <ull_conn_tx_demux+0x3e>
				if (!conn->tx_head) {
   1d6f4:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
				conn->tx_data = tx;
   1d6f8:	f8c0 1128 	str.w	r1, [r0, #296]	; 0x128
				if (!conn->tx_head) {
   1d6fc:	b91b      	cbnz	r3, 1d706 <ull_conn_tx_demux+0x3e>
					conn->tx_head = tx;
   1d6fe:	f8c0 111c 	str.w	r1, [r0, #284]	; 0x11c
					conn->tx_data_last = NULL;
   1d702:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
			if (conn->tx_data_last) {
   1d706:	f8d0 312c 	ldr.w	r3, [r0, #300]	; 0x12c
   1d70a:	b103      	cbz	r3, 1d70e <ull_conn_tx_demux+0x46>
				conn->tx_data_last->next = tx;
   1d70c:	6019      	str	r1, [r3, #0]
			conn->tx_data_last = tx;
   1d70e:	f8c0 112c 	str.w	r1, [r0, #300]	; 0x12c
	uint8_t _first = *first; /* Copy read-index */
   1d712:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
   1d714:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(conn_tx);
   1d716:	7862      	ldrb	r2, [r4, #1]
   1d718:	4299      	cmp	r1, r3
   1d71a:	d005      	beq.n	1d728 <ull_conn_tx_demux+0x60>
	_first += 1U;
   1d71c:	3301      	adds	r3, #1
   1d71e:	b2db      	uxtb	r3, r3
		_first = 0U;
   1d720:	429a      	cmp	r2, r3
   1d722:	bf08      	it	eq
   1d724:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1d726:	70a3      	strb	r3, [r4, #2]
	} while (--count);
   1d728:	3d01      	subs	r5, #1
   1d72a:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   1d72e:	d1cf      	bne.n	1d6d0 <ull_conn_tx_demux+0x8>
}
   1d730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p->ll_id = PDU_DATA_LLID_RESV;
   1d732:	790b      	ldrb	r3, [r1, #4]
   1d734:	f360 0301 	bfi	r3, r0, #0, #2
   1d738:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(LLL_HANDLE_INVALID, tx);
   1d73a:	f64f 70ff 	movw	r0, #65535	; 0xffff
   1d73e:	f7fe f80f 	bl	1b760 <ll_tx_ack_put>
   1d742:	e7e6      	b.n	1d712 <ull_conn_tx_demux+0x4a>
   1d744:	20000a90 	.word	0x20000a90

0001d748 <conn_cleanup>:
	if (conn == conn_upd_curr) {
   1d748:	4b3d      	ldr	r3, [pc, #244]	; (1d840 <conn_cleanup+0xf8>)
{
   1d74a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (conn == conn_upd_curr) {
   1d74e:	681a      	ldr	r2, [r3, #0]
	*((uint8_t *)rx->pdu) = reason;
   1d750:	f880 10f0 	strb.w	r1, [r0, #240]	; 0xf0
	if (conn == conn_upd_curr) {
   1d754:	4290      	cmp	r0, r2
		conn_upd_curr = NULL;
   1d756:	bf04      	itt	eq
   1d758:	2200      	moveq	r2, #0
   1d75a:	601a      	streq	r2, [r3, #0]
	rx->hdr.handle = conn->lll.handle;
   1d75c:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   1d75e:	f8a0 30da 	strh.w	r3, [r0, #218]	; 0xda
	rx = conn->llcp_rx;
   1d762:	f8d0 1098 	ldr.w	r1, [r0, #152]	; 0x98
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   1d766:	2317      	movs	r3, #23
{
   1d768:	4604      	mov	r4, r0
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   1d76a:	f880 30d8 	strb.w	r3, [r0, #216]	; 0xd8
		hdr->type = NODE_RX_TYPE_RELEASE;
   1d76e:	2501      	movs	r5, #1
	while (rx) {
   1d770:	bb49      	cbnz	r1, 1d7c6 <conn_cleanup+0x7e>
		link = mem_acquire(&mem_link_tx.free);
   1d772:	4f34      	ldr	r7, [pc, #208]	; (1d844 <conn_cleanup+0xfc>)
		LL_ASSERT(link);
   1d774:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 1d848 <conn_cleanup+0x100>
   1d778:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 1d84c <conn_cleanup+0x104>
	while (conn->tx_head) {
   1d77c:	f8d4 511c 	ldr.w	r5, [r4, #284]	; 0x11c
   1d780:	bb45      	cbnz	r5, 1d7d4 <conn_cleanup+0x8c>
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1d782:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   1d784:	4b32      	ldr	r3, [pc, #200]	; (1d850 <conn_cleanup+0x108>)
   1d786:	9400      	str	r4, [sp, #0]
   1d788:	3205      	adds	r2, #5
   1d78a:	b2d2      	uxtb	r2, r2
   1d78c:	2101      	movs	r1, #1
   1d78e:	4628      	mov	r0, r5
   1d790:	f7fc fc28 	bl	19fe4 <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1d794:	f030 0302 	bics.w	r3, r0, #2
   1d798:	d00c      	beq.n	1d7b4 <conn_cleanup+0x6c>
   1d79a:	4a2b      	ldr	r2, [pc, #172]	; (1d848 <conn_cleanup+0x100>)
   1d79c:	492d      	ldr	r1, [pc, #180]	; (1d854 <conn_cleanup+0x10c>)
   1d79e:	482e      	ldr	r0, [pc, #184]	; (1d858 <conn_cleanup+0x110>)
   1d7a0:	f640 1323 	movw	r3, #2339	; 0x923
   1d7a4:	f007 fd0a 	bl	251bc <printk>
   1d7a8:	4040      	eors	r0, r0
   1d7aa:	f380 8811 	msr	BASEPRI, r0
   1d7ae:	f04f 0003 	mov.w	r0, #3
   1d7b2:	df02      	svc	2
	lll->handle = LLL_HANDLE_INVALID;
   1d7b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
   1d7b8:	20ff      	movs	r0, #255	; 0xff
	lll->handle = LLL_HANDLE_INVALID;
   1d7ba:	8523      	strh	r3, [r4, #40]	; 0x28
}
   1d7bc:	b003      	add	sp, #12
   1d7be:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	ull_conn_tx_demux(UINT8_MAX);
   1d7c2:	f7ff bf81 	b.w	1d6c8 <ull_conn_tx_demux>
		rx = hdr->link->mem;
   1d7c6:	6808      	ldr	r0, [r1, #0]
   1d7c8:	6846      	ldr	r6, [r0, #4]
		hdr->type = NODE_RX_TYPE_RELEASE;
   1d7ca:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   1d7cc:	f7fd ff06 	bl	1b5dc <ll_rx_put>
		rx = hdr->link->mem;
   1d7d0:	4631      	mov	r1, r6
   1d7d2:	e7cd      	b.n	1d770 <conn_cleanup+0x28>
	if (conn->tx_head == conn->tx_ctrl) {
   1d7d4:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
		conn->tx_head = conn->tx_head->next;
   1d7d8:	682b      	ldr	r3, [r5, #0]
	if (conn->tx_head == conn->tx_ctrl) {
   1d7da:	4295      	cmp	r5, r2
   1d7dc:	d124      	bne.n	1d828 <conn_cleanup+0xe0>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1d7de:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
		conn->tx_head = conn->tx_head->next;
   1d7e2:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1d7e6:	4295      	cmp	r5, r2
			conn->tx_ctrl = NULL;
   1d7e8:	bf06      	itte	eq
   1d7ea:	2300      	moveq	r3, #0
			conn->tx_ctrl_last = NULL;
   1d7ec:	e9c4 3348 	strdeq	r3, r3, [r4, #288]	; 0x120
			conn->tx_ctrl = conn->tx_head;
   1d7f0:	f8c4 3120 	strne.w	r3, [r4, #288]	; 0x120
		tx->next = tx;
   1d7f4:	602d      	str	r5, [r5, #0]
		link = mem_acquire(&mem_link_tx.free);
   1d7f6:	4638      	mov	r0, r7
   1d7f8:	f00d f80a 	bl	2a810 <mem_acquire>
		LL_ASSERT(link);
   1d7fc:	4606      	mov	r6, r0
   1d7fe:	b960      	cbnz	r0, 1d81a <conn_cleanup+0xd2>
   1d800:	4815      	ldr	r0, [pc, #84]	; (1d858 <conn_cleanup+0x110>)
   1d802:	f640 135e 	movw	r3, #2398	; 0x95e
   1d806:	4642      	mov	r2, r8
   1d808:	4649      	mov	r1, r9
   1d80a:	f007 fcd7 	bl	251bc <printk>
   1d80e:	4040      	eors	r0, r0
   1d810:	f380 8811 	msr	BASEPRI, r0
   1d814:	f04f 0003 	mov.w	r0, #3
   1d818:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   1d81a:	f104 025c 	add.w	r2, r4, #92	; 0x5c
   1d81e:	4629      	mov	r1, r5
   1d820:	4630      	mov	r0, r6
   1d822:	f00d f853 	bl	2a8cc <memq_enqueue>
   1d826:	e7a9      	b.n	1d77c <conn_cleanup+0x34>
		if (conn->tx_head == conn->tx_data) {
   1d828:	f8d4 2128 	ldr.w	r2, [r4, #296]	; 0x128
		conn->tx_head = conn->tx_head->next;
   1d82c:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		if (conn->tx_head == conn->tx_data) {
   1d830:	4295      	cmp	r5, r2
			conn->tx_data = conn->tx_data->next;
   1d832:	bf08      	it	eq
   1d834:	f8c4 3128 	streq.w	r3, [r4, #296]	; 0x128
		tx->next = NULL;
   1d838:	2300      	movs	r3, #0
   1d83a:	602b      	str	r3, [r5, #0]
   1d83c:	e7db      	b.n	1d7f6 <conn_cleanup+0xae>
   1d83e:	bf00      	nop
   1d840:	20003238 	.word	0x20003238
   1d844:	20003380 	.word	0x20003380
   1d848:	00034356 	.word	0x00034356
   1d84c:	000337d3 	.word	0x000337d3
   1d850:	0001c925 	.word	0x0001c925
   1d854:	00034433 	.word	0x00034433
   1d858:	0002f8b5 	.word	0x0002f8b5

0001d85c <ull_conn_done>:
{
   1d85c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	conn = CONTAINER_OF(done->param, struct ll_conn, ull);
   1d860:	69c4      	ldr	r4, [r0, #28]
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
   1d862:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   1d864:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1d868:	429a      	cmp	r2, r3
{
   1d86a:	b08a      	sub	sp, #40	; 0x28
   1d86c:	4680      	mov	r8, r0
	if (unlikely(lll->handle == LLL_HANDLE_INVALID)) {
   1d86e:	f000 80ba 	beq.w	1d9e6 <ull_conn_done+0x18a>
	reason_final = conn->llcp_terminate.reason_final;
   1d872:	f894 50d3 	ldrb.w	r5, [r4, #211]	; 0xd3
	if (reason_final && (
   1d876:	b135      	cbz	r5, 1d886 <ull_conn_done+0x2a>
		conn_cleanup(conn, reason_final);
   1d878:	4629      	mov	r1, r5
   1d87a:	4620      	mov	r0, r4
}
   1d87c:	b00a      	add	sp, #40	; 0x28
   1d87e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		conn_cleanup(conn, reason_final);
   1d882:	f7ff bf61 	b.w	1d748 <conn_cleanup>
	latency_event = lll->latency_event;
   1d886:	8e27      	ldrh	r7, [r4, #48]	; 0x30
	if (done->extra.trx_cnt) {
   1d888:	8c83      	ldrh	r3, [r0, #36]	; 0x24
	elapsed_event = latency_event + 1;
   1d88a:	1c7e      	adds	r6, r7, #1
	ticks_drift_minus = 0U;
   1d88c:	e9cd 5508 	strd	r5, r5, [sp, #32]
	elapsed_event = latency_event + 1;
   1d890:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
   1d892:	b17b      	cbz	r3, 1d8b4 <ull_conn_done+0x58>
		} else if (lll->role) {
   1d894:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1d898:	2b00      	cmp	r3, #0
   1d89a:	da08      	bge.n	1d8ae <ull_conn_done+0x52>
			ull_drift_ticks_get(done, &ticks_drift_plus,
   1d89c:	aa08      	add	r2, sp, #32
   1d89e:	a909      	add	r1, sp, #36	; 0x24
   1d8a0:	f7e2 fd9e 	bl	3e0 <ull_drift_ticks_get>
			if (!conn->tx_head) {
   1d8a4:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   1d8a8:	b163      	cbz	r3, 1d8c4 <ull_conn_done+0x68>
				lll->latency_event = 0;
   1d8aa:	2300      	movs	r3, #0
				lll->latency_event = lll->latency;
   1d8ac:	8623      	strh	r3, [r4, #48]	; 0x30
		conn->connect_expire = 0U;
   1d8ae:	2300      	movs	r3, #0
   1d8b0:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
	if (done->extra.crc_valid) {
   1d8b4:	f898 3026 	ldrb.w	r3, [r8, #38]	; 0x26
   1d8b8:	07db      	lsls	r3, r3, #31
   1d8ba:	d517      	bpl.n	1d8ec <ull_conn_done+0x90>
		conn->supervision_expire = 0U;
   1d8bc:	2300      	movs	r3, #0
			conn->supervision_expire = conn->supervision_reload;
   1d8be:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
   1d8c2:	e01c      	b.n	1d8fe <ull_conn_done+0xa2>
				ull_conn_tx_demux(UINT8_MAX);
   1d8c4:	20ff      	movs	r0, #255	; 0xff
   1d8c6:	f7ff feff 	bl	1d6c8 <ull_conn_tx_demux>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   1d8ca:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   1d8ce:	2b00      	cmp	r3, #0
   1d8d0:	d1eb      	bne.n	1d8aa <ull_conn_done+0x4e>
   1d8d2:	e9d4 0116 	ldrd	r0, r1, [r4, #88]	; 0x58
   1d8d6:	462a      	mov	r2, r5
   1d8d8:	f00c ffff 	bl	2a8da <memq_peek>
   1d8dc:	2800      	cmp	r0, #0
   1d8de:	d1e4      	bne.n	1d8aa <ull_conn_done+0x4e>
			} else if (lll->periph.latency_enabled) {
   1d8e0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1d8e4:	075a      	lsls	r2, r3, #29
   1d8e6:	d5e2      	bpl.n	1d8ae <ull_conn_done+0x52>
				lll->latency_event = lll->latency;
   1d8e8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   1d8ea:	e7df      	b.n	1d8ac <ull_conn_done+0x50>
	else if (conn->connect_expire) {
   1d8ec:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
   1d8f0:	2b00      	cmp	r3, #0
   1d8f2:	d07b      	beq.n	1d9ec <ull_conn_done+0x190>
		if (conn->connect_expire > elapsed_event) {
   1d8f4:	42b3      	cmp	r3, r6
   1d8f6:	d972      	bls.n	1d9de <ull_conn_done+0x182>
			conn->connect_expire -= elapsed_event;
   1d8f8:	1b9b      	subs	r3, r3, r6
   1d8fa:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
	if (conn->supervision_expire) {
   1d8fe:	f8b4 3074 	ldrh.w	r3, [r4, #116]	; 0x74
   1d902:	b1e3      	cbz	r3, 1d93e <ull_conn_done+0xe2>
		if (conn->supervision_expire > elapsed_event) {
   1d904:	42b3      	cmp	r3, r6
   1d906:	d978      	bls.n	1d9fa <ull_conn_done+0x19e>
			conn->supervision_expire -= elapsed_event;
   1d908:	1b9b      	subs	r3, r3, r6
   1d90a:	b29b      	uxth	r3, r3
			lll->latency_event = 0U;
   1d90c:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   1d90e:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   1d910:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
			lll->latency_event = 0U;
   1d914:	8622      	strh	r2, [r4, #48]	; 0x30
			if (conn->supervision_expire <= 6U) {
   1d916:	d972      	bls.n	1d9fe <ull_conn_done+0x1a2>
			else if (lll->role) {
   1d918:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
   1d91c:	4293      	cmp	r3, r2
   1d91e:	da0e      	bge.n	1d93e <ull_conn_done+0xe2>
				if (latency_event) {
   1d920:	2f00      	cmp	r7, #0
   1d922:	d16c      	bne.n	1d9fe <ull_conn_done+0x1a2>
					force = conn->periph.force & 0x01;
   1d924:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
					conn->periph.force >>= 1U;
   1d928:	085a      	lsrs	r2, r3, #1
					if (force) {
   1d92a:	f013 0301 	ands.w	r3, r3, #1
						conn->periph.force |= BIT(31);
   1d92e:	bf17      	itett	ne
   1d930:	f042 4200 	orrne.w	r2, r2, #2147483648	; 0x80000000
					conn->periph.force >>= 1U;
   1d934:	f8c4 2080 	streq.w	r2, [r4, #128]	; 0x80
						conn->periph.force |= BIT(31);
   1d938:	f8c4 2080 	strne.w	r2, [r4, #128]	; 0x80
					force = conn->periph.force & 0x01;
   1d93c:	461d      	movne	r5, r3
	if (conn->procedure_expire != 0U) {
   1d93e:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1d942:	b123      	cbz	r3, 1d94e <ull_conn_done+0xf2>
		if (conn->procedure_expire > elapsed_event) {
   1d944:	42b3      	cmp	r3, r6
   1d946:	d95c      	bls.n	1da02 <ull_conn_done+0x1a6>
			conn->procedure_expire -= elapsed_event;
   1d948:	1b9b      	subs	r3, r3, r6
   1d94a:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   1d94e:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   1d952:	f894 2089 	ldrb.w	r2, [r4, #137]	; 0x89
   1d956:	1a9b      	subs	r3, r3, r2
   1d958:	f003 0303 	and.w	r3, r3, #3
   1d95c:	2b02      	cmp	r3, #2
   1d95e:	d104      	bne.n	1d96a <ull_conn_done+0x10e>
	     ((conn->llcp_type == LLCP_CONN_UPD) ||
   1d960:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   1d964:	3b01      	subs	r3, #1
   1d966:	2b01      	cmp	r3, #1
   1d968:	d905      	bls.n	1d976 <ull_conn_done+0x11a>
	      (conn->llcp_type == LLCP_CHAN_MAP))) ||
   1d96a:	f894 209c 	ldrb.w	r2, [r4, #156]	; 0x9c
   1d96e:	f894 309d 	ldrb.w	r3, [r4, #157]	; 0x9d
   1d972:	429a      	cmp	r2, r3
   1d974:	d001      	beq.n	1d97a <ull_conn_done+0x11e>
		lll->latency_event = 0U;
   1d976:	2300      	movs	r3, #0
   1d978:	8623      	strh	r3, [r4, #48]	; 0x30
	if ((force) || (latency_event != lll->latency_event)) {
   1d97a:	8e21      	ldrh	r1, [r4, #48]	; 0x30
   1d97c:	b90d      	cbnz	r5, 1d982 <ull_conn_done+0x126>
   1d97e:	428f      	cmp	r7, r1
   1d980:	d041      	beq.n	1da06 <ull_conn_done+0x1aa>
		lazy = lll->latency_event + 1U;
   1d982:	3101      	adds	r1, #1
   1d984:	b289      	uxth	r1, r1
	if (ticks_drift_plus || ticks_drift_minus || lazy || force) {
   1d986:	e9dd 7308 	ldrd	r7, r3, [sp, #32]
   1d98a:	ea53 0207 	orrs.w	r2, r3, r7
   1d98e:	d101      	bne.n	1d994 <ull_conn_done+0x138>
   1d990:	b901      	cbnz	r1, 1d994 <ull_conn_done+0x138>
   1d992:	b345      	cbz	r5, 1d9e6 <ull_conn_done+0x18a>
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   1d994:	8d22      	ldrh	r2, [r4, #40]	; 0x28
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1d996:	481d      	ldr	r0, [pc, #116]	; (1da0c <ull_conn_done+0x1b0>)
		struct ll_conn *conn = lll->hdr.parent;
   1d998:	69e6      	ldr	r6, [r4, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1d99a:	9606      	str	r6, [sp, #24]
   1d99c:	e9cd 5004 	strd	r5, r0, [sp, #16]
		uint8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   1d9a0:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1d9a2:	2000      	movs	r0, #0
   1d9a4:	9103      	str	r1, [sp, #12]
   1d9a6:	e9cd 0001 	strd	r0, r0, [sp, #4]
   1d9aa:	9700      	str	r7, [sp, #0]
   1d9ac:	b2d2      	uxtb	r2, r2
   1d9ae:	2101      	movs	r1, #1
   1d9b0:	f00d fa3a 	bl	2ae28 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1d9b4:	f030 0302 	bics.w	r3, r0, #2
   1d9b8:	d015      	beq.n	1d9e6 <ull_conn_done+0x18a>
   1d9ba:	f7fd ff59 	bl	1b870 <ull_disable_mark_get>
   1d9be:	4286      	cmp	r6, r0
   1d9c0:	d011      	beq.n	1d9e6 <ull_conn_done+0x18a>
   1d9c2:	4a13      	ldr	r2, [pc, #76]	; (1da10 <ull_conn_done+0x1b4>)
   1d9c4:	4913      	ldr	r1, [pc, #76]	; (1da14 <ull_conn_done+0x1b8>)
   1d9c6:	4814      	ldr	r0, [pc, #80]	; (1da18 <ull_conn_done+0x1bc>)
   1d9c8:	f240 63cd 	movw	r3, #1741	; 0x6cd
   1d9cc:	f007 fbf6 	bl	251bc <printk>
   1d9d0:	4040      	eors	r0, r0
   1d9d2:	f380 8811 	msr	BASEPRI, r0
   1d9d6:	f04f 0003 	mov.w	r0, #3
   1d9da:	df02      	svc	2
   1d9dc:	e003      	b.n	1d9e6 <ull_conn_done+0x18a>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   1d9de:	213e      	movs	r1, #62	; 0x3e
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   1d9e0:	4620      	mov	r0, r4
   1d9e2:	f7ff feb1 	bl	1d748 <conn_cleanup>
}
   1d9e6:	b00a      	add	sp, #40	; 0x28
   1d9e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!conn->supervision_expire) {
   1d9ec:	f8b4 3074 	ldrh.w	r3, [r4, #116]	; 0x74
   1d9f0:	2b00      	cmp	r3, #0
   1d9f2:	d184      	bne.n	1d8fe <ull_conn_done+0xa2>
			conn->supervision_expire = conn->supervision_reload;
   1d9f4:	f8b4 3072 	ldrh.w	r3, [r4, #114]	; 0x72
   1d9f8:	e761      	b.n	1d8be <ull_conn_done+0x62>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   1d9fa:	2108      	movs	r1, #8
   1d9fc:	e7f0      	b.n	1d9e0 <ull_conn_done+0x184>
				force = 1U;
   1d9fe:	2501      	movs	r5, #1
   1da00:	e79d      	b.n	1d93e <ull_conn_done+0xe2>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   1da02:	2122      	movs	r1, #34	; 0x22
   1da04:	e7ec      	b.n	1d9e0 <ull_conn_done+0x184>
	lazy = 0U;
   1da06:	4629      	mov	r1, r5
   1da08:	e7bd      	b.n	1d986 <ull_conn_done+0x12a>
   1da0a:	bf00      	nop
   1da0c:	0001cb35 	.word	0x0001cb35
   1da10:	00034356 	.word	0x00034356
   1da14:	00034460 	.word	0x00034460
   1da18:	0002f8b5 	.word	0x0002f8b5

0001da1c <ull_conn_tx_lll_enqueue>:
{
   1da1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   1da20:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1daac <ull_conn_tx_lll_enqueue+0x90>
		LL_ASSERT(link);
   1da24:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1dab0 <ull_conn_tx_lll_enqueue+0x94>
   1da28:	f8df a088 	ldr.w	sl, [pc, #136]	; 1dab4 <ull_conn_tx_lll_enqueue+0x98>
{
   1da2c:	4604      	mov	r4, r0
   1da2e:	460e      	mov	r6, r1
	while (conn->tx_head &&
   1da30:	f8d4 511c 	ldr.w	r5, [r4, #284]	; 0x11c
   1da34:	b105      	cbz	r5, 1da38 <ull_conn_tx_lll_enqueue+0x1c>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   1da36:	b90e      	cbnz	r6, 1da3c <ull_conn_tx_lll_enqueue+0x20>
}
   1da38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (conn->tx_head == conn->tx_ctrl) {
   1da3c:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
		conn->tx_head = conn->tx_head->next;
   1da40:	682b      	ldr	r3, [r5, #0]
	if (conn->tx_head == conn->tx_ctrl) {
   1da42:	4295      	cmp	r5, r2
   1da44:	d126      	bne.n	1da94 <ull_conn_tx_lll_enqueue+0x78>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1da46:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
		conn->tx_head = conn->tx_head->next;
   1da4a:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   1da4e:	4295      	cmp	r5, r2
			conn->tx_ctrl = NULL;
   1da50:	bf06      	itte	eq
   1da52:	2300      	moveq	r3, #0
			conn->tx_ctrl_last = NULL;
   1da54:	e9c4 3348 	strdeq	r3, r3, [r4, #288]	; 0x120
			conn->tx_ctrl = conn->tx_head;
   1da58:	f8c4 3120 	strne.w	r3, [r4, #288]	; 0x120
		tx->next = tx;
   1da5c:	602d      	str	r5, [r5, #0]
		link = mem_acquire(&mem_link_tx.free);
   1da5e:	4640      	mov	r0, r8
   1da60:	f00c fed6 	bl	2a810 <mem_acquire>
		LL_ASSERT(link);
   1da64:	4607      	mov	r7, r0
   1da66:	b960      	cbnz	r0, 1da82 <ull_conn_tx_lll_enqueue+0x66>
   1da68:	4813      	ldr	r0, [pc, #76]	; (1dab8 <ull_conn_tx_lll_enqueue+0x9c>)
   1da6a:	f240 7326 	movw	r3, #1830	; 0x726
   1da6e:	464a      	mov	r2, r9
   1da70:	4651      	mov	r1, sl
   1da72:	f007 fba3 	bl	251bc <printk>
   1da76:	4040      	eors	r0, r0
   1da78:	f380 8811 	msr	BASEPRI, r0
   1da7c:	f04f 0003 	mov.w	r0, #3
   1da80:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   1da82:	f104 025c 	add.w	r2, r4, #92	; 0x5c
   1da86:	4629      	mov	r1, r5
   1da88:	4638      	mov	r0, r7
   1da8a:	3e01      	subs	r6, #1
   1da8c:	f00c ff1e 	bl	2a8cc <memq_enqueue>
   1da90:	b2f6      	uxtb	r6, r6
   1da92:	e7cd      	b.n	1da30 <ull_conn_tx_lll_enqueue+0x14>
		if (conn->tx_head == conn->tx_data) {
   1da94:	f8d4 2128 	ldr.w	r2, [r4, #296]	; 0x128
		conn->tx_head = conn->tx_head->next;
   1da98:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		if (conn->tx_head == conn->tx_data) {
   1da9c:	4295      	cmp	r5, r2
			conn->tx_data = conn->tx_data->next;
   1da9e:	bf08      	it	eq
   1daa0:	f8c4 3128 	streq.w	r3, [r4, #296]	; 0x128
		tx->next = NULL;
   1daa4:	2300      	movs	r3, #0
   1daa6:	602b      	str	r3, [r5, #0]
   1daa8:	e7d9      	b.n	1da5e <ull_conn_tx_lll_enqueue+0x42>
   1daaa:	bf00      	nop
   1daac:	20003380 	.word	0x20003380
   1dab0:	00034356 	.word	0x00034356
   1dab4:	000337d3 	.word	0x000337d3
   1dab8:	0002f8b5 	.word	0x0002f8b5

0001dabc <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   1dabc:	4901      	ldr	r1, [pc, #4]	; (1dac4 <ull_conn_link_tx_release+0x8>)
   1dabe:	f00c bec0 	b.w	2a842 <mem_release>
   1dac2:	bf00      	nop
   1dac4:	20003380 	.word	0x20003380

0001dac8 <ull_conn_ack_last_idx_get>:
}
   1dac8:	4b01      	ldr	r3, [pc, #4]	; (1dad0 <ull_conn_ack_last_idx_get+0x8>)
   1daca:	78d8      	ldrb	r0, [r3, #3]
   1dacc:	4770      	bx	lr
   1dace:	bf00      	nop
   1dad0:	20000a4c 	.word	0x20000a4c

0001dad4 <ull_conn_ack_peek>:
{
   1dad4:	b570      	push	{r4, r5, r6, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   1dad6:	4b09      	ldr	r3, [pc, #36]	; (1dafc <ull_conn_ack_peek+0x28>)
   1dad8:	789c      	ldrb	r4, [r3, #2]
   1dada:	78dd      	ldrb	r5, [r3, #3]
   1dadc:	781e      	ldrb	r6, [r3, #0]
	if (first == last) {
   1dade:	42ac      	cmp	r4, r5
   1dae0:	d00a      	beq.n	1daf8 <ull_conn_ack_peek+0x24>
	return (void *)(fifo + first * size);
   1dae2:	3304      	adds	r3, #4
   1dae4:	fb14 f406 	smulbb	r4, r4, r6
	*ack_last = mfifo_conn_ack.l;
   1dae8:	7005      	strb	r5, [r0, #0]
   1daea:	191e      	adds	r6, r3, r4
	*handle = lll_tx->handle;
   1daec:	5b1b      	ldrh	r3, [r3, r4]
   1daee:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   1daf0:	6873      	ldr	r3, [r6, #4]
   1daf2:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   1daf4:	6818      	ldr	r0, [r3, #0]
}
   1daf6:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   1daf8:	2000      	movs	r0, #0
   1dafa:	e7fc      	b.n	1daf6 <ull_conn_ack_peek+0x22>
   1dafc:	20000a4c 	.word	0x20000a4c

0001db00 <ull_conn_ack_by_last_peek>:
{
   1db00:	b530      	push	{r4, r5, lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   1db02:	4b08      	ldr	r3, [pc, #32]	; (1db24 <ull_conn_ack_by_last_peek+0x24>)
   1db04:	789c      	ldrb	r4, [r3, #2]
   1db06:	781d      	ldrb	r5, [r3, #0]
	if (first == last) {
   1db08:	4284      	cmp	r4, r0
   1db0a:	d009      	beq.n	1db20 <ull_conn_ack_by_last_peek+0x20>
	return (void *)(fifo + first * size);
   1db0c:	3304      	adds	r3, #4
   1db0e:	fb14 f405 	smulbb	r4, r4, r5
   1db12:	1918      	adds	r0, r3, r4
	*handle = lll_tx->handle;
   1db14:	5b1b      	ldrh	r3, [r3, r4]
   1db16:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   1db18:	6843      	ldr	r3, [r0, #4]
   1db1a:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   1db1c:	6818      	ldr	r0, [r3, #0]
}
   1db1e:	bd30      	pop	{r4, r5, pc}
		return NULL;
   1db20:	2000      	movs	r0, #0
   1db22:	e7fc      	b.n	1db1e <ull_conn_ack_by_last_peek+0x1e>
   1db24:	20000a4c 	.word	0x20000a4c

0001db28 <ull_conn_ack_dequeue>:
{
   1db28:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(conn_ack);
   1db2a:	4a09      	ldr	r2, [pc, #36]	; (1db50 <ull_conn_ack_dequeue+0x28>)
	uint8_t _first = *first; /* Copy read-index */
   1db2c:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1db2e:	78d0      	ldrb	r0, [r2, #3]
   1db30:	7811      	ldrb	r1, [r2, #0]
   1db32:	7854      	ldrb	r4, [r2, #1]
   1db34:	4298      	cmp	r0, r3
   1db36:	d009      	beq.n	1db4c <ull_conn_ack_dequeue+0x24>
	mem = *((void **)(fifo + _first * size));
   1db38:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1db3c:	3301      	adds	r3, #1
   1db3e:	b2db      	uxtb	r3, r3
		_first = 0U;
   1db40:	429c      	cmp	r4, r3
   1db42:	bf08      	it	eq
   1db44:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1db46:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   1db48:	7093      	strb	r3, [r2, #2]
}
   1db4a:	bd10      	pop	{r4, pc}
		return NULL;
   1db4c:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
   1db4e:	e7fc      	b.n	1db4a <ull_conn_ack_dequeue+0x22>
   1db50:	20000a4c 	.word	0x20000a4c

0001db54 <ull_conn_lll_ack_enqueue>:
{
   1db54:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   1db56:	4a12      	ldr	r2, [pc, #72]	; (1dba0 <ull_conn_lll_ack_enqueue+0x4c>)
   1db58:	78d6      	ldrb	r6, [r2, #3]
	if (last == count) {
   1db5a:	7855      	ldrb	r5, [r2, #1]
   1db5c:	7894      	ldrb	r4, [r2, #2]
	last = last + 1;
   1db5e:	1c73      	adds	r3, r6, #1
   1db60:	b2db      	uxtb	r3, r3
		last = 0U;
   1db62:	429d      	cmp	r5, r3
   1db64:	bf08      	it	eq
   1db66:	2300      	moveq	r3, #0
	if (last == first) {
   1db68:	429c      	cmp	r4, r3
   1db6a:	d10f      	bne.n	1db8c <ull_conn_lll_ack_enqueue+0x38>
	LL_ASSERT(lll_tx);
   1db6c:	4a0d      	ldr	r2, [pc, #52]	; (1dba4 <ull_conn_lll_ack_enqueue+0x50>)
   1db6e:	490e      	ldr	r1, [pc, #56]	; (1dba8 <ull_conn_lll_ack_enqueue+0x54>)
   1db70:	480e      	ldr	r0, [pc, #56]	; (1dbac <ull_conn_lll_ack_enqueue+0x58>)
   1db72:	f240 7376 	movw	r3, #1910	; 0x776
   1db76:	f007 fb21 	bl	251bc <printk>
   1db7a:	4040      	eors	r0, r0
   1db7c:	f380 8811 	msr	BASEPRI, r0
   1db80:	f04f 0003 	mov.w	r0, #3
   1db84:	df02      	svc	2
	lll_tx->handle = handle;
   1db86:	2300      	movs	r3, #0
   1db88:	801b      	strh	r3, [r3, #0]
   1db8a:	deff      	udf	#255	; 0xff
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1db8c:	4615      	mov	r5, r2
   1db8e:	f815 4b04 	ldrb.w	r4, [r5], #4
   1db92:	fb14 f406 	smulbb	r4, r4, r6
   1db96:	192e      	adds	r6, r5, r4
   1db98:	5328      	strh	r0, [r5, r4]
	lll_tx->node = tx;
   1db9a:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
   1db9c:	70d3      	strb	r3, [r2, #3]
}
   1db9e:	bd70      	pop	{r4, r5, r6, pc}
   1dba0:	20000a4c 	.word	0x20000a4c
   1dba4:	00034356 	.word	0x00034356
   1dba8:	000343f2 	.word	0x000343f2
   1dbac:	0002f8b5 	.word	0x0002f8b5

0001dbb0 <ull_conn_tx_ack>:
{
   1dbb0:	b570      	push	{r4, r5, r6, lr}
	LL_ASSERT(pdu_tx->len);
   1dbb2:	7953      	ldrb	r3, [r2, #5]
{
   1dbb4:	4605      	mov	r5, r0
   1dbb6:	460e      	mov	r6, r1
   1dbb8:	4614      	mov	r4, r2
	LL_ASSERT(pdu_tx->len);
   1dbba:	b963      	cbnz	r3, 1dbd6 <ull_conn_tx_ack+0x26>
   1dbbc:	4a2c      	ldr	r2, [pc, #176]	; (1dc70 <ull_conn_tx_ack+0xc0>)
   1dbbe:	492d      	ldr	r1, [pc, #180]	; (1dc74 <ull_conn_tx_ack+0xc4>)
   1dbc0:	482d      	ldr	r0, [pc, #180]	; (1dc78 <ull_conn_tx_ack+0xc8>)
   1dbc2:	f240 7383 	movw	r3, #1923	; 0x783
   1dbc6:	f007 faf9 	bl	251bc <printk>
   1dbca:	4040      	eors	r0, r0
   1dbcc:	f380 8811 	msr	BASEPRI, r0
   1dbd0:	f04f 0003 	mov.w	r0, #3
   1dbd4:	df02      	svc	2
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   1dbd6:	7923      	ldrb	r3, [r4, #4]
   1dbd8:	f003 0203 	and.w	r2, r3, #3
   1dbdc:	2a03      	cmp	r2, #3
   1dbde:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1dbe2:	d13e      	bne.n	1dc62 <ull_conn_tx_ack+0xb2>
		if (handle != LLL_HANDLE_INVALID) {
   1dbe4:	4295      	cmp	r5, r2
   1dbe6:	d008      	beq.n	1dbfa <ull_conn_tx_ack+0x4a>
			struct ll_conn *conn = ll_conn_get(handle);
   1dbe8:	4628      	mov	r0, r5
   1dbea:	f7ff f851 	bl	1cc90 <ll_conn_get>
	switch (pdu_tx->llctrl.opcode) {
   1dbee:	79e3      	ldrb	r3, [r4, #7]
   1dbf0:	2b07      	cmp	r3, #7
   1dbf2:	d00f      	beq.n	1dc14 <ull_conn_tx_ack+0x64>
   1dbf4:	d80a      	bhi.n	1dc0c <ull_conn_tx_ack+0x5c>
   1dbf6:	2b02      	cmp	r3, #2
   1dbf8:	d013      	beq.n	1dc22 <ull_conn_tx_ack+0x72>
		if (link->next == (void *)tx) {
   1dbfa:	6833      	ldr	r3, [r6, #0]
   1dbfc:	42a3      	cmp	r3, r4
   1dbfe:	d11c      	bne.n	1dc3a <ull_conn_tx_ack+0x8a>
			mem_release(tx, &mem_conn_tx_ctrl.free);
   1dc00:	4620      	mov	r0, r4
   1dc02:	491e      	ldr	r1, [pc, #120]	; (1dc7c <ull_conn_tx_ack+0xcc>)
}
   1dc04:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			mem_release(tx, &mem_conn_tx_ctrl.free);
   1dc08:	f00c be1b 	b.w	2a842 <mem_release>
	switch (pdu_tx->llctrl.opcode) {
   1dc0c:	2b09      	cmp	r3, #9
   1dc0e:	d001      	beq.n	1dc14 <ull_conn_tx_ack+0x64>
   1dc10:	2b13      	cmp	r3, #19
   1dc12:	d1f2      	bne.n	1dbfa <ull_conn_tx_ack+0x4a>
		conn->common.txn_lock = 0U;
   1dc14:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
   1dc18:	f36f 0341 	bfc	r3, #1, #1
   1dc1c:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
		break;
   1dc20:	e7eb      	b.n	1dbfa <ull_conn_tx_ack+0x4a>
		if (pdu_tx->llctrl.terminate_ind.error_code ==
   1dc22:	7a23      	ldrb	r3, [r4, #8]
			conn->llcp_terminate.reason_final =
   1dc24:	2b13      	cmp	r3, #19
   1dc26:	bf08      	it	eq
   1dc28:	2316      	moveq	r3, #22
   1dc2a:	f880 30d3 	strb.w	r3, [r0, #211]	; 0xd3
		conn->llcp_terminate.ack--;
   1dc2e:	f890 30d1 	ldrb.w	r3, [r0, #209]	; 0xd1
   1dc32:	3b01      	subs	r3, #1
   1dc34:	f880 30d1 	strb.w	r3, [r0, #209]	; 0xd1
	break;
   1dc38:	e7df      	b.n	1dbfa <ull_conn_tx_ack+0x4a>
		LL_ASSERT(!link->next);
   1dc3a:	b163      	cbz	r3, 1dc56 <ull_conn_tx_ack+0xa6>
   1dc3c:	4a0c      	ldr	r2, [pc, #48]	; (1dc70 <ull_conn_tx_ack+0xc0>)
   1dc3e:	4910      	ldr	r1, [pc, #64]	; (1dc80 <ull_conn_tx_ack+0xd0>)
   1dc40:	480d      	ldr	r0, [pc, #52]	; (1dc78 <ull_conn_tx_ack+0xc8>)
   1dc42:	f44f 63f4 	mov.w	r3, #1952	; 0x7a0
   1dc46:	f007 fab9 	bl	251bc <printk>
   1dc4a:	4040      	eors	r0, r0
   1dc4c:	f380 8811 	msr	BASEPRI, r0
   1dc50:	f04f 0003 	mov.w	r0, #3
   1dc54:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   1dc56:	4621      	mov	r1, r4
   1dc58:	4628      	mov	r0, r5
}
   1dc5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_tx_ack_put(handle, tx);
   1dc5e:	f7fd bd7f 	b.w	1b760 <ll_tx_ack_put>
	} else if (handle == LLL_HANDLE_INVALID) {
   1dc62:	4295      	cmp	r5, r2
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   1dc64:	bf04      	itt	eq
   1dc66:	f36f 0301 	bfceq	r3, #0, #2
   1dc6a:	7123      	strbeq	r3, [r4, #4]
   1dc6c:	e7f3      	b.n	1dc56 <ull_conn_tx_ack+0xa6>
   1dc6e:	bf00      	nop
   1dc70:	00034356 	.word	0x00034356
   1dc74:	000344b9 	.word	0x000344b9
   1dc78:	0002f8b5 	.word	0x0002f8b5
   1dc7c:	200032cc 	.word	0x200032cc
   1dc80:	000344c5 	.word	0x000344c5

0001dc84 <ticker_update_latency_cancel_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void ticker_update_latency_cancel_op_cb(uint32_t ticker_status,
					       void *param)
{
   1dc84:	b510      	push	{r4, lr}
   1dc86:	460c      	mov	r4, r1
	struct ll_conn *conn = param;

	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   1dc88:	b160      	cbz	r0, 1dca4 <ticker_update_latency_cancel_op_cb+0x20>
   1dc8a:	4a0a      	ldr	r2, [pc, #40]	; (1dcb4 <ticker_update_latency_cancel_op_cb+0x30>)
   1dc8c:	490a      	ldr	r1, [pc, #40]	; (1dcb8 <ticker_update_latency_cancel_op_cb+0x34>)
   1dc8e:	480b      	ldr	r0, [pc, #44]	; (1dcbc <ticker_update_latency_cancel_op_cb+0x38>)
   1dc90:	f240 23af 	movw	r3, #687	; 0x2af
   1dc94:	f007 fa92 	bl	251bc <printk>
   1dc98:	4040      	eors	r0, r0
   1dc9a:	f380 8811 	msr	BASEPRI, r0
   1dc9e:	f04f 0003 	mov.w	r0, #3
   1dca2:	df02      	svc	2

	conn->periph.latency_cancel = 0U;
   1dca4:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
   1dca8:	f36f 0382 	bfc	r3, #2, #1
   1dcac:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
   1dcb0:	bd10      	pop	{r4, pc}
   1dcb2:	bf00      	nop
   1dcb4:	000344e2 	.word	0x000344e2
   1dcb8:	00034528 	.word	0x00034528
   1dcbc:	0002f8b5 	.word	0x0002f8b5

0001dcc0 <ticker_op_cb>:
{
   1dcc0:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1dcc2:	b160      	cbz	r0, 1dcde <ticker_op_cb+0x1e>
   1dcc4:	4a06      	ldr	r2, [pc, #24]	; (1dce0 <ticker_op_cb+0x20>)
   1dcc6:	4907      	ldr	r1, [pc, #28]	; (1dce4 <ticker_op_cb+0x24>)
   1dcc8:	4807      	ldr	r0, [pc, #28]	; (1dce8 <ticker_op_cb+0x28>)
   1dcca:	f240 23a7 	movw	r3, #679	; 0x2a7
   1dcce:	f007 fa75 	bl	251bc <printk>
   1dcd2:	4040      	eors	r0, r0
   1dcd4:	f380 8811 	msr	BASEPRI, r0
   1dcd8:	f04f 0003 	mov.w	r0, #3
   1dcdc:	df02      	svc	2
}
   1dcde:	bd08      	pop	{r3, pc}
   1dce0:	000344e2 	.word	0x000344e2
   1dce4:	0003452f 	.word	0x0003452f
   1dce8:	0002f8b5 	.word	0x0002f8b5

0001dcec <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   1dcec:	2801      	cmp	r0, #1
{
   1dcee:	b510      	push	{r4, lr}
   1dcf0:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   1dcf2:	d110      	bne.n	1dd16 <ticker_op_stop_adv_cb+0x2a>
   1dcf4:	f7fd fdbc 	bl	1b870 <ull_disable_mark_get>
   1dcf8:	4284      	cmp	r4, r0
   1dcfa:	d00c      	beq.n	1dd16 <ticker_op_stop_adv_cb+0x2a>
   1dcfc:	4a06      	ldr	r2, [pc, #24]	; (1dd18 <ticker_op_stop_adv_cb+0x2c>)
   1dcfe:	4907      	ldr	r1, [pc, #28]	; (1dd1c <ticker_op_stop_adv_cb+0x30>)
   1dd00:	4807      	ldr	r0, [pc, #28]	; (1dd20 <ticker_op_stop_adv_cb+0x34>)
   1dd02:	f240 239f 	movw	r3, #671	; 0x29f
   1dd06:	f007 fa59 	bl	251bc <printk>
   1dd0a:	4040      	eors	r0, r0
   1dd0c:	f380 8811 	msr	BASEPRI, r0
   1dd10:	f04f 0003 	mov.w	r0, #3
   1dd14:	df02      	svc	2
}
   1dd16:	bd10      	pop	{r4, pc}
   1dd18:	000344e2 	.word	0x000344e2
   1dd1c:	0003453b 	.word	0x0003453b
   1dd20:	0002f8b5 	.word	0x0002f8b5

0001dd24 <ull_periph_ticker_cb>:
{
   1dd24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1dd28:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1dd2a:	f89d 9020 	ldrb.w	r9, [sp, #32]
   1dd2e:	4690      	mov	r8, r2
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   1dd30:	8d22      	ldrh	r2, [r4, #40]	; 0x28
{
   1dd32:	461e      	mov	r6, r3
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   1dd34:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1dd38:	429a      	cmp	r2, r3
{
   1dd3a:	4607      	mov	r7, r0
	if (unlikely(conn->lll.handle == 0xFFFF)) {
   1dd3c:	d03f      	beq.n	1ddbe <ull_periph_ticker_cb+0x9a>
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   1dd3e:	4601      	mov	r1, r0
   1dd40:	4632      	mov	r2, r6
   1dd42:	4620      	mov	r0, r4
   1dd44:	f7e2 fe38 	bl	9b8 <ull_conn_llcp>
		if (ret) {
   1dd48:	2800      	cmp	r0, #0
   1dd4a:	d138      	bne.n	1ddbe <ull_periph_ticker_cb+0x9a>
	return ++hdr->ref;
   1dd4c:	7825      	ldrb	r5, [r4, #0]
   1dd4e:	3501      	adds	r5, #1
   1dd50:	b2ed      	uxtb	r5, r5
   1dd52:	7025      	strb	r5, [r4, #0]
	LL_ASSERT(ref);
   1dd54:	b965      	cbnz	r5, 1dd70 <ull_periph_ticker_cb+0x4c>
   1dd56:	4a1b      	ldr	r2, [pc, #108]	; (1ddc4 <ull_periph_ticker_cb+0xa0>)
   1dd58:	491b      	ldr	r1, [pc, #108]	; (1ddc8 <ull_periph_ticker_cb+0xa4>)
   1dd5a:	481c      	ldr	r0, [pc, #112]	; (1ddcc <ull_periph_ticker_cb+0xa8>)
   1dd5c:	f240 231d 	movw	r3, #541	; 0x21d
   1dd60:	f007 fa2c 	bl	251bc <printk>
   1dd64:	4040      	eors	r0, r0
   1dd66:	f380 8811 	msr	BASEPRI, r0
   1dd6a:	f04f 0003 	mov.w	r0, #3
   1dd6e:	df02      	svc	2
	p.ticks_at_expire = ticks_at_expire;
   1dd70:	4d17      	ldr	r5, [pc, #92]	; (1ddd0 <ull_periph_ticker_cb+0xac>)
	p.param = &conn->lll;
   1dd72:	f104 031c 	add.w	r3, r4, #28
   1dd76:	60eb      	str	r3, [r5, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1dd78:	2200      	movs	r2, #0
	mfy.param = &p;
   1dd7a:	4b16      	ldr	r3, [pc, #88]	; (1ddd4 <ull_periph_ticker_cb+0xb0>)
	p.lazy = lazy;
   1dd7c:	812e      	strh	r6, [r5, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1dd7e:	4611      	mov	r1, r2
   1dd80:	2001      	movs	r0, #1
	p.remainder = remainder;
   1dd82:	e9c5 7800 	strd	r7, r8, [r5]
	p.force = force;
   1dd86:	f885 900a 	strb.w	r9, [r5, #10]
	mfy.param = &p;
   1dd8a:	609d      	str	r5, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1dd8c:	f7fb fb66 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!err);
   1dd90:	b160      	cbz	r0, 1ddac <ull_periph_ticker_cb+0x88>
   1dd92:	4a0c      	ldr	r2, [pc, #48]	; (1ddc4 <ull_periph_ticker_cb+0xa0>)
   1dd94:	4910      	ldr	r1, [pc, #64]	; (1ddd8 <ull_periph_ticker_cb+0xb4>)
   1dd96:	480d      	ldr	r0, [pc, #52]	; (1ddcc <ull_periph_ticker_cb+0xa8>)
   1dd98:	f240 232a 	movw	r3, #554	; 0x22a
   1dd9c:	f007 fa0e 	bl	251bc <printk>
   1dda0:	4040      	eors	r0, r0
   1dda2:	f380 8811 	msr	BASEPRI, r0
   1dda6:	f04f 0003 	mov.w	r0, #3
   1ddaa:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   1ddac:	20ff      	movs	r0, #255	; 0xff
   1ddae:	f7ff fc8b 	bl	1d6c8 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   1ddb2:	4620      	mov	r0, r4
   1ddb4:	21ff      	movs	r1, #255	; 0xff
}
   1ddb6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   1ddba:	f7ff be2f 	b.w	1da1c <ull_conn_tx_lll_enqueue>
}
   1ddbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1ddc2:	bf00      	nop
   1ddc4:	000344e2 	.word	0x000344e2
   1ddc8:	00034279 	.word	0x00034279
   1ddcc:	0002f8b5 	.word	0x0002f8b5
   1ddd0:	200033c4 	.word	0x200033c4
   1ddd4:	20000af4 	.word	0x20000af4
   1ddd8:	0003404c 	.word	0x0003404c

0001dddc <ull_periph_latency_cancel>:
{
   1dddc:	b500      	push	{lr}
	if (conn->lll.latency_event && !conn->periph.latency_cancel) {
   1ddde:	8e03      	ldrh	r3, [r0, #48]	; 0x30
{
   1dde0:	b089      	sub	sp, #36	; 0x24
	if (conn->lll.latency_event && !conn->periph.latency_cancel) {
   1dde2:	b33b      	cbz	r3, 1de34 <ull_periph_latency_cancel+0x58>
   1dde4:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
   1dde8:	f012 0304 	ands.w	r3, r2, #4
   1ddec:	d122      	bne.n	1de34 <ull_periph_latency_cancel+0x58>
		conn->periph.latency_cancel = 1U;
   1ddee:	f042 0204 	orr.w	r2, r2, #4
   1ddf2:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ddf6:	1d4a      	adds	r2, r1, #5
   1ddf8:	4910      	ldr	r1, [pc, #64]	; (1de3c <ull_periph_latency_cancel+0x60>)
   1ddfa:	9006      	str	r0, [sp, #24]
   1ddfc:	e9cd 3104 	strd	r3, r1, [sp, #16]
   1de00:	2101      	movs	r1, #1
   1de02:	e9cd 3102 	strd	r3, r1, [sp, #8]
   1de06:	e9cd 3300 	strd	r3, r3, [sp]
   1de0a:	4618      	mov	r0, r3
   1de0c:	b2d2      	uxtb	r2, r2
   1de0e:	2103      	movs	r1, #3
   1de10:	f00d f80a 	bl	2ae28 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   1de14:	f030 0302 	bics.w	r3, r0, #2
   1de18:	d00c      	beq.n	1de34 <ull_periph_latency_cancel+0x58>
   1de1a:	4a09      	ldr	r2, [pc, #36]	; (1de40 <ull_periph_latency_cancel+0x64>)
   1de1c:	4909      	ldr	r1, [pc, #36]	; (1de44 <ull_periph_latency_cancel+0x68>)
   1de1e:	480a      	ldr	r0, [pc, #40]	; (1de48 <ull_periph_latency_cancel+0x6c>)
   1de20:	f240 13e3 	movw	r3, #483	; 0x1e3
   1de24:	f007 f9ca 	bl	251bc <printk>
   1de28:	4040      	eors	r0, r0
   1de2a:	f380 8811 	msr	BASEPRI, r0
   1de2e:	f04f 0003 	mov.w	r0, #3
   1de32:	df02      	svc	2
}
   1de34:	b009      	add	sp, #36	; 0x24
   1de36:	f85d fb04 	ldr.w	pc, [sp], #4
   1de3a:	bf00      	nop
   1de3c:	0001dc85 	.word	0x0001dc85
   1de40:	000344e2 	.word	0x000344e2
   1de44:	00034433 	.word	0x00034433
   1de48:	0002f8b5 	.word	0x0002f8b5

0001de4c <ll_fal_clear>:
{
	return FAL_SIZE;
}

uint8_t ll_fal_clear(void)
{
   1de4c:	b508      	push	{r3, lr}
#if defined(CONFIG_BT_BROADCASTER)
	if (ull_adv_filter_pol_get(0)) {
   1de4e:	2000      	movs	r0, #0
   1de50:	f00d f923 	bl	2b09a <ull_adv_filter_pol_get>
   1de54:	b108      	cbz	r0, 1de5a <ll_fal_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1de56:	200c      	movs	r0, #12
#else
	filter_clear(&fal_filter);
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
   1de58:	bd08      	pop	{r3, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   1de5a:	f00d fa1b 	bl	2b294 <ull_scan_filter_pol_get>
   1de5e:	f010 0001 	ands.w	r0, r0, #1
   1de62:	d1f8      	bne.n	1de56 <ll_fal_clear+0xa>
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
   1de64:	4b01      	ldr	r3, [pc, #4]	; (1de6c <ll_fal_clear+0x20>)
   1de66:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
   1de68:	7058      	strb	r0, [r3, #1]
	return 0;
   1de6a:	e7f5      	b.n	1de58 <ll_fal_clear+0xc>
   1de6c:	20003aff 	.word	0x20003aff

0001de70 <ll_fal_add>:
{
   1de70:	b570      	push	{r4, r5, r6, lr}
   1de72:	4604      	mov	r4, r0
	if (ull_adv_filter_pol_get(0)) {
   1de74:	2000      	movs	r0, #0
   1de76:	f00d f910 	bl	2b09a <ull_adv_filter_pol_get>
   1de7a:	b108      	cbz	r0, 1de80 <ll_fal_add+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1de7c:	200c      	movs	r0, #12
}
   1de7e:	bd70      	pop	{r4, r5, r6, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   1de80:	f00d fa08 	bl	2b294 <ull_scan_filter_pol_get>
   1de84:	f010 0001 	ands.w	r0, r0, #1
   1de88:	d1f8      	bne.n	1de7c <ll_fal_add+0xc>
	if (addr->type == ADDR_TYPE_ANON) {
   1de8a:	7823      	ldrb	r3, [r4, #0]
   1de8c:	2bff      	cmp	r3, #255	; 0xff
   1de8e:	d0f6      	beq.n	1de7e <ll_fal_add+0xe>
	return filter_add(&fal_filter, addr->type, addr->a.val);
   1de90:	1c61      	adds	r1, r4, #1
	if (filter->enable_bitmask == LLL_FILTER_BITMASK_ALL) {
   1de92:	4c0f      	ldr	r4, [pc, #60]	; (1ded0 <ll_fal_add+0x60>)
   1de94:	7822      	ldrb	r2, [r4, #0]
   1de96:	2aff      	cmp	r2, #255	; 0xff
   1de98:	d018      	beq.n	1decc <ll_fal_add+0x5c>
	     (filter->enable_bitmask & BIT(index));
   1de9a:	fa22 f500 	lsr.w	r5, r2, r0
	for (index = 0;
   1de9e:	f015 0501 	ands.w	r5, r5, #1
   1dea2:	d111      	bne.n	1dec8 <ll_fal_add+0x58>
	filter->enable_bitmask |= BIT(index);
   1dea4:	2601      	movs	r6, #1
   1dea6:	4086      	lsls	r6, r0
   1dea8:	4332      	orrs	r2, r6
   1deaa:	7022      	strb	r2, [r4, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
   1deac:	f003 0301 	and.w	r3, r3, #1
   1deb0:	7862      	ldrb	r2, [r4, #1]
   1deb2:	4083      	lsls	r3, r0
   1deb4:	4313      	orrs	r3, r2
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   1deb6:	2206      	movs	r2, #6
   1deb8:	fb02 4000 	mla	r0, r2, r0, r4
   1debc:	3002      	adds	r0, #2
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
   1debe:	7063      	strb	r3, [r4, #1]
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   1dec0:	f009 fcd6 	bl	27870 <memcpy>
	return filter_add(&fal_filter, addr->type, addr->a.val);
   1dec4:	b2e8      	uxtb	r0, r5
   1dec6:	e7da      	b.n	1de7e <ll_fal_add+0xe>
	     index++) {
   1dec8:	3001      	adds	r0, #1
   1deca:	e7e6      	b.n	1de9a <ll_fal_add+0x2a>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   1decc:	2507      	movs	r5, #7
   1dece:	e7f9      	b.n	1dec4 <ll_fal_add+0x54>
   1ded0:	20003aff 	.word	0x20003aff

0001ded4 <ll_fal_remove>:
{
   1ded4:	b538      	push	{r3, r4, r5, lr}
   1ded6:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
   1ded8:	2000      	movs	r0, #0
   1deda:	f00d f8de 	bl	2b09a <ull_adv_filter_pol_get>
   1dede:	b108      	cbz	r0, 1dee4 <ll_fal_remove+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1dee0:	200c      	movs	r0, #12
}
   1dee2:	bd38      	pop	{r3, r4, r5, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   1dee4:	f00d f9d6 	bl	2b294 <ull_scan_filter_pol_get>
   1dee8:	f010 0401 	ands.w	r4, r0, #1
   1deec:	d1f8      	bne.n	1dee0 <ll_fal_remove+0xc>
	if (addr->type == ADDR_TYPE_ANON) {
   1deee:	7829      	ldrb	r1, [r5, #0]
   1def0:	29ff      	cmp	r1, #255	; 0xff
   1def2:	d017      	beq.n	1df24 <ll_fal_remove+0x50>
	return filter_remove(&fal_filter, addr->type, addr->a.val);
   1def4:	1c6a      	adds	r2, r5, #1
	if (!filter->enable_bitmask) {
   1def6:	4d0c      	ldr	r5, [pc, #48]	; (1df28 <ll_fal_remove+0x54>)
   1def8:	782b      	ldrb	r3, [r5, #0]
   1defa:	b913      	cbnz	r3, 1df02 <ll_fal_remove+0x2e>
		return BT_HCI_ERR_INVALID_PARAM;
   1defc:	2412      	movs	r4, #18
	return filter_remove(&fal_filter, addr->type, addr->a.val);
   1defe:	b2e0      	uxtb	r0, r4
   1df00:	e7ef      	b.n	1dee2 <ll_fal_remove+0xe>
   1df02:	4628      	mov	r0, r5
   1df04:	f00d fb41 	bl	2b58a <filter_find.part.0>
	if (index == FILTER_IDX_NONE) {
   1df08:	28ff      	cmp	r0, #255	; 0xff
   1df0a:	d0f7      	beq.n	1defc <ll_fal_remove+0x28>
	filter->enable_bitmask &= ~BIT(index);
   1df0c:	2301      	movs	r3, #1
   1df0e:	fa03 f000 	lsl.w	r0, r3, r0
   1df12:	782b      	ldrb	r3, [r5, #0]
   1df14:	ea23 0300 	bic.w	r3, r3, r0
   1df18:	702b      	strb	r3, [r5, #0]
	filter->addr_type_bitmask &= ~BIT(index);
   1df1a:	786b      	ldrb	r3, [r5, #1]
   1df1c:	ea23 0000 	bic.w	r0, r3, r0
   1df20:	7068      	strb	r0, [r5, #1]
	return 0;
   1df22:	e7ec      	b.n	1defe <ll_fal_remove+0x2a>
		return 0;
   1df24:	4620      	mov	r0, r4
   1df26:	e7dc      	b.n	1dee2 <ll_fal_remove+0xe>
   1df28:	20003aff 	.word	0x20003aff

0001df2c <ull_filter_reset>:
	filter->enable_bitmask = 0;
   1df2c:	4b02      	ldr	r3, [pc, #8]	; (1df38 <ull_filter_reset+0xc>)
   1df2e:	2200      	movs	r2, #0
   1df30:	701a      	strb	r2, [r3, #0]
	filter->addr_type_bitmask = 0;
   1df32:	705a      	strb	r2, [r3, #1]
}
   1df34:	4770      	bx	lr
   1df36:	bf00      	nop
   1df38:	20003aff 	.word	0x20003aff

0001df3c <ull_filter_lll_get>:
{
   1df3c:	b508      	push	{r3, lr}
	LL_ASSERT(filter);
   1df3e:	b960      	cbnz	r0, 1df5a <ull_filter_lll_get+0x1e>
   1df40:	4a07      	ldr	r2, [pc, #28]	; (1df60 <ull_filter_lll_get+0x24>)
   1df42:	4908      	ldr	r1, [pc, #32]	; (1df64 <ull_filter_lll_get+0x28>)
   1df44:	4808      	ldr	r0, [pc, #32]	; (1df68 <ull_filter_lll_get+0x2c>)
   1df46:	f240 2392 	movw	r3, #658	; 0x292
   1df4a:	f007 f937 	bl	251bc <printk>
   1df4e:	4040      	eors	r0, r0
   1df50:	f380 8811 	msr	BASEPRI, r0
   1df54:	f04f 0003 	mov.w	r0, #3
   1df58:	df02      	svc	2
}
   1df5a:	4804      	ldr	r0, [pc, #16]	; (1df6c <ull_filter_lll_get+0x30>)
   1df5c:	bd08      	pop	{r3, pc}
   1df5e:	bf00      	nop
   1df60:	0003458e 	.word	0x0003458e
   1df64:	000345dc 	.word	0x000345dc
   1df68:	0002f8b5 	.word	0x0002f8b5
   1df6c:	20003aff 	.word	0x20003aff

0001df70 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(const void *arg)
{
   1df70:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	lll_prof_enter_ull_high();

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   1df72:	4b08      	ldr	r3, [pc, #32]	; (1df94 <rtc0_nrf5_isr+0x24>)
   1df74:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   1df78:	b122      	cbz	r2, 1df84 <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   1df7a:	2000      	movs	r0, #0
   1df7c:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
   1df80:	f7fb ff84 	bl	19e8c <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   1df84:	2001      	movs	r0, #1
   1df86:	f7fb fab9 	bl	194fc <mayfly_run>

	lll_prof_exit_ull_low();
#endif

	DEBUG_TICKER_ISR(0);
}
   1df8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   1df8e:	2002      	movs	r0, #2
   1df90:	f7fb bab4 	b.w	194fc <mayfly_run>
   1df94:	4000b000 	.word	0x4000b000

0001df98 <ticker_stop_op_cb>:
static uint8_t preempt_stop_ack;
static uint8_t preempt_req;
static uint8_t volatile preempt_ack;

static void ticker_stop_op_cb(uint32_t status, void *param)
{
   1df98:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	ARG_UNUSED(status);

	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
   1df9a:	4b0d      	ldr	r3, [pc, #52]	; (1dfd0 <ticker_stop_op_cb+0x38>)
   1df9c:	4c0d      	ldr	r4, [pc, #52]	; (1dfd4 <ticker_stop_op_cb+0x3c>)
   1df9e:	781b      	ldrb	r3, [r3, #0]
   1dfa0:	7822      	ldrb	r2, [r4, #0]
   1dfa2:	429a      	cmp	r2, r3
   1dfa4:	d10c      	bne.n	1dfc0 <ticker_stop_op_cb+0x28>
   1dfa6:	4a0c      	ldr	r2, [pc, #48]	; (1dfd8 <ticker_stop_op_cb+0x40>)
   1dfa8:	490c      	ldr	r1, [pc, #48]	; (1dfdc <ticker_stop_op_cb+0x44>)
   1dfaa:	480d      	ldr	r0, [pc, #52]	; (1dfe0 <ticker_stop_op_cb+0x48>)
   1dfac:	f240 3301 	movw	r3, #769	; 0x301
   1dfb0:	f007 f904 	bl	251bc <printk>
   1dfb4:	4040      	eors	r0, r0
   1dfb6:	f380 8811 	msr	BASEPRI, r0
   1dfba:	f04f 0003 	mov.w	r0, #3
   1dfbe:	df02      	svc	2
	preempt_stop_ack++;
   1dfc0:	7823      	ldrb	r3, [r4, #0]
   1dfc2:	3301      	adds	r3, #1
   1dfc4:	7023      	strb	r3, [r4, #0]

	preempt_req = preempt_ack;
   1dfc6:	4b07      	ldr	r3, [pc, #28]	; (1dfe4 <ticker_stop_op_cb+0x4c>)
   1dfc8:	781a      	ldrb	r2, [r3, #0]
   1dfca:	4b07      	ldr	r3, [pc, #28]	; (1dfe8 <ticker_stop_op_cb+0x50>)
   1dfcc:	701a      	strb	r2, [r3, #0]
}
   1dfce:	bd10      	pop	{r4, pc}
   1dfd0:	20003b36 	.word	0x20003b36
   1dfd4:	20003b35 	.word	0x20003b35
   1dfd8:	000345e3 	.word	0x000345e3
   1dfdc:	00034629 	.word	0x00034629
   1dfe0:	0002f8b5 	.word	0x0002f8b5
   1dfe4:	20003b31 	.word	0x20003b31
   1dfe8:	20003b32 	.word	0x20003b32

0001dfec <ticker_start_op_cb>:

static void ticker_start_op_cb(uint32_t status, void *param)
{
   1dfec:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1dfee:	b160      	cbz	r0, 1e00a <ticker_start_op_cb+0x1e>
   1dff0:	4a1c      	ldr	r2, [pc, #112]	; (1e064 <ticker_start_op_cb+0x78>)
   1dff2:	491d      	ldr	r1, [pc, #116]	; (1e068 <ticker_start_op_cb+0x7c>)
   1dff4:	481d      	ldr	r0, [pc, #116]	; (1e06c <ticker_start_op_cb+0x80>)
   1dff6:	f240 330a 	movw	r3, #778	; 0x30a
   1dffa:	f007 f8df 	bl	251bc <printk>
   1dffe:	4040      	eors	r0, r0
   1e000:	f380 8811 	msr	BASEPRI, r0
   1e004:	f04f 0003 	mov.w	r0, #3
   1e008:	df02      	svc	2

	LL_ASSERT(preempt_start_req != preempt_start_ack);
   1e00a:	4b19      	ldr	r3, [pc, #100]	; (1e070 <ticker_start_op_cb+0x84>)
   1e00c:	4c19      	ldr	r4, [pc, #100]	; (1e074 <ticker_start_op_cb+0x88>)
   1e00e:	781b      	ldrb	r3, [r3, #0]
   1e010:	7822      	ldrb	r2, [r4, #0]
   1e012:	429a      	cmp	r2, r3
   1e014:	d10c      	bne.n	1e030 <ticker_start_op_cb+0x44>
   1e016:	4a13      	ldr	r2, [pc, #76]	; (1e064 <ticker_start_op_cb+0x78>)
   1e018:	4917      	ldr	r1, [pc, #92]	; (1e078 <ticker_start_op_cb+0x8c>)
   1e01a:	4814      	ldr	r0, [pc, #80]	; (1e06c <ticker_start_op_cb+0x80>)
   1e01c:	f44f 7343 	mov.w	r3, #780	; 0x30c
   1e020:	f007 f8cc 	bl	251bc <printk>
   1e024:	4040      	eors	r0, r0
   1e026:	f380 8811 	msr	BASEPRI, r0
   1e02a:	f04f 0003 	mov.w	r0, #3
   1e02e:	df02      	svc	2
	preempt_start_ack++;
   1e030:	7823      	ldrb	r3, [r4, #0]
   1e032:	3301      	adds	r3, #1
   1e034:	7023      	strb	r3, [r4, #0]

	LL_ASSERT(preempt_req == preempt_ack);
   1e036:	4b11      	ldr	r3, [pc, #68]	; (1e07c <ticker_start_op_cb+0x90>)
   1e038:	4c11      	ldr	r4, [pc, #68]	; (1e080 <ticker_start_op_cb+0x94>)
   1e03a:	781b      	ldrb	r3, [r3, #0]
   1e03c:	7822      	ldrb	r2, [r4, #0]
   1e03e:	429a      	cmp	r2, r3
   1e040:	d00c      	beq.n	1e05c <ticker_start_op_cb+0x70>
   1e042:	4a08      	ldr	r2, [pc, #32]	; (1e064 <ticker_start_op_cb+0x78>)
   1e044:	490f      	ldr	r1, [pc, #60]	; (1e084 <ticker_start_op_cb+0x98>)
   1e046:	4809      	ldr	r0, [pc, #36]	; (1e06c <ticker_start_op_cb+0x80>)
   1e048:	f240 330f 	movw	r3, #783	; 0x30f
   1e04c:	f007 f8b6 	bl	251bc <printk>
   1e050:	4040      	eors	r0, r0
   1e052:	f380 8811 	msr	BASEPRI, r0
   1e056:	f04f 0003 	mov.w	r0, #3
   1e05a:	df02      	svc	2
	preempt_req++;
   1e05c:	7823      	ldrb	r3, [r4, #0]
   1e05e:	3301      	adds	r3, #1
   1e060:	7023      	strb	r3, [r4, #0]
}
   1e062:	bd10      	pop	{r4, pc}
   1e064:	000345e3 	.word	0x000345e3
   1e068:	0003452f 	.word	0x0003452f
   1e06c:	0002f8b5 	.word	0x0002f8b5
   1e070:	20003b34 	.word	0x20003b34
   1e074:	20003b33 	.word	0x20003b33
   1e078:	0003464e 	.word	0x0003464e
   1e07c:	20003b31 	.word	0x20003b31
   1e080:	20003b32 	.word	0x20003b32
   1e084:	00034675 	.word	0x00034675

0001e088 <preempt_ticker_cb>:
}

static void preempt_ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			      uint32_t remainder, uint16_t lazy, uint8_t force,
			      void *param)
{
   1e088:	b510      	push	{r4, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	uint32_t ret;

	LL_ASSERT(preempt_ack != preempt_req);
   1e08a:	4a17      	ldr	r2, [pc, #92]	; (1e0e8 <preempt_ticker_cb+0x60>)
   1e08c:	4c17      	ldr	r4, [pc, #92]	; (1e0ec <preempt_ticker_cb+0x64>)
   1e08e:	7812      	ldrb	r2, [r2, #0]
   1e090:	7823      	ldrb	r3, [r4, #0]
   1e092:	429a      	cmp	r2, r3
   1e094:	d10c      	bne.n	1e0b0 <preempt_ticker_cb+0x28>
   1e096:	4a16      	ldr	r2, [pc, #88]	; (1e0f0 <preempt_ticker_cb+0x68>)
   1e098:	4916      	ldr	r1, [pc, #88]	; (1e0f4 <preempt_ticker_cb+0x6c>)
   1e09a:	4817      	ldr	r0, [pc, #92]	; (1e0f8 <preempt_ticker_cb+0x70>)
   1e09c:	f44f 735c 	mov.w	r3, #880	; 0x370
   1e0a0:	f007 f88c 	bl	251bc <printk>
   1e0a4:	4040      	eors	r0, r0
   1e0a6:	f380 8811 	msr	BASEPRI, r0
   1e0aa:	f04f 0003 	mov.w	r0, #3
   1e0ae:	df02      	svc	2
	preempt_ack++;
   1e0b0:	7823      	ldrb	r3, [r4, #0]

	mfy.param = param;
   1e0b2:	9a03      	ldr	r2, [sp, #12]
	preempt_ack++;
   1e0b4:	3301      	adds	r3, #1
   1e0b6:	b2db      	uxtb	r3, r3
   1e0b8:	7023      	strb	r3, [r4, #0]
	mfy.param = param;
   1e0ba:	4b10      	ldr	r3, [pc, #64]	; (1e0fc <preempt_ticker_cb+0x74>)
   1e0bc:	609a      	str	r2, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1e0be:	2200      	movs	r2, #0
   1e0c0:	4611      	mov	r1, r2
   1e0c2:	2001      	movs	r0, #1
   1e0c4:	f7fb f9ca 	bl	1945c <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   1e0c8:	b160      	cbz	r0, 1e0e4 <preempt_ticker_cb+0x5c>
   1e0ca:	4a09      	ldr	r2, [pc, #36]	; (1e0f0 <preempt_ticker_cb+0x68>)
   1e0cc:	490c      	ldr	r1, [pc, #48]	; (1e100 <preempt_ticker_cb+0x78>)
   1e0ce:	480a      	ldr	r0, [pc, #40]	; (1e0f8 <preempt_ticker_cb+0x70>)
   1e0d0:	f240 3376 	movw	r3, #886	; 0x376
   1e0d4:	f007 f872 	bl	251bc <printk>
   1e0d8:	4040      	eors	r0, r0
   1e0da:	f380 8811 	msr	BASEPRI, r0
   1e0de:	f04f 0003 	mov.w	r0, #3
   1e0e2:	df02      	svc	2
}
   1e0e4:	bd10      	pop	{r4, pc}
   1e0e6:	bf00      	nop
   1e0e8:	20003b32 	.word	0x20003b32
   1e0ec:	20003b31 	.word	0x20003b31
   1e0f0:	000345e3 	.word	0x000345e3
   1e0f4:	00034690 	.word	0x00034690
   1e0f8:	0002f8b5 	.word	0x0002f8b5
   1e0fc:	20000b04 	.word	0x20000b04
   1e100:	000340d7 	.word	0x000340d7

0001e104 <preempt_ticker_stop>:
{
   1e104:	b513      	push	{r0, r1, r4, lr}
	if ((preempt_stop_req != preempt_stop_ack) ||
   1e106:	4a17      	ldr	r2, [pc, #92]	; (1e164 <preempt_ticker_stop+0x60>)
   1e108:	4917      	ldr	r1, [pc, #92]	; (1e168 <preempt_ticker_stop+0x64>)
   1e10a:	7813      	ldrb	r3, [r2, #0]
   1e10c:	7809      	ldrb	r1, [r1, #0]
   1e10e:	4299      	cmp	r1, r3
   1e110:	d003      	beq.n	1e11a <preempt_ticker_stop+0x16>
		return TICKER_STATUS_SUCCESS;
   1e112:	2400      	movs	r4, #0
}
   1e114:	4620      	mov	r0, r4
   1e116:	b002      	add	sp, #8
   1e118:	bd10      	pop	{r4, pc}
	    (preempt_req == preempt_ack)) {
   1e11a:	4b14      	ldr	r3, [pc, #80]	; (1e16c <preempt_ticker_stop+0x68>)
   1e11c:	4914      	ldr	r1, [pc, #80]	; (1e170 <preempt_ticker_stop+0x6c>)
   1e11e:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_stop_req != preempt_stop_ack) ||
   1e120:	7809      	ldrb	r1, [r1, #0]
   1e122:	4299      	cmp	r1, r3
   1e124:	d0f5      	beq.n	1e112 <preempt_ticker_stop+0xe>
	preempt_stop_req++;
   1e126:	7813      	ldrb	r3, [r2, #0]
   1e128:	3301      	adds	r3, #1
   1e12a:	b2db      	uxtb	r3, r3
   1e12c:	7013      	strb	r3, [r2, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1e12e:	2200      	movs	r2, #0
   1e130:	4b10      	ldr	r3, [pc, #64]	; (1e174 <preempt_ticker_stop+0x70>)
   1e132:	9200      	str	r2, [sp, #0]
   1e134:	4611      	mov	r1, r2
   1e136:	4610      	mov	r0, r2
   1e138:	f7fb ff54 	bl	19fe4 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1e13c:	4604      	mov	r4, r0
   1e13e:	2800      	cmp	r0, #0
   1e140:	d0e7      	beq.n	1e112 <preempt_ticker_stop+0xe>
   1e142:	2802      	cmp	r0, #2
   1e144:	d0e6      	beq.n	1e114 <preempt_ticker_stop+0x10>
   1e146:	4a0c      	ldr	r2, [pc, #48]	; (1e178 <preempt_ticker_stop+0x74>)
   1e148:	490c      	ldr	r1, [pc, #48]	; (1e17c <preempt_ticker_stop+0x78>)
   1e14a:	480d      	ldr	r0, [pc, #52]	; (1e180 <preempt_ticker_stop+0x7c>)
   1e14c:	f240 3362 	movw	r3, #866	; 0x362
   1e150:	f007 f834 	bl	251bc <printk>
   1e154:	4040      	eors	r0, r0
   1e156:	f380 8811 	msr	BASEPRI, r0
   1e15a:	f04f 0003 	mov.w	r0, #3
   1e15e:	df02      	svc	2
   1e160:	e7d8      	b.n	1e114 <preempt_ticker_stop+0x10>
   1e162:	bf00      	nop
   1e164:	20003b36 	.word	0x20003b36
   1e168:	20003b35 	.word	0x20003b35
   1e16c:	20003b31 	.word	0x20003b31
   1e170:	20003b32 	.word	0x20003b32
   1e174:	0001df99 	.word	0x0001df99
   1e178:	000345e3 	.word	0x000345e3
   1e17c:	000341e5 	.word	0x000341e5
   1e180:	0002f8b5 	.word	0x0002f8b5

0001e184 <preempt_ticker_start>:
	ull = HDR_LLL2ULL(p->param);
   1e184:	68cb      	ldr	r3, [r1, #12]
   1e186:	681b      	ldr	r3, [r3, #0]
{
   1e188:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	preempt_anchor = p->ticks_at_expire;
   1e18c:	f8d1 8000 	ldr.w	r8, [r1]
	preempt_to = MAX(ull->ticks_active_to_start,
   1e190:	68de      	ldr	r6, [r3, #12]
	if ((preempt_start_req != preempt_start_ack) ||
   1e192:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 1e238 <preempt_ticker_start+0xb4>
{
   1e196:	460d      	mov	r5, r1
	preempt_to = MAX(ull->ticks_active_to_start,
   1e198:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   1e19c:	4291      	cmp	r1, r2
   1e19e:	bf2c      	ite	cs
   1e1a0:	ebc6 0601 	rsbcs	r6, r6, r1
   1e1a4:	ebc6 0602 	rsbcc	r6, r6, r2
	if ((preempt_start_req != preempt_start_ack) ||
   1e1a8:	4a24      	ldr	r2, [pc, #144]	; (1e23c <preempt_ticker_start+0xb8>)
   1e1aa:	f899 3000 	ldrb.w	r3, [r9]
   1e1ae:	7812      	ldrb	r2, [r2, #0]
   1e1b0:	429a      	cmp	r2, r3
{
   1e1b2:	b08a      	sub	sp, #40	; 0x28
   1e1b4:	4604      	mov	r4, r0
	ticks_at_preempt_new = preempt_anchor + preempt_to;
   1e1b6:	eb08 0706 	add.w	r7, r8, r6
	if ((preempt_start_req != preempt_start_ack) ||
   1e1ba:	d105      	bne.n	1e1c8 <preempt_ticker_start+0x44>
	    (preempt_req != preempt_ack)) {
   1e1bc:	4b20      	ldr	r3, [pc, #128]	; (1e240 <preempt_ticker_start+0xbc>)
   1e1be:	4a21      	ldr	r2, [pc, #132]	; (1e244 <preempt_ticker_start+0xc0>)
   1e1c0:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_start_req != preempt_start_ack) ||
   1e1c2:	7812      	ldrb	r2, [r2, #0]
   1e1c4:	429a      	cmp	r2, r3
   1e1c6:	d018      	beq.n	1e1fa <preempt_ticker_start+0x76>
		if (!prev || prev->is_aborted ||
   1e1c8:	2c00      	cmp	r4, #0
   1e1ca:	d032      	beq.n	1e232 <preempt_ticker_start+0xae>
   1e1cc:	7f23      	ldrb	r3, [r4, #28]
   1e1ce:	079b      	lsls	r3, r3, #30
   1e1d0:	d42f      	bmi.n	1e232 <preempt_ticker_start+0xae>
		diff = ticks_at_preempt_new - ticks_at_preempt;
   1e1d2:	f8df a074 	ldr.w	sl, [pc, #116]	; 1e248 <preempt_ticker_start+0xc4>
   1e1d6:	f8da 2000 	ldr.w	r2, [sl]
   1e1da:	1aba      	subs	r2, r7, r2
		if (!prev || prev->is_aborted ||
   1e1dc:	f412 0000 	ands.w	r0, r2, #8388608	; 0x800000
   1e1e0:	d024      	beq.n	1e22c <preempt_ticker_start+0xa8>
		preempt_ticker_stop();
   1e1e2:	f7ff ff8f 	bl	1e104 <preempt_ticker_stop>
		prev->is_aborted = 1U;
   1e1e6:	7f23      	ldrb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
   1e1e8:	68e1      	ldr	r1, [r4, #12]
		ticks_at_preempt = ticks_at_preempt_new;
   1e1ea:	f8ca 7000 	str.w	r7, [sl]
		prev->is_aborted = 1U;
   1e1ee:	f043 0302 	orr.w	r3, r3, #2
   1e1f2:	7723      	strb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
   1e1f4:	4620      	mov	r0, r4
   1e1f6:	69a3      	ldr	r3, [r4, #24]
   1e1f8:	4798      	blx	r3
	preempt_start_req++;
   1e1fa:	f899 2000 	ldrb.w	r2, [r9]
	ticks_at_preempt = ticks_at_preempt_new;
   1e1fe:	4b12      	ldr	r3, [pc, #72]	; (1e248 <preempt_ticker_start+0xc4>)
	preempt_start_req++;
   1e200:	3201      	adds	r2, #1
	ticks_at_preempt = ticks_at_preempt_new;
   1e202:	601f      	str	r7, [r3, #0]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1e204:	4b11      	ldr	r3, [pc, #68]	; (1e24c <preempt_ticker_start+0xc8>)
   1e206:	9508      	str	r5, [sp, #32]
	preempt_start_req++;
   1e208:	b2d2      	uxtb	r2, r2
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1e20a:	e9cd 5306 	strd	r5, r3, [sp, #24]
	preempt_start_req++;
   1e20e:	f889 2000 	strb.w	r2, [r9]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1e212:	4b0f      	ldr	r3, [pc, #60]	; (1e250 <preempt_ticker_start+0xcc>)
   1e214:	9305      	str	r3, [sp, #20]
   1e216:	2200      	movs	r2, #0
   1e218:	e9cd 2203 	strd	r2, r2, [sp, #12]
   1e21c:	e9cd 2201 	strd	r2, r2, [sp, #4]
   1e220:	9600      	str	r6, [sp, #0]
   1e222:	4643      	mov	r3, r8
   1e224:	4611      	mov	r1, r2
   1e226:	4610      	mov	r0, r2
   1e228:	f00c fde3 	bl	2adf2 <ticker_start>
}
   1e22c:	b00a      	add	sp, #40	; 0x28
   1e22e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return TICKER_STATUS_SUCCESS;
   1e232:	2000      	movs	r0, #0
   1e234:	e7fa      	b.n	1e22c <preempt_ticker_start+0xa8>
   1e236:	bf00      	nop
   1e238:	20003b34 	.word	0x20003b34
   1e23c:	20003b33 	.word	0x20003b33
   1e240:	20003b31 	.word	0x20003b31
   1e244:	20003b32 	.word	0x20003b32
   1e248:	200033ec 	.word	0x200033ec
   1e24c:	0001dfed 	.word	0x0001dfed
   1e250:	0001e089 	.word	0x0001e089

0001e254 <preempt>:

static void preempt(void *param)
{
   1e254:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_event *next;
	uint8_t idx;
	int err;

	/* No event to abort */
	if (!event.curr.abort_cb || !event.curr.param) {
   1e256:	4c3a      	ldr	r4, [pc, #232]	; (1e340 <preempt+0xec>)
   1e258:	68a3      	ldr	r3, [r4, #8]
{
   1e25a:	b089      	sub	sp, #36	; 0x24
   1e25c:	4605      	mov	r5, r0
	if (!event.curr.abort_cb || !event.curr.param) {
   1e25e:	2b00      	cmp	r3, #0
   1e260:	d034      	beq.n	1e2cc <preempt+0x78>
   1e262:	6823      	ldr	r3, [r4, #0]
   1e264:	2b00      	cmp	r3, #0
   1e266:	d031      	beq.n	1e2cc <preempt+0x78>
		return;
	}

	/* Check if any prepare in pipeline */
	idx = UINT8_MAX;
   1e268:	23ff      	movs	r3, #255	; 0xff
   1e26a:	f88d 300a 	strb.w	r3, [sp, #10]
		return;
	}

	/* Find a prepare that is ready and not a resume */
	while (next && (next->is_aborted || next->is_resume)) {
		next = ull_prepare_dequeue_iter(&idx);
   1e26e:	f10d 000a 	add.w	r0, sp, #10
   1e272:	f7fd fc25 	bl	1bac0 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   1e276:	4601      	mov	r1, r0
   1e278:	b340      	cbz	r0, 1e2cc <preempt+0x78>
   1e27a:	7f06      	ldrb	r6, [r0, #28]
   1e27c:	f016 0603 	ands.w	r6, r6, #3
   1e280:	d1f5      	bne.n	1e26e <preempt+0x1a>
	if (!next) {
		return;
	}

	/* Preemptor not in pipeline */
	if (next != param) {
   1e282:	4285      	cmp	r5, r0
   1e284:	d013      	beq.n	1e2ae <preempt+0x5a>
		uint32_t ret;

		/* Start the preempt timeout */
		ret = preempt_ticker_start(NULL, next);
   1e286:	4630      	mov	r0, r6
   1e288:	f7ff ff7c 	bl	1e184 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1e28c:	f030 0302 	bics.w	r3, r0, #2
   1e290:	d01c      	beq.n	1e2cc <preempt+0x78>
   1e292:	4a2c      	ldr	r2, [pc, #176]	; (1e344 <preempt+0xf0>)
   1e294:	492c      	ldr	r1, [pc, #176]	; (1e348 <preempt+0xf4>)
   1e296:	f44f 7367 	mov.w	r3, #924	; 0x39c

		/* Enqueue as resume event */
		iter = resume_enqueue(resume_cb);
		LL_ASSERT(iter);
	} else {
		LL_ASSERT(err == -ECANCELED);
   1e29a:	482c      	ldr	r0, [pc, #176]	; (1e34c <preempt+0xf8>)
   1e29c:	f006 ff8e 	bl	251bc <printk>
   1e2a0:	4040      	eors	r0, r0
   1e2a2:	f380 8811 	msr	BASEPRI, r0
   1e2a6:	f04f 0003 	mov.w	r0, #3
   1e2aa:	df02      	svc	2
   1e2ac:	e00e      	b.n	1e2cc <preempt+0x78>
	err = event.curr.is_abort_cb(next->prepare_param.param,
   1e2ae:	6863      	ldr	r3, [r4, #4]
   1e2b0:	6821      	ldr	r1, [r4, #0]
   1e2b2:	68e8      	ldr	r0, [r5, #12]
   1e2b4:	aa03      	add	r2, sp, #12
   1e2b6:	4798      	blx	r3
	if (!err) {
   1e2b8:	4607      	mov	r7, r0
   1e2ba:	b948      	cbnz	r0, 1e2d0 <preempt+0x7c>
		next->is_aborted = 1;
   1e2bc:	7f2b      	ldrb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1e2be:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
   1e2c0:	f043 0302 	orr.w	r3, r3, #2
   1e2c4:	772b      	strb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1e2c6:	4628      	mov	r0, r5
   1e2c8:	69ab      	ldr	r3, [r5, #24]
   1e2ca:	4798      	blx	r3
	}
}
   1e2cc:	b009      	add	sp, #36	; 0x24
   1e2ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	event.curr.abort_cb(NULL, event.curr.param);
   1e2d0:	68a3      	ldr	r3, [r4, #8]
   1e2d2:	6821      	ldr	r1, [r4, #0]
   1e2d4:	4630      	mov	r0, r6
   1e2d6:	4798      	blx	r3
	if (err == -EAGAIN) {
   1e2d8:	f117 0f0b 	cmn.w	r7, #11
   1e2dc:	d129      	bne.n	1e332 <preempt+0xde>
		iter_idx = UINT8_MAX;
   1e2de:	25ff      	movs	r5, #255	; 0xff
				iter_idx = UINT8_MAX;
   1e2e0:	f88d 500b 	strb.w	r5, [sp, #11]
			iter = ull_prepare_dequeue_iter(&iter_idx);
   1e2e4:	f10d 000b 	add.w	r0, sp, #11
   1e2e8:	f7fd fbea 	bl	1bac0 <ull_prepare_dequeue_iter>
		while (iter) {
   1e2ec:	b9a0      	cbnz	r0, 1e318 <preempt+0xc4>
	prepare_param.param = event.curr.param;
   1e2ee:	6823      	ldr	r3, [r4, #0]
   1e2f0:	9307      	str	r3, [sp, #28]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1e2f2:	2301      	movs	r3, #1
	struct lll_prepare_param prepare_param = {0};
   1e2f4:	e9cd 0004 	strd	r0, r0, [sp, #16]
   1e2f8:	9006      	str	r0, [sp, #24]
	event.curr.param = NULL;
   1e2fa:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1e2fc:	9300      	str	r3, [sp, #0]
   1e2fe:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
   1e302:	9b03      	ldr	r3, [sp, #12]
   1e304:	aa04      	add	r2, sp, #16
   1e306:	f7fd fb9f 	bl	1ba48 <ull_prepare_enqueue>
		LL_ASSERT(iter);
   1e30a:	2800      	cmp	r0, #0
   1e30c:	d1de      	bne.n	1e2cc <preempt+0x78>
   1e30e:	4a0d      	ldr	r2, [pc, #52]	; (1e344 <preempt+0xf0>)
   1e310:	490f      	ldr	r1, [pc, #60]	; (1e350 <preempt+0xfc>)
   1e312:	f240 33ce 	movw	r3, #974	; 0x3ce
   1e316:	e7c0      	b.n	1e29a <preempt+0x46>
			if (!iter->is_aborted &&
   1e318:	7f03      	ldrb	r3, [r0, #28]
   1e31a:	079a      	lsls	r2, r3, #30
   1e31c:	d4e2      	bmi.n	1e2e4 <preempt+0x90>
			    event.curr.param == iter->prepare_param.param) {
   1e31e:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   1e320:	6821      	ldr	r1, [r4, #0]
   1e322:	4291      	cmp	r1, r2
   1e324:	d1de      	bne.n	1e2e4 <preempt+0x90>
				iter->is_aborted = 1;
   1e326:	f043 0302 	orr.w	r3, r3, #2
   1e32a:	7703      	strb	r3, [r0, #28]
				iter->abort_cb(&iter->prepare_param,
   1e32c:	6983      	ldr	r3, [r0, #24]
   1e32e:	4798      	blx	r3
   1e330:	e7d6      	b.n	1e2e0 <preempt+0x8c>
		LL_ASSERT(err == -ECANCELED);
   1e332:	378c      	adds	r7, #140	; 0x8c
   1e334:	d0ca      	beq.n	1e2cc <preempt+0x78>
   1e336:	4a03      	ldr	r2, [pc, #12]	; (1e344 <preempt+0xf0>)
   1e338:	4906      	ldr	r1, [pc, #24]	; (1e354 <preempt+0x100>)
   1e33a:	f44f 7374 	mov.w	r3, #976	; 0x3d0
   1e33e:	e7ac      	b.n	1e29a <preempt+0x46>
   1e340:	200033d8 	.word	0x200033d8
   1e344:	000345e3 	.word	0x000345e3
   1e348:	000341e5 	.word	0x000341e5
   1e34c:	0002f8b5 	.word	0x0002f8b5
   1e350:	000346ab 	.word	0x000346ab
   1e354:	000346b0 	.word	0x000346b0

0001e358 <lll_init>:
{
   1e358:	b510      	push	{r4, lr}
   1e35a:	4816      	ldr	r0, [pc, #88]	; (1e3b4 <lll_init+0x5c>)
   1e35c:	f005 fa62 	bl	23824 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
   1e360:	4b15      	ldr	r3, [pc, #84]	; (1e3b8 <lll_init+0x60>)
   1e362:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
   1e364:	b310      	cbz	r0, 1e3ac <lll_init+0x54>
	event.curr.abort_cb = NULL;
   1e366:	4b15      	ldr	r3, [pc, #84]	; (1e3bc <lll_init+0x64>)
   1e368:	2400      	movs	r4, #0
   1e36a:	609c      	str	r4, [r3, #8]
	err = lll_clock_init();
   1e36c:	f000 fa34 	bl	1e7d8 <lll_clock_init>
	if (err < 0) {
   1e370:	2800      	cmp	r0, #0
   1e372:	db1a      	blt.n	1e3aa <lll_init+0x52>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   1e374:	4622      	mov	r2, r4
   1e376:	4621      	mov	r1, r4
   1e378:	2001      	movs	r0, #1
   1e37a:	f7e6 f99f 	bl	46bc <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   1e37e:	4622      	mov	r2, r4
   1e380:	2101      	movs	r1, #1
   1e382:	200b      	movs	r0, #11
   1e384:	f7e6 f99a 	bl	46bc <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   1e388:	4622      	mov	r2, r4
   1e38a:	4621      	mov	r1, r4
   1e38c:	2018      	movs	r0, #24
   1e38e:	f7e6 f995 	bl	46bc <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   1e392:	2001      	movs	r0, #1
   1e394:	f7e6 f960 	bl	4658 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   1e398:	200b      	movs	r0, #11
   1e39a:	f7e6 f95d 	bl	4658 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   1e39e:	2018      	movs	r0, #24
   1e3a0:	f7e6 f95a 	bl	4658 <arch_irq_enable>
	radio_setup();
   1e3a4:	f00d fb5d 	bl	2ba62 <radio_setup>
	return 0;
   1e3a8:	4620      	mov	r0, r4
}
   1e3aa:	bd10      	pop	{r4, pc}
		return -ENODEV;
   1e3ac:	f06f 0012 	mvn.w	r0, #18
   1e3b0:	e7fb      	b.n	1e3aa <lll_init+0x52>
   1e3b2:	bf00      	nop
   1e3b4:	000346bc 	.word	0x000346bc
   1e3b8:	200033d4 	.word	0x200033d4
   1e3bc:	200033d8 	.word	0x200033d8

0001e3c0 <lll_csrand_get>:
	return entropy_get_entropy(dev_entropy, buf, len);
   1e3c0:	4a05      	ldr	r2, [pc, #20]	; (1e3d8 <lll_csrand_get+0x18>)
{
   1e3c2:	b410      	push	{r4}
   1e3c4:	4603      	mov	r3, r0
	return entropy_get_entropy(dev_entropy, buf, len);
   1e3c6:	6810      	ldr	r0, [r2, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   1e3c8:	6882      	ldr	r2, [r0, #8]
   1e3ca:	6814      	ldr	r4, [r2, #0]
   1e3cc:	b28a      	uxth	r2, r1
   1e3ce:	4619      	mov	r1, r3
   1e3d0:	4623      	mov	r3, r4
}
   1e3d2:	bc10      	pop	{r4}
   1e3d4:	4718      	bx	r3
   1e3d6:	bf00      	nop
   1e3d8:	200033d4 	.word	0x200033d4

0001e3dc <lll_csrand_isr_get>:
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
   1e3dc:	4b08      	ldr	r3, [pc, #32]	; (1e400 <lll_csrand_isr_get+0x24>)
{
   1e3de:	b430      	push	{r4, r5}
   1e3e0:	4604      	mov	r4, r0
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
   1e3e2:	6818      	ldr	r0, [r3, #0]
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
   1e3e4:	6883      	ldr	r3, [r0, #8]
   1e3e6:	685d      	ldr	r5, [r3, #4]
   1e3e8:	b28a      	uxth	r2, r1
   1e3ea:	b125      	cbz	r5, 1e3f6 <lll_csrand_isr_get+0x1a>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
   1e3ec:	4621      	mov	r1, r4
   1e3ee:	46ac      	mov	ip, r5
   1e3f0:	2300      	movs	r3, #0
}
   1e3f2:	bc30      	pop	{r4, r5}
   1e3f4:	4760      	bx	ip
   1e3f6:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1e3fa:	bc30      	pop	{r4, r5}
   1e3fc:	4770      	bx	lr
   1e3fe:	bf00      	nop
   1e400:	200033d4 	.word	0x200033d4

0001e404 <lll_disable>:
{
   1e404:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1e406:	4b19      	ldr	r3, [pc, #100]	; (1e46c <lll_disable+0x68>)
	if (!param || (param == event.curr.param)) {
   1e408:	4604      	mov	r4, r0
   1e40a:	b110      	cbz	r0, 1e412 <lll_disable+0xe>
   1e40c:	681a      	ldr	r2, [r3, #0]
   1e40e:	4282      	cmp	r2, r0
   1e410:	d105      	bne.n	1e41e <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
   1e412:	689a      	ldr	r2, [r3, #8]
   1e414:	b16a      	cbz	r2, 1e432 <lll_disable+0x2e>
   1e416:	6819      	ldr	r1, [r3, #0]
   1e418:	b159      	cbz	r1, 1e432 <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
   1e41a:	2000      	movs	r0, #0
   1e41c:	4790      	blx	r2
		idx = UINT8_MAX;
   1e41e:	25ff      	movs	r5, #255	; 0xff
				idx = UINT8_MAX;
   1e420:	f88d 5007 	strb.w	r5, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   1e424:	f10d 0007 	add.w	r0, sp, #7
   1e428:	f7fd fb4a 	bl	1bac0 <ull_prepare_dequeue_iter>
		while (next) {
   1e42c:	b980      	cbnz	r0, 1e450 <lll_disable+0x4c>
}
   1e42e:	b003      	add	sp, #12
   1e430:	bd30      	pop	{r4, r5, pc}
			LL_ASSERT(!param);
   1e432:	2c00      	cmp	r4, #0
   1e434:	d0f3      	beq.n	1e41e <lll_disable+0x1a>
   1e436:	4a0e      	ldr	r2, [pc, #56]	; (1e470 <lll_disable+0x6c>)
   1e438:	490e      	ldr	r1, [pc, #56]	; (1e474 <lll_disable+0x70>)
   1e43a:	480f      	ldr	r0, [pc, #60]	; (1e478 <lll_disable+0x74>)
   1e43c:	23fd      	movs	r3, #253	; 0xfd
   1e43e:	f006 febd 	bl	251bc <printk>
   1e442:	4040      	eors	r0, r0
   1e444:	f380 8811 	msr	BASEPRI, r0
   1e448:	f04f 0003 	mov.w	r0, #3
   1e44c:	df02      	svc	2
   1e44e:	e7e6      	b.n	1e41e <lll_disable+0x1a>
			if (!next->is_aborted &&
   1e450:	7f03      	ldrb	r3, [r0, #28]
   1e452:	079b      	lsls	r3, r3, #30
   1e454:	d4e6      	bmi.n	1e424 <lll_disable+0x20>
			    (!param || (param == next->prepare_param.param))) {
   1e456:	68c1      	ldr	r1, [r0, #12]
			if (!next->is_aborted &&
   1e458:	b10c      	cbz	r4, 1e45e <lll_disable+0x5a>
			    (!param || (param == next->prepare_param.param))) {
   1e45a:	428c      	cmp	r4, r1
   1e45c:	d1e2      	bne.n	1e424 <lll_disable+0x20>
				next->is_aborted = 1;
   1e45e:	7f03      	ldrb	r3, [r0, #28]
   1e460:	f043 0302 	orr.w	r3, r3, #2
   1e464:	7703      	strb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
   1e466:	6983      	ldr	r3, [r0, #24]
   1e468:	4798      	blx	r3
   1e46a:	e7d9      	b.n	1e420 <lll_disable+0x1c>
   1e46c:	200033d8 	.word	0x200033d8
   1e470:	000345e3 	.word	0x000345e3
   1e474:	000346c0 	.word	0x000346c0
   1e478:	0002f8b5 	.word	0x0002f8b5

0001e47c <lll_done>:
{
   1e47c:	b538      	push	{r3, r4, r5, lr}
   1e47e:	4604      	mov	r4, r0
	next = ull_prepare_dequeue_get();
   1e480:	f7fd fb10 	bl	1baa4 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   1e484:	b17c      	cbz	r4, 1e4a6 <lll_done+0x2a>
   1e486:	b960      	cbnz	r0, 1e4a2 <lll_done+0x26>
   1e488:	4a1d      	ldr	r2, [pc, #116]	; (1e500 <lll_done+0x84>)
   1e48a:	491e      	ldr	r1, [pc, #120]	; (1e504 <lll_done+0x88>)
   1e48c:	481e      	ldr	r0, [pc, #120]	; (1e508 <lll_done+0x8c>)
   1e48e:	f240 1337 	movw	r3, #311	; 0x137
   1e492:	f006 fe93 	bl	251bc <printk>
   1e496:	4040      	eors	r0, r0
   1e498:	f380 8811 	msr	BASEPRI, r0
   1e49c:	f04f 0003 	mov.w	r0, #3
   1e4a0:	df02      	svc	2
			ull = HDR_LLL2ULL(param);
   1e4a2:	6824      	ldr	r4, [r4, #0]
   1e4a4:	e015      	b.n	1e4d2 <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
   1e4a6:	4d19      	ldr	r5, [pc, #100]	; (1e50c <lll_done+0x90>)
   1e4a8:	68ab      	ldr	r3, [r5, #8]
   1e4aa:	b963      	cbnz	r3, 1e4c6 <lll_done+0x4a>
   1e4ac:	4a14      	ldr	r2, [pc, #80]	; (1e500 <lll_done+0x84>)
   1e4ae:	4918      	ldr	r1, [pc, #96]	; (1e510 <lll_done+0x94>)
   1e4b0:	4815      	ldr	r0, [pc, #84]	; (1e508 <lll_done+0x8c>)
   1e4b2:	f240 133d 	movw	r3, #317	; 0x13d
   1e4b6:	f006 fe81 	bl	251bc <printk>
   1e4ba:	4040      	eors	r0, r0
   1e4bc:	f380 8811 	msr	BASEPRI, r0
   1e4c0:	f04f 0003 	mov.w	r0, #3
   1e4c4:	df02      	svc	2
		param = event.curr.param;
   1e4c6:	682c      	ldr	r4, [r5, #0]
		event.curr.abort_cb = NULL;
   1e4c8:	2300      	movs	r3, #0
   1e4ca:	60ab      	str	r3, [r5, #8]
		event.curr.param = NULL;
   1e4cc:	602b      	str	r3, [r5, #0]
		if (param) {
   1e4ce:	2c00      	cmp	r4, #0
   1e4d0:	d1e7      	bne.n	1e4a2 <lll_done+0x26>
	ull_prepare_dequeue(TICKER_USER_ID_LLL);
   1e4d2:	2000      	movs	r0, #0
   1e4d4:	f7fd fb12 	bl	1bafc <ull_prepare_dequeue>
	evdone = ull_event_done(ull);
   1e4d8:	4620      	mov	r0, r4
   1e4da:	f7fd fb67 	bl	1bbac <ull_event_done>
	LL_ASSERT(evdone);
   1e4de:	b960      	cbnz	r0, 1e4fa <lll_done+0x7e>
   1e4e0:	4a07      	ldr	r2, [pc, #28]	; (1e500 <lll_done+0x84>)
   1e4e2:	490c      	ldr	r1, [pc, #48]	; (1e514 <lll_done+0x98>)
   1e4e4:	4808      	ldr	r0, [pc, #32]	; (1e508 <lll_done+0x8c>)
   1e4e6:	f240 136d 	movw	r3, #365	; 0x16d
   1e4ea:	f006 fe67 	bl	251bc <printk>
   1e4ee:	4040      	eors	r0, r0
   1e4f0:	f380 8811 	msr	BASEPRI, r0
   1e4f4:	f04f 0003 	mov.w	r0, #3
   1e4f8:	df02      	svc	2
}
   1e4fa:	2000      	movs	r0, #0
   1e4fc:	bd38      	pop	{r3, r4, r5, pc}
   1e4fe:	bf00      	nop
   1e500:	000345e3 	.word	0x000345e3
   1e504:	000346c7 	.word	0x000346c7
   1e508:	0002f8b5 	.word	0x0002f8b5
   1e50c:	200033d8 	.word	0x200033d8
   1e510:	000346d6 	.word	0x000346d6
   1e514:	000346ea 	.word	0x000346ea

0001e518 <lll_is_done>:
	*is_resume = (param != event.curr.param);
   1e518:	4a05      	ldr	r2, [pc, #20]	; (1e530 <lll_is_done+0x18>)
   1e51a:	6813      	ldr	r3, [r2, #0]
   1e51c:	1a1b      	subs	r3, r3, r0
	return !event.curr.abort_cb;
   1e51e:	6890      	ldr	r0, [r2, #8]
	*is_resume = (param != event.curr.param);
   1e520:	bf18      	it	ne
   1e522:	2301      	movne	r3, #1
}
   1e524:	fab0 f080 	clz	r0, r0
	*is_resume = (param != event.curr.param);
   1e528:	700b      	strb	r3, [r1, #0]
}
   1e52a:	0940      	lsrs	r0, r0, #5
   1e52c:	4770      	bx	lr
   1e52e:	bf00      	nop
   1e530:	200033d8 	.word	0x200033d8

0001e534 <lll_chan_set>:
	switch (chan) {
   1e534:	2826      	cmp	r0, #38	; 0x26
{
   1e536:	b510      	push	{r4, lr}
   1e538:	4604      	mov	r4, r0
	switch (chan) {
   1e53a:	d00b      	beq.n	1e554 <lll_chan_set+0x20>
   1e53c:	2827      	cmp	r0, #39	; 0x27
   1e53e:	d00b      	beq.n	1e558 <lll_chan_set+0x24>
   1e540:	2825      	cmp	r0, #37	; 0x25
   1e542:	d10b      	bne.n	1e55c <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   1e544:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
   1e546:	f001 fcf7 	bl	1ff38 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   1e54a:	4620      	mov	r0, r4
}
   1e54c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   1e550:	f001 bcf8 	b.w	1ff44 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   1e554:	201a      	movs	r0, #26
   1e556:	e7f6      	b.n	1e546 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
   1e558:	2050      	movs	r0, #80	; 0x50
   1e55a:	e7f4      	b.n	1e546 <lll_chan_set+0x12>
		if (chan < 11) {
   1e55c:	280a      	cmp	r0, #10
   1e55e:	d802      	bhi.n	1e566 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
   1e560:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1e562:	0040      	lsls	r0, r0, #1
   1e564:	e7ef      	b.n	1e546 <lll_chan_set+0x12>
		} else if (chan < 40) {
   1e566:	2827      	cmp	r0, #39	; 0x27
   1e568:	d801      	bhi.n	1e56e <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1e56a:	3003      	adds	r0, #3
   1e56c:	e7f9      	b.n	1e562 <lll_chan_set+0x2e>
			LL_ASSERT(0);
   1e56e:	4a07      	ldr	r2, [pc, #28]	; (1e58c <lll_chan_set+0x58>)
   1e570:	4907      	ldr	r1, [pc, #28]	; (1e590 <lll_chan_set+0x5c>)
   1e572:	4808      	ldr	r0, [pc, #32]	; (1e594 <lll_chan_set+0x60>)
   1e574:	f240 13df 	movw	r3, #479	; 0x1df
   1e578:	f006 fe20 	bl	251bc <printk>
   1e57c:	4040      	eors	r0, r0
   1e57e:	f380 8811 	msr	BASEPRI, r0
   1e582:	f04f 0003 	mov.w	r0, #3
   1e586:	df02      	svc	2
   1e588:	e7df      	b.n	1e54a <lll_chan_set+0x16>
   1e58a:	bf00      	nop
   1e58c:	000345e3 	.word	0x000345e3
   1e590:	00031059 	.word	0x00031059
   1e594:	0002f8b5 	.word	0x0002f8b5

0001e598 <lll_isr_cleanup>:
{
   1e598:	b508      	push	{r3, lr}
   1e59a:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
   1e59c:	480f      	ldr	r0, [pc, #60]	; (1e5dc <lll_isr_cleanup+0x44>)
   1e59e:	f001 fc71 	bl	1fe84 <radio_isr_set>
	if (!radio_is_idle()) {
   1e5a2:	f001 fd69 	bl	20078 <radio_is_idle>
   1e5a6:	b908      	cbnz	r0, 1e5ac <lll_isr_cleanup+0x14>
		radio_disable();
   1e5a8:	f001 fd34 	bl	20014 <radio_disable>
	radio_tmr_stop();
   1e5ac:	f001 ff38 	bl	20420 <radio_tmr_stop>
	err = lll_hfclock_off();
   1e5b0:	f000 f954 	bl	1e85c <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   1e5b4:	2800      	cmp	r0, #0
   1e5b6:	da0c      	bge.n	1e5d2 <lll_isr_cleanup+0x3a>
   1e5b8:	4a09      	ldr	r2, [pc, #36]	; (1e5e0 <lll_isr_cleanup+0x48>)
   1e5ba:	490a      	ldr	r1, [pc, #40]	; (1e5e4 <lll_isr_cleanup+0x4c>)
   1e5bc:	480a      	ldr	r0, [pc, #40]	; (1e5e8 <lll_isr_cleanup+0x50>)
   1e5be:	f240 2342 	movw	r3, #578	; 0x242
   1e5c2:	f006 fdfb 	bl	251bc <printk>
   1e5c6:	4040      	eors	r0, r0
   1e5c8:	f380 8811 	msr	BASEPRI, r0
   1e5cc:	f04f 0003 	mov.w	r0, #3
   1e5d0:	df02      	svc	2
}
   1e5d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   1e5d6:	2000      	movs	r0, #0
   1e5d8:	f7ff bf50 	b.w	1e47c <lll_done>
   1e5dc:	0002b5db 	.word	0x0002b5db
   1e5e0:	000345e3 	.word	0x000345e3
   1e5e4:	000346f1 	.word	0x000346f1
   1e5e8:	0002f8b5 	.word	0x0002f8b5

0001e5ec <lll_isr_early_abort>:
{
   1e5ec:	b508      	push	{r3, lr}
   1e5ee:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
   1e5f0:	480e      	ldr	r0, [pc, #56]	; (1e62c <lll_isr_early_abort+0x40>)
   1e5f2:	f001 fc47 	bl	1fe84 <radio_isr_set>
	if (!radio_is_idle()) {
   1e5f6:	f001 fd3f 	bl	20078 <radio_is_idle>
   1e5fa:	b908      	cbnz	r0, 1e600 <lll_isr_early_abort+0x14>
		radio_disable();
   1e5fc:	f001 fd0a 	bl	20014 <radio_disable>
	err = lll_hfclock_off();
   1e600:	f000 f92c 	bl	1e85c <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   1e604:	2800      	cmp	r0, #0
   1e606:	da0c      	bge.n	1e622 <lll_isr_early_abort+0x36>
   1e608:	4a09      	ldr	r2, [pc, #36]	; (1e630 <lll_isr_early_abort+0x44>)
   1e60a:	490a      	ldr	r1, [pc, #40]	; (1e634 <lll_isr_early_abort+0x48>)
   1e60c:	480a      	ldr	r0, [pc, #40]	; (1e638 <lll_isr_early_abort+0x4c>)
   1e60e:	f240 2351 	movw	r3, #593	; 0x251
   1e612:	f006 fdd3 	bl	251bc <printk>
   1e616:	4040      	eors	r0, r0
   1e618:	f380 8811 	msr	BASEPRI, r0
   1e61c:	f04f 0003 	mov.w	r0, #3
   1e620:	df02      	svc	2
}
   1e622:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   1e626:	2000      	movs	r0, #0
   1e628:	f7ff bf28 	b.w	1e47c <lll_done>
   1e62c:	0002b5db 	.word	0x0002b5db
   1e630:	000345e3 	.word	0x000345e3
   1e634:	000346f1 	.word	0x000346f1
   1e638:	0002f8b5 	.word	0x0002f8b5

0001e63c <lll_prepare_resolve>:
{
   1e63c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   1e640:	461d      	mov	r5, r3
   1e642:	f89d a030 	ldrb.w	sl, [sp, #48]	; 0x30
	idx = UINT8_MAX;
   1e646:	23ff      	movs	r3, #255	; 0xff
{
   1e648:	4681      	mov	r9, r0
   1e64a:	4688      	mov	r8, r1
   1e64c:	4616      	mov	r6, r2
	idx = UINT8_MAX;
   1e64e:	f88d 300f 	strb.w	r3, [sp, #15]
		p = ull_prepare_dequeue_iter(&idx);
   1e652:	f10d 000f 	add.w	r0, sp, #15
   1e656:	f7fd fa33 	bl	1bac0 <ull_prepare_dequeue_iter>
   1e65a:	4604      	mov	r4, r0
	while (p && (p->is_aborted || p->is_resume)) {
   1e65c:	b110      	cbz	r0, 1e664 <lll_prepare_resolve+0x28>
   1e65e:	7f03      	ldrb	r3, [r0, #28]
   1e660:	079b      	lsls	r3, r3, #30
   1e662:	d1f6      	bne.n	1e652 <lll_prepare_resolve+0x16>
	    event.curr.abort_cb ||
   1e664:	4f41      	ldr	r7, [pc, #260]	; (1e76c <lll_prepare_resolve+0x130>)
	if ((!is_dequeue && !is_done_sync()) ||
   1e666:	68bb      	ldr	r3, [r7, #8]
   1e668:	b923      	cbnz	r3, 1e674 <lll_prepare_resolve+0x38>
	    event.curr.abort_cb ||
   1e66a:	2c00      	cmp	r4, #0
   1e66c:	d046      	beq.n	1e6fc <lll_prepare_resolve+0xc0>
	    (p && is_resume)) {
   1e66e:	f1ba 0f00 	cmp.w	sl, #0
   1e672:	d034      	beq.n	1e6de <lll_prepare_resolve+0xa2>
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   1e674:	462a      	mov	r2, r5
   1e676:	f8cd a000 	str.w	sl, [sp]
   1e67a:	4633      	mov	r3, r6
   1e67c:	4641      	mov	r1, r8
   1e67e:	4648      	mov	r0, r9
   1e680:	f7fd f9e2 	bl	1ba48 <ull_prepare_enqueue>
		LL_ASSERT(next);
   1e684:	4605      	mov	r5, r0
   1e686:	b960      	cbnz	r0, 1e6a2 <lll_prepare_resolve+0x66>
   1e688:	4a39      	ldr	r2, [pc, #228]	; (1e770 <lll_prepare_resolve+0x134>)
   1e68a:	493a      	ldr	r1, [pc, #232]	; (1e774 <lll_prepare_resolve+0x138>)
   1e68c:	483a      	ldr	r0, [pc, #232]	; (1e778 <lll_prepare_resolve+0x13c>)
   1e68e:	f240 238d 	movw	r3, #653	; 0x28d
   1e692:	f006 fd93 	bl	251bc <printk>
   1e696:	4040      	eors	r0, r0
   1e698:	f380 8811 	msr	BASEPRI, r0
   1e69c:	f04f 0003 	mov.w	r0, #3
   1e6a0:	df02      	svc	2
		if (is_resume) {
   1e6a2:	f1ba 0f00 	cmp.w	sl, #0
   1e6a6:	d005      	beq.n	1e6b4 <lll_prepare_resolve+0x78>
		return -EINPROGRESS;
   1e6a8:	f06f 0476 	mvn.w	r4, #118	; 0x76
}
   1e6ac:	4620      	mov	r0, r4
   1e6ae:	b004      	add	sp, #16
   1e6b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ret  = preempt_ticker_start(p, next);
   1e6b4:	4629      	mov	r1, r5
   1e6b6:	4620      	mov	r0, r4
   1e6b8:	f7ff fd64 	bl	1e184 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1e6bc:	f030 0302 	bics.w	r3, r0, #2
   1e6c0:	d0f2      	beq.n	1e6a8 <lll_prepare_resolve+0x6c>
   1e6c2:	4a2b      	ldr	r2, [pc, #172]	; (1e770 <lll_prepare_resolve+0x134>)
   1e6c4:	492d      	ldr	r1, [pc, #180]	; (1e77c <lll_prepare_resolve+0x140>)
   1e6c6:	482c      	ldr	r0, [pc, #176]	; (1e778 <lll_prepare_resolve+0x13c>)
   1e6c8:	f44f 7326 	mov.w	r3, #664	; 0x298
   1e6cc:	f006 fd76 	bl	251bc <printk>
   1e6d0:	4040      	eors	r0, r0
   1e6d2:	f380 8811 	msr	BASEPRI, r0
   1e6d6:	f04f 0003 	mov.w	r0, #3
   1e6da:	df02      	svc	2
   1e6dc:	e7e4      	b.n	1e6a8 <lll_prepare_resolve+0x6c>
	LL_ASSERT(!p || &p->prepare_param == prepare_param);
   1e6de:	42ac      	cmp	r4, r5
   1e6e0:	d00c      	beq.n	1e6fc <lll_prepare_resolve+0xc0>
   1e6e2:	4a23      	ldr	r2, [pc, #140]	; (1e770 <lll_prepare_resolve+0x134>)
   1e6e4:	4926      	ldr	r1, [pc, #152]	; (1e780 <lll_prepare_resolve+0x144>)
   1e6e6:	4824      	ldr	r0, [pc, #144]	; (1e778 <lll_prepare_resolve+0x13c>)
   1e6e8:	f240 23be 	movw	r3, #702	; 0x2be
   1e6ec:	f006 fd66 	bl	251bc <printk>
   1e6f0:	4040      	eors	r0, r0
   1e6f2:	f380 8811 	msr	BASEPRI, r0
   1e6f6:	f04f 0003 	mov.w	r0, #3
   1e6fa:	df02      	svc	2
	event.curr.param = prepare_param->param;
   1e6fc:	68eb      	ldr	r3, [r5, #12]
	event.curr.abort_cb = abort_cb;
   1e6fe:	f8c7 8008 	str.w	r8, [r7, #8]
	event.curr.is_abort_cb = is_abort_cb;
   1e702:	e9c7 3900 	strd	r3, r9, [r7]
	err = prepare_cb(prepare_param);
   1e706:	4628      	mov	r0, r5
   1e708:	47b0      	blx	r6
   1e70a:	4604      	mov	r4, r0
	ret = preempt_ticker_stop();
   1e70c:	f7ff fcfa 	bl	1e104 <preempt_ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1e710:	f030 0302 	bics.w	r3, r0, #2
   1e714:	d00c      	beq.n	1e730 <lll_prepare_resolve+0xf4>
   1e716:	4a16      	ldr	r2, [pc, #88]	; (1e770 <lll_prepare_resolve+0x134>)
   1e718:	4918      	ldr	r1, [pc, #96]	; (1e77c <lll_prepare_resolve+0x140>)
   1e71a:	4817      	ldr	r0, [pc, #92]	; (1e778 <lll_prepare_resolve+0x13c>)
   1e71c:	f240 23cb 	movw	r3, #715	; 0x2cb
   1e720:	f006 fd4c 	bl	251bc <printk>
   1e724:	4040      	eors	r0, r0
   1e726:	f380 8811 	msr	BASEPRI, r0
   1e72a:	f04f 0003 	mov.w	r0, #3
   1e72e:	df02      	svc	2
		p = ull_prepare_dequeue_iter(&idx);
   1e730:	f10d 000f 	add.w	r0, sp, #15
   1e734:	f7fd f9c4 	bl	1bac0 <ull_prepare_dequeue_iter>
		if (!p) {
   1e738:	4601      	mov	r1, r0
   1e73a:	2800      	cmp	r0, #0
   1e73c:	d0b6      	beq.n	1e6ac <lll_prepare_resolve+0x70>
	} while (p->is_aborted || p->is_resume);
   1e73e:	7f00      	ldrb	r0, [r0, #28]
   1e740:	f010 0003 	ands.w	r0, r0, #3
   1e744:	d1f4      	bne.n	1e730 <lll_prepare_resolve+0xf4>
	ret = preempt_ticker_start(NULL, p);
   1e746:	f7ff fd1d 	bl	1e184 <preempt_ticker_start>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1e74a:	f030 0302 	bics.w	r3, r0, #2
   1e74e:	d0ad      	beq.n	1e6ac <lll_prepare_resolve+0x70>
   1e750:	4a07      	ldr	r2, [pc, #28]	; (1e770 <lll_prepare_resolve+0x134>)
   1e752:	490a      	ldr	r1, [pc, #40]	; (1e77c <lll_prepare_resolve+0x140>)
   1e754:	4808      	ldr	r0, [pc, #32]	; (1e778 <lll_prepare_resolve+0x13c>)
   1e756:	f44f 7336 	mov.w	r3, #728	; 0x2d8
   1e75a:	f006 fd2f 	bl	251bc <printk>
   1e75e:	4040      	eors	r0, r0
   1e760:	f380 8811 	msr	BASEPRI, r0
   1e764:	f04f 0003 	mov.w	r0, #3
   1e768:	df02      	svc	2
   1e76a:	e79f      	b.n	1e6ac <lll_prepare_resolve+0x70>
   1e76c:	200033d8 	.word	0x200033d8
   1e770:	000345e3 	.word	0x000345e3
   1e774:	000346d1 	.word	0x000346d1
   1e778:	0002f8b5 	.word	0x0002f8b5
   1e77c:	000341e5 	.word	0x000341e5
   1e780:	000346fa 	.word	0x000346fa

0001e784 <blocking_on>:

	k_sem_give(&clk_state->sem);
}

static int blocking_on(struct onoff_manager *mgr, uint32_t timeout)
{
   1e784:	b570      	push	{r4, r5, r6, lr}
   1e786:	4606      	mov	r6, r0
   1e788:	b08a      	sub	sp, #40	; 0x28
   1e78a:	460d      	mov	r5, r1
	return z_impl_k_sem_init(sem, initial_count, limit);
   1e78c:	2201      	movs	r2, #1
   1e78e:	2100      	movs	r1, #0
   1e790:	a804      	add	r0, sp, #16
   1e792:	f00e fa74 	bl	2cc7e <z_impl_k_sem_init>
					      sys_notify_generic_callback handler)
{
	__ASSERT_NO_MSG(notify != NULL);
	__ASSERT_NO_MSG(handler != NULL);

	*notify = (struct sys_notify){
   1e796:	4b0f      	ldr	r3, [pc, #60]	; (1e7d4 <blocking_on+0x50>)
   1e798:	9301      	str	r3, [sp, #4]
   1e79a:	2400      	movs	r4, #0
   1e79c:	2303      	movs	r3, #3
	struct lll_clock_state state;
	int err;

	k_sem_init(&state.sem, 0, 1);
	sys_notify_init_callback(&state.cli.notify, clock_ready);
	err = onoff_request(mgr, &state.cli);
   1e79e:	4669      	mov	r1, sp
   1e7a0:	4630      	mov	r0, r6
   1e7a2:	9403      	str	r4, [sp, #12]
   1e7a4:	9302      	str	r3, [sp, #8]
   1e7a6:	f006 fd85 	bl	252b4 <onoff_request>
	if (err < 0) {
   1e7aa:	2800      	cmp	r0, #0
   1e7ac:	db10      	blt.n	1e7d0 <blocking_on+0x4c>
   1e7ae:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   1e7b2:	4621      	mov	r1, r4
   1e7b4:	f240 30e7 	movw	r0, #999	; 0x3e7
   1e7b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1e7bc:	2300      	movs	r3, #0
   1e7be:	fbe5 0106 	umlal	r0, r1, r5, r6
   1e7c2:	f7e1 fc8d 	bl	e0 <__aeabi_uldivmod>
   1e7c6:	4602      	mov	r2, r0
   1e7c8:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
   1e7ca:	a804      	add	r0, sp, #16
   1e7cc:	f005 fbe8 	bl	23fa0 <z_impl_k_sem_take>
		return err;
	}

	return k_sem_take(&state.sem, K_MSEC(timeout));
}
   1e7d0:	b00a      	add	sp, #40	; 0x28
   1e7d2:	bd70      	pop	{r4, r5, r6, pc}
   1e7d4:	0002b699 	.word	0x0002b699

0001e7d8 <lll_clock_init>:

int lll_clock_init(void)
{
   1e7d8:	b508      	push	{r3, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   1e7da:	2001      	movs	r0, #1
   1e7dc:	f002 f996 	bl	20b0c <z_nrf_clock_control_get_onoff>
	*notify = (struct sys_notify){
   1e7e0:	4904      	ldr	r1, [pc, #16]	; (1e7f4 <lll_clock_init+0x1c>)
   1e7e2:	2300      	movs	r3, #0
   1e7e4:	604b      	str	r3, [r1, #4]
   1e7e6:	60cb      	str	r3, [r1, #12]
   1e7e8:	2301      	movs	r3, #1
   1e7ea:	608b      	str	r3, [r1, #8]

	sys_notify_init_spinwait(&lf_cli.notify);

	return onoff_request(mgr, &lf_cli);
}
   1e7ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return onoff_request(mgr, &lf_cli);
   1e7f0:	f006 bd60 	b.w	252b4 <onoff_request>
   1e7f4:	200033f4 	.word	0x200033f4

0001e7f8 <lll_clock_wait>:
{
	struct onoff_manager *mgr;
	static bool done;
	int err;

	if (done) {
   1e7f8:	4b0c      	ldr	r3, [pc, #48]	; (1e82c <lll_clock_wait+0x34>)
   1e7fa:	781a      	ldrb	r2, [r3, #0]
{
   1e7fc:	b510      	push	{r4, lr}
	if (done) {
   1e7fe:	b10a      	cbz	r2, 1e804 <lll_clock_wait+0xc>
		return 0;
   1e800:	2000      	movs	r0, #0
	if (err != ONOFF_STATE_ON) {
		return -EIO;
	}

	return 0;
}
   1e802:	bd10      	pop	{r4, pc}
	done = true;
   1e804:	2001      	movs	r0, #1
   1e806:	7018      	strb	r0, [r3, #0]
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   1e808:	f002 f980 	bl	20b0c <z_nrf_clock_control_get_onoff>
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
   1e80c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
	mgr = z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
   1e810:	4604      	mov	r4, r0
	err = blocking_on(mgr, LFCLOCK_TIMEOUT_MS);
   1e812:	f7ff ffb7 	bl	1e784 <blocking_on>
	if (err) {
   1e816:	2800      	cmp	r0, #0
   1e818:	d1f3      	bne.n	1e802 <lll_clock_wait+0xa>
	err = onoff_release(mgr);
   1e81a:	4620      	mov	r0, r4
   1e81c:	f006 fd93 	bl	25346 <onoff_release>
	if (err != ONOFF_STATE_ON) {
   1e820:	2802      	cmp	r0, #2
   1e822:	d0ed      	beq.n	1e800 <lll_clock_wait+0x8>
		return -EIO;
   1e824:	f06f 0004 	mvn.w	r0, #4
   1e828:	e7eb      	b.n	1e802 <lll_clock_wait+0xa>
   1e82a:	bf00      	nop
   1e82c:	20003b37 	.word	0x20003b37

0001e830 <lll_hfclock_on>:

int lll_hfclock_on(void)
{
   1e830:	b508      	push	{r3, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1e832:	4b09      	ldr	r3, [pc, #36]	; (1e858 <lll_hfclock_on+0x28>)
   1e834:	f3bf 8f5b 	dmb	ish
   1e838:	e853 2f00 	ldrex	r2, [r3]
   1e83c:	1c51      	adds	r1, r2, #1
   1e83e:	e843 1000 	strex	r0, r1, [r3]
   1e842:	2800      	cmp	r0, #0
   1e844:	d1f8      	bne.n	1e838 <lll_hfclock_on+0x8>
   1e846:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&hf_refcnt) > 0) {
   1e84a:	2a00      	cmp	r2, #0
   1e84c:	dc01      	bgt.n	1e852 <lll_hfclock_on+0x22>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_request();
   1e84e:	f002 f965 	bl	20b1c <z_nrf_clock_bt_ctlr_hf_request>
	DEBUG_RADIO_XTAL(1);

	return 0;
}
   1e852:	2000      	movs	r0, #0
   1e854:	bd08      	pop	{r3, pc}
   1e856:	bf00      	nop
   1e858:	200033f0 	.word	0x200033f0

0001e85c <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
   1e85c:	b508      	push	{r3, lr}
	if (hf_refcnt < 1) {
   1e85e:	4b0c      	ldr	r3, [pc, #48]	; (1e890 <lll_hfclock_off+0x34>)
   1e860:	681a      	ldr	r2, [r3, #0]
   1e862:	2a00      	cmp	r2, #0
   1e864:	dd10      	ble.n	1e888 <lll_hfclock_off+0x2c>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1e866:	f3bf 8f5b 	dmb	ish
   1e86a:	e853 2f00 	ldrex	r2, [r3]
   1e86e:	1e51      	subs	r1, r2, #1
   1e870:	e843 1000 	strex	r0, r1, [r3]
   1e874:	2800      	cmp	r0, #0
   1e876:	d1f8      	bne.n	1e86a <lll_hfclock_off+0xe>
   1e878:	f3bf 8f5b 	dmb	ish
		return -EALREADY;
	}

	if (atomic_dec(&hf_refcnt) > 1) {
   1e87c:	2a01      	cmp	r2, #1
   1e87e:	dc01      	bgt.n	1e884 <lll_hfclock_off+0x28>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_release();
   1e880:	f002 f962 	bl	20b48 <z_nrf_clock_bt_ctlr_hf_release>
		return 0;
   1e884:	2000      	movs	r0, #0
   1e886:	e001      	b.n	1e88c <lll_hfclock_off+0x30>
		return -EALREADY;
   1e888:	f06f 0077 	mvn.w	r0, #119	; 0x77
	DEBUG_RADIO_XTAL(0);

	return 0;
}
   1e88c:	bd08      	pop	{r3, pc}
   1e88e:	bf00      	nop
   1e890:	200033f0 	.word	0x200033f0

0001e894 <lll_clock_ppm_get>:
}

uint32_t lll_clock_ppm_get(uint8_t sca)
{
	return sca_ppm_lut[sca];
}
   1e894:	4b01      	ldr	r3, [pc, #4]	; (1e89c <lll_clock_ppm_get+0x8>)
   1e896:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   1e89a:	4770      	bx	lr
   1e89c:	0002ea3c 	.word	0x0002ea3c

0001e8a0 <isr_tx>:

	lll_done(param);
}

static void isr_tx(void *param)
{
   1e8a0:	b538      	push	{r3, r4, r5, lr}
   1e8a2:	4605      	mov	r5, r0
		lll_prof_latency_capture();
		node_rx_prof = lll_prof_reserve();
	}

	/* Clear radio tx status and events */
	lll_isr_tx_status_reset();
   1e8a4:	f00c fed2 	bl	2b64c <lll_isr_tx_status_reset>

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
   1e8a8:	2096      	movs	r0, #150	; 0x96
   1e8aa:	f001 fd23 	bl	202f4 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_p, 0, phy_p, phy_flags);
   1e8ae:	2300      	movs	r3, #0
   1e8b0:	4618      	mov	r0, r3
   1e8b2:	461a      	mov	r2, r3
   1e8b4:	4619      	mov	r1, r3
   1e8b6:	f001 fc8b 	bl	201d0 <radio_switch_complete_and_tx>

	/* setup Rx buffer */
	node_rx = ull_pdu_rx_alloc_peek(1);
   1e8ba:	2001      	movs	r0, #1
   1e8bc:	f7fd f870 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1e8c0:	4604      	mov	r4, r0
   1e8c2:	b960      	cbnz	r0, 1e8de <isr_tx+0x3e>
   1e8c4:	4a1c      	ldr	r2, [pc, #112]	; (1e938 <isr_tx+0x98>)
   1e8c6:	491d      	ldr	r1, [pc, #116]	; (1e93c <isr_tx+0x9c>)
   1e8c8:	481d      	ldr	r0, [pc, #116]	; (1e940 <isr_tx+0xa0>)
   1e8ca:	f240 4341 	movw	r3, #1089	; 0x441
   1e8ce:	f006 fc75 	bl	251bc <printk>
   1e8d2:	4040      	eors	r0, r0
   1e8d4:	f380 8811 	msr	BASEPRI, r0
   1e8d8:	f04f 0003 	mov.w	r0, #3
   1e8dc:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1e8de:	f104 001c 	add.w	r0, r4, #28
   1e8e2:	f001 fb7f 	bl	1ffe4 <radio_pkt_rx_set>

	/* assert if radio packet ptr is not set and radio started rx */
	LL_ASSERT(!radio_is_ready());
   1e8e6:	f001 fbb3 	bl	20050 <radio_is_ready>
   1e8ea:	b160      	cbz	r0, 1e906 <isr_tx+0x66>
   1e8ec:	4a12      	ldr	r2, [pc, #72]	; (1e938 <isr_tx+0x98>)
   1e8ee:	4915      	ldr	r1, [pc, #84]	; (1e944 <isr_tx+0xa4>)
   1e8f0:	4813      	ldr	r0, [pc, #76]	; (1e940 <isr_tx+0xa0>)
   1e8f2:	f240 4345 	movw	r3, #1093	; 0x445
   1e8f6:	f006 fc61 	bl	251bc <printk>
   1e8fa:	4040      	eors	r0, r0
   1e8fc:	f380 8811 	msr	BASEPRI, r0
   1e900:	f04f 0003 	mov.w	r0, #3
   1e904:	df02      	svc	2

	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_cputime_capture();
	}

	radio_isr_set(isr_rx, param);
   1e906:	4629      	mov	r1, r5
   1e908:	480f      	ldr	r0, [pc, #60]	; (1e948 <isr_tx+0xa8>)
   1e90a:	f001 fabb 	bl	1fe84 <radio_isr_set>
		radio_ar_configure(count, irks, 0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	/* +/- 2us active clock jitter, +1 us hcto compensation */
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1e90e:	f001 fdd9 	bl	204c4 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   1e912:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1e914:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   1e916:	4608      	mov	r0, r1
   1e918:	f00d f8c9 	bl	2baae <radio_rx_chain_delay_get>
	hcto += addr_us_get(phy_p);
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
   1e91c:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
   1e91e:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
   1e920:	4608      	mov	r0, r1
   1e922:	f00d f8c0 	bl	2baa6 <radio_tx_chain_delay_get>
   1e926:	442c      	add	r4, r5
   1e928:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1e92a:	1a20      	subs	r0, r4, r0
   1e92c:	f001 fd84 	bl	20438 <radio_tmr_hcto_configure>
		/* NOTE: as scratch packet is used to receive, it is safe to
		 * generate profile event using rx nodes.
		 */
		lll_prof_reserve_send(node_rx_prof);
	}
}
   1e930:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_end_capture();
   1e934:	f001 bdb8 	b.w	204a8 <radio_tmr_end_capture>
   1e938:	00034741 	.word	0x00034741
   1e93c:	0003478b 	.word	0x0003478b
   1e940:	0002f8b5 	.word	0x0002f8b5
   1e944:	00034793 	.word	0x00034793
   1e948:	0001ee0d 	.word	0x0001ee0d

0001e94c <is_abort_cb>:
	if (next != curr) {
   1e94c:	4281      	cmp	r1, r0
{
   1e94e:	b508      	push	{r3, lr}
	if (next != curr) {
   1e950:	d018      	beq.n	1e984 <is_abort_cb+0x38>
		} else if (lll->is_hdcd) {
   1e952:	7a0b      	ldrb	r3, [r1, #8]
   1e954:	07db      	lsls	r3, r3, #31
   1e956:	d522      	bpl.n	1e99e <is_abort_cb+0x52>
			*resume_cb = resume_prepare_cb;
   1e958:	4b12      	ldr	r3, [pc, #72]	; (1e9a4 <is_abort_cb+0x58>)
   1e95a:	6013      	str	r3, [r2, #0]
			err = lll_hfclock_on();
   1e95c:	f7ff ff68 	bl	1e830 <lll_hfclock_on>
			LL_ASSERT(err >= 0);
   1e960:	2800      	cmp	r0, #0
   1e962:	da0c      	bge.n	1e97e <is_abort_cb+0x32>
   1e964:	4a10      	ldr	r2, [pc, #64]	; (1e9a8 <is_abort_cb+0x5c>)
   1e966:	4911      	ldr	r1, [pc, #68]	; (1e9ac <is_abort_cb+0x60>)
   1e968:	4811      	ldr	r0, [pc, #68]	; (1e9b0 <is_abort_cb+0x64>)
   1e96a:	f240 33fa 	movw	r3, #1018	; 0x3fa
   1e96e:	f006 fc25 	bl	251bc <printk>
   1e972:	4040      	eors	r0, r0
   1e974:	f380 8811 	msr	BASEPRI, r0
   1e978:	f04f 0003 	mov.w	r0, #3
   1e97c:	df02      	svc	2
   1e97e:	f06f 000a 	mvn.w	r0, #10
   1e982:	e00b      	b.n	1e99c <is_abort_cb+0x50>
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   1e984:	7b0b      	ldrb	r3, [r1, #12]
   1e986:	eb01 0183 	add.w	r1, r1, r3, lsl #2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1e98a:	690b      	ldr	r3, [r1, #16]
   1e98c:	781b      	ldrb	r3, [r3, #0]
   1e98e:	f003 030f 	and.w	r3, r3, #15
		return 0;
   1e992:	2b01      	cmp	r3, #1
   1e994:	bf14      	ite	ne
   1e996:	f06f 008b 	mvnne.w	r0, #139	; 0x8b
   1e99a:	2000      	moveq	r0, #0
}
   1e99c:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   1e99e:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   1e9a2:	e7fb      	b.n	1e99c <is_abort_cb+0x50>
   1e9a4:	0002b74f 	.word	0x0002b74f
   1e9a8:	00034741 	.word	0x00034741
   1e9ac:	000346f1 	.word	0x000346f1
   1e9b0:	0002f8b5 	.word	0x0002f8b5

0001e9b4 <abort_cb>:
{
   1e9b4:	b510      	push	{r4, lr}
   1e9b6:	460c      	mov	r4, r1
	if (!prepare_param) {
   1e9b8:	b930      	cbnz	r0, 1e9c8 <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
   1e9ba:	480e      	ldr	r0, [pc, #56]	; (1e9f4 <abort_cb+0x40>)
   1e9bc:	f001 fa62 	bl	1fe84 <radio_isr_set>
}
   1e9c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   1e9c4:	f001 bb26 	b.w	20014 <radio_disable>
	err = lll_hfclock_off();
   1e9c8:	f7ff ff48 	bl	1e85c <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   1e9cc:	2800      	cmp	r0, #0
   1e9ce:	da0c      	bge.n	1e9ea <abort_cb+0x36>
   1e9d0:	4a09      	ldr	r2, [pc, #36]	; (1e9f8 <abort_cb+0x44>)
   1e9d2:	490a      	ldr	r1, [pc, #40]	; (1e9fc <abort_cb+0x48>)
   1e9d4:	480a      	ldr	r0, [pc, #40]	; (1ea00 <abort_cb+0x4c>)
   1e9d6:	f44f 6384 	mov.w	r3, #1056	; 0x420
   1e9da:	f006 fbef 	bl	251bc <printk>
   1e9de:	4040      	eors	r0, r0
   1e9e0:	f380 8811 	msr	BASEPRI, r0
   1e9e4:	f04f 0003 	mov.w	r0, #3
   1e9e8:	df02      	svc	2
	lll_done(param);
   1e9ea:	4620      	mov	r0, r4
}
   1e9ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1e9f0:	f7ff bd44 	b.w	1e47c <lll_done>
   1e9f4:	0002b6a5 	.word	0x0002b6a5
   1e9f8:	00034741 	.word	0x00034741
   1e9fc:	000346f1 	.word	0x000346f1
   1ea00:	0002f8b5 	.word	0x0002f8b5

0001ea04 <lll_adv_init>:
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
   1ea04:	4b08      	ldr	r3, [pc, #32]	; (1ea28 <lll_adv_init+0x24>)
   1ea06:	2204      	movs	r2, #4
{
   1ea08:	b510      	push	{r4, lr}
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
   1ea0a:	1898      	adds	r0, r3, r2
   1ea0c:	2128      	movs	r1, #40	; 0x28
   1ea0e:	f00b fed7 	bl	2a7c0 <mem_init>
	MFIFO_INIT(pdu_free);
   1ea12:	4b06      	ldr	r3, [pc, #24]	; (1ea2c <lll_adv_init+0x28>)
   1ea14:	2400      	movs	r4, #0
   1ea16:	805c      	strh	r4, [r3, #2]
	return z_impl_k_sem_init(sem, initial_count, limit);
   1ea18:	2202      	movs	r2, #2
   1ea1a:	4621      	mov	r1, r4
   1ea1c:	4804      	ldr	r0, [pc, #16]	; (1ea30 <lll_adv_init+0x2c>)
   1ea1e:	f00e f92e 	bl	2cc7e <z_impl_k_sem_init>
}
   1ea22:	4620      	mov	r0, r4
   1ea24:	bd10      	pop	{r4, pc}
   1ea26:	bf00      	nop
   1ea28:	20003404 	.word	0x20003404
   1ea2c:	20000b14 	.word	0x20000b14
   1ea30:	200034a8 	.word	0x200034a8

0001ea34 <lll_adv_data_init>:
{
   1ea34:	b510      	push	{r4, lr}
   1ea36:	4604      	mov	r4, r0
	p = mem_acquire(&mem_pdu.free);
   1ea38:	4805      	ldr	r0, [pc, #20]	; (1ea50 <lll_adv_data_init+0x1c>)
   1ea3a:	f00b fee9 	bl	2a810 <mem_acquire>
	if (!p) {
   1ea3e:	4603      	mov	r3, r0
   1ea40:	b118      	cbz	r0, 1ea4a <lll_adv_data_init+0x16>
	p->len = 0U;
   1ea42:	2000      	movs	r0, #0
   1ea44:	7058      	strb	r0, [r3, #1]
	pdu->pdu[0] = (void *)p;
   1ea46:	6063      	str	r3, [r4, #4]
}
   1ea48:	bd10      	pop	{r4, pc}
		return -ENOMEM;
   1ea4a:	f06f 000b 	mvn.w	r0, #11
   1ea4e:	e7fb      	b.n	1ea48 <lll_adv_data_init+0x14>
   1ea50:	20003404 	.word	0x20003404

0001ea54 <lll_adv_pdu_alloc_pdu_adv>:
{
   1ea54:	b538      	push	{r3, r4, r5, lr}
	p = MFIFO_DEQUEUE_PEEK(pdu_free);
   1ea56:	4c33      	ldr	r4, [pc, #204]	; (1eb24 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
   1ea58:	78a2      	ldrb	r2, [r4, #2]
	if (first == last) {
   1ea5a:	78e1      	ldrb	r1, [r4, #3]
   1ea5c:	7823      	ldrb	r3, [r4, #0]
   1ea5e:	4291      	cmp	r1, r2
   1ea60:	d023      	beq.n	1eaaa <lll_adv_pdu_alloc_pdu_adv+0x56>
	return *((void **)(fifo + first * size));
   1ea62:	fb02 4303 	mla	r3, r2, r3, r4
   1ea66:	685d      	ldr	r5, [r3, #4]
	if (p) {
   1ea68:	b1fd      	cbz	r5, 1eaaa <lll_adv_pdu_alloc_pdu_adv+0x56>
	return z_impl_k_sem_take(sem, timeout);
   1ea6a:	482f      	ldr	r0, [pc, #188]	; (1eb28 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
   1ea6c:	2200      	movs	r2, #0
   1ea6e:	2300      	movs	r3, #0
   1ea70:	f005 fa96 	bl	23fa0 <z_impl_k_sem_take>
		LL_ASSERT(!err);
   1ea74:	b160      	cbz	r0, 1ea90 <lll_adv_pdu_alloc_pdu_adv+0x3c>
   1ea76:	4a2d      	ldr	r2, [pc, #180]	; (1eb2c <lll_adv_pdu_alloc_pdu_adv+0xd8>)
   1ea78:	492d      	ldr	r1, [pc, #180]	; (1eb30 <lll_adv_pdu_alloc_pdu_adv+0xdc>)
   1ea7a:	482e      	ldr	r0, [pc, #184]	; (1eb34 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
   1ea7c:	f240 1397 	movw	r3, #407	; 0x197
   1ea80:	f006 fb9c 	bl	251bc <printk>
   1ea84:	4040      	eors	r0, r0
   1ea86:	f380 8811 	msr	BASEPRI, r0
   1ea8a:	f04f 0003 	mov.w	r0, #3
   1ea8e:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
   1ea90:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
   1ea92:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(pdu_free);
   1ea94:	7862      	ldrb	r2, [r4, #1]
   1ea96:	4299      	cmp	r1, r3
   1ea98:	d005      	beq.n	1eaa6 <lll_adv_pdu_alloc_pdu_adv+0x52>
	_first += 1U;
   1ea9a:	3301      	adds	r3, #1
   1ea9c:	b2db      	uxtb	r3, r3
		_first = 0U;
   1ea9e:	429a      	cmp	r2, r3
   1eaa0:	bf08      	it	eq
   1eaa2:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1eaa4:	70a3      	strb	r3, [r4, #2]
}
   1eaa6:	4628      	mov	r0, r5
   1eaa8:	bd38      	pop	{r3, r4, r5, pc}
	p = mem_acquire(&mem_pdu.free);
   1eaaa:	4823      	ldr	r0, [pc, #140]	; (1eb38 <lll_adv_pdu_alloc_pdu_adv+0xe4>)
   1eaac:	f00b feb0 	bl	2a810 <mem_acquire>
	if (p) {
   1eab0:	4605      	mov	r5, r0
   1eab2:	2800      	cmp	r0, #0
   1eab4:	d1f7      	bne.n	1eaa6 <lll_adv_pdu_alloc_pdu_adv+0x52>
   1eab6:	481c      	ldr	r0, [pc, #112]	; (1eb28 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
   1eab8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1eabc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1eac0:	f005 fa6e 	bl	23fa0 <z_impl_k_sem_take>
	LL_ASSERT(!err);
   1eac4:	b160      	cbz	r0, 1eae0 <lll_adv_pdu_alloc_pdu_adv+0x8c>
   1eac6:	4a19      	ldr	r2, [pc, #100]	; (1eb2c <lll_adv_pdu_alloc_pdu_adv+0xd8>)
   1eac8:	4919      	ldr	r1, [pc, #100]	; (1eb30 <lll_adv_pdu_alloc_pdu_adv+0xdc>)
   1eaca:	481a      	ldr	r0, [pc, #104]	; (1eb34 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
   1eacc:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
   1ead0:	f006 fb74 	bl	251bc <printk>
   1ead4:	4040      	eors	r0, r0
   1ead6:	f380 8811 	msr	BASEPRI, r0
   1eada:	f04f 0003 	mov.w	r0, #3
   1eade:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
   1eae0:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
   1eae2:	78e0      	ldrb	r0, [r4, #3]
	p = MFIFO_DEQUEUE(pdu_free);
   1eae4:	7822      	ldrb	r2, [r4, #0]
   1eae6:	7861      	ldrb	r1, [r4, #1]
   1eae8:	4298      	cmp	r0, r3
   1eaea:	d10d      	bne.n	1eb08 <lll_adv_pdu_alloc_pdu_adv+0xb4>
	LL_ASSERT(p);
   1eaec:	4a0f      	ldr	r2, [pc, #60]	; (1eb2c <lll_adv_pdu_alloc_pdu_adv+0xd8>)
   1eaee:	4913      	ldr	r1, [pc, #76]	; (1eb3c <lll_adv_pdu_alloc_pdu_adv+0xe8>)
   1eaf0:	4810      	ldr	r0, [pc, #64]	; (1eb34 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
   1eaf2:	f240 13ad 	movw	r3, #429	; 0x1ad
   1eaf6:	f006 fb61 	bl	251bc <printk>
   1eafa:	4040      	eors	r0, r0
   1eafc:	f380 8811 	msr	BASEPRI, r0
   1eb00:	f04f 0003 	mov.w	r0, #3
   1eb04:	df02      	svc	2
   1eb06:	e7ce      	b.n	1eaa6 <lll_adv_pdu_alloc_pdu_adv+0x52>
	mem = *((void **)(fifo + _first * size));
   1eb08:	fb03 4202 	mla	r2, r3, r2, r4
	_first += 1U;
   1eb0c:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   1eb0e:	6852      	ldr	r2, [r2, #4]
	_first += 1U;
   1eb10:	b2db      	uxtb	r3, r3
		_first = 0U;
   1eb12:	4299      	cmp	r1, r3
   1eb14:	bf08      	it	eq
   1eb16:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1eb18:	70a3      	strb	r3, [r4, #2]
   1eb1a:	2a00      	cmp	r2, #0
   1eb1c:	d0e6      	beq.n	1eaec <lll_adv_pdu_alloc_pdu_adv+0x98>
   1eb1e:	4615      	mov	r5, r2
   1eb20:	e7c1      	b.n	1eaa6 <lll_adv_pdu_alloc_pdu_adv+0x52>
   1eb22:	bf00      	nop
   1eb24:	20000b14 	.word	0x20000b14
   1eb28:	200034a8 	.word	0x200034a8
   1eb2c:	00034741 	.word	0x00034741
   1eb30:	0003404c 	.word	0x0003404c
   1eb34:	0002f8b5 	.word	0x0002f8b5
   1eb38:	20003404 	.word	0x20003404
   1eb3c:	0002f843 	.word	0x0002f843

0001eb40 <lll_adv_pdu_latest_get>:
{
   1eb40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
   1eb42:	7803      	ldrb	r3, [r0, #0]
	if (first != pdu->last) {
   1eb44:	7842      	ldrb	r2, [r0, #1]
   1eb46:	429a      	cmp	r2, r3
{
   1eb48:	4605      	mov	r5, r0
   1eb4a:	460e      	mov	r6, r1
	first = pdu->first;
   1eb4c:	b2dc      	uxtb	r4, r3
	if (first != pdu->last) {
   1eb4e:	d022      	beq.n	1eb96 <lll_adv_pdu_latest_get+0x56>
			if (!MFIFO_ENQUEUE_IDX_GET(pdu_free, &free_idx)) {
   1eb50:	4a13      	ldr	r2, [pc, #76]	; (1eba0 <lll_adv_pdu_latest_get+0x60>)
   1eb52:	eb00 0784 	add.w	r7, r0, r4, lsl #2
   1eb56:	78d0      	ldrb	r0, [r2, #3]
	if (last == count) {
   1eb58:	f892 e001 	ldrb.w	lr, [r2, #1]
   1eb5c:	f892 c002 	ldrb.w	ip, [r2, #2]
		p = pdu->pdu[pdu_idx];
   1eb60:	6879      	ldr	r1, [r7, #4]
	last = last + 1;
   1eb62:	1c43      	adds	r3, r0, #1
   1eb64:	b2db      	uxtb	r3, r3
		last = 0U;
   1eb66:	459e      	cmp	lr, r3
   1eb68:	bf08      	it	eq
   1eb6a:	2300      	moveq	r3, #0
	if (last == first) {
   1eb6c:	459c      	cmp	ip, r3
   1eb6e:	d009      	beq.n	1eb84 <lll_adv_pdu_latest_get+0x44>
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1eb70:	f892 c000 	ldrb.w	ip, [r2]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1eb74:	fb0c 2000 	mla	r0, ip, r0, r2
   1eb78:	6041      	str	r1, [r0, #4]
	*last = idx; /* Commit: Update write index */
   1eb7a:	70d3      	strb	r3, [r2, #3]
	z_impl_k_sem_give(sem);
   1eb7c:	4809      	ldr	r0, [pc, #36]	; (1eba4 <lll_adv_pdu_latest_get+0x64>)
   1eb7e:	f005 f9e9 	bl	23f54 <z_impl_k_sem_give>
			p = next;
   1eb82:	2100      	movs	r1, #0
		first += 1U;
   1eb84:	3401      	adds	r4, #1
   1eb86:	b2e4      	uxtb	r4, r4
			first = 0U;
   1eb88:	2c02      	cmp	r4, #2
   1eb8a:	bf08      	it	eq
   1eb8c:	2400      	moveq	r4, #0
		*is_modified = 1U;
   1eb8e:	2301      	movs	r3, #1
		pdu->pdu[pdu_idx] = p;
   1eb90:	6079      	str	r1, [r7, #4]
		pdu->first = first;
   1eb92:	702c      	strb	r4, [r5, #0]
		*is_modified = 1U;
   1eb94:	7033      	strb	r3, [r6, #0]
	return (void *)pdu->pdu[first];
   1eb96:	eb05 0484 	add.w	r4, r5, r4, lsl #2
}
   1eb9a:	6860      	ldr	r0, [r4, #4]
   1eb9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1eb9e:	bf00      	nop
   1eba0:	20000b14 	.word	0x20000b14
   1eba4:	200034a8 	.word	0x200034a8

0001eba8 <chan_prepare.isra.0>:
{
	struct pdu_adv *pdu;
	uint8_t chan;
	uint8_t upd;

	chan = find_lsb_set(lll->chan_map_curr);
   1eba8:	7a03      	ldrb	r3, [r0, #8]
	return __builtin_ffs(op);
   1ebaa:	f3c3 1302 	ubfx	r3, r3, #4, #3
static struct pdu_adv *chan_prepare(struct lll_adv *lll)
   1ebae:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1ebb0:	2b00      	cmp	r3, #0
   1ebb2:	4604      	mov	r4, r0
   1ebb4:	fa93 f0a3 	rbit	r0, r3
   1ebb8:	fab0 f080 	clz	r0, r0
   1ebbc:	bf08      	it	eq
   1ebbe:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
   1ebc2:	1c45      	adds	r5, r0, #1
   1ebc4:	d10c      	bne.n	1ebe0 <chan_prepare.isra.0+0x38>
   1ebc6:	4a30      	ldr	r2, [pc, #192]	; (1ec88 <chan_prepare.isra.0+0xe0>)
   1ebc8:	4930      	ldr	r1, [pc, #192]	; (1ec8c <chan_prepare.isra.0+0xe4>)
   1ebca:	4831      	ldr	r0, [pc, #196]	; (1ec90 <chan_prepare.isra.0+0xe8>)
   1ebcc:	f240 5337 	movw	r3, #1335	; 0x537
   1ebd0:	f006 faf4 	bl	251bc <printk>
   1ebd4:	4040      	eors	r0, r0
   1ebd6:	f380 8811 	msr	BASEPRI, r0
   1ebda:	f04f 0003 	mov.w	r0, #3
   1ebde:	df02      	svc	2

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   1ebe0:	7a23      	ldrb	r3, [r4, #8]
   1ebe2:	f3c3 1102 	ubfx	r1, r3, #4, #3
   1ebe6:	1e4a      	subs	r2, r1, #1
   1ebe8:	400a      	ands	r2, r1
   1ebea:	f362 1306 	bfi	r3, r2, #4, #3

	lll_chan_set(36 + chan);
   1ebee:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   1ebf2:	7223      	strb	r3, [r4, #8]
	lll_chan_set(36 + chan);
   1ebf4:	f7ff fc9e 	bl	1e534 <lll_chan_set>

	/* FIXME: get latest only when primary PDU without Aux PDUs */
	upd = 0U;
   1ebf8:	2300      	movs	r3, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT_PDU_EXTRA_DATA_MEMORY */

static inline struct pdu_adv *lll_adv_data_latest_get(struct lll_adv *lll,
						      uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->adv_data, is_modified);
   1ebfa:	f10d 0107 	add.w	r1, sp, #7
   1ebfe:	f104 000c 	add.w	r0, r4, #12
   1ec02:	f88d 3007 	strb.w	r3, [sp, #7]
   1ec06:	f7ff ff9b 	bl	1eb40 <lll_adv_pdu_latest_get>
	pdu = lll_adv_data_latest_get(lll, &upd);
	LL_ASSERT(pdu);
   1ec0a:	4605      	mov	r5, r0
   1ec0c:	b960      	cbnz	r0, 1ec28 <chan_prepare.isra.0+0x80>
   1ec0e:	4a1e      	ldr	r2, [pc, #120]	; (1ec88 <chan_prepare.isra.0+0xe0>)
   1ec10:	4920      	ldr	r1, [pc, #128]	; (1ec94 <chan_prepare.isra.0+0xec>)
   1ec12:	481f      	ldr	r0, [pc, #124]	; (1ec90 <chan_prepare.isra.0+0xe8>)
   1ec14:	f44f 63a8 	mov.w	r3, #1344	; 0x540
   1ec18:	f006 fad0 	bl	251bc <printk>
   1ec1c:	4040      	eors	r0, r0
   1ec1e:	f380 8811 	msr	BASEPRI, r0
   1ec22:	f04f 0003 	mov.w	r0, #3
   1ec26:	df02      	svc	2

	radio_pkt_tx_set(pdu);
   1ec28:	4628      	mov	r0, r5
   1ec2a:	f001 f9e1 	bl	1fff0 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1ec2e:	782b      	ldrb	r3, [r5, #0]
   1ec30:	f003 030f 	and.w	r3, r3, #15
   1ec34:	2b02      	cmp	r3, #2
   1ec36:	d01f      	beq.n	1ec78 <chan_prepare.isra.0+0xd0>
}

static inline struct pdu_adv *lll_adv_scan_rsp_latest_get(struct lll_adv *lll,
							  uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
   1ec38:	f10d 0107 	add.w	r1, sp, #7
   1ec3c:	f104 0018 	add.w	r0, r4, #24
   1ec40:	f7ff ff7e 	bl	1eb40 <lll_adv_pdu_latest_get>
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		struct pdu_adv *scan_pdu;

		scan_pdu = lll_adv_scan_rsp_latest_get(lll, &upd);
		LL_ASSERT(scan_pdu);
   1ec44:	b960      	cbnz	r0, 1ec60 <chan_prepare.isra.0+0xb8>
   1ec46:	4a10      	ldr	r2, [pc, #64]	; (1ec88 <chan_prepare.isra.0+0xe0>)
   1ec48:	4913      	ldr	r1, [pc, #76]	; (1ec98 <chan_prepare.isra.0+0xf0>)
   1ec4a:	4811      	ldr	r0, [pc, #68]	; (1ec90 <chan_prepare.isra.0+0xe8>)
   1ec4c:	f240 534a 	movw	r3, #1354	; 0x54a
   1ec50:	f006 fab4 	bl	251bc <printk>
   1ec54:	4040      	eors	r0, r0
   1ec56:	f380 8811 	msr	BASEPRI, r0
   1ec5a:	f04f 0003 	mov.w	r0, #3
   1ec5e:	df02      	svc	2
#else
		ARG_UNUSED(scan_pdu);
		ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		radio_isr_set(isr_tx, lll);
   1ec60:	480e      	ldr	r0, [pc, #56]	; (1ec9c <chan_prepare.isra.0+0xf4>)
   1ec62:	4621      	mov	r1, r4
   1ec64:	f001 f90e 	bl	1fe84 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1ec68:	2096      	movs	r0, #150	; 0x96
   1ec6a:	f001 fb43 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1ec6e:	2000      	movs	r0, #0
   1ec70:	f001 fa9a 	bl	201a8 <radio_switch_complete_and_rx>
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	return pdu;
}
   1ec74:	b003      	add	sp, #12
   1ec76:	bd30      	pop	{r4, r5, pc}
		radio_isr_set(isr_done, lll);
   1ec78:	4809      	ldr	r0, [pc, #36]	; (1eca0 <chan_prepare.isra.0+0xf8>)
   1ec7a:	4621      	mov	r1, r4
   1ec7c:	f001 f902 	bl	1fe84 <radio_isr_set>
		radio_switch_complete_and_disable();
   1ec80:	f001 faba 	bl	201f8 <radio_switch_complete_and_disable>
	return pdu;
   1ec84:	e7f6      	b.n	1ec74 <chan_prepare.isra.0+0xcc>
   1ec86:	bf00      	nop
   1ec88:	00034741 	.word	0x00034741
   1ec8c:	00034589 	.word	0x00034589
   1ec90:	0002f8b5 	.word	0x0002f8b5
   1ec94:	000347aa 	.word	0x000347aa
   1ec98:	000347a5 	.word	0x000347a5
   1ec9c:	0001e8a1 	.word	0x0001e8a1
   1eca0:	0002b6ff 	.word	0x0002b6ff

0001eca4 <prepare_cb>:
{
   1eca4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	lll = p->param;
   1eca6:	68c4      	ldr	r4, [r0, #12]
	if (unlikely(lll->conn &&
   1eca8:	6863      	ldr	r3, [r4, #4]
{
   1ecaa:	4605      	mov	r5, r0
	if (unlikely(lll->conn &&
   1ecac:	b163      	cbz	r3, 1ecc8 <prepare_cb+0x24>
   1ecae:	f893 3020 	ldrb.w	r3, [r3, #32]
   1ecb2:	079a      	lsls	r2, r3, #30
   1ecb4:	d008      	beq.n	1ecc8 <prepare_cb+0x24>
		radio_isr_set(lll_isr_early_abort, lll);
   1ecb6:	4831      	ldr	r0, [pc, #196]	; (1ed7c <prepare_cb+0xd8>)
   1ecb8:	4621      	mov	r1, r4
		radio_isr_set(isr_abort, lll);
   1ecba:	f001 f8e3 	bl	1fe84 <radio_isr_set>
		radio_disable();
   1ecbe:	f001 f9a9 	bl	20014 <radio_disable>
}
   1ecc2:	2000      	movs	r0, #0
   1ecc4:	b003      	add	sp, #12
   1ecc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   1ecc8:	f001 f8fc 	bl	1fec4 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1eccc:	2000      	movs	r0, #0
   1ecce:	f001 f92d 	bl	1ff2c <radio_tx_power_set>
	radio_phy_set(0, 0);
   1ecd2:	2100      	movs	r1, #0
   1ecd4:	4608      	mov	r0, r1
   1ecd6:	f001 f919 	bl	1ff0c <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
   1ecda:	2200      	movs	r2, #0
   1ecdc:	2125      	movs	r1, #37	; 0x25
   1ecde:	2008      	movs	r0, #8
   1ece0:	f001 f95a 	bl	1ff98 <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   1ece4:	4b26      	ldr	r3, [pc, #152]	; (1ed80 <prepare_cb+0xdc>)
   1ece6:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
   1ece8:	a801      	add	r0, sp, #4
   1ecea:	f001 f93d 	bl	1ff68 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   1ecee:	4925      	ldr	r1, [pc, #148]	; (1ed84 <prepare_cb+0xe0>)
   1ecf0:	f240 605b 	movw	r0, #1627	; 0x65b
   1ecf4:	f001 f9ca 	bl	2008c <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   1ecf8:	7a23      	ldrb	r3, [r4, #8]
   1ecfa:	f3c3 0242 	ubfx	r2, r3, #1, #3
   1ecfe:	f362 1306 	bfi	r3, r2, #4, #3
   1ed02:	7223      	strb	r3, [r4, #8]
	pdu = chan_prepare(lll);
   1ed04:	4620      	mov	r0, r4
   1ed06:	f7ff ff4f 	bl	1eba8 <chan_prepare.isra.0>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
   1ed0a:	7a63      	ldrb	r3, [r4, #9]
   1ed0c:	079b      	lsls	r3, r3, #30
   1ed0e:	d007      	beq.n	1ed20 <prepare_cb+0x7c>
		struct lll_filter *fal = ull_filter_lll_get(true);
   1ed10:	2001      	movs	r0, #1
   1ed12:	f7ff f913 	bl	1df3c <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
   1ed16:	7841      	ldrb	r1, [r0, #1]
   1ed18:	1c82      	adds	r2, r0, #2
   1ed1a:	7800      	ldrb	r0, [r0, #0]
   1ed1c:	f001 fa9c 	bl	20258 <radio_filter_configure>
	ull = HDR_LLL2ULL(lll);
   1ed20:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
   1ed22:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
   1ed24:	4638      	mov	r0, r7
   1ed26:	f00c fc72 	bl	2b60e <lll_event_offset_get>
   1ed2a:	4406      	add	r6, r0
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
   1ed2c:	686a      	ldr	r2, [r5, #4]
   1ed2e:	f106 0109 	add.w	r1, r6, #9
   1ed32:	2001      	movs	r0, #1
   1ed34:	f001 faea 	bl	2030c <radio_tmr_start>
	radio_tmr_end_capture();
   1ed38:	f001 fbb6 	bl	204a8 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   1ed3c:	4620      	mov	r0, r4
   1ed3e:	f7fd fc53 	bl	1c5e8 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_BASE +
   1ed42:	1c81      	adds	r1, r0, #2
   1ed44:	4632      	mov	r2, r6
   1ed46:	b2c9      	uxtb	r1, r1
   1ed48:	4638      	mov	r0, r7
   1ed4a:	f00c fc6e 	bl	2b62a <lll_preempt_calc>
   1ed4e:	b110      	cbz	r0, 1ed56 <prepare_cb+0xb2>
		radio_isr_set(isr_abort, lll);
   1ed50:	480d      	ldr	r0, [pc, #52]	; (1ed88 <prepare_cb+0xe4>)
   1ed52:	4621      	mov	r1, r4
   1ed54:	e7b1      	b.n	1ecba <prepare_cb+0x16>
		ret = lll_prepare_done(lll);
   1ed56:	4620      	mov	r0, r4
   1ed58:	f00c fc54 	bl	2b604 <lll_prepare_done>
		LL_ASSERT(!ret);
   1ed5c:	2800      	cmp	r0, #0
   1ed5e:	d0b0      	beq.n	1ecc2 <prepare_cb+0x1e>
   1ed60:	4a0a      	ldr	r2, [pc, #40]	; (1ed8c <prepare_cb+0xe8>)
   1ed62:	490b      	ldr	r1, [pc, #44]	; (1ed90 <prepare_cb+0xec>)
   1ed64:	480b      	ldr	r0, [pc, #44]	; (1ed94 <prepare_cb+0xf0>)
   1ed66:	f240 33d1 	movw	r3, #977	; 0x3d1
   1ed6a:	f006 fa27 	bl	251bc <printk>
   1ed6e:	4040      	eors	r0, r0
   1ed70:	f380 8811 	msr	BASEPRI, r0
   1ed74:	f04f 0003 	mov.w	r0, #3
   1ed78:	df02      	svc	2
   1ed7a:	e7a2      	b.n	1ecc2 <prepare_cb+0x1e>
   1ed7c:	0001e5ed 	.word	0x0001e5ed
   1ed80:	8e89bed6 	.word	0x8e89bed6
   1ed84:	00555555 	.word	0x00555555
   1ed88:	0002b6a5 	.word	0x0002b6a5
   1ed8c:	00034741 	.word	0x00034741
   1ed90:	000340d7 	.word	0x000340d7
   1ed94:	0002f8b5 	.word	0x0002f8b5

0001ed98 <lll_adv_prepare>:
{
   1ed98:	b513      	push	{r0, r1, r4, lr}
   1ed9a:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1ed9c:	f7ff fd48 	bl	1e830 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   1eda0:	2800      	cmp	r0, #0
   1eda2:	da0c      	bge.n	1edbe <lll_adv_prepare+0x26>
   1eda4:	4a12      	ldr	r2, [pc, #72]	; (1edf0 <lll_adv_prepare+0x58>)
   1eda6:	4913      	ldr	r1, [pc, #76]	; (1edf4 <lll_adv_prepare+0x5c>)
   1eda8:	4813      	ldr	r0, [pc, #76]	; (1edf8 <lll_adv_prepare+0x60>)
   1edaa:	f240 239a 	movw	r3, #666	; 0x29a
   1edae:	f006 fa05 	bl	251bc <printk>
   1edb2:	4040      	eors	r0, r0
   1edb4:	f380 8811 	msr	BASEPRI, r0
   1edb8:	f04f 0003 	mov.w	r0, #3
   1edbc:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
   1edbe:	4a0f      	ldr	r2, [pc, #60]	; (1edfc <lll_adv_prepare+0x64>)
   1edc0:	490f      	ldr	r1, [pc, #60]	; (1ee00 <lll_adv_prepare+0x68>)
   1edc2:	4810      	ldr	r0, [pc, #64]	; (1ee04 <lll_adv_prepare+0x6c>)
   1edc4:	9400      	str	r4, [sp, #0]
   1edc6:	2300      	movs	r3, #0
   1edc8:	f00c f91c 	bl	2b004 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1edcc:	b170      	cbz	r0, 1edec <lll_adv_prepare+0x54>
   1edce:	3077      	adds	r0, #119	; 0x77
   1edd0:	d00c      	beq.n	1edec <lll_adv_prepare+0x54>
   1edd2:	4a07      	ldr	r2, [pc, #28]	; (1edf0 <lll_adv_prepare+0x58>)
   1edd4:	490c      	ldr	r1, [pc, #48]	; (1ee08 <lll_adv_prepare+0x70>)
   1edd6:	4808      	ldr	r0, [pc, #32]	; (1edf8 <lll_adv_prepare+0x60>)
   1edd8:	f240 239d 	movw	r3, #669	; 0x29d
   1eddc:	f006 f9ee 	bl	251bc <printk>
   1ede0:	4040      	eors	r0, r0
   1ede2:	f380 8811 	msr	BASEPRI, r0
   1ede6:	f04f 0003 	mov.w	r0, #3
   1edea:	df02      	svc	2
}
   1edec:	b002      	add	sp, #8
   1edee:	bd10      	pop	{r4, pc}
   1edf0:	00034741 	.word	0x00034741
   1edf4:	000346f1 	.word	0x000346f1
   1edf8:	0002f8b5 	.word	0x0002f8b5
   1edfc:	0001eca5 	.word	0x0001eca5
   1ee00:	0001e9b5 	.word	0x0001e9b5
   1ee04:	0001e94d 	.word	0x0001e94d
   1ee08:	000347ae 	.word	0x000347ae

0001ee0c <isr_rx>:
{
   1ee0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ee10:	b087      	sub	sp, #28
   1ee12:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   1ee14:	f001 f926 	bl	20064 <radio_is_done>
	if (trx_done) {
   1ee18:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
   1ee1c:	d074      	beq.n	1ef08 <isr_rx+0xfc>
		crc_ok = radio_crc_is_valid();
   1ee1e:	f001 f941 	bl	200a4 <radio_crc_is_valid>
   1ee22:	b2c6      	uxtb	r6, r0
		devmatch_ok = radio_filter_has_match();
   1ee24:	f001 fa46 	bl	202b4 <radio_filter_has_match>
   1ee28:	fa5f f880 	uxtb.w	r8, r0
		devmatch_id = radio_filter_match_get();
   1ee2c:	f001 fa4c 	bl	202c8 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   1ee30:	f001 fb66 	bl	20500 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
   1ee34:	f001 fb4c 	bl	204d0 <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
   1ee38:	f001 fa04 	bl	20244 <radio_rssi_is_ready>
	lll_isr_status_reset();
   1ee3c:	f00c fc16 	bl	2b66c <lll_isr_status_reset>
	if (!trx_done) {
   1ee40:	2d00      	cmp	r5, #0
   1ee42:	f000 80bf 	beq.w	1efc4 <isr_rx+0x1b8>
	if (crc_ok) {
   1ee46:	2e00      	cmp	r6, #0
   1ee48:	f000 80bc 	beq.w	1efc4 <isr_rx+0x1b8>
#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
				    FILTER_IDX_NONE;
#else
	uint8_t rl_idx = FILTER_IDX_NONE;
   1ee4c:	23ff      	movs	r3, #255	; 0xff
#endif /* CONFIG_BT_CTLR_PRIVACY */

	node_rx = ull_pdu_rx_alloc_peek(1);
   1ee4e:	2001      	movs	r0, #1
	uint8_t rl_idx = FILTER_IDX_NONE;
   1ee50:	f88d 3017 	strb.w	r3, [sp, #23]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1ee54:	f7fc fda4 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1ee58:	4605      	mov	r5, r0
   1ee5a:	b960      	cbnz	r0, 1ee76 <isr_rx+0x6a>
   1ee5c:	4a5e      	ldr	r2, [pc, #376]	; (1efd8 <isr_rx+0x1cc>)
   1ee5e:	495f      	ldr	r1, [pc, #380]	; (1efdc <isr_rx+0x1d0>)
   1ee60:	485f      	ldr	r0, [pc, #380]	; (1efe0 <isr_rx+0x1d4>)
   1ee62:	f240 537a 	movw	r3, #1402	; 0x57a
   1ee66:	f006 f9a9 	bl	251bc <printk>
   1ee6a:	4040      	eors	r0, r0
   1ee6c:	f380 8811 	msr	BASEPRI, r0
   1ee70:	f04f 0003 	mov.w	r0, #3
   1ee74:	df02      	svc	2
   1ee76:	7b23      	ldrb	r3, [r4, #12]
   1ee78:	eb04 0383 	add.w	r3, r4, r3, lsl #2

	pdu_rx = (void *)node_rx->pdu;
   1ee7c:	f105 0a1c 	add.w	sl, r5, #28
   1ee80:	691e      	ldr	r6, [r3, #16]
	pdu_adv = lll_adv_data_curr_get(lll);

	addr = pdu_adv->adv_ind.addr;
   1ee82:	46b1      	mov	r9, r6
	tx_addr = pdu_adv->tx_addr;
   1ee84:	f819 7b02 	ldrb.w	r7, [r9], #2

	if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   1ee88:	f007 030f 	and.w	r3, r7, #15
   1ee8c:	2b01      	cmp	r3, #1
	} else {
		tgt_addr = NULL;
	}
	rx_addr = pdu_adv->rx_addr;

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1ee8e:	7f2b      	ldrb	r3, [r5, #28]
   1ee90:	f003 030f 	and.w	r3, r3, #15
		tgt_addr = pdu_adv->direct_ind.tgt_addr;
   1ee94:	bf0c      	ite	eq
   1ee96:	3608      	addeq	r6, #8
		tgt_addr = NULL;
   1ee98:	2600      	movne	r6, #0
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1ee9a:	2b03      	cmp	r3, #3
	tx_addr = pdu_adv->tx_addr;
   1ee9c:	f3c7 1b80 	ubfx	fp, r7, #6, #1
	rx_addr = pdu_adv->rx_addr;
   1eea0:	ea4f 17d7 	mov.w	r7, r7, lsr #7
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1eea4:	d133      	bne.n	1ef0e <isr_rx+0x102>
   1eea6:	7f6b      	ldrb	r3, [r5, #29]
   1eea8:	2b0c      	cmp	r3, #12
   1eeaa:	f040 808b 	bne.w	1efc4 <isr_rx+0x1b8>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   1eeae:	2e00      	cmp	r6, #0
   1eeb0:	f040 8088 	bne.w	1efc4 <isr_rx+0x1b8>
	    (tgt_addr == NULL) &&
	    lll_adv_scan_req_check(lll, pdu_rx, tx_addr, addr, devmatch_ok,
   1eeb4:	f10d 0317 	add.w	r3, sp, #23
   1eeb8:	e9cd 8300 	strd	r8, r3, [sp]
   1eebc:	465a      	mov	r2, fp
   1eebe:	464b      	mov	r3, r9
   1eec0:	4651      	mov	r1, sl
   1eec2:	4620      	mov	r0, r4
   1eec4:	f00c fc57 	bl	2b776 <lll_adv_scan_req_check>
	    (tgt_addr == NULL) &&
   1eec8:	b308      	cbz	r0, 1ef0e <isr_rx+0x102>
				    &rl_idx)) {
		radio_isr_set(isr_done, lll);
   1eeca:	4621      	mov	r1, r4
   1eecc:	4845      	ldr	r0, [pc, #276]	; (1efe4 <isr_rx+0x1d8>)
   1eece:	f000 ffd9 	bl	1fe84 <radio_isr_set>
		radio_switch_complete_and_disable();
   1eed2:	f001 f991 	bl	201f8 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   1eed6:	7e20      	ldrb	r0, [r4, #24]
   1eed8:	eb04 0480 	add.w	r4, r4, r0, lsl #2
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   1eedc:	69e0      	ldr	r0, [r4, #28]
   1eede:	f001 f887 	bl	1fff0 <radio_pkt_tx_set>

		/* assert if radio packet ptr is not set and radio started tx */
		LL_ASSERT(!radio_is_ready());
   1eee2:	f001 f8b5 	bl	20050 <radio_is_ready>
   1eee6:	b160      	cbz	r0, 1ef02 <isr_rx+0xf6>
   1eee8:	4a3b      	ldr	r2, [pc, #236]	; (1efd8 <isr_rx+0x1cc>)
   1eeea:	493f      	ldr	r1, [pc, #252]	; (1efe8 <isr_rx+0x1dc>)
   1eeec:	483c      	ldr	r0, [pc, #240]	; (1efe0 <isr_rx+0x1d4>)
   1eeee:	f240 5393 	movw	r3, #1427	; 0x593
   1eef2:	f006 f963 	bl	251bc <printk>
   1eef6:	4040      	eors	r0, r0
   1eef8:	f380 8811 	msr	BASEPRI, r0
   1eefc:	f04f 0003 	mov.w	r0, #3
   1ef00:	df02      	svc	2
}
   1ef02:	b007      	add	sp, #28
   1ef04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   1ef08:	462e      	mov	r6, r5
   1ef0a:	46a8      	mov	r8, r5
   1ef0c:	e796      	b.n	1ee3c <isr_rx+0x30>
	 *       Under this race, peer central would get failed to establish
	 *       connection as the disconnect reason. This is an acceptable
	 *       outcome to keep the thread mode implementation simple when
	 *       disabling connectable advertising.
	 */
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   1ef0e:	7f2b      	ldrb	r3, [r5, #28]
   1ef10:	f003 030f 	and.w	r3, r3, #15
   1ef14:	2b05      	cmp	r3, #5
   1ef16:	d155      	bne.n	1efc4 <isr_rx+0x1b8>
   1ef18:	7f6b      	ldrb	r3, [r5, #29]
   1ef1a:	2b22      	cmp	r3, #34	; 0x22
   1ef1c:	d152      	bne.n	1efc4 <isr_rx+0x1b8>
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
		   lll->conn && !lll->conn->periph.cancelled &&
   1ef1e:	6863      	ldr	r3, [r4, #4]
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   1ef20:	2b00      	cmp	r3, #0
   1ef22:	d04f      	beq.n	1efc4 <isr_rx+0x1b8>
		   lll->conn && !lll->conn->periph.cancelled &&
   1ef24:	f893 3020 	ldrb.w	r3, [r3, #32]
   1ef28:	079b      	lsls	r3, r3, #30
   1ef2a:	d44b      	bmi.n	1efc4 <isr_rx+0x1b8>
		   lll_adv_connect_ind_check(lll, pdu_rx, tx_addr, addr,
   1ef2c:	f10d 0317 	add.w	r3, sp, #23
   1ef30:	e9cd 8302 	strd	r8, r3, [sp, #8]
   1ef34:	e9cd 7600 	strd	r7, r6, [sp]
   1ef38:	464b      	mov	r3, r9
   1ef3a:	465a      	mov	r2, fp
   1ef3c:	4651      	mov	r1, sl
   1ef3e:	4620      	mov	r0, r4
   1ef40:	f00c fc31 	bl	2b7a6 <lll_adv_connect_ind_check>
		   lll->conn && !lll->conn->periph.cancelled &&
   1ef44:	2800      	cmp	r0, #0
   1ef46:	d03d      	beq.n	1efc4 <isr_rx+0x1b8>
		struct node_rx_pdu *rx;

		if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {
			rx = ull_pdu_rx_alloc_peek(4);
		} else {
			rx = ull_pdu_rx_alloc_peek(3);
   1ef48:	2003      	movs	r0, #3
   1ef4a:	f7fc fd29 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
		}

		if (!rx) {
   1ef4e:	2800      	cmp	r0, #0
   1ef50:	d038      	beq.n	1efc4 <isr_rx+0x1b8>
			return -ENOBUFS;
		}

		radio_isr_set(isr_abort, lll);
   1ef52:	4826      	ldr	r0, [pc, #152]	; (1efec <isr_rx+0x1e0>)
   1ef54:	4621      	mov	r1, r4
   1ef56:	f000 ff95 	bl	1fe84 <radio_isr_set>
		radio_disable();
   1ef5a:	f001 f85b 	bl	20014 <radio_disable>

		/* assert if radio started tx */
		LL_ASSERT(!radio_is_ready());
   1ef5e:	f001 f877 	bl	20050 <radio_is_ready>
   1ef62:	b160      	cbz	r0, 1ef7e <isr_rx+0x172>
   1ef64:	4a1c      	ldr	r2, [pc, #112]	; (1efd8 <isr_rx+0x1cc>)
   1ef66:	4920      	ldr	r1, [pc, #128]	; (1efe8 <isr_rx+0x1dc>)
   1ef68:	481d      	ldr	r0, [pc, #116]	; (1efe0 <isr_rx+0x1d4>)
   1ef6a:	f240 53da 	movw	r3, #1498	; 0x5da
   1ef6e:	f006 f925 	bl	251bc <printk>
   1ef72:	4040      	eors	r0, r0
   1ef74:	f380 8811 	msr	BASEPRI, r0
   1ef78:	f04f 0003 	mov.w	r0, #3
   1ef7c:	df02      	svc	2
			lll->conn->rssi_latest =  radio_rssi_get();
		}
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

		/* Stop further LLL radio events */
		lll->conn->periph.initiated = 1;
   1ef7e:	6862      	ldr	r2, [r4, #4]
   1ef80:	f892 3020 	ldrb.w	r3, [r2, #32]
   1ef84:	f043 0301 	orr.w	r3, r3, #1
   1ef88:	f882 3020 	strb.w	r3, [r2, #32]

		rx = ull_pdu_rx_alloc();
   1ef8c:	f7fc fd20 	bl	1b9d0 <ull_pdu_rx_alloc>

		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1ef90:	2316      	movs	r3, #22
   1ef92:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   1ef94:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1ef98:	80c3      	strh	r3, [r0, #6]

		ftr = &(rx->hdr.rx_ftr);
		ftr->param = lll;
   1ef9a:	6084      	str	r4, [r0, #8]
		rx = ull_pdu_rx_alloc();
   1ef9c:	4605      	mov	r5, r0
		ftr->ticks_anchor = radio_tmr_start_get();
   1ef9e:	f001 fa39 	bl	20414 <radio_tmr_start_get>
   1efa2:	6128      	str	r0, [r5, #16]
		ftr->radio_end_us = radio_tmr_end_get() -
   1efa4:	f001 fa88 	bl	204b8 <radio_tmr_end_get>
				    radio_rx_chain_delay_get(0, 0);
   1efa8:	2100      	movs	r1, #0
		ftr->radio_end_us = radio_tmr_end_get() -
   1efaa:	4604      	mov	r4, r0
				    radio_rx_chain_delay_get(0, 0);
   1efac:	4608      	mov	r0, r1
   1efae:	f00c fd7e 	bl	2baae <radio_rx_chain_delay_get>
		ftr->radio_end_us = radio_tmr_end_get() -
   1efb2:	1a24      	subs	r4, r4, r0

		if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {
			ftr->extra = ull_pdu_rx_alloc();
		}

		ull_rx_put(rx->hdr.link, rx);
   1efb4:	4629      	mov	r1, r5
   1efb6:	6828      	ldr	r0, [r5, #0]
		ftr->radio_end_us = radio_tmr_end_get() -
   1efb8:	616c      	str	r4, [r5, #20]
		ull_rx_put(rx->hdr.link, rx);
   1efba:	f7fc fd1f 	bl	1b9fc <ull_rx_put>
		ull_rx_sched();
   1efbe:	f7fc fd2d 	bl	1ba1c <ull_rx_sched>
		if (!err) {
   1efc2:	e79e      	b.n	1ef02 <isr_rx+0xf6>
	radio_isr_set(isr_done, param);
   1efc4:	4807      	ldr	r0, [pc, #28]	; (1efe4 <isr_rx+0x1d8>)
   1efc6:	4621      	mov	r1, r4
   1efc8:	f000 ff5c 	bl	1fe84 <radio_isr_set>
}
   1efcc:	b007      	add	sp, #28
   1efce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	radio_disable();
   1efd2:	f001 b81f 	b.w	20014 <radio_disable>
   1efd6:	bf00      	nop
   1efd8:	00034741 	.word	0x00034741
   1efdc:	0003478b 	.word	0x0003478b
   1efe0:	0002f8b5 	.word	0x0002f8b5
   1efe4:	0002b6ff 	.word	0x0002b6ff
   1efe8:	00034793 	.word	0x00034793
   1efec:	0002b6a5 	.word	0x0002b6a5

0001eff0 <common_prepare_cb>:

	return common_prepare_cb(p, true);
}

static int common_prepare_cb(struct lll_prepare_param *p, bool is_resume)
{
   1eff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t remainder;
	uint32_t aa;

	DEBUG_RADIO_START_O(1);

	lll = p->param;
   1eff4:	68c4      	ldr	r4, [r0, #12]
		return 0;
	}
#endif /* CONFIG_BT_CENTRAL */

	/* Initialize scanning state */
	lll->state = 0U;
   1eff6:	7923      	ldrb	r3, [r4, #4]
   1eff8:	f36f 0300 	bfc	r3, #0, #1
{
   1effc:	b08c      	sub	sp, #48	; 0x30
	lll->state = 0U;
   1effe:	7123      	strb	r3, [r4, #4]
{
   1f000:	460d      	mov	r5, r1
   1f002:	4607      	mov	r7, r0

	radio_reset();
   1f004:	f000 ff5e 	bl	1fec4 <radio_reset>

#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1f008:	2000      	movs	r0, #0
   1f00a:	f000 ff8f 	bl	1ff2c <radio_tx_power_set>
			    RADIO_PKT_CONF_PHY(lll->phy));

	lll->is_adv_ind = 0U;
	lll->is_aux_sched = 0U;
#else /* !CONFIG_BT_CTLR_ADV_EXT */
	radio_phy_set(0, 0);
   1f00e:	2100      	movs	r1, #0
   1f010:	4608      	mov	r0, r1
   1f012:	f000 ff7b 	bl	1ff0c <radio_phy_set>
	radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, PDU_AC_LEG_PAYLOAD_SIZE_MAX,
   1f016:	2200      	movs	r2, #0
   1f018:	2125      	movs	r1, #37	; 0x25
   1f01a:	2008      	movs	r0, #8
   1f01c:	f000 ffbc 	bl	1ff98 <radio_pkt_configure>
			    RADIO_PKT_CONF_PHY(RADIO_PKT_CONF_PHY_LEGACY));
#endif /* !CONFIG_BT_CTLR_ADV_EXT */

	node_rx = ull_pdu_rx_alloc_peek(1);
   1f020:	2001      	movs	r0, #1
   1f022:	f7fc fcbd 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f026:	4606      	mov	r6, r0
   1f028:	b960      	cbnz	r0, 1f044 <common_prepare_cb+0x54>
   1f02a:	4a4e      	ldr	r2, [pc, #312]	; (1f164 <common_prepare_cb+0x174>)
   1f02c:	494e      	ldr	r1, [pc, #312]	; (1f168 <common_prepare_cb+0x178>)
   1f02e:	484f      	ldr	r0, [pc, #316]	; (1f16c <common_prepare_cb+0x17c>)
   1f030:	f240 138d 	movw	r3, #397	; 0x18d
   1f034:	f006 f8c2 	bl	251bc <printk>
   1f038:	4040      	eors	r0, r0
   1f03a:	f380 8811 	msr	BASEPRI, r0
   1f03e:	f04f 0003 	mov.w	r0, #3
   1f042:	df02      	svc	2

	radio_pkt_rx_set(node_rx->pdu);
   1f044:	f106 001c 	add.w	r0, r6, #28
   1f048:	f000 ffcc 	bl	1ffe4 <radio_pkt_rx_set>

	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
   1f04c:	4b48      	ldr	r3, [pc, #288]	; (1f170 <common_prepare_cb+0x180>)
   1f04e:	930b      	str	r3, [sp, #44]	; 0x2c
	radio_aa_set((uint8_t *)&aa);
   1f050:	a80b      	add	r0, sp, #44	; 0x2c
   1f052:	f000 ff89 	bl	1ff68 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   1f056:	4947      	ldr	r1, [pc, #284]	; (1f174 <common_prepare_cb+0x184>)
   1f058:	f240 605b 	movw	r0, #1627	; 0x65b
   1f05c:	f001 f816 	bl	2008c <radio_crc_configure>
					PDU_AC_CRC_IV);

	lll_chan_set(37 + lll->chan);
   1f060:	7920      	ldrb	r0, [r4, #4]
   1f062:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1f066:	3025      	adds	r0, #37	; 0x25
   1f068:	f7ff fa64 	bl	1e534 <lll_chan_set>

	radio_isr_set(isr_rx, lll);
   1f06c:	4842      	ldr	r0, [pc, #264]	; (1f178 <common_prepare_cb+0x188>)
   1f06e:	4621      	mov	r1, r4
   1f070:	f000 ff08 	bl	1fe84 <radio_isr_set>

	/* setup tIFS switching */
	if (0) {
	} else if (lll->type ||
   1f074:	7923      	ldrb	r3, [r4, #4]
   1f076:	069b      	lsls	r3, r3, #26
   1f078:	d539      	bpl.n	1f0ee <common_prepare_cb+0xfe>
#if defined(CONFIG_BT_CENTRAL)
		   lll->conn) {
#else /* !CONFIG_BT_CENTRAL */
		   0) {
#endif /* !CONFIG_BT_CENTRAL */
		radio_tmr_tifs_set(EVENT_IFS_US);
   1f07a:	2096      	movs	r0, #150	; 0x96
   1f07c:	f001 f93a 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
   1f080:	2300      	movs	r3, #0
   1f082:	461a      	mov	r2, r3
   1f084:	4619      	mov	r1, r3
   1f086:	4618      	mov	r0, r3
   1f088:	f001 f8a2 	bl	201d0 <radio_switch_complete_and_tx>
		radio_ar_configure(count, irks, 0);
#endif
	} else
#endif /* CONFIG_BT_CTLR_PRIVACY */

	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
   1f08c:	7923      	ldrb	r3, [r4, #4]
   1f08e:	f013 0f18 	tst.w	r3, #24
   1f092:	d007      	beq.n	1f0a4 <common_prepare_cb+0xb4>
		/* Setup Radio Filter */
		struct lll_filter *fal = ull_filter_lll_get(true);
   1f094:	2001      	movs	r0, #1
   1f096:	f7fe ff51 	bl	1df3c <ull_filter_lll_get>

		radio_filter_configure(fal->enable_bitmask,
   1f09a:	7841      	ldrb	r1, [r0, #1]
   1f09c:	1c82      	adds	r2, r0, #2
   1f09e:	7800      	ldrb	r0, [r0, #0]
   1f0a0:	f001 f8da 	bl	20258 <radio_filter_configure>
				       fal->addr_type_bitmask,
				       (uint8_t *)fal->bdaddr);
	}

	ticks_at_event = p->ticks_at_expire;
	ull = HDR_LLL2ULL(lll);
   1f0a4:	f8d4 8000 	ldr.w	r8, [r4]
	ticks_at_event = p->ticks_at_expire;
   1f0a8:	683e      	ldr	r6, [r7, #0]
	ticks_at_event += lll_event_offset_get(ull);
   1f0aa:	4640      	mov	r0, r8
   1f0ac:	f00c faaf 	bl	2b60e <lll_event_offset_get>
   1f0b0:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = p->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1f0b2:	687a      	ldr	r2, [r7, #4]
   1f0b4:	f106 0109 	add.w	r1, r6, #9
   1f0b8:	2000      	movs	r0, #0
   1f0ba:	f001 f927 	bl	2030c <radio_tmr_start>

	/* capture end of Rx-ed PDU, for initiator to calculate first
	 * central event or extended scan to schedule auxiliary channel
	 * reception.
	 */
	radio_tmr_end_capture();
   1f0be:	f001 f9f3 	bl	204a8 <radio_tmr_end_capture>

	/* scanner always measures RSSI */
	radio_rssi_measure();
   1f0c2:	f001 f8a7 	bl	20214 <radio_rssi_measure>

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_BASE +
				   ull_scan_lll_handle_get(lll)),
   1f0c6:	4620      	mov	r0, r4
   1f0c8:	f7fd fbbc 	bl	1c844 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_BASE +
   1f0cc:	1d01      	adds	r1, r0, #4
   1f0ce:	4632      	mov	r2, r6
   1f0d0:	b2c9      	uxtb	r1, r1
   1f0d2:	4640      	mov	r0, r8
   1f0d4:	f00c faa9 	bl	2b62a <lll_preempt_calc>
   1f0d8:	b160      	cbz	r0, 1f0f4 <common_prepare_cb+0x104>
			     ticks_at_event)) {
		radio_isr_set(isr_abort, lll);
   1f0da:	4828      	ldr	r0, [pc, #160]	; (1f17c <common_prepare_cb+0x18c>)
   1f0dc:	4621      	mov	r1, r4
   1f0de:	f000 fed1 	bl	1fe84 <radio_isr_set>
		radio_disable();
   1f0e2:	f000 ff97 	bl	20014 <radio_disable>
	}

	DEBUG_RADIO_START_O(1);

	return 0;
}
   1f0e6:	2000      	movs	r0, #0
   1f0e8:	b00c      	add	sp, #48	; 0x30
   1f0ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		radio_switch_complete_and_disable();
   1f0ee:	f001 f883 	bl	201f8 <radio_switch_complete_and_disable>
   1f0f2:	e7cb      	b.n	1f08c <common_prepare_cb+0x9c>
		if (!is_resume && lll->ticks_window) {
   1f0f4:	bb1d      	cbnz	r5, 1f13e <common_prepare_cb+0x14e>
   1f0f6:	6923      	ldr	r3, [r4, #16]
   1f0f8:	b30b      	cbz	r3, 1f13e <common_prepare_cb+0x14e>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1f0fa:	f44f 72fd 	mov.w	r2, #506	; 0x1fa
   1f0fe:	9208      	str	r2, [sp, #32]
   1f100:	4a1f      	ldr	r2, [pc, #124]	; (1f180 <common_prepare_cb+0x190>)
   1f102:	e9cd 4206 	strd	r4, r2, [sp, #24]
   1f106:	4a1f      	ldr	r2, [pc, #124]	; (1f184 <common_prepare_cb+0x194>)
   1f108:	e9cd 3500 	strd	r3, r5, [sp]
   1f10c:	e9cd 5204 	strd	r5, r2, [sp, #16]
   1f110:	4633      	mov	r3, r6
   1f112:	e9cd 5502 	strd	r5, r5, [sp, #8]
   1f116:	2203      	movs	r2, #3
   1f118:	4629      	mov	r1, r5
   1f11a:	f00b fe6a 	bl	2adf2 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1f11e:	f030 0302 	bics.w	r3, r0, #2
   1f122:	d00c      	beq.n	1f13e <common_prepare_cb+0x14e>
   1f124:	4a0f      	ldr	r2, [pc, #60]	; (1f164 <common_prepare_cb+0x174>)
   1f126:	4918      	ldr	r1, [pc, #96]	; (1f188 <common_prepare_cb+0x198>)
   1f128:	4810      	ldr	r0, [pc, #64]	; (1f16c <common_prepare_cb+0x17c>)
   1f12a:	f240 13fb 	movw	r3, #507	; 0x1fb
   1f12e:	f006 f845 	bl	251bc <printk>
   1f132:	4040      	eors	r0, r0
   1f134:	f380 8811 	msr	BASEPRI, r0
   1f138:	f04f 0003 	mov.w	r0, #3
   1f13c:	df02      	svc	2
		ret = lll_prepare_done(lll);
   1f13e:	4620      	mov	r0, r4
   1f140:	f00c fa60 	bl	2b604 <lll_prepare_done>
		LL_ASSERT(!ret);
   1f144:	2800      	cmp	r0, #0
   1f146:	d0ce      	beq.n	1f0e6 <common_prepare_cb+0xf6>
   1f148:	4a06      	ldr	r2, [pc, #24]	; (1f164 <common_prepare_cb+0x174>)
   1f14a:	4910      	ldr	r1, [pc, #64]	; (1f18c <common_prepare_cb+0x19c>)
   1f14c:	4807      	ldr	r0, [pc, #28]	; (1f16c <common_prepare_cb+0x17c>)
   1f14e:	f44f 7305 	mov.w	r3, #532	; 0x214
   1f152:	f006 f833 	bl	251bc <printk>
   1f156:	4040      	eors	r0, r0
   1f158:	f380 8811 	msr	BASEPRI, r0
   1f15c:	f04f 0003 	mov.w	r0, #3
   1f160:	df02      	svc	2
   1f162:	e7c0      	b.n	1f0e6 <common_prepare_cb+0xf6>
   1f164:	000347d2 	.word	0x000347d2
   1f168:	0003478b 	.word	0x0003478b
   1f16c:	0002f8b5 	.word	0x0002f8b5
   1f170:	8e89bed6 	.word	0x8e89bed6
   1f174:	00555555 	.word	0x00555555
   1f178:	0001f3c5 	.word	0x0001f3c5
   1f17c:	0002b823 	.word	0x0002b823
   1f180:	0001f2a9 	.word	0x0001f2a9
   1f184:	0001f335 	.word	0x0001f335
   1f188:	000341e5 	.word	0x000341e5
   1f18c:	000340d7 	.word	0x000340d7

0001f190 <isr_common_done>:

	radio_isr_set(isr_rx, param);
}

static void isr_common_done(void *param)
{
   1f190:	b538      	push	{r3, r4, r5, lr}
   1f192:	4604      	mov	r4, r0
	struct node_rx_pdu *node_rx;
	struct lll_scan *lll;

	/* Clear radio status and events */
	lll_isr_status_reset();
   1f194:	f00c fa6a 	bl	2b66c <lll_isr_status_reset>

	/* Reset scanning state */
	lll = param;
	lll->state = 0U;
   1f198:	7923      	ldrb	r3, [r4, #4]
   1f19a:	f36f 0300 	bfc	r3, #0, #1
   1f19e:	7123      	strb	r3, [r4, #4]
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	/* setup tIFS switching */
	if (0) {
		/* TODO: Add Rx-Rx switch usecase improvement in the future */
	} else if (lll->type ||
   1f1a0:	069b      	lsls	r3, r3, #26
   1f1a2:	d526      	bpl.n	1f1f2 <isr_common_done+0x62>
#if defined(CONFIG_BT_CENTRAL)
		   lll->conn) {
#else /* !CONFIG_BT_CENTRAL */
		   0) {
#endif /* !CONFIG_BT_CENTRAL */
		radio_tmr_tifs_set(EVENT_IFS_US);
   1f1a4:	2096      	movs	r0, #150	; 0x96
   1f1a6:	f001 f8a5 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
   1f1aa:	2300      	movs	r3, #0
   1f1ac:	461a      	mov	r2, r3
   1f1ae:	4619      	mov	r1, r3
   1f1b0:	4618      	mov	r0, r3
   1f1b2:	f001 f80d 	bl	201d0 <radio_switch_complete_and_tx>
	} else {
		radio_switch_complete_and_disable();
	}

	node_rx = ull_pdu_rx_alloc_peek(1);
   1f1b6:	2001      	movs	r0, #1
   1f1b8:	f7fc fbf2 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f1bc:	4605      	mov	r5, r0
   1f1be:	b960      	cbnz	r0, 1f1da <isr_common_done+0x4a>
   1f1c0:	4a0d      	ldr	r2, [pc, #52]	; (1f1f8 <isr_common_done+0x68>)
   1f1c2:	490e      	ldr	r1, [pc, #56]	; (1f1fc <isr_common_done+0x6c>)
   1f1c4:	480e      	ldr	r0, [pc, #56]	; (1f200 <isr_common_done+0x70>)
   1f1c6:	f44f 7352 	mov.w	r3, #840	; 0x348
   1f1ca:	f005 fff7 	bl	251bc <printk>
   1f1ce:	4040      	eors	r0, r0
   1f1d0:	f380 8811 	msr	BASEPRI, r0
   1f1d4:	f04f 0003 	mov.w	r0, #3
   1f1d8:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1f1da:	f105 001c 	add.w	r0, r5, #28
   1f1de:	f000 ff01 	bl	1ffe4 <radio_pkt_rx_set>
		radio_ar_configure(count, irks, 0);
#endif
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	radio_rssi_measure();
   1f1e2:	f001 f817 	bl	20214 <radio_rssi_measure>

	radio_isr_set(isr_rx, param);
   1f1e6:	4621      	mov	r1, r4
   1f1e8:	4806      	ldr	r0, [pc, #24]	; (1f204 <isr_common_done+0x74>)
}
   1f1ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(isr_rx, param);
   1f1ee:	f000 be49 	b.w	1fe84 <radio_isr_set>
		radio_switch_complete_and_disable();
   1f1f2:	f001 f801 	bl	201f8 <radio_switch_complete_and_disable>
   1f1f6:	e7de      	b.n	1f1b6 <isr_common_done+0x26>
   1f1f8:	000347d2 	.word	0x000347d2
   1f1fc:	0003478b 	.word	0x0003478b
   1f200:	0002f8b5 	.word	0x0002f8b5
   1f204:	0001f3c5 	.word	0x0001f3c5

0001f208 <isr_tx>:
{
   1f208:	b570      	push	{r4, r5, r6, lr}
   1f20a:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
   1f20c:	f00c fa1e 	bl	2b64c <lll_isr_tx_status_reset>
	radio_switch_complete_and_disable();
   1f210:	f000 fff2 	bl	201f8 <radio_switch_complete_and_disable>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1f214:	2001      	movs	r0, #1
   1f216:	f7fc fbc3 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f21a:	4604      	mov	r4, r0
   1f21c:	b960      	cbnz	r0, 1f238 <isr_tx+0x30>
   1f21e:	4a1d      	ldr	r2, [pc, #116]	; (1f294 <isr_tx+0x8c>)
   1f220:	491d      	ldr	r1, [pc, #116]	; (1f298 <isr_tx+0x90>)
   1f222:	481e      	ldr	r0, [pc, #120]	; (1f29c <isr_tx+0x94>)
   1f224:	f240 3302 	movw	r3, #770	; 0x302
   1f228:	f005 ffc8 	bl	251bc <printk>
   1f22c:	4040      	eors	r0, r0
   1f22e:	f380 8811 	msr	BASEPRI, r0
   1f232:	f04f 0003 	mov.w	r0, #3
   1f236:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
   1f238:	f104 001c 	add.w	r0, r4, #28
   1f23c:	f000 fed2 	bl	1ffe4 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1f240:	f000 ff06 	bl	20050 <radio_is_ready>
   1f244:	b160      	cbz	r0, 1f260 <isr_tx+0x58>
   1f246:	4a13      	ldr	r2, [pc, #76]	; (1f294 <isr_tx+0x8c>)
   1f248:	4915      	ldr	r1, [pc, #84]	; (1f2a0 <isr_tx+0x98>)
   1f24a:	4814      	ldr	r0, [pc, #80]	; (1f29c <isr_tx+0x94>)
   1f24c:	f240 3306 	movw	r3, #774	; 0x306
   1f250:	f005 ffb4 	bl	251bc <printk>
   1f254:	4040      	eors	r0, r0
   1f256:	f380 8811 	msr	BASEPRI, r0
   1f25a:	f04f 0003 	mov.w	r0, #3
   1f25e:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1f260:	f001 f930 	bl	204c4 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1f264:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1f266:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f268:	4608      	mov	r0, r1
   1f26a:	f00c fc20 	bl	2baae <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f26e:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f270:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f272:	4608      	mov	r0, r1
   1f274:	f00c fc17 	bl	2baa6 <radio_tx_chain_delay_get>
   1f278:	4434      	add	r4, r6
   1f27a:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1f27c:	1a20      	subs	r0, r4, r0
   1f27e:	f001 f8db 	bl	20438 <radio_tmr_hcto_configure>
	radio_rssi_measure();
   1f282:	f000 ffc7 	bl	20214 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
   1f286:	4629      	mov	r1, r5
   1f288:	4806      	ldr	r0, [pc, #24]	; (1f2a4 <isr_tx+0x9c>)
}
   1f28a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(isr_rx, param);
   1f28e:	f000 bdf9 	b.w	1fe84 <radio_isr_set>
   1f292:	bf00      	nop
   1f294:	000347d2 	.word	0x000347d2
   1f298:	0003478b 	.word	0x0003478b
   1f29c:	0002f8b5 	.word	0x0002f8b5
   1f2a0:	00034793 	.word	0x00034793
   1f2a4:	0001f3c5 	.word	0x0001f3c5

0001f2a8 <ticker_op_start_cb>:
{
   1f2a8:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1f2aa:	b160      	cbz	r0, 1f2c6 <ticker_op_start_cb+0x1e>
   1f2ac:	4a06      	ldr	r2, [pc, #24]	; (1f2c8 <ticker_op_start_cb+0x20>)
   1f2ae:	4907      	ldr	r1, [pc, #28]	; (1f2cc <ticker_op_start_cb+0x24>)
   1f2b0:	4807      	ldr	r0, [pc, #28]	; (1f2d0 <ticker_op_start_cb+0x28>)
   1f2b2:	f44f 7324 	mov.w	r3, #656	; 0x290
   1f2b6:	f005 ff81 	bl	251bc <printk>
   1f2ba:	4040      	eors	r0, r0
   1f2bc:	f380 8811 	msr	BASEPRI, r0
   1f2c0:	f04f 0003 	mov.w	r0, #3
   1f2c4:	df02      	svc	2
}
   1f2c6:	bd08      	pop	{r3, pc}
   1f2c8:	000347d2 	.word	0x000347d2
   1f2cc:	0003452f 	.word	0x0003452f
   1f2d0:	0002f8b5 	.word	0x0002f8b5

0001f2d4 <is_abort_cb>:
	if (next != curr) {
   1f2d4:	4281      	cmp	r1, r0
{
   1f2d6:	b508      	push	{r3, lr}
	if (next != curr) {
   1f2d8:	d017      	beq.n	1f30a <is_abort_cb+0x36>
			if (!lll->ticks_window) {
   1f2da:	690b      	ldr	r3, [r1, #16]
   1f2dc:	b9e3      	cbnz	r3, 1f318 <is_abort_cb+0x44>
				*resume_cb = resume_prepare_cb;
   1f2de:	4b10      	ldr	r3, [pc, #64]	; (1f320 <is_abort_cb+0x4c>)
   1f2e0:	6013      	str	r3, [r2, #0]
				err = lll_hfclock_on();
   1f2e2:	f7ff faa5 	bl	1e830 <lll_hfclock_on>
				LL_ASSERT(err >= 0);
   1f2e6:	2800      	cmp	r0, #0
   1f2e8:	da0c      	bge.n	1f304 <is_abort_cb+0x30>
   1f2ea:	4a0e      	ldr	r2, [pc, #56]	; (1f324 <is_abort_cb+0x50>)
   1f2ec:	490e      	ldr	r1, [pc, #56]	; (1f328 <is_abort_cb+0x54>)
   1f2ee:	480f      	ldr	r0, [pc, #60]	; (1f32c <is_abort_cb+0x58>)
   1f2f0:	f240 2332 	movw	r3, #562	; 0x232
   1f2f4:	f005 ff62 	bl	251bc <printk>
   1f2f8:	4040      	eors	r0, r0
   1f2fa:	f380 8811 	msr	BASEPRI, r0
   1f2fe:	f04f 0003 	mov.w	r0, #3
   1f302:	df02      	svc	2
				return -EAGAIN;
   1f304:	f06f 000a 	mvn.w	r0, #10
   1f308:	e005      	b.n	1f316 <is_abort_cb+0x42>
		radio_isr_set(isr_window, lll);
   1f30a:	4809      	ldr	r0, [pc, #36]	; (1f330 <is_abort_cb+0x5c>)
   1f30c:	f000 fdba 	bl	1fe84 <radio_isr_set>
	radio_disable();
   1f310:	f000 fe80 	bl	20014 <radio_disable>
   1f314:	2000      	movs	r0, #0
}
   1f316:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   1f318:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   1f31c:	e7fb      	b.n	1f316 <is_abort_cb+0x42>
   1f31e:	bf00      	nop
   1f320:	0002b887 	.word	0x0002b887
   1f324:	000347d2 	.word	0x000347d2
   1f328:	000346f1 	.word	0x000346f1
   1f32c:	0002f8b5 	.word	0x0002f8b5
   1f330:	0002b84b 	.word	0x0002b84b

0001f334 <ticker_stop_cb>:
{
   1f334:	b508      	push	{r3, lr}
	mfy.param = param;
   1f336:	4b0b      	ldr	r3, [pc, #44]	; (1f364 <ticker_stop_cb+0x30>)
   1f338:	9a03      	ldr	r2, [sp, #12]
   1f33a:	609a      	str	r2, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1f33c:	2200      	movs	r2, #0
   1f33e:	4611      	mov	r1, r2
   1f340:	2001      	movs	r0, #1
   1f342:	f7fa f88b 	bl	1945c <mayfly_enqueue>
	LL_ASSERT(!ret);
   1f346:	b160      	cbz	r0, 1f362 <ticker_stop_cb+0x2e>
   1f348:	4a07      	ldr	r2, [pc, #28]	; (1f368 <ticker_stop_cb+0x34>)
   1f34a:	4908      	ldr	r1, [pc, #32]	; (1f36c <ticker_stop_cb+0x38>)
   1f34c:	4808      	ldr	r0, [pc, #32]	; (1f370 <ticker_stop_cb+0x3c>)
   1f34e:	f240 2389 	movw	r3, #649	; 0x289
   1f352:	f005 ff33 	bl	251bc <printk>
   1f356:	4040      	eors	r0, r0
   1f358:	f380 8811 	msr	BASEPRI, r0
   1f35c:	f04f 0003 	mov.w	r0, #3
   1f360:	df02      	svc	2
}
   1f362:	bd08      	pop	{r3, pc}
   1f364:	20000b24 	.word	0x20000b24
   1f368:	000347d2 	.word	0x000347d2
   1f36c:	000340d7 	.word	0x000340d7
   1f370:	0002f8b5 	.word	0x0002f8b5

0001f374 <abort_cb>:
{
   1f374:	b510      	push	{r4, lr}
   1f376:	460c      	mov	r4, r1
	if (!prepare_param) {
   1f378:	b930      	cbnz	r0, 1f388 <abort_cb+0x14>
			radio_isr_set(isr_done_cleanup, param);
   1f37a:	480e      	ldr	r0, [pc, #56]	; (1f3b4 <abort_cb+0x40>)
   1f37c:	f000 fd82 	bl	1fe84 <radio_isr_set>
}
   1f380:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
   1f384:	f000 be46 	b.w	20014 <radio_disable>
	err = lll_hfclock_off();
   1f388:	f7ff fa68 	bl	1e85c <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   1f38c:	2800      	cmp	r0, #0
   1f38e:	da0c      	bge.n	1f3aa <abort_cb+0x36>
   1f390:	4a09      	ldr	r2, [pc, #36]	; (1f3b8 <abort_cb+0x44>)
   1f392:	490a      	ldr	r1, [pc, #40]	; (1f3bc <abort_cb+0x48>)
   1f394:	480a      	ldr	r0, [pc, #40]	; (1f3c0 <abort_cb+0x4c>)
   1f396:	f240 2379 	movw	r3, #633	; 0x279
   1f39a:	f005 ff0f 	bl	251bc <printk>
   1f39e:	4040      	eors	r0, r0
   1f3a0:	f380 8811 	msr	BASEPRI, r0
   1f3a4:	f04f 0003 	mov.w	r0, #3
   1f3a8:	df02      	svc	2
	lll_done(param);
   1f3aa:	4620      	mov	r0, r4
}
   1f3ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1f3b0:	f7ff b864 	b.w	1e47c <lll_done>
   1f3b4:	0002b8b1 	.word	0x0002b8b1
   1f3b8:	000347d2 	.word	0x000347d2
   1f3bc:	000346f1 	.word	0x000346f1
   1f3c0:	0002f8b5 	.word	0x0002f8b5

0001f3c4 <isr_rx>:
{
   1f3c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f3c8:	4605      	mov	r5, r0
	trx_done = radio_is_done();
   1f3ca:	f000 fe4b 	bl	20064 <radio_is_done>
	if (trx_done) {
   1f3ce:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
   1f3d2:	f000 80a3 	beq.w	1f51c <isr_rx+0x158>
		crc_ok = radio_crc_is_valid();
   1f3d6:	f000 fe65 	bl	200a4 <radio_crc_is_valid>
   1f3da:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
   1f3de:	f000 ff69 	bl	202b4 <radio_filter_has_match>
   1f3e2:	b2c6      	uxtb	r6, r0
		devmatch_id = radio_filter_match_get();
   1f3e4:	f000 ff70 	bl	202c8 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   1f3e8:	f001 f88a 	bl	20500 <radio_ar_has_match>
		irkmatch_id = radio_ar_match_get();
   1f3ec:	f001 f870 	bl	204d0 <radio_ar_match_get>
		rssi_ready = radio_rssi_is_ready();
   1f3f0:	f000 ff28 	bl	20244 <radio_rssi_is_ready>
   1f3f4:	b2c7      	uxtb	r7, r0
		phy_flags_rx = radio_phy_flags_rx_get();
   1f3f6:	f00c fb5f 	bl	2bab8 <radio_phy_flags_rx_get>
	lll_isr_status_reset();
   1f3fa:	f00c f937 	bl	2b66c <lll_isr_status_reset>
	if (!trx_done || !crc_ok) {
   1f3fe:	2c00      	cmp	r4, #0
   1f400:	f000 80c1 	beq.w	1f586 <isr_rx+0x1c2>
   1f404:	f1b8 0f00 	cmp.w	r8, #0
   1f408:	f000 80bd 	beq.w	1f586 <isr_rx+0x1c2>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1f40c:	2001      	movs	r0, #1
   1f40e:	f7fc fac7 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f412:	4604      	mov	r4, r0
   1f414:	b960      	cbnz	r0, 1f430 <isr_rx+0x6c>
   1f416:	4a7e      	ldr	r2, [pc, #504]	; (1f610 <isr_rx+0x24c>)
   1f418:	497e      	ldr	r1, [pc, #504]	; (1f614 <isr_rx+0x250>)
   1f41a:	487f      	ldr	r0, [pc, #508]	; (1f618 <isr_rx+0x254>)
   1f41c:	f240 23c3 	movw	r3, #707	; 0x2c3
   1f420:	f005 fecc 	bl	251bc <printk>
   1f424:	4040      	eors	r0, r0
   1f426:	f380 8811 	msr	BASEPRI, r0
   1f42a:	f04f 0003 	mov.w	r0, #3
   1f42e:	df02      	svc	2
	return ((lll->filter_policy & SCAN_FP_FILTER) == 0U) ||
   1f430:	792a      	ldrb	r2, [r5, #4]
   1f432:	0713      	lsls	r3, r2, #28
   1f434:	d502      	bpl.n	1f43c <isr_rx+0x78>
	if (has_adva &&
   1f436:	2e00      	cmp	r6, #0
   1f438:	f000 80a5 	beq.w	1f586 <isr_rx+0x1c2>

		return 0;
#endif /* CONFIG_BT_CENTRAL */

	/* Active scanner */
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1f43c:	7f23      	ldrb	r3, [r4, #28]
   1f43e:	f013 010f 	ands.w	r1, r3, #15
   1f442:	d002      	beq.n	1f44a <isr_rx+0x86>
   1f444:	2906      	cmp	r1, #6
   1f446:	f040 80e1 	bne.w	1f60c <isr_rx+0x248>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   1f44a:	7f60      	ldrb	r0, [r4, #29]
   1f44c:	2825      	cmp	r0, #37	; 0x25
   1f44e:	d86b      	bhi.n	1f528 <isr_rx+0x164>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
		   lll->type &&
   1f450:	0690      	lsls	r0, r2, #26
   1f452:	d569      	bpl.n	1f528 <isr_rx+0x164>
		bt_addr_t *lrpa;
#endif /* CONFIG_BT_CTLR_PRIVACY */
		int err;

		/* setup tIFS switching */
		radio_tmr_tifs_set(EVENT_IFS_US);
   1f454:	2096      	movs	r0, #150	; 0x96
   1f456:	f000 ff4d 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1f45a:	2000      	movs	r0, #0
   1f45c:	f000 fea4 	bl	201a8 <radio_switch_complete_and_rx>
			      uint8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	int err = 0;

	node_rx = ull_pdu_rx_alloc_peek(3);
   1f460:	2003      	movs	r0, #3
   1f462:	f7fc fa9d 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   1f466:	4606      	mov	r6, r0
   1f468:	2800      	cmp	r0, #0
   1f46a:	f000 808c 	beq.w	1f586 <isr_rx+0x1c2>
		return -ENOBUFS;
	}
	ull_pdu_rx_alloc();
   1f46e:	f7fc faaf 	bl	1b9d0 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
   1f472:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f476:	80f3      	strh	r3, [r6, #6]
			}
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   1f478:	2305      	movs	r3, #5
   1f47a:	7133      	strb	r3, [r6, #4]
	}

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f47c:	2f00      	cmp	r7, #0
   1f47e:	d051      	beq.n	1f524 <isr_rx+0x160>
   1f480:	f000 fed2 	bl	20228 <radio_rssi_get>
   1f484:	b2c0      	uxtb	r0, r0
#endif /* CONFIG_BT_CTLR_ADV_EXT */
#endif /* CONFIG_BT_CTLR_PRIVACY */

#if defined(CONFIG_BT_CTLR_EXT_SCAN_FP)
	/* save the directed adv report flag */
	node_rx->hdr.rx_ftr.direct = dir_report;
   1f486:	7e73      	ldrb	r3, [r6, #25]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f488:	7630      	strb	r0, [r6, #24]
	node_rx->hdr.rx_ftr.direct = dir_report;
   1f48a:	f36f 0300 	bfc	r3, #0, #1
   1f48e:	7673      	strb	r3, [r6, #25]
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
   1f490:	4631      	mov	r1, r6
   1f492:	6830      	ldr	r0, [r6, #0]
   1f494:	f7fc fab2 	bl	1b9fc <ull_rx_put>
	ull_rx_sched();
   1f498:	f7fc fac0 	bl	1ba1c <ull_rx_sched>
		pdu_tx = (void *)radio_pkt_scratch_get();
   1f49c:	f000 fe10 	bl	200c0 <radio_pkt_scratch_get>
			pdu_tx->tx_addr = lll->init_addr_type;
   1f4a0:	792b      	ldrb	r3, [r5, #4]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   1f4a2:	7f22      	ldrb	r2, [r4, #28]
			pdu_tx->tx_addr = lll->init_addr_type;
   1f4a4:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
   1f4a8:	019b      	lsls	r3, r3, #6
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
   1f4aa:	f3c2 1280 	ubfx	r2, r2, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
   1f4ae:	f043 0303 	orr.w	r3, r3, #3
   1f4b2:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   1f4b6:	7802      	ldrb	r2, [r0, #0]
   1f4b8:	f002 0230 	and.w	r2, r2, #48	; 0x30
   1f4bc:	4313      	orrs	r3, r2
   1f4be:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
   1f4c0:	230c      	movs	r3, #12
   1f4c2:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
   1f4c4:	4606      	mov	r6, r0
			memcpy(&pdu_tx->scan_req.scan_addr[0],
   1f4c6:	2206      	movs	r2, #6
   1f4c8:	1d69      	adds	r1, r5, #5
   1f4ca:	3002      	adds	r0, #2
   1f4cc:	f008 f9d0 	bl	27870 <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
   1f4d0:	2206      	movs	r2, #6
   1f4d2:	f104 011e 	add.w	r1, r4, #30
   1f4d6:	f106 0008 	add.w	r0, r6, #8
   1f4da:	f008 f9c9 	bl	27870 <memcpy>
		radio_pkt_tx_set(pdu_tx);
   1f4de:	4630      	mov	r0, r6
   1f4e0:	f000 fd86 	bl	1fff0 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   1f4e4:	f000 fdb4 	bl	20050 <radio_is_ready>
   1f4e8:	b160      	cbz	r0, 1f504 <isr_rx+0x140>
   1f4ea:	4a49      	ldr	r2, [pc, #292]	; (1f610 <isr_rx+0x24c>)
   1f4ec:	494b      	ldr	r1, [pc, #300]	; (1f61c <isr_rx+0x258>)
   1f4ee:	484a      	ldr	r0, [pc, #296]	; (1f618 <isr_rx+0x254>)
   1f4f0:	f240 5316 	movw	r3, #1302	; 0x516
   1f4f4:	f005 fe62 	bl	251bc <printk>
   1f4f8:	4040      	eors	r0, r0
   1f4fa:	f380 8811 	msr	BASEPRI, r0
   1f4fe:	f04f 0003 	mov.w	r0, #3
   1f502:	df02      	svc	2
		radio_tmr_end_capture();
   1f504:	f000 ffd0 	bl	204a8 <radio_tmr_end_capture>
		lll->state = 1U;
   1f508:	792b      	ldrb	r3, [r5, #4]
		radio_isr_set(isr_tx, lll);
   1f50a:	4845      	ldr	r0, [pc, #276]	; (1f620 <isr_rx+0x25c>)
		lll->state = 1U;
   1f50c:	f043 0301 	orr.w	r3, r3, #1
   1f510:	712b      	strb	r3, [r5, #4]
		radio_isr_set(isr_tx, lll);
   1f512:	4629      	mov	r1, r5
}
   1f514:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		radio_isr_set(isr_tx, lll);
   1f518:	f000 bcb4 	b.w	1fe84 <radio_isr_set>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready =
   1f51c:	46a0      	mov	r8, r4
   1f51e:	4627      	mov	r7, r4
   1f520:	4626      	mov	r6, r4
   1f522:	e76a      	b.n	1f3fa <isr_rx+0x36>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f524:	207f      	movs	r0, #127	; 0x7f
   1f526:	e7ae      	b.n	1f486 <isr_rx+0xc2>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1f528:	f013 0f0d 	tst.w	r3, #13
   1f52c:	d001      	beq.n	1f532 <isr_rx+0x16e>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
   1f52e:	2906      	cmp	r1, #6
   1f530:	d122      	bne.n	1f578 <isr_rx+0x1b4>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
   1f532:	7f60      	ldrb	r0, [r4, #29]
   1f534:	2825      	cmp	r0, #37	; 0x25
   1f536:	d81f      	bhi.n	1f578 <isr_rx+0x1b4>
	bool dir_report = false;
   1f538:	2600      	movs	r6, #0
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
   1f53a:	7f63      	ldrb	r3, [r4, #29]
   1f53c:	b31b      	cbz	r3, 1f586 <isr_rx+0x1c2>
	node_rx = ull_pdu_rx_alloc_peek(3);
   1f53e:	2003      	movs	r0, #3
   1f540:	f7fc fa2e 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   1f544:	4604      	mov	r4, r0
   1f546:	b1f0      	cbz	r0, 1f586 <isr_rx+0x1c2>
	ull_pdu_rx_alloc();
   1f548:	f7fc fa42 	bl	1b9d0 <ull_pdu_rx_alloc>
	node_rx->hdr.handle = 0xffff;
   1f54c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f550:	80e3      	strh	r3, [r4, #6]
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   1f552:	2305      	movs	r3, #5
   1f554:	7123      	strb	r3, [r4, #4]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f556:	2f00      	cmp	r7, #0
   1f558:	d056      	beq.n	1f608 <isr_rx+0x244>
   1f55a:	f000 fe65 	bl	20228 <radio_rssi_get>
   1f55e:	b2c0      	uxtb	r0, r0
	node_rx->hdr.rx_ftr.direct = dir_report;
   1f560:	7e63      	ldrb	r3, [r4, #25]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f562:	7620      	strb	r0, [r4, #24]
	node_rx->hdr.rx_ftr.direct = dir_report;
   1f564:	f366 0300 	bfi	r3, r6, #0, #1
	ull_rx_put(node_rx->hdr.link, node_rx);
   1f568:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.direct = dir_report;
   1f56a:	7663      	strb	r3, [r4, #25]
	ull_rx_put(node_rx->hdr.link, node_rx);
   1f56c:	4621      	mov	r1, r4
   1f56e:	f7fc fa45 	bl	1b9fc <ull_rx_put>
	ull_rx_sched();
   1f572:	f7fc fa53 	bl	1ba1c <ull_rx_sched>
	if (!err) {
   1f576:	e006      	b.n	1f586 <isr_rx+0x1c2>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
   1f578:	2901      	cmp	r1, #1
   1f57a:	d00c      	beq.n	1f596 <isr_rx+0x1d2>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
   1f57c:	7f23      	ldrb	r3, [r4, #28]
					rl_idx, &dir_report))) ||
   1f57e:	f003 030f 	and.w	r3, r3, #15
   1f582:	2b04      	cmp	r3, #4
   1f584:	d028      	beq.n	1f5d8 <isr_rx+0x214>
	radio_isr_set(isr_done, lll);
   1f586:	4629      	mov	r1, r5
   1f588:	4826      	ldr	r0, [pc, #152]	; (1f624 <isr_rx+0x260>)
   1f58a:	f000 fc7b 	bl	1fe84 <radio_isr_set>
}
   1f58e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	radio_disable();
   1f592:	f000 bd3f 	b.w	20014 <radio_disable>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
   1f596:	7f61      	ldrb	r1, [r4, #29]
   1f598:	290c      	cmp	r1, #12
   1f59a:	d1f4      	bne.n	1f586 <isr_rx+0x1c2>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   1f59c:	f3c2 1280 	ubfx	r2, r2, #6, #1
   1f5a0:	ebb2 1fd3 	cmp.w	r2, r3, lsr #7
		    isr_scan_tgta_check(lll, false, pdu_adv_rx->rx_addr,
   1f5a4:	ea4f 16d3 	mov.w	r6, r3, lsr #7
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   1f5a8:	d00d      	beq.n	1f5c6 <isr_rx+0x202>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   1f5aa:	792b      	ldrb	r3, [r5, #4]
   1f5ac:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   1f5b0:	079a      	lsls	r2, r3, #30
   1f5b2:	d5e3      	bpl.n	1f57c <isr_rx+0x1b8>
   1f5b4:	2e00      	cmp	r6, #0
   1f5b6:	d0e1      	beq.n	1f57c <isr_rx+0x1b8>
   1f5b8:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   1f5bc:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1f5c0:	2b40      	cmp	r3, #64	; 0x40
   1f5c2:	d1db      	bne.n	1f57c <isr_rx+0x1b8>
   1f5c4:	e7b9      	b.n	1f53a <isr_rx+0x176>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   1f5c6:	2206      	movs	r2, #6
   1f5c8:	f104 0124 	add.w	r1, r4, #36	; 0x24
   1f5cc:	1d68      	adds	r0, r5, #5
   1f5ce:	f008 f93e 	bl	2784e <memcmp>
	return (((lll->init_addr_type == addr_type) &&
   1f5d2:	2800      	cmp	r0, #0
   1f5d4:	d0b0      	beq.n	1f538 <isr_rx+0x174>
   1f5d6:	e7e8      	b.n	1f5aa <isr_rx+0x1e6>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
   1f5d8:	7f63      	ldrb	r3, [r4, #29]
   1f5da:	2b25      	cmp	r3, #37	; 0x25
   1f5dc:	d8d3      	bhi.n	1f586 <isr_rx+0x1c2>
		   (lll->state != 0U) &&
   1f5de:	792b      	ldrb	r3, [r5, #4]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
   1f5e0:	07db      	lsls	r3, r3, #31
   1f5e2:	d5d0      	bpl.n	1f586 <isr_rx+0x1c2>
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
   1f5e4:	f000 fd6c 	bl	200c0 <radio_pkt_scratch_get>
	return ((sreq->rx_addr == srsp->tx_addr) &&
   1f5e8:	7f23      	ldrb	r3, [r4, #28]
   1f5ea:	7802      	ldrb	r2, [r0, #0]
   1f5ec:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1f5f0:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1f5f4:	d1c7      	bne.n	1f586 <isr_rx+0x1c2>
		(memcmp(&sreq->scan_req.adv_addr[0],
   1f5f6:	2206      	movs	r2, #6
   1f5f8:	f104 011e 	add.w	r1, r4, #30
   1f5fc:	3008      	adds	r0, #8
   1f5fe:	f008 f926 	bl	2784e <memcmp>
		   (lll->state != 0U) &&
   1f602:	2800      	cmp	r0, #0
   1f604:	d098      	beq.n	1f538 <isr_rx+0x174>
   1f606:	e7be      	b.n	1f586 <isr_rx+0x1c2>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1f608:	207f      	movs	r0, #127	; 0x7f
   1f60a:	e7a9      	b.n	1f560 <isr_rx+0x19c>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
   1f60c:	2902      	cmp	r1, #2
   1f60e:	e78f      	b.n	1f530 <isr_rx+0x16c>
   1f610:	000347d2 	.word	0x000347d2
   1f614:	0003478b 	.word	0x0003478b
   1f618:	0002f8b5 	.word	0x0002f8b5
   1f61c:	00034793 	.word	0x00034793
   1f620:	0001f209 	.word	0x0001f209
   1f624:	0002b839 	.word	0x0002b839

0001f628 <lll_scan_prepare>:
{
   1f628:	b513      	push	{r0, r1, r4, lr}
   1f62a:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1f62c:	f7ff f900 	bl	1e830 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   1f630:	2800      	cmp	r0, #0
   1f632:	da0b      	bge.n	1f64c <lll_scan_prepare+0x24>
   1f634:	4a11      	ldr	r2, [pc, #68]	; (1f67c <lll_scan_prepare+0x54>)
   1f636:	4912      	ldr	r1, [pc, #72]	; (1f680 <lll_scan_prepare+0x58>)
   1f638:	4812      	ldr	r0, [pc, #72]	; (1f684 <lll_scan_prepare+0x5c>)
   1f63a:	2388      	movs	r3, #136	; 0x88
   1f63c:	f005 fdbe 	bl	251bc <printk>
   1f640:	4040      	eors	r0, r0
   1f642:	f380 8811 	msr	BASEPRI, r0
   1f646:	f04f 0003 	mov.w	r0, #3
   1f64a:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
   1f64c:	4a0e      	ldr	r2, [pc, #56]	; (1f688 <lll_scan_prepare+0x60>)
   1f64e:	490f      	ldr	r1, [pc, #60]	; (1f68c <lll_scan_prepare+0x64>)
   1f650:	480f      	ldr	r0, [pc, #60]	; (1f690 <lll_scan_prepare+0x68>)
   1f652:	9400      	str	r4, [sp, #0]
   1f654:	2300      	movs	r3, #0
   1f656:	f00b fcd5 	bl	2b004 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1f65a:	b168      	cbz	r0, 1f678 <lll_scan_prepare+0x50>
   1f65c:	3077      	adds	r0, #119	; 0x77
   1f65e:	d00b      	beq.n	1f678 <lll_scan_prepare+0x50>
   1f660:	4a06      	ldr	r2, [pc, #24]	; (1f67c <lll_scan_prepare+0x54>)
   1f662:	490c      	ldr	r1, [pc, #48]	; (1f694 <lll_scan_prepare+0x6c>)
   1f664:	4807      	ldr	r0, [pc, #28]	; (1f684 <lll_scan_prepare+0x5c>)
   1f666:	238b      	movs	r3, #139	; 0x8b
   1f668:	f005 fda8 	bl	251bc <printk>
   1f66c:	4040      	eors	r0, r0
   1f66e:	f380 8811 	msr	BASEPRI, r0
   1f672:	f04f 0003 	mov.w	r0, #3
   1f676:	df02      	svc	2
}
   1f678:	b002      	add	sp, #8
   1f67a:	bd10      	pop	{r4, pc}
   1f67c:	000347d2 	.word	0x000347d2
   1f680:	000346f1 	.word	0x000346f1
   1f684:	0002f8b5 	.word	0x0002f8b5
   1f688:	0002b81d 	.word	0x0002b81d
   1f68c:	0001f375 	.word	0x0001f375
   1f690:	0001f2d5 	.word	0x0001f2d5
   1f694:	000347ae 	.word	0x000347ae

0001f698 <isr_done>:
{
	return 0;
}

static void isr_done(void *param)
{
   1f698:	b570      	push	{r4, r5, r6, lr}
   1f69a:	4605      	mov	r5, r0
	struct event_done_extra *e;

	lll_isr_status_reset();
   1f69c:	f00b ffe6 	bl	2b66c <lll_isr_status_reset>

	e = ull_event_done_extra_get();
   1f6a0:	f7fc fa74 	bl	1bb8c <ull_event_done_extra_get>
	LL_ASSERT(e);
   1f6a4:	4604      	mov	r4, r0
   1f6a6:	b960      	cbnz	r0, 1f6c2 <isr_done+0x2a>
   1f6a8:	4a17      	ldr	r2, [pc, #92]	; (1f708 <isr_done+0x70>)
   1f6aa:	4918      	ldr	r1, [pc, #96]	; (1f70c <isr_done+0x74>)
   1f6ac:	4818      	ldr	r0, [pc, #96]	; (1f710 <isr_done+0x78>)
   1f6ae:	f240 3317 	movw	r3, #791	; 0x317
   1f6b2:	f005 fd83 	bl	251bc <printk>
   1f6b6:	4040      	eors	r0, r0
   1f6b8:	f380 8811 	msr	BASEPRI, r0
   1f6bc:	f04f 0003 	mov.w	r0, #3
   1f6c0:	df02      	svc	2

	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   1f6c2:	2301      	movs	r3, #1
	e->trx_cnt = trx_cnt;
	e->crc_valid = crc_valid;
   1f6c4:	4913      	ldr	r1, [pc, #76]	; (1f714 <isr_done+0x7c>)
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   1f6c6:	7023      	strb	r3, [r4, #0]
	e->trx_cnt = trx_cnt;
   1f6c8:	4b13      	ldr	r3, [pc, #76]	; (1f718 <isr_done+0x80>)
	e->crc_valid = crc_valid;
   1f6ca:	79a2      	ldrb	r2, [r4, #6]
   1f6cc:	7809      	ldrb	r1, [r1, #0]
	e->trx_cnt = trx_cnt;
   1f6ce:	881b      	ldrh	r3, [r3, #0]
   1f6d0:	80a3      	strh	r3, [r4, #4]
	e->crc_valid = crc_valid;
   1f6d2:	f361 0200 	bfi	r2, r1, #0, #1
   1f6d6:	71a2      	strb	r2, [r4, #6]
#if defined(CONFIG_BT_CTLR_LE_ENC)
	e->mic_state = mic_state;
#endif /* CONFIG_BT_CTLR_LE_ENC */

#if defined(CONFIG_BT_PERIPHERAL)
	if (trx_cnt) {
   1f6d8:	b18b      	cbz	r3, 1f6fe <isr_done+0x66>
		struct lll_conn *lll = param;

		if (lll->role) {
   1f6da:	f995 301d 	ldrsb.w	r3, [r5, #29]
   1f6de:	2b00      	cmp	r3, #0
   1f6e0:	da0d      	bge.n	1f6fe <isr_done+0x66>
			preamble_to_addr_us =
				addr_us_get(0);
#endif /* !CONFIG_BT_CTLR_PHY */

			e->drift.start_to_address_actual_us =
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   1f6e2:	f000 fed5 	bl	20490 <radio_tmr_aa_restore>
   1f6e6:	4606      	mov	r6, r0
   1f6e8:	f000 fed8 	bl	2049c <radio_tmr_ready_get>
			e->drift.window_widening_event_us =
   1f6ec:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   1f6ee:	60e3      	str	r3, [r4, #12]
				lll->periph.window_widening_event_us;
			e->drift.preamble_to_addr_us = preamble_to_addr_us;
   1f6f0:	2328      	movs	r3, #40	; 0x28
   1f6f2:	6123      	str	r3, [r4, #16]
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   1f6f4:	1a36      	subs	r6, r6, r0

			/* Reset window widening, as anchor point sync-ed */
			lll->periph.window_widening_event_us = 0;
   1f6f6:	2300      	movs	r3, #0
			e->drift.start_to_address_actual_us =
   1f6f8:	60a6      	str	r6, [r4, #8]
			lll->periph.window_widening_event_us = 0;
   1f6fa:	632b      	str	r3, [r5, #48]	; 0x30
			lll->periph.window_size_event_us = 0;
   1f6fc:	63ab      	str	r3, [r5, #56]	; 0x38
		}
	}
#endif /* CONFIG_BT_PERIPHERAL */

	lll_isr_cleanup(param);
   1f6fe:	4628      	mov	r0, r5
}
   1f700:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lll_isr_cleanup(param);
   1f704:	f7fe bf48 	b.w	1e598 <lll_isr_cleanup>
   1f708:	0003482e 	.word	0x0003482e
   1f70c:	00033717 	.word	0x00033717
   1f710:	0002f8b5 	.word	0x0002f8b5
   1f714:	20003b39 	.word	0x20003b39
   1f718:	2000392a 	.word	0x2000392a

0001f71c <lll_conn_prepare_reset>:
	trx_cnt = 0U;
   1f71c:	4a03      	ldr	r2, [pc, #12]	; (1f72c <lll_conn_prepare_reset+0x10>)
   1f71e:	2300      	movs	r3, #0
   1f720:	8013      	strh	r3, [r2, #0]
	crc_valid = 0U;
   1f722:	4a03      	ldr	r2, [pc, #12]	; (1f730 <lll_conn_prepare_reset+0x14>)
   1f724:	7013      	strb	r3, [r2, #0]
	crc_expire = 0U;
   1f726:	4a03      	ldr	r2, [pc, #12]	; (1f734 <lll_conn_prepare_reset+0x18>)
   1f728:	7013      	strb	r3, [r2, #0]
}
   1f72a:	4770      	bx	lr
   1f72c:	2000392a 	.word	0x2000392a
   1f730:	20003b39 	.word	0x20003b39
   1f734:	20003b38 	.word	0x20003b38

0001f738 <lll_conn_abort_cb>:
{
   1f738:	b538      	push	{r3, r4, r5, lr}
   1f73a:	460d      	mov	r5, r1
	if (!prepare_param) {
   1f73c:	4604      	mov	r4, r0
   1f73e:	b930      	cbnz	r0, 1f74e <lll_conn_abort_cb+0x16>
		radio_isr_set(isr_done, param);
   1f740:	4810      	ldr	r0, [pc, #64]	; (1f784 <lll_conn_abort_cb+0x4c>)
   1f742:	f000 fb9f 	bl	1fe84 <radio_isr_set>
}
   1f746:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		radio_disable();
   1f74a:	f000 bc63 	b.w	20014 <radio_disable>
	err = lll_hfclock_off();
   1f74e:	f7ff f885 	bl	1e85c <lll_hfclock_off>
	LL_ASSERT(err >= 0);
   1f752:	2800      	cmp	r0, #0
   1f754:	da0b      	bge.n	1f76e <lll_conn_abort_cb+0x36>
   1f756:	4a0c      	ldr	r2, [pc, #48]	; (1f788 <lll_conn_abort_cb+0x50>)
   1f758:	490c      	ldr	r1, [pc, #48]	; (1f78c <lll_conn_abort_cb+0x54>)
   1f75a:	480d      	ldr	r0, [pc, #52]	; (1f790 <lll_conn_abort_cb+0x58>)
   1f75c:	23aa      	movs	r3, #170	; 0xaa
   1f75e:	f005 fd2d 	bl	251bc <printk>
   1f762:	4040      	eors	r0, r0
   1f764:	f380 8811 	msr	BASEPRI, r0
   1f768:	f04f 0003 	mov.w	r0, #3
   1f76c:	df02      	svc	2
	lll = prepare_param->param;
   1f76e:	68e2      	ldr	r2, [r4, #12]
	lll->latency_prepare += (prepare_param->lazy + 1);
   1f770:	8923      	ldrh	r3, [r4, #8]
   1f772:	8a51      	ldrh	r1, [r2, #18]
   1f774:	3301      	adds	r3, #1
   1f776:	440b      	add	r3, r1
   1f778:	8253      	strh	r3, [r2, #18]
	lll_done(param);
   1f77a:	4628      	mov	r0, r5
}
   1f77c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(param);
   1f780:	f7fe be7c 	b.w	1e47c <lll_done>
   1f784:	0001f699 	.word	0x0001f699
   1f788:	0003482e 	.word	0x0003482e
   1f78c:	000346f1 	.word	0x000346f1
   1f790:	0002f8b5 	.word	0x0002f8b5

0001f794 <lll_conn_rx_pkt_set>:
{
   1f794:	b510      	push	{r4, lr}
	node_rx = ull_pdu_rx_alloc_peek(1);
   1f796:	2001      	movs	r0, #1
   1f798:	f7fc f902 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f79c:	4604      	mov	r4, r0
   1f79e:	b960      	cbnz	r0, 1f7ba <lll_conn_rx_pkt_set+0x26>
   1f7a0:	4a0d      	ldr	r2, [pc, #52]	; (1f7d8 <lll_conn_rx_pkt_set+0x44>)
   1f7a2:	490e      	ldr	r1, [pc, #56]	; (1f7dc <lll_conn_rx_pkt_set+0x48>)
   1f7a4:	480e      	ldr	r0, [pc, #56]	; (1f7e0 <lll_conn_rx_pkt_set+0x4c>)
   1f7a6:	f240 235a 	movw	r3, #602	; 0x25a
   1f7aa:	f005 fd07 	bl	251bc <printk>
   1f7ae:	4040      	eors	r0, r0
   1f7b0:	f380 8811 	msr	BASEPRI, r0
   1f7b4:	f04f 0003 	mov.w	r0, #3
   1f7b8:	df02      	svc	2
	radio_phy_set(phy, 0);
   1f7ba:	2100      	movs	r1, #0
   1f7bc:	4608      	mov	r0, r1
   1f7be:	f000 fba5 	bl	1ff0c <radio_phy_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_rx_octets,
   1f7c2:	2008      	movs	r0, #8
   1f7c4:	2201      	movs	r2, #1
   1f7c6:	211b      	movs	r1, #27
   1f7c8:	f000 fbe6 	bl	1ff98 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   1f7cc:	f104 001c 	add.w	r0, r4, #28
}
   1f7d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_pkt_rx_set(node_rx->pdu);
   1f7d4:	f000 bc06 	b.w	1ffe4 <radio_pkt_rx_set>
   1f7d8:	0003482e 	.word	0x0003482e
   1f7dc:	0003478b 	.word	0x0003478b
   1f7e0:	0002f8b5 	.word	0x0002f8b5

0001f7e4 <lll_conn_isr_tx>:
{
   1f7e4:	b570      	push	{r4, r5, r6, lr}
   1f7e6:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
   1f7e8:	f00b ff30 	bl	2b64c <lll_isr_tx_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1f7ec:	2096      	movs	r0, #150	; 0x96
   1f7ee:	f000 fd81 	bl	202f4 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1f7f2:	2300      	movs	r3, #0
   1f7f4:	4618      	mov	r0, r3
   1f7f6:	461a      	mov	r2, r3
   1f7f8:	4619      	mov	r1, r3
   1f7fa:	f000 fce9 	bl	201d0 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   1f7fe:	4628      	mov	r0, r5
   1f800:	f7ff ffc8 	bl	1f794 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   1f804:	f000 fc24 	bl	20050 <radio_is_ready>
   1f808:	b160      	cbz	r0, 1f824 <lll_conn_isr_tx+0x40>
   1f80a:	4a12      	ldr	r2, [pc, #72]	; (1f854 <lll_conn_isr_tx+0x70>)
   1f80c:	4912      	ldr	r1, [pc, #72]	; (1f858 <lll_conn_isr_tx+0x74>)
   1f80e:	4813      	ldr	r0, [pc, #76]	; (1f85c <lll_conn_isr_tx+0x78>)
   1f810:	f240 2313 	movw	r3, #531	; 0x213
   1f814:	f005 fcd2 	bl	251bc <printk>
   1f818:	4040      	eors	r0, r0
   1f81a:	f380 8811 	msr	BASEPRI, r0
   1f81e:	f04f 0003 	mov.w	r0, #3
   1f822:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + (EVENT_CLOCK_JITTER_US << 1) +
   1f824:	f000 fe4e 	bl	204c4 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1f828:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + (EVENT_CLOCK_JITTER_US << 1) +
   1f82a:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f82c:	4608      	mov	r0, r1
   1f82e:	f00c f93e 	bl	2baae <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f832:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f834:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f836:	4608      	mov	r0, r1
   1f838:	f00c f935 	bl	2baa6 <radio_tx_chain_delay_get>
   1f83c:	4434      	add	r4, r6
   1f83e:	34cb      	adds	r4, #203	; 0xcb
	radio_tmr_hcto_configure(hcto);
   1f840:	1a20      	subs	r0, r4, r0
   1f842:	f000 fdf9 	bl	20438 <radio_tmr_hcto_configure>
	radio_isr_set(lll_conn_isr_rx, param);
   1f846:	4629      	mov	r1, r5
   1f848:	4805      	ldr	r0, [pc, #20]	; (1f860 <lll_conn_isr_tx+0x7c>)
}
   1f84a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(lll_conn_isr_rx, param);
   1f84e:	f000 bb19 	b.w	1fe84 <radio_isr_set>
   1f852:	bf00      	nop
   1f854:	0003482e 	.word	0x0003482e
   1f858:	00034793 	.word	0x00034793
   1f85c:	0002f8b5 	.word	0x0002f8b5
   1f860:	0001f865 	.word	0x0001f865

0001f864 <lll_conn_isr_rx>:
{
   1f864:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1f868:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   1f86a:	f000 fbfb 	bl	20064 <radio_is_done>
	if (trx_done) {
   1f86e:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
   1f872:	d010      	beq.n	1f896 <lll_conn_isr_rx+0x32>
		crc_ok = radio_crc_is_valid();
   1f874:	f000 fc16 	bl	200a4 <radio_crc_is_valid>
   1f878:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   1f87a:	f000 fce3 	bl	20244 <radio_rssi_is_ready>
	lll_isr_rx_status_reset();
   1f87e:	f00b feec 	bl	2b65a <lll_isr_rx_status_reset>
	if (!trx_done) {
   1f882:	b955      	cbnz	r5, 1f89a <lll_conn_isr_rx+0x36>
		radio_isr_set(isr_done, param);
   1f884:	489e      	ldr	r0, [pc, #632]	; (1fb00 <lll_conn_isr_rx+0x29c>)
   1f886:	4621      	mov	r1, r4
   1f888:	f000 fafc 	bl	1fe84 <radio_isr_set>
}
   1f88c:	b002      	add	sp, #8
   1f88e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		radio_disable();
   1f892:	f000 bbbf 	b.w	20014 <radio_disable>
		crc_ok = rssi_ready = 0U;
   1f896:	462f      	mov	r7, r5
   1f898:	e7f1      	b.n	1f87e <lll_conn_isr_rx+0x1a>
	trx_cnt++;
   1f89a:	4a9a      	ldr	r2, [pc, #616]	; (1fb04 <lll_conn_isr_rx+0x2a0>)
   1f89c:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1f89e:	2001      	movs	r0, #1
	trx_cnt++;
   1f8a0:	3301      	adds	r3, #1
   1f8a2:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   1f8a4:	f7fc f87c 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1f8a8:	4606      	mov	r6, r0
   1f8aa:	b958      	cbnz	r0, 1f8c4 <lll_conn_isr_rx+0x60>
   1f8ac:	4a96      	ldr	r2, [pc, #600]	; (1fb08 <lll_conn_isr_rx+0x2a4>)
   1f8ae:	4997      	ldr	r1, [pc, #604]	; (1fb0c <lll_conn_isr_rx+0x2a8>)
   1f8b0:	4897      	ldr	r0, [pc, #604]	; (1fb10 <lll_conn_isr_rx+0x2ac>)
   1f8b2:	23f2      	movs	r3, #242	; 0xf2
   1f8b4:	f005 fc82 	bl	251bc <printk>
   1f8b8:	4040      	eors	r0, r0
   1f8ba:	f380 8811 	msr	BASEPRI, r0
   1f8be:	f04f 0003 	mov.w	r0, #3
   1f8c2:	df02      	svc	2
	if (crc_ok) {
   1f8c4:	f8df 824c 	ldr.w	r8, [pc, #588]	; 1fb14 <lll_conn_isr_rx+0x2b0>
   1f8c8:	2f00      	cmp	r7, #0
   1f8ca:	f000 80fa 	beq.w	1fac2 <lll_conn_isr_rx+0x25e>
#elif !defined(HAL_RADIO_PDU_LEN_MAX)
#error "Undefined HAL_RADIO_PDU_LEN_MAX."
#endif

	/* Ack for tx-ed data */
	if (pdu_data_rx->nesn != lll->sn) {
   1f8ce:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1f8d2:	7f31      	ldrb	r1, [r6, #28]
   1f8d4:	f003 0201 	and.w	r2, r3, #1
   1f8d8:	f3c1 0180 	ubfx	r1, r1, #2, #1
   1f8dc:	4291      	cmp	r1, r2
   1f8de:	f000 80ab 	beq.w	1fa38 <lll_conn_isr_rx+0x1d4>
		struct pdu_data *pdu_data_tx;
		struct node_tx *tx;
		memq_link_t *link;

		/* Increment sequence number */
		lll->sn++;
   1f8e2:	f082 0201 	eor.w	r2, r2, #1
   1f8e6:	f362 0300 	bfi	r3, r2, #0, #1
   1f8ea:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52

#if defined(CONFIG_BT_PERIPHERAL)
		/* First ack (and redundantly any other ack) enable use of
		 * peripheral latency.
		 */
		if (lll->role) {
   1f8ee:	f994 301d 	ldrsb.w	r3, [r4, #29]
   1f8f2:	2b00      	cmp	r3, #0
			lll->periph.latency_enabled = 1;
   1f8f4:	bfbe      	ittt	lt
   1f8f6:	f894 3020 	ldrblt.w	r3, [r4, #32]
   1f8fa:	f043 0304 	orrlt.w	r3, r3, #4
   1f8fe:	f884 3020 	strblt.w	r3, [r4, #32]
		}
#endif /* CONFIG_BT_PERIPHERAL */

		FORCE_MD_CNT_DEC();

		if (!lll->empty) {
   1f902:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1f906:	f013 0504 	ands.w	r5, r3, #4
   1f90a:	f040 808f 	bne.w	1fa2c <lll_conn_isr_rx+0x1c8>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   1f90e:	e9d4 010f 	ldrd	r0, r1, [r4, #60]	; 0x3c
   1f912:	aa01      	add	r2, sp, #4
   1f914:	f00a ffe1 	bl	2a8da <memq_peek>
			}

			link = NULL;
		}

		if (link) {
   1f918:	4681      	mov	r9, r0
   1f91a:	2800      	cmp	r0, #0
   1f91c:	f040 808f 	bne.w	1fa3e <lll_conn_isr_rx+0x1da>
			}
		}
	}

	/* process received data */
	if ((pdu_data_rx->sn == lll->nesn) &&
   1f920:	7f32      	ldrb	r2, [r6, #28]
   1f922:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1f926:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   1f92a:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1f92e:	429a      	cmp	r2, r3
   1f930:	f000 80b3 	beq.w	1fa9a <lll_conn_isr_rx+0x236>
	is_rx_enqueue = 0U;
   1f934:	f04f 0a00 	mov.w	sl, #0
		crc_valid = 1U;
   1f938:	4b77      	ldr	r3, [pc, #476]	; (1fb18 <lll_conn_isr_rx+0x2b4>)
		crc_expire = 0U;
   1f93a:	2500      	movs	r5, #0
		crc_valid = 1U;
   1f93c:	2201      	movs	r2, #1
		crc_expire = 0U;
   1f93e:	f888 5000 	strb.w	r5, [r8]
		crc_valid = 1U;
   1f942:	701a      	strb	r2, [r3, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   1f944:	a901      	add	r1, sp, #4
   1f946:	4620      	mov	r0, r4
   1f948:	f00b fffa 	bl	2b940 <lll_conn_pdu_tx_prep>
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   1f94c:	2d00      	cmp	r5, #0
   1f94e:	f040 80cb 	bne.w	1fae8 <lll_conn_isr_rx+0x284>
   1f952:	b157      	cbz	r7, 1f96a <lll_conn_isr_rx+0x106>
   1f954:	7f33      	ldrb	r3, [r6, #28]
   1f956:	06d9      	lsls	r1, r3, #27
   1f958:	d407      	bmi.n	1f96a <lll_conn_isr_rx+0x106>
			      (pdu_data_tx->md == 0) &&
   1f95a:	9b01      	ldr	r3, [sp, #4]
   1f95c:	781a      	ldrb	r2, [r3, #0]
	is_done = is_done || ((crc_ok) && (pdu_data_rx->md == 0) &&
   1f95e:	06d2      	lsls	r2, r2, #27
   1f960:	d403      	bmi.n	1f96a <lll_conn_isr_rx+0x106>
			      (pdu_data_tx->md == 0) &&
   1f962:	785b      	ldrb	r3, [r3, #1]
   1f964:	2b00      	cmp	r3, #0
   1f966:	f000 80bf 	beq.w	1fae8 <lll_conn_isr_rx+0x284>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1f96a:	2096      	movs	r0, #150	; 0x96
   1f96c:	f000 fcc2 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1f970:	2000      	movs	r0, #0
   1f972:	f000 fc19 	bl	201a8 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
   1f976:	4869      	ldr	r0, [pc, #420]	; (1fb1c <lll_conn_isr_rx+0x2b8>)
   1f978:	4621      	mov	r1, r4
   1f97a:	f000 fa83 	bl	1fe84 <radio_isr_set>
		radio_tmr_end_capture();
   1f97e:	f000 fd93 	bl	204a8 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   1f982:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1f986:	9901      	ldr	r1, [sp, #4]
   1f988:	f3c3 0200 	ubfx	r2, r3, #0, #1
	pdu_data_tx->nesn = lll->nesn;
   1f98c:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1f990:	009b      	lsls	r3, r3, #2
   1f992:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
   1f996:	780a      	ldrb	r2, [r1, #0]
   1f998:	f022 020c 	bic.w	r2, r2, #12
   1f99c:	4313      	orrs	r3, r2
   1f99e:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   1f9a0:	4620      	mov	r0, r4
   1f9a2:	f00b ffbd 	bl	2b920 <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   1f9a6:	f000 fb53 	bl	20050 <radio_is_ready>
   1f9aa:	b160      	cbz	r0, 1f9c6 <lll_conn_isr_rx+0x162>
   1f9ac:	4a56      	ldr	r2, [pc, #344]	; (1fb08 <lll_conn_isr_rx+0x2a4>)
   1f9ae:	495c      	ldr	r1, [pc, #368]	; (1fb20 <lll_conn_isr_rx+0x2bc>)
   1f9b0:	4857      	ldr	r0, [pc, #348]	; (1fb10 <lll_conn_isr_rx+0x2ac>)
   1f9b2:	f240 1369 	movw	r3, #361	; 0x169
   1f9b6:	f005 fc01 	bl	251bc <printk>
   1f9ba:	4040      	eors	r0, r0
   1f9bc:	f380 8811 	msr	BASEPRI, r0
   1f9c0:	f04f 0003 	mov.w	r0, #3
   1f9c4:	df02      	svc	2
	if (!radio_tmr_aa_restore()) {
   1f9c6:	f000 fd63 	bl	20490 <radio_tmr_aa_restore>
   1f9ca:	b918      	cbnz	r0, 1f9d4 <lll_conn_isr_rx+0x170>
		radio_tmr_aa_save(radio_tmr_aa_get());
   1f9cc:	f000 fd54 	bl	20478 <radio_tmr_aa_get>
   1f9d0:	f000 fd58 	bl	20484 <radio_tmr_aa_save>
	if (tx_release) {
   1f9d4:	f1b9 0f00 	cmp.w	r9, #0
   1f9d8:	f000 808d 	beq.w	1faf6 <lll_conn_isr_rx+0x292>
		LL_ASSERT(lll->handle != 0xFFFF);
   1f9dc:	89a2      	ldrh	r2, [r4, #12]
   1f9de:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f9e2:	429a      	cmp	r2, r3
   1f9e4:	d10c      	bne.n	1fa00 <lll_conn_isr_rx+0x19c>
   1f9e6:	4a48      	ldr	r2, [pc, #288]	; (1fb08 <lll_conn_isr_rx+0x2a4>)
   1f9e8:	494e      	ldr	r1, [pc, #312]	; (1fb24 <lll_conn_isr_rx+0x2c0>)
   1f9ea:	4849      	ldr	r0, [pc, #292]	; (1fb10 <lll_conn_isr_rx+0x2ac>)
   1f9ec:	f44f 73bc 	mov.w	r3, #376	; 0x178
   1f9f0:	f005 fbe4 	bl	251bc <printk>
   1f9f4:	4040      	eors	r0, r0
   1f9f6:	f380 8811 	msr	BASEPRI, r0
   1f9fa:	f04f 0003 	mov.w	r0, #3
   1f9fe:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   1fa00:	89a0      	ldrh	r0, [r4, #12]
   1fa02:	4649      	mov	r1, r9
   1fa04:	f7fe f8a6 	bl	1db54 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   1fa08:	f1ba 0f00 	cmp.w	sl, #0
   1fa0c:	d009      	beq.n	1fa22 <lll_conn_isr_rx+0x1be>
		ull_pdu_rx_alloc();
   1fa0e:	f7fb ffdf 	bl	1b9d0 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   1fa12:	2303      	movs	r3, #3
   1fa14:	7133      	strb	r3, [r6, #4]
		node_rx->hdr.handle = lll->handle;
   1fa16:	89a3      	ldrh	r3, [r4, #12]
		ull_rx_put(node_rx->hdr.link, node_rx);
   1fa18:	6830      	ldr	r0, [r6, #0]
		node_rx->hdr.handle = lll->handle;
   1fa1a:	80f3      	strh	r3, [r6, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   1fa1c:	4631      	mov	r1, r6
   1fa1e:	f7fb ffed 	bl	1b9fc <ull_rx_put>
		ull_rx_sched();
   1fa22:	f7fb fffb 	bl	1ba1c <ull_rx_sched>
}
   1fa26:	b002      	add	sp, #8
   1fa28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			lll->empty = 0;
   1fa2c:	f36f 0382 	bfc	r3, #2, #1
   1fa30:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
			pdu_data_tx = (void *)radio_pkt_empty_get();
   1fa34:	f000 fb40 	bl	200b8 <radio_pkt_empty_get>
	tx_release = NULL;
   1fa38:	f04f 0900 	mov.w	r9, #0
   1fa3c:	e770      	b.n	1f920 <lll_conn_isr_rx+0xbc>
					       lll->packet_tx_head_offset);
   1fa3e:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
			pdu_data_tx_len = pdu_data_tx->len;
   1fa42:	9a01      	ldr	r2, [sp, #4]
   1fa44:	441a      	add	r2, r3
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
   1fa46:	7952      	ldrb	r2, [r2, #5]
   1fa48:	4413      	add	r3, r2
			if (offset < lll->packet_tx_head_len) {
   1fa4a:	f894 2050 	ldrb.w	r2, [r4, #80]	; 0x50
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
   1fa4e:	b2db      	uxtb	r3, r3
			if (offset < lll->packet_tx_head_len) {
   1fa50:	4293      	cmp	r3, r2
   1fa52:	d202      	bcs.n	1fa5a <lll_conn_isr_rx+0x1f6>
				lll->packet_tx_head_offset = offset;
   1fa54:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
   1fa58:	e7ee      	b.n	1fa38 <lll_conn_isr_rx+0x1d4>
			} else if (offset == lll->packet_tx_head_len) {
   1fa5a:	d110      	bne.n	1fa7e <lll_conn_isr_rx+0x21a>
				memq_dequeue(lll->memq_tx.tail,
   1fa5c:	462a      	mov	r2, r5
   1fa5e:	6c20      	ldr	r0, [r4, #64]	; 0x40
				lll->packet_tx_head_len = 0;
   1fa60:	f8a4 5050 	strh.w	r5, [r4, #80]	; 0x50
				memq_dequeue(lll->memq_tx.tail,
   1fa64:	f104 013c 	add.w	r1, r4, #60	; 0x3c
   1fa68:	f00a ff3f 	bl	2a8ea <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
   1fa6c:	9b01      	ldr	r3, [sp, #4]
   1fa6e:	681a      	ldr	r2, [r3, #0]
   1fa70:	f8c9 2000 	str.w	r2, [r9]
				tx->next = link;
   1fa74:	f8c3 9000 	str.w	r9, [r3]
				*tx_release = tx;
   1fa78:	f8dd 9004 	ldr.w	r9, [sp, #4]
				FORCE_MD_CNT_SET();
   1fa7c:	e750      	b.n	1f920 <lll_conn_isr_rx+0xbc>
				LL_ASSERT(0);
   1fa7e:	4a22      	ldr	r2, [pc, #136]	; (1fb08 <lll_conn_isr_rx+0x2a4>)
   1fa80:	4929      	ldr	r1, [pc, #164]	; (1fb28 <lll_conn_isr_rx+0x2c4>)
   1fa82:	4823      	ldr	r0, [pc, #140]	; (1fb10 <lll_conn_isr_rx+0x2ac>)
   1fa84:	f240 33a3 	movw	r3, #931	; 0x3a3
   1fa88:	f005 fb98 	bl	251bc <printk>
   1fa8c:	4040      	eors	r0, r0
   1fa8e:	f380 8811 	msr	BASEPRI, r0
   1fa92:	f04f 0003 	mov.w	r0, #3
   1fa96:	df02      	svc	2
   1fa98:	e7ce      	b.n	1fa38 <lll_conn_isr_rx+0x1d4>
	    /* check so that we will NEVER use the rx buffer reserved for empty
	     * packet and internal control enqueue
	     */
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   1fa9a:	2003      	movs	r0, #3
   1fa9c:	f7fb ff80 	bl	1b9a0 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
   1faa0:	2800      	cmp	r0, #0
   1faa2:	f43f af47 	beq.w	1f934 <lll_conn_isr_rx+0xd0>
		/* Increment next expected serial number */
		lll->nesn++;
   1faa6:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1faaa:	f083 0302 	eor.w	r3, r3, #2
   1faae:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52

		if (pdu_data_rx->len != 0) {
   1fab2:	f896 a01d 	ldrb.w	sl, [r6, #29]
	is_rx_enqueue = 0U;
   1fab6:	f1ba 0a00 	subs.w	sl, sl, #0
   1faba:	bf18      	it	ne
   1fabc:	f04f 0a01 	movne.w	sl, #1
   1fac0:	e73a      	b.n	1f938 <lll_conn_isr_rx+0xd4>
		if (crc_expire == 0U) {
   1fac2:	f898 3000 	ldrb.w	r3, [r8]
   1fac6:	b913      	cbnz	r3, 1face <lll_conn_isr_rx+0x26a>
			crc_expire = 2U;
   1fac8:	2302      	movs	r3, #2
   1faca:	f888 3000 	strb.w	r3, [r8]
		crc_expire--;
   1face:	f898 5000 	ldrb.w	r5, [r8]
   1fad2:	3d01      	subs	r5, #1
   1fad4:	b2ed      	uxtb	r5, r5
   1fad6:	f888 5000 	strb.w	r5, [r8]
	is_rx_enqueue = 0U;
   1fada:	f04f 0a00 	mov.w	sl, #0
		is_done = (crc_expire == 0U);
   1fade:	fab5 f585 	clz	r5, r5
   1fae2:	096d      	lsrs	r5, r5, #5
	tx_release = NULL;
   1fae4:	46d1      	mov	r9, sl
   1fae6:	e72d      	b.n	1f944 <lll_conn_isr_rx+0xe0>
		radio_isr_set(isr_done, param);
   1fae8:	4805      	ldr	r0, [pc, #20]	; (1fb00 <lll_conn_isr_rx+0x29c>)
   1faea:	4621      	mov	r1, r4
   1faec:	f000 f9ca 	bl	1fe84 <radio_isr_set>
			radio_switch_complete_and_disable();
   1faf0:	f000 fb82 	bl	201f8 <radio_switch_complete_and_disable>
   1faf4:	e745      	b.n	1f982 <lll_conn_isr_rx+0x11e>
	if (is_rx_enqueue) {
   1faf6:	f1ba 0f00 	cmp.w	sl, #0
   1fafa:	d094      	beq.n	1fa26 <lll_conn_isr_rx+0x1c2>
   1fafc:	e787      	b.n	1fa0e <lll_conn_isr_rx+0x1aa>
   1fafe:	bf00      	nop
   1fb00:	0001f699 	.word	0x0001f699
   1fb04:	2000392a 	.word	0x2000392a
   1fb08:	0003482e 	.word	0x0003482e
   1fb0c:	0003478b 	.word	0x0003478b
   1fb10:	0002f8b5 	.word	0x0002f8b5
   1fb14:	20003b38 	.word	0x20003b38
   1fb18:	20003b39 	.word	0x20003b39
   1fb1c:	0001f7e5 	.word	0x0001f7e5
   1fb20:	00034793 	.word	0x00034793
   1fb24:	00034879 	.word	0x00034879
   1fb28:	00031059 	.word	0x00031059

0001fb2c <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *p)
{
   1fb2c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint32_t remainder;
	uint32_t hcto;

	DEBUG_RADIO_START_S(1);

	lll = p->param;
   1fb30:	68c4      	ldr	r4, [r0, #12]

	/* Check if stopped (on disconnection between prepare and pre-empt)
	 */
	if (unlikely(lll->handle == 0xFFFF)) {
   1fb32:	89a2      	ldrh	r2, [r4, #12]
   1fb34:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1fb38:	429a      	cmp	r2, r3
{
   1fb3a:	4606      	mov	r6, r0
	if (unlikely(lll->handle == 0xFFFF)) {
   1fb3c:	d109      	bne.n	1fb52 <prepare_cb+0x26>
		radio_isr_set(lll_isr_early_abort, lll);
   1fb3e:	485c      	ldr	r0, [pc, #368]	; (1fcb0 <prepare_cb+0x184>)
   1fb40:	4621      	mov	r1, r4
#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_CONN_BASE + lll->handle),
			     ticks_at_event)) {
		radio_isr_set(lll_isr_abort, lll);
   1fb42:	f000 f99f 	bl	1fe84 <radio_isr_set>
		radio_disable();
   1fb46:	f000 fa65 	bl	20014 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   1fb4a:	2000      	movs	r0, #0
   1fb4c:	b002      	add	sp, #8
   1fb4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	lll_conn_prepare_reset();
   1fb52:	f7ff fde3 	bl	1f71c <lll_conn_prepare_reset>
	lll->latency_event = lll->latency_prepare + p->lazy;
   1fb56:	8933      	ldrh	r3, [r6, #8]
   1fb58:	8a62      	ldrh	r2, [r4, #18]
   1fb5a:	441a      	add	r2, r3
	lll->event_counter = (event_counter + 1);
   1fb5c:	8ae3      	ldrh	r3, [r4, #22]
	lll->latency_event = lll->latency_prepare + p->lazy;
   1fb5e:	b292      	uxth	r2, r2
	lll->event_counter = (event_counter + 1);
   1fb60:	3301      	adds	r3, #1
   1fb62:	4413      	add	r3, r2
   1fb64:	82e3      	strh	r3, [r4, #22]
	if (lll->data_chan_sel) {
   1fb66:	7f63      	ldrb	r3, [r4, #29]
	lll->latency_event = lll->latency_prepare + p->lazy;
   1fb68:	82a2      	strh	r2, [r4, #20]
	lll->latency_prepare = 0;
   1fb6a:	2500      	movs	r5, #0
	if (lll->data_chan_sel) {
   1fb6c:	0659      	lsls	r1, r3, #25
	lll->latency_prepare = 0;
   1fb6e:	8265      	strh	r5, [r4, #18]
	if (lll->data_chan_sel) {
   1fb70:	d57e      	bpl.n	1fc70 <prepare_cb+0x144>
		LL_ASSERT(0);
   1fb72:	4a50      	ldr	r2, [pc, #320]	; (1fcb4 <prepare_cb+0x188>)
   1fb74:	4950      	ldr	r1, [pc, #320]	; (1fcb8 <prepare_cb+0x18c>)
   1fb76:	4851      	ldr	r0, [pc, #324]	; (1fcbc <prepare_cb+0x190>)
   1fb78:	2399      	movs	r3, #153	; 0x99
   1fb7a:	f005 fb1f 	bl	251bc <printk>
   1fb7e:	4040      	eors	r0, r0
   1fb80:	f380 8811 	msr	BASEPRI, r0
   1fb84:	f04f 0003 	mov.w	r0, #3
   1fb88:	df02      	svc	2
	lll->periph.window_widening_event_us +=
   1fb8a:	e9d4 230b 	ldrd	r2, r3, [r4, #44]	; 0x2c
	    lll->periph.window_widening_max_us) {
   1fb8e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	lll->periph.window_widening_event_us +=
   1fb90:	4413      	add	r3, r2
		lll->periph.window_widening_event_us =
   1fb92:	4299      	cmp	r1, r3
   1fb94:	bf94      	ite	ls
   1fb96:	6321      	strls	r1, [r4, #48]	; 0x30
   1fb98:	6323      	strhi	r3, [r4, #48]	; 0x30
	lll->periph.window_size_event_us +=
   1fb9a:	e9d4 130d 	ldrd	r1, r3, [r4, #52]	; 0x34
	lll->periph.window_widening_prepare_us = 0;
   1fb9e:	2200      	movs	r2, #0
	lll->periph.window_size_event_us +=
   1fba0:	440b      	add	r3, r1
	lll->periph.window_size_prepare_us = 0;
   1fba2:	e9c4 230d 	strd	r2, r3, [r4, #52]	; 0x34
	lll->periph.window_widening_prepare_us = 0;
   1fba6:	62e2      	str	r2, [r4, #44]	; 0x2c
	if (!lll->empty) {
   1fba8:	f894 2052 	ldrb.w	r2, [r4, #82]	; 0x52
   1fbac:	f012 0204 	ands.w	r2, r2, #4
   1fbb0:	d10a      	bne.n	1fbc8 <prepare_cb+0x9c>
		link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL);
   1fbb2:	e9d4 010f 	ldrd	r0, r1, [r4, #60]	; 0x3c
   1fbb6:	f00a fe90 	bl	2a8da <memq_peek>
		if (!link) {
   1fbba:	b928      	cbnz	r0, 1fbc8 <prepare_cb+0x9c>
			lll->empty = 1U;
   1fbbc:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   1fbc0:	f043 0304 	orr.w	r3, r3, #4
   1fbc4:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
	radio_reset();
   1fbc8:	f000 f97c 	bl	1fec4 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1fbcc:	2000      	movs	r0, #0
   1fbce:	f000 f9ad 	bl	1ff2c <radio_tx_power_set>
	lll_conn_rx_pkt_set(lll);
   1fbd2:	4620      	mov	r0, r4
   1fbd4:	f7ff fdde 	bl	1f794 <lll_conn_rx_pkt_set>
	radio_aa_set(lll->access_addr);
   1fbd8:	1d20      	adds	r0, r4, #4
   1fbda:	f000 f9c5 	bl	1ff68 <radio_aa_set>
	return ((uint32_t)src[2] << 16) | sys_get_le16(&src[0]);
   1fbde:	8923      	ldrh	r3, [r4, #8]
   1fbe0:	7aa1      	ldrb	r1, [r4, #10]
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
   1fbe2:	f240 605b 	movw	r0, #1627	; 0x65b
   1fbe6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   1fbea:	f000 fa4f 	bl	2008c <radio_crc_configure>
	lll_chan_set(data_chan_use);
   1fbee:	4628      	mov	r0, r5
   1fbf0:	f7fe fca0 	bl	1e534 <lll_chan_set>
	radio_isr_set(lll_conn_isr_rx, lll);
   1fbf4:	4621      	mov	r1, r4
   1fbf6:	4832      	ldr	r0, [pc, #200]	; (1fcc0 <prepare_cb+0x194>)
   1fbf8:	f000 f944 	bl	1fe84 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1fbfc:	2096      	movs	r0, #150	; 0x96
   1fbfe:	f000 fb79 	bl	202f4 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
   1fc02:	2300      	movs	r3, #0
   1fc04:	461a      	mov	r2, r3
   1fc06:	4619      	mov	r1, r3
   1fc08:	4618      	mov	r0, r3
   1fc0a:	f000 fae1 	bl	201d0 <radio_switch_complete_and_tx>
	ull = HDR_LLL2ULL(lll);
   1fc0e:	f8d4 8000 	ldr.w	r8, [r4]
	ticks_at_event = p->ticks_at_expire;
   1fc12:	6837      	ldr	r7, [r6, #0]
	ticks_at_event += lll_event_offset_get(ull);
   1fc14:	4640      	mov	r0, r8
   1fc16:	f00b fcfa 	bl	2b60e <lll_event_offset_get>
   1fc1a:	4407      	add	r7, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1fc1c:	6872      	ldr	r2, [r6, #4]
   1fc1e:	f107 0109 	add.w	r1, r7, #9
   1fc22:	2000      	movs	r0, #0
   1fc24:	f000 fb72 	bl	2030c <radio_tmr_start>
   1fc28:	4605      	mov	r5, r0
	radio_tmr_aa_capture();
   1fc2a:	f000 fc11 	bl	20450 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   1fc2e:	2000      	movs	r0, #0
   1fc30:	f000 fc28 	bl	20484 <radio_tmr_aa_save>
	       ((EVENT_JITTER_US + EVENT_TICKER_RES_MARGIN_US +
   1fc34:	6b26      	ldr	r6, [r4, #48]	; 0x30
   1fc36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	hcto += radio_rx_ready_delay_get(0, 0);
   1fc38:	2100      	movs	r1, #0
   1fc3a:	eb03 0346 	add.w	r3, r3, r6, lsl #1
   1fc3e:	4608      	mov	r0, r1
   1fc40:	f103 0688 	add.w	r6, r3, #136	; 0x88
   1fc44:	f00b ff31 	bl	2baaa <radio_rx_ready_delay_get>
	hcto += addr_us_get(0);
   1fc48:	4435      	add	r5, r6
	hcto += radio_rx_chain_delay_get(0, 0);
   1fc4a:	2100      	movs	r1, #0
	hcto += addr_us_get(0);
   1fc4c:	4405      	add	r5, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1fc4e:	4608      	mov	r0, r1
   1fc50:	f00b ff2d 	bl	2baae <radio_rx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
   1fc54:	4428      	add	r0, r5
   1fc56:	f000 fbef 	bl	20438 <radio_tmr_hcto_configure>
	if (lll_preempt_calc(ull, (TICKER_ID_CONN_BASE + lll->handle),
   1fc5a:	89a1      	ldrh	r1, [r4, #12]
   1fc5c:	3105      	adds	r1, #5
   1fc5e:	463a      	mov	r2, r7
   1fc60:	b2c9      	uxtb	r1, r1
   1fc62:	4640      	mov	r0, r8
   1fc64:	f00b fce1 	bl	2b62a <lll_preempt_calc>
   1fc68:	b170      	cbz	r0, 1fc88 <prepare_cb+0x15c>
		radio_isr_set(lll_isr_abort, lll);
   1fc6a:	4816      	ldr	r0, [pc, #88]	; (1fcc4 <prepare_cb+0x198>)
   1fc6c:	4621      	mov	r1, r4
   1fc6e:	e768      	b.n	1fb42 <prepare_cb+0x16>
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   1fc70:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1fc74:	7fa1      	ldrb	r1, [r4, #30]
   1fc76:	9300      	str	r3, [sp, #0]
   1fc78:	f104 001f 	add.w	r0, r4, #31
   1fc7c:	f104 0318 	add.w	r3, r4, #24
   1fc80:	f00b fc4e 	bl	2b520 <lll_chan_sel_1>
   1fc84:	4605      	mov	r5, r0
   1fc86:	e780      	b.n	1fb8a <prepare_cb+0x5e>
		ret = lll_prepare_done(lll);
   1fc88:	4620      	mov	r0, r4
   1fc8a:	f00b fcbb 	bl	2b604 <lll_prepare_done>
		LL_ASSERT(!ret);
   1fc8e:	2800      	cmp	r0, #0
   1fc90:	f43f af5b 	beq.w	1fb4a <prepare_cb+0x1e>
   1fc94:	4a07      	ldr	r2, [pc, #28]	; (1fcb4 <prepare_cb+0x188>)
   1fc96:	490c      	ldr	r1, [pc, #48]	; (1fcc8 <prepare_cb+0x19c>)
   1fc98:	4808      	ldr	r0, [pc, #32]	; (1fcbc <prepare_cb+0x190>)
   1fc9a:	f44f 73a7 	mov.w	r3, #334	; 0x14e
   1fc9e:	f005 fa8d 	bl	251bc <printk>
   1fca2:	4040      	eors	r0, r0
   1fca4:	f380 8811 	msr	BASEPRI, r0
   1fca8:	f04f 0003 	mov.w	r0, #3
   1fcac:	df02      	svc	2
   1fcae:	e74c      	b.n	1fb4a <prepare_cb+0x1e>
   1fcb0:	0001e5ed 	.word	0x0001e5ed
   1fcb4:	000348a0 	.word	0x000348a0
   1fcb8:	00031059 	.word	0x00031059
   1fcbc:	0002f8b5 	.word	0x0002f8b5
   1fcc0:	0001f865 	.word	0x0001f865
   1fcc4:	0002b687 	.word	0x0002b687
   1fcc8:	000340d7 	.word	0x000340d7

0001fccc <lll_periph_prepare>:
{
   1fccc:	b513      	push	{r0, r1, r4, lr}
   1fcce:	4604      	mov	r4, r0
	err = lll_hfclock_on();
   1fcd0:	f7fe fdae 	bl	1e830 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
   1fcd4:	2800      	cmp	r0, #0
   1fcd6:	da0b      	bge.n	1fcf0 <lll_periph_prepare+0x24>
   1fcd8:	4a17      	ldr	r2, [pc, #92]	; (1fd38 <lll_periph_prepare+0x6c>)
   1fcda:	4918      	ldr	r1, [pc, #96]	; (1fd3c <lll_periph_prepare+0x70>)
   1fcdc:	4818      	ldr	r0, [pc, #96]	; (1fd40 <lll_periph_prepare+0x74>)
   1fcde:	234d      	movs	r3, #77	; 0x4d
   1fce0:	f005 fa6c 	bl	251bc <printk>
   1fce4:	4040      	eors	r0, r0
   1fce6:	f380 8811 	msr	BASEPRI, r0
   1fcea:	f04f 0003 	mov.w	r0, #3
   1fcee:	df02      	svc	2
	lll = p->param;
   1fcf0:	68e2      	ldr	r2, [r4, #12]
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
   1fcf2:	8921      	ldrh	r1, [r4, #8]
   1fcf4:	6a53      	ldr	r3, [r2, #36]	; 0x24
	err = lll_prepare(lll_is_abort_cb, lll_conn_abort_cb, prepare_cb, 0, p);
   1fcf6:	4813      	ldr	r0, [pc, #76]	; (1fd44 <lll_periph_prepare+0x78>)
	    lll->periph.window_widening_periodic_us * (p->lazy + 1);
   1fcf8:	fb01 3303 	mla	r3, r1, r3, r3
	lll->periph.window_widening_prepare_us +=
   1fcfc:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
   1fcfe:	440b      	add	r3, r1
	    lll->periph.window_widening_max_us) {
   1fd00:	6a91      	ldr	r1, [r2, #40]	; 0x28
		lll->periph.window_widening_prepare_us =
   1fd02:	4299      	cmp	r1, r3
   1fd04:	bf94      	ite	ls
   1fd06:	62d1      	strls	r1, [r2, #44]	; 0x2c
   1fd08:	62d3      	strhi	r3, [r2, #44]	; 0x2c
	err = lll_prepare(lll_is_abort_cb, lll_conn_abort_cb, prepare_cb, 0, p);
   1fd0a:	4a0f      	ldr	r2, [pc, #60]	; (1fd48 <lll_periph_prepare+0x7c>)
   1fd0c:	490f      	ldr	r1, [pc, #60]	; (1fd4c <lll_periph_prepare+0x80>)
   1fd0e:	9400      	str	r4, [sp, #0]
   1fd10:	2300      	movs	r3, #0
   1fd12:	f00b f977 	bl	2b004 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1fd16:	b168      	cbz	r0, 1fd34 <lll_periph_prepare+0x68>
   1fd18:	3077      	adds	r0, #119	; 0x77
   1fd1a:	d00b      	beq.n	1fd34 <lll_periph_prepare+0x68>
   1fd1c:	4a06      	ldr	r2, [pc, #24]	; (1fd38 <lll_periph_prepare+0x6c>)
   1fd1e:	490c      	ldr	r1, [pc, #48]	; (1fd50 <lll_periph_prepare+0x84>)
   1fd20:	4807      	ldr	r0, [pc, #28]	; (1fd40 <lll_periph_prepare+0x74>)
   1fd22:	235e      	movs	r3, #94	; 0x5e
   1fd24:	f005 fa4a 	bl	251bc <printk>
   1fd28:	4040      	eors	r0, r0
   1fd2a:	f380 8811 	msr	BASEPRI, r0
   1fd2e:	f04f 0003 	mov.w	r0, #3
   1fd32:	df02      	svc	2
}
   1fd34:	b002      	add	sp, #8
   1fd36:	bd10      	pop	{r4, pc}
   1fd38:	000348a0 	.word	0x000348a0
   1fd3c:	000346f1 	.word	0x000346f1
   1fd40:	0002f8b5 	.word	0x0002f8b5
   1fd44:	0002b609 	.word	0x0002b609
   1fd48:	0001fb2d 	.word	0x0001fb2d
   1fd4c:	0001f739 	.word	0x0001f739
   1fd50:	000347ae 	.word	0x000347ae

0001fd54 <cntr_init>:

static uint8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   1fd54:	4b05      	ldr	r3, [pc, #20]	; (1fd6c <cntr_init+0x18>)
   1fd56:	2200      	movs	r2, #0
   1fd58:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   1fd5c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1fd60:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   1fd64:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   1fd68:	4770      	bx	lr
   1fd6a:	bf00      	nop
   1fd6c:	4000b000 	.word	0x4000b000

0001fd70 <cntr_start>:

uint32_t cntr_start(void)
{
	if (_refcount++) {
   1fd70:	4a04      	ldr	r2, [pc, #16]	; (1fd84 <cntr_start+0x14>)
   1fd72:	7813      	ldrb	r3, [r2, #0]
   1fd74:	1c59      	adds	r1, r3, #1
   1fd76:	7011      	strb	r1, [r2, #0]
   1fd78:	2001      	movs	r0, #1
   1fd7a:	b913      	cbnz	r3, 1fd82 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   1fd7c:	4a02      	ldr	r2, [pc, #8]	; (1fd88 <cntr_start+0x18>)
   1fd7e:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   1fd80:	4618      	mov	r0, r3
}
   1fd82:	4770      	bx	lr
   1fd84:	20003b3a 	.word	0x20003b3a
   1fd88:	4000b000 	.word	0x4000b000

0001fd8c <cntr_stop>:

uint32_t cntr_stop(void)
{
   1fd8c:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   1fd8e:	4c0d      	ldr	r4, [pc, #52]	; (1fdc4 <cntr_stop+0x38>)
   1fd90:	7823      	ldrb	r3, [r4, #0]
   1fd92:	b95b      	cbnz	r3, 1fdac <cntr_stop+0x20>
   1fd94:	4a0c      	ldr	r2, [pc, #48]	; (1fdc8 <cntr_stop+0x3c>)
   1fd96:	490d      	ldr	r1, [pc, #52]	; (1fdcc <cntr_stop+0x40>)
   1fd98:	480d      	ldr	r0, [pc, #52]	; (1fdd0 <cntr_stop+0x44>)
   1fd9a:	232d      	movs	r3, #45	; 0x2d
   1fd9c:	f005 fa0e 	bl	251bc <printk>
   1fda0:	4040      	eors	r0, r0
   1fda2:	f380 8811 	msr	BASEPRI, r0
   1fda6:	f04f 0003 	mov.w	r0, #3
   1fdaa:	df02      	svc	2

	if (--_refcount) {
   1fdac:	7820      	ldrb	r0, [r4, #0]
   1fdae:	3801      	subs	r0, #1
   1fdb0:	b2c0      	uxtb	r0, r0
   1fdb2:	7020      	strb	r0, [r4, #0]
   1fdb4:	2301      	movs	r3, #1
   1fdb6:	b910      	cbnz	r0, 1fdbe <cntr_stop+0x32>
   1fdb8:	4a06      	ldr	r2, [pc, #24]	; (1fdd4 <cntr_stop+0x48>)
   1fdba:	6053      	str	r3, [r2, #4]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   1fdbc:	bd10      	pop	{r4, pc}
		return 1;
   1fdbe:	4618      	mov	r0, r3
   1fdc0:	e7fc      	b.n	1fdbc <cntr_stop+0x30>
   1fdc2:	bf00      	nop
   1fdc4:	20003b3a 	.word	0x20003b3a
   1fdc8:	00034904 	.word	0x00034904
   1fdcc:	00034950 	.word	0x00034950
   1fdd0:	0002f8b5 	.word	0x0002f8b5
   1fdd4:	4000b000 	.word	0x4000b000

0001fdd8 <cntr_cnt_get>:
     return p_reg->COUNTER;
   1fdd8:	4b01      	ldr	r3, [pc, #4]	; (1fde0 <cntr_cnt_get+0x8>)
   1fdda:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

uint32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   1fdde:	4770      	bx	lr
   1fde0:	4000b000 	.word	0x4000b000

0001fde4 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   1fde4:	4b02      	ldr	r3, [pc, #8]	; (1fdf0 <cntr_cmp_set+0xc>)
   1fde6:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   1fdea:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(uint8_t cmp, uint32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   1fdee:	4770      	bx	lr
   1fdf0:	4000b000 	.word	0x4000b000

0001fdf4 <do_ecb>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fdf4:	4b10      	ldr	r3, [pc, #64]	; (1fe38 <do_ecb+0x44>)
	uint8_t clear_text[16];
	uint8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   1fdf6:	b530      	push	{r4, r5, lr}
   1fdf8:	2201      	movs	r2, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
   1fdfa:	2400      	movs	r4, #0
   1fdfc:	605a      	str	r2, [r3, #4]
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
   1fdfe:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   1fe02:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   1fe06:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
   1fe0a:	601a      	str	r2, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   1fe0c:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   1fe10:	b931      	cbnz	r1, 1fe20 <do_ecb+0x2c>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   1fe12:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   1fe16:	b919      	cbnz	r1, 1fe20 <do_ecb+0x2c>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   1fe18:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   1fe1c:	2900      	cmp	r1, #0
   1fe1e:	d1f5      	bne.n	1fe0c <do_ecb+0x18>
   1fe20:	605a      	str	r2, [r3, #4]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   1fe22:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
   1fe26:	2900      	cmp	r1, #0
   1fe28:	d1e8      	bne.n	1fdfc <do_ecb+0x8>
   1fe2a:	f8d3 5504 	ldr.w	r5, [r3, #1284]	; 0x504
   1fe2e:	2d00      	cmp	r5, #0
   1fe30:	d0e4      	beq.n	1fdfc <do_ecb+0x8>

	NRF_ECB->ECBDATAPTR = 0;
   1fe32:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
}
   1fe36:	bd30      	pop	{r4, r5, pc}
   1fe38:	4000e000 	.word	0x4000e000

0001fe3c <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(uint8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
   1fe3c:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   1fe3e:	4b08      	ldr	r3, [pc, #32]	; (1fe60 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
   1fe40:	bf14      	ite	ne
   1fe42:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
   1fe46:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
   1fe4a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
   1fe4e:	bf14      	ite	ne
   1fe50:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
   1fe54:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
   1fe58:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
   1fe5c:	4770      	bx	lr
   1fe5e:	bf00      	nop
   1fe60:	4001f000 	.word	0x4001f000

0001fe64 <isr_radio>:
}
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

uint32_t radio_has_disabled(void)
{
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   1fe64:	4b04      	ldr	r3, [pc, #16]	; (1fe78 <isr_radio+0x14>)
   1fe66:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   1fe6a:	b123      	cbz	r3, 1fe76 <isr_radio+0x12>
		isr_cb(isr_cb_param);
   1fe6c:	4b03      	ldr	r3, [pc, #12]	; (1fe7c <isr_radio+0x18>)
   1fe6e:	4a04      	ldr	r2, [pc, #16]	; (1fe80 <isr_radio+0x1c>)
   1fe70:	681b      	ldr	r3, [r3, #0]
   1fe72:	6810      	ldr	r0, [r2, #0]
   1fe74:	4718      	bx	r3
}
   1fe76:	4770      	bx	lr
   1fe78:	40001000 	.word	0x40001000
   1fe7c:	200035d0 	.word	0x200035d0
   1fe80:	200035d4 	.word	0x200035d4

0001fe84 <radio_isr_set>:
{
   1fe84:	b538      	push	{r3, r4, r5, lr}
   1fe86:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   1fe88:	2001      	movs	r0, #1
{
   1fe8a:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   1fe8c:	f7e4 fbf4 	bl	4678 <arch_irq_disable>
	isr_cb_param = param;
   1fe90:	4b08      	ldr	r3, [pc, #32]	; (1feb4 <radio_isr_set+0x30>)
   1fe92:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
   1fe94:	4b08      	ldr	r3, [pc, #32]	; (1feb8 <radio_isr_set+0x34>)
   1fe96:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1fe98:	4b08      	ldr	r3, [pc, #32]	; (1febc <radio_isr_set+0x38>)
   1fe9a:	2210      	movs	r2, #16
   1fe9c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1fea0:	4b07      	ldr	r3, [pc, #28]	; (1fec0 <radio_isr_set+0x3c>)
   1fea2:	2202      	movs	r2, #2
   1fea4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
   1fea8:	2001      	movs	r0, #1
}
   1feaa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   1feae:	f7e4 bbd3 	b.w	4658 <arch_irq_enable>
   1feb2:	bf00      	nop
   1feb4:	200035d4 	.word	0x200035d4
   1feb8:	200035d0 	.word	0x200035d0
   1febc:	40001000 	.word	0x40001000
   1fec0:	e000e100 	.word	0xe000e100

0001fec4 <radio_reset>:
{
   1fec4:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
   1fec6:	2001      	movs	r0, #1
   1fec8:	f7e4 fbd6 	bl	4678 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (radio_power ? RADIO_POWER_POWER_Enabled : RADIO_POWER_POWER_Disabled)
   1fecc:	4a0d      	ldr	r2, [pc, #52]	; (1ff04 <radio_reset+0x40>)
   1fece:	2300      	movs	r3, #0
   1fed0:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
   1fed4:	2301      	movs	r3, #1
   1fed6:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

static inline void hal_radio_reset(void)
{
	/* Anomalies 102, 106 and 107 */
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
   1feda:	f8d2 3774 	ldr.w	r3, [r2, #1908]	; 0x774
					 0xfffffffe) | 0x01000000;
   1fede:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   1fee2:	f023 0301 	bic.w	r3, r3, #1
   1fee6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
   1feea:	f8c2 3774 	str.w	r3, [r2, #1908]	; 0x774
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   1feee:	4b06      	ldr	r3, [pc, #24]	; (1ff08 <radio_reset+0x44>)
   1fef0:	f44f 5290 	mov.w	r2, #4608	; 0x1200
   1fef4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		BIT(HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(0)) |
#if defined(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PHYEND_DELAY_COMPENSATION_PPI(0)) |
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PPI(0));
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   1fef8:	f44f 5210 	mov.w	r2, #9216	; 0x2400
   1fefc:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   1ff00:	bd08      	pop	{r3, pc}
   1ff02:	bf00      	nop
   1ff04:	40001000 	.word	0x40001000
   1ff08:	4001f000 	.word	0x4001f000

0001ff0c <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   1ff0c:	4b06      	ldr	r3, [pc, #24]	; (1ff28 <radio_phy_set+0x1c>)
	default:
		mode = RADIO_MODE_MODE_Ble_1Mbit;
		break;

	case BIT(1):
		mode = RADIO_MODE_MODE_Ble_2Mbit;
   1ff0e:	2802      	cmp	r0, #2
   1ff10:	bf14      	ite	ne
   1ff12:	2203      	movne	r2, #3
   1ff14:	2204      	moveq	r2, #4
   1ff16:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   1ff1a:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   1ff1e:	f042 0201 	orr.w	r2, r2, #1
   1ff22:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   1ff26:	4770      	bx	lr
   1ff28:	40001000 	.word	0x40001000

0001ff2c <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (uint32_t)power;
   1ff2c:	4b01      	ldr	r3, [pc, #4]	; (1ff34 <radio_tx_power_set+0x8>)
   1ff2e:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   1ff32:	4770      	bx	lr
   1ff34:	40001000 	.word	0x40001000

0001ff38 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   1ff38:	4b01      	ldr	r3, [pc, #4]	; (1ff40 <radio_freq_chan_set+0x8>)
   1ff3a:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   1ff3e:	4770      	bx	lr
   1ff40:	40001000 	.word	0x40001000

0001ff44 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   1ff44:	4b07      	ldr	r3, [pc, #28]	; (1ff64 <radio_whiten_iv_set+0x20>)
   1ff46:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   1ff4a:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1ff4e:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   1ff52:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   1ff56:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1ff5a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   1ff5e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   1ff62:	4770      	bx	lr
   1ff64:	40001000 	.word	0x40001000

0001ff68 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   1ff68:	4a0a      	ldr	r2, [pc, #40]	; (1ff94 <radio_aa_set+0x2c>)
   1ff6a:	2300      	movs	r3, #0
   1ff6c:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   1ff70:	2301      	movs	r3, #1
   1ff72:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   1ff76:	78c3      	ldrb	r3, [r0, #3]
   1ff78:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   1ff7c:	7843      	ldrb	r3, [r0, #1]
   1ff7e:	7881      	ldrb	r1, [r0, #2]
   1ff80:	041b      	lsls	r3, r3, #16
   1ff82:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   1ff86:	7801      	ldrb	r1, [r0, #0]
   1ff88:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1ff8c:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   1ff90:	4770      	bx	lr
   1ff92:	bf00      	nop
   1ff94:	40001000 	.word	0x40001000

0001ff98 <radio_pkt_configure>:
	switch (phy) {
   1ff98:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   1ff9c:	2b02      	cmp	r3, #2
   1ff9e:	bf14      	ite	ne
   1ffa0:	2300      	movne	r3, #0
   1ffa2:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
	if (pdu_type == RADIO_PKT_CONF_PDU_TYPE_DC) {
   1ffa6:	07d2      	lsls	r2, r2, #31
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   1ffa8:	bf48      	it	mi
   1ffaa:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
		((((uint32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) & RADIO_PCNF0_LFLEN_Msk) |
   1ffae:	f000 000f 	and.w	r0, r0, #15
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
   1ffb2:	4318      	orrs	r0, r3
	NRF_RADIO->PCNF0 =
   1ffb4:	4b09      	ldr	r3, [pc, #36]	; (1ffdc <radio_pkt_configure+0x44>)
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   1ffb6:	4a0a      	ldr	r2, [pc, #40]	; (1ffe0 <radio_pkt_configure+0x48>)
		((((uint32_t)bits_s1) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) | extra;
   1ffb8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
	NRF_RADIO->PCNF0 =
   1ffbc:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   1ffc0:	f8d3 0518 	ldr.w	r0, [r3, #1304]	; 0x518
   1ffc4:	4002      	ands	r2, r0
   1ffc6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |=
   1ffca:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   1ffce:	4311      	orrs	r1, r2
   1ffd0:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   1ffd4:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
}
   1ffd8:	4770      	bx	lr
   1ffda:	bf00      	nop
   1ffdc:	40001000 	.word	0x40001000
   1ffe0:	fef80000 	.word	0xfef80000

0001ffe4 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (uint32_t)rx_packet;
   1ffe4:	4b01      	ldr	r3, [pc, #4]	; (1ffec <radio_pkt_rx_set+0x8>)
   1ffe6:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   1ffea:	4770      	bx	lr
   1ffec:	40001000 	.word	0x40001000

0001fff0 <radio_pkt_tx_set>:
   1fff0:	4b01      	ldr	r3, [pc, #4]	; (1fff8 <radio_pkt_tx_set+0x8>)
   1fff2:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   1fff6:	4770      	bx	lr
   1fff8:	40001000 	.word	0x40001000

0001fffc <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fffc:	4b01      	ldr	r3, [pc, #4]	; (20004 <radio_rx_enable+0x8>)
   1fffe:	2201      	movs	r2, #1
   20000:	605a      	str	r2, [r3, #4]
}
   20002:	4770      	bx	lr
   20004:	40001000 	.word	0x40001000

00020008 <radio_tx_enable>:
   20008:	4b01      	ldr	r3, [pc, #4]	; (20010 <radio_tx_enable+0x8>)
   2000a:	2201      	movs	r2, #1
   2000c:	601a      	str	r2, [r3, #0]
}
   2000e:	4770      	bx	lr
   20010:	40001000 	.word	0x40001000

00020014 <radio_disable>:
    p_reg->CHENCLR = mask;
   20014:	4a07      	ldr	r2, [pc, #28]	; (20034 <radio_disable+0x20>)
   20016:	f44f 6310 	mov.w	r3, #2304	; 0x900
   2001a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   2001e:	2301      	movs	r3, #1
   20020:	6053      	str	r3, [r2, #4]
   20022:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
   20024:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
   20028:	2100      	movs	r1, #0
   2002a:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   2002e:	6113      	str	r3, [r2, #16]
}
   20030:	4770      	bx	lr
   20032:	bf00      	nop
   20034:	4001f000 	.word	0x4001f000

00020038 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   20038:	4b04      	ldr	r3, [pc, #16]	; (2004c <radio_status_reset+0x14>)
   2003a:	2200      	movs	r2, #0
   2003c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   20040:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   20044:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   20048:	4770      	bx	lr
   2004a:	bf00      	nop
   2004c:	40001000 	.word	0x40001000

00020050 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   20050:	4b03      	ldr	r3, [pc, #12]	; (20060 <radio_is_ready+0x10>)
   20052:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   20056:	3800      	subs	r0, #0
   20058:	bf18      	it	ne
   2005a:	2001      	movne	r0, #1
   2005c:	4770      	bx	lr
   2005e:	bf00      	nop
   20060:	40001000 	.word	0x40001000

00020064 <radio_is_done>:
	return (NRF_RADIO->NRF_RADIO_TXRX_END_EVENT != 0);
   20064:	4b03      	ldr	r3, [pc, #12]	; (20074 <radio_is_done+0x10>)
   20066:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   2006a:	3800      	subs	r0, #0
   2006c:	bf18      	it	ne
   2006e:	2001      	movne	r0, #1
   20070:	4770      	bx	lr
   20072:	bf00      	nop
   20074:	40001000 	.word	0x40001000

00020078 <radio_is_idle>:
}

uint32_t radio_is_idle(void)
{
	return (NRF_RADIO->STATE == 0);
   20078:	4b03      	ldr	r3, [pc, #12]	; (20088 <radio_is_idle+0x10>)
   2007a:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
   2007e:	fab0 f080 	clz	r0, r0
   20082:	0940      	lsrs	r0, r0, #5
   20084:	4770      	bx	lr
   20086:	bf00      	nop
   20088:	40001000 	.word	0x40001000

0002008c <radio_crc_configure>:

void radio_crc_configure(uint32_t polynomial, uint32_t iv)
{
	NRF_RADIO->CRCCNF =
   2008c:	4b04      	ldr	r3, [pc, #16]	; (200a0 <radio_crc_configure+0x14>)
   2008e:	f240 1203 	movw	r2, #259	; 0x103
   20092:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	    (((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) &
	     RADIO_CRCCNF_SKIPADDR_Msk) |
	    (((RADIO_CRCCNF_LEN_Three) << RADIO_CRCCNF_LEN_Pos) &
	       RADIO_CRCCNF_LEN_Msk);
	NRF_RADIO->CRCPOLY = polynomial;
   20096:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   2009a:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   2009e:	4770      	bx	lr
   200a0:	40001000 	.word	0x40001000

000200a4 <radio_crc_is_valid>:

uint32_t radio_crc_is_valid(void)
{
	return (NRF_RADIO->CRCSTATUS != 0);
   200a4:	4b03      	ldr	r3, [pc, #12]	; (200b4 <radio_crc_is_valid+0x10>)
   200a6:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   200aa:	3800      	subs	r0, #0
   200ac:	bf18      	it	ne
   200ae:	2001      	movne	r0, #1
   200b0:	4770      	bx	lr
   200b2:	bf00      	nop
   200b4:	40001000 	.word	0x40001000

000200b8 <radio_pkt_empty_get>:
				       PDU_AC_LL_SIZE_MAX)];

void *radio_pkt_empty_get(void)
{
	return _pkt_empty;
}
   200b8:	4800      	ldr	r0, [pc, #0]	; (200bc <radio_pkt_empty_get+0x4>)
   200ba:	4770      	bx	lr
   200bc:	200034c8 	.word	0x200034c8

000200c0 <radio_pkt_scratch_get>:

void *radio_pkt_scratch_get(void)
{
	return _pkt_scratch;
}
   200c0:	4800      	ldr	r0, [pc, #0]	; (200c4 <radio_pkt_scratch_get+0x4>)
   200c2:	4770      	bx	lr
   200c4:	200034cc 	.word	0x200034cc

000200c8 <sw_switch>:
 *                         direction to next direction.
 */
void sw_switch(uint8_t dir_curr, uint8_t dir_next, uint8_t phy_curr, uint8_t flags_curr,
	       uint8_t phy_next, uint8_t flags_next,
	       enum radio_end_evt_delay_state end_evt_delay_en)
{
   200c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   200ca:	4d31      	ldr	r5, [pc, #196]	; (20190 <sw_switch+0xc8>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
   200cc:	4f31      	ldr	r7, [pc, #196]	; (20194 <sw_switch+0xcc>)
   200ce:	782e      	ldrb	r6, [r5, #0]
   200d0:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 20198 <sw_switch+0xd0>
{
   200d4:	f89d c014 	ldrb.w	ip, [sp, #20]
   200d8:	f8c7 e568 	str.w	lr, [r7, #1384]	; 0x568
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   200dc:	00f3      	lsls	r3, r6, #3
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   200de:	f106 040c 	add.w	r4, r6, #12
   200e2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   200e6:	b2e4      	uxtb	r4, r4
   200e8:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   200ec:	00e4      	lsls	r4, r4, #3
   200ee:	f8c7 356c 	str.w	r3, [r7, #1388]	; 0x56c
	nrf_ppi_event_endpoint_setup(
   200f2:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   200f6:	4b29      	ldr	r3, [pc, #164]	; (2019c <sw_switch+0xd4>)
   200f8:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
   200fc:	eb03 0386 	add.w	r3, r3, r6, lsl #2

	/* NOTE: As constants are passed to dir_curr and dir_next, the
	 *       compiler should optimize out the redundant code path
	 *       during the optimization.
	 */
	if (dir_next == SW_SWITCH_TX) {
   20100:	2901      	cmp	r1, #1
   20102:	ea4f 0786 	mov.w	r7, r6, lsl #2
    p_reg->CH[(uint32_t) channel].EEP = eep;
   20106:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
   2010a:	d13b      	bne.n	20184 <sw_switch+0xbc>
		/* TX */

		/* Calculate delay with respect to current and next PHY.
		 */
		if (dir_curr == SW_SWITCH_TX) {
   2010c:	2801      	cmp	r0, #1
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_TXEN_TXIDLE_TX_2M_NS;
   2010e:	f24a 035a 	movw	r3, #41050	; 0xa05a
   20112:	d126      	bne.n	20162 <sw_switch+0x9a>
   20114:	f649 4240 	movw	r2, #40000	; 0x9c40
   20118:	f1bc 0f02 	cmp.w	ip, #2
   2011c:	bf08      	it	eq
   2011e:	4613      	moveq	r3, r2
			delay = HAL_RADIO_NS2US_ROUND(
   20120:	f203 13f5 	addw	r3, r3, #501	; 0x1f5
			hal_radio_b2b_txen_on_sw_switch(ppi);
		} else {
			/* If RX PHY is LE Coded, calculate for S8 coding.
			 * Assumption being, S8 has higher delay.
			 */
			delay = HAL_RADIO_NS2US_ROUND(
   20124:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   20128:	fbb3 f3f2 	udiv	r3, r3, r2
    p_reg->CH[(uint32_t) channel].TEP = tep;
   2012c:	4a1c      	ldr	r2, [pc, #112]	; (201a0 <sw_switch+0xd8>)
   2012e:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay < SW_SWITCH_TIMER->CC[cc]) {
   20132:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
   20136:	f502 4210 	add.w	r2, r2, #36864	; 0x9000
   2013a:	f8d2 1540 	ldr.w	r1, [r2, #1344]	; 0x540
   2013e:	4299      	cmp	r1, r3
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 (SW_SWITCH_TIMER->CC[cc] - delay));
   20140:	bf8a      	itet	hi
   20142:	f8d2 1540 	ldrhi.w	r1, [r2, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   20146:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   20148:	1acb      	subhi	r3, r1, r3
   2014a:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    p_reg->CHENSET = mask;
   2014e:	4b11      	ldr	r3, [pc, #68]	; (20194 <sw_switch+0xcc>)
   20150:	f44f 6210 	mov.w	r2, #2304	; 0x900
   20154:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 */
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X */
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
   20158:	1c73      	adds	r3, r6, #1
	sw_tifs_toggle &= 1U;
   2015a:	f003 0301 	and.w	r3, r3, #1
   2015e:	702b      	strb	r3, [r5, #0]
}
   20160:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20162:	f649 4140 	movw	r1, #40000	; 0x9c40
   20166:	f1bc 0f02 	cmp.w	ip, #2
   2016a:	bf08      	it	eq
   2016c:	460b      	moveq	r3, r1
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_NS;
   2016e:	f241 504a 	movw	r0, #5450	; 0x154a
   20172:	f242 41b8 	movw	r1, #9400	; 0x24b8
   20176:	2a02      	cmp	r2, #2
   20178:	bf08      	it	eq
   2017a:	4601      	moveq	r1, r0
			delay = HAL_RADIO_NS2US_ROUND(
   2017c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
   20180:	440b      	add	r3, r1
   20182:	e7cf      	b.n	20124 <sw_switch+0x5c>
    p_reg->CH[(uint32_t) channel].TEP = tep;
   20184:	4b07      	ldr	r3, [pc, #28]	; (201a4 <sw_switch+0xdc>)
   20186:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
   2018a:	232d      	movs	r3, #45	; 0x2d
}
   2018c:	e7d1      	b.n	20132 <sw_switch+0x6a>
   2018e:	bf00      	nop
   20190:	20003b3b 	.word	0x20003b3b
   20194:	4001f000 	.word	0x4001f000
   20198:	4000110c 	.word	0x4000110c
   2019c:	40009140 	.word	0x40009140
   201a0:	40001000 	.word	0x40001000
   201a4:	40001004 	.word	0x40001004

000201a8 <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(uint8_t phy_rx)
{
   201a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   201aa:	4b08      	ldr	r3, [pc, #32]	; (201cc <radio_switch_complete_and_rx+0x24>)
   201ac:	2203      	movs	r2, #3
   201ae:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

	/* NOTE: As Tx chain delays are negligible constant values (~1 us)
	 *	 across nRF5x radios, sw_switch assumes the 1M chain delay for
	 *       calculations.
	 */
	sw_switch(SW_SWITCH_TX, SW_SWITCH_RX, SW_SWITCH_PHY_1M, SW_SWITCH_FLAGS_DONTCARE, phy_rx,
   201b2:	2300      	movs	r3, #0
   201b4:	9000      	str	r0, [sp, #0]
   201b6:	e9cd 3301 	strd	r3, r3, [sp, #4]
   201ba:	461a      	mov	r2, r3
   201bc:	4619      	mov	r1, r3
   201be:	2001      	movs	r0, #1
   201c0:	f7ff ff82 	bl	200c8 <sw_switch>
		  SW_SWITCH_FLAGS_DONTCARE, END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   201c4:	b005      	add	sp, #20
   201c6:	f85d fb04 	ldr.w	pc, [sp], #4
   201ca:	bf00      	nop
   201cc:	40001000 	.word	0x40001000

000201d0 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(uint8_t phy_rx, uint8_t flags_rx,
				  uint8_t phy_tx, uint8_t flags_tx)
{
   201d0:	b530      	push	{r4, r5, lr}
   201d2:	4604      	mov	r4, r0
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   201d4:	4807      	ldr	r0, [pc, #28]	; (201f4 <radio_switch_complete_and_tx+0x24>)
{
   201d6:	b085      	sub	sp, #20
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE;
   201d8:	2503      	movs	r5, #3
   201da:	f8c0 5200 	str.w	r5, [r0, #512]	; 0x200

	sw_switch(SW_SWITCH_RX, SW_SWITCH_TX, phy_rx, flags_rx, phy_tx, flags_tx,
   201de:	2000      	movs	r0, #0
   201e0:	e9cd 3001 	strd	r3, r0, [sp, #4]
   201e4:	9200      	str	r2, [sp, #0]
   201e6:	460b      	mov	r3, r1
   201e8:	4622      	mov	r2, r4
   201ea:	2101      	movs	r1, #1
   201ec:	f7ff ff6c 	bl	200c8 <sw_switch>
		  END_EVT_DELAY_DISABLED);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   201f0:	b005      	add	sp, #20
   201f2:	bd30      	pop	{r4, r5, pc}
   201f4:	40001000 	.word	0x40001000

000201f8 <radio_switch_complete_and_disable>:
void radio_switch_complete_and_disable(void)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);
#else /* CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = (RADIO_SHORTS_READY_START_Msk | NRF_RADIO_SHORTS_PDU_END_DISABLE);
   201f8:	4b05      	ldr	r3, [pc, #20]	; (20210 <radio_switch_complete_and_disable+0x18>)
   201fa:	2203      	movs	r2, #3
   201fc:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
   20200:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   20204:	f44f 6210 	mov.w	r2, #2304	; 0x900
   20208:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   2020c:	4770      	bx	lr
   2020e:	bf00      	nop
   20210:	40001000 	.word	0x40001000

00020214 <radio_rssi_measure>:
#endif /* !CONFIG_BT_CTLR_PHY_CODED */
}

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
   20214:	4a03      	ldr	r2, [pc, #12]	; (20224 <radio_rssi_measure+0x10>)
   20216:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   2021a:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   2021e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
   20222:	4770      	bx	lr
   20224:	40001000 	.word	0x40001000

00020228 <radio_rssi_get>:

uint32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
   20228:	4b01      	ldr	r3, [pc, #4]	; (20230 <radio_rssi_get+0x8>)
   2022a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
   2022e:	4770      	bx	lr
   20230:	40001000 	.word	0x40001000

00020234 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   20234:	4b02      	ldr	r3, [pc, #8]	; (20240 <radio_rssi_status_reset+0xc>)
   20236:	2200      	movs	r2, #0
   20238:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   2023c:	4770      	bx	lr
   2023e:	bf00      	nop
   20240:	40001000 	.word	0x40001000

00020244 <radio_rssi_is_ready>:

uint32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   20244:	4b03      	ldr	r3, [pc, #12]	; (20254 <radio_rssi_is_ready+0x10>)
   20246:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   2024a:	3800      	subs	r0, #0
   2024c:	bf18      	it	ne
   2024e:	2001      	movne	r0, #1
   20250:	4770      	bx	lr
   20252:	bf00      	nop
   20254:	40001000 	.word	0x40001000

00020258 <radio_filter_configure>:

void radio_filter_configure(uint8_t bitmask_enable, uint8_t bitmask_addr_type,
			    uint8_t *bdaddr)
{
   20258:	b5f0      	push	{r4, r5, r6, r7, lr}
   2025a:	2400      	movs	r4, #0
   2025c:	2706      	movs	r7, #6
   2025e:	fb07 f304 	mul.w	r3, r7, r4
   20262:	18d5      	adds	r5, r2, r3
	uint8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
			((uint32_t)bdaddr[2] << 16) |
			((uint32_t)bdaddr[1] << 8) |
   20264:	58d6      	ldr	r6, [r2, r3]
   20266:	00a3      	lsls	r3, r4, #2
   20268:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2026c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
	for (index = 0U; index < 8; index++) {
   20270:	3401      	adds	r4, #1
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
   20272:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((uint32_t)bdaddr[5] << 8) | bdaddr[4];
   20276:	88ad      	ldrh	r5, [r5, #4]
   20278:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
   2027c:	2c08      	cmp	r4, #8
   2027e:	d1ee      	bne.n	2025e <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((uint32_t)bitmask_addr_type << 8) | bitmask_enable;
   20280:	4b02      	ldr	r3, [pc, #8]	; (2028c <radio_filter_configure+0x34>)
   20282:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
   20286:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
   2028a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2028c:	40001000 	.word	0x40001000

00020290 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   20290:	4a03      	ldr	r2, [pc, #12]	; (202a0 <radio_filter_disable+0x10>)
   20292:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   20296:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2029a:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   2029e:	4770      	bx	lr
   202a0:	40001000 	.word	0x40001000

000202a4 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   202a4:	4b02      	ldr	r3, [pc, #8]	; (202b0 <radio_filter_status_reset+0xc>)
   202a6:	2200      	movs	r2, #0
   202a8:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   202ac:	4770      	bx	lr
   202ae:	bf00      	nop
   202b0:	40001000 	.word	0x40001000

000202b4 <radio_filter_has_match>:

uint32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   202b4:	4b03      	ldr	r3, [pc, #12]	; (202c4 <radio_filter_has_match+0x10>)
   202b6:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   202ba:	3800      	subs	r0, #0
   202bc:	bf18      	it	ne
   202be:	2001      	movne	r0, #1
   202c0:	4770      	bx	lr
   202c2:	bf00      	nop
   202c4:	40001000 	.word	0x40001000

000202c8 <radio_filter_match_get>:

uint32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   202c8:	4b01      	ldr	r3, [pc, #4]	; (202d0 <radio_filter_match_get+0x8>)
   202ca:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   202ce:	4770      	bx	lr
   202d0:	40001000 	.word	0x40001000

000202d4 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   202d4:	4b05      	ldr	r3, [pc, #20]	; (202ec <radio_tmr_status_reset+0x18>)
   202d6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   202da:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
   202de:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   202e2:	4a03      	ldr	r2, [pc, #12]	; (202f0 <radio_tmr_status_reset+0x1c>)
   202e4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
#endif /* CONFIG_BT_CTLR_PHY_CODED */
#if defined(CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE)
			BIT(HAL_SW_SWITCH_TIMER_PHYEND_DELAY_COMPENSATION_DISABLE_PPI) |
#endif /* CONFIG_BT_CTLR_DF_PHYEND_OFFSET_COMPENSATION_ENABLE */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   202e8:	4770      	bx	lr
   202ea:	bf00      	nop
   202ec:	4000b000 	.word	0x4000b000
   202f0:	0e7000c0 	.word	0x0e7000c0

000202f4 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(uint32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   202f4:	4b03      	ldr	r3, [pc, #12]	; (20304 <radio_tmr_tifs_set+0x10>)
   202f6:	4a04      	ldr	r2, [pc, #16]	; (20308 <radio_tmr_tifs_set+0x14>)
   202f8:	781b      	ldrb	r3, [r3, #0]
   202fa:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   202fe:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   20302:	4770      	bx	lr
   20304:	20003b3b 	.word	0x20003b3b
   20308:	40009000 	.word	0x40009000

0002030c <radio_tmr_start>:

uint32_t radio_tmr_start(uint8_t trx, uint32_t ticks_start, uint32_t remainder)
{
   2030c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
   2030e:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   20312:	4c2f      	ldr	r4, [pc, #188]	; (203d0 <radio_tmr_start+0xc4>)
   20314:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   20318:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
   2031a:	bf88      	it	hi
   2031c:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20320:	4b2c      	ldr	r3, [pc, #176]	; (203d4 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
   20322:	4c2d      	ldr	r4, [pc, #180]	; (203d8 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
   20324:	bf84      	itt	hi
   20326:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
   2032a:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
   2032e:	f04f 0501 	mov.w	r5, #1

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   20332:	f04f 0600 	mov.w	r6, #0
	remainder /= 1000000UL;
   20336:	fbb2 f4f4 	udiv	r4, r2, r4
	EVENT_TIMER->PRESCALER = 4;
   2033a:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   2033e:	f04f 0202 	mov.w	r2, #2
   20342:	60dd      	str	r5, [r3, #12]
	EVENT_TIMER->MODE = 0;
   20344:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	EVENT_TIMER->PRESCALER = 4;
   20348:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   2034c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
   20350:	4a22      	ldr	r2, [pc, #136]	; (203dc <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
   20352:	f8c3 4540 	str.w	r4, [r3, #1344]	; 0x540
		ticks_start--;
   20356:	bf88      	it	hi
   20358:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   2035c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   20360:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   20364:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   20368:	491d      	ldr	r1, [pc, #116]	; (203e0 <radio_tmr_start+0xd4>)
   2036a:	f502 72a4 	add.w	r2, r2, #328	; 0x148
   2036e:	f8c1 2540 	str.w	r2, [r1, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   20372:	f8c1 3544 	str.w	r3, [r1, #1348]	; 0x544
    p_reg->CHENSET = mask;
   20376:	2340      	movs	r3, #64	; 0x40
   20378:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   2037c:	f7ff fd5e 	bl	1fe3c <hal_radio_enable_on_tick_ppi_config_and_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20380:	4b18      	ldr	r3, [pc, #96]	; (203e4 <radio_tmr_start+0xd8>)
   20382:	60dd      	str	r5, [r3, #12]
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   20384:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   20388:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   2038c:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
   20390:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   20392:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
   20396:	3b74      	subs	r3, #116	; 0x74
   20398:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
   2039c:	f503 43fe 	add.w	r3, r3, #32512	; 0x7f00
   203a0:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
   203a4:	f503 739a 	add.w	r3, r3, #308	; 0x134
   203a8:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
   203ac:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   203b0:	33c4      	adds	r3, #196	; 0xc4
   203b2:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   203b6:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
   203ba:	3bc0      	subs	r3, #192	; 0xc0
   203bc:	f8c1 3560 	str.w	r3, [r1, #1376]	; 0x560
    p_reg->CH[(uint32_t) channel].TEP = tep;
   203c0:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
   203c4:	33c8      	adds	r3, #200	; 0xc8
   203c6:	f8c1 3564 	str.w	r3, [r1, #1380]	; 0x564
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   203ca:	4620      	mov	r0, r4
   203cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   203ce:	bf00      	nop
   203d0:	7ff0bdbf 	.word	0x7ff0bdbf
   203d4:	40008000 	.word	0x40008000
   203d8:	000f4240 	.word	0x000f4240
   203dc:	4000b000 	.word	0x4000b000
   203e0:	4001f000 	.word	0x4001f000
   203e4:	40009000 	.word	0x40009000

000203e8 <radio_tmr_start_now>:
#endif /* CONFIG_SOC_SERIES_NRF53X */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

uint32_t radio_tmr_start_now(uint8_t trx)
{
   203e8:	b510      	push	{r4, lr}
	uint32_t now, start;

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   203ea:	f7ff fd27 	bl	1fe3c <hal_radio_enable_on_tick_ppi_config_and_enable>
   203ee:	4b08      	ldr	r3, [pc, #32]	; (20410 <radio_tmr_start_now+0x28>)
   203f0:	2401      	movs	r4, #1
   203f2:	645c      	str	r4, [r3, #68]	; 0x44
#endif /* CONFIG_SOC_SERIES_NRF53X */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	/* Capture the current time */
	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CAPTURE1);
	now = EVENT_TIMER->CC[1];
   203f4:	f8d3 2544 	ldr.w	r2, [r3, #1348]	; 0x544
	start = now;
   203f8:	4611      	mov	r1, r2

	/* Setup PPI while determining the latency in doing so */
	do {
		/* Set start to be, now plus the determined latency */
		start = (now << 1) - start;
   203fa:	ebc1 0142 	rsb	r1, r1, r2, lsl #1

		/* Setup compare event with min. 1 us offset */
		nrf_timer_cc_set(EVENT_TIMER, 0, start + 1);
   203fe:	1c48      	adds	r0, r1, #1
    p_reg->CC[cc_channel] = cc_value;
   20400:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20404:	645c      	str	r4, [r3, #68]	; 0x44

		/* Capture the current time */
		nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CAPTURE1);

		now = EVENT_TIMER->CC[1];
   20406:	f8d3 2544 	ldr.w	r2, [r3, #1348]	; 0x544
	} while (now > start);
   2040a:	4291      	cmp	r1, r2
   2040c:	d3f5      	bcc.n	203fa <radio_tmr_start_now+0x12>

	return start + 1;
}
   2040e:	bd10      	pop	{r4, pc}
   20410:	40008000 	.word	0x40008000

00020414 <radio_tmr_start_get>:
    return p_reg->CC[ch];
   20414:	4b01      	ldr	r3, [pc, #4]	; (2041c <radio_tmr_start_get+0x8>)
   20416:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548

uint32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   2041a:	4770      	bx	lr
   2041c:	4000b000 	.word	0x4000b000

00020420 <radio_tmr_stop>:
   20420:	4a04      	ldr	r2, [pc, #16]	; (20434 <radio_tmr_stop+0x14>)
   20422:	2301      	movs	r3, #1
   20424:	6053      	str	r3, [r2, #4]
   20426:	6113      	str	r3, [r2, #16]
   20428:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   2042c:	6053      	str	r3, [r2, #4]
   2042e:	6113      	str	r3, [r2, #16]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   20430:	4770      	bx	lr
   20432:	bf00      	nop
   20434:	40008000 	.word	0x40008000

00020438 <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   20438:	4b04      	ldr	r3, [pc, #16]	; (2044c <radio_tmr_hcto_configure+0x14>)
   2043a:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   2043e:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   20442:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   20446:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   2044a:	4770      	bx	lr
   2044c:	40008000 	.word	0x40008000

00020450 <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   20450:	4b06      	ldr	r3, [pc, #24]	; (2046c <radio_tmr_aa_capture+0x1c>)
   20452:	4a07      	ldr	r2, [pc, #28]	; (20470 <radio_tmr_aa_capture+0x20>)
   20454:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    p_reg->CH[(uint32_t) channel].TEP = tep;
   20458:	f502 42de 	add.w	r2, r2, #28416	; 0x6f00
   2045c:	3240      	adds	r2, #64	; 0x40
   2045e:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
    p_reg->CHENSET = mask;
   20462:	4a04      	ldr	r2, [pc, #16]	; (20474 <radio_tmr_aa_capture+0x24>)
   20464:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   20468:	4770      	bx	lr
   2046a:	bf00      	nop
   2046c:	4001f000 	.word	0x4001f000
   20470:	40001100 	.word	0x40001100
   20474:	04000080 	.word	0x04000080

00020478 <radio_tmr_aa_get>:

uint32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   20478:	4b01      	ldr	r3, [pc, #4]	; (20480 <radio_tmr_aa_get+0x8>)
   2047a:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   2047e:	4770      	bx	lr
   20480:	40008000 	.word	0x40008000

00020484 <radio_tmr_aa_save>:

static uint32_t radio_tmr_aa;

void radio_tmr_aa_save(uint32_t aa)
{
	radio_tmr_aa = aa;
   20484:	4b01      	ldr	r3, [pc, #4]	; (2048c <radio_tmr_aa_save+0x8>)
   20486:	6018      	str	r0, [r3, #0]
}
   20488:	4770      	bx	lr
   2048a:	bf00      	nop
   2048c:	200035d8 	.word	0x200035d8

00020490 <radio_tmr_aa_restore>:

uint32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
}
   20490:	4b01      	ldr	r3, [pc, #4]	; (20498 <radio_tmr_aa_restore+0x8>)
   20492:	6818      	ldr	r0, [r3, #0]
   20494:	4770      	bx	lr
   20496:	bf00      	nop
   20498:	200035d8 	.word	0x200035d8

0002049c <radio_tmr_ready_get>:

uint32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   2049c:	4b01      	ldr	r3, [pc, #4]	; (204a4 <radio_tmr_ready_get+0x8>)
   2049e:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   204a2:	4770      	bx	lr
   204a4:	40008000 	.word	0x40008000

000204a8 <radio_tmr_end_capture>:
   204a8:	4b02      	ldr	r3, [pc, #8]	; (204b4 <radio_tmr_end_capture+0xc>)
   204aa:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   204ae:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X ||
	* (CONFIG_SOC_SERIES_NRF53X && !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	*/
}
   204b2:	4770      	bx	lr
   204b4:	4001f000 	.word	0x4001f000

000204b8 <radio_tmr_end_get>:
uint32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   204b8:	4b01      	ldr	r3, [pc, #4]	; (204c0 <radio_tmr_end_get+0x8>)
   204ba:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   204be:	4770      	bx	lr
   204c0:	40008000 	.word	0x40008000

000204c4 <radio_tmr_tifs_base_get>:
   204c4:	4b01      	ldr	r3, [pc, #4]	; (204cc <radio_tmr_tifs_base_get+0x8>)
   204c6:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   204ca:	4770      	bx	lr
   204cc:	40008000 	.word	0x40008000

000204d0 <radio_ar_match_get>:
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}

uint32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
   204d0:	4b01      	ldr	r3, [pc, #4]	; (204d8 <radio_ar_match_get+0x8>)
   204d2:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   204d6:	4770      	bx	lr
   204d8:	4000f000 	.word	0x4000f000

000204dc <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
   204dc:	4a06      	ldr	r2, [pc, #24]	; (204f8 <radio_ar_status_reset+0x1c>)
   204de:	2300      	movs	r3, #0
   204e0:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
   204e4:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   204e8:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
    p_reg->CHENCLR = mask;
   204ec:	4b03      	ldr	r3, [pc, #12]	; (204fc <radio_ar_status_reset+0x20>)
   204ee:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   204f2:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			  AAR_ENABLE_ENABLE_Msk;

	hal_radio_nrf_ppi_channels_disable(BIT(HAL_TRIGGER_AAR_PPI));
}
   204f6:	4770      	bx	lr
   204f8:	40001000 	.word	0x40001000
   204fc:	4001f000 	.word	0x4001f000

00020500 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
   20500:	4b08      	ldr	r3, [pc, #32]	; (20524 <radio_ar_has_match+0x24>)
   20502:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

uint32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
   20506:	b160      	cbz	r0, 20522 <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
   20508:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
   2050c:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
   20510:	b138      	cbz	r0, 20522 <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
   20512:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
   20516:	b120      	cbz	r0, 20522 <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
   20518:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
   2051c:	fab0 f080 	clz	r0, r0
   20520:	0940      	lsrs	r0, r0, #5
}
   20522:	4770      	bx	lr
   20524:	40001000 	.word	0x40001000

00020528 <mayfly_enable_cb>:

void mayfly_enable_cb(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   20528:	2902      	cmp	r1, #2
{
   2052a:	b510      	push	{r4, lr}
   2052c:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   2052e:	d00b      	beq.n	20548 <mayfly_enable_cb+0x20>
   20530:	4a0a      	ldr	r2, [pc, #40]	; (2055c <mayfly_enable_cb+0x34>)
   20532:	490b      	ldr	r1, [pc, #44]	; (20560 <mayfly_enable_cb+0x38>)
   20534:	480b      	ldr	r0, [pc, #44]	; (20564 <mayfly_enable_cb+0x3c>)
   20536:	231e      	movs	r3, #30
   20538:	f004 fe40 	bl	251bc <printk>
   2053c:	4040      	eors	r0, r0
   2053e:	f380 8811 	msr	BASEPRI, r0
   20542:	f04f 0003 	mov.w	r0, #3
   20546:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   20548:	200b      	movs	r0, #11
	if (enable) {
   2054a:	b11c      	cbz	r4, 20554 <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   2054c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   20550:	f7e4 b882 	b.w	4658 <arch_irq_enable>
}
   20554:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   20558:	f7e4 b88e 	b.w	4678 <arch_irq_disable>
   2055c:	0003497b 	.word	0x0003497b
   20560:	000349c9 	.word	0x000349c9
   20564:	0002f8b5 	.word	0x0002f8b5

00020568 <mayfly_is_enabled>:

uint32_t mayfly_is_enabled(uint8_t caller_id, uint8_t callee_id)
{
   20568:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
   2056a:	b181      	cbz	r1, 2058e <mayfly_is_enabled+0x26>
   2056c:	3901      	subs	r1, #1
   2056e:	2901      	cmp	r1, #1
   20570:	d912      	bls.n	20598 <mayfly_is_enabled+0x30>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   20572:	4a0a      	ldr	r2, [pc, #40]	; (2059c <mayfly_is_enabled+0x34>)
   20574:	490a      	ldr	r1, [pc, #40]	; (205a0 <mayfly_is_enabled+0x38>)
   20576:	480b      	ldr	r0, [pc, #44]	; (205a4 <mayfly_is_enabled+0x3c>)
   20578:	2336      	movs	r3, #54	; 0x36
   2057a:	f004 fe1f 	bl	251bc <printk>
   2057e:	4040      	eors	r0, r0
   20580:	f380 8811 	msr	BASEPRI, r0
   20584:	f04f 0003 	mov.w	r0, #3
   20588:	df02      	svc	2
		break;
	}

	return 0;
}
   2058a:	2000      	movs	r0, #0
   2058c:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   2058e:	2018      	movs	r0, #24
}
   20590:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   20594:	f7e4 b884 	b.w	46a0 <arch_irq_is_enabled>
   20598:	200b      	movs	r0, #11
   2059a:	e7f9      	b.n	20590 <mayfly_is_enabled+0x28>
   2059c:	0003497b 	.word	0x0003497b
   205a0:	00031059 	.word	0x00031059
   205a4:	0002f8b5 	.word	0x0002f8b5

000205a8 <mayfly_pend>:

void mayfly_pend(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   205a8:	2901      	cmp	r1, #1
{
   205aa:	b508      	push	{r3, lr}
	switch (callee_id) {
   205ac:	d008      	beq.n	205c0 <mayfly_pend+0x18>
   205ae:	2902      	cmp	r1, #2
   205b0:	d006      	beq.n	205c0 <mayfly_pend+0x18>
   205b2:	b949      	cbnz	r1, 205c8 <mayfly_pend+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   205b4:	4b0b      	ldr	r3, [pc, #44]	; (205e4 <mayfly_pend+0x3c>)
   205b6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   205ba:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	default:
		LL_ASSERT(0);
		break;
	}
}
   205be:	bd08      	pop	{r3, pc}
   205c0:	4b08      	ldr	r3, [pc, #32]	; (205e4 <mayfly_pend+0x3c>)
   205c2:	f44f 6200 	mov.w	r2, #2048	; 0x800
   205c6:	e7f8      	b.n	205ba <mayfly_pend+0x12>
		LL_ASSERT(0);
   205c8:	4a07      	ldr	r2, [pc, #28]	; (205e8 <mayfly_pend+0x40>)
   205ca:	4908      	ldr	r1, [pc, #32]	; (205ec <mayfly_pend+0x44>)
   205cc:	4808      	ldr	r0, [pc, #32]	; (205f0 <mayfly_pend+0x48>)
   205ce:	2367      	movs	r3, #103	; 0x67
   205d0:	f004 fdf4 	bl	251bc <printk>
   205d4:	4040      	eors	r0, r0
   205d6:	f380 8811 	msr	BASEPRI, r0
   205da:	f04f 0003 	mov.w	r0, #3
   205de:	df02      	svc	2
}
   205e0:	e7ed      	b.n	205be <mayfly_pend+0x16>
   205e2:	bf00      	nop
   205e4:	e000e100 	.word	0xe000e100
   205e8:	0003497b 	.word	0x0003497b
   205ec:	00031059 	.word	0x00031059
   205f0:	0002f8b5 	.word	0x0002f8b5

000205f4 <hal_ticker_instance0_caller_id_get>:

uint8_t hal_ticker_instance0_caller_id_get(uint8_t user_id)
{
	uint8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   205f4:	2803      	cmp	r0, #3
{
   205f6:	b510      	push	{r4, lr}
   205f8:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   205fa:	d90b      	bls.n	20614 <hal_ticker_instance0_caller_id_get+0x20>
   205fc:	4a0e      	ldr	r2, [pc, #56]	; (20638 <hal_ticker_instance0_caller_id_get+0x44>)
   205fe:	490f      	ldr	r1, [pc, #60]	; (2063c <hal_ticker_instance0_caller_id_get+0x48>)
   20600:	480f      	ldr	r0, [pc, #60]	; (20640 <hal_ticker_instance0_caller_id_get+0x4c>)
   20602:	232b      	movs	r3, #43	; 0x2b
   20604:	f004 fdda 	bl	251bc <printk>
   20608:	4040      	eors	r0, r0
   2060a:	f380 8811 	msr	BASEPRI, r0
   2060e:	f04f 0003 	mov.w	r0, #3
   20612:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
   20614:	4b0b      	ldr	r3, [pc, #44]	; (20644 <hal_ticker_instance0_caller_id_get+0x50>)
   20616:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   20618:	b95c      	cbnz	r4, 20632 <hal_ticker_instance0_caller_id_get+0x3e>
   2061a:	4a07      	ldr	r2, [pc, #28]	; (20638 <hal_ticker_instance0_caller_id_get+0x44>)
   2061c:	490a      	ldr	r1, [pc, #40]	; (20648 <hal_ticker_instance0_caller_id_get+0x54>)
   2061e:	4808      	ldr	r0, [pc, #32]	; (20640 <hal_ticker_instance0_caller_id_get+0x4c>)
   20620:	232e      	movs	r3, #46	; 0x2e
   20622:	f004 fdcb 	bl	251bc <printk>
   20626:	4040      	eors	r0, r0
   20628:	f380 8811 	msr	BASEPRI, r0
   2062c:	f04f 0003 	mov.w	r0, #3
   20630:	df02      	svc	2

	return caller_id;
}
   20632:	4620      	mov	r0, r4
   20634:	bd10      	pop	{r4, pc}
   20636:	bf00      	nop
   20638:	000349eb 	.word	0x000349eb
   2063c:	00034a39 	.word	0x00034a39
   20640:	0002f8b5 	.word	0x0002f8b5
   20644:	00034a7b 	.word	0x00034a7b
   20648:	00034a59 	.word	0x00034a59

0002064c <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   2064c:	3801      	subs	r0, #1
{
   2064e:	b510      	push	{r4, lr}
   20650:	461c      	mov	r4, r3
	switch (caller_id) {
   20652:	2804      	cmp	r0, #4
   20654:	d845      	bhi.n	206e2 <hal_ticker_instance0_sched+0x96>
   20656:	e8df f000 	tbb	[pc, r0]
   2065a:	1a03      	.short	0x1a03
   2065c:	2c23      	.short	0x2c23
   2065e:	3b          	.byte	0x3b
   2065f:	00          	.byte	0x00
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
   20660:	2904      	cmp	r1, #4
   20662:	d107      	bne.n	20674 <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
   20664:	4b20      	ldr	r3, [pc, #128]	; (206e8 <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   20666:	2102      	movs	r1, #2
			m.param = instance;
   20668:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   2066a:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
   2066c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   20670:	f7f8 bef4 	b.w	1945c <mayfly_enqueue>
			LL_ASSERT(0);
   20674:	234e      	movs	r3, #78	; 0x4e
		LL_ASSERT(0);
   20676:	4a1d      	ldr	r2, [pc, #116]	; (206ec <hal_ticker_instance0_sched+0xa0>)
   20678:	491d      	ldr	r1, [pc, #116]	; (206f0 <hal_ticker_instance0_sched+0xa4>)
   2067a:	481e      	ldr	r0, [pc, #120]	; (206f4 <hal_ticker_instance0_sched+0xa8>)
   2067c:	f004 fd9e 	bl	251bc <printk>
   20680:	4040      	eors	r0, r0
   20682:	f380 8811 	msr	BASEPRI, r0
   20686:	f04f 0003 	mov.w	r0, #3
   2068a:	df02      	svc	2
}
   2068c:	bd10      	pop	{r4, pc}
		switch (callee_id) {
   2068e:	2903      	cmp	r1, #3
   20690:	d104      	bne.n	2069c <hal_ticker_instance0_sched+0x50>
			m.param = instance;
   20692:	4b19      	ldr	r3, [pc, #100]	; (206f8 <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   20694:	2101      	movs	r1, #1
			m.param = instance;
   20696:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   20698:	4608      	mov	r0, r1
   2069a:	e7e7      	b.n	2066c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   2069c:	2365      	movs	r3, #101	; 0x65
   2069e:	e7ea      	b.n	20676 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   206a0:	2904      	cmp	r1, #4
   206a2:	d104      	bne.n	206ae <hal_ticker_instance0_sched+0x62>
			m.param = instance;
   206a4:	4b15      	ldr	r3, [pc, #84]	; (206fc <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   206a6:	2102      	movs	r1, #2
			m.param = instance;
   206a8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   206aa:	2001      	movs	r0, #1
   206ac:	e7de      	b.n	2066c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   206ae:	237c      	movs	r3, #124	; 0x7c
   206b0:	e7e1      	b.n	20676 <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
   206b2:	2903      	cmp	r1, #3
   206b4:	d003      	beq.n	206be <hal_ticker_instance0_sched+0x72>
   206b6:	2904      	cmp	r1, #4
   206b8:	d006      	beq.n	206c8 <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
   206ba:	23a2      	movs	r3, #162	; 0xa2
   206bc:	e7db      	b.n	20676 <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
   206be:	4b10      	ldr	r3, [pc, #64]	; (20700 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   206c0:	2101      	movs	r1, #1
			m.param = instance;
   206c2:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   206c4:	2002      	movs	r0, #2
   206c6:	e7d1      	b.n	2066c <hal_ticker_instance0_sched+0x20>
			m.param = instance;
   206c8:	4b0e      	ldr	r3, [pc, #56]	; (20704 <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   206ca:	2102      	movs	r1, #2
			m.param = instance;
   206cc:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   206ce:	e7e3      	b.n	20698 <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
   206d0:	2904      	cmp	r1, #4
   206d2:	d104      	bne.n	206de <hal_ticker_instance0_sched+0x92>
			m.param = instance;
   206d4:	4b0c      	ldr	r3, [pc, #48]	; (20708 <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   206d6:	2102      	movs	r1, #2
			m.param = instance;
   206d8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   206da:	2003      	movs	r0, #3
   206dc:	e7c6      	b.n	2066c <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
   206de:	23ba      	movs	r3, #186	; 0xba
   206e0:	e7c9      	b.n	20676 <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
   206e2:	23c0      	movs	r3, #192	; 0xc0
   206e4:	e7c7      	b.n	20676 <hal_ticker_instance0_sched+0x2a>
   206e6:	bf00      	nop
   206e8:	20000b44 	.word	0x20000b44
   206ec:	000349eb 	.word	0x000349eb
   206f0:	00031059 	.word	0x00031059
   206f4:	0002f8b5 	.word	0x0002f8b5
   206f8:	20000b34 	.word	0x20000b34
   206fc:	20000b84 	.word	0x20000b84
   20700:	20000b74 	.word	0x20000b74
   20704:	20000b64 	.word	0x20000b64
   20708:	20000b54 	.word	0x20000b54

0002070c <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   2070c:	4b02      	ldr	r3, [pc, #8]	; (20718 <net_buf_pool_get+0xc>)
   2070e:	222c      	movs	r2, #44	; 0x2c
   20710:	fb02 3000 	mla	r0, r2, r0, r3
   20714:	4770      	bx	lr
   20716:	bf00      	nop
   20718:	20000f8c 	.word	0x20000f8c

0002071c <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   2071c:	7982      	ldrb	r2, [r0, #6]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
				__alignof__(struct net_buf));
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   2071e:	4b06      	ldr	r3, [pc, #24]	; (20738 <net_buf_id+0x1c>)
   20720:	212c      	movs	r1, #44	; 0x2c
   20722:	fb01 3302 	mla	r3, r1, r2, r3
   20726:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   20728:	7f1b      	ldrb	r3, [r3, #28]
   2072a:	3317      	adds	r3, #23
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   2072c:	1a80      	subs	r0, r0, r2
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   2072e:	f023 0303 	bic.w	r3, r3, #3

	return offset / struct_size;
}
   20732:	fbb0 f0f3 	udiv	r0, r0, r3
   20736:	4770      	bx	lr
   20738:	20000f8c 	.word	0x20000f8c

0002073c <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
   2073c:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2073e:	4b0a      	ldr	r3, [pc, #40]	; (20768 <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   20740:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   20742:	242c      	movs	r4, #44	; 0x2c
   20744:	fb04 3302 	mla	r3, r4, r2, r3

	*size = MIN(fixed->data_size, *size);
   20748:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2074a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2074c:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   2074e:	6823      	ldr	r3, [r4, #0]
   20750:	429a      	cmp	r2, r3
   20752:	bf94      	ite	ls
   20754:	600a      	strls	r2, [r1, #0]
   20756:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   20758:	f7ff ffe0 	bl	2071c <net_buf_id>
   2075c:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   20760:	fb02 3000 	mla	r0, r2, r0, r3
   20764:	bd10      	pop	{r4, pc}
   20766:	bf00      	nop
   20768:	20000f8c 	.word	0x20000f8c

0002076c <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   2076c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20770:	4605      	mov	r5, r0
   20772:	9101      	str	r1, [sp, #4]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   20774:	4610      	mov	r0, r2
   20776:	4619      	mov	r1, r3
{
   20778:	4691      	mov	r9, r2
   2077a:	4698      	mov	r8, r3
   2077c:	4617      	mov	r7, r2
   2077e:	461e      	mov	r6, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   20780:	f00c fcec 	bl	2d15c <sys_clock_timeout_end_calc>
   20784:	4682      	mov	sl, r0
   20786:	468b      	mov	fp, r1
	__asm__ volatile(
   20788:	f04f 0320 	mov.w	r3, #32
   2078c:	f3ef 8111 	mrs	r1, BASEPRI
   20790:	f383 8812 	msr	BASEPRI_MAX, r3
   20794:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   20798:	8b6b      	ldrh	r3, [r5, #26]
   2079a:	2b00      	cmp	r3, #0
   2079c:	d05a      	beq.n	20854 <net_buf_alloc_len+0xe8>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   2079e:	8b2a      	ldrh	r2, [r5, #24]
   207a0:	429a      	cmp	r2, r3
   207a2:	d93e      	bls.n	20822 <net_buf_alloc_len+0xb6>
   207a4:	9100      	str	r1, [sp, #0]
	return z_impl_k_queue_get(queue, timeout);
   207a6:	2200      	movs	r2, #0
   207a8:	2300      	movs	r3, #0
   207aa:	4628      	mov	r0, r5
   207ac:	f003 fb9e 	bl	23eec <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   207b0:	9900      	ldr	r1, [sp, #0]
   207b2:	4604      	mov	r4, r0
   207b4:	2800      	cmp	r0, #0
   207b6:	d034      	beq.n	20822 <net_buf_alloc_len+0xb6>
	__asm__ volatile(
   207b8:	f381 8811 	msr	BASEPRI, r1
   207bc:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   207c0:	9b01      	ldr	r3, [sp, #4]
   207c2:	2b00      	cmp	r3, #0
   207c4:	d056      	beq.n	20874 <net_buf_alloc_len+0x108>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   207c6:	ea58 0309 	orrs.w	r3, r8, r9
   207ca:	d00f      	beq.n	207ec <net_buf_alloc_len+0x80>
   207cc:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   207d0:	bf08      	it	eq
   207d2:	f1b9 3fff 	cmpeq.w	r9, #4294967295	; 0xffffffff
   207d6:	d009      	beq.n	207ec <net_buf_alloc_len+0x80>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
   207d8:	f004 fa94 	bl	24d04 <sys_clock_tick_get>
   207dc:	ebba 0700 	subs.w	r7, sl, r0
   207e0:	eb6b 0601 	sbc.w	r6, fp, r1
   207e4:	2e00      	cmp	r6, #0
   207e6:	bfbc      	itt	lt
   207e8:	2700      	movlt	r7, #0
   207ea:	463e      	movlt	r6, r7
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   207ec:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   207ee:	f8df 809c 	ldr.w	r8, [pc, #156]	; 2088c <net_buf_alloc_len+0x120>
   207f2:	f04f 092c 	mov.w	r9, #44	; 0x2c
   207f6:	fb09 8303 	mla	r3, r9, r3, r8
   207fa:	463a      	mov	r2, r7
   207fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   207fe:	681b      	ldr	r3, [r3, #0]
   20800:	a901      	add	r1, sp, #4
   20802:	681d      	ldr	r5, [r3, #0]
   20804:	4620      	mov	r0, r4
   20806:	4633      	mov	r3, r6
   20808:	47a8      	blx	r5
   2080a:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   2080c:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   2080e:	2800      	cmp	r0, #0
   20810:	d131      	bne.n	20876 <net_buf_alloc_len+0x10a>
	k_lifo_put(&pool->free, buf);
   20812:	79a0      	ldrb	r0, [r4, #6]
   20814:	4621      	mov	r1, r4
   20816:	fb00 8009 	mla	r0, r0, r9, r8
   2081a:	f00c f9ea 	bl	2cbf2 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   2081e:	462c      	mov	r4, r5
}
   20820:	e024      	b.n	2086c <net_buf_alloc_len+0x100>
		uninit_count = pool->uninit_count--;
   20822:	8b68      	ldrh	r0, [r5, #26]
   20824:	1e43      	subs	r3, r0, #1
   20826:	836b      	strh	r3, [r5, #26]
   20828:	f381 8811 	msr	BASEPRI, r1
   2082c:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   20830:	7f2a      	ldrb	r2, [r5, #28]
   20832:	f102 0417 	add.w	r4, r2, #23
   20836:	f024 0303 	bic.w	r3, r4, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
   2083a:	8b2c      	ldrh	r4, [r5, #24]
   2083c:	1a20      	subs	r0, r4, r0
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
   2083e:	6aac      	ldr	r4, [r5, #40]	; 0x28
   20840:	fb00 4403 	mla	r4, r0, r3, r4
	return pool - _net_buf_pool_list;
   20844:	4811      	ldr	r0, [pc, #68]	; (2088c <net_buf_alloc_len+0x120>)
   20846:	4b12      	ldr	r3, [pc, #72]	; (20890 <net_buf_alloc_len+0x124>)
	buf->user_data_size = pool->user_data_size;
   20848:	71e2      	strb	r2, [r4, #7]
	return pool - _net_buf_pool_list;
   2084a:	1a2d      	subs	r5, r5, r0
   2084c:	10ad      	asrs	r5, r5, #2
   2084e:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
   20850:	71a5      	strb	r5, [r4, #6]
		goto success;
   20852:	e7b5      	b.n	207c0 <net_buf_alloc_len+0x54>
   20854:	f381 8811 	msr	BASEPRI, r1
   20858:	f3bf 8f6f 	isb	sy
   2085c:	464a      	mov	r2, r9
   2085e:	4643      	mov	r3, r8
   20860:	4628      	mov	r0, r5
   20862:	f003 fb43 	bl	23eec <z_impl_k_queue_get>
	if (!buf) {
   20866:	4604      	mov	r4, r0
   20868:	2800      	cmp	r0, #0
   2086a:	d1a9      	bne.n	207c0 <net_buf_alloc_len+0x54>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
   2086c:	4620      	mov	r0, r4
   2086e:	b003      	add	sp, #12
   20870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf->__buf = NULL;
   20874:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
   20876:	2300      	movs	r3, #0
	buf->ref   = 1U;
   20878:	2201      	movs	r2, #1
	buf->frags = NULL;
   2087a:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   2087c:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
   2087e:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
   20880:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
   20882:	6923      	ldr	r3, [r4, #16]
   20884:	81e2      	strh	r2, [r4, #14]
   20886:	60a3      	str	r3, [r4, #8]
	return buf;
   20888:	e7f0      	b.n	2086c <net_buf_alloc_len+0x100>
   2088a:	bf00      	nop
   2088c:	20000f8c 	.word	0x20000f8c
   20890:	ba2e8ba3 	.word	0xba2e8ba3

00020894 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   20894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20898:	4d16      	ldr	r5, [pc, #88]	; (208f4 <net_buf_unref+0x60>)
   2089a:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   2089c:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
   2089e:	272c      	movs	r7, #44	; 0x2c
	while (buf) {
   208a0:	b90c      	cbnz	r4, 208a6 <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   208a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
   208a6:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   208a8:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
   208ac:	3b01      	subs	r3, #1
   208ae:	b2db      	uxtb	r3, r3
   208b0:	7123      	strb	r3, [r4, #4]
   208b2:	2b00      	cmp	r3, #0
   208b4:	d1f5      	bne.n	208a2 <net_buf_unref+0xe>
		if (buf->__buf) {
   208b6:	6921      	ldr	r1, [r4, #16]
   208b8:	b159      	cbz	r1, 208d2 <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   208ba:	7963      	ldrb	r3, [r4, #5]
   208bc:	079b      	lsls	r3, r3, #30
   208be:	d407      	bmi.n	208d0 <net_buf_unref+0x3c>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   208c0:	79a3      	ldrb	r3, [r4, #6]
	pool->alloc->cb->unref(buf, data);
   208c2:	fb07 5303 	mla	r3, r7, r3, r5
   208c6:	4620      	mov	r0, r4
   208c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   208ca:	681b      	ldr	r3, [r3, #0]
   208cc:	689b      	ldr	r3, [r3, #8]
   208ce:	4798      	blx	r3
			buf->__buf = NULL;
   208d0:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
   208d2:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   208d4:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
   208d6:	fb07 5300 	mla	r3, r7, r0, r5
		buf->frags = NULL;
   208da:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   208dc:	6a1b      	ldr	r3, [r3, #32]
   208de:	b11b      	cbz	r3, 208e8 <net_buf_unref+0x54>
			pool->destroy(buf);
   208e0:	4620      	mov	r0, r4
   208e2:	4798      	blx	r3
{
   208e4:	4644      	mov	r4, r8
   208e6:	e7db      	b.n	208a0 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
   208e8:	4621      	mov	r1, r4
   208ea:	fb00 5007 	mla	r0, r0, r7, r5
   208ee:	f00c f980 	bl	2cbf2 <k_queue_prepend>
}
   208f2:	e7f7      	b.n	208e4 <net_buf_unref+0x50>
   208f4:	20000f8c 	.word	0x20000f8c

000208f8 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   208f8:	4b08      	ldr	r3, [pc, #32]	; (2091c <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   208fa:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   208fc:	1ac3      	subs	r3, r0, r3
{
   208fe:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   20900:	4907      	ldr	r1, [pc, #28]	; (20920 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
   20902:	109b      	asrs	r3, r3, #2
{
   20904:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   20906:	4359      	muls	r1, r3
   20908:	4806      	ldr	r0, [pc, #24]	; (20924 <onoff_stop+0x2c>)
   2090a:	2240      	movs	r2, #64	; 0x40
   2090c:	f00b fae1 	bl	2bed2 <stop>
	notify(mgr, res);
   20910:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   20912:	4601      	mov	r1, r0
	notify(mgr, res);
   20914:	4620      	mov	r0, r4
}
   20916:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   2091a:	4718      	bx	r3
   2091c:	2000361c 	.word	0x2000361c
   20920:	b6db6db7 	.word	0xb6db6db7
   20924:	0002d570 	.word	0x0002d570

00020928 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   20928:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   2092a:	4c0c      	ldr	r4, [pc, #48]	; (2095c <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   2092c:	4a0c      	ldr	r2, [pc, #48]	; (20960 <onoff_start+0x38>)
   2092e:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   20930:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   20932:	9300      	str	r3, [sp, #0]
{
   20934:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   20936:	460b      	mov	r3, r1
   20938:	490a      	ldr	r1, [pc, #40]	; (20964 <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
   2093a:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   2093c:	4361      	muls	r1, r4
{
   2093e:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   20940:	4809      	ldr	r0, [pc, #36]	; (20968 <onoff_start+0x40>)
   20942:	f00b faf3 	bl	2bf2c <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   20946:	1e01      	subs	r1, r0, #0
   20948:	da05      	bge.n	20956 <onoff_start+0x2e>
		notify(mgr, err);
   2094a:	4630      	mov	r0, r6
   2094c:	462b      	mov	r3, r5
	}
}
   2094e:	b002      	add	sp, #8
   20950:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
   20954:	4718      	bx	r3
}
   20956:	b002      	add	sp, #8
   20958:	bd70      	pop	{r4, r5, r6, pc}
   2095a:	bf00      	nop
   2095c:	2000361c 	.word	0x2000361c
   20960:	0002bf9b 	.word	0x0002bf9b
   20964:	b6db6db7 	.word	0xb6db6db7
   20968:	0002d570 	.word	0x0002d570

0002096c <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   2096c:	2200      	movs	r2, #0
{
   2096e:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   20970:	2101      	movs	r1, #1
{
   20972:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   20974:	4610      	mov	r0, r2
   20976:	f7e3 fea1 	bl	46bc <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   2097a:	2000      	movs	r0, #0
   2097c:	f7e3 fe6c 	bl	4658 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   20980:	480f      	ldr	r0, [pc, #60]	; (209c0 <clk_init+0x54>)
   20982:	f001 ff39 	bl	227f8 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   20986:	4b0f      	ldr	r3, [pc, #60]	; (209c4 <clk_init+0x58>)
   20988:	4298      	cmp	r0, r3
   2098a:	d115      	bne.n	209b8 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   2098c:	f00b ff58 	bl	2c840 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
   20990:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
   20992:	490d      	ldr	r1, [pc, #52]	; (209c8 <clk_init+0x5c>)
   20994:	4630      	mov	r0, r6
   20996:	f004 fc7a 	bl	2528e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   2099a:	2800      	cmp	r0, #0
   2099c:	db0b      	blt.n	209b6 <clk_init+0x4a>
	struct nrf_clock_control_data *data = dev->data;
   2099e:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   209a0:	4909      	ldr	r1, [pc, #36]	; (209c8 <clk_init+0x5c>)
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   209a2:	2501      	movs	r5, #1
   209a4:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
   209a6:	f104 001c 	add.w	r0, r4, #28
   209aa:	f004 fc70 	bl	2528e <onoff_manager_init>
		if (err < 0) {
   209ae:	2800      	cmp	r0, #0
   209b0:	db01      	blt.n	209b6 <clk_init+0x4a>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   209b2:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
   209b4:	2000      	movs	r0, #0
}
   209b6:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   209b8:	f06f 0004 	mvn.w	r0, #4
   209bc:	e7fb      	b.n	209b6 <clk_init+0x4a>
   209be:	bf00      	nop
   209c0:	00020a01 	.word	0x00020a01
   209c4:	0bad0000 	.word	0x0bad0000
   209c8:	0002e884 	.word	0x0002e884

000209cc <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   209cc:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   209ce:	230c      	movs	r3, #12
   209d0:	4809      	ldr	r0, [pc, #36]	; (209f8 <clkstarted_handle.constprop.0+0x2c>)
   209d2:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
   209d4:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   209d6:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
   209d8:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
   209dc:	2200      	movs	r2, #0
	set_on_state(&sub_data->flags);
   209de:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
   209e0:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   209e2:	4418      	add	r0, r3
   209e4:	f00b fa62 	bl	2beac <set_on_state>
	if (callback) {
   209e8:	b12d      	cbz	r5, 209f6 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   209ea:	4632      	mov	r2, r6
   209ec:	462b      	mov	r3, r5
   209ee:	4803      	ldr	r0, [pc, #12]	; (209fc <clkstarted_handle.constprop.0+0x30>)
}
   209f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   209f4:	4718      	bx	r3
}
   209f6:	bd70      	pop	{r4, r5, r6, pc}
   209f8:	2000361c 	.word	0x2000361c
   209fc:	0002d570 	.word	0x0002d570

00020a00 <clock_event_handler>:
	switch (event) {
   20a00:	b110      	cbz	r0, 20a08 <clock_event_handler+0x8>
   20a02:	2801      	cmp	r0, #1
   20a04:	d004      	beq.n	20a10 <clock_event_handler+0x10>
   20a06:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   20a08:	4b03      	ldr	r3, [pc, #12]	; (20a18 <clock_event_handler+0x18>)
   20a0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   20a0c:	075b      	lsls	r3, r3, #29
   20a0e:	d101      	bne.n	20a14 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   20a10:	f7ff bfdc 	b.w	209cc <clkstarted_handle.constprop.0>
}
   20a14:	4770      	bx	lr
   20a16:	bf00      	nop
   20a18:	2000361c 	.word	0x2000361c

00020a1c <generic_hfclk_start>:
{
   20a1c:	b508      	push	{r3, lr}
	__asm__ volatile(
   20a1e:	f04f 0320 	mov.w	r3, #32
   20a22:	f3ef 8111 	mrs	r1, BASEPRI
   20a26:	f383 8812 	msr	BASEPRI_MAX, r3
   20a2a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   20a2e:	4a12      	ldr	r2, [pc, #72]	; (20a78 <generic_hfclk_start+0x5c>)
   20a30:	6813      	ldr	r3, [r2, #0]
   20a32:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   20a36:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   20a3a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   20a3c:	d00c      	beq.n	20a58 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   20a3e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   20a42:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20a46:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   20a4a:	f013 0301 	ands.w	r3, r3, #1
   20a4e:	d003      	beq.n	20a58 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
   20a50:	480a      	ldr	r0, [pc, #40]	; (20a7c <generic_hfclk_start+0x60>)
   20a52:	f00b fa2b 	bl	2beac <set_on_state>
			already_started = true;
   20a56:	2301      	movs	r3, #1
	__asm__ volatile(
   20a58:	f381 8811 	msr	BASEPRI, r1
   20a5c:	f3bf 8f6f 	isb	sy
	if (already_started) {
   20a60:	b123      	cbz	r3, 20a6c <generic_hfclk_start+0x50>
}
   20a62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   20a66:	2000      	movs	r0, #0
   20a68:	f7ff bfb0 	b.w	209cc <clkstarted_handle.constprop.0>
}
   20a6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   20a70:	2001      	movs	r0, #1
   20a72:	f001 bed1 	b.w	22818 <nrfx_clock_start>
   20a76:	bf00      	nop
   20a78:	2000366c 	.word	0x2000366c
   20a7c:	2000365c 	.word	0x2000365c

00020a80 <api_blocking_start>:
{
   20a80:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   20a82:	2200      	movs	r2, #0
   20a84:	2301      	movs	r3, #1
   20a86:	e9cd 2302 	strd	r2, r3, [sp, #8]
   20a8a:	ab04      	add	r3, sp, #16
   20a8c:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   20a90:	4a09      	ldr	r2, [pc, #36]	; (20ab8 <api_blocking_start+0x38>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   20a92:	f8cd d000 	str.w	sp, [sp]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   20a96:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   20a98:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   20a9c:	f00b fa76 	bl	2bf8c <api_start>
	if (err < 0) {
   20aa0:	2800      	cmp	r0, #0
   20aa2:	db05      	blt.n	20ab0 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
   20aa4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   20aa8:	2300      	movs	r3, #0
   20aaa:	4668      	mov	r0, sp
   20aac:	f003 fa78 	bl	23fa0 <z_impl_k_sem_take>
}
   20ab0:	b007      	add	sp, #28
   20ab2:	f85d fb04 	ldr.w	pc, [sp], #4
   20ab6:	bf00      	nop
   20ab8:	0002bfb3 	.word	0x0002bfb3

00020abc <lfclk_start>:
{
   20abc:	b510      	push	{r4, lr}
	if (!once) {
   20abe:	4c07      	ldr	r4, [pc, #28]	; (20adc <lfclk_start+0x20>)
   20ac0:	7823      	ldrb	r3, [r4, #0]
   20ac2:	b92b      	cbnz	r3, 20ad0 <lfclk_start+0x14>
	z_impl_k_busy_wait(usec_to_wait);
   20ac4:	f44f 70a5 	mov.w	r0, #330	; 0x14a
   20ac8:	f00c fb44 	bl	2d154 <z_impl_k_busy_wait>
		once = true;
   20acc:	2301      	movs	r3, #1
   20ace:	7023      	strb	r3, [r4, #0]
}
   20ad0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   20ad4:	2000      	movs	r0, #0
   20ad6:	f001 be9f 	b.w	22818 <nrfx_clock_start>
   20ada:	bf00      	nop
   20adc:	20003b3c 	.word	0x20003b3c

00020ae0 <generic_hfclk_stop>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   20ae0:	4b09      	ldr	r3, [pc, #36]	; (20b08 <generic_hfclk_stop+0x28>)
   20ae2:	f3bf 8f5b 	dmb	ish
   20ae6:	e853 2f00 	ldrex	r2, [r3]
   20aea:	f022 0102 	bic.w	r1, r2, #2
   20aee:	e843 1000 	strex	r0, r1, [r3]
   20af2:	2800      	cmp	r0, #0
   20af4:	d1f7      	bne.n	20ae6 <generic_hfclk_stop+0x6>
   20af6:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   20afa:	07d3      	lsls	r3, r2, #31
   20afc:	d402      	bmi.n	20b04 <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   20afe:	2001      	movs	r0, #1
   20b00:	f001 bed2 	b.w	228a8 <nrfx_clock_stop>
}
   20b04:	4770      	bx	lr
   20b06:	bf00      	nop
   20b08:	2000366c 	.word	0x2000366c

00020b0c <z_nrf_clock_control_get_onoff>:
}
   20b0c:	4a02      	ldr	r2, [pc, #8]	; (20b18 <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
   20b0e:	b2c3      	uxtb	r3, r0
}
   20b10:	201c      	movs	r0, #28
   20b12:	fb03 2000 	mla	r0, r3, r0, r2
   20b16:	4770      	bx	lr
   20b18:	2000361c 	.word	0x2000361c

00020b1c <z_nrf_clock_bt_ctlr_hf_request>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   20b1c:	4b09      	ldr	r3, [pc, #36]	; (20b44 <z_nrf_clock_bt_ctlr_hf_request+0x28>)
   20b1e:	f3bf 8f5b 	dmb	ish
   20b22:	e853 2f00 	ldrex	r2, [r3]
   20b26:	f042 0101 	orr.w	r1, r2, #1
   20b2a:	e843 1000 	strex	r0, r1, [r3]
   20b2e:	2800      	cmp	r0, #0
   20b30:	d1f7      	bne.n	20b22 <z_nrf_clock_bt_ctlr_hf_request+0x6>
   20b32:	f3bf 8f5b 	dmb	ish
	if (atomic_or(&hfclk_users, HF_USER_BT) & HF_USER_GENERIC) {
   20b36:	0793      	lsls	r3, r2, #30
   20b38:	d402      	bmi.n	20b40 <z_nrf_clock_bt_ctlr_hf_request+0x24>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   20b3a:	2001      	movs	r0, #1
   20b3c:	f001 be6c 	b.w	22818 <nrfx_clock_start>
}
   20b40:	4770      	bx	lr
   20b42:	bf00      	nop
   20b44:	2000366c 	.word	0x2000366c

00020b48 <z_nrf_clock_bt_ctlr_hf_release>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   20b48:	4b09      	ldr	r3, [pc, #36]	; (20b70 <z_nrf_clock_bt_ctlr_hf_release+0x28>)
   20b4a:	f3bf 8f5b 	dmb	ish
   20b4e:	e853 2f00 	ldrex	r2, [r3]
   20b52:	f022 0101 	bic.w	r1, r2, #1
   20b56:	e843 1000 	strex	r0, r1, [r3]
   20b5a:	2800      	cmp	r0, #0
   20b5c:	d1f7      	bne.n	20b4e <z_nrf_clock_bt_ctlr_hf_release+0x6>
   20b5e:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_BT) & HF_USER_GENERIC) {
   20b62:	0793      	lsls	r3, r2, #30
   20b64:	d402      	bmi.n	20b6c <z_nrf_clock_bt_ctlr_hf_release+0x24>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   20b66:	2001      	movs	r0, #1
   20b68:	f001 be9e 	b.w	228a8 <nrfx_clock_stop>
}
   20b6c:	4770      	bx	lr
   20b6e:	bf00      	nop
   20b70:	2000366c 	.word	0x2000366c

00020b74 <z_nrf_clock_control_lf_on>:
{
   20b74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   20b78:	4939      	ldr	r1, [pc, #228]	; (20c60 <z_nrf_clock_control_lf_on+0xec>)
   20b7a:	f3bf 8f5b 	dmb	ish
   20b7e:	4607      	mov	r7, r0
   20b80:	2201      	movs	r2, #1
   20b82:	e851 3f00 	ldrex	r3, [r1]
   20b86:	e841 2000 	strex	r0, r2, [r1]
   20b8a:	2800      	cmp	r0, #0
   20b8c:	d1f9      	bne.n	20b82 <z_nrf_clock_control_lf_on+0xe>
   20b8e:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
   20b92:	b933      	cbnz	r3, 20ba2 <z_nrf_clock_control_lf_on+0x2e>
   20b94:	4933      	ldr	r1, [pc, #204]	; (20c64 <z_nrf_clock_control_lf_on+0xf0>)
		err = onoff_request(mgr, &cli);
   20b96:	4834      	ldr	r0, [pc, #208]	; (20c68 <z_nrf_clock_control_lf_on+0xf4>)
   20b98:	604b      	str	r3, [r1, #4]
   20b9a:	60cb      	str	r3, [r1, #12]
   20b9c:	608a      	str	r2, [r1, #8]
   20b9e:	f004 fb89 	bl	252b4 <onoff_request>
	switch (start_mode) {
   20ba2:	1e7b      	subs	r3, r7, #1
   20ba4:	2b01      	cmp	r3, #1
   20ba6:	d82f      	bhi.n	20c08 <z_nrf_clock_control_lf_on+0x94>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   20ba8:	2f01      	cmp	r7, #1
   20baa:	d107      	bne.n	20bbc <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   20bac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   20bb0:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   20bb4:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   20bb8:	2b01      	cmp	r3, #1
   20bba:	d025      	beq.n	20c08 <z_nrf_clock_control_lf_on+0x94>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   20bbc:	f00b ff4f 	bl	2ca5e <k_is_in_isr>
   20bc0:	4604      	mov	r4, r0
   20bc2:	b918      	cbnz	r0, 20bcc <z_nrf_clock_control_lf_on+0x58>
	return !z_sys_post_kernel;
   20bc4:	4b29      	ldr	r3, [pc, #164]	; (20c6c <z_nrf_clock_control_lf_on+0xf8>)
	int key = isr_mode ? irq_lock() : 0;
   20bc6:	781b      	ldrb	r3, [r3, #0]
   20bc8:	2b00      	cmp	r3, #0
   20bca:	d141      	bne.n	20c50 <z_nrf_clock_control_lf_on+0xdc>
	__asm__ volatile(
   20bcc:	f04f 0320 	mov.w	r3, #32
   20bd0:	f3ef 8611 	mrs	r6, BASEPRI
   20bd4:	f383 8812 	msr	BASEPRI_MAX, r3
   20bd8:	f3bf 8f6f 	isb	sy
   20bdc:	2401      	movs	r4, #1
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20bde:	f8df 8090 	ldr.w	r8, [pc, #144]	; 20c70 <z_nrf_clock_control_lf_on+0xfc>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20be2:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
   20be6:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20bea:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   20bee:	03d2      	lsls	r2, r2, #15
   20bf0:	d50c      	bpl.n	20c0c <z_nrf_clock_control_lf_on+0x98>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   20bf2:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
   20bf6:	2b01      	cmp	r3, #1
   20bf8:	d001      	beq.n	20bfe <z_nrf_clock_control_lf_on+0x8a>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   20bfa:	2f01      	cmp	r7, #1
   20bfc:	d106      	bne.n	20c0c <z_nrf_clock_control_lf_on+0x98>
	if (isr_mode) {
   20bfe:	b30c      	cbz	r4, 20c44 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   20c00:	f386 8811 	msr	BASEPRI, r6
   20c04:	f3bf 8f6f 	isb	sy
}
   20c08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   20c0c:	b1ac      	cbz	r4, 20c3a <z_nrf_clock_control_lf_on+0xc6>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   20c0e:	4630      	mov	r0, r6
   20c10:	f7e3 fcb2 	bl	4578 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   20c14:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   20c18:	2b00      	cmp	r3, #0
   20c1a:	d1e4      	bne.n	20be6 <z_nrf_clock_control_lf_on+0x72>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20c1c:	f8d5 2104 	ldr.w	r2, [r5, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   20c20:	2a00      	cmp	r2, #0
   20c22:	d0e0      	beq.n	20be6 <z_nrf_clock_control_lf_on+0x72>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20c24:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   20c28:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   20c2c:	2301      	movs	r3, #1
   20c2e:	f8c5 3518 	str.w	r3, [r5, #1304]	; 0x518
   20c32:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20c36:	60ab      	str	r3, [r5, #8]
}
   20c38:	e7d5      	b.n	20be6 <z_nrf_clock_control_lf_on+0x72>
	return z_impl_k_sleep(timeout);
   20c3a:	2100      	movs	r1, #0
   20c3c:	2021      	movs	r0, #33	; 0x21
   20c3e:	f003 fe6d 	bl	2491c <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   20c42:	e7e7      	b.n	20c14 <z_nrf_clock_control_lf_on+0xa0>
    p_reg->INTENSET = mask;
   20c44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   20c48:	2202      	movs	r2, #2
   20c4a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   20c4e:	e7db      	b.n	20c08 <z_nrf_clock_control_lf_on+0x94>
    p_reg->INTENCLR = mask;
   20c50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   20c54:	2202      	movs	r2, #2
   20c56:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
   20c5a:	4606      	mov	r6, r0
}
   20c5c:	e7bf      	b.n	20bde <z_nrf_clock_control_lf_on+0x6a>
   20c5e:	bf00      	nop
   20c60:	20003670 	.word	0x20003670
   20c64:	2000360c 	.word	0x2000360c
   20c68:	20003638 	.word	0x20003638
   20c6c:	20003f6d 	.word	0x20003f6d
   20c70:	e000e100 	.word	0xe000e100

00020c74 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   20c74:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   20c76:	4b08      	ldr	r3, [pc, #32]	; (20c98 <uart_console_init+0x24>)
   20c78:	4808      	ldr	r0, [pc, #32]	; (20c9c <uart_console_init+0x28>)
   20c7a:	6018      	str	r0, [r3, #0]
   20c7c:	f00b fe3e 	bl	2c8fc <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
   20c80:	b138      	cbz	r0, 20c92 <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   20c82:	4807      	ldr	r0, [pc, #28]	; (20ca0 <uart_console_init+0x2c>)
   20c84:	f7e4 fa20 	bl	50c8 <__stdout_hook_install>
	__printk_hook_install(console_out);
   20c88:	4805      	ldr	r0, [pc, #20]	; (20ca0 <uart_console_init+0x2c>)
   20c8a:	f7e1 fa63 	bl	2154 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   20c8e:	2000      	movs	r0, #0
}
   20c90:	bd08      	pop	{r3, pc}
		return -ENODEV;
   20c92:	f06f 0012 	mvn.w	r0, #18
   20c96:	e7fb      	b.n	20c90 <uart_console_init+0x1c>
   20c98:	20003674 	.word	0x20003674
   20c9c:	0002d5b8 	.word	0x0002d5b8
   20ca0:	00020ca5 	.word	0x00020ca5

00020ca4 <console_out>:
	if ('\n' == c) {
   20ca4:	280a      	cmp	r0, #10
{
   20ca6:	b538      	push	{r3, r4, r5, lr}
   20ca8:	4d07      	ldr	r5, [pc, #28]	; (20cc8 <console_out+0x24>)
   20caa:	4604      	mov	r4, r0
	if ('\n' == c) {
   20cac:	d104      	bne.n	20cb8 <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
   20cae:	6828      	ldr	r0, [r5, #0]
   20cb0:	6883      	ldr	r3, [r0, #8]
   20cb2:	210d      	movs	r1, #13
   20cb4:	685b      	ldr	r3, [r3, #4]
   20cb6:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   20cb8:	6828      	ldr	r0, [r5, #0]
   20cba:	6883      	ldr	r3, [r0, #8]
   20cbc:	b2e1      	uxtb	r1, r4
   20cbe:	685b      	ldr	r3, [r3, #4]
   20cc0:	4798      	blx	r3
}
   20cc2:	4620      	mov	r0, r4
   20cc4:	bd38      	pop	{r3, r4, r5, pc}
   20cc6:	bf00      	nop
   20cc8:	20003674 	.word	0x20003674

00020ccc <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   20ccc:	b530      	push	{r4, r5, lr}
	return port->config;
   20cce:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   20cd0:	7b04      	ldrb	r4, [r0, #12]
   20cd2:	f001 051f 	and.w	r5, r1, #31
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   20cd6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   20cda:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   20cde:	b085      	sub	sp, #20
   20ce0:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   20ce4:	d104      	bne.n	20cf0 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   20ce6:	4628      	mov	r0, r5
   20ce8:	f002 f87c 	bl	22de4 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   20cec:	2000      	movs	r0, #0
   20cee:	e02e      	b.n	20d4e <gpio_nrfx_pin_interrupt_configure+0x82>
	if (mode == GPIO_INT_MODE_LEVEL) {
   20cf0:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   20cf4:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   20cf8:	d12b      	bne.n	20d52 <gpio_nrfx_pin_interrupt_configure+0x86>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   20cfa:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   20cfe:	bf0c      	ite	eq
   20d00:	2304      	moveq	r3, #4
   20d02:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   20d04:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   20d08:	6883      	ldr	r3, [r0, #8]
   20d0a:	fa23 f101 	lsr.w	r1, r3, r1
   20d0e:	07c9      	lsls	r1, r1, #31
   20d10:	d42b      	bmi.n	20d6a <gpio_nrfx_pin_interrupt_configure+0x9e>
   20d12:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   20d16:	d128      	bne.n	20d6a <gpio_nrfx_pin_interrupt_configure+0x9e>
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   20d18:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   20d1c:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   20d20:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   20d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   20d28:	07db      	lsls	r3, r3, #31
   20d2a:	d41e      	bmi.n	20d6a <gpio_nrfx_pin_interrupt_configure+0x9e>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   20d2c:	f10d 0407 	add.w	r4, sp, #7
   20d30:	4621      	mov	r1, r4
   20d32:	4628      	mov	r0, r5
   20d34:	f001 ffbe 	bl	22cb4 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   20d38:	4b14      	ldr	r3, [pc, #80]	; (20d8c <gpio_nrfx_pin_interrupt_configure+0xc0>)
   20d3a:	4298      	cmp	r0, r3
   20d3c:	d114      	bne.n	20d68 <gpio_nrfx_pin_interrupt_configure+0x9c>
			err = nrfx_gpiote_channel_alloc(&ch);
   20d3e:	4620      	mov	r0, r4
   20d40:	f002 f806 	bl	22d50 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   20d44:	4b12      	ldr	r3, [pc, #72]	; (20d90 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   20d46:	4298      	cmp	r0, r3
   20d48:	d00e      	beq.n	20d68 <gpio_nrfx_pin_interrupt_configure+0x9c>
				return -ENOMEM;
   20d4a:	f06f 000b 	mvn.w	r0, #11
}
   20d4e:	b005      	add	sp, #20
   20d50:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   20d52:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   20d56:	d005      	beq.n	20d64 <gpio_nrfx_pin_interrupt_configure+0x98>
   20d58:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   20d5c:	bf0c      	ite	eq
   20d5e:	2302      	moveq	r3, #2
   20d60:	2301      	movne	r3, #1
   20d62:	e7cf      	b.n	20d04 <gpio_nrfx_pin_interrupt_configure+0x38>
   20d64:	2303      	movs	r3, #3
   20d66:	e7cd      	b.n	20d04 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   20d68:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   20d6a:	2300      	movs	r3, #0
   20d6c:	4619      	mov	r1, r3
   20d6e:	aa02      	add	r2, sp, #8
   20d70:	4628      	mov	r0, r5
   20d72:	f001 fe77 	bl	22a64 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   20d76:	4b06      	ldr	r3, [pc, #24]	; (20d90 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   20d78:	4298      	cmp	r0, r3
   20d7a:	d104      	bne.n	20d86 <gpio_nrfx_pin_interrupt_configure+0xba>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   20d7c:	2101      	movs	r1, #1
   20d7e:	4628      	mov	r0, r5
   20d80:	f001 ffec 	bl	22d5c <nrfx_gpiote_trigger_enable>
   20d84:	e7b2      	b.n	20cec <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   20d86:	f06f 0004 	mvn.w	r0, #4
   20d8a:	e7e0      	b.n	20d4e <gpio_nrfx_pin_interrupt_configure+0x82>
   20d8c:	0bad0004 	.word	0x0bad0004
   20d90:	0bad0000 	.word	0x0bad0000

00020d94 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   20d94:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   20d96:	f001 ffcb 	bl	22d30 <nrfx_gpiote_is_init>
   20d9a:	4604      	mov	r4, r0
   20d9c:	b968      	cbnz	r0, 20dba <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   20d9e:	f001 ff9f 	bl	22ce0 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   20da2:	4b08      	ldr	r3, [pc, #32]	; (20dc4 <gpio_nrfx_init+0x30>)
   20da4:	4298      	cmp	r0, r3
   20da6:	d10a      	bne.n	20dbe <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   20da8:	4807      	ldr	r0, [pc, #28]	; (20dc8 <gpio_nrfx_init+0x34>)
   20daa:	4621      	mov	r1, r4
   20dac:	f001 ff7c 	bl	22ca8 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   20db0:	4622      	mov	r2, r4
   20db2:	2105      	movs	r1, #5
   20db4:	2006      	movs	r0, #6
   20db6:	f7e3 fc81 	bl	46bc <z_arm_irq_priority_set>
		return 0;
   20dba:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   20dbc:	bd10      	pop	{r4, pc}
		return -EIO;
   20dbe:	f06f 0004 	mvn.w	r0, #4
   20dc2:	e7fb      	b.n	20dbc <gpio_nrfx_init+0x28>
   20dc4:	0bad0000 	.word	0x0bad0000
   20dc8:	00020dcd 	.word	0x00020dcd

00020dcc <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   20dcc:	0943      	lsrs	r3, r0, #5
{
   20dce:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   20dd0:	d110      	bne.n	20df4 <nrfx_gpio_handler+0x28>
	return list->head;
   20dd2:	4b09      	ldr	r3, [pc, #36]	; (20df8 <nrfx_gpio_handler+0x2c>)
   20dd4:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   20dd6:	b169      	cbz	r1, 20df4 <nrfx_gpio_handler+0x28>
	gpio_fire_callbacks(list, port, BIT(pin));
   20dd8:	2501      	movs	r5, #1
	return node->next;
   20dda:	680c      	ldr	r4, [r1, #0]
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   20ddc:	4e07      	ldr	r6, [pc, #28]	; (20dfc <nrfx_gpio_handler+0x30>)
   20dde:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   20de0:	688a      	ldr	r2, [r1, #8]
   20de2:	402a      	ands	r2, r5
   20de4:	d002      	beq.n	20dec <nrfx_gpio_handler+0x20>
			cb->handler(port, cb, cb->pin_mask & pins);
   20de6:	684b      	ldr	r3, [r1, #4]
   20de8:	4630      	mov	r0, r6
   20dea:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   20dec:	b114      	cbz	r4, 20df4 <nrfx_gpio_handler+0x28>
   20dee:	4621      	mov	r1, r4
   20df0:	6824      	ldr	r4, [r4, #0]
   20df2:	e7f5      	b.n	20de0 <nrfx_gpio_handler+0x14>
}
   20df4:	bd70      	pop	{r4, r5, r6, pc}
   20df6:	bf00      	nop
   20df8:	20003678 	.word	0x20003678
   20dfc:	0002d588 	.word	0x0002d588

00020e00 <gpio_nrfx_pin_configure>:
{
   20e00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return port->config;
   20e04:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   20e06:	7b3b      	ldrb	r3, [r7, #12]
   20e08:	f001 051f 	and.w	r5, r1, #31
{
   20e0c:	b085      	sub	sp, #20
   20e0e:	460e      	mov	r6, r1
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   20e10:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   20e14:	4614      	mov	r4, r2
   20e16:	b9ca      	cbnz	r2, 20e4c <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   20e18:	a902      	add	r1, sp, #8
   20e1a:	4628      	mov	r0, r5
   20e1c:	f001 ff4a 	bl	22cb4 <nrfx_gpiote_channel_get>
   20e20:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   20e22:	4628      	mov	r0, r5
   20e24:	f002 f806 	bl	22e34 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   20e28:	4b48      	ldr	r3, [pc, #288]	; (20f4c <gpio_nrfx_pin_configure+0x14c>)
   20e2a:	4298      	cmp	r0, r3
   20e2c:	d004      	beq.n	20e38 <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   20e2e:	f06f 0004 	mvn.w	r0, #4
}
   20e32:	b005      	add	sp, #20
   20e34:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   20e38:	4284      	cmp	r4, r0
   20e3a:	d105      	bne.n	20e48 <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   20e3c:	f89d 0008 	ldrb.w	r0, [sp, #8]
   20e40:	f001 ff80 	bl	22d44 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   20e44:	42a0      	cmp	r0, r4
   20e46:	d1f2      	bne.n	20e2e <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   20e48:	2000      	movs	r0, #0
   20e4a:	e7f2      	b.n	20e32 <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   20e4c:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   20e50:	f10d 0103 	add.w	r1, sp, #3
   20e54:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   20e56:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   20e5a:	f001 ff2b 	bl	22cb4 <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   20e5e:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   20e60:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   20e62:	aa02      	add	r2, sp, #8
   20e64:	4649      	mov	r1, r9
   20e66:	4628      	mov	r0, r5
   20e68:	f001 fdfc 	bl	22a64 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   20e6c:	4b37      	ldr	r3, [pc, #220]	; (20f4c <gpio_nrfx_pin_configure+0x14c>)
   20e6e:	4298      	cmp	r0, r3
   20e70:	d002      	beq.n	20e78 <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   20e72:	f06f 0015 	mvn.w	r0, #21
   20e76:	e7dc      	b.n	20e32 <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   20e78:	4580      	cmp	r8, r0
   20e7a:	d103      	bne.n	20e84 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   20e7c:	f89d 0003 	ldrb.w	r0, [sp, #3]
   20e80:	f001 ff60 	bl	22d44 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   20e84:	05a3      	lsls	r3, r4, #22
   20e86:	d54e      	bpl.n	20f26 <gpio_nrfx_pin_configure+0x126>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   20e88:	4b31      	ldr	r3, [pc, #196]	; (20f50 <gpio_nrfx_pin_configure+0x150>)
   20e8a:	4a32      	ldr	r2, [pc, #200]	; (20f54 <gpio_nrfx_pin_configure+0x154>)
   20e8c:	4023      	ands	r3, r4
   20e8e:	4293      	cmp	r3, r2
   20e90:	d03a      	beq.n	20f08 <gpio_nrfx_pin_configure+0x108>
   20e92:	d80c      	bhi.n	20eae <gpio_nrfx_pin_configure+0xae>
   20e94:	2b06      	cmp	r3, #6
   20e96:	d014      	beq.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
   20e98:	d804      	bhi.n	20ea4 <gpio_nrfx_pin_configure+0xa4>
   20e9a:	b193      	cbz	r3, 20ec2 <gpio_nrfx_pin_configure+0xc2>
   20e9c:	2b02      	cmp	r3, #2
   20e9e:	d1e8      	bne.n	20e72 <gpio_nrfx_pin_configure+0x72>
   20ea0:	2304      	movs	r3, #4
   20ea2:	e00e      	b.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
   20ea4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   20ea8:	d1e3      	bne.n	20e72 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   20eaa:	2301      	movs	r3, #1
   20eac:	e009      	b.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   20eae:	4a2a      	ldr	r2, [pc, #168]	; (20f58 <gpio_nrfx_pin_configure+0x158>)
   20eb0:	4293      	cmp	r3, r2
   20eb2:	d02b      	beq.n	20f0c <gpio_nrfx_pin_configure+0x10c>
   20eb4:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   20eb8:	d02a      	beq.n	20f10 <gpio_nrfx_pin_configure+0x110>
   20eba:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   20ebe:	d1d8      	bne.n	20e72 <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   20ec0:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   20ec2:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   20ec6:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   20eca:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   20ece:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   20ed0:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLDOWN;
   20ed4:	bf54      	ite	pl
   20ed6:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
   20eda:	2303      	movmi	r3, #3
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   20edc:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   20ede:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   20ee2:	d517      	bpl.n	20f14 <gpio_nrfx_pin_configure+0x114>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   20ee4:	687b      	ldr	r3, [r7, #4]
   20ee6:	2101      	movs	r1, #1
   20ee8:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   20eec:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   20ef0:	2200      	movs	r2, #0
   20ef2:	a901      	add	r1, sp, #4
   20ef4:	4628      	mov	r0, r5
   20ef6:	f001 fe5f 	bl	22bb8 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   20efa:	4b14      	ldr	r3, [pc, #80]	; (20f4c <gpio_nrfx_pin_configure+0x14c>)
   20efc:	4298      	cmp	r0, r3
   20efe:	bf14      	ite	ne
   20f00:	f06f 0015 	mvnne.w	r0, #21
   20f04:	2000      	moveq	r0, #0
   20f06:	e794      	b.n	20e32 <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   20f08:	2307      	movs	r3, #7
   20f0a:	e7da      	b.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   20f0c:	2305      	movs	r3, #5
   20f0e:	e7d8      	b.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   20f10:	2303      	movs	r3, #3
   20f12:	e7d6      	b.n	20ec2 <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   20f14:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   20f16:	bf41      	itttt	mi
   20f18:	687b      	ldrmi	r3, [r7, #4]
   20f1a:	2101      	movmi	r1, #1
   20f1c:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   20f20:	f8c3 650c 	strmi.w	r6, [r3, #1292]	; 0x50c
}
   20f24:	e7e4      	b.n	20ef0 <gpio_nrfx_pin_configure+0xf0>
	if (flags & GPIO_PULL_UP) {
   20f26:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   20f28:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   20f2c:	bf54      	ite	pl
   20f2e:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
   20f32:	2403      	movmi	r4, #3
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   20f34:	461a      	mov	r2, r3
   20f36:	a901      	add	r1, sp, #4
   20f38:	4628      	mov	r0, r5
	nrfx_gpiote_input_config_t input_config = {
   20f3a:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   20f3e:	f001 fd91 	bl	22a64 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   20f42:	4b02      	ldr	r3, [pc, #8]	; (20f4c <gpio_nrfx_pin_configure+0x14c>)
   20f44:	4298      	cmp	r0, r3
   20f46:	f43f af7f 	beq.w	20e48 <gpio_nrfx_pin_configure+0x48>
   20f4a:	e792      	b.n	20e72 <gpio_nrfx_pin_configure+0x72>
   20f4c:	0bad0000 	.word	0x0bad0000
   20f50:	00f00006 	.word	0x00f00006
   20f54:	00100006 	.word	0x00100006
   20f58:	00400002 	.word	0x00400002

00020f5c <sx1509b_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int sx1509b_init(const struct device *dev)
{
   20f5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct sx1509b_config *cfg = dev->config;
   20f60:	6847      	ldr	r7, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
   20f62:	6905      	ldr	r5, [r0, #16]
{
   20f64:	4606      	mov	r6, r0
   20f66:	b087      	sub	sp, #28
	int rc;

	drv_data->i2c_master = device_get_binding(cfg->i2c_master_dev_name);
   20f68:	6878      	ldr	r0, [r7, #4]
   20f6a:	f002 fc5b 	bl	23824 <z_impl_device_get_binding>
   20f6e:	4603      	mov	r3, r0
   20f70:	6068      	str	r0, [r5, #4]
	if (!drv_data->i2c_master) {
   20f72:	bb00      	cbnz	r0, 20fb6 <sx1509b_init+0x5a>
		LOG_ERR("%s: no bus %s", dev->name,
   20f74:	687a      	ldr	r2, [r7, #4]
   20f76:	9203      	str	r2, [sp, #12]
   20f78:	6832      	ldr	r2, [r6, #0]
   20f7a:	9202      	str	r2, [sp, #8]
   20f7c:	4a4a      	ldr	r2, [pc, #296]	; (210a8 <sx1509b_init+0x14c>)
   20f7e:	494b      	ldr	r1, [pc, #300]	; (210ac <sx1509b_init+0x150>)
   20f80:	e9cd 0200 	strd	r0, r2, [sp]
   20f84:	2201      	movs	r2, #1
   20f86:	f00b f86f 	bl	2c068 <z_log_msg2_runtime_create.constprop.0>
			cfg->i2c_master_dev_name);
		rc = -EINVAL;
   20f8a:	f06f 0415 	mvn.w	r4, #21
				SX1509B_REG_MISC_FREQ);
	}

out:
	if (rc != 0) {
		LOG_ERR("%s init failed: %d", dev->name, rc);
   20f8e:	6833      	ldr	r3, [r6, #0]
   20f90:	9302      	str	r3, [sp, #8]
   20f92:	4b47      	ldr	r3, [pc, #284]	; (210b0 <sx1509b_init+0x154>)
   20f94:	9301      	str	r3, [sp, #4]
   20f96:	2300      	movs	r3, #0
   20f98:	4944      	ldr	r1, [pc, #272]	; (210ac <sx1509b_init+0x150>)
   20f9a:	9403      	str	r4, [sp, #12]
   20f9c:	9300      	str	r3, [sp, #0]
   20f9e:	2201      	movs	r2, #1
   20fa0:	4618      	mov	r0, r3
   20fa2:	f00b f861 	bl	2c068 <z_log_msg2_runtime_create.constprop.0>
	z_impl_k_sem_give(sem);
   20fa6:	f105 0020 	add.w	r0, r5, #32
   20faa:	f002 ffd3 	bl	23f54 <z_impl_k_sem_give>
	} else {
		LOG_INF("%s init ok", dev->name);
	}
	k_sem_give(&drv_data->lock);
	return rc;
}
   20fae:	4620      	mov	r0, r4
   20fb0:	b007      	add	sp, #28
   20fb2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
   20fb6:	893b      	ldrh	r3, [r7, #8]
 */
static inline int i2c_reg_write_byte(const struct device *dev,
				     uint16_t dev_addr,
				     uint8_t reg_addr, uint8_t value)
{
	uint8_t tx_buf[2] = {reg_addr, value};
   20fb8:	f04f 097d 	mov.w	r9, #125	; 0x7d
   20fbc:	f04f 0812 	mov.w	r8, #18

	return i2c_write(dev, tx_buf, 2, dev_addr);
   20fc0:	2202      	movs	r2, #2
   20fc2:	a905      	add	r1, sp, #20
	uint8_t tx_buf[2] = {reg_addr, value};
   20fc4:	f88d 9014 	strb.w	r9, [sp, #20]
   20fc8:	f88d 8015 	strb.w	r8, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   20fcc:	f00b f85c 	bl	2c088 <i2c_write>
	if (rc != 0) {
   20fd0:	4604      	mov	r4, r0
   20fd2:	b160      	cbz	r0, 20fee <sx1509b_init+0x92>
		LOG_ERR("%s: reset m0 failed: %d\n", dev->name, rc);
   20fd4:	6833      	ldr	r3, [r6, #0]
   20fd6:	9302      	str	r3, [sp, #8]
   20fd8:	4b36      	ldr	r3, [pc, #216]	; (210b4 <sx1509b_init+0x158>)
   20fda:	9301      	str	r3, [sp, #4]
   20fdc:	2300      	movs	r3, #0
   20fde:	9003      	str	r0, [sp, #12]
   20fe0:	4932      	ldr	r1, [pc, #200]	; (210ac <sx1509b_init+0x150>)
   20fe2:	9300      	str	r3, [sp, #0]
   20fe4:	2201      	movs	r2, #1
   20fe6:	4618      	mov	r0, r3
   20fe8:	f00b f83e 	bl	2c068 <z_log_msg2_runtime_create.constprop.0>
		goto out;
   20fec:	e7cf      	b.n	20f8e <sx1509b_init+0x32>
	uint8_t tx_buf[2] = {reg_addr, value};
   20fee:	2234      	movs	r2, #52	; 0x34
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
   20ff0:	6868      	ldr	r0, [r5, #4]
   20ff2:	893b      	ldrh	r3, [r7, #8]
   20ff4:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   20ff8:	a905      	add	r1, sp, #20
   20ffa:	2202      	movs	r2, #2
	uint8_t tx_buf[2] = {reg_addr, value};
   20ffc:	f88d 9014 	strb.w	r9, [sp, #20]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   21000:	f00b f842 	bl	2c088 <i2c_write>
	if (rc != 0) {
   21004:	4604      	mov	r4, r0
   21006:	2800      	cmp	r0, #0
   21008:	d1c1      	bne.n	20f8e <sx1509b_init+0x32>
	return z_impl_k_sleep(timeout);
   2100a:	2100      	movs	r1, #0
   2100c:	2063      	movs	r0, #99	; 0x63
   2100e:	f003 fc85 	bl	2491c <z_impl_k_sleep>
	drv_data->pin_state = (struct sx1509b_pin_state) {
   21012:	4642      	mov	r2, r8
   21014:	4621      	mov	r1, r4
   21016:	f105 0008 	add.w	r0, r5, #8
   2101a:	f006 fc34 	bl	27886 <memset>
   2101e:	f24e 03e0 	movw	r3, #57568	; 0xe0e0
	uint8_t tx_buf[2] = {reg_addr, value};
   21022:	221e      	movs	r2, #30
   21024:	832b      	strh	r3, [r5, #24]
	drv_data->debounce_state = (struct sx1509b_debounce_state) {
   21026:	83ac      	strh	r4, [r5, #28]
   21028:	77ac      	strb	r4, [r5, #30]
	rc = i2c_reg_write_byte(drv_data->i2c_master, cfg->i2c_slave_addr,
   2102a:	6868      	ldr	r0, [r5, #4]
   2102c:	893b      	ldrh	r3, [r7, #8]
   2102e:	f88d 2014 	strb.w	r2, [sp, #20]
   21032:	2240      	movs	r2, #64	; 0x40
   21034:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   21038:	a905      	add	r1, sp, #20
   2103a:	2202      	movs	r2, #2
   2103c:	f00b f824 	bl	2c088 <i2c_write>
	drv_data->debounce_state = (struct sx1509b_debounce_state) {
   21040:	46a0      	mov	r8, r4
	if (rc == 0) {
   21042:	4604      	mov	r4, r0
   21044:	2800      	cmp	r0, #0
   21046:	d1a2      	bne.n	20f8e <sx1509b_init+0x32>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   21048:	8b2b      	ldrh	r3, [r5, #24]
   2104a:	8939      	ldrh	r1, [r7, #8]
   2104c:	6868      	ldr	r0, [r5, #4]
   2104e:	2210      	movs	r2, #16
   21050:	f00b f827 	bl	2c0a2 <i2c_reg_write_word_be>
	if (rc == 0) {
   21054:	4604      	mov	r4, r0
   21056:	2800      	cmp	r0, #0
   21058:	d199      	bne.n	20f8e <sx1509b_init+0x32>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   2105a:	8aeb      	ldrh	r3, [r5, #22]
   2105c:	8939      	ldrh	r1, [r7, #8]
   2105e:	6868      	ldr	r0, [r5, #4]
   21060:	220e      	movs	r2, #14
   21062:	f00b f81e 	bl	2c0a2 <i2c_reg_write_word_be>
	if (rc == 0) {
   21066:	4604      	mov	r4, r0
   21068:	2800      	cmp	r0, #0
   2106a:	d190      	bne.n	20f8e <sx1509b_init+0x32>
	uint8_t tx_buf[3] = { reg_addr, value };
   2106c:	221f      	movs	r2, #31
		rc = i2c_reg_write_byte_be(
   2106e:	6868      	ldr	r0, [r5, #4]
   21070:	893b      	ldrh	r3, [r7, #8]
	uint8_t tx_buf[3] = { reg_addr, value };
   21072:	f88d 2014 	strb.w	r2, [sp, #20]
   21076:	2298      	movs	r2, #152	; 0x98
   21078:	f88d 2015 	strb.w	r2, [sp, #21]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   2107c:	a905      	add	r1, sp, #20
   2107e:	2202      	movs	r2, #2
	uint8_t tx_buf[3] = { reg_addr, value };
   21080:	f88d 8016 	strb.w	r8, [sp, #22]
	return i2c_write(dev, tx_buf, 2, dev_addr);
   21084:	f00b f800 	bl	2c088 <i2c_write>
	if (rc != 0) {
   21088:	4604      	mov	r4, r0
   2108a:	2800      	cmp	r0, #0
   2108c:	f47f af7f 	bne.w	20f8e <sx1509b_init+0x32>
		LOG_INF("%s init ok", dev->name);
   21090:	6833      	ldr	r3, [r6, #0]
   21092:	9302      	str	r3, [sp, #8]
   21094:	4b08      	ldr	r3, [pc, #32]	; (210b8 <sx1509b_init+0x15c>)
   21096:	4905      	ldr	r1, [pc, #20]	; (210ac <sx1509b_init+0x150>)
   21098:	e9cd 0300 	strd	r0, r3, [sp]
   2109c:	2203      	movs	r2, #3
   2109e:	4603      	mov	r3, r0
   210a0:	f00a ffe2 	bl	2c068 <z_log_msg2_runtime_create.constprop.0>
   210a4:	e77f      	b.n	20fa6 <sx1509b_init+0x4a>
   210a6:	bf00      	nop
   210a8:	00034aa7 	.word	0x00034aa7
   210ac:	0002dc1c 	.word	0x0002dc1c
   210b0:	00034ace 	.word	0x00034ace
   210b4:	00034ab5 	.word	0x00034ab5
   210b8:	00034ae1 	.word	0x00034ae1

000210bc <i2c_nrfx_twim_recover_bus>:

	return 0;
}

static int i2c_nrfx_twim_recover_bus(const struct device *dev)
{
   210bc:	b508      	push	{r3, lr}
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   210be:	6903      	ldr	r3, [r0, #16]
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
   210c0:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	; 0x30
   210c4:	f002 fac0 	bl	23648 <nrfx_twi_twim_bus_recover>

	nrfx_err_t err = nrfx_twim_bus_recover(dev_data->twim_config.scl,
					       dev_data->twim_config.sda);

	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   210c8:	4b03      	ldr	r3, [pc, #12]	; (210d8 <i2c_nrfx_twim_recover_bus+0x1c>)
   210ca:	4298      	cmp	r0, r3
}
   210cc:	bf14      	ite	ne
   210ce:	f06f 000f 	mvnne.w	r0, #15
   210d2:	2000      	moveq	r0, #0
   210d4:	bd08      	pop	{r3, pc}
   210d6:	bf00      	nop
   210d8:	0bad0000 	.word	0x0bad0000

000210dc <init_twim>:
{
   210dc:	b530      	push	{r4, r5, lr}
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   210de:	6905      	ldr	r5, [r0, #16]
	nrfx_err_t result = nrfx_twim_init(&dev_config->twim,
   210e0:	4a0f      	ldr	r2, [pc, #60]	; (21120 <init_twim+0x44>)
   210e2:	462b      	mov	r3, r5
{
   210e4:	b085      	sub	sp, #20
   210e6:	4604      	mov	r4, r0
	nrfx_err_t result = nrfx_twim_init(&dev_config->twim,
   210e8:	f105 0130 	add.w	r1, r5, #48	; 0x30
   210ec:	6840      	ldr	r0, [r0, #4]
   210ee:	f002 f869 	bl	231c4 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
   210f2:	4b0c      	ldr	r3, [pc, #48]	; (21124 <init_twim+0x48>)
   210f4:	4298      	cmp	r0, r3
   210f6:	d00e      	beq.n	21116 <init_twim+0x3a>
		LOG_ERR("Failed to initialize device: %s", dev->name);
   210f8:	6823      	ldr	r3, [r4, #0]
   210fa:	9302      	str	r3, [sp, #8]
   210fc:	4b0a      	ldr	r3, [pc, #40]	; (21128 <init_twim+0x4c>)
   210fe:	9301      	str	r3, [sp, #4]
   21100:	2300      	movs	r3, #0
   21102:	4618      	mov	r0, r3
   21104:	4909      	ldr	r1, [pc, #36]	; (2112c <init_twim+0x50>)
   21106:	9300      	str	r3, [sp, #0]
   21108:	2201      	movs	r2, #1
   2110a:	f00b f934 	bl	2c376 <z_log_msg2_runtime_create.constprop.0>
   2110e:	f06f 0004 	mvn.w	r0, #4
}
   21112:	b005      	add	sp, #20
   21114:	bd30      	pop	{r4, r5, pc}
	dev_data->twim_initialized = true;
   21116:	2301      	movs	r3, #1
   21118:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
	return 0;
   2111c:	2000      	movs	r0, #0
   2111e:	e7f8      	b.n	21112 <init_twim+0x36>
   21120:	000211a5 	.word	0x000211a5
   21124:	0bad0000 	.word	0x0bad0000
   21128:	00034b06 	.word	0x00034b06
   2112c:	0002dbcc 	.word	0x0002dbcc

00021130 <i2c_nrfx_twim_configure>:
{
   21130:	b530      	push	{r4, r5, lr}
	if (I2C_ADDR_10_BITS & i2c_config) {
   21132:	f011 0301 	ands.w	r3, r1, #1
{
   21136:	b089      	sub	sp, #36	; 0x24
   21138:	4604      	mov	r4, r0
	if (I2C_ADDR_10_BITS & i2c_config) {
   2113a:	d110      	bne.n	2115e <i2c_nrfx_twim_configure+0x2e>
	switch (I2C_SPEED_GET(i2c_config)) {
   2113c:	f3c1 0142 	ubfx	r1, r1, #1, #3
   21140:	2901      	cmp	r1, #1
   21142:	d010      	beq.n	21166 <i2c_nrfx_twim_configure+0x36>
   21144:	2902      	cmp	r1, #2
   21146:	d024      	beq.n	21192 <i2c_nrfx_twim_configure+0x62>
		LOG_ERR("unsupported speed");
   21148:	4a14      	ldr	r2, [pc, #80]	; (2119c <i2c_nrfx_twim_configure+0x6c>)
   2114a:	9206      	str	r2, [sp, #24]
   2114c:	2202      	movs	r2, #2
   2114e:	9201      	str	r2, [sp, #4]
   21150:	9205      	str	r2, [sp, #20]
   21152:	4813      	ldr	r0, [pc, #76]	; (211a0 <i2c_nrfx_twim_configure+0x70>)
   21154:	aa05      	add	r2, sp, #20
   21156:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   2115a:	f004 fdbd 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   2115e:	f06f 0015 	mvn.w	r0, #21
}
   21162:	b009      	add	sp, #36	; 0x24
   21164:	bd30      	pop	{r4, r5, pc}
		frequency = NRF_TWIM_FREQ_100K;
   21166:	f04f 73cc 	mov.w	r3, #26738688	; 0x1980000
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   2116a:	6925      	ldr	r5, [r4, #16]
	if (frequency != dev_data->twim_config.frequency) {
   2116c:	6baa      	ldr	r2, [r5, #56]	; 0x38
   2116e:	4293      	cmp	r3, r2
   21170:	d012      	beq.n	21198 <i2c_nrfx_twim_configure+0x68>
		dev_data->twim_config.frequency = frequency;
   21172:	63ab      	str	r3, [r5, #56]	; 0x38
	if (dev_data->twim_initialized) {
   21174:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
   21178:	b12b      	cbz	r3, 21186 <i2c_nrfx_twim_configure+0x56>
		nrfx_twim_uninit(&dev_config->twim);
   2117a:	6860      	ldr	r0, [r4, #4]
   2117c:	f002 f8a0 	bl	232c0 <nrfx_twim_uninit>
		dev_data->twim_initialized = false;
   21180:	2300      	movs	r3, #0
   21182:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
		return init_twim(dev);
   21186:	4620      	mov	r0, r4
}
   21188:	b009      	add	sp, #36	; 0x24
   2118a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		return init_twim(dev);
   2118e:	f7ff bfa5 	b.w	210dc <init_twim>
	switch (I2C_SPEED_GET(i2c_config)) {
   21192:	f04f 63c8 	mov.w	r3, #104857600	; 0x6400000
   21196:	e7e8      	b.n	2116a <i2c_nrfx_twim_configure+0x3a>
	return 0;
   21198:	2000      	movs	r0, #0
   2119a:	e7e2      	b.n	21162 <i2c_nrfx_twim_configure+0x32>
   2119c:	00034b26 	.word	0x00034b26
   211a0:	0002dbcc 	.word	0x0002dbcc

000211a4 <event_handler>:
	switch (p_event->type) {
   211a4:	7803      	ldrb	r3, [r0, #0]
   211a6:	2b01      	cmp	r3, #1
   211a8:	d008      	beq.n	211bc <event_handler+0x18>
   211aa:	2b02      	cmp	r3, #2
   211ac:	d008      	beq.n	211c0 <event_handler+0x1c>
   211ae:	b94b      	cbnz	r3, 211c4 <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
   211b0:	4b05      	ldr	r3, [pc, #20]	; (211c8 <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   211b2:	644b      	str	r3, [r1, #68]	; 0x44
	z_impl_k_sem_give(sem);
   211b4:	f101 0018 	add.w	r0, r1, #24
   211b8:	f002 becc 	b.w	23f54 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   211bc:	4b03      	ldr	r3, [pc, #12]	; (211cc <event_handler+0x28>)
   211be:	e7f8      	b.n	211b2 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   211c0:	4b03      	ldr	r3, [pc, #12]	; (211d0 <event_handler+0x2c>)
   211c2:	e7f6      	b.n	211b2 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
   211c4:	4b03      	ldr	r3, [pc, #12]	; (211d4 <event_handler+0x30>)
   211c6:	e7f4      	b.n	211b2 <event_handler+0xe>
   211c8:	0bad0000 	.word	0x0bad0000
   211cc:	0bae0001 	.word	0x0bae0001
   211d0:	0bae0002 	.word	0x0bae0002
   211d4:	0bad0001 	.word	0x0bad0001

000211d8 <i2c_nrfx_twim_transfer>:
{
   211d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   211dc:	b099      	sub	sp, #100	; 0x64
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   211de:	f8d0 9004 	ldr.w	r9, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   211e2:	6906      	ldr	r6, [r0, #16]
{
   211e4:	af06      	add	r7, sp, #24
   211e6:	461d      	mov	r5, r3
   211e8:	613a      	str	r2, [r7, #16]
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   211ea:	f8b9 3008 	ldrh.w	r3, [r9, #8]
   211ee:	617b      	str	r3, [r7, #20]
{
   211f0:	4680      	mov	r8, r0
   211f2:	460c      	mov	r4, r1
	nrfx_twim_xfer_desc_t cur_xfer = {
   211f4:	2214      	movs	r2, #20
   211f6:	2100      	movs	r1, #0
   211f8:	f107 001c 	add.w	r0, r7, #28
	uint8_t *msg_buf = dev_data->msg_buf;
   211fc:	f8d6 b048 	ldr.w	fp, [r6, #72]	; 0x48
	nrfx_twim_xfer_desc_t cur_xfer = {
   21200:	f006 fb41 	bl	27886 <memset>
	if (!dev_data->twim_initialized && init_twim(dev) < 0) {
   21204:	f896 3040 	ldrb.w	r3, [r6, #64]	; 0x40
	nrfx_twim_xfer_desc_t cur_xfer = {
   21208:	777d      	strb	r5, [r7, #29]
	if (!dev_data->twim_initialized && init_twim(dev) < 0) {
   2120a:	b1d3      	cbz	r3, 21242 <i2c_nrfx_twim_transfer+0x6a>
	return z_impl_k_sem_take(sem, timeout);
   2120c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21210:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21214:	4630      	mov	r0, r6
   21216:	f002 fec3 	bl	23fa0 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
   2121a:	f106 0318 	add.w	r3, r6, #24
   2121e:	60fb      	str	r3, [r7, #12]
   21220:	2200      	movs	r2, #0
   21222:	2300      	movs	r3, #0
   21224:	f106 0018 	add.w	r0, r6, #24
   21228:	f002 feba 	bl	23fa0 <z_impl_k_sem_take>
	nrfx_twim_enable(&dev_config->twim);
   2122c:	4648      	mov	r0, r9
   2122e:	f002 f819 	bl	23264 <nrfx_twim_enable>
	for (size_t i = 0; i < num_msgs; i++) {
   21232:	f04f 0a00 	mov.w	sl, #0
	uint16_t msg_buf_used = 0;
   21236:	4655      	mov	r5, sl
	for (size_t i = 0; i < num_msgs; i++) {
   21238:	693b      	ldr	r3, [r7, #16]
   2123a:	459a      	cmp	sl, r3
   2123c:	d309      	bcc.n	21252 <i2c_nrfx_twim_transfer+0x7a>
   2123e:	2400      	movs	r4, #0
   21240:	e037      	b.n	212b2 <i2c_nrfx_twim_transfer+0xda>
	if (!dev_data->twim_initialized && init_twim(dev) < 0) {
   21242:	4640      	mov	r0, r8
   21244:	f7ff ff4a 	bl	210dc <init_twim>
   21248:	2800      	cmp	r0, #0
   2124a:	dadf      	bge.n	2120c <i2c_nrfx_twim_transfer+0x34>
		return -EIO;
   2124c:	f06f 0404 	mvn.w	r4, #4
   21250:	e035      	b.n	212be <i2c_nrfx_twim_transfer+0xe6>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   21252:	7a21      	ldrb	r1, [r4, #8]
   21254:	070b      	lsls	r3, r1, #28
   21256:	f100 80e0 	bmi.w	2141a <i2c_nrfx_twim_transfer+0x242>
				&& ((msgs[i].flags & I2C_MSG_READ)
   2125a:	693a      	ldr	r2, [r7, #16]
		bool concat_next = ((i + 1) < num_msgs)
   2125c:	f10a 0301 	add.w	r3, sl, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
   21260:	4293      	cmp	r3, r2
		bool concat_next = ((i + 1) < num_msgs)
   21262:	60bb      	str	r3, [r7, #8]
				&& ((msgs[i].flags & I2C_MSG_READ)
   21264:	d20a      	bcs.n	2127c <i2c_nrfx_twim_transfer+0xa4>
				&& !(msgs[i].flags & I2C_MSG_STOP)
   21266:	0788      	lsls	r0, r1, #30
   21268:	d408      	bmi.n	2127c <i2c_nrfx_twim_transfer+0xa4>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
   2126a:	7d23      	ldrb	r3, [r4, #20]
				    == (msgs[i + 1].flags & I2C_MSG_READ));
   2126c:	ea81 0203 	eor.w	r2, r1, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
   21270:	f002 0201 	and.w	r2, r2, #1
   21274:	f003 0304 	and.w	r3, r3, #4
   21278:	4313      	orrs	r3, r2
   2127a:	d025      	beq.n	212c8 <i2c_nrfx_twim_transfer+0xf0>
		if (concat_next || (msg_buf_used != 0)) {
   2127c:	2d00      	cmp	r5, #0
   2127e:	d037      	beq.n	212f0 <i2c_nrfx_twim_transfer+0x118>
				&& ((msgs[i].flags & I2C_MSG_READ)
   21280:	2300      	movs	r3, #0
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
   21282:	6862      	ldr	r2, [r4, #4]
   21284:	f8d7 c014 	ldr.w	ip, [r7, #20]
   21288:	18a8      	adds	r0, r5, r2
   2128a:	4560      	cmp	r0, ip
   2128c:	d91e      	bls.n	212cc <i2c_nrfx_twim_transfer+0xf4>
				LOG_ERR("Need to use concatenation buffer and "
   2128e:	f8d8 3000 	ldr.w	r3, [r8]
   21292:	9305      	str	r3, [sp, #20]
   21294:	697b      	ldr	r3, [r7, #20]
   21296:	4962      	ldr	r1, [pc, #392]	; (21420 <i2c_nrfx_twim_transfer+0x248>)
   21298:	9502      	str	r5, [sp, #8]
   2129a:	e9cd 2303 	strd	r2, r3, [sp, #12]
   2129e:	4b61      	ldr	r3, [pc, #388]	; (21424 <i2c_nrfx_twim_transfer+0x24c>)
   212a0:	9301      	str	r3, [sp, #4]
   212a2:	2300      	movs	r3, #0
   212a4:	9300      	str	r3, [sp, #0]
   212a6:	2201      	movs	r2, #1
   212a8:	4618      	mov	r0, r3
   212aa:	f00b f864 	bl	2c376 <z_log_msg2_runtime_create.constprop.0>
				ret = -ENOSPC;
   212ae:	f06f 041b 	mvn.w	r4, #27
	nrfx_twim_disable(&dev_config->twim);
   212b2:	4648      	mov	r0, r9
   212b4:	f001 ffe6 	bl	23284 <nrfx_twim_disable>
	z_impl_k_sem_give(sem);
   212b8:	4630      	mov	r0, r6
   212ba:	f002 fe4b 	bl	23f54 <z_impl_k_sem_give>
}
   212be:	4620      	mov	r0, r4
   212c0:	374c      	adds	r7, #76	; 0x4c
   212c2:	46bd      	mov	sp, r7
   212c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				&& ((msgs[i].flags & I2C_MSG_READ)
   212c8:	2301      	movs	r3, #1
   212ca:	e7da      	b.n	21282 <i2c_nrfx_twim_transfer+0xaa>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
   212cc:	07c9      	lsls	r1, r1, #31
   212ce:	d406      	bmi.n	212de <i2c_nrfx_twim_transfer+0x106>
				memcpy(msg_buf + msg_buf_used,
   212d0:	6821      	ldr	r1, [r4, #0]
   212d2:	607b      	str	r3, [r7, #4]
   212d4:	eb0b 0005 	add.w	r0, fp, r5
   212d8:	f006 faca 	bl	27870 <memcpy>
   212dc:	687b      	ldr	r3, [r7, #4]
			msg_buf_used += msgs[i].len;
   212de:	6862      	ldr	r2, [r4, #4]
   212e0:	4415      	add	r5, r2
   212e2:	b2ad      	uxth	r5, r5
		if (concat_next) {
   212e4:	2b00      	cmp	r3, #0
   212e6:	d042      	beq.n	2136e <i2c_nrfx_twim_transfer+0x196>
		bool concat_next = ((i + 1) < num_msgs)
   212e8:	f8d7 a008 	ldr.w	sl, [r7, #8]
   212ec:	340c      	adds	r4, #12
   212ee:	e7a3      	b.n	21238 <i2c_nrfx_twim_transfer+0x60>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   212f0:	07ca      	lsls	r2, r1, #31
   212f2:	d51d      	bpl.n	21330 <i2c_nrfx_twim_transfer+0x158>
			cur_xfer.p_primary_buf = msgs[i].buf;
   212f4:	6823      	ldr	r3, [r4, #0]
   212f6:	62bb      	str	r3, [r7, #40]	; 0x28
			cur_xfer.primary_length = msgs[i].len;
   212f8:	6863      	ldr	r3, [r4, #4]
   212fa:	623b      	str	r3, [r7, #32]
   212fc:	2500      	movs	r5, #0
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   212fe:	7a23      	ldrb	r3, [r4, #8]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
   21300:	f003 0201 	and.w	r2, r3, #1
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   21304:	f013 0f02 	tst.w	r3, #2
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   21308:	773a      	strb	r2, [r7, #28]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   2130a:	f107 011c 	add.w	r1, r7, #28
   2130e:	bf0c      	ite	eq
   21310:	2220      	moveq	r2, #32
   21312:	2200      	movne	r2, #0
   21314:	4648      	mov	r0, r9
   21316:	f002 f809 	bl	2332c <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   2131a:	4b43      	ldr	r3, [pc, #268]	; (21428 <i2c_nrfx_twim_transfer+0x250>)
   2131c:	4298      	cmp	r0, r3
   2131e:	d02c      	beq.n	2137a <i2c_nrfx_twim_transfer+0x1a2>
			if (res == NRFX_ERROR_BUSY) {
   21320:	330b      	adds	r3, #11
				ret = -EIO;
   21322:	4298      	cmp	r0, r3
   21324:	bf0c      	ite	eq
   21326:	f06f 040f 	mvneq.w	r4, #15
   2132a:	f06f 0404 	mvnne.w	r4, #4
   2132e:	e7c0      	b.n	212b2 <i2c_nrfx_twim_transfer+0xda>
			   !nrfx_is_in_ram(msgs[i].buf)) {
   21330:	6821      	ldr	r1, [r4, #0]

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   21332:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   21336:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2133a:	d0db      	beq.n	212f4 <i2c_nrfx_twim_transfer+0x11c>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
   2133c:	6862      	ldr	r2, [r4, #4]
   2133e:	f8b9 300a 	ldrh.w	r3, [r9, #10]
   21342:	4293      	cmp	r3, r2
   21344:	d20f      	bcs.n	21366 <i2c_nrfx_twim_transfer+0x18e>
				LOG_ERR("Cannot copy flash buffer of size: %u. "
   21346:	f8d8 3000 	ldr.w	r3, [r8]
   2134a:	4935      	ldr	r1, [pc, #212]	; (21420 <i2c_nrfx_twim_transfer+0x248>)
   2134c:	e9cd 2302 	strd	r2, r3, [sp, #8]
   21350:	4b36      	ldr	r3, [pc, #216]	; (2142c <i2c_nrfx_twim_transfer+0x254>)
   21352:	2201      	movs	r2, #1
   21354:	e9cd 5300 	strd	r5, r3, [sp]
   21358:	4628      	mov	r0, r5
   2135a:	462b      	mov	r3, r5
   2135c:	f00b f80b 	bl	2c376 <z_log_msg2_runtime_create.constprop.0>
				ret = -EINVAL;
   21360:	f06f 0415 	mvn.w	r4, #21
				break;
   21364:	e7a5      	b.n	212b2 <i2c_nrfx_twim_transfer+0xda>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
   21366:	4658      	mov	r0, fp
   21368:	f006 fa82 	bl	27870 <memcpy>
			msg_buf_used = msgs[i].len;
   2136c:	88a5      	ldrh	r5, [r4, #4]
		if (msg_buf_used == 0) {
   2136e:	2d00      	cmp	r5, #0
   21370:	d0c0      	beq.n	212f4 <i2c_nrfx_twim_transfer+0x11c>
			cur_xfer.p_primary_buf = msg_buf;
   21372:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
			cur_xfer.primary_length = msg_buf_used;
   21376:	623d      	str	r5, [r7, #32]
   21378:	e7c1      	b.n	212fe <i2c_nrfx_twim_transfer+0x126>
	return z_impl_k_sem_take(sem, timeout);
   2137a:	2300      	movs	r3, #0
   2137c:	68f8      	ldr	r0, [r7, #12]
   2137e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   21382:	f002 fe0d 	bl	23fa0 <z_impl_k_sem_take>
		if (ret != 0) {
   21386:	4603      	mov	r3, r0
   21388:	b1b8      	cbz	r0, 213ba <i2c_nrfx_twim_transfer+0x1e2>
			LOG_ERR("Error on I2C line occurred for message %d", i);
   2138a:	4b29      	ldr	r3, [pc, #164]	; (21430 <i2c_nrfx_twim_transfer+0x258>)
   2138c:	e9c7 3a10 	strd	r3, sl, [r7, #64]	; 0x40
   21390:	2303      	movs	r3, #3
   21392:	61bb      	str	r3, [r7, #24]
   21394:	63fb      	str	r3, [r7, #60]	; 0x3c
   21396:	f44f 51c2 	mov.w	r1, #6208	; 0x1840
   2139a:	4821      	ldr	r0, [pc, #132]	; (21420 <i2c_nrfx_twim_transfer+0x248>)
   2139c:	2300      	movs	r3, #0
   2139e:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   213a2:	f004 fc99 	bl	25cd8 <z_impl_z_log_msg2_static_create>
			nrfx_twim_disable(&dev_config->twim);
   213a6:	4648      	mov	r0, r9
   213a8:	f001 ff6c 	bl	23284 <nrfx_twim_disable>
   213ac:	e9d6 010c 	ldrd	r0, r1, [r6, #48]	; 0x30
   213b0:	f002 f94a 	bl	23648 <nrfx_twi_twim_bus_recover>
			ret = -EIO;
   213b4:	f06f 0404 	mvn.w	r4, #4
			break;
   213b8:	e77b      	b.n	212b2 <i2c_nrfx_twim_transfer+0xda>
		res = dev_data->res;
   213ba:	6c71      	ldr	r1, [r6, #68]	; 0x44
		if (res != NRFX_SUCCESS) {
   213bc:	4a1a      	ldr	r2, [pc, #104]	; (21428 <i2c_nrfx_twim_transfer+0x250>)
   213be:	4291      	cmp	r1, r2
   213c0:	d012      	beq.n	213e8 <i2c_nrfx_twim_transfer+0x210>
			LOG_ERR("Error 0x%08X occurred for message %d", res, i);
   213c2:	481c      	ldr	r0, [pc, #112]	; (21434 <i2c_nrfx_twim_transfer+0x25c>)
   213c4:	466c      	mov	r4, sp
   213c6:	b088      	sub	sp, #32
   213c8:	aa06      	add	r2, sp, #24
   213ca:	e9c2 0104 	strd	r0, r1, [r2, #16]
   213ce:	2104      	movs	r1, #4
   213d0:	f8c2 a018 	str.w	sl, [r2, #24]
   213d4:	6339      	str	r1, [r7, #48]	; 0x30
   213d6:	f842 1f0c 	str.w	r1, [r2, #12]!
   213da:	4811      	ldr	r0, [pc, #68]	; (21420 <i2c_nrfx_twim_transfer+0x248>)
   213dc:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   213e0:	f004 fc7a 	bl	25cd8 <z_impl_z_log_msg2_static_create>
   213e4:	46a5      	mov	sp, r4
   213e6:	e7e5      	b.n	213b4 <i2c_nrfx_twim_transfer+0x1dc>
		if ((msgs[i].flags & I2C_MSG_READ)
   213e8:	7a23      	ldrb	r3, [r4, #8]
   213ea:	07db      	lsls	r3, r3, #31
   213ec:	d401      	bmi.n	213f2 <i2c_nrfx_twim_transfer+0x21a>
		msg_buf_used = 0;
   213ee:	2500      	movs	r5, #0
   213f0:	e77a      	b.n	212e8 <i2c_nrfx_twim_transfer+0x110>
		    && cur_xfer.p_primary_buf == msg_buf) {
   213f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   213f4:	459b      	cmp	fp, r3
   213f6:	d1fa      	bne.n	213ee <i2c_nrfx_twim_transfer+0x216>
   213f8:	46a2      	mov	sl, r4
   213fa:	e007      	b.n	2140c <i2c_nrfx_twim_transfer+0x234>
				msg_buf_used -= msgs[j].len;
   213fc:	1aa9      	subs	r1, r5, r2
   213fe:	b28d      	uxth	r5, r1
				memcpy(msgs[j].buf,
   21400:	f8da 000c 	ldr.w	r0, [sl, #12]
   21404:	fa1b f181 	uxtah	r1, fp, r1
   21408:	f006 fa32 	bl	27870 <memcpy>
			while (msg_buf_used >= msgs[j].len) {
   2140c:	f8da 2004 	ldr.w	r2, [sl, #4]
   21410:	4295      	cmp	r5, r2
   21412:	f1aa 0a0c 	sub.w	sl, sl, #12
   21416:	d2f1      	bcs.n	213fc <i2c_nrfx_twim_transfer+0x224>
   21418:	e7e9      	b.n	213ee <i2c_nrfx_twim_transfer+0x216>
			ret = -ENOTSUP;
   2141a:	f06f 0485 	mvn.w	r4, #133	; 0x85
   2141e:	e748      	b.n	212b2 <i2c_nrfx_twim_transfer+0xda>
   21420:	0002dbcc 	.word	0x0002dbcc
   21424:	00034b38 	.word	0x00034b38
   21428:	0bad0000 	.word	0x0bad0000
   2142c:	00034bc8 	.word	0x00034bc8
   21430:	00034c2e 	.word	0x00034c2e
   21434:	00034c58 	.word	0x00034c58

00021438 <common_init.isra.0>:
 *
 * @param gpiop where to store the GPIO device pointer
 *
 * @return negative on error, otherwise zero.
 */
static int common_init(const struct device *dev)
   21438:	b5f0      	push	{r4, r5, r6, r7, lr}
   2143a:	4604      	mov	r4, r0
   2143c:	b085      	sub	sp, #20
{
	const struct driver_config *cfg = dev->config;
	gpio_flags_t flags;

	if (!device_is_ready(cfg->enable.port)) {
   2143e:	68c0      	ldr	r0, [r0, #12]
   21440:	f00b fa5c 	bl	2c8fc <z_device_is_ready>
   21444:	4603      	mov	r3, r0
   21446:	b970      	cbnz	r0, 21466 <common_init.isra.0+0x2e>
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
   21448:	68e2      	ldr	r2, [r4, #12]
   2144a:	491c      	ldr	r1, [pc, #112]	; (214bc <common_init.isra.0+0x84>)
   2144c:	6812      	ldr	r2, [r2, #0]
   2144e:	9202      	str	r2, [sp, #8]
   21450:	4a1b      	ldr	r2, [pc, #108]	; (214c0 <common_init.isra.0+0x88>)
   21452:	e9cd 0200 	strd	r0, r2, [sp]
   21456:	2201      	movs	r2, #1
   21458:	f00b f847 	bl	2c4ea <z_log_msg2_runtime_create.constprop.0>
		return -ENODEV;
   2145c:	f06f 0412 	mvn.w	r4, #18
		 */
		k_busy_wait(delay_us);
	}

	return rc;
}
   21460:	4620      	mov	r0, r4
   21462:	b005      	add	sp, #20
   21464:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (on) {
   21466:	7d25      	ldrb	r5, [r4, #20]
				  spec->dt_flags | extra_flags);
   21468:	7c63      	ldrb	r3, [r4, #17]
	return gpio_pin_configure(spec->port,
   2146a:	68e0      	ldr	r0, [r4, #12]
   2146c:	7c21      	ldrb	r1, [r4, #16]
   2146e:	f015 0503 	ands.w	r5, r5, #3
		flags = GPIO_OUTPUT_ACTIVE;
   21472:	bf16      	itet	ne
   21474:	f44f 52d0 	movne.w	r2, #6656	; 0x1a00
		flags = GPIO_OUTPUT_INACTIVE;
   21478:	f44f 52b0 	moveq.w	r2, #5632	; 0x1600
		delay_us = cfg->startup_delay_us;
   2147c:	6865      	ldrne	r5, [r4, #4]
   2147e:	4313      	orrs	r3, r2
	struct gpio_driver_data *data =
   21480:	6907      	ldr	r7, [r0, #16]
	const struct gpio_driver_api *api =
   21482:	f8d0 c008 	ldr.w	ip, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   21486:	683c      	ldr	r4, [r7, #0]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   21488:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   2148a:	bf48      	it	mi
   2148c:	f483 6340 	eormi.w	r3, r3, #3072	; 0xc00
		data->invert |= (gpio_port_pins_t)BIT(pin);
   21490:	2601      	movs	r6, #1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   21492:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   21496:	408e      	lsls	r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   21498:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   2149a:	bf4c      	ite	mi
   2149c:	4334      	orrmi	r4, r6
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   2149e:	43b4      	bicpl	r4, r6
   214a0:	603c      	str	r4, [r7, #0]
	return api->pin_configure(port, pin, flags);
   214a2:	f8dc 3000 	ldr.w	r3, [ip]
   214a6:	4798      	blx	r3
	if ((rc == 0) && (delay_us > 0)) {
   214a8:	4604      	mov	r4, r0
   214aa:	2800      	cmp	r0, #0
   214ac:	d1d8      	bne.n	21460 <common_init.isra.0+0x28>
   214ae:	2d00      	cmp	r5, #0
   214b0:	d0d6      	beq.n	21460 <common_init.isra.0+0x28>
	z_impl_k_busy_wait(usec_to_wait);
   214b2:	4628      	mov	r0, r5
   214b4:	f00b fe4e 	bl	2d154 <z_impl_k_busy_wait>
}
   214b8:	e7d2      	b.n	21460 <common_init.isra.0+0x28>
   214ba:	bf00      	nop
   214bc:	0002dc04 	.word	0x0002dc04
   214c0:	00034c91 	.word	0x00034c91

000214c4 <regulator_fixed_init_onoff>:
	.enable = enable_onoff,
	.disable = disable_onoff,
};

static int regulator_fixed_init_onoff(const struct device *dev)
{
   214c4:	b530      	push	{r4, r5, lr}
	struct driver_data_onoff *data = dev->data;
   214c6:	6905      	ldr	r5, [r0, #16]
	int rc;

	data->dev = dev;
	rc = onoff_manager_init(&data->mgr, &transitions);
   214c8:	4910      	ldr	r1, [pc, #64]	; (2150c <regulator_fixed_init_onoff+0x48>)
{
   214ca:	4604      	mov	r4, r0
	data->dev = dev;
   214cc:	4628      	mov	r0, r5
{
   214ce:	b085      	sub	sp, #20
	data->dev = dev;
   214d0:	f840 4b04 	str.w	r4, [r0], #4
	rc = onoff_manager_init(&data->mgr, &transitions);
   214d4:	f003 fedb 	bl	2528e <onoff_manager_init>
	__ASSERT_NO_MSG(rc == 0);

#ifdef CONFIG_MULTITHREADING
	k_work_init_delayable(&data->dwork, onoff_worker);
   214d8:	490d      	ldr	r1, [pc, #52]	; (21510 <regulator_fixed_init_onoff+0x4c>)
   214da:	f105 0020 	add.w	r0, r5, #32
   214de:	f00b fc84 	bl	2cdea <k_work_init_delayable>
#endif /* CONFIG_MULTITHREADING */

	rc = common_init(dev);
   214e2:	6860      	ldr	r0, [r4, #4]
   214e4:	f7ff ffa8 	bl	21438 <common_init.isra.0>
	if (rc >= 0) {
		rc = 0;
	}

	LOG_INF("%s onoff: %d", dev->name, rc);
   214e8:	6823      	ldr	r3, [r4, #0]
   214ea:	9302      	str	r3, [sp, #8]
   214ec:	4b09      	ldr	r3, [pc, #36]	; (21514 <regulator_fixed_init_onoff+0x50>)
   214ee:	9301      	str	r3, [sp, #4]
   214f0:	ea00 75e0 	and.w	r5, r0, r0, asr #31
   214f4:	2300      	movs	r3, #0
   214f6:	4618      	mov	r0, r3
   214f8:	4907      	ldr	r1, [pc, #28]	; (21518 <regulator_fixed_init_onoff+0x54>)
   214fa:	9503      	str	r5, [sp, #12]
   214fc:	9300      	str	r3, [sp, #0]
   214fe:	2203      	movs	r2, #3
   21500:	f00a fff3 	bl	2c4ea <z_log_msg2_runtime_create.constprop.0>

	return rc;
}
   21504:	4628      	mov	r0, r5
   21506:	b005      	add	sp, #20
   21508:	bd30      	pop	{r4, r5, pc}
   2150a:	bf00      	nop
   2150c:	0002e9ac 	.word	0x0002e9ac
   21510:	0002c507 	.word	0x0002c507
   21514:	00034ca9 	.word	0x00034ca9
   21518:	0002dc04 	.word	0x0002dc04

0002151c <regulator_fixed_init_sync>:
	.enable = enable_sync,
	.disable = disable_sync,
};

static int regulator_fixed_init_sync(const struct device *dev)
{
   2151c:	b530      	push	{r4, r5, lr}
   2151e:	4605      	mov	r5, r0
   21520:	b085      	sub	sp, #20
	const struct driver_config *cfg = dev->config;
	int rc = common_init(dev);
   21522:	6840      	ldr	r0, [r0, #4]
   21524:	f7ff ff88 	bl	21438 <common_init.isra.0>
	__ASSERT(cfg->startup_delay_us == 0,
		 "sync not valid with startup delay");
	__ASSERT(cfg->off_on_delay_us == 0,
		 "sync not valid with shutdown delay");

	LOG_INF("%s sync: %d", dev->name, rc);
   21528:	682b      	ldr	r3, [r5, #0]
   2152a:	9302      	str	r3, [sp, #8]
   2152c:	4b06      	ldr	r3, [pc, #24]	; (21548 <regulator_fixed_init_sync+0x2c>)
   2152e:	9301      	str	r3, [sp, #4]
   21530:	2300      	movs	r3, #0
	int rc = common_init(dev);
   21532:	4604      	mov	r4, r0
	LOG_INF("%s sync: %d", dev->name, rc);
   21534:	9003      	str	r0, [sp, #12]
   21536:	4905      	ldr	r1, [pc, #20]	; (2154c <regulator_fixed_init_sync+0x30>)
   21538:	9300      	str	r3, [sp, #0]
   2153a:	4618      	mov	r0, r3
   2153c:	2203      	movs	r2, #3
   2153e:	f00a ffd4 	bl	2c4ea <z_log_msg2_runtime_create.constprop.0>

	return rc;
}
   21542:	4620      	mov	r0, r4
   21544:	b005      	add	sp, #20
   21546:	bd30      	pop	{r4, r5, pc}
   21548:	00034cb6 	.word	0x00034cb6
   2154c:	0002dc04 	.word	0x0002dc04

00021550 <finalize_transition>:
{
   21550:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if ((rc >= 0) && (delay_us > 0)) {
   21554:	1e1c      	subs	r4, r3, #0
{
   21556:	4605      	mov	r5, r0
   21558:	460f      	mov	r7, r1
   2155a:	4690      	mov	r8, r2
	if ((rc >= 0) && (delay_us > 0)) {
   2155c:	db10      	blt.n	21580 <finalize_transition+0x30>
   2155e:	b17a      	cbz	r2, 21580 <finalize_transition+0x30>
			return (uint32_t)((t * to_hz + off) / from_hz);
   21560:	ea4f 4952 	mov.w	r9, r2, lsr #17
   21564:	03d6      	lsls	r6, r2, #15
   21566:	2300      	movs	r3, #0
   21568:	4a14      	ldr	r2, [pc, #80]	; (215bc <finalize_transition+0x6c>)
   2156a:	4630      	mov	r0, r6
   2156c:	4649      	mov	r1, r9
   2156e:	f7de fdb7 	bl	e0 <__aeabi_uldivmod>
		    || k_is_pre_kernel()
   21572:	b110      	cbz	r0, 2157a <finalize_transition+0x2a>
	return !z_sys_post_kernel;
   21574:	4b12      	ldr	r3, [pc, #72]	; (215c0 <finalize_transition+0x70>)
   21576:	781b      	ldrb	r3, [r3, #0]
   21578:	b943      	cbnz	r3, 2158c <finalize_transition+0x3c>
	z_impl_k_busy_wait(usec_to_wait);
   2157a:	4640      	mov	r0, r8
   2157c:	f00b fdea 	bl	2d154 <z_impl_k_busy_wait>
	notify(&data->mgr, rc);
   21580:	4621      	mov	r1, r4
   21582:	1d28      	adds	r0, r5, #4
   21584:	463b      	mov	r3, r7
}
   21586:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	notify(&data->mgr, rc);
   2158a:	4718      	bx	r3
			return ((t * to_hz + off) / from_hz);
   2158c:	480d      	ldr	r0, [pc, #52]	; (215c4 <finalize_transition+0x74>)
   2158e:	4a0b      	ldr	r2, [pc, #44]	; (215bc <finalize_transition+0x6c>)
			data->notify = notify;
   21590:	652f      	str	r7, [r5, #80]	; 0x50
   21592:	1830      	adds	r0, r6, r0
			data->task = WORK_TASK_DELAY;
   21594:	f04f 0303 	mov.w	r3, #3
   21598:	f149 0100 	adc.w	r1, r9, #0
   2159c:	f885 3054 	strb.w	r3, [r5, #84]	; 0x54
   215a0:	2300      	movs	r3, #0
   215a2:	f7de fd9d 	bl	e0 <__aeabi_uldivmod>
   215a6:	4602      	mov	r2, r0
   215a8:	460b      	mov	r3, r1
			rc = k_work_schedule(&data->dwork, K_USEC(delay_us));
   215aa:	f105 0020 	add.w	r0, r5, #32
   215ae:	f002 fea5 	bl	242fc <k_work_schedule>
			if (rc >= 0) {
   215b2:	1e04      	subs	r4, r0, #0
   215b4:	dbe4      	blt.n	21580 <finalize_transition+0x30>
}
   215b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   215ba:	bf00      	nop
   215bc:	000f4240 	.word	0x000f4240
   215c0:	20003f6d 	.word	0x20003f6d
   215c4:	000f423f 	.word	0x000f423f

000215c8 <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
   215c8:	4b02      	ldr	r3, [pc, #8]	; (215d4 <flash_nrf_pages_layout+0xc>)
   215ca:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   215cc:	2301      	movs	r3, #1
   215ce:	6013      	str	r3, [r2, #0]
}
   215d0:	4770      	bx	lr
   215d2:	bf00      	nop
   215d4:	2000368c 	.word	0x2000368c

000215d8 <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
   215d8:	4800      	ldr	r0, [pc, #0]	; (215dc <flash_nrf_get_parameters+0x4>)
   215da:	4770      	bx	lr
   215dc:	0002e9cc 	.word	0x0002e9cc

000215e0 <flash_nrf_read>:
{
   215e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   215e2:	460d      	mov	r5, r1
   215e4:	b083      	sub	sp, #12
	if (is_regular_addr_valid(addr, len)) {
   215e6:	4619      	mov	r1, r3
{
   215e8:	af00      	add	r7, sp, #0
	if (is_regular_addr_valid(addr, len)) {
   215ea:	4628      	mov	r0, r5
{
   215ec:	461c      	mov	r4, r3
   215ee:	4616      	mov	r6, r2
	if (is_regular_addr_valid(addr, len)) {
   215f0:	f00b f829 	bl	2c646 <is_regular_addr_valid>
   215f4:	4603      	mov	r3, r0
   215f6:	b9a8      	cbnz	r0, 21624 <flash_nrf_read+0x44>
		LOG_ERR("invalid address: 0x%08lx:%zu",
   215f8:	490f      	ldr	r1, [pc, #60]	; (21638 <flash_nrf_read+0x58>)
   215fa:	466e      	mov	r6, sp
   215fc:	b088      	sub	sp, #32
   215fe:	466a      	mov	r2, sp
   21600:	e9c2 1504 	strd	r1, r5, [r2, #16]
   21604:	2104      	movs	r1, #4
   21606:	6194      	str	r4, [r2, #24]
   21608:	6079      	str	r1, [r7, #4]
   2160a:	f842 1f0c 	str.w	r1, [r2, #12]!
   2160e:	480b      	ldr	r0, [pc, #44]	; (2163c <flash_nrf_read+0x5c>)
   21610:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   21614:	f004 fb60 	bl	25cd8 <z_impl_z_log_msg2_static_create>
   21618:	f06f 0015 	mvn.w	r0, #21
   2161c:	46b5      	mov	sp, r6
}
   2161e:	370c      	adds	r7, #12
   21620:	46bd      	mov	sp, r7
   21622:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!len) {
   21624:	b134      	cbz	r4, 21634 <flash_nrf_read+0x54>
	memcpy(data, (void *)addr, len);
   21626:	4622      	mov	r2, r4
   21628:	4629      	mov	r1, r5
   2162a:	4630      	mov	r0, r6
   2162c:	f006 f920 	bl	27870 <memcpy>
	return 0;
   21630:	2000      	movs	r0, #0
   21632:	e7f4      	b.n	2161e <flash_nrf_read+0x3e>
		return 0;
   21634:	4620      	mov	r0, r4
   21636:	e7f2      	b.n	2161e <flash_nrf_read+0x3e>
   21638:	00034d13 	.word	0x00034d13
   2163c:	0002dbb4 	.word	0x0002dbb4

00021640 <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
   21640:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   21642:	2201      	movs	r2, #1
   21644:	4611      	mov	r1, r2
   21646:	4807      	ldr	r0, [pc, #28]	; (21664 <nrf_flash_init+0x24>)
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   21648:	4c07      	ldr	r4, [pc, #28]	; (21668 <nrf_flash_init+0x28>)
   2164a:	f00b fb18 	bl	2cc7e <z_impl_k_sem_init>
	nrf_flash_sync_init();
   2164e:	f000 f993 	bl	21978 <nrf_flash_sync_init>
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   21652:	f00b f917 	bl	2c884 <nrfx_nvmc_flash_page_count_get>
   21656:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   21658:	f00b f910 	bl	2c87c <nrfx_nvmc_flash_page_size_get>
   2165c:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
   2165e:	2000      	movs	r0, #0
   21660:	bd10      	pop	{r4, pc}
   21662:	bf00      	nop
   21664:	20003694 	.word	0x20003694
   21668:	2000368c 	.word	0x2000368c

0002166c <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
   2166c:	b538      	push	{r3, r4, r5, lr}
	struct flash_context *w_ctx = context;

#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	uint32_t i = 1U;

	if (w_ctx->enable_time_limit) {
   2166e:	7b03      	ldrb	r3, [r0, #12]
{
   21670:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
   21672:	b10b      	cbz	r3, 21678 <write_op+0xc>
		nrf_flash_sync_get_timestamp_begin();
   21674:	f000 f992 	bl	2199c <nrf_flash_sync_get_timestamp_begin>
{
   21678:	2501      	movs	r5, #1
		}
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(uint32_t)) {
   2167a:	68a3      	ldr	r3, [r4, #8]
   2167c:	2b03      	cmp	r3, #3
   2167e:	d806      	bhi.n	2168e <write_op+0x22>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   21680:	4a12      	ldr	r2, [pc, #72]	; (216cc <write_op+0x60>)
   21682:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   21686:	07db      	lsls	r3, r3, #31
   21688:	d5fb      	bpl.n	21682 <write_op+0x16>
		shift_write_context(w_ctx->len, w_ctx);
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	nvmc_wait_ready();

	return FLASH_OP_DONE;
   2168a:	2000      	movs	r0, #0
}
   2168c:	bd38      	pop	{r3, r4, r5, pc}
				     UNALIGNED_GET((uint32_t *)w_ctx->data_addr));
   2168e:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
   21690:	6860      	ldr	r0, [r4, #4]
   21692:	6819      	ldr	r1, [r3, #0]
   21694:	f001 fcc4 	bl	23020 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
   21698:	6863      	ldr	r3, [r4, #4]
   2169a:	3304      	adds	r3, #4
   2169c:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
   2169e:	6823      	ldr	r3, [r4, #0]
   216a0:	3304      	adds	r3, #4
   216a2:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
   216a4:	68a3      	ldr	r3, [r4, #8]
   216a6:	3b04      	subs	r3, #4
   216a8:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
   216aa:	7b23      	ldrb	r3, [r4, #12]
		i++;
   216ac:	3501      	adds	r5, #1
		if (w_ctx->enable_time_limit) {
   216ae:	2b00      	cmp	r3, #0
   216b0:	d0e3      	beq.n	2167a <write_op+0xe>
			if (nrf_flash_sync_check_time_limit(i)) {
   216b2:	4628      	mov	r0, r5
   216b4:	f7e0 f86c 	bl	1790 <nrf_flash_sync_check_time_limit>
   216b8:	2800      	cmp	r0, #0
   216ba:	d0de      	beq.n	2167a <write_op+0xe>
   216bc:	4a03      	ldr	r2, [pc, #12]	; (216cc <write_op+0x60>)
   216be:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   216c2:	07d9      	lsls	r1, r3, #31
   216c4:	d5fb      	bpl.n	216be <write_op+0x52>
				return FLASH_OP_ONGOING;
   216c6:	2001      	movs	r0, #1
   216c8:	e7e0      	b.n	2168c <write_op+0x20>
   216ca:	bf00      	nop
   216cc:	4001e000 	.word	0x4001e000

000216d0 <flash_nrf_erase>:
{
   216d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   216d4:	b086      	sub	sp, #24
   216d6:	af00      	add	r7, sp, #0
   216d8:	460e      	mov	r6, r1
   216da:	4615      	mov	r5, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   216dc:	f00b f8ce 	bl	2c87c <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   216e0:	4629      	mov	r1, r5
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   216e2:	4680      	mov	r8, r0
	if (is_regular_addr_valid(addr, size)) {
   216e4:	4630      	mov	r0, r6
   216e6:	f00a ffae 	bl	2c646 <is_regular_addr_valid>
   216ea:	4603      	mov	r3, r0
   216ec:	2800      	cmp	r0, #0
   216ee:	d03a      	beq.n	21766 <flash_nrf_erase+0x96>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   216f0:	fbb6 f3f8 	udiv	r3, r6, r8
   216f4:	fb08 6313 	mls	r3, r8, r3, r6
   216f8:	b923      	cbnz	r3, 21704 <flash_nrf_erase+0x34>
   216fa:	fbb5 f4f8 	udiv	r4, r5, r8
   216fe:	fb08 5414 	mls	r4, r8, r4, r5
   21702:	b1c4      	cbz	r4, 21736 <flash_nrf_erase+0x66>
			LOG_ERR("unaligned address: 0x%08lx:%zu",
   21704:	4b29      	ldr	r3, [pc, #164]	; (217ac <flash_nrf_erase+0xdc>)
   21706:	466c      	mov	r4, sp
   21708:	b088      	sub	sp, #32
   2170a:	466a      	mov	r2, sp
   2170c:	e9c2 3604 	strd	r3, r6, [r2, #16]
   21710:	2304      	movs	r3, #4
   21712:	6195      	str	r5, [r2, #24]
   21714:	60bb      	str	r3, [r7, #8]
   21716:	f842 3f0c 	str.w	r3, [r2, #12]!
   2171a:	2300      	movs	r3, #0
   2171c:	4824      	ldr	r0, [pc, #144]	; (217b0 <flash_nrf_erase+0xe0>)
   2171e:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   21722:	f004 fad9 	bl	25cd8 <z_impl_z_log_msg2_static_create>
   21726:	46a5      	mov	sp, r4
		return -EINVAL;
   21728:	f06f 0415 	mvn.w	r4, #21
}
   2172c:	4620      	mov	r0, r4
   2172e:	3718      	adds	r7, #24
   21730:	46bd      	mov	sp, r7
   21732:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!n_pages) {
   21736:	45a8      	cmp	r8, r5
   21738:	d8f8      	bhi.n	2172c <flash_nrf_erase+0x5c>
	return z_impl_k_sem_take(sem, timeout);
   2173a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2173e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21742:	481c      	ldr	r0, [pc, #112]	; (217b4 <flash_nrf_erase+0xe4>)
   21744:	f002 fc2c 	bl	23fa0 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
   21748:	f00a ff8e 	bl	2c668 <nrf_flash_sync_is_required>
   2174c:	f107 0308 	add.w	r3, r7, #8
   21750:	4601      	mov	r1, r0
   21752:	b9a0      	cbnz	r0, 2177e <flash_nrf_erase+0xae>

static int erase(uint32_t addr, uint32_t size)
{
	struct flash_context context = {
   21754:	2210      	movs	r2, #16
   21756:	4618      	mov	r0, r3
   21758:	f006 f895 	bl	27886 <memset>
   2175c:	e9c7 6503 	strd	r6, r5, [r7, #12]
#if defined(CONFIG_SOC_FLASH_NRF_PARTIAL_ERASE)
		.flash_addr_next = addr
#endif
	};

	return	erase_op(&context);
   21760:	f00a ff4d 	bl	2c5fe <erase_op>
   21764:	e01d      	b.n	217a2 <flash_nrf_erase+0xd2>
		LOG_ERR("invalid address: 0x%08lx:%zu",
   21766:	4914      	ldr	r1, [pc, #80]	; (217b8 <flash_nrf_erase+0xe8>)
   21768:	466c      	mov	r4, sp
   2176a:	b088      	sub	sp, #32
   2176c:	466a      	mov	r2, sp
   2176e:	e9c2 1604 	strd	r1, r6, [r2, #16]
   21772:	2104      	movs	r1, #4
   21774:	6195      	str	r5, [r2, #24]
   21776:	60b9      	str	r1, [r7, #8]
   21778:	f842 1f0c 	str.w	r1, [r2, #12]!
	compiler_barrier();
   2177c:	e7ce      	b.n	2171c <flash_nrf_erase+0x4c>
	struct flash_context context = {
   2177e:	2210      	movs	r2, #16
   21780:	4621      	mov	r1, r4
   21782:	4618      	mov	r0, r3
   21784:	f006 f87f 	bl	27886 <memset>
   21788:	2201      	movs	r2, #1
   2178a:	753a      	strb	r2, [r7, #20]
	struct flash_op_desc flash_op_desc = {
   2178c:	4a0b      	ldr	r2, [pc, #44]	; (217bc <flash_nrf_erase+0xec>)
   2178e:	e9c7 2000 	strd	r2, r0, [r7]
	nrf_flash_sync_set_context(FLASH_SLOT_ERASE);
   21792:	480b      	ldr	r0, [pc, #44]	; (217c0 <flash_nrf_erase+0xf0>)
	struct flash_context context = {
   21794:	e9c7 6503 	strd	r6, r5, [r7, #12]
	nrf_flash_sync_set_context(FLASH_SLOT_ERASE);
   21798:	f000 f8f8 	bl	2198c <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
   2179c:	4638      	mov	r0, r7
   2179e:	f7df ff7b 	bl	1698 <nrf_flash_sync_exe>
	return	erase_op(&context);
   217a2:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   217a4:	4803      	ldr	r0, [pc, #12]	; (217b4 <flash_nrf_erase+0xe4>)
   217a6:	f002 fbd5 	bl	23f54 <z_impl_k_sem_give>
}
   217aa:	e7bf      	b.n	2172c <flash_nrf_erase+0x5c>
   217ac:	00034d30 	.word	0x00034d30
   217b0:	0002dbb4 	.word	0x0002dbb4
   217b4:	20003694 	.word	0x20003694
   217b8:	00034d13 	.word	0x00034d13
   217bc:	0002c5ff 	.word	0x0002c5ff
   217c0:	00015e64 	.word	0x00015e64

000217c4 <flash_nrf_write>:
{
   217c4:	b5f0      	push	{r4, r5, r6, r7, lr}
   217c6:	460d      	mov	r5, r1
   217c8:	b087      	sub	sp, #28
	if (is_regular_addr_valid(addr, len)) {
   217ca:	4619      	mov	r1, r3
{
   217cc:	af00      	add	r7, sp, #0
	if (is_regular_addr_valid(addr, len)) {
   217ce:	4628      	mov	r0, r5
{
   217d0:	461c      	mov	r4, r3
   217d2:	4616      	mov	r6, r2
	if (is_regular_addr_valid(addr, len)) {
   217d4:	f00a ff37 	bl	2c646 <is_regular_addr_valid>
   217d8:	4603      	mov	r3, r0
   217da:	b9b0      	cbnz	r0, 2180a <flash_nrf_write+0x46>
		LOG_ERR("invalid address: 0x%08lx:%zu",
   217dc:	4927      	ldr	r1, [pc, #156]	; (2187c <flash_nrf_write+0xb8>)
   217de:	466e      	mov	r6, sp
   217e0:	b088      	sub	sp, #32
   217e2:	466a      	mov	r2, sp
   217e4:	e9c2 1504 	strd	r1, r5, [r2, #16]
   217e8:	2104      	movs	r1, #4
   217ea:	6194      	str	r4, [r2, #24]
   217ec:	60b9      	str	r1, [r7, #8]
   217ee:	f842 1f0c 	str.w	r1, [r2, #12]!
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   217f2:	4823      	ldr	r0, [pc, #140]	; (21880 <flash_nrf_write+0xbc>)
   217f4:	f44f 5101 	mov.w	r1, #8256	; 0x2040
   217f8:	f004 fa6e 	bl	25cd8 <z_impl_z_log_msg2_static_create>
		return -EINVAL;
   217fc:	f06f 0415 	mvn.w	r4, #21
   21800:	46b5      	mov	sp, r6
}
   21802:	4620      	mov	r0, r4
   21804:	371c      	adds	r7, #28
   21806:	46bd      	mov	sp, r7
   21808:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
   2180a:	ea44 0305 	orr.w	r3, r4, r5
   2180e:	079b      	lsls	r3, r3, #30
   21810:	d00c      	beq.n	2182c <flash_nrf_write+0x68>
		LOG_ERR("not word-aligned: 0x%08lx:%zu",
   21812:	4b1c      	ldr	r3, [pc, #112]	; (21884 <flash_nrf_write+0xc0>)
   21814:	466e      	mov	r6, sp
   21816:	b088      	sub	sp, #32
   21818:	466a      	mov	r2, sp
   2181a:	e9c2 3504 	strd	r3, r5, [r2, #16]
   2181e:	2304      	movs	r3, #4
   21820:	6194      	str	r4, [r2, #24]
   21822:	60bb      	str	r3, [r7, #8]
   21824:	f842 3f0c 	str.w	r3, [r2, #12]!
   21828:	2300      	movs	r3, #0
   2182a:	e7e2      	b.n	217f2 <flash_nrf_write+0x2e>
	if (!len) {
   2182c:	2c00      	cmp	r4, #0
   2182e:	d0e8      	beq.n	21802 <flash_nrf_write+0x3e>
	return z_impl_k_sem_take(sem, timeout);
   21830:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21834:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21838:	4813      	ldr	r0, [pc, #76]	; (21888 <flash_nrf_write+0xc4>)
   2183a:	f002 fbb1 	bl	23fa0 <z_impl_k_sem_take>
	if (nrf_flash_sync_is_required()) {
   2183e:	f00a ff13 	bl	2c668 <nrf_flash_sync_is_required>
   21842:	4603      	mov	r3, r0
	struct flash_context context = {
   21844:	e9c7 6502 	strd	r6, r5, [r7, #8]
   21848:	f107 0008 	add.w	r0, r7, #8
   2184c:	613c      	str	r4, [r7, #16]
	if (nrf_flash_sync_is_required()) {
   2184e:	b183      	cbz	r3, 21872 <flash_nrf_write+0xae>
	struct flash_context context = {
   21850:	2301      	movs	r3, #1
   21852:	753b      	strb	r3, [r7, #20]
	struct flash_op_desc flash_op_desc = {
   21854:	4b0d      	ldr	r3, [pc, #52]	; (2188c <flash_nrf_write+0xc8>)
   21856:	e9c7 3000 	strd	r3, r0, [r7]
	nrf_flash_sync_set_context(FLASH_SLOT_WRITE);
   2185a:	f641 504c 	movw	r0, #7500	; 0x1d4c
   2185e:	f000 f895 	bl	2198c <nrf_flash_sync_set_context>
	return nrf_flash_sync_exe(&flash_op_desc);
   21862:	4638      	mov	r0, r7
   21864:	f7df ff18 	bl	1698 <nrf_flash_sync_exe>
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
		.enable_time_limit = 0 /* disable time limit */
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	};

	return write_op(&context);
   21868:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   2186a:	4807      	ldr	r0, [pc, #28]	; (21888 <flash_nrf_write+0xc4>)
   2186c:	f002 fb72 	bl	23f54 <z_impl_k_sem_give>
}
   21870:	e7c7      	b.n	21802 <flash_nrf_write+0x3e>
	struct flash_context context = {
   21872:	753b      	strb	r3, [r7, #20]
	return write_op(&context);
   21874:	f7ff fefa 	bl	2166c <write_op>
   21878:	e7f6      	b.n	21868 <flash_nrf_write+0xa4>
   2187a:	bf00      	nop
   2187c:	00034d13 	.word	0x00034d13
   21880:	0002dbb4 	.word	0x0002dbb4
   21884:	00034d4f 	.word	0x00034d4f
   21888:	20003694 	.word	0x20003694
   2188c:	0002166d 	.word	0x0002166d

00021890 <time_slot_callback_work>:
{
   21890:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   21892:	9b07      	ldr	r3, [sp, #28]
	rc = op_desc->handler(op_desc->context);
   21894:	e9d3 2000 	ldrd	r2, r0, [r3]
   21898:	4790      	blx	r2
	if (rc != FLASH_OP_ONGOING) {
   2189a:	2801      	cmp	r0, #1
	rc = op_desc->handler(op_desc->context);
   2189c:	4604      	mov	r4, r0
	if (rc != FLASH_OP_ONGOING) {
   2189e:	d013      	beq.n	218c8 <time_slot_callback_work+0x38>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   218a0:	f10d 010f 	add.w	r1, sp, #15
   218a4:	f10d 000e 	add.w	r0, sp, #14
   218a8:	f009 fb59 	bl	2af5e <ll_timeslice_ticker_id_get>
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
   218ac:	2300      	movs	r3, #0
   218ae:	9300      	str	r3, [sp, #0]
   218b0:	4619      	mov	r1, r3
   218b2:	f89d 200f 	ldrb.w	r2, [sp, #15]
   218b6:	f89d 000e 	ldrb.w	r0, [sp, #14]
   218ba:	f7f8 fb93 	bl	19fe4 <ticker_stop>
		_ticker_sync_context.result = (rc == FLASH_OP_DONE) ? 0 : rc;
   218be:	4b03      	ldr	r3, [pc, #12]	; (218cc <time_slot_callback_work+0x3c>)
   218c0:	60dc      	str	r4, [r3, #12]
	z_impl_k_sem_give(sem);
   218c2:	4803      	ldr	r0, [pc, #12]	; (218d0 <time_slot_callback_work+0x40>)
   218c4:	f002 fb46 	bl	23f54 <z_impl_k_sem_give>
}
   218c8:	b004      	add	sp, #16
   218ca:	bd10      	pop	{r4, pc}
   218cc:	200036ac 	.word	0x200036ac
   218d0:	200036bc 	.word	0x200036bc

000218d4 <time_slot_delay>:
{
   218d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   218d8:	b08d      	sub	sp, #52	; 0x34
   218da:	4606      	mov	r6, r0
   218dc:	460f      	mov	r7, r1
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   218de:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   218e2:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
{
   218e6:	4690      	mov	r8, r2
   218e8:	4699      	mov	r9, r3
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   218ea:	f009 fb38 	bl	2af5e <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
   218ee:	f89d 502f 	ldrb.w	r5, [sp, #47]	; 0x2f
   218f2:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   218f6:	9700      	str	r7, [sp, #0]
   218f8:	2400      	movs	r4, #0
   218fa:	3501      	adds	r5, #1
   218fc:	4633      	mov	r3, r6
   218fe:	e9cd 4407 	strd	r4, r4, [sp, #28]
   21902:	e9cd 8905 	strd	r8, r9, [sp, #20]
   21906:	e9cd 4403 	strd	r4, r4, [sp, #12]
   2190a:	e9cd 4401 	strd	r4, r4, [sp, #4]
   2190e:	b2ea      	uxtb	r2, r5
   21910:	2101      	movs	r1, #1
   21912:	f009 fa6e 	bl	2adf2 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
   21916:	f030 0302 	bics.w	r3, r0, #2
   2191a:	d00d      	beq.n	21938 <time_slot_delay+0x64>
		_ticker_sync_context.result = 0;
   2191c:	4b08      	ldr	r3, [pc, #32]	; (21940 <time_slot_delay+0x6c>)
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
   2191e:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
		_ticker_sync_context.result = 0;
   21922:	60dc      	str	r4, [r3, #12]
	int ret = ticker_stop(inst_idx, u_id, tic_id, NULL, NULL);
   21924:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   21928:	9400      	str	r4, [sp, #0]
   2192a:	4623      	mov	r3, r4
   2192c:	4621      	mov	r1, r4
   2192e:	f7f8 fb59 	bl	19fe4 <ticker_stop>
   21932:	4804      	ldr	r0, [pc, #16]	; (21944 <time_slot_delay+0x70>)
   21934:	f002 fb0e 	bl	23f54 <z_impl_k_sem_give>
}
   21938:	b00d      	add	sp, #52	; 0x34
   2193a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2193e:	bf00      	nop
   21940:	200036ac 	.word	0x200036ac
   21944:	200036bc 	.word	0x200036bc

00021948 <time_slot_callback_prepare>:
	time_slot_delay(ticks_at_expire,
   21948:	9b01      	ldr	r3, [sp, #4]
   2194a:	4a02      	ldr	r2, [pc, #8]	; (21954 <time_slot_callback_prepare+0xc>)
   2194c:	2131      	movs	r1, #49	; 0x31
   2194e:	f7ff bfc1 	b.w	218d4 <time_slot_delay>
   21952:	bf00      	nop
   21954:	00021959 	.word	0x00021959

00021958 <time_slot_callback_abort>:
{
   21958:	b570      	push	{r4, r5, r6, lr}
   2195a:	9d05      	ldr	r5, [sp, #20]
   2195c:	4604      	mov	r4, r0
	ll_radio_state_abort();
   2195e:	f7f9 ff2d 	bl	1b7bc <ll_radio_state_abort>
	time_slot_delay(ticks_at_expire,
   21962:	462b      	mov	r3, r5
   21964:	4620      	mov	r0, r4
   21966:	4a03      	ldr	r2, [pc, #12]	; (21974 <time_slot_callback_abort+0x1c>)
}
   21968:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	time_slot_delay(ticks_at_expire,
   2196c:	2106      	movs	r1, #6
   2196e:	f7ff bfb1 	b.w	218d4 <time_slot_delay>
   21972:	bf00      	nop
   21974:	00021891 	.word	0x00021891

00021978 <nrf_flash_sync_init>:
{
   21978:	b508      	push	{r3, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   2197a:	2201      	movs	r2, #1
   2197c:	2100      	movs	r1, #0
   2197e:	4802      	ldr	r0, [pc, #8]	; (21988 <nrf_flash_sync_init+0x10>)
   21980:	f00b f97d 	bl	2cc7e <z_impl_k_sem_init>
}
   21984:	2000      	movs	r0, #0
   21986:	bd08      	pop	{r3, pc}
   21988:	200036bc 	.word	0x200036bc

0002198c <nrf_flash_sync_set_context>:
	_ticker_sync_context.interval = duration - FLASH_SYNC_SWITCHING_TIME;
   2198c:	4b02      	ldr	r3, [pc, #8]	; (21998 <nrf_flash_sync_set_context+0xc>)
   2198e:	f2a0 62a4 	subw	r2, r0, #1700	; 0x6a4
	_ticker_sync_context.slot = duration;
   21992:	e9c3 2000 	strd	r2, r0, [r3]
}
   21996:	4770      	bx	lr
   21998:	200036ac 	.word	0x200036ac

0002199c <nrf_flash_sync_get_timestamp_begin>:
{
   2199c:	b508      	push	{r3, lr}
	_ticker_sync_context.ticks_begin = ticker_ticks_now_get();
   2199e:	f009 fa5b 	bl	2ae58 <ticker_ticks_now_get>
   219a2:	4b01      	ldr	r3, [pc, #4]	; (219a8 <nrf_flash_sync_get_timestamp_begin+0xc>)
   219a4:	6098      	str	r0, [r3, #8]
}
   219a6:	bd08      	pop	{r3, pc}
   219a8:	200036ac 	.word	0x200036ac

000219ac <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   219ac:	b570      	push	{r4, r5, r6, lr}
		break;
	default:
		return -ENOTSUP;
	}
#else
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
   219ae:	794b      	ldrb	r3, [r1, #5]
   219b0:	2b01      	cmp	r3, #1
   219b2:	d120      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   219b4:	798b      	ldrb	r3, [r1, #6]
   219b6:	2b03      	cmp	r3, #3
   219b8:	d11d      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   219ba:	79cc      	ldrb	r4, [r1, #7]
   219bc:	b10c      	cbz	r4, 219c2 <uarte_nrfx_configure+0x16>
   219be:	2c01      	cmp	r4, #1
   219c0:	d119      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   219c2:	790a      	ldrb	r2, [r1, #4]
   219c4:	b112      	cbz	r2, 219cc <uarte_nrfx_configure+0x20>
   219c6:	2a02      	cmp	r2, #2
   219c8:	d115      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
   219ca:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   219cc:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   219ce:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   219d0:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   219d4:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   219d6:	d062      	beq.n	21a9e <uarte_nrfx_configure+0xf2>
   219d8:	d82b      	bhi.n	21a32 <uarte_nrfx_configure+0x86>
   219da:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   219de:	d061      	beq.n	21aa4 <uarte_nrfx_configure+0xf8>
   219e0:	d814      	bhi.n	21a0c <uarte_nrfx_configure+0x60>
   219e2:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   219e6:	d05f      	beq.n	21aa8 <uarte_nrfx_configure+0xfc>
   219e8:	d808      	bhi.n	219fc <uarte_nrfx_configure+0x50>
   219ea:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   219ee:	d05e      	beq.n	21aae <uarte_nrfx_configure+0x102>
   219f0:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   219f4:	d05e      	beq.n	21ab4 <uarte_nrfx_configure+0x108>
   219f6:	f06f 0085 	mvn.w	r0, #133	; 0x85
   219fa:	e04f      	b.n	21a9c <uarte_nrfx_configure+0xf0>
   219fc:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   21a00:	d05b      	beq.n	21aba <uarte_nrfx_configure+0x10e>
   21a02:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   21a06:	d1f6      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   21a08:	4b36      	ldr	r3, [pc, #216]	; (21ae4 <uarte_nrfx_configure+0x138>)
   21a0a:	e03c      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a0c:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   21a10:	d056      	beq.n	21ac0 <uarte_nrfx_configure+0x114>
   21a12:	d807      	bhi.n	21a24 <uarte_nrfx_configure+0x78>
   21a14:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   21a18:	d054      	beq.n	21ac4 <uarte_nrfx_configure+0x118>
   21a1a:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   21a1e:	d1ea      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   21a20:	4b31      	ldr	r3, [pc, #196]	; (21ae8 <uarte_nrfx_configure+0x13c>)
   21a22:	e030      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a24:	f647 2612 	movw	r6, #31250	; 0x7a12
   21a28:	42b3      	cmp	r3, r6
   21a2a:	d1e4      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   21a2c:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   21a30:	e029      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a32:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   21a36:	d047      	beq.n	21ac8 <uarte_nrfx_configure+0x11c>
   21a38:	d813      	bhi.n	21a62 <uarte_nrfx_configure+0xb6>
   21a3a:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   21a3e:	d046      	beq.n	21ace <uarte_nrfx_configure+0x122>
   21a40:	d809      	bhi.n	21a56 <uarte_nrfx_configure+0xaa>
   21a42:	f64d 26c0 	movw	r6, #56000	; 0xdac0
   21a46:	42b3      	cmp	r3, r6
   21a48:	d043      	beq.n	21ad2 <uarte_nrfx_configure+0x126>
   21a4a:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   21a4e:	d1d2      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   21a50:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   21a54:	e017      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a56:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   21a5a:	d1cc      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   21a5c:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   21a60:	e011      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a62:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   21a66:	d037      	beq.n	21ad8 <uarte_nrfx_configure+0x12c>
   21a68:	d808      	bhi.n	21a7c <uarte_nrfx_configure+0xd0>
   21a6a:	4e20      	ldr	r6, [pc, #128]	; (21aec <uarte_nrfx_configure+0x140>)
   21a6c:	42b3      	cmp	r3, r6
   21a6e:	d036      	beq.n	21ade <uarte_nrfx_configure+0x132>
   21a70:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   21a74:	d1bf      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   21a76:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   21a7a:	e004      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21a7c:	4e1c      	ldr	r6, [pc, #112]	; (21af0 <uarte_nrfx_configure+0x144>)
   21a7e:	42b3      	cmp	r3, r6
   21a80:	d1b9      	bne.n	219f6 <uarte_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   21a82:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
	struct uarte_nrfx_data *data = dev->data;
   21a86:	6900      	ldr	r0, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   21a88:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	data->uart_config = *cfg;
   21a8c:	1d03      	adds	r3, r0, #4
   21a8e:	c903      	ldmia	r1, {r0, r1}
                    | (uint32_t)p_cfg->hwfc;
   21a90:	4322      	orrs	r2, r4
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   21a92:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   21a96:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   21a9a:	2000      	movs	r0, #0
}
   21a9c:	bd70      	pop	{r4, r5, r6, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   21a9e:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   21aa2:	e7f0      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   21aa4:	4b13      	ldr	r3, [pc, #76]	; (21af4 <uarte_nrfx_configure+0x148>)
   21aa6:	e7ee      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   21aa8:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   21aac:	e7eb      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = 0x00014000;
   21aae:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   21ab2:	e7e8      	b.n	21a86 <uarte_nrfx_configure+0xda>
	switch (baudrate) {
   21ab4:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   21ab8:	e7e5      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   21aba:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   21abe:	e7e2      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   21ac0:	4b0d      	ldr	r3, [pc, #52]	; (21af8 <uarte_nrfx_configure+0x14c>)
   21ac2:	e7e0      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   21ac4:	4b0d      	ldr	r3, [pc, #52]	; (21afc <uarte_nrfx_configure+0x150>)
   21ac6:	e7de      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   21ac8:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   21acc:	e7db      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   21ace:	4b0c      	ldr	r3, [pc, #48]	; (21b00 <uarte_nrfx_configure+0x154>)
   21ad0:	e7d9      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   21ad2:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   21ad6:	e7d6      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   21ad8:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   21adc:	e7d3      	b.n	21a86 <uarte_nrfx_configure+0xda>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   21ade:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   21ae2:	e7d0      	b.n	21a86 <uarte_nrfx_configure+0xda>
   21ae4:	0013b000 	.word	0x0013b000
   21ae8:	004ea000 	.word	0x004ea000
   21aec:	0003d090 	.word	0x0003d090
   21af0:	000f4240 	.word	0x000f4240
   21af4:	00275000 	.word	0x00275000
   21af8:	0075c000 	.word	0x0075c000
   21afc:	003af000 	.word	0x003af000
   21b00:	013a9000 	.word	0x013a9000

00021b04 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   21b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct uarte_nrfx_data *data = dev->data;
   21b06:	6906      	ldr	r6, [r0, #16]
{
   21b08:	4605      	mov	r5, r0
   21b0a:	460f      	mov	r7, r1
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   21b0c:	f00a ffa7 	bl	2ca5e <k_is_in_isr>
   21b10:	b910      	cbnz	r0, 21b18 <uarte_nrfx_poll_out+0x14>
   21b12:	4b2c      	ldr	r3, [pc, #176]	; (21bc4 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   21b14:	781b      	ldrb	r3, [r3, #0]
   21b16:	b983      	cbnz	r3, 21b3a <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   21b18:	f04f 0320 	mov.w	r3, #32
   21b1c:	f3ef 8411 	mrs	r4, BASEPRI
   21b20:	f383 8812 	msr	BASEPRI_MAX, r3
   21b24:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   21b28:	6868      	ldr	r0, [r5, #4]
   21b2a:	f00a fe2a 	bl	2c782 <is_tx_ready.isra.0>
   21b2e:	bb28      	cbnz	r0, 21b7c <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   21b30:	f384 8811 	msr	BASEPRI, r4
   21b34:	f3bf 8f6f 	isb	sy
}
   21b38:	e7ee      	b.n	21b18 <uarte_nrfx_poll_out+0x14>
{
   21b3a:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   21b3c:	6868      	ldr	r0, [r5, #4]
   21b3e:	f00a fe20 	bl	2c782 <is_tx_ready.isra.0>
   21b42:	b970      	cbnz	r0, 21b62 <uarte_nrfx_poll_out+0x5e>
   21b44:	2001      	movs	r0, #1
   21b46:	f00a fe79 	bl	2c83c <nrfx_busy_wait>
   21b4a:	3c01      	subs	r4, #1
   21b4c:	d1f6      	bne.n	21b3c <uarte_nrfx_poll_out+0x38>
	return z_impl_k_sleep(timeout);
   21b4e:	2100      	movs	r1, #0
   21b50:	2021      	movs	r0, #33	; 0x21
   21b52:	f002 fee3 	bl	2491c <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   21b56:	e7f0      	b.n	21b3a <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   21b58:	f384 8811 	msr	BASEPRI, r4
   21b5c:	f3bf 8f6f 	isb	sy
}
   21b60:	e7f5      	b.n	21b4e <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   21b62:	f04f 0320 	mov.w	r3, #32
   21b66:	f3ef 8411 	mrs	r4, BASEPRI
   21b6a:	f383 8812 	msr	BASEPRI_MAX, r3
   21b6e:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   21b72:	6868      	ldr	r0, [r5, #4]
   21b74:	f00a fe05 	bl	2c782 <is_tx_ready.isra.0>
   21b78:	2800      	cmp	r0, #0
   21b7a:	d0ed      	beq.n	21b58 <uarte_nrfx_poll_out+0x54>
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   21b7c:	f806 7f10 	strb.w	r7, [r6, #16]!
	tx_start(dev, &data->char_out, 1);
   21b80:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   21b82:	680b      	ldr	r3, [r1, #0]
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   21b84:	2201      	movs	r2, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21b86:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21b8a:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21b8e:	2200      	movs	r2, #0
   21b90:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   21b94:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   21b98:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   21b9c:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   21ba0:	684a      	ldr	r2, [r1, #4]
   21ba2:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   21ba4:	bf41      	itttt	mi
   21ba6:	2208      	movmi	r2, #8
   21ba8:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   21bac:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   21bb0:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21bb4:	2201      	movs	r2, #1
   21bb6:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   21bb8:	f384 8811 	msr	BASEPRI, r4
   21bbc:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
   21bc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   21bc2:	bf00      	nop
   21bc4:	20003f6d 	.word	0x20003f6d

00021bc8 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   21bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   21bcc:	2101      	movs	r1, #1
   21bce:	4606      	mov	r6, r0
   21bd0:	b089      	sub	sp, #36	; 0x24
   21bd2:	2200      	movs	r2, #0
   21bd4:	2002      	movs	r0, #2
   21bd6:	f7e2 fd71 	bl	46bc <z_arm_irq_priority_set>
   21bda:	2002      	movs	r0, #2
   21bdc:	f7e2 fd3c 	bl	4658 <arch_irq_enable>
	const struct uarte_nrfx_config *config = dev->config;
   21be0:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = dev->data;
   21be2:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   21be4:	683c      	ldr	r4, [r7, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   21be6:	2300      	movs	r3, #0
   21be8:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   21bec:	602e      	str	r6, [r5, #0]
	uarte_nrfx_pins_configure(dev, false);
   21bee:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   21bf0:	68d8      	ldr	r0, [r3, #12]
   21bf2:	1c41      	adds	r1, r0, #1
   21bf4:	d00c      	beq.n	21c10 <uarte_0_init+0x48>
    *p_pin = pin_number & 0x1F;
   21bf6:	f000 021f 	and.w	r2, r0, #31
    p_reg->OUTSET = set_mask;
   21bfa:	f04f 4ca0 	mov.w	ip, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21bfe:	2101      	movs	r1, #1
   21c00:	4091      	lsls	r1, r2
    reg->PIN_CNF[pin_number] = cnf;
   21c02:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    p_reg->OUTSET = set_mask;
   21c06:	f8cc 1508 	str.w	r1, [ip, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
   21c0a:	2103      	movs	r1, #3
   21c0c:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   21c10:	6919      	ldr	r1, [r3, #16]
   21c12:	1c4a      	adds	r2, r1, #1
   21c14:	d010      	beq.n	21c38 <uarte_0_init+0x70>
			nrf_gpio_cfg_input(cfg->rx_pin,
   21c16:	7f1a      	ldrb	r2, [r3, #28]
   21c18:	2a00      	cmp	r2, #0
    *p_pin = pin_number & 0x1F;
   21c1a:	f001 021f 	and.w	r2, r1, #31
   21c1e:	bf14      	ite	ne
   21c20:	f04f 0c03 	movne.w	ip, #3
   21c24:	f04f 0c00 	moveq.w	ip, #0
    reg->PIN_CNF[pin_number] = cnf;
   21c28:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   21c2c:	f04f 4ea0 	mov.w	lr, #1342177280	; 0x50000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21c30:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    reg->PIN_CNF[pin_number] = cnf;
   21c34:	f84e c022 	str.w	ip, [lr, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   21c38:	f8d3 c014 	ldr.w	ip, [r3, #20]
   21c3c:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   21c40:	d00f      	beq.n	21c62 <uarte_0_init+0x9a>
    *p_pin = pin_number & 0x1F;
   21c42:	f00c 021f 	and.w	r2, ip, #31
    p_reg->OUTSET = set_mask;
   21c46:	f04f 48a0 	mov.w	r8, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21c4a:	f04f 0e01 	mov.w	lr, #1
   21c4e:	fa0e fe02 	lsl.w	lr, lr, r2
    reg->PIN_CNF[pin_number] = cnf;
   21c52:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    p_reg->OUTSET = set_mask;
   21c56:	f8c8 e508 	str.w	lr, [r8, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
   21c5a:	f04f 0e03 	mov.w	lr, #3
   21c5e:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   21c62:	f8d3 e018 	ldr.w	lr, [r3, #24]
   21c66:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
   21c6a:	d010      	beq.n	21c8e <uarte_0_init+0xc6>
			nrf_gpio_cfg_input(cfg->cts_pin,
   21c6c:	7f5a      	ldrb	r2, [r3, #29]
   21c6e:	2a00      	cmp	r2, #0
    *p_pin = pin_number & 0x1F;
   21c70:	f00e 021f 	and.w	r2, lr, #31
   21c74:	bf14      	ite	ne
   21c76:	f04f 0803 	movne.w	r8, #3
   21c7a:	f04f 0800 	moveq.w	r8, #0
    reg->PIN_CNF[pin_number] = cnf;
   21c7e:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   21c82:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21c86:	ea4f 0888 	mov.w	r8, r8, lsl #2
    reg->PIN_CNF[pin_number] = cnf;
   21c8a:	f849 8022 	str.w	r8, [r9, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   21c8e:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   21c90:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   21c94:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &data->uart_config);
   21c98:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   21c9a:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   21c9e:	1d29      	adds	r1, r5, #4
    p_reg->PSEL.CTS = pselcts;
   21ca0:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   21ca4:	f7ff fe82 	bl	219ac <uarte_nrfx_configure>
	if (err) {
   21ca8:	4606      	mov	r6, r0
   21caa:	b9b8      	cbnz	r0, 21cdc <uarte_0_init+0x114>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   21cac:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   21cae:	0799      	lsls	r1, r3, #30
   21cb0:	d52b      	bpl.n	21d0a <uarte_0_init+0x142>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   21cb2:	f105 0012 	add.w	r0, r5, #18
   21cb6:	f001 f9c1 	bl	2303c <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   21cba:	4b28      	ldr	r3, [pc, #160]	; (21d5c <uarte_0_init+0x194>)
   21cbc:	4298      	cmp	r0, r3
   21cbe:	d011      	beq.n	21ce4 <uarte_0_init+0x11c>
		LOG_ERR("Failed to allocate PPI Channel");
   21cc0:	4b27      	ldr	r3, [pc, #156]	; (21d60 <uarte_0_init+0x198>)
   21cc2:	9306      	str	r3, [sp, #24]
   21cc4:	2302      	movs	r3, #2
   21cc6:	9301      	str	r3, [sp, #4]
   21cc8:	9305      	str	r3, [sp, #20]
   21cca:	4826      	ldr	r0, [pc, #152]	; (21d64 <uarte_0_init+0x19c>)
   21ccc:	4633      	mov	r3, r6
   21cce:	aa05      	add	r2, sp, #20
   21cd0:	f44f 5182 	mov.w	r1, #4160	; 0x1040
		return -EIO;
   21cd4:	f06f 0604 	mvn.w	r6, #4
   21cd8:	f003 fffe 	bl	25cd8 <z_impl_z_log_msg2_static_create>
UART_NRF_UARTE_DEVICE(0);
   21cdc:	4630      	mov	r0, r6
   21cde:	b009      	add	sp, #36	; 0x24
   21ce0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
   21ce4:	7ca8      	ldrb	r0, [r5, #18]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
   21ce6:	00c3      	lsls	r3, r0, #3
   21ce8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21cec:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    return (uint32_t)p_reg + (uint32_t)task;
   21cf0:	f104 020c 	add.w	r2, r4, #12
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
   21cf4:	f504 7190 	add.w	r1, r4, #288	; 0x120
    p_reg->CH[(uint32_t) channel].EEP = eep;
   21cf8:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    p_reg->CH[(uint32_t) channel].TEP = tep;
   21cfc:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    p_reg->CHENSET = mask;
   21d00:	4a19      	ldr	r2, [pc, #100]	; (21d68 <uarte_0_init+0x1a0>)
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   21d02:	2301      	movs	r3, #1
   21d04:	4083      	lsls	r3, r0
   21d06:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   21d0a:	2308      	movs	r3, #8
   21d0c:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   21d10:	7a3b      	ldrb	r3, [r7, #8]
   21d12:	b95b      	cbnz	r3, 21d2c <uarte_0_init+0x164>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d14:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   21d18:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   21d1c:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21d20:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21d24:	2301      	movs	r3, #1
   21d26:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d2a:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   21d2c:	687b      	ldr	r3, [r7, #4]
   21d2e:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   21d30:	bf5c      	itt	pl
   21d32:	f44f 7280 	movpl.w	r2, #256	; 0x100
   21d36:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   21d3a:	06db      	lsls	r3, r3, #27
   21d3c:	bf44      	itt	mi
   21d3e:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   21d42:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   21d46:	3510      	adds	r5, #16
    p_reg->TXD.MAXCNT = length;
   21d48:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21d4a:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21d4e:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d52:	2301      	movs	r3, #1
   21d54:	60a3      	str	r3, [r4, #8]
   21d56:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   21d58:	e7c0      	b.n	21cdc <uarte_0_init+0x114>
   21d5a:	bf00      	nop
   21d5c:	0bad0000 	.word	0x0bad0000
   21d60:	00034d77 	.word	0x00034d77
   21d64:	0002dc24 	.word	0x0002dc24
   21d68:	4001f000 	.word	0x4001f000

00021d6c <random_byte_get>:
	__asm__ volatile(
   21d6c:	f04f 0320 	mov.w	r3, #32
   21d70:	f3ef 8211 	mrs	r2, BASEPRI
   21d74:	f383 8812 	msr	BASEPRI_MAX, r3
   21d78:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   21d7c:	4b09      	ldr	r3, [pc, #36]	; (21da4 <random_byte_get+0x38>)
   21d7e:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   21d82:	b161      	cbz	r1, 21d9e <random_byte_get+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   21d84:	2100      	movs	r1, #0
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   21d86:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   21d8a:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   21d8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
		retval = nrf_rng_random_value_get(NRF_RNG);
   21d92:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   21d94:	f382 8811 	msr	BASEPRI, r2
   21d98:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
   21d9c:	4770      	bx	lr
	int retval = -EAGAIN;
   21d9e:	f06f 000a 	mvn.w	r0, #10
   21da2:	e7f7      	b.n	21d94 <random_byte_get+0x28>
   21da4:	4000d000 	.word	0x4000d000

00021da8 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
   21da8:	b5f0      	push	{r4, r5, r6, r7, lr}
   21daa:	4603      	mov	r3, r0
	uint32_t last  = rngp->last;
   21dac:	7884      	ldrb	r4, [r0, #2]
	uint32_t mask  = rngp->mask;
   21dae:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
   21db0:	f04f 0020 	mov.w	r0, #32
   21db4:	f3ef 8e11 	mrs	lr, BASEPRI
   21db8:	f380 8812 	msr	BASEPRI_MAX, r0
   21dbc:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   21dc0:	781e      	ldrb	r6, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   21dc2:	f893 c001 	ldrb.w	ip, [r3, #1]

	available = (last - first) & mask;
   21dc6:	1ba4      	subs	r4, r4, r6
   21dc8:	403c      	ands	r4, r7
	if (available < len) {
   21dca:	42a2      	cmp	r2, r4
		len = available;
   21dcc:	bf88      	it	hi
   21dce:	b2a2      	uxthhi	r2, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   21dd0:	18b0      	adds	r0, r6, r2
   21dd2:	4038      	ands	r0, r7
	first = rngp->first_alloc;
   21dd4:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
   21dd6:	7018      	strb	r0, [r3, #0]
	__asm__ volatile(
   21dd8:	f38e 8811 	msr	BASEPRI, lr
   21ddc:	f3bf 8f6f 	isb	sy
   21de0:	1888      	adds	r0, r1, r2
	uint8_t *dst   = buf;
   21de2:	460a      	mov	r2, r1
	irq_unlock(key);

	while (likely(len--)) {
   21de4:	4290      	cmp	r0, r2
   21de6:	d119      	bne.n	21e1c <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   21de8:	4566      	cmp	r6, ip
   21dea:	d10d      	bne.n	21e08 <rng_pool_get+0x60>
	__asm__ volatile(
   21dec:	f04f 0520 	mov.w	r5, #32
   21df0:	f3ef 8011 	mrs	r0, BASEPRI
   21df4:	f385 8812 	msr	BASEPRI_MAX, r5
   21df8:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   21dfc:	781d      	ldrb	r5, [r3, #0]
   21dfe:	705d      	strb	r5, [r3, #1]
	__asm__ volatile(
   21e00:	f380 8811 	msr	BASEPRI, r0
   21e04:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   21e08:	1a52      	subs	r2, r2, r1
	available = available - len;
	if (available <= rngp->threshold) {
   21e0a:	791b      	ldrb	r3, [r3, #4]
	len = dst - buf;
   21e0c:	b290      	uxth	r0, r2
	available = available - len;
   21e0e:	1a22      	subs	r2, r4, r0
	if (available <= rngp->threshold) {
   21e10:	4293      	cmp	r3, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   21e12:	bf22      	ittt	cs
   21e14:	4b06      	ldrcs	r3, [pc, #24]	; (21e30 <rng_pool_get+0x88>)
   21e16:	2201      	movcs	r2, #1
   21e18:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   21e1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   21e1c:	eb03 0e05 	add.w	lr, r3, r5
		first = (first + 1) & mask;
   21e20:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   21e22:	f89e e005 	ldrb.w	lr, [lr, #5]
   21e26:	f802 eb01 	strb.w	lr, [r2], #1
		first = (first + 1) & mask;
   21e2a:	403d      	ands	r5, r7
   21e2c:	e7da      	b.n	21de4 <rng_pool_get+0x3c>
   21e2e:	bf00      	nop
   21e30:	4000d000 	.word	0x4000d000

00021e34 <entropy_nrf5_get_entropy_isr>:
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   21e34:	43db      	mvns	r3, r3
{
   21e36:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   21e3a:	f013 0501 	ands.w	r5, r3, #1
{
   21e3e:	460e      	mov	r6, r1
   21e40:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   21e42:	d004      	beq.n	21e4e <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   21e44:	4821      	ldr	r0, [pc, #132]	; (21ecc <entropy_nrf5_get_entropy_isr+0x98>)
   21e46:	f7ff ffaf 	bl	21da8 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
   21e4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   21e4e:	b3a2      	cbz	r2, 21eba <entropy_nrf5_get_entropy_isr+0x86>
	__asm__ volatile(
   21e50:	f04f 0320 	mov.w	r3, #32
   21e54:	f3ef 8811 	mrs	r8, BASEPRI
   21e58:	f383 8812 	msr	BASEPRI_MAX, r3
   21e5c:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
   21e60:	200d      	movs	r0, #13
   21e62:	f7e2 fc1d 	bl	46a0 <arch_irq_is_enabled>
   21e66:	4607      	mov	r7, r0
		irq_disable(IRQN);
   21e68:	200d      	movs	r0, #13
   21e6a:	f7e2 fc05 	bl	4678 <arch_irq_disable>
	__asm__ volatile(
   21e6e:	f388 8811 	msr	BASEPRI, r8
   21e72:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   21e76:	f8df 8058 	ldr.w	r8, [pc, #88]	; 21ed0 <entropy_nrf5_get_entropy_isr+0x9c>
   21e7a:	f8df 9058 	ldr.w	r9, [pc, #88]	; 21ed4 <entropy_nrf5_get_entropy_isr+0xa0>
   21e7e:	f8c8 5100 	str.w	r5, [r8, #256]	; 0x100
   21e82:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
   21e86:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   21e8a:	2301      	movs	r3, #1
   21e8c:	f8c8 3000 	str.w	r3, [r8]
   21e90:	4625      	mov	r5, r4
   21e92:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   21e96:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
   21e9a:	b183      	cbz	r3, 21ebe <entropy_nrf5_get_entropy_isr+0x8a>
			byte = random_byte_get();
   21e9c:	f7ff ff66 	bl	21d6c <random_byte_get>
			if (byte < 0) {
   21ea0:	1e03      	subs	r3, r0, #0
   21ea2:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   21ea6:	dbf6      	blt.n	21e96 <entropy_nrf5_get_entropy_isr+0x62>
			buf[--len] = byte;
   21ea8:	3d01      	subs	r5, #1
   21eaa:	b2ad      	uxth	r5, r5
   21eac:	5573      	strb	r3, [r6, r5]
		} while (len);
   21eae:	2d00      	cmp	r5, #0
   21eb0:	d1f1      	bne.n	21e96 <entropy_nrf5_get_entropy_isr+0x62>
		if (irq_enabled) {
   21eb2:	b117      	cbz	r7, 21eba <entropy_nrf5_get_entropy_isr+0x86>
			irq_enable(IRQN);
   21eb4:	200d      	movs	r0, #13
   21eb6:	f7e2 fbcf 	bl	4658 <arch_irq_enable>
	return cnt;
   21eba:	4620      	mov	r0, r4
   21ebc:	e7c5      	b.n	21e4a <entropy_nrf5_get_entropy_isr+0x16>
  __ASM volatile ("dsb 0xF":::"memory");
   21ebe:	f3bf 8f4f 	dsb	sy
				__WFE();
   21ec2:	bf20      	wfe
				__SEV();
   21ec4:	bf40      	sev
				__WFE();
   21ec6:	bf20      	wfe
   21ec8:	e7e5      	b.n	21e96 <entropy_nrf5_get_entropy_isr+0x62>
   21eca:	bf00      	nop
   21ecc:	20003704 	.word	0x20003704
   21ed0:	4000d000 	.word	0x4000d000
   21ed4:	e000e100 	.word	0xe000e100

00021ed8 <entropy_nrf5_get_entropy>:
{
   21ed8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
   21edc:	4f13      	ldr	r7, [pc, #76]	; (21f2c <entropy_nrf5_get_entropy+0x54>)
   21ede:	460d      	mov	r5, r1
   21ee0:	4614      	mov	r4, r2
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   21ee2:	f107 0845 	add.w	r8, r7, #69	; 0x45
   21ee6:	f107 0918 	add.w	r9, r7, #24
	while (len) {
   21eea:	b914      	cbnz	r4, 21ef2 <entropy_nrf5_get_entropy+0x1a>
}
   21eec:	4620      	mov	r0, r4
   21eee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   21ef2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21ef6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21efa:	4638      	mov	r0, r7
   21efc:	f002 f850 	bl	23fa0 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   21f00:	4622      	mov	r2, r4
   21f02:	4629      	mov	r1, r5
   21f04:	4640      	mov	r0, r8
   21f06:	f7ff ff4f 	bl	21da8 <rng_pool_get>
   21f0a:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
   21f0c:	4638      	mov	r0, r7
   21f0e:	f002 f821 	bl	23f54 <z_impl_k_sem_give>
		if (bytes == 0U) {
   21f12:	b93e      	cbnz	r6, 21f24 <entropy_nrf5_get_entropy+0x4c>
	return z_impl_k_sem_take(sem, timeout);
   21f14:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21f18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21f1c:	4648      	mov	r0, r9
   21f1e:	f002 f83f 	bl	23fa0 <z_impl_k_sem_take>
			continue;
   21f22:	e7e2      	b.n	21eea <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
   21f24:	1ba4      	subs	r4, r4, r6
   21f26:	b2a4      	uxth	r4, r4
		buf += bytes;
   21f28:	4435      	add	r5, r6
   21f2a:	e7de      	b.n	21eea <entropy_nrf5_get_entropy+0x12>
   21f2c:	200036d4 	.word	0x200036d4

00021f30 <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
   21f30:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   21f32:	4c19      	ldr	r4, [pc, #100]	; (21f98 <entropy_nrf5_init+0x68>)
   21f34:	2201      	movs	r2, #1
   21f36:	4611      	mov	r1, r2
   21f38:	4620      	mov	r0, r4
   21f3a:	f00a fea0 	bl	2cc7e <z_impl_k_sem_init>
   21f3e:	2201      	movs	r2, #1
   21f40:	2100      	movs	r1, #0
   21f42:	f104 0018 	add.w	r0, r4, #24
   21f46:	f00a fe9a 	bl	2cc7e <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   21f4a:	f240 4307 	movw	r3, #1031	; 0x407
   21f4e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   21f52:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   21f56:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   21f58:	230c      	movs	r3, #12
   21f5a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   21f5e:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   21f60:	4b0e      	ldr	r3, [pc, #56]	; (21f9c <entropy_nrf5_init+0x6c>)
   21f62:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   21f66:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   21f6a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   21f6e:	f042 0201 	orr.w	r2, r2, #1
   21f72:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    p_reg->INTENSET = mask;
   21f76:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   21f78:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
   21f7c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   21f80:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
   21f84:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   21f86:	6019      	str	r1, [r3, #0]
   21f88:	200d      	movs	r0, #13
   21f8a:	f7e2 fb97 	bl	46bc <z_arm_irq_priority_set>
	irq_enable(IRQN);
   21f8e:	200d      	movs	r0, #13
   21f90:	f7e2 fb62 	bl	4658 <arch_irq_enable>

	return 0;
}
   21f94:	4628      	mov	r0, r5
   21f96:	bd38      	pop	{r3, r4, r5, pc}
   21f98:	200036d4 	.word	0x200036d4
   21f9c:	4000d000 	.word	0x4000d000

00021fa0 <isr>:
{
   21fa0:	b510      	push	{r4, lr}
	byte = random_byte_get();
   21fa2:	f7ff fee3 	bl	21d6c <random_byte_get>
	if (byte < 0) {
   21fa6:	2800      	cmp	r0, #0
   21fa8:	db20      	blt.n	21fec <isr+0x4c>
	uint8_t last  = rngp->last;
   21faa:	4b17      	ldr	r3, [pc, #92]	; (22008 <isr+0x68>)
   21fac:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   21fb0:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	uint8_t mask  = rngp->mask;
   21fb4:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   21fb8:	1a51      	subs	r1, r2, r1
   21fba:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   21fbe:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   21fc0:	d10d      	bne.n	21fde <isr+0x3e>
	uint8_t last  = rngp->last;
   21fc2:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   21fc6:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	uint8_t mask  = rngp->mask;
   21fca:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   21fce:	1a51      	subs	r1, r2, r1
   21fd0:	ea34 0101 	bics.w	r1, r4, r1
   21fd4:	d10b      	bne.n	21fee <isr+0x4e>
   21fd6:	4b0d      	ldr	r3, [pc, #52]	; (2200c <isr+0x6c>)
   21fd8:	2201      	movs	r2, #1
   21fda:	605a      	str	r2, [r3, #4]
}
   21fdc:	e00e      	b.n	21ffc <isr+0x5c>
	rngp->buffer[last] = byte;
   21fde:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   21fe0:	3201      	adds	r2, #1
   21fe2:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   21fe4:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   21fe8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
   21fec:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   21fee:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   21ff0:	3201      	adds	r2, #1
   21ff2:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   21ff4:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   21ff8:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   21ffc:	4804      	ldr	r0, [pc, #16]	; (22010 <isr+0x70>)
}
   21ffe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   22002:	f001 bfa7 	b.w	23f54 <z_impl_k_sem_give>
   22006:	bf00      	nop
   22008:	200036d4 	.word	0x200036d4
   2200c:	4000d000 	.word	0x4000d000
   22010:	200036ec 	.word	0x200036ec

00022014 <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
   22014:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   22016:	2301      	movs	r3, #1
   22018:	4083      	lsls	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2201a:	4a11      	ldr	r2, [pc, #68]	; (22060 <compare_int_lock+0x4c>)
   2201c:	f3bf 8f5b 	dmb	ish
   22020:	43dc      	mvns	r4, r3
   22022:	e852 1f00 	ldrex	r1, [r2]
   22026:	ea01 0c04 	and.w	ip, r1, r4
   2202a:	e842 ce00 	strex	lr, ip, [r2]
   2202e:	f1be 0f00 	cmp.w	lr, #0
   22032:	d1f6      	bne.n	22022 <compare_int_lock+0xe>
   22034:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   22038:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2203c:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   22040:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   22044:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   22048:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
   2204c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   22050:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   22054:	420b      	tst	r3, r1
}
   22056:	bf14      	ite	ne
   22058:	2001      	movne	r0, #1
   2205a:	2000      	moveq	r0, #0
   2205c:	bd10      	pop	{r4, pc}
   2205e:	bf00      	nop
   22060:	2000372c 	.word	0x2000372c

00022064 <sys_clock_timeout_handler>:
static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   22064:	4919      	ldr	r1, [pc, #100]	; (220cc <sys_clock_timeout_handler+0x68>)
{
   22066:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22068:	4604      	mov	r4, r0
	return absolute_time & COUNTER_MAX;
   2206a:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   2206e:	6808      	ldr	r0, [r1, #0]

	last_count += dticks * CYC_PER_TICK;
   22070:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   22074:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   22078:	1a10      	subs	r0, r2, r0
	if (in_anchor_range(cc_value)) {
   2207a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   2207e:	d222      	bcs.n	220c6 <sys_clock_timeout_handler+0x62>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   22080:	4b13      	ldr	r3, [pc, #76]	; (220d0 <sys_clock_timeout_handler+0x6c>)
   22082:	681b      	ldr	r3, [r3, #0]
   22084:	0a1a      	lsrs	r2, r3, #8
   22086:	061b      	lsls	r3, r3, #24
   22088:	195e      	adds	r6, r3, r5
   2208a:	4b12      	ldr	r3, [pc, #72]	; (220d4 <sys_clock_timeout_handler+0x70>)
   2208c:	f142 0700 	adc.w	r7, r2, #0
   22090:	e9c3 6700 	strd	r6, r7, [r3]
		return true;
   22094:	2601      	movs	r6, #1
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   22096:	f002 fdd9 	bl	24c4c <sys_clock_announce>
    return p_reg->CC[ch];
   2209a:	00a3      	lsls	r3, r4, #2
   2209c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   220a0:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
   220a4:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   220a8:	42aa      	cmp	r2, r5
   220aa:	d10b      	bne.n	220c4 <sys_clock_timeout_handler+0x60>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   220ac:	b91e      	cbnz	r6, 220b6 <sys_clock_timeout_handler+0x52>
    p_reg->CC[ch] = cc_val;
   220ae:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   220b2:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->EVTENSET = mask;
   220b6:	4b08      	ldr	r3, [pc, #32]	; (220d8 <sys_clock_timeout_handler+0x74>)
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   220b8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   220bc:	fa00 f404 	lsl.w	r4, r0, r4
   220c0:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   220c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
   220c6:	2600      	movs	r6, #0
   220c8:	e7e5      	b.n	22096 <sys_clock_timeout_handler+0x32>
   220ca:	bf00      	nop
   220cc:	200022f8 	.word	0x200022f8
   220d0:	20003730 	.word	0x20003730
   220d4:	200022e0 	.word	0x200022e0
   220d8:	40011000 	.word	0x40011000

000220dc <compare_int_unlock>:
	if (key) {
   220dc:	b319      	cbz	r1, 22126 <compare_int_unlock+0x4a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   220de:	f3bf 8f5b 	dmb	ish
		atomic_or(&int_mask, BIT(chan));
   220e2:	2301      	movs	r3, #1
   220e4:	4a10      	ldr	r2, [pc, #64]	; (22128 <compare_int_unlock+0x4c>)
   220e6:	4083      	lsls	r3, r0
   220e8:	e852 1f00 	ldrex	r1, [r2]
   220ec:	4319      	orrs	r1, r3
   220ee:	e842 1c00 	strex	ip, r1, [r2]
   220f2:	f1bc 0f00 	cmp.w	ip, #0
   220f6:	d1f7      	bne.n	220e8 <compare_int_unlock+0xc>
   220f8:	f3bf 8f5b 	dmb	ish
    p_reg->INTENSET = mask;
   220fc:	4a0b      	ldr	r2, [pc, #44]	; (2212c <compare_int_unlock+0x50>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   220fe:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   22102:	4083      	lsls	r3, r0
   22104:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   22108:	4b09      	ldr	r3, [pc, #36]	; (22130 <compare_int_unlock+0x54>)
   2210a:	f3bf 8f5b 	dmb	ish
   2210e:	681b      	ldr	r3, [r3, #0]
   22110:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   22114:	fa23 f000 	lsr.w	r0, r3, r0
   22118:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2211a:	bf42      	ittt	mi
   2211c:	4b05      	ldrmi	r3, [pc, #20]	; (22134 <compare_int_unlock+0x58>)
   2211e:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
   22122:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   22126:	4770      	bx	lr
   22128:	2000372c 	.word	0x2000372c
   2212c:	40011000 	.word	0x40011000
   22130:	20003728 	.word	0x20003728
   22134:	e000e100 	.word	0xe000e100

00022138 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   22138:	4b0d      	ldr	r3, [pc, #52]	; (22170 <z_nrf_rtc_timer_read+0x38>)
   2213a:	6818      	ldr	r0, [r3, #0]
   2213c:	0a01      	lsrs	r1, r0, #8
   2213e:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
   22140:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   22144:	4b0b      	ldr	r3, [pc, #44]	; (22174 <z_nrf_rtc_timer_read+0x3c>)
   22146:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   2214a:	1818      	adds	r0, r3, r0
   2214c:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   22150:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   22154:	d20a      	bcs.n	2216c <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   22156:	4b08      	ldr	r3, [pc, #32]	; (22178 <z_nrf_rtc_timer_read+0x40>)
   22158:	e9d3 2300 	ldrd	r2, r3, [r3]
   2215c:	4290      	cmp	r0, r2
   2215e:	eb71 0303 	sbcs.w	r3, r1, r3
   22162:	d203      	bcs.n	2216c <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   22164:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   22168:	f141 0100 	adc.w	r1, r1, #0
}
   2216c:	4770      	bx	lr
   2216e:	bf00      	nop
   22170:	20003730 	.word	0x20003730
   22174:	40011000 	.word	0x40011000
   22178:	200022e0 	.word	0x200022e0

0002217c <compare_set>:
{
   2217c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22180:	b085      	sub	sp, #20
   22182:	4616      	mov	r6, r2
   22184:	4698      	mov	r8, r3
   22186:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   22188:	f7ff ff44 	bl	22014 <compare_int_lock>
   2218c:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   2218e:	f7ff ffd3 	bl	22138 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   22192:	42b0      	cmp	r0, r6
   22194:	eb71 0308 	sbcs.w	r3, r1, r8
   22198:	d278      	bcs.n	2228c <compare_set+0x110>
		if (target_time - curr_time > COUNTER_SPAN) {
   2219a:	4b46      	ldr	r3, [pc, #280]	; (222b4 <compare_set+0x138>)
   2219c:	1a30      	subs	r0, r6, r0
   2219e:	eb68 0101 	sbc.w	r1, r8, r1
   221a2:	4298      	cmp	r0, r3
   221a4:	f171 0300 	sbcs.w	r3, r1, #0
   221a8:	f080 8081 	bcs.w	222ae <compare_set+0x132>
		if (target_time != cc_data[chan].target_time) {
   221ac:	4b42      	ldr	r3, [pc, #264]	; (222b8 <compare_set+0x13c>)
   221ae:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   221b2:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
   221b6:	45d8      	cmp	r8, fp
   221b8:	bf08      	it	eq
   221ba:	4556      	cmpeq	r6, sl
   221bc:	d051      	beq.n	22262 <compare_set+0xe6>
   221be:	ea4f 0985 	mov.w	r9, r5, lsl #2
   221c2:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   221c6:	f105 0750 	add.w	r7, r5, #80	; 0x50
   221ca:	f509 3988 	add.w	r9, r9, #69632	; 0x11000
   221ce:	00bf      	lsls	r7, r7, #2
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   221d0:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   221d4:	fa01 f305 	lsl.w	r3, r1, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   221d8:	b2bf      	uxth	r7, r7
	return absolute_time & COUNTER_MAX;
   221da:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
   221de:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   221e2:	9301      	str	r3, [sp, #4]
    return p_reg->CC[ch];
   221e4:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   221e8:	4b34      	ldr	r3, [pc, #208]	; (222bc <compare_set+0x140>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   221ea:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   221ee:	4614      	mov	r4, r2
     return p_reg->COUNTER;
   221f0:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   221f4:	1a40      	subs	r0, r0, r1
   221f6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   221fa:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   221fe:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   22200:	f8c9 c540 	str.w	ip, [r9, #1344]	; 0x540
   22204:	d107      	bne.n	22216 <compare_set+0x9a>
   22206:	e9cd 2102 	strd	r2, r1, [sp, #8]
	z_impl_k_busy_wait(usec_to_wait);
   2220a:	2013      	movs	r0, #19
   2220c:	f00a ffa2 	bl	2d154 <z_impl_k_busy_wait>
   22210:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
   22214:	4b29      	ldr	r3, [pc, #164]	; (222bc <compare_set+0x140>)
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   22216:	f101 0c02 	add.w	ip, r1, #2
	return (a - b) & COUNTER_MAX;
   2221a:	eba4 000c 	sub.w	r0, r4, ip
   2221e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			cc_val = now + 2;
   22222:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   22226:	bf88      	it	hi
   22228:	4664      	movhi	r4, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   2222a:	2000      	movs	r0, #0
   2222c:	6038      	str	r0, [r7, #0]
   2222e:	6838      	ldr	r0, [r7, #0]
    p_reg->EVTENSET = mask;
   22230:	9801      	ldr	r0, [sp, #4]
   22232:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   22236:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   2223a:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   2223e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   22242:	4281      	cmp	r1, r0
   22244:	d006      	beq.n	22254 <compare_set+0xd8>
	return (a - b) & COUNTER_MAX;
   22246:	1a20      	subs	r0, r4, r0
   22248:	3802      	subs	r0, #2
   2224a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   2224e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   22252:	d819      	bhi.n	22288 <compare_set+0x10c>
	return (a - b) & COUNTER_MAX;
   22254:	1aa4      	subs	r4, r4, r2
   22256:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   2225a:	eb14 0a06 	adds.w	sl, r4, r6
   2225e:	f148 0b00 	adc.w	fp, r8, #0
	cc_data[chan].target_time = target_time;
   22262:	4915      	ldr	r1, [pc, #84]	; (222b8 <compare_set+0x13c>)
	cc_data[chan].callback = handler;
   22264:	980e      	ldr	r0, [sp, #56]	; 0x38
	cc_data[chan].target_time = target_time;
   22266:	012b      	lsls	r3, r5, #4
   22268:	eb01 1205 	add.w	r2, r1, r5, lsl #4
   2226c:	e9c2 ab02 	strd	sl, fp, [r2, #8]
	cc_data[chan].callback = handler;
   22270:	50c8      	str	r0, [r1, r3]
	cc_data[chan].user_context = user_data;
   22272:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   22274:	6053      	str	r3, [r2, #4]
	return ret;
   22276:	2400      	movs	r4, #0
	compare_int_unlock(chan, key);
   22278:	4628      	mov	r0, r5
   2227a:	9900      	ldr	r1, [sp, #0]
   2227c:	f7ff ff2e 	bl	220dc <compare_int_unlock>
}
   22280:	4620      	mov	r0, r4
   22282:	b005      	add	sp, #20
   22284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22288:	4620      	mov	r0, r4
   2228a:	e7b1      	b.n	221f0 <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
   2228c:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2228e:	4a0c      	ldr	r2, [pc, #48]	; (222c0 <compare_set+0x144>)
   22290:	f3bf 8f5b 	dmb	ish
   22294:	40ab      	lsls	r3, r5
   22296:	e852 1f00 	ldrex	r1, [r2]
   2229a:	4319      	orrs	r1, r3
   2229c:	e842 1000 	strex	r0, r1, [r2]
   222a0:	2800      	cmp	r0, #0
   222a2:	d1f8      	bne.n	22296 <compare_set+0x11a>
   222a4:	f3bf 8f5b 	dmb	ish
   222a8:	46b2      	mov	sl, r6
   222aa:	46c3      	mov	fp, r8
   222ac:	e7d9      	b.n	22262 <compare_set+0xe6>
			return -EINVAL;
   222ae:	f06f 0415 	mvn.w	r4, #21
   222b2:	e7e1      	b.n	22278 <compare_set+0xfc>
   222b4:	01000001 	.word	0x01000001
   222b8:	200022e8 	.word	0x200022e8
   222bc:	40011000 	.word	0x40011000
   222c0:	20003728 	.word	0x20003728

000222c4 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   222c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   222c6:	4b19      	ldr	r3, [pc, #100]	; (2232c <sys_clock_driver_init+0x68>)
    p_reg->PRESCALER = val;
   222c8:	4d19      	ldr	r5, [pc, #100]	; (22330 <sys_clock_driver_init+0x6c>)
   222ca:	2400      	movs	r4, #0
   222cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   222d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   222d4:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   222d8:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   222dc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   222e0:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   222e4:	4b13      	ldr	r3, [pc, #76]	; (22334 <sys_clock_driver_init+0x70>)
   222e6:	2602      	movs	r6, #2
   222e8:	f44f 3200 	mov.w	r2, #131072	; 0x20000

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   222ec:	2101      	movs	r1, #1
   222ee:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   222f2:	2011      	movs	r0, #17
   222f4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   222f8:	4622      	mov	r2, r4
   222fa:	f7e2 f9df 	bl	46bc <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   222fe:	2011      	movs	r0, #17
   22300:	f7e2 f9aa 	bl	4658 <arch_irq_enable>

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   22304:	4a0c      	ldr	r2, [pc, #48]	; (22338 <sys_clock_driver_init+0x74>)
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   22306:	2301      	movs	r3, #1
   22308:	60ab      	str	r3, [r5, #8]
   2230a:	602b      	str	r3, [r5, #0]
   2230c:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   2230e:	4b0b      	ldr	r3, [pc, #44]	; (2233c <sys_clock_driver_init+0x78>)
   22310:	4a0b      	ldr	r2, [pc, #44]	; (22340 <sys_clock_driver_init+0x7c>)
   22312:	9300      	str	r3, [sp, #0]
   22314:	9401      	str	r4, [sp, #4]
   22316:	2300      	movs	r3, #0
   22318:	4620      	mov	r0, r4
   2231a:	f7ff ff2f 	bl	2217c <compare_set>

	z_nrf_clock_control_lf_on(mode);
   2231e:	4630      	mov	r0, r6
   22320:	f7fe fc28 	bl	20b74 <z_nrf_clock_control_lf_on>

	return 0;
}
   22324:	4620      	mov	r0, r4
   22326:	b002      	add	sp, #8
   22328:	bd70      	pop	{r4, r5, r6, pc}
   2232a:	bf00      	nop
   2232c:	200022e8 	.word	0x200022e8
   22330:	40011000 	.word	0x40011000
   22334:	e000e100 	.word	0xe000e100
   22338:	2000372c 	.word	0x2000372c
   2233c:	00022065 	.word	0x00022065
   22340:	007fffff 	.word	0x007fffff

00022344 <rtc_nrf_isr>:
{
   22344:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
   22348:	4c35      	ldr	r4, [pc, #212]	; (22420 <rtc_nrf_isr+0xdc>)
   2234a:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   2234e:	079a      	lsls	r2, r3, #30
   22350:	d50b      	bpl.n	2236a <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22352:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   22356:	b143      	cbz	r3, 2236a <rtc_nrf_isr+0x26>
		overflow_cnt++;
   22358:	4a32      	ldr	r2, [pc, #200]	; (22424 <rtc_nrf_isr+0xe0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   2235a:	2300      	movs	r3, #0
   2235c:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   22360:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   22364:	6813      	ldr	r3, [r2, #0]
   22366:	3301      	adds	r3, #1
   22368:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   2236a:	f04f 0320 	mov.w	r3, #32
   2236e:	f3ef 8211 	mrs	r2, BASEPRI
   22372:	f383 8812 	msr	BASEPRI_MAX, r3
   22376:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   2237a:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   2237e:	03db      	lsls	r3, r3, #15
   22380:	d512      	bpl.n	223a8 <rtc_nrf_isr+0x64>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   22382:	f3bf 8f5b 	dmb	ish
   22386:	4b28      	ldr	r3, [pc, #160]	; (22428 <rtc_nrf_isr+0xe4>)
   22388:	e853 1f00 	ldrex	r1, [r3]
   2238c:	f021 0001 	bic.w	r0, r1, #1
   22390:	e843 0600 	strex	r6, r0, [r3]
   22394:	2e00      	cmp	r6, #0
   22396:	d1f7      	bne.n	22388 <rtc_nrf_isr+0x44>
   22398:	f3bf 8f5b 	dmb	ish
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   2239c:	2900      	cmp	r1, #0
   2239e:	d136      	bne.n	2240e <rtc_nrf_isr+0xca>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   223a0:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		if (result) {
   223a4:	2b00      	cmp	r3, #0
   223a6:	d132      	bne.n	2240e <rtc_nrf_isr+0xca>
{
   223a8:	2300      	movs	r3, #0
	__asm__ volatile(
   223aa:	f382 8811 	msr	BASEPRI, r2
   223ae:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   223b2:	b34b      	cbz	r3, 22408 <rtc_nrf_isr+0xc4>
		curr_time = z_nrf_rtc_timer_read();
   223b4:	f7ff fec0 	bl	22138 <z_nrf_rtc_timer_read>
	__asm__ volatile(
   223b8:	f04f 0320 	mov.w	r3, #32
   223bc:	f3ef 8c11 	mrs	ip, BASEPRI
   223c0:	f383 8812 	msr	BASEPRI_MAX, r3
   223c4:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   223c8:	4b18      	ldr	r3, [pc, #96]	; (2242c <rtc_nrf_isr+0xe8>)
   223ca:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
   223ce:	42b0      	cmp	r0, r6
   223d0:	eb71 0207 	sbcs.w	r2, r1, r7
   223d4:	f04f 0200 	mov.w	r2, #0
   223d8:	d320      	bcc.n	2241c <rtc_nrf_isr+0xd8>
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   223da:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   223de:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
   223e2:	e9d3 1500 	ldrd	r1, r5, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   223e6:	e9c3 8902 	strd	r8, r9, [r3, #8]
			cc_data[chan].callback = NULL;
   223ea:	601a      	str	r2, [r3, #0]
    p_reg->EVTENCLR = mask;
   223ec:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   223f0:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
	__asm__ volatile(
   223f4:	f38c 8811 	msr	BASEPRI, ip
   223f8:	f3bf 8f6f 	isb	sy
		if (handler) {
   223fc:	b121      	cbz	r1, 22408 <rtc_nrf_isr+0xc4>
			handler(chan, expire_time, user_context);
   223fe:	9500      	str	r5, [sp, #0]
   22400:	4632      	mov	r2, r6
   22402:	463b      	mov	r3, r7
   22404:	2000      	movs	r0, #0
   22406:	4788      	blx	r1
}
   22408:	b003      	add	sp, #12
   2240a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   2240e:	2300      	movs	r3, #0
   22410:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
   22414:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   22418:	2301      	movs	r3, #1
}
   2241a:	e7c6      	b.n	223aa <rtc_nrf_isr+0x66>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   2241c:	4611      	mov	r1, r2
   2241e:	e7e9      	b.n	223f4 <rtc_nrf_isr+0xb0>
   22420:	40011000 	.word	0x40011000
   22424:	20003730 	.word	0x20003730
   22428:	20003728 	.word	0x20003728
   2242c:	200022e8 	.word	0x200022e8

00022430 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   22430:	1c43      	adds	r3, r0, #1
{
   22432:	b513      	push	{r0, r1, r4, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   22434:	d021      	beq.n	2247a <sys_clock_set_timeout+0x4a>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   22436:	2801      	cmp	r0, #1
   22438:	dd21      	ble.n	2247e <sys_clock_set_timeout+0x4e>
   2243a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   2243e:	da20      	bge.n	22482 <sys_clock_set_timeout+0x52>
   22440:	1e44      	subs	r4, r0, #1
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   22442:	f7ff fe79 	bl	22138 <z_nrf_rtc_timer_read>
   22446:	4b10      	ldr	r3, [pc, #64]	; (22488 <sys_clock_set_timeout+0x58>)
   22448:	e9d3 1300 	ldrd	r1, r3, [r3]
   2244c:	1a40      	subs	r0, r0, r1
		ticks = 0;
   2244e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   22452:	bf28      	it	cs
   22454:	2400      	movcs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   22456:	3001      	adds	r0, #1
   22458:	1902      	adds	r2, r0, r4
	uint64_t target_time = cyc + last_count;
   2245a:	480c      	ldr	r0, [pc, #48]	; (2248c <sys_clock_set_timeout+0x5c>)
   2245c:	4282      	cmp	r2, r0
   2245e:	bf28      	it	cs
   22460:	4602      	movcs	r2, r0
   22462:	1852      	adds	r2, r2, r1
   22464:	f04f 0000 	mov.w	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   22468:	4909      	ldr	r1, [pc, #36]	; (22490 <sys_clock_set_timeout+0x60>)
   2246a:	9001      	str	r0, [sp, #4]
   2246c:	9100      	str	r1, [sp, #0]
   2246e:	f143 0300 	adc.w	r3, r3, #0
   22472:	f7ff fe83 	bl	2217c <compare_set>
}
   22476:	b002      	add	sp, #8
   22478:	bd10      	pop	{r4, pc}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   2247a:	4804      	ldr	r0, [pc, #16]	; (2248c <sys_clock_set_timeout+0x5c>)
   2247c:	e7e0      	b.n	22440 <sys_clock_set_timeout+0x10>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   2247e:	2400      	movs	r4, #0
   22480:	e7df      	b.n	22442 <sys_clock_set_timeout+0x12>
   22482:	4c02      	ldr	r4, [pc, #8]	; (2248c <sys_clock_set_timeout+0x5c>)
   22484:	e7dd      	b.n	22442 <sys_clock_set_timeout+0x12>
   22486:	bf00      	nop
   22488:	200022f8 	.word	0x200022f8
   2248c:	007fffff 	.word	0x007fffff
   22490:	00022065 	.word	0x00022065

00022494 <sys_clock_elapsed>:
{
   22494:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   22496:	f7ff fe4f 	bl	22138 <z_nrf_rtc_timer_read>
   2249a:	4b02      	ldr	r3, [pc, #8]	; (224a4 <sys_clock_elapsed+0x10>)
   2249c:	681b      	ldr	r3, [r3, #0]
}
   2249e:	1ac0      	subs	r0, r0, r3
   224a0:	bd08      	pop	{r3, pc}
   224a2:	bf00      	nop
   224a4:	200022f8 	.word	0x200022f8

000224a8 <nrf52_errata_16>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   224a8:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   224ac:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   224b0:	2a06      	cmp	r2, #6
   224b2:	d109      	bne.n	224c8 <nrf52_errata_16+0x20>
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   224b4:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
   224b8:	f3c3 1303 	ubfx	r3, r3, #4, #4
   224bc:	3b03      	subs	r3, #3
   224be:	2b04      	cmp	r3, #4
   224c0:	d802      	bhi.n	224c8 <nrf52_errata_16+0x20>
   224c2:	4a02      	ldr	r2, [pc, #8]	; (224cc <nrf52_errata_16+0x24>)
   224c4:	5cd0      	ldrb	r0, [r2, r3]
   224c6:	4770      	bx	lr
                    default:
                        return false;
                }
            }
        #endif
        return false;
   224c8:	2000      	movs	r0, #0
    #endif
}
   224ca:	4770      	bx	lr
   224cc:	00034dbc 	.word	0x00034dbc

000224d0 <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   224d0:	4a02      	ldr	r2, [pc, #8]	; (224dc <nvmc_wait+0xc>)
   224d2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   224d6:	2b00      	cmp	r3, #0
   224d8:	d0fb      	beq.n	224d2 <nvmc_wait+0x2>
}
   224da:	4770      	bx	lr
   224dc:	4001e000 	.word	0x4001e000

000224e0 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   224e0:	b510      	push	{r4, lr}
    #endif

    #if NRF52_ERRATA_12_ENABLE_WORKAROUND
        /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_12()){
   224e2:	f00a f99c 	bl	2c81e <nrf52_errata_108>
   224e6:	b140      	cbz	r0, 224fa <SystemInit+0x1a>
            *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
   224e8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   224ec:	4a90      	ldr	r2, [pc, #576]	; (22730 <SystemInit+0x250>)
   224ee:	f8d3 3324 	ldr.w	r3, [r3, #804]	; 0x324
   224f2:	f3c3 2304 	ubfx	r3, r3, #8, #5
   224f6:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    #endif

    #if NRF52_ERRATA_16_ENABLE_WORKAROUND
        /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_16()){
   224fa:	f7ff ffd5 	bl	224a8 <nrf52_errata_16>
   224fe:	b110      	cbz	r0, 22506 <SystemInit+0x26>
            *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   22500:	4b8c      	ldr	r3, [pc, #560]	; (22734 <SystemInit+0x254>)
   22502:	4a8d      	ldr	r2, [pc, #564]	; (22738 <SystemInit+0x258>)
   22504:	675a      	str	r2, [r3, #116]	; 0x74
    #endif

    #if NRF52_ERRATA_31_ENABLE_WORKAROUND
        /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_31()){
   22506:	f00a f98a 	bl	2c81e <nrf52_errata_108>
   2250a:	b148      	cbz	r0, 22520 <SystemInit+0x40>
            *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   2250c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22510:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   22514:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
   22518:	f3c3 3342 	ubfx	r3, r3, #13, #3
   2251c:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
    #endif

    #if NRF52_ERRATA_32_ENABLE_WORKAROUND
        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_32()){
   22520:	f7ff ffc2 	bl	224a8 <nrf52_errata_16>
   22524:	b130      	cbz	r0, 22534 <SystemInit+0x54>
            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   22526:	4a85      	ldr	r2, [pc, #532]	; (2273c <SystemInit+0x25c>)
   22528:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   2252c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   22530:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
   22534:	f00a f973 	bl	2c81e <nrf52_errata_108>
   22538:	b140      	cbz	r0, 2254c <SystemInit+0x6c>
            NRF_CLOCK->EVENTS_DONE = 0;
   2253a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2253e:	2200      	movs	r2, #0
   22540:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
   22544:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
   22548:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_37_ENABLE_WORKAROUND
        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_37()){
   2254c:	f7ff ffac 	bl	224a8 <nrf52_errata_16>
   22550:	b120      	cbz	r0, 2255c <SystemInit+0x7c>
            *(volatile uint32_t *)0x400005A0 = 0x3;
   22552:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22556:	2203      	movs	r2, #3
   22558:	f8c3 25a0 	str.w	r2, [r3, #1440]	; 0x5a0
    #endif

    #if NRF52_ERRATA_57_ENABLE_WORKAROUND
        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_57()){
   2255c:	f7ff ffa4 	bl	224a8 <nrf52_errata_16>
   22560:	b160      	cbz	r0, 2257c <SystemInit+0x9c>
            *(volatile uint32_t *)0x40005610 = 0x00000005;
   22562:	4b77      	ldr	r3, [pc, #476]	; (22740 <SystemInit+0x260>)
   22564:	2205      	movs	r2, #5
   22566:	f8c3 2610 	str.w	r2, [r3, #1552]	; 0x610
            *(volatile uint32_t *)0x40005688 = 0x00000001;
   2256a:	2201      	movs	r2, #1
   2256c:	f8c3 2688 	str.w	r2, [r3, #1672]	; 0x688
            *(volatile uint32_t *)0x40005618 = 0x00000000;
   22570:	2200      	movs	r2, #0
   22572:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
            *(volatile uint32_t *)0x40005614 = 0x0000003F;
   22576:	223f      	movs	r2, #63	; 0x3f
   22578:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   2257c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22580:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   22584:	1c51      	adds	r1, r2, #1
            {
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   22586:	bf09      	itett	eq
   22588:	f04f 4370 	moveq.w	r3, #4026531840	; 0xf0000000
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
   2258c:	f8d3 3134 	ldrne.w	r3, [r3, #308]	; 0x134
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   22590:	f893 2fe0 	ldrbeq.w	r2, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   22594:	f8d3 3fe8 	ldreq.w	r3, [r3, #4072]	; 0xfe8
   22598:	bf08      	it	eq
   2259a:	f3c3 1303 	ubfxeq	r3, r3, #4, #4
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   2259e:	2a06      	cmp	r2, #6
   225a0:	d14d      	bne.n	2263e <SystemInit+0x15e>
            {
                switch(var2)
   225a2:	3b03      	subs	r3, #3
   225a4:	2b04      	cmp	r3, #4
   225a6:	d803      	bhi.n	225b0 <SystemInit+0xd0>
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
   225a8:	4a66      	ldr	r2, [pc, #408]	; (22744 <SystemInit+0x264>)
   225aa:	5cd3      	ldrb	r3, [r2, r3]
   225ac:	2b00      	cmp	r3, #0
   225ae:	d046      	beq.n	2263e <SystemInit+0x15e>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   225b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   225b4:	4b64      	ldr	r3, [pc, #400]	; (22748 <SystemInit+0x268>)
   225b6:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   225ba:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   225be:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   225c2:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   225c6:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   225ca:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   225ce:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   225d2:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   225d6:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   225da:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   225de:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   225e2:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   225e6:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   225ea:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   225ee:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   225f2:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   225f6:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   225fa:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   225fe:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   22602:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   22606:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   2260a:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   2260e:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   22612:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   22616:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   2261a:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   2261e:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   22622:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   22626:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   2262a:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   2262e:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   22632:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   22636:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   2263a:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_108_ENABLE_WORKAROUND
        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_108()){
   2263e:	f00a f8ee 	bl	2c81e <nrf52_errata_108>
   22642:	b148      	cbz	r0, 22658 <SystemInit+0x178>
            *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
   22644:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22648:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   2264c:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   22650:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   22654:	f8c2 3ee4 	str.w	r3, [r2, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
   22658:	f00a f8e1 	bl	2c81e <nrf52_errata_108>
   2265c:	b148      	cbz	r0, 22672 <SystemInit+0x192>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   2265e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22662:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   22666:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   22668:	bf44      	itt	mi
   2266a:	f06f 0201 	mvnmi.w	r2, #1
   2266e:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   22672:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   22676:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   2267a:	2a06      	cmp	r2, #6
   2267c:	d126      	bne.n	226cc <SystemInit+0x1ec>
            {
                switch(var2)
   2267e:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
   22682:	3b03      	subs	r3, #3
   22684:	2b04      	cmp	r3, #4
   22686:	d802      	bhi.n	2268e <SystemInit+0x1ae>
    #endif

    #if NRF52_ERRATA_182_ENABLE_WORKAROUND
        /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_182()){
   22688:	4a30      	ldr	r2, [pc, #192]	; (2274c <SystemInit+0x26c>)
   2268a:	5cd3      	ldrb	r3, [r2, r3]
   2268c:	b163      	cbz	r3, 226a8 <SystemInit+0x1c8>
            *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
   2268e:	4a30      	ldr	r2, [pc, #192]	; (22750 <SystemInit+0x270>)
   22690:	f8d2 373c 	ldr.w	r3, [r2, #1852]	; 0x73c
   22694:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   22698:	f8c2 373c 	str.w	r3, [r2, #1852]	; 0x73c
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   2269c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   226a0:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   226a4:	2b06      	cmp	r3, #6
   226a6:	d111      	bne.n	226cc <SystemInit+0x1ec>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   226a8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   226ac:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
   226b0:	3b03      	subs	r3, #3
   226b2:	2b04      	cmp	r3, #4
   226b4:	d802      	bhi.n	226bc <SystemInit+0x1dc>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
   226b6:	4a27      	ldr	r2, [pc, #156]	; (22754 <SystemInit+0x274>)
   226b8:	5cd3      	ldrb	r3, [r2, r3]
   226ba:	b13b      	cbz	r3, 226cc <SystemInit+0x1ec>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
   226bc:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   226c0:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
   226c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   226c8:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   226cc:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   226d0:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   226d4:	2a00      	cmp	r2, #0
   226d6:	db03      	blt.n	226e0 <SystemInit+0x200>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   226d8:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   226dc:	2b00      	cmp	r3, #0
   226de:	da22      	bge.n	22726 <SystemInit+0x246>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   226e0:	491d      	ldr	r1, [pc, #116]	; (22758 <SystemInit+0x278>)
   226e2:	2301      	movs	r3, #1
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   226e4:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   226e8:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   226ec:	2415      	movs	r4, #21
    nvmc_wait();
   226ee:	f7ff feef 	bl	224d0 <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   226f2:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
   226f6:	f7ff feeb 	bl	224d0 <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
   226fa:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
   226fe:	f7ff fee7 	bl	224d0 <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   22702:	2300      	movs	r3, #0
   22704:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    nvmc_wait();
   22708:	f7ff fee2 	bl	224d0 <nvmc_wait>
  __ASM volatile ("dsb 0xF":::"memory");
   2270c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   22710:	490a      	ldr	r1, [pc, #40]	; (2273c <SystemInit+0x25c>)
   22712:	4b12      	ldr	r3, [pc, #72]	; (2275c <SystemInit+0x27c>)
   22714:	68ca      	ldr	r2, [r1, #12]
   22716:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   2271a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2271c:	60cb      	str	r3, [r1, #12]
   2271e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   22722:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   22724:	e7fd      	b.n	22722 <SystemInit+0x242>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   22726:	4b0e      	ldr	r3, [pc, #56]	; (22760 <SystemInit+0x280>)
   22728:	4a0e      	ldr	r2, [pc, #56]	; (22764 <SystemInit+0x284>)
   2272a:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   2272c:	bd10      	pop	{r4, pc}
   2272e:	bf00      	nop
   22730:	40013000 	.word	0x40013000
   22734:	4007c000 	.word	0x4007c000
   22738:	baadf00d 	.word	0xbaadf00d
   2273c:	e000ed00 	.word	0xe000ed00
   22740:	40005000 	.word	0x40005000
   22744:	00034dad 	.word	0x00034dad
   22748:	4000c000 	.word	0x4000c000
   2274c:	00034db2 	.word	0x00034db2
   22750:	40001000 	.word	0x40001000
   22754:	00034db7 	.word	0x00034db7
   22758:	4001e000 	.word	0x4001e000
   2275c:	05fa0004 	.word	0x05fa0004
   22760:	20000c78 	.word	0x20000c78
   22764:	03d09000 	.word	0x03d09000

00022768 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   22768:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   2276a:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   2276c:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   2276e:	fab2 f382 	clz	r3, r2
   22772:	f1c3 031f 	rsb	r3, r3, #31
        if (idx < 0) {
   22776:	1c5e      	adds	r6, r3, #1
        idx = 31 - NRF_CLZ(prev_mask);
   22778:	b2dc      	uxtb	r4, r3
        if (idx < 0) {
   2277a:	d014      	beq.n	227a6 <nrfx_flag32_alloc+0x3e>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   2277c:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask & ~NRFX_BIT(idx);
   22780:	fa05 f303 	lsl.w	r3, r5, r3
   22784:	ea22 0303 	bic.w	r3, r2, r3
   22788:	e850 6f00 	ldrex	r6, [r0]
   2278c:	4296      	cmp	r6, r2
   2278e:	d104      	bne.n	2279a <nrfx_flag32_alloc+0x32>
   22790:	e840 3c00 	strex	ip, r3, [r0]
   22794:	f1bc 0f00 	cmp.w	ip, #0
   22798:	d1f6      	bne.n	22788 <nrfx_flag32_alloc+0x20>
   2279a:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   2279e:	d1e5      	bne.n	2276c <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   227a0:	4802      	ldr	r0, [pc, #8]	; (227ac <nrfx_flag32_alloc+0x44>)
    *p_flag = idx;
   227a2:	700c      	strb	r4, [r1, #0]
}
   227a4:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   227a6:	4802      	ldr	r0, [pc, #8]	; (227b0 <nrfx_flag32_alloc+0x48>)
   227a8:	e7fc      	b.n	227a4 <nrfx_flag32_alloc+0x3c>
   227aa:	bf00      	nop
   227ac:	0bad0000 	.word	0x0bad0000
   227b0:	0bad0002 	.word	0x0bad0002

000227b4 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   227b4:	6803      	ldr	r3, [r0, #0]
   227b6:	40cb      	lsrs	r3, r1
   227b8:	07db      	lsls	r3, r3, #31
{
   227ba:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   227bc:	d415      	bmi.n	227ea <nrfx_flag32_free+0x36>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   227be:	2301      	movs	r3, #1
   227c0:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   227c4:	6803      	ldr	r3, [r0, #0]
   227c6:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask | NRFX_BIT(flag);
   227ca:	ea41 0203 	orr.w	r2, r1, r3
   227ce:	e850 4f00 	ldrex	r4, [r0]
   227d2:	429c      	cmp	r4, r3
   227d4:	d104      	bne.n	227e0 <nrfx_flag32_free+0x2c>
   227d6:	e840 2c00 	strex	ip, r2, [r0]
   227da:	f1bc 0f00 	cmp.w	ip, #0
   227de:	d1f6      	bne.n	227ce <nrfx_flag32_free+0x1a>
   227e0:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   227e4:	d1ee      	bne.n	227c4 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   227e6:	4802      	ldr	r0, [pc, #8]	; (227f0 <nrfx_flag32_free+0x3c>)
}
   227e8:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   227ea:	4802      	ldr	r0, [pc, #8]	; (227f4 <nrfx_flag32_free+0x40>)
   227ec:	e7fc      	b.n	227e8 <nrfx_flag32_free+0x34>
   227ee:	bf00      	nop
   227f0:	0bad0000 	.word	0x0bad0000
   227f4:	0bad0004 	.word	0x0bad0004

000227f8 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   227f8:	4b04      	ldr	r3, [pc, #16]	; (2280c <nrfx_clock_init+0x14>)
   227fa:	791a      	ldrb	r2, [r3, #4]
   227fc:	b922      	cbnz	r2, 22808 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   227fe:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   22800:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   22802:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   22804:	4802      	ldr	r0, [pc, #8]	; (22810 <nrfx_clock_init+0x18>)
   22806:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   22808:	4802      	ldr	r0, [pc, #8]	; (22814 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   2280a:	4770      	bx	lr
   2280c:	20003734 	.word	0x20003734
   22810:	0bad0000 	.word	0x0bad0000
   22814:	0bad000c 	.word	0x0bad000c

00022818 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
   22818:	b530      	push	{r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   2281a:	b110      	cbz	r0, 22822 <nrfx_clock_start+0xa>
   2281c:	2801      	cmp	r0, #1
   2281e:	d034      	beq.n	2288a <nrfx_clock_start+0x72>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   22820:	bd30      	pop	{r4, r5, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   22822:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22826:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   2282a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   2282e:	03c9      	lsls	r1, r1, #15
   22830:	d529      	bpl.n	22886 <nrfx_clock_start+0x6e>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   22832:	f002 0203 	and.w	r2, r2, #3
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   22836:	2a01      	cmp	r2, #1
   22838:	d125      	bne.n	22886 <nrfx_clock_start+0x6e>
    p_reg->LFCLKSRC = (uint32_t)(source);
   2283a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2283e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22842:	2200      	movs	r2, #0
   22844:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   22848:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
   2284c:	2202      	movs	r2, #2
   2284e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    core_debug = CoreDebug->DEMCR;
   22852:	4a13      	ldr	r2, [pc, #76]	; (228a0 <nrfx_clock_start+0x88>)
   22854:	f8d2 00fc 	ldr.w	r0, [r2, #252]	; 0xfc
    CoreDebug->DEMCR = core_debug | CoreDebug_DEMCR_TRCENA_Msk;
   22858:	f040 7380 	orr.w	r3, r0, #16777216	; 0x1000000
   2285c:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    dwt_ctrl = DWT->CTRL;
   22860:	4b10      	ldr	r3, [pc, #64]	; (228a4 <nrfx_clock_start+0x8c>)
   22862:	681c      	ldr	r4, [r3, #0]
    DWT->CTRL = dwt_ctrl | DWT_CTRL_CYCCNTENA_Msk;
   22864:	f044 0101 	orr.w	r1, r4, #1
   22868:	6019      	str	r1, [r3, #0]
    cyccnt_inital = DWT->CYCCNT;
   2286a:	685d      	ldr	r5, [r3, #4]
    while ((DWT->CYCCNT - cyccnt_inital) < ANOMALY_132_DELAY_CYCLES)
   2286c:	6859      	ldr	r1, [r3, #4]
   2286e:	1b49      	subs	r1, r1, r5
   22870:	f5b1 5f0a 	cmp.w	r1, #8832	; 0x2280
   22874:	d3fa      	bcc.n	2286c <nrfx_clock_start+0x54>
    DWT->CTRL = dwt_ctrl;
   22876:	601c      	str	r4, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   22878:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    CoreDebug->DEMCR = core_debug;
   2287c:	f8c2 00fc 	str.w	r0, [r2, #252]	; 0xfc
   22880:	2201      	movs	r2, #1
   22882:	609a      	str	r2, [r3, #8]
}
   22884:	e7cc      	b.n	22820 <nrfx_clock_start+0x8>
    p_reg->LFCLKSRC = (uint32_t)(source);
   22886:	2200      	movs	r2, #0
   22888:	e7d7      	b.n	2283a <nrfx_clock_start+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2288a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2288e:	2200      	movs	r2, #0
   22890:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   22894:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   22898:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2289c:	6018      	str	r0, [r3, #0]
}
   2289e:	e7bf      	b.n	22820 <nrfx_clock_start+0x8>
   228a0:	e000ed00 	.word	0xe000ed00
   228a4:	e0001000 	.word	0xe0001000

000228a8 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   228a8:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   228aa:	b110      	cbz	r0, 228b2 <nrfx_clock_stop+0xa>
   228ac:	2801      	cmp	r0, #1
   228ae:	d017      	beq.n	228e0 <nrfx_clock_stop+0x38>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   228b0:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   228b2:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
   228b6:	2302      	movs	r3, #2
   228b8:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   228bc:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
   228c0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   228c4:	2301      	movs	r3, #1
   228c6:	60e3      	str	r3, [r4, #12]
   228c8:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   228cc:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   228d0:	03db      	lsls	r3, r3, #15
   228d2:	d5ed      	bpl.n	228b0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   228d4:	2001      	movs	r0, #1
   228d6:	f009 ffb1 	bl	2c83c <nrfx_busy_wait>
   228da:	3d01      	subs	r5, #1
   228dc:	d1f6      	bne.n	228cc <nrfx_clock_stop+0x24>
   228de:	e7e7      	b.n	228b0 <nrfx_clock_stop+0x8>
    p_reg->INTENCLR = mask;
   228e0:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   228e4:	2300      	movs	r3, #0
    p_reg->INTENCLR = mask;
   228e6:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   228ea:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
   228ee:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   228f2:	6060      	str	r0, [r4, #4]
   228f4:	f242 7510 	movw	r5, #10000	; 0x2710
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   228f8:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   228fc:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
   22900:	03d2      	lsls	r2, r2, #15
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   22902:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   22906:	d505      	bpl.n	22914 <nrfx_clock_stop+0x6c>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   22908:	b123      	cbz	r3, 22914 <nrfx_clock_stop+0x6c>
   2290a:	2001      	movs	r0, #1
   2290c:	f009 ff96 	bl	2c83c <nrfx_busy_wait>
   22910:	3d01      	subs	r5, #1
   22912:	d1f1      	bne.n	228f8 <nrfx_clock_stop+0x50>
            m_clock_cb.hfclk_started = false;
   22914:	4b01      	ldr	r3, [pc, #4]	; (2291c <nrfx_clock_stop+0x74>)
   22916:	2200      	movs	r2, #0
   22918:	715a      	strb	r2, [r3, #5]
   2291a:	e7c9      	b.n	228b0 <nrfx_clock_stop+0x8>
   2291c:	20003734 	.word	0x20003734

00022920 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   22920:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   22924:	b510      	push	{r4, lr}
   22926:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   2292a:	b16a      	cbz	r2, 22948 <nrfx_power_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2292c:	2200      	movs	r2, #0
   2292e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   22932:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   22936:	2201      	movs	r2, #1
   22938:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
   2293c:	4b11      	ldr	r3, [pc, #68]	; (22984 <nrfx_power_clock_irq_handler+0x64>)
   2293e:	7958      	ldrb	r0, [r3, #5]
   22940:	b910      	cbnz	r0, 22948 <nrfx_power_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
   22942:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   22944:	681b      	ldr	r3, [r3, #0]
   22946:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   22948:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2294c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   22950:	b172      	cbz	r2, 22970 <nrfx_power_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22952:	2200      	movs	r2, #0
   22954:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   22958:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   2295c:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   22960:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   22964:	0792      	lsls	r2, r2, #30
   22966:	d104      	bne.n	22972 <nrfx_power_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
   22968:	2201      	movs	r2, #1
   2296a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2296e:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   22970:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   22972:	2202      	movs	r2, #2
   22974:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   22978:	4b02      	ldr	r3, [pc, #8]	; (22984 <nrfx_power_clock_irq_handler+0x64>)
}
   2297a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   2297e:	681b      	ldr	r3, [r3, #0]
   22980:	2001      	movs	r0, #1
   22982:	4718      	bx	r3
   22984:	20003734 	.word	0x20003734

00022988 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   22988:	4b03      	ldr	r3, [pc, #12]	; (22998 <pin_in_use_by_te+0x10>)
   2298a:	3008      	adds	r0, #8
   2298c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   22990:	f3c0 1040 	ubfx	r0, r0, #5, #1
   22994:	4770      	bx	lr
   22996:	bf00      	nop
   22998:	20000c7c 	.word	0x20000c7c

0002299c <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   2299c:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   2299e:	f100 0308 	add.w	r3, r0, #8
   229a2:	4c0c      	ldr	r4, [pc, #48]	; (229d4 <call_handler+0x38>)
   229a4:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
   229a8:	05da      	lsls	r2, r3, #23
{
   229aa:	4605      	mov	r5, r0
   229ac:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   229ae:	d507      	bpl.n	229c0 <call_handler+0x24>
   229b0:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   229b4:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   229b8:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   229bc:	6852      	ldr	r2, [r2, #4]
   229be:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   229c0:	68a3      	ldr	r3, [r4, #8]
   229c2:	b12b      	cbz	r3, 229d0 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   229c4:	68e2      	ldr	r2, [r4, #12]
   229c6:	4631      	mov	r1, r6
   229c8:	4628      	mov	r0, r5
    }
}
   229ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   229ce:	4718      	bx	r3
}
   229d0:	bd70      	pop	{r4, r5, r6, pc}
   229d2:	bf00      	nop
   229d4:	20000c7c 	.word	0x20000c7c

000229d8 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   229d8:	4a12      	ldr	r2, [pc, #72]	; (22a24 <release_handler+0x4c>)
   229da:	3008      	adds	r0, #8
{
   229dc:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   229de:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
   229e2:	05d9      	lsls	r1, r3, #23
   229e4:	d51b      	bpl.n	22a1e <release_handler+0x46>
   229e6:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   229ea:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   229ee:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   229f2:	f102 0410 	add.w	r4, r2, #16
   229f6:	2000      	movs	r0, #0
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   229f8:	f834 3b02 	ldrh.w	r3, [r4], #2
   229fc:	f413 7f80 	tst.w	r3, #256	; 0x100
   22a00:	d003      	beq.n	22a0a <release_handler+0x32>
   22a02:	f3c3 2343 	ubfx	r3, r3, #9, #4
   22a06:	4299      	cmp	r1, r3
   22a08:	d009      	beq.n	22a1e <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   22a0a:	3001      	adds	r0, #1
   22a0c:	2820      	cmp	r0, #32
   22a0e:	d1f3      	bne.n	229f8 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   22a10:	2300      	movs	r3, #0
   22a12:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   22a16:	4804      	ldr	r0, [pc, #16]	; (22a28 <release_handler+0x50>)
}
   22a18:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   22a1a:	f7ff becb 	b.w	227b4 <nrfx_flag32_free>
}
   22a1e:	bc10      	pop	{r4}
   22a20:	4770      	bx	lr
   22a22:	bf00      	nop
   22a24:	20000c7c 	.word	0x20000c7c
   22a28:	20000cd0 	.word	0x20000cd0

00022a2c <pin_handler_trigger_uninit>:
{
   22a2c:	b538      	push	{r3, r4, r5, lr}
   22a2e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   22a30:	f7ff ffaa 	bl	22988 <pin_in_use_by_te>
   22a34:	4c09      	ldr	r4, [pc, #36]	; (22a5c <pin_handler_trigger_uninit+0x30>)
   22a36:	f102 0508 	add.w	r5, r2, #8
   22a3a:	b140      	cbz	r0, 22a4e <pin_handler_trigger_uninit+0x22>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   22a3c:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   22a40:	4907      	ldr	r1, [pc, #28]	; (22a60 <pin_handler_trigger_uninit+0x34>)
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   22a42:	0b5b      	lsrs	r3, r3, #13
   22a44:	f503 73a2 	add.w	r3, r3, #324	; 0x144
   22a48:	2000      	movs	r0, #0
   22a4a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    release_handler(pin);
   22a4e:	4610      	mov	r0, r2
   22a50:	f7ff ffc2 	bl	229d8 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   22a54:	2300      	movs	r3, #0
   22a56:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   22a5a:	bd38      	pop	{r3, r4, r5, pc}
   22a5c:	20000c7c 	.word	0x20000c7c
   22a60:	40006000 	.word	0x40006000

00022a64 <nrfx_gpiote_input_configure>:
{
   22a64:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   22a68:	4604      	mov	r4, r0
   22a6a:	461e      	mov	r6, r3
    if (p_input_config)
   22a6c:	b309      	cbz	r1, 22ab2 <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22a6e:	4f4d      	ldr	r7, [pc, #308]	; (22ba4 <nrfx_gpiote_input_configure+0x140>)
   22a70:	f100 0808 	add.w	r8, r0, #8
   22a74:	f837 5018 	ldrh.w	r5, [r7, r8, lsl #1]
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   22a78:	07ab      	lsls	r3, r5, #30
   22a7a:	d506      	bpl.n	22a8a <nrfx_gpiote_input_configure+0x26>
   22a7c:	f7ff ff84 	bl	22988 <pin_in_use_by_te>
        if (pin_is_task_output(pin))
   22a80:	b118      	cbz	r0, 22a8a <nrfx_gpiote_input_configure+0x26>
            return NRFX_ERROR_INVALID_PARAM;
   22a82:	4849      	ldr	r0, [pc, #292]	; (22ba8 <nrfx_gpiote_input_configure+0x144>)
}
   22a84:	b002      	add	sp, #8
   22a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *p_pin = pin_number & 0x1F;
   22a8a:	f004 001f 	and.w	r0, r4, #31
   22a8e:	0080      	lsls	r0, r0, #2
   22a90:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   22a94:	7809      	ldrb	r1, [r1, #0]
    uint32_t cnf = reg->PIN_CNF[pin_number];
   22a96:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   22a9a:	f025 0502 	bic.w	r5, r5, #2
    cnf &= ~to_update;
   22a9e:	f023 030f 	bic.w	r3, r3, #15
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   22aa2:	f045 0501 	orr.w	r5, r5, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   22aa6:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
   22aaa:	f827 5018 	strh.w	r5, [r7, r8, lsl #1]
    reg->PIN_CNF[pin_number] = cnf;
   22aae:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
    if (p_trigger_config)
   22ab2:	b192      	cbz	r2, 22ada <nrfx_gpiote_input_configure+0x76>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22ab4:	4b3b      	ldr	r3, [pc, #236]	; (22ba4 <nrfx_gpiote_input_configure+0x140>)
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   22ab6:	7815      	ldrb	r5, [r2, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   22ab8:	6852      	ldr	r2, [r2, #4]
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22aba:	f104 0008 	add.w	r0, r4, #8
   22abe:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
        if (pin_is_output(pin))
   22ac2:	078f      	lsls	r7, r1, #30
   22ac4:	d50c      	bpl.n	22ae0 <nrfx_gpiote_input_configure+0x7c>
            if (use_evt)
   22ac6:	2a00      	cmp	r2, #0
   22ac8:	d1db      	bne.n	22a82 <nrfx_gpiote_input_configure+0x1e>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   22aca:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
   22ace:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   22ad2:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
   22ad6:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    if (p_handler_config)
   22ada:	bbce      	cbnz	r6, 22b50 <nrfx_gpiote_input_configure+0xec>
    return NRFX_SUCCESS;
   22adc:	4833      	ldr	r0, [pc, #204]	; (22bac <nrfx_gpiote_input_configure+0x148>)
   22ade:	e7d1      	b.n	22a84 <nrfx_gpiote_input_configure+0x20>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   22ae0:	f021 0120 	bic.w	r1, r1, #32
   22ae4:	04c9      	lsls	r1, r1, #19
   22ae6:	0cc9      	lsrs	r1, r1, #19
   22ae8:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
            if (use_evt)
   22aec:	2a00      	cmp	r2, #0
   22aee:	d0ec      	beq.n	22aca <nrfx_gpiote_input_configure+0x66>
                if (!edge)
   22af0:	2d03      	cmp	r5, #3
   22af2:	d8c6      	bhi.n	22a82 <nrfx_gpiote_input_configure+0x1e>
                uint8_t ch = *p_trigger_config->p_in_channel;
   22af4:	7817      	ldrb	r7, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   22af6:	b92d      	cbnz	r5, 22b04 <nrfx_gpiote_input_configure+0xa0>
   22af8:	4a2d      	ldr	r2, [pc, #180]	; (22bb0 <nrfx_gpiote_input_configure+0x14c>)
   22afa:	f507 71a2 	add.w	r1, r7, #324	; 0x144
   22afe:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
   22b02:	e7e2      	b.n	22aca <nrfx_gpiote_input_configure+0x66>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   22b04:	00ba      	lsls	r2, r7, #2
   22b06:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   22b0a:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   22b0e:	ea41 3147 	orr.w	r1, r1, r7, lsl #13
   22b12:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
   22b16:	f02c 0c03 	bic.w	ip, ip, #3
   22b1a:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   22b1e:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
   22b22:	f42c 3c47 	bic.w	ip, ip, #203776	; 0x31c00
   22b26:	f42c 7c40 	bic.w	ip, ip, #768	; 0x300
   22b2a:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   22b2e:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
   22b32:	ea4f 2c04 	mov.w	ip, r4, lsl #8
   22b36:	f40c 5cf8 	and.w	ip, ip, #7936	; 0x1f00
   22b3a:	ea4e 4e05 	orr.w	lr, lr, r5, lsl #16
   22b3e:	ea4c 0c0e 	orr.w	ip, ip, lr
   22b42:	f041 0120 	orr.w	r1, r1, #32
   22b46:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
   22b4a:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
   22b4e:	e7bc      	b.n	22aca <nrfx_gpiote_input_configure+0x66>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   22b50:	e9d6 7600 	ldrd	r7, r6, [r6]
    release_handler(pin);
   22b54:	4620      	mov	r0, r4
   22b56:	f7ff ff3f 	bl	229d8 <release_handler>
    if (!handler)
   22b5a:	2f00      	cmp	r7, #0
   22b5c:	d0be      	beq.n	22adc <nrfx_gpiote_input_configure+0x78>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   22b5e:	4d11      	ldr	r5, [pc, #68]	; (22ba4 <nrfx_gpiote_input_configure+0x140>)
   22b60:	682b      	ldr	r3, [r5, #0]
   22b62:	429f      	cmp	r7, r3
   22b64:	d104      	bne.n	22b70 <nrfx_gpiote_input_configure+0x10c>
   22b66:	686b      	ldr	r3, [r5, #4]
   22b68:	429e      	cmp	r6, r3
   22b6a:	d101      	bne.n	22b70 <nrfx_gpiote_input_configure+0x10c>
   22b6c:	2200      	movs	r2, #0
   22b6e:	e009      	b.n	22b84 <nrfx_gpiote_input_configure+0x120>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   22b70:	4810      	ldr	r0, [pc, #64]	; (22bb4 <nrfx_gpiote_input_configure+0x150>)
   22b72:	f10d 0107 	add.w	r1, sp, #7
   22b76:	f7ff fdf7 	bl	22768 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   22b7a:	4b0c      	ldr	r3, [pc, #48]	; (22bac <nrfx_gpiote_input_configure+0x148>)
   22b7c:	4298      	cmp	r0, r3
   22b7e:	d181      	bne.n	22a84 <nrfx_gpiote_input_configure+0x20>
        handler_id = (int32_t)id;
   22b80:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].handler = handler;
   22b84:	f845 7032 	str.w	r7, [r5, r2, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
   22b88:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   22b8c:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   22b8e:	605e      	str	r6, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   22b90:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
   22b94:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   22b98:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   22b9c:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   22ba0:	e79c      	b.n	22adc <nrfx_gpiote_input_configure+0x78>
   22ba2:	bf00      	nop
   22ba4:	20000c7c 	.word	0x20000c7c
   22ba8:	0bad0004 	.word	0x0bad0004
   22bac:	0bad0000 	.word	0x0bad0000
   22bb0:	40006000 	.word	0x40006000
   22bb4:	20000cd0 	.word	0x20000cd0

00022bb8 <nrfx_gpiote_output_configure>:
{
   22bb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22bba:	4604      	mov	r4, r0
    if (p_config)
   22bbc:	b371      	cbz	r1, 22c1c <nrfx_gpiote_output_configure+0x64>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22bbe:	4e37      	ldr	r6, [pc, #220]	; (22c9c <nrfx_gpiote_output_configure+0xe4>)
   22bc0:	f100 0708 	add.w	r7, r0, #8
   22bc4:	f836 5017 	ldrh.w	r5, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   22bc8:	07ab      	lsls	r3, r5, #30
   22bca:	d404      	bmi.n	22bd6 <nrfx_gpiote_output_configure+0x1e>
   22bcc:	f7ff fedc 	bl	22988 <pin_in_use_by_te>
   22bd0:	b108      	cbz	r0, 22bd6 <nrfx_gpiote_output_configure+0x1e>
    return NRFX_SUCCESS;
   22bd2:	4833      	ldr	r0, [pc, #204]	; (22ca0 <nrfx_gpiote_output_configure+0xe8>)
}
   22bd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   22bd6:	f015 0f1c 	tst.w	r5, #28
   22bda:	784b      	ldrb	r3, [r1, #1]
   22bdc:	d001      	beq.n	22be2 <nrfx_gpiote_output_configure+0x2a>
   22bde:	2b01      	cmp	r3, #1
   22be0:	d0f7      	beq.n	22bd2 <nrfx_gpiote_output_configure+0x1a>
    *p_pin = pin_number & 0x1F;
   22be2:	f004 001f 	and.w	r0, r4, #31
   22be6:	0080      	lsls	r0, r0, #2
   22be8:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   22bec:	f891 e000 	ldrb.w	lr, [r1]
    uint32_t cnf = reg->PIN_CNF[pin_number];
   22bf0:	f8d0 c700 	ldr.w	ip, [r0, #1792]	; 0x700
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   22bf4:	7889      	ldrb	r1, [r1, #2]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   22bf6:	005b      	lsls	r3, r3, #1
    cnf &= ~to_update;
   22bf8:	f42c 6ce1 	bic.w	ip, ip, #1800	; 0x708
   22bfc:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
   22c00:	f02c 0c07 	bic.w	ip, ip, #7
   22c04:	ea43 030c 	orr.w	r3, r3, ip
   22c08:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   22c0c:	f045 0503 	orr.w	r5, r5, #3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   22c10:	f043 0301 	orr.w	r3, r3, #1
   22c14:	f826 5017 	strh.w	r5, [r6, r7, lsl #1]
    reg->PIN_CNF[pin_number] = cnf;
   22c18:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
    if (p_task_config)
   22c1c:	b90a      	cbnz	r2, 22c22 <nrfx_gpiote_output_configure+0x6a>
    return NRFX_SUCCESS;
   22c1e:	4821      	ldr	r0, [pc, #132]	; (22ca4 <nrfx_gpiote_output_configure+0xec>)
   22c20:	e7d8      	b.n	22bd4 <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22c22:	4e1e      	ldr	r6, [pc, #120]	; (22c9c <nrfx_gpiote_output_configure+0xe4>)
   22c24:	f104 0708 	add.w	r7, r4, #8
   22c28:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
   22c2c:	0783      	lsls	r3, r0, #30
   22c2e:	d5d0      	bpl.n	22bd2 <nrfx_gpiote_output_configure+0x1a>
        uint32_t ch = p_task_config->task_ch;
   22c30:	f892 c000 	ldrb.w	ip, [r2]
    p_reg->CONFIG[idx] = 0;
   22c34:	4661      	mov	r1, ip
   22c36:	0089      	lsls	r1, r1, #2
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   22c38:	f020 0020 	bic.w	r0, r0, #32
   22c3c:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   22c40:	04c0      	lsls	r0, r0, #19
   22c42:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
   22c46:	0cc0      	lsrs	r0, r0, #19
   22c48:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   22c4c:	2300      	movs	r3, #0
   22c4e:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   22c52:	7855      	ldrb	r5, [r2, #1]
   22c54:	2d00      	cmp	r5, #0
   22c56:	d0e2      	beq.n	22c1e <nrfx_gpiote_output_configure+0x66>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   22c58:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   22c5c:	7892      	ldrb	r2, [r2, #2]
   22c5e:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   22c62:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   22c66:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   22c6a:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   22c6e:	0223      	lsls	r3, r4, #8
   22c70:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   22c74:	042d      	lsls	r5, r5, #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   22c76:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   22c7a:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   22c7e:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   22c80:	432b      	orrs	r3, r5
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   22c82:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   22c86:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   22c8a:	4313      	orrs	r3, r2
   22c8c:	f040 0020 	orr.w	r0, r0, #32
   22c90:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   22c94:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   22c98:	e7c1      	b.n	22c1e <nrfx_gpiote_output_configure+0x66>
   22c9a:	bf00      	nop
   22c9c:	20000c7c 	.word	0x20000c7c
   22ca0:	0bad0004 	.word	0x0bad0004
   22ca4:	0bad0000 	.word	0x0bad0000

00022ca8 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   22ca8:	4b01      	ldr	r3, [pc, #4]	; (22cb0 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   22caa:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   22cae:	4770      	bx	lr
   22cb0:	20000c7c 	.word	0x20000c7c

00022cb4 <nrfx_gpiote_channel_get>:
{
   22cb4:	b508      	push	{r3, lr}
   22cb6:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   22cb8:	f7ff fe66 	bl	22988 <pin_in_use_by_te>
   22cbc:	b138      	cbz	r0, 22cce <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   22cbe:	4b05      	ldr	r3, [pc, #20]	; (22cd4 <nrfx_gpiote_channel_get+0x20>)
        return NRFX_SUCCESS;
   22cc0:	4805      	ldr	r0, [pc, #20]	; (22cd8 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   22cc2:	3208      	adds	r2, #8
   22cc4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   22cc8:	0b5b      	lsrs	r3, r3, #13
   22cca:	700b      	strb	r3, [r1, #0]
}
   22ccc:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
   22cce:	4803      	ldr	r0, [pc, #12]	; (22cdc <nrfx_gpiote_channel_get+0x28>)
   22cd0:	e7fc      	b.n	22ccc <nrfx_gpiote_channel_get+0x18>
   22cd2:	bf00      	nop
   22cd4:	20000c7c 	.word	0x20000c7c
   22cd8:	0bad0000 	.word	0x0bad0000
   22cdc:	0bad0004 	.word	0x0bad0004

00022ce0 <nrfx_gpiote_init>:
{
   22ce0:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   22ce2:	4c0f      	ldr	r4, [pc, #60]	; (22d20 <nrfx_gpiote_init+0x40>)
   22ce4:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   22ce8:	b9bd      	cbnz	r5, 22d1a <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   22cea:	2240      	movs	r2, #64	; 0x40
   22cec:	4629      	mov	r1, r5
   22cee:	f104 0010 	add.w	r0, r4, #16
   22cf2:	f004 fdc8 	bl	27886 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   22cf6:	2006      	movs	r0, #6
   22cf8:	f7e1 fcae 	bl	4658 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   22cfc:	4b09      	ldr	r3, [pc, #36]	; (22d24 <nrfx_gpiote_init+0x44>)
    return err_code;
   22cfe:	480a      	ldr	r0, [pc, #40]	; (22d28 <nrfx_gpiote_init+0x48>)
   22d00:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
   22d04:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   22d08:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   22d0c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   22d10:	2301      	movs	r3, #1
   22d12:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   22d16:	6563      	str	r3, [r4, #84]	; 0x54
}
   22d18:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   22d1a:	4804      	ldr	r0, [pc, #16]	; (22d2c <nrfx_gpiote_init+0x4c>)
   22d1c:	e7fc      	b.n	22d18 <nrfx_gpiote_init+0x38>
   22d1e:	bf00      	nop
   22d20:	20000c7c 	.word	0x20000c7c
   22d24:	40006000 	.word	0x40006000
   22d28:	0bad0000 	.word	0x0bad0000
   22d2c:	0bad0005 	.word	0x0bad0005

00022d30 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   22d30:	4b03      	ldr	r3, [pc, #12]	; (22d40 <nrfx_gpiote_is_init+0x10>)
   22d32:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   22d36:	3800      	subs	r0, #0
   22d38:	bf18      	it	ne
   22d3a:	2001      	movne	r0, #1
   22d3c:	4770      	bx	lr
   22d3e:	bf00      	nop
   22d40:	20000c7c 	.word	0x20000c7c

00022d44 <nrfx_gpiote_channel_free>:
{
   22d44:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   22d46:	4801      	ldr	r0, [pc, #4]	; (22d4c <nrfx_gpiote_channel_free+0x8>)
   22d48:	f7ff bd34 	b.w	227b4 <nrfx_flag32_free>
   22d4c:	20000ccc 	.word	0x20000ccc

00022d50 <nrfx_gpiote_channel_alloc>:
{
   22d50:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   22d52:	4801      	ldr	r0, [pc, #4]	; (22d58 <nrfx_gpiote_channel_alloc+0x8>)
   22d54:	f7ff bd08 	b.w	22768 <nrfx_flag32_alloc>
   22d58:	20000ccc 	.word	0x20000ccc

00022d5c <nrfx_gpiote_trigger_enable>:
{
   22d5c:	b510      	push	{r4, lr}
   22d5e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   22d60:	f7ff fe12 	bl	22988 <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22d64:	f102 0408 	add.w	r4, r2, #8
   22d68:	4b1c      	ldr	r3, [pc, #112]	; (22ddc <nrfx_gpiote_trigger_enable+0x80>)
   22d6a:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   22d6e:	b1e0      	cbz	r0, 22daa <nrfx_gpiote_trigger_enable+0x4e>
   22d70:	f013 0402 	ands.w	r4, r3, #2
   22d74:	d119      	bne.n	22daa <nrfx_gpiote_trigger_enable+0x4e>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   22d76:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   22d78:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
   22d7a:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
   22d7e:	f500 40c2 	add.w	r0, r0, #24832	; 0x6100
   22d82:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   22d86:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   22d8a:	6004      	str	r4, [r0, #0]
   22d8c:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   22d8e:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   22d92:	f040 0001 	orr.w	r0, r0, #1
   22d96:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   22d9a:	b129      	cbz	r1, 22da8 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   22d9c:	2201      	movs	r2, #1
   22d9e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   22da2:	4a0f      	ldr	r2, [pc, #60]	; (22de0 <nrfx_gpiote_trigger_enable+0x84>)
   22da4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   22da8:	bd10      	pop	{r4, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   22daa:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   22dae:	2b04      	cmp	r3, #4
   22db0:	d010      	beq.n	22dd4 <nrfx_gpiote_trigger_enable+0x78>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   22db2:	2b05      	cmp	r3, #5
   22db4:	d010      	beq.n	22dd8 <nrfx_gpiote_trigger_enable+0x7c>
    return p_reg->IN;
   22db6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   22dba:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
    *p_pin = pin_number & 0x1F;
   22dbe:	f002 031f 	and.w	r3, r2, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22dc2:	40d9      	lsrs	r1, r3
   22dc4:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   22dc8:	3102      	adds	r1, #2
}
   22dca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   22dce:	4610      	mov	r0, r2
   22dd0:	f009 bd40 	b.w	2c854 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   22dd4:	2103      	movs	r1, #3
   22dd6:	e7f8      	b.n	22dca <nrfx_gpiote_trigger_enable+0x6e>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   22dd8:	2102      	movs	r1, #2
   22dda:	e7f6      	b.n	22dca <nrfx_gpiote_trigger_enable+0x6e>
   22ddc:	20000c7c 	.word	0x20000c7c
   22de0:	40006000 	.word	0x40006000

00022de4 <nrfx_gpiote_trigger_disable>:
{
   22de4:	b508      	push	{r3, lr}
   22de6:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   22de8:	f7ff fdce 	bl	22988 <pin_in_use_by_te>
   22dec:	b1c0      	cbz	r0, 22e20 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   22dee:	f102 0108 	add.w	r1, r2, #8
   22df2:	4b0e      	ldr	r3, [pc, #56]	; (22e2c <nrfx_gpiote_trigger_disable+0x48>)
   22df4:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   22df8:	0799      	lsls	r1, r3, #30
   22dfa:	d411      	bmi.n	22e20 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   22dfc:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   22dfe:	2201      	movs	r2, #1
   22e00:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   22e02:	009b      	lsls	r3, r3, #2
   22e04:	490a      	ldr	r1, [pc, #40]	; (22e30 <nrfx_gpiote_trigger_disable+0x4c>)
   22e06:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22e0a:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
   22e0e:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   22e12:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   22e16:	f022 0203 	bic.w	r2, r2, #3
   22e1a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   22e1e:	bd08      	pop	{r3, pc}
   22e20:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   22e24:	2100      	movs	r1, #0
   22e26:	4610      	mov	r0, r2
   22e28:	f009 bd14 	b.w	2c854 <nrf_gpio_cfg_sense_set>
   22e2c:	20000c7c 	.word	0x20000c7c
   22e30:	40006000 	.word	0x40006000

00022e34 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   22e34:	4b0d      	ldr	r3, [pc, #52]	; (22e6c <nrfx_gpiote_pin_uninit+0x38>)
   22e36:	f100 0208 	add.w	r2, r0, #8
{
   22e3a:	b510      	push	{r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   22e3c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (!pin_in_use(pin))
   22e40:	07db      	lsls	r3, r3, #31
{
   22e42:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   22e44:	d50f      	bpl.n	22e66 <nrfx_gpiote_pin_uninit+0x32>
    nrfx_gpiote_trigger_disable(pin);
   22e46:	f7ff ffcd 	bl	22de4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   22e4a:	4620      	mov	r0, r4
    *p_pin = pin_number & 0x1F;
   22e4c:	f004 041f 	and.w	r4, r4, #31
   22e50:	f7ff fdec 	bl	22a2c <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   22e54:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
   22e58:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   22e5c:	2202      	movs	r2, #2
   22e5e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   22e62:	4803      	ldr	r0, [pc, #12]	; (22e70 <nrfx_gpiote_pin_uninit+0x3c>)
}
   22e64:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   22e66:	4803      	ldr	r0, [pc, #12]	; (22e74 <nrfx_gpiote_pin_uninit+0x40>)
   22e68:	e7fc      	b.n	22e64 <nrfx_gpiote_pin_uninit+0x30>
   22e6a:	bf00      	nop
   22e6c:	20000c7c 	.word	0x20000c7c
   22e70:	0bad0000 	.word	0x0bad0000
   22e74:	0bad0004 	.word	0x0bad0004

00022e78 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   22e78:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22e7c:	4b4e      	ldr	r3, [pc, #312]	; (22fb8 <nrfx_gpiote_irq_handler+0x140>)
    return p_reg->INTENSET & mask;
   22e7e:	484f      	ldr	r0, [pc, #316]	; (22fbc <nrfx_gpiote_irq_handler+0x144>)
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   22e80:	494f      	ldr	r1, [pc, #316]	; (22fc0 <nrfx_gpiote_irq_handler+0x148>)
    uint32_t status = 0;
   22e82:	2500      	movs	r5, #0
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   22e84:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   22e86:	462c      	mov	r4, r5
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e88:	681e      	ldr	r6, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   22e8a:	b136      	cbz	r6, 22e9a <nrfx_gpiote_irq_handler+0x22>
    return p_reg->INTENSET & mask;
   22e8c:	f8d0 6304 	ldr.w	r6, [r0, #772]	; 0x304
   22e90:	4216      	tst	r6, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   22e92:	bf1e      	ittt	ne
   22e94:	601c      	strne	r4, [r3, #0]
   22e96:	681e      	ldrne	r6, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   22e98:	4315      	orrne	r5, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   22e9a:	3304      	adds	r3, #4
   22e9c:	428b      	cmp	r3, r1
        }
        mask <<= 1;
   22e9e:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   22ea2:	d1f1      	bne.n	22e88 <nrfx_gpiote_irq_handler+0x10>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22ea4:	4b45      	ldr	r3, [pc, #276]	; (22fbc <nrfx_gpiote_irq_handler+0x144>)
   22ea6:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   22eaa:	b1bb      	cbz	r3, 22edc <nrfx_gpiote_irq_handler+0x64>
        *p_masks = gpio_regs[i]->LATCH;
   22eac:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
   22eb0:	f8d6 3520 	ldr.w	r3, [r6, #1312]	; 0x520
   22eb4:	9301      	str	r3, [sp, #4]
        gpio_regs[i]->LATCH = *p_masks;
   22eb6:	f8c6 3520 	str.w	r3, [r6, #1312]	; 0x520
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   22eba:	af01      	add	r7, sp, #4
   22ebc:	f04f 0801 	mov.w	r8, #1
            while (latch[i])
   22ec0:	9c01      	ldr	r4, [sp, #4]
   22ec2:	b96c      	cbnz	r4, 22ee0 <nrfx_gpiote_irq_handler+0x68>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   22ec4:	4b3d      	ldr	r3, [pc, #244]	; (22fbc <nrfx_gpiote_irq_handler+0x144>)
   22ec6:	f8c3 417c 	str.w	r4, [r3, #380]	; 0x17c
   22eca:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
   22ece:	f8d6 3520 	ldr.w	r3, [r6, #1312]	; 0x520
   22ed2:	9301      	str	r3, [sp, #4]
        gpio_regs[i]->LATCH = *p_masks;
   22ed4:	f8c6 3520 	str.w	r3, [r6, #1312]	; 0x520
        if (latch[port_idx])
   22ed8:	2b00      	cmp	r3, #0
   22eda:	d1ee      	bne.n	22eba <nrfx_gpiote_irq_handler+0x42>
        mask &= ~NRFX_BIT(ch);
   22edc:	2401      	movs	r4, #1
   22ede:	e066      	b.n	22fae <nrfx_gpiote_irq_handler+0x136>
                uint32_t pin = NRF_CTZ(latch[i]);
   22ee0:	fa94 f4a4 	rbit	r4, r4
   22ee4:	fab4 f484 	clz	r4, r4
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   22ee8:	4a36      	ldr	r2, [pc, #216]	; (22fc4 <nrfx_gpiote_irq_handler+0x14c>)
   22eea:	f104 0308 	add.w	r3, r4, #8
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   22eee:	08e0      	lsrs	r0, r4, #3
   22ef0:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    bit = BITMASK_RELBIT_GET(bit);
   22ef4:	f004 0307 	and.w	r3, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   22ef8:	fa08 f203 	lsl.w	r2, r8, r3
   22efc:	5c3b      	ldrb	r3, [r7, r0]
   22efe:	ea23 0302 	bic.w	r3, r3, r2
   22f02:	543b      	strb	r3, [r7, r0]
   22f04:	00a3      	lsls	r3, r4, #2
   22f06:	f103 49a0 	add.w	r9, r3, #1342177280	; 0x50000000
   22f0a:	f3c1 0a82 	ubfx	sl, r1, #2, #3
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   22f0e:	f8d9 2700 	ldr.w	r2, [r9, #1792]	; 0x700
    if (is_level(trigger))
   22f12:	06cb      	lsls	r3, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   22f14:	46d3      	mov	fp, sl
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   22f16:	f3c2 4201 	ubfx	r2, r2, #16, #2
    if (is_level(trigger))
   22f1a:	d518      	bpl.n	22f4e <nrfx_gpiote_irq_handler+0xd6>
        call_handler(pin, trigger);
   22f1c:	4659      	mov	r1, fp
   22f1e:	4620      	mov	r0, r4
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   22f20:	fa5f fa82 	uxtb.w	sl, r2
   22f24:	f7ff fd3a 	bl	2299c <call_handler>
   22f28:	f8d9 3700 	ldr.w	r3, [r9, #1792]	; 0x700
        if (nrf_gpio_pin_sense_get(pin) == sense)
   22f2c:	f3c3 4301 	ubfx	r3, r3, #16, #2
   22f30:	459a      	cmp	sl, r3
   22f32:	d107      	bne.n	22f44 <nrfx_gpiote_irq_handler+0xcc>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   22f34:	2100      	movs	r1, #0
   22f36:	4620      	mov	r0, r4
   22f38:	f009 fc8c 	bl	2c854 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   22f3c:	4651      	mov	r1, sl
   22f3e:	4620      	mov	r0, r4
   22f40:	f009 fc88 	bl	2c854 <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   22f44:	fa08 f404 	lsl.w	r4, r8, r4
   22f48:	f8c6 4520 	str.w	r4, [r6, #1312]	; 0x520
}
   22f4c:	e7b8      	b.n	22ec0 <nrfx_gpiote_irq_handler+0x48>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   22f4e:	2a02      	cmp	r2, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   22f50:	bf0c      	ite	eq
   22f52:	2103      	moveq	r1, #3
   22f54:	2102      	movne	r1, #2
   22f56:	4620      	mov	r0, r4
   22f58:	f009 fc7c 	bl	2c854 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   22f5c:	f1ba 0f03 	cmp.w	sl, #3
   22f60:	d004      	beq.n	22f6c <nrfx_gpiote_irq_handler+0xf4>
   22f62:	2a02      	cmp	r2, #2
   22f64:	d107      	bne.n	22f76 <nrfx_gpiote_irq_handler+0xfe>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   22f66:	f1ba 0f01 	cmp.w	sl, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   22f6a:	d1eb      	bne.n	22f44 <nrfx_gpiote_irq_handler+0xcc>
            call_handler(pin, trigger);
   22f6c:	4659      	mov	r1, fp
   22f6e:	4620      	mov	r0, r4
   22f70:	f7ff fd14 	bl	2299c <call_handler>
   22f74:	e7e6      	b.n	22f44 <nrfx_gpiote_irq_handler+0xcc>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   22f76:	2a03      	cmp	r2, #3
   22f78:	d1e4      	bne.n	22f44 <nrfx_gpiote_irq_handler+0xcc>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   22f7a:	f1ba 0f02 	cmp.w	sl, #2
   22f7e:	e7f4      	b.n	22f6a <nrfx_gpiote_irq_handler+0xf2>
        uint32_t ch = NRF_CTZ(mask);
   22f80:	fa95 f3a5 	rbit	r3, r5
   22f84:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   22f88:	fa04 f203 	lsl.w	r2, r4, r3
   22f8c:	009b      	lsls	r3, r3, #2
   22f8e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22f92:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
   22f96:	ea25 0502 	bic.w	r5, r5, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   22f9a:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   22f9e:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   22fa2:	f3c0 2004 	ubfx	r0, r0, #8, #5
   22fa6:	f3c1 4101 	ubfx	r1, r1, #16, #2
   22faa:	f7ff fcf7 	bl	2299c <call_handler>
    while (mask)
   22fae:	2d00      	cmp	r5, #0
   22fb0:	d1e6      	bne.n	22f80 <nrfx_gpiote_irq_handler+0x108>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   22fb2:	b003      	add	sp, #12
   22fb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22fb8:	40006100 	.word	0x40006100
   22fbc:	40006000 	.word	0x40006000
   22fc0:	40006120 	.word	0x40006120
   22fc4:	20000c7c 	.word	0x20000c7c

00022fc8 <nvmc_word_write>:
   22fc8:	4a04      	ldr	r2, [pc, #16]	; (22fdc <nvmc_word_write+0x14>)
   22fca:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   22fce:	07db      	lsls	r3, r3, #31
   22fd0:	d5fb      	bpl.n	22fca <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
   22fd2:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   22fd4:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   22fd8:	4770      	bx	lr
   22fda:	bf00      	nop
   22fdc:	4001e000 	.word	0x4001e000

00022fe0 <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   22fe0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22fe4:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
   22fe6:	fbb0 f3f2 	udiv	r3, r0, r2
   22fea:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT(is_valid_address(addr, false));

    if (!is_page_aligned_check(addr))
   22fee:	b973      	cbnz	r3, 2300e <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   22ff0:	4b08      	ldr	r3, [pc, #32]	; (23014 <nrfx_nvmc_page_erase+0x34>)
   22ff2:	2202      	movs	r2, #2
   22ff4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   22ff8:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   22ffc:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   23000:	07d2      	lsls	r2, r2, #31
   23002:	d5fb      	bpl.n	22ffc <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
   23004:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   23006:	4804      	ldr	r0, [pc, #16]	; (23018 <nrfx_nvmc_page_erase+0x38>)
   23008:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   2300c:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
   2300e:	4803      	ldr	r0, [pc, #12]	; (2301c <nrfx_nvmc_page_erase+0x3c>)
}
   23010:	4770      	bx	lr
   23012:	bf00      	nop
   23014:	4001e000 	.word	0x4001e000
   23018:	0bad0000 	.word	0x0bad0000
   2301c:	0bad000a 	.word	0x0bad000a

00023020 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   23020:	b510      	push	{r4, lr}
   23022:	4c05      	ldr	r4, [pc, #20]	; (23038 <nrfx_nvmc_word_write+0x18>)
   23024:	2301      	movs	r3, #1
   23026:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    NRFX_ASSERT(is_valid_address(addr, true));
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   2302a:	f7ff ffcd 	bl	22fc8 <nvmc_word_write>
   2302e:	2300      	movs	r3, #0
   23030:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
   23034:	bd10      	pop	{r4, pc}
   23036:	bf00      	nop
   23038:	4001e000 	.word	0x4001e000

0002303c <nrfx_ppi_channel_alloc>:
    nrfx_flag32_init(&m_groups_allocated, NRFX_PPI_ALL_APP_GROUPS_MASK);
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
   2303c:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_channels_allocated, (uint8_t *)p_channel);
   2303e:	4801      	ldr	r0, [pc, #4]	; (23044 <nrfx_ppi_channel_alloc+0x8>)
   23040:	f7ff bb92 	b.w	22768 <nrfx_flag32_alloc>
   23044:	20000cd8 	.word	0x20000cd8

00023048 <twim_irq_handler>:
{
    return nrf_twim_event_address_get(p_instance->p_twim, NRF_TWIM_EVENT_STOPPED);
}

static void twim_irq_handler(NRF_TWIM_Type * p_twim, twim_control_block_t * p_cb)
{
   23048:	b5f0      	push	{r4, r5, r6, r7, lr}
}

NRF_STATIC_INLINE bool nrf_twim_event_check(NRF_TWIM_Type const * p_reg,
                                            nrf_twim_event_t      event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2304a:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
   2304e:	b087      	sub	sp, #28
   23050:	4604      	mov	r4, r0
   23052:	460d      	mov	r5, r1
    }
#endif

    NRFX_ASSERT(p_cb->handler);

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   23054:	b1f3      	cbz	r3, 23094 <twim_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   23056:	2300      	movs	r3, #0
   23058:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
   2305c:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   23060:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
    {
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_ERROR));
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   23064:	b9b3      	cbnz	r3, 23094 <twim_irq_handler+0x4c>
        {
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   23066:	688b      	ldr	r3, [r1, #8]
}

NRF_STATIC_INLINE void nrf_twim_int_disable(NRF_TWIM_Type * p_reg,
                                            uint32_t mask)
{
    p_reg->INTENCLR = mask;
   23068:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2306c:	2302      	movs	r3, #2
   2306e:	608b      	str	r3, [r1, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   23070:	688b      	ldr	r3, [r1, #8]
    p_reg->INTENSET = mask;
   23072:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   23076:	f8d0 3160 	ldr.w	r3, [r0, #352]	; 0x160

            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   2307a:	b11b      	cbz	r3, 23084 <twim_irq_handler+0x3c>
    p_reg->SHORTS = mask;
}

NRF_STATIC_INLINE uint32_t nrf_twim_shorts_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->SHORTS;
   2307c:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   23080:	059f      	lsls	r7, r3, #22
   23082:	d402      	bmi.n	2308a <twim_irq_handler+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   23084:	2301      	movs	r3, #1
   23086:	6223      	str	r3, [r4, #32]
   23088:	6163      	str	r3, [r4, #20]
            {
                nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
                nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STOP);
            }

            p_cb->error = true;
   2308a:	2301      	movs	r3, #1
   2308c:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e

    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
    {
        p_cb->handler(&event, p_cb->p_context);
    }
}
   23090:	b007      	add	sp, #28
   23092:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   23094:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   23098:	2b00      	cmp	r3, #0
   2309a:	d044      	beq.n	23126 <twim_irq_handler+0xde>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2309c:	2300      	movs	r3, #0
   2309e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   230a2:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   230a6:	6a2b      	ldr	r3, [r5, #32]
   230a8:	065e      	lsls	r6, r3, #25
   230aa:	d40a      	bmi.n	230c2 <twim_irq_handler+0x7a>
   230ac:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   230b0:	b93b      	cbnz	r3, 230c2 <twim_irq_handler+0x7a>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   230b2:	4629      	mov	r1, r5
   230b4:	4620      	mov	r0, r4
   230b6:	f009 fbe9 	bl	2c88c <xfer_completeness_check>
   230ba:	f080 0001 	eor.w	r0, r0, #1
   230be:	f885 002e 	strb.w	r0, [r5, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   230c2:	6a2b      	ldr	r3, [r5, #32]
   230c4:	f013 0c04 	ands.w	ip, r3, #4
   230c8:	d13e      	bne.n	23148 <twim_irq_handler+0x100>
            event.xfer_desc = p_cb->xfer_desc;
   230ca:	f105 070c 	add.w	r7, r5, #12
   230ce:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   230d0:	ae01      	add	r6, sp, #4
   230d2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
            if (!p_cb->repeated || p_cb->error)
   230d4:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
            event.xfer_desc = p_cb->xfer_desc;
   230d8:	683b      	ldr	r3, [r7, #0]
   230da:	f8c4 c160 	str.w	ip, [r4, #352]	; 0x160
   230de:	6033      	str	r3, [r6, #0]
   230e0:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   230e4:	f8c4 c15c 	str.w	ip, [r4, #348]	; 0x15c
   230e8:	f8d4 315c 	ldr.w	r3, [r4, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   230ec:	f1be 0f00 	cmp.w	lr, #0
   230f0:	d002      	beq.n	230f8 <twim_irq_handler+0xb0>
   230f2:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   230f6:	b33b      	cbz	r3, 23148 <twim_irq_handler+0x100>
    p_reg->SHORTS = mask;
   230f8:	2300      	movs	r3, #0
   230fa:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                p_cb->int_mask = 0;
   230fe:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   23100:	4b2e      	ldr	r3, [pc, #184]	; (231bc <twim_irq_handler+0x174>)
   23102:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   23106:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
   2310a:	2b00      	cmp	r3, #0
   2310c:	ea4f 3214 	mov.w	r2, r4, lsr #12
   23110:	db1a      	blt.n	23148 <twim_irq_handler+0x100>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   23112:	f002 011f 	and.w	r1, r2, #31
   23116:	095b      	lsrs	r3, r3, #5
   23118:	2201      	movs	r2, #1
   2311a:	408a      	lsls	r2, r1
   2311c:	3360      	adds	r3, #96	; 0x60
   2311e:	4928      	ldr	r1, [pc, #160]	; (231c0 <twim_irq_handler+0x178>)
   23120:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   23124:	e010      	b.n	23148 <twim_irq_handler+0x100>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   23126:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   2312a:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   2312e:	7b2b      	ldrb	r3, [r5, #12]
   23130:	bb23      	cbnz	r3, 2317c <twim_irq_handler+0x134>
            event.xfer_desc = p_cb->xfer_desc;
   23132:	f105 070c 	add.w	r7, r5, #12
   23136:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   23138:	ae01      	add	r6, sp, #4
   2313a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   2313c:	683b      	ldr	r3, [r7, #0]
   2313e:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   23140:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   23144:	2b00      	cmp	r3, #0
   23146:	d0d8      	beq.n	230fa <twim_irq_handler+0xb2>
    uint32_t error_source = p_reg->ERRORSRC;
   23148:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   2314c:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   23150:	0798      	lsls	r0, r3, #30
   23152:	d525      	bpl.n	231a0 <twim_irq_handler+0x158>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   23154:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   23156:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   2315a:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   2315e:	b90b      	cbnz	r3, 23164 <twim_irq_handler+0x11c>
        p_cb->busy = false;
   23160:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   23164:	6a2b      	ldr	r3, [r5, #32]
   23166:	075b      	lsls	r3, r3, #29
   23168:	d503      	bpl.n	23172 <twim_irq_handler+0x12a>
   2316a:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   2316e:	2b00      	cmp	r3, #0
   23170:	d08e      	beq.n	23090 <twim_irq_handler+0x48>
        p_cb->handler(&event, p_cb->p_context);
   23172:	e9d5 3100 	ldrd	r3, r1, [r5]
   23176:	4668      	mov	r0, sp
   23178:	4798      	blx	r3
   2317a:	e789      	b.n	23090 <twim_irq_handler+0x48>
    p_reg->SHORTS = mask;
   2317c:	f44f 7300 	mov.w	r3, #512	; 0x200
   23180:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   23184:	f240 2302 	movw	r3, #514	; 0x202
   23188:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   2318a:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2318e:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   23192:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   23194:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   23198:	2301      	movs	r3, #1
   2319a:	60a3      	str	r3, [r4, #8]
   2319c:	6223      	str	r3, [r4, #32]
            return;
   2319e:	e777      	b.n	23090 <twim_irq_handler+0x48>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   231a0:	0759      	lsls	r1, r3, #29
   231a2:	d501      	bpl.n	231a8 <twim_irq_handler+0x160>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   231a4:	2302      	movs	r3, #2
   231a6:	e7d6      	b.n	23156 <twim_irq_handler+0x10e>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   231a8:	07da      	lsls	r2, r3, #31
   231aa:	d501      	bpl.n	231b0 <twim_irq_handler+0x168>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   231ac:	2303      	movs	r3, #3
   231ae:	e7d2      	b.n	23156 <twim_irq_handler+0x10e>
    else if (p_cb->error)
   231b0:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   231b4:	2b00      	cmp	r3, #0
   231b6:	d0ce      	beq.n	23156 <twim_irq_handler+0x10e>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   231b8:	2304      	movs	r3, #4
   231ba:	e7cc      	b.n	23156 <twim_irq_handler+0x10e>
   231bc:	019c0202 	.word	0x019c0202
   231c0:	e000e100 	.word	0xe000e100

000231c4 <nrfx_twim_init>:
{
   231c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   231c6:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   231c8:	4d23      	ldr	r5, [pc, #140]	; (23258 <nrfx_twim_init+0x94>)
   231ca:	f04f 0c34 	mov.w	ip, #52	; 0x34
   231ce:	fb0c fc06 	mul.w	ip, ip, r6
   231d2:	eb05 040c 	add.w	r4, r5, ip
   231d6:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
   231da:	2f00      	cmp	r7, #0
   231dc:	d13a      	bne.n	23254 <nrfx_twim_init+0x90>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   231de:	6800      	ldr	r0, [r0, #0]
    p_cb->p_context       = p_context;
   231e0:	6063      	str	r3, [r4, #4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   231e2:	7b4b      	ldrb	r3, [r1, #13]
   231e4:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   231e8:	7b8b      	ldrb	r3, [r1, #14]
    p_cb->int_mask        = 0;
   231ea:	60a7      	str	r7, [r4, #8]
    p_cb->repeated        = false;
   231ec:	f884 7030 	strb.w	r7, [r4, #48]	; 0x30
    p_cb->busy            = false;
   231f0:	f884 702f 	strb.w	r7, [r4, #47]	; 0x2f
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   231f4:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
    p_cb->handler         = event_handler;
   231f8:	f845 200c 	str.w	r2, [r5, ip]
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   231fc:	7bcc      	ldrb	r4, [r1, #15]
   231fe:	b1b3      	cbz	r3, 2322e <nrfx_twim_init+0x6a>
   23200:	b92c      	cbnz	r4, 2320e <nrfx_twim_init+0x4a>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   23202:	e9d1 4300 	ldrd	r4, r3, [r1]
    p_reg->PSEL.SCL = scl_pin;
   23206:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   2320a:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   2320e:	688b      	ldr	r3, [r1, #8]
    p_reg->FREQUENCY = frequency;
   23210:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
    if (p_cb->handler)
   23214:	b11a      	cbz	r2, 2321e <nrfx_twim_init+0x5a>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   23216:	f340 3007 	sbfx	r0, r0, #12, #8
   2321a:	f7e1 fa1d 	bl	4658 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2321e:	2334      	movs	r3, #52	; 0x34
   23220:	fb03 5506 	mla	r5, r3, r6, r5
    return err_code;
   23224:	480d      	ldr	r0, [pc, #52]	; (2325c <nrfx_twim_init+0x98>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   23226:	2301      	movs	r3, #1
   23228:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   2322c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    *p_pin = pin_number & 0x1F;
   2322e:	680b      	ldr	r3, [r1, #0]
   23230:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
   23234:	f04f 47a0 	mov.w	r7, #1342177280	; 0x50000000
   23238:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   2323c:	f240 6c0c 	movw	ip, #1548	; 0x60c
   23240:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
    *p_pin = pin_number & 0x1F;
   23244:	684b      	ldr	r3, [r1, #4]
   23246:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
   2324a:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   2324e:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
    if (!p_config->skip_psel_cfg)
   23252:	e7d5      	b.n	23200 <nrfx_twim_init+0x3c>
        return err_code;
   23254:	4802      	ldr	r0, [pc, #8]	; (23260 <nrfx_twim_init+0x9c>)
   23256:	e7e9      	b.n	2322c <nrfx_twim_init+0x68>
   23258:	2000373c 	.word	0x2000373c
   2325c:	0bad0000 	.word	0x0bad0000
   23260:	0bad0005 	.word	0x0bad0005

00023264 <nrfx_twim_enable>:
    nrf_twim_enable(p_instance->p_twim);
   23264:	6803      	ldr	r3, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   23266:	7902      	ldrb	r2, [r0, #4]
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   23268:	2106      	movs	r1, #6
   2326a:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   2326e:	4b04      	ldr	r3, [pc, #16]	; (23280 <nrfx_twim_enable+0x1c>)
   23270:	2134      	movs	r1, #52	; 0x34
   23272:	fb01 3302 	mla	r3, r1, r2, r3
   23276:	2202      	movs	r2, #2
   23278:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
}
   2327c:	4770      	bx	lr
   2327e:	bf00      	nop
   23280:	2000373c 	.word	0x2000373c

00023284 <nrfx_twim_disable>:
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   23284:	7901      	ldrb	r1, [r0, #4]
    p_cb->int_mask = 0;
   23286:	4b0c      	ldr	r3, [pc, #48]	; (232b8 <nrfx_twim_disable+0x34>)
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   23288:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   2328a:	2034      	movs	r0, #52	; 0x34
   2328c:	fb00 3301 	mla	r3, r0, r1, r3
   23290:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   23292:	480a      	ldr	r0, [pc, #40]	; (232bc <nrfx_twim_disable+0x38>)
   23294:	6099      	str	r1, [r3, #8]
   23296:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   2329a:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   2329e:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   232a2:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   232a6:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   232aa:	2201      	movs	r2, #1
   232ac:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    p_cb->busy = false;
   232b0:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
}
   232b4:	4770      	bx	lr
   232b6:	bf00      	nop
   232b8:	2000373c 	.word	0x2000373c
   232bc:	019c0202 	.word	0x019c0202

000232c0 <nrfx_twim_uninit>:
{
   232c0:	b570      	push	{r4, r5, r6, lr}
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   232c2:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->handler)
   232c4:	4d18      	ldr	r5, [pc, #96]	; (23328 <nrfx_twim_uninit+0x68>)
   232c6:	2334      	movs	r3, #52	; 0x34
   232c8:	4373      	muls	r3, r6
{
   232ca:	4604      	mov	r4, r0
    if (p_cb->handler)
   232cc:	58eb      	ldr	r3, [r5, r3]
   232ce:	b123      	cbz	r3, 232da <nrfx_twim_uninit+0x1a>
   232d0:	6800      	ldr	r0, [r0, #0]
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_twim));
   232d2:	f340 3007 	sbfx	r0, r0, #12, #8
   232d6:	f7e1 f9cf 	bl	4678 <arch_irq_disable>
    nrfx_twim_disable(p_instance);
   232da:	4620      	mov	r0, r4
   232dc:	f7ff ffd2 	bl	23284 <nrfx_twim_disable>
    if (!p_cb->skip_gpio_cfg && !p_cb->hold_bus_uninit)
   232e0:	2334      	movs	r3, #52	; 0x34
   232e2:	fb03 5306 	mla	r3, r3, r6, r5
   232e6:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
   232ea:	b9b2      	cbnz	r2, 2331a <nrfx_twim_uninit+0x5a>
   232ec:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
   232f0:	b99b      	cbnz	r3, 2331a <nrfx_twim_uninit+0x5a>
        nrf_gpio_cfg_default(nrf_twim_scl_pin_get(p_instance->p_twim));
   232f2:	6820      	ldr	r0, [r4, #0]
    return p_reg->PSEL.SCL;
   232f4:	f8d0 3508 	ldr.w	r3, [r0, #1288]	; 0x508
    *p_pin = pin_number & 0x1F;
   232f8:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
   232fc:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   23300:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   23304:	2102      	movs	r1, #2
   23306:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    return p_reg->PSEL.SDA;
   2330a:	f8d0 350c 	ldr.w	r3, [r0, #1292]	; 0x50c
    *p_pin = pin_number & 0x1F;
   2330e:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
   23312:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
   23316:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   2331a:	2334      	movs	r3, #52	; 0x34
   2331c:	fb03 5506 	mla	r5, r3, r6, r5
   23320:	2300      	movs	r3, #0
   23322:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   23326:	bd70      	pop	{r4, r5, r6, pc}
   23328:	2000373c 	.word	0x2000373c

0002332c <nrfx_twim_xfer>:
{
   2332c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    p_cb->error = false;
   23330:	f8df c2d0 	ldr.w	ip, [pc, #720]	; 23604 <nrfx_twim_xfer+0x2d8>
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   23334:	f890 e004 	ldrb.w	lr, [r0, #4]
    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   23338:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   2333a:	2334      	movs	r3, #52	; 0x34
   2333c:	fb03 c30e 	mla	r3, r3, lr, ip
{
   23340:	4617      	mov	r7, r2
    p_cb->error = false;
   23342:	2200      	movs	r2, #0
   23344:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   23348:	684b      	ldr	r3, [r1, #4]
{
   2334a:	460d      	mov	r5, r1
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   2334c:	b14b      	cbz	r3, 23362 <nrfx_twim_xfer+0x36>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   2334e:	68cb      	ldr	r3, [r1, #12]
   23350:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   23354:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   23358:	d003      	beq.n	23362 <nrfx_twim_xfer+0x36>
        return err_code;
   2335a:	4eab      	ldr	r6, [pc, #684]	; (23608 <nrfx_twim_xfer+0x2dc>)
}
   2335c:	4630      	mov	r0, r6
   2335e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (p_cb->busy)
   23362:	2634      	movs	r6, #52	; 0x34
    p_reg->INTENCLR = mask;
   23364:	4ba9      	ldr	r3, [pc, #676]	; (2360c <nrfx_twim_xfer+0x2e0>)
   23366:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   2336a:	fb06 c60e 	mla	r6, r6, lr, ip
   2336e:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   23372:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   23376:	b123      	cbz	r3, 23382 <nrfx_twim_xfer+0x56>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   23378:	68b3      	ldr	r3, [r6, #8]
    p_reg->INTENSET = mask;
   2337a:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
        return err_code;
   2337e:	4ea4      	ldr	r6, [pc, #656]	; (23610 <nrfx_twim_xfer+0x2e4>)
   23380:	e7ec      	b.n	2335c <nrfx_twim_xfer+0x30>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   23382:	f017 0f14 	tst.w	r7, #20
   23386:	bf0c      	ite	eq
   23388:	2301      	moveq	r3, #1
   2338a:	2300      	movne	r3, #0
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   2338c:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   23390:	46a9      	mov	r9, r5
   23392:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   23396:	f106 080c 	add.w	r8, r6, #12
   2339a:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   2339e:	f8d9 3000 	ldr.w	r3, [r9]
   233a2:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   233a6:	f3c7 1300 	ubfx	r3, r7, #4, #1
   233aa:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
    p_cb->flags = flags;
   233ae:	6237      	str	r7, [r6, #32]
    p_reg->ADDRESS = address;
   233b0:	786b      	ldrb	r3, [r5, #1]
   233b2:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   233b6:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   233ba:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   233be:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   233c2:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   233c6:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   233ca:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   233ce:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
   233d2:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   233d6:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   233da:	bf18      	it	ne
   233dc:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   233de:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   233e2:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   233e6:	bf18      	it	ne
   233e8:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   233ea:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   233ee:	782a      	ldrb	r2, [r5, #0]
   233f0:	2a03      	cmp	r2, #3
   233f2:	f200 80b5 	bhi.w	23560 <nrfx_twim_xfer+0x234>
   233f6:	e8df f002 	tbb	[pc, r2]
   233fa:	a084      	.short	0xa084
   233fc:	0269      	.short	0x0269
   233fe:	692b      	ldr	r3, [r5, #16]
   23400:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   23404:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   23408:	d1a7      	bne.n	2335a <nrfx_twim_xfer+0x2e>
    p_reg->SHORTS = mask;
   2340a:	f44f 7180 	mov.w	r1, #256	; 0x100
   2340e:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   23412:	68e8      	ldr	r0, [r5, #12]
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   23414:	6869      	ldr	r1, [r5, #4]
   23416:	f8c4 0544 	str.w	r0, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2341a:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2341e:	2100      	movs	r1, #0
   23420:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
   23424:	f8d4 0150 	ldr.w	r0, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   23428:	2001      	movs	r0, #1
   2342a:	6220      	str	r0, [r4, #32]
   2342c:	60a0      	str	r0, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2342e:	f8d4 0150 	ldr.w	r0, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   23432:	2800      	cmp	r0, #0
   23434:	d0fb      	beq.n	2342e <nrfx_twim_xfer+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   23436:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
   2343a:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   2343e:	68a9      	ldr	r1, [r5, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   23440:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   23444:	2334      	movs	r3, #52	; 0x34
   23446:	fb03 c30e 	mla	r3, r3, lr, ip
    p_reg->TXD.MAXCNT = length;
   2344a:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
   2344e:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   23452:	6099      	str	r1, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   23454:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   23456:	4e6f      	ldr	r6, [pc, #444]	; (23614 <nrfx_twim_xfer+0x2e8>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   23458:	0739      	lsls	r1, r7, #28
   2345a:	d406      	bmi.n	2346a <nrfx_twim_xfer+0x13e>
   2345c:	2a03      	cmp	r2, #3
   2345e:	d004      	beq.n	2346a <nrfx_twim_xfer+0x13e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   23460:	2201      	movs	r2, #1
   23462:	50e2      	str	r2, [r4, r3]
        if (p_xfer_desc->primary_length == 0)
   23464:	686b      	ldr	r3, [r5, #4]
   23466:	b903      	cbnz	r3, 2346a <nrfx_twim_xfer+0x13e>
   23468:	6162      	str	r2, [r4, #20]
    if (p_cb->handler)
   2346a:	2334      	movs	r3, #52	; 0x34
   2346c:	fb03 f30e 	mul.w	r3, r3, lr
   23470:	eb0c 0103 	add.w	r1, ip, r3
   23474:	f85c 2003 	ldr.w	r2, [ip, r3]
   23478:	2a00      	cmp	r2, #0
   2347a:	d174      	bne.n	23566 <nrfx_twim_xfer+0x23a>
                transmission_finished = true;
   2347c:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2347e:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
   23482:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   23486:	2800      	cmp	r0, #0
   23488:	f040 8088 	bne.w	2359c <nrfx_twim_xfer+0x270>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   2348c:	3b00      	subs	r3, #0
   2348e:	bf18      	it	ne
   23490:	2301      	movne	r3, #1
   23492:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   23496:	2800      	cmp	r0, #0
   23498:	f000 8086 	beq.w	235a8 <nrfx_twim_xfer+0x27c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2349c:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
   234a0:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   234a4:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   234a8:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   234ac:	b115      	cbz	r5, 234b4 <nrfx_twim_xfer+0x188>
   234ae:	f410 7f00 	tst.w	r0, #512	; 0x200
   234b2:	d104      	bne.n	234be <nrfx_twim_xfer+0x192>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   234b4:	6221      	str	r1, [r4, #32]
   234b6:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   234b8:	2d00      	cmp	r5, #0
   234ba:	d0e0      	beq.n	2347e <nrfx_twim_xfer+0x152>
                    transmission_finished = false;
   234bc:	2300      	movs	r3, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   234be:	05c0      	lsls	r0, r0, #23
   234c0:	d572      	bpl.n	235a8 <nrfx_twim_xfer+0x27c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   234c2:	f8c4 2148 	str.w	r2, [r4, #328]	; 0x148
   234c6:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        } while (!transmission_finished);
   234ca:	e7d8      	b.n	2347e <nrfx_twim_xfer+0x152>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   234cc:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   234ce:	68e9      	ldr	r1, [r5, #12]
   234d0:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   234d4:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   234d8:	692b      	ldr	r3, [r5, #16]
   234da:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   234de:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   234e2:	f47f af3a 	bne.w	2335a <nrfx_twim_xfer+0x2e>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   234e6:	68a9      	ldr	r1, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   234e8:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   234ec:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   234f0:	f8c4 1538 	str.w	r1, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   234f4:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   234f8:	2334      	movs	r3, #52	; 0x34
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   234fa:	fb03 c30e 	mla	r3, r3, lr, ip
   234fe:	2102      	movs	r1, #2
   23500:	e012      	b.n	23528 <nrfx_twim_xfer+0x1fc>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   23502:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   23504:	68e9      	ldr	r1, [r5, #12]
   23506:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   2350a:	f017 0f20 	tst.w	r7, #32
    p_reg->TXD.MAXCNT = length;
   2350e:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   23512:	f04f 0334 	mov.w	r3, #52	; 0x34
   23516:	d00b      	beq.n	23530 <nrfx_twim_xfer+0x204>
    p_reg->SHORTS = mask;
   23518:	f44f 7180 	mov.w	r1, #256	; 0x100
   2351c:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   23520:	fb03 c30e 	mla	r3, r3, lr, ip
   23524:	f44f 2180 	mov.w	r1, #262144	; 0x40000
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   23528:	6099      	str	r1, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2352a:	2301      	movs	r3, #1
   2352c:	6223      	str	r3, [r4, #32]
   2352e:	e791      	b.n	23454 <nrfx_twim_xfer+0x128>
    p_reg->SHORTS = mask;
   23530:	f44f 7100 	mov.w	r1, #512	; 0x200
   23534:	f8c4 1200 	str.w	r1, [r4, #512]	; 0x200
   23538:	e7df      	b.n	234fa <nrfx_twim_xfer+0x1ce>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2353a:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2353c:	68e9      	ldr	r1, [r5, #12]
   2353e:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   23542:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   23546:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   2354a:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2354e:	2334      	movs	r3, #52	; 0x34
   23550:	fb03 c30e 	mla	r3, r3, lr, ip
   23554:	2102      	movs	r1, #2
   23556:	6099      	str	r1, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   23558:	2301      	movs	r3, #1
   2355a:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   2355c:	2300      	movs	r3, #0
   2355e:	e77a      	b.n	23456 <nrfx_twim_xfer+0x12a>
    switch (p_xfer_desc->type)
   23560:	4e2d      	ldr	r6, [pc, #180]	; (23618 <nrfx_twim_xfer+0x2ec>)
   23562:	2308      	movs	r3, #8
   23564:	e778      	b.n	23458 <nrfx_twim_xfer+0x12c>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   23566:	077a      	lsls	r2, r7, #29
            p_cb->int_mask = 0;
   23568:	bf44      	itt	mi
   2356a:	2300      	movmi	r3, #0
   2356c:	608b      	strmi	r3, [r1, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   2356e:	067b      	lsls	r3, r7, #25
   23570:	d406      	bmi.n	23580 <nrfx_twim_xfer+0x254>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   23572:	2334      	movs	r3, #52	; 0x34
   23574:	fb03 c30e 	mla	r3, r3, lr, ip
   23578:	689a      	ldr	r2, [r3, #8]
   2357a:	f042 0202 	orr.w	r2, r2, #2
   2357e:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   23580:	2334      	movs	r3, #52	; 0x34
   23582:	fb03 cc0e 	mla	ip, r3, lr, ip
   23586:	f8dc 3008 	ldr.w	r3, [ip, #8]
   2358a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   2358e:	f8cc 3008 	str.w	r3, [ip, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   23592:	f8dc 3008 	ldr.w	r3, [ip, #8]
    p_reg->INTENSET = mask;
   23596:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   2359a:	e6df      	b.n	2335c <nrfx_twim_xfer+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2359c:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
   235a0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   235a4:	2301      	movs	r3, #1
   235a6:	e774      	b.n	23492 <nrfx_twim_xfer+0x166>
        } while (!transmission_finished);
   235a8:	2b00      	cmp	r3, #0
   235aa:	f43f af68 	beq.w	2347e <nrfx_twim_xfer+0x152>
        p_cb->busy = false;
   235ae:	2134      	movs	r1, #52	; 0x34
    uint32_t error_source = p_reg->ERRORSRC;
   235b0:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   235b4:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   235b8:	fb01 c20e 	mla	r2, r1, lr, ip
   235bc:	2000      	movs	r0, #0
   235be:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   235c2:	b18b      	cbz	r3, 235e8 <nrfx_twim_xfer+0x2bc>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   235c4:	4a15      	ldr	r2, [pc, #84]	; (2361c <nrfx_twim_xfer+0x2f0>)
   235c6:	4e16      	ldr	r6, [pc, #88]	; (23620 <nrfx_twim_xfer+0x2f4>)
   235c8:	f013 0f01 	tst.w	r3, #1
   235cc:	bf18      	it	ne
   235ce:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   235d0:	f013 0f02 	tst.w	r3, #2
   235d4:	f102 0201 	add.w	r2, r2, #1
   235d8:	bf18      	it	ne
   235da:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   235dc:	f013 0f04 	tst.w	r3, #4
   235e0:	4b10      	ldr	r3, [pc, #64]	; (23624 <nrfx_twim_xfer+0x2f8>)
   235e2:	bf18      	it	ne
   235e4:	461e      	movne	r6, r3
   235e6:	e6b9      	b.n	2335c <nrfx_twim_xfer+0x30>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   235e8:	067b      	lsls	r3, r7, #25
   235ea:	f53f aeb7 	bmi.w	2335c <nrfx_twim_xfer+0x30>
                !xfer_completeness_check(p_twim, p_cb))
   235ee:	fb0e c101 	mla	r1, lr, r1, ip
   235f2:	4620      	mov	r0, r4
   235f4:	f009 f94a 	bl	2c88c <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   235f8:	4b09      	ldr	r3, [pc, #36]	; (23620 <nrfx_twim_xfer+0x2f4>)
   235fa:	2800      	cmp	r0, #0
   235fc:	bf08      	it	eq
   235fe:	461e      	moveq	r6, r3
   23600:	e6ac      	b.n	2335c <nrfx_twim_xfer+0x30>
   23602:	bf00      	nop
   23604:	2000373c 	.word	0x2000373c
   23608:	0bad000a 	.word	0x0bad000a
   2360c:	019c0202 	.word	0x019c0202
   23610:	0bad000b 	.word	0x0bad000b
   23614:	0bad0000 	.word	0x0bad0000
   23618:	0bad0004 	.word	0x0bad0004
   2361c:	0bae0000 	.word	0x0bae0000
   23620:	0bad0001 	.word	0x0bad0001
   23624:	0bae0002 	.word	0x0bae0002

00023628 <nrfx_twim_0_irq_handler>:

#if NRFX_CHECK(NRFX_TWIM0_ENABLED)
void nrfx_twim_0_irq_handler(void)
{
    twim_irq_handler(NRF_TWIM0, &m_cb[NRFX_TWIM0_INST_IDX]);
   23628:	4901      	ldr	r1, [pc, #4]	; (23630 <nrfx_twim_0_irq_handler+0x8>)
   2362a:	4802      	ldr	r0, [pc, #8]	; (23634 <nrfx_twim_0_irq_handler+0xc>)
   2362c:	f7ff bd0c 	b.w	23048 <twim_irq_handler>
   23630:	2000373c 	.word	0x2000373c
   23634:	40003000 	.word	0x40003000

00023638 <nrfx_twim_1_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
   23638:	4902      	ldr	r1, [pc, #8]	; (23644 <nrfx_twim_1_irq_handler+0xc>)
   2363a:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
   2363e:	f7ff bd03 	b.w	23048 <twim_irq_handler>
   23642:	bf00      	nop
   23644:	20003770 	.word	0x20003770

00023648 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   23648:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    *p_pin = pin_number & 0x1F;
   2364c:	f000 001f 	and.w	r0, r0, #31
   23650:	f001 061f 	and.w	r6, r1, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   23654:	2401      	movs	r4, #1
    p_reg->OUTSET = set_mask;
   23656:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   2365a:	fa04 f800 	lsl.w	r8, r4, r0
    reg->PIN_CNF[pin_number] = cnf;
   2365e:	f506 72e0 	add.w	r2, r6, #448	; 0x1c0
   23662:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
   23666:	f240 630d 	movw	r3, #1549	; 0x60d
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   2366a:	40b4      	lsls	r4, r6
    p_reg->OUTSET = set_mask;
   2366c:	f8c5 8508 	str.w	r8, [r5, #1288]	; 0x508
   23670:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = cnf;
   23674:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
   23678:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
    nrf_gpio_pin_set(scl_pin);
    nrf_gpio_pin_set(sda_pin);

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   2367c:	2004      	movs	r0, #4
   2367e:	f009 f8dd 	bl	2c83c <nrfx_busy_wait>
   23682:	2709      	movs	r7, #9
    return p_reg->IN;
   23684:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510

    for (uint8_t i = 0; i < 9; i++)
    {
        if (nrf_gpio_pin_read(sda_pin))
   23688:	421c      	tst	r4, r3
   2368a:	d10d      	bne.n	236a8 <nrfx_twi_twim_bus_recover+0x60>
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
   2368c:	2004      	movs	r0, #4
    p_reg->OUTCLR = clr_mask;
   2368e:	f8c5 850c 	str.w	r8, [r5, #1292]	; 0x50c
   23692:	f009 f8d3 	bl	2c83c <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   23696:	3f01      	subs	r7, #1
    p_reg->OUTSET = set_mask;
   23698:	f8c5 8508 	str.w	r8, [r5, #1288]	; 0x508
            nrf_gpio_pin_set(scl_pin);
            NRFX_DELAY_US(4);
   2369c:	2004      	movs	r0, #4
   2369e:	f009 f8cd 	bl	2c83c <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   236a2:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
   236a6:	d1ed      	bne.n	23684 <nrfx_twi_twim_bus_recover+0x3c>
    p_reg->OUTCLR = clr_mask;
   236a8:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   236ac:	2004      	movs	r0, #4
   236ae:	f8c5 450c 	str.w	r4, [r5, #1292]	; 0x50c
   236b2:	f009 f8c3 	bl	2c83c <nrfx_busy_wait>
    p_reg->OUTSET = set_mask;
   236b6:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    nrf_gpio_pin_set(sda_pin);
    NRFX_DELAY_US(4);
   236ba:	2004      	movs	r0, #4
   236bc:	f009 f8be 	bl	2c83c <nrfx_busy_wait>
    return p_reg->IN;
   236c0:	f8d5 1510 	ldr.w	r1, [r5, #1296]	; 0x510

    if (nrf_gpio_pin_read(sda_pin))
   236c4:	4803      	ldr	r0, [pc, #12]	; (236d4 <nrfx_twi_twim_bus_recover+0x8c>)
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   236c6:	fa21 f606 	lsr.w	r6, r1, r6
   236ca:	f006 0601 	and.w	r6, r6, #1
   236ce:	1b80      	subs	r0, r0, r6
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   236d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   236d4:	0bad0001 	.word	0x0bad0001

000236d8 <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
   236d8:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   236da:	4c11      	ldr	r4, [pc, #68]	; (23720 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   236dc:	4a11      	ldr	r2, [pc, #68]	; (23724 <_DoInit+0x4c>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
   236de:	4912      	ldr	r1, [pc, #72]	; (23728 <_DoInit+0x50>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   236e0:	2303      	movs	r3, #3
   236e2:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   236e4:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
   236e6:	4b11      	ldr	r3, [pc, #68]	; (2372c <_DoInit+0x54>)
  p->aUp[0].sName         = "Terminal";
   236e8:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   236ea:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   236ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
   236f0:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
   236f2:	2300      	movs	r3, #0
   236f4:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   236f6:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   236f8:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
   236fa:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   236fc:	4a0c      	ldr	r2, [pc, #48]	; (23730 <_DoInit+0x58>)
   236fe:	6662      	str	r2, [r4, #100]	; 0x64
  STRCPY((char*)&p->acID[7], "RTT");
   23700:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   23702:	2210      	movs	r2, #16
   23704:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
   23706:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   23708:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   2370a:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
   2370c:	f004 f868 	bl	277e0 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
   23710:	4908      	ldr	r1, [pc, #32]	; (23734 <_DoInit+0x5c>)
   23712:	4620      	mov	r0, r4
   23714:	f004 f864 	bl	277e0 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
   23718:	2320      	movs	r3, #32
   2371a:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
   2371c:	bd10      	pop	{r4, pc}
   2371e:	bf00      	nop
   23720:	200037a4 	.word	0x200037a4
   23724:	00034dc1 	.word	0x00034dc1
   23728:	00034dca 	.word	0x00034dca
   2372c:	20003b6d 	.word	0x20003b6d
   23730:	20003b5d 	.word	0x20003b5d
   23734:	00034dce 	.word	0x00034dce

00023738 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   23738:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
   2373c:	4f23      	ldr	r7, [pc, #140]	; (237cc <SEGGER_RTT_WriteSkipNoLock+0x94>)
   2373e:	f04f 0b18 	mov.w	fp, #24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   23742:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   23744:	fb0b 7200 	mla	r2, fp, r0, r7
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   23748:	4606      	mov	r6, r0
  RdOff = pRing->RdOff;
   2374a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   2374c:	6a55      	ldr	r5, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   2374e:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   23750:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   23752:	d834      	bhi.n	237be <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   23754:	f8d2 a020 	ldr.w	sl, [r2, #32]
   23758:	ebaa 0905 	sub.w	r9, sl, r5
   2375c:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
    if (Avail >= NumBytes) {                            // Case 1)?
   23760:	4294      	cmp	r4, r2
   23762:	d811      	bhi.n	23788 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   23764:	f04f 0918 	mov.w	r9, #24
   23768:	fb06 9309 	mla	r3, r6, r9, r9
   2376c:	443b      	add	r3, r7
      memcpy((void*)pDst, pData, NumBytes);
   2376e:	4622      	mov	r2, r4
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   23770:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
   23772:	4641      	mov	r1, r8
   23774:	4428      	add	r0, r5
   23776:	f004 f87b 	bl	27870 <memcpy>
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
   2377a:	fb09 7606 	mla	r6, r9, r6, r7
   2377e:	442c      	add	r4, r5
      if (NumBytes) {
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
        memcpy((void*)pDst, pData + Rem, NumBytes);
      }
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = NumBytes;
   23780:	6274      	str	r4, [r6, #36]	; 0x24
      return 1;
   23782:	2001      	movs	r0, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   23784:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   23788:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   2378a:	429c      	cmp	r4, r3
   2378c:	d81b      	bhi.n	237c6 <SEGGER_RTT_WriteSkipNoLock+0x8e>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   2378e:	fb00 bb0b 	mla	fp, r0, fp, fp
   23792:	44bb      	add	fp, r7
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   23794:	464a      	mov	r2, r9
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   23796:	f8db 0004 	ldr.w	r0, [fp, #4]
   2379a:	442c      	add	r4, r5
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   2379c:	4428      	add	r0, r5
   2379e:	f004 f867 	bl	27870 <memcpy>
      if (NumBytes) {
   237a2:	ebb4 040a 	subs.w	r4, r4, sl
   237a6:	d006      	beq.n	237b6 <SEGGER_RTT_WriteSkipNoLock+0x7e>
        memcpy((void*)pDst, pData + Rem, NumBytes);
   237a8:	f8db 0004 	ldr.w	r0, [fp, #4]
   237ac:	4622      	mov	r2, r4
   237ae:	eb08 0109 	add.w	r1, r8, r9
   237b2:	f004 f85d 	bl	27870 <memcpy>
      pRing->WrOff = NumBytes;
   237b6:	2018      	movs	r0, #24
   237b8:	fb00 7606 	mla	r6, r0, r6, r7
   237bc:	e7e0      	b.n	23780 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   237be:	3b01      	subs	r3, #1
   237c0:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   237c2:	42a3      	cmp	r3, r4
   237c4:	d2ce      	bcs.n	23764 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   237c6:	2000      	movs	r0, #0
   237c8:	e7dc      	b.n	23784 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   237ca:	bf00      	nop
   237cc:	200037a4 	.word	0x200037a4

000237d0 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
   237d0:	4b03      	ldr	r3, [pc, #12]	; (237e0 <SEGGER_RTT_HasDataUp+0x10>)
   237d2:	2218      	movs	r2, #24
   237d4:	fb02 3300 	mla	r3, r2, r0, r3
   237d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   237da:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   237dc:	1a80      	subs	r0, r0, r2
   237de:	4770      	bx	lr
   237e0:	200037a4 	.word	0x200037a4

000237e4 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   237e4:	4b0e      	ldr	r3, [pc, #56]	; (23820 <z_sys_init_run_level+0x3c>)
{
   237e6:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   237e8:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   237ec:	3001      	adds	r0, #1
   237ee:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   237f2:	42a6      	cmp	r6, r4
   237f4:	d800      	bhi.n	237f8 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   237f6:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   237f8:	e9d4 3500 	ldrd	r3, r5, [r4]
   237fc:	4628      	mov	r0, r5
   237fe:	4798      	blx	r3
		if (dev != NULL) {
   23800:	b165      	cbz	r5, 2381c <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
   23802:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
   23804:	b130      	cbz	r0, 23814 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   23806:	2800      	cmp	r0, #0
   23808:	bfb8      	it	lt
   2380a:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   2380c:	28ff      	cmp	r0, #255	; 0xff
   2380e:	bfa8      	it	ge
   23810:	20ff      	movge	r0, #255	; 0xff
   23812:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   23814:	785a      	ldrb	r2, [r3, #1]
   23816:	f042 0201 	orr.w	r2, r2, #1
   2381a:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2381c:	3408      	adds	r4, #8
   2381e:	e7e8      	b.n	237f2 <z_sys_init_run_level+0xe>
   23820:	0002ea10 	.word	0x0002ea10

00023824 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
   23824:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
   23826:	4605      	mov	r5, r0
   23828:	b910      	cbnz	r0, 23830 <z_impl_device_get_binding+0xc>
		return NULL;
   2382a:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
   2382c:	4620      	mov	r0, r4
   2382e:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
   23830:	7803      	ldrb	r3, [r0, #0]
   23832:	2b00      	cmp	r3, #0
   23834:	d0f9      	beq.n	2382a <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
   23836:	4c0e      	ldr	r4, [pc, #56]	; (23870 <z_impl_device_get_binding+0x4c>)
   23838:	4e0e      	ldr	r6, [pc, #56]	; (23874 <z_impl_device_get_binding+0x50>)
   2383a:	42b4      	cmp	r4, r6
   2383c:	d108      	bne.n	23850 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
   2383e:	4c0c      	ldr	r4, [pc, #48]	; (23870 <z_impl_device_get_binding+0x4c>)
   23840:	42b4      	cmp	r4, r6
   23842:	d0f2      	beq.n	2382a <z_impl_device_get_binding+0x6>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
   23844:	4620      	mov	r0, r4
   23846:	f009 f859 	bl	2c8fc <z_device_is_ready>
   2384a:	b950      	cbnz	r0, 23862 <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
   2384c:	3418      	adds	r4, #24
   2384e:	e7f7      	b.n	23840 <z_impl_device_get_binding+0x1c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
   23850:	4620      	mov	r0, r4
   23852:	f009 f853 	bl	2c8fc <z_device_is_ready>
   23856:	b110      	cbz	r0, 2385e <z_impl_device_get_binding+0x3a>
   23858:	6823      	ldr	r3, [r4, #0]
   2385a:	42ab      	cmp	r3, r5
   2385c:	d0e6      	beq.n	2382c <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
   2385e:	3418      	adds	r4, #24
   23860:	e7eb      	b.n	2383a <z_impl_device_get_binding+0x16>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
   23862:	6821      	ldr	r1, [r4, #0]
   23864:	4628      	mov	r0, r5
   23866:	f003 ffd5 	bl	27814 <strcmp>
   2386a:	2800      	cmp	r0, #0
   2386c:	d1ee      	bne.n	2384c <z_impl_device_get_binding+0x28>
   2386e:	e7dd      	b.n	2382c <z_impl_device_get_binding+0x8>
   23870:	0002d570 	.word	0x0002d570
   23874:	0002d6c0 	.word	0x0002d6c0

00023878 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   23878:	4b01      	ldr	r3, [pc, #4]	; (23880 <z_impl_z_errno+0x8>)
   2387a:	6898      	ldr	r0, [r3, #8]
}
   2387c:	3064      	adds	r0, #100	; 0x64
   2387e:	4770      	bx	lr
   23880:	2000384c 	.word	0x2000384c

00023884 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   23884:	b510      	push	{r4, lr}
   23886:	4604      	mov	r4, r0
   23888:	b088      	sub	sp, #32
	z_impl_log_panic();
   2388a:	f7df fae3 	bl	2e54 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   2388e:	4b07      	ldr	r3, [pc, #28]	; (238ac <k_sys_fatal_error_handler+0x28>)
   23890:	9306      	str	r3, [sp, #24]
   23892:	2302      	movs	r3, #2
   23894:	9301      	str	r3, [sp, #4]
   23896:	9305      	str	r3, [sp, #20]
   23898:	4805      	ldr	r0, [pc, #20]	; (238b0 <k_sys_fatal_error_handler+0x2c>)
   2389a:	2300      	movs	r3, #0
   2389c:	aa05      	add	r2, sp, #20
   2389e:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   238a2:	f002 fa19 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	arch_system_halt(reason);
   238a6:	4620      	mov	r0, r4
   238a8:	f009 f841 	bl	2c92e <arch_system_halt>
   238ac:	00034dd5 	.word	0x00034dd5
   238b0:	0002dbf4 	.word	0x0002dbf4

000238b4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   238b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   238b8:	4605      	mov	r5, r0
   238ba:	b08e      	sub	sp, #56	; 0x38
   238bc:	460e      	mov	r6, r1
	__asm__ volatile(
   238be:	f04f 0320 	mov.w	r3, #32
   238c2:	f3ef 8811 	mrs	r8, BASEPRI
   238c6:	f383 8812 	msr	BASEPRI_MAX, r3
   238ca:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   238ce:	f001 f83f 	bl	24950 <z_impl_z_current_get>
   238d2:	2d04      	cmp	r5, #4
   238d4:	bf96      	itet	ls
   238d6:	4b22      	ldrls	r3, [pc, #136]	; (23960 <z_fatal_error+0xac>)
   238d8:	4b22      	ldrhi	r3, [pc, #136]	; (23964 <z_fatal_error+0xb0>)
   238da:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   238de:	4922      	ldr	r1, [pc, #136]	; (23968 <z_fatal_error+0xb4>)
   238e0:	9502      	str	r5, [sp, #8]
   238e2:	2700      	movs	r7, #0
   238e4:	e9cd 3703 	strd	r3, r7, [sp, #12]
   238e8:	4b20      	ldr	r3, [pc, #128]	; (2396c <z_fatal_error+0xb8>)
   238ea:	4604      	mov	r4, r0
   238ec:	e9cd 7300 	strd	r7, r3, [sp]
   238f0:	2201      	movs	r2, #1
   238f2:	463b      	mov	r3, r7
   238f4:	4638      	mov	r0, r7
   238f6:	f009 f80b 	bl	2c910 <z_log_msg2_runtime_create.constprop.0>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   238fa:	b17e      	cbz	r6, 2391c <z_fatal_error+0x68>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   238fc:	69f3      	ldr	r3, [r6, #28]
   238fe:	f3c3 0308 	ubfx	r3, r3, #0, #9
   23902:	b15b      	cbz	r3, 2391c <z_fatal_error+0x68>
		LOG_ERR("Fault during interrupt handling\n");
   23904:	4b1a      	ldr	r3, [pc, #104]	; (23970 <z_fatal_error+0xbc>)
   23906:	930c      	str	r3, [sp, #48]	; 0x30
   23908:	2302      	movs	r3, #2
   2390a:	9307      	str	r3, [sp, #28]
   2390c:	930b      	str	r3, [sp, #44]	; 0x2c
   2390e:	4816      	ldr	r0, [pc, #88]	; (23968 <z_fatal_error+0xb4>)
   23910:	463b      	mov	r3, r7
   23912:	aa0b      	add	r2, sp, #44	; 0x2c
   23914:	f44f 5182 	mov.w	r1, #4160	; 0x1040
   23918:	f002 f9de 	bl	25cd8 <z_impl_z_log_msg2_static_create>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   2391c:	b12c      	cbz	r4, 2392a <z_fatal_error+0x76>
   2391e:	4620      	mov	r0, r4
   23920:	f009 f8a6 	bl	2ca70 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   23924:	b108      	cbz	r0, 2392a <z_fatal_error+0x76>
   23926:	7803      	ldrb	r3, [r0, #0]
   23928:	b903      	cbnz	r3, 2392c <z_fatal_error+0x78>
		thread_name = "unknown";
   2392a:	4812      	ldr	r0, [pc, #72]	; (23974 <z_fatal_error+0xc0>)
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   2392c:	4b12      	ldr	r3, [pc, #72]	; (23978 <z_fatal_error+0xc4>)
   2392e:	9301      	str	r3, [sp, #4]
   23930:	2300      	movs	r3, #0
   23932:	e9cd 4002 	strd	r4, r0, [sp, #8]
   23936:	9300      	str	r3, [sp, #0]
   23938:	4618      	mov	r0, r3
   2393a:	2201      	movs	r2, #1
   2393c:	490a      	ldr	r1, [pc, #40]	; (23968 <z_fatal_error+0xb4>)
   2393e:	f008 ffe7 	bl	2c910 <z_log_msg2_runtime_create.constprop.0>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   23942:	4631      	mov	r1, r6
   23944:	4628      	mov	r0, r5
   23946:	f7ff ff9d 	bl	23884 <k_sys_fatal_error_handler>
	__asm__ volatile(
   2394a:	f388 8811 	msr	BASEPRI, r8
   2394e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   23952:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   23954:	b00e      	add	sp, #56	; 0x38
   23956:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2395a:	f7e1 bac3 	b.w	4ee4 <z_impl_k_thread_abort>
   2395e:	bf00      	nop
   23960:	0002ea28 	.word	0x0002ea28
   23964:	00034de4 	.word	0x00034de4
   23968:	0002dbf4 	.word	0x0002dbf4
   2396c:	00034df2 	.word	0x00034df2
   23970:	00034e1a 	.word	0x00034e1a
   23974:	0002f70c 	.word	0x0002f70c
   23978:	00034e3b 	.word	0x00034e3b

0002397c <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
   2397c:	b530      	push	{r4, r5, lr}
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   2397e:	2300      	movs	r3, #0
{
   23980:	b087      	sub	sp, #28
	z_setup_new_thread(thread, stack,
   23982:	2201      	movs	r2, #1
   23984:	e9cd 2304 	strd	r2, r3, [sp, #16]
   23988:	220f      	movs	r2, #15
   2398a:	e9cd 3202 	strd	r3, r2, [sp, #8]
   2398e:	9301      	str	r3, [sp, #4]
	struct k_thread *thread = &z_idle_threads[i];
   23990:	4c0c      	ldr	r4, [pc, #48]	; (239c4 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23992:	4b0d      	ldr	r3, [pc, #52]	; (239c8 <init_idle_thread+0x4c>)
	z_setup_new_thread(thread, stack,
   23994:	490d      	ldr	r1, [pc, #52]	; (239cc <init_idle_thread+0x50>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23996:	2218      	movs	r2, #24
	struct k_thread *thread = &z_idle_threads[i];
   23998:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2399c:	fb02 3300 	mla	r3, r2, r0, r3
	z_setup_new_thread(thread, stack,
   239a0:	f44f 75b0 	mov.w	r5, #352	; 0x160
   239a4:	9300      	str	r3, [sp, #0]
   239a6:	fb05 1100 	mla	r1, r5, r0, r1
   239aa:	4b09      	ldr	r3, [pc, #36]	; (239d0 <init_idle_thread+0x54>)
   239ac:	f44f 72a0 	mov.w	r2, #320	; 0x140
   239b0:	4620      	mov	r0, r4
   239b2:	f000 f90b 	bl	23bcc <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   239b6:	7b63      	ldrb	r3, [r4, #13]
   239b8:	f023 0304 	bic.w	r3, r3, #4
   239bc:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   239be:	b007      	add	sp, #28
   239c0:	bd30      	pop	{r4, r5, pc}
   239c2:	bf00      	nop
   239c4:	20002300 	.word	0x20002300
   239c8:	2000384c 	.word	0x2000384c
   239cc:	20005b20 	.word	0x20005b20
   239d0:	00023d41 	.word	0x00023d41

000239d4 <bg_thread_main>:
{
   239d4:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   239d6:	4b0a      	ldr	r3, [pc, #40]	; (23a00 <bg_thread_main+0x2c>)
   239d8:	2201      	movs	r2, #1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   239da:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   239dc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   239de:	f7ff ff01 	bl	237e4 <z_sys_init_run_level>
	boot_banner();
   239e2:	f001 fae3 	bl	24fac <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   239e6:	2003      	movs	r0, #3
   239e8:	f7ff fefc 	bl	237e4 <z_sys_init_run_level>
	z_init_static_threads();
   239ec:	f000 f94c 	bl	23c88 <z_init_static_threads>
	main();
   239f0:	f7de f8da 	bl	1ba8 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   239f4:	4a03      	ldr	r2, [pc, #12]	; (23a04 <bg_thread_main+0x30>)
   239f6:	7b13      	ldrb	r3, [r2, #12]
   239f8:	f023 0301 	bic.w	r3, r3, #1
   239fc:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   239fe:	bd08      	pop	{r3, pc}
   23a00:	20003f6d 	.word	0x20003f6d
   23a04:	20002380 	.word	0x20002380

00023a08 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   23a08:	4802      	ldr	r0, [pc, #8]	; (23a14 <z_bss_zero+0xc>)
   23a0a:	4a03      	ldr	r2, [pc, #12]	; (23a18 <z_bss_zero+0x10>)
   23a0c:	2100      	movs	r1, #0
   23a0e:	1a12      	subs	r2, r2, r0
   23a10:	f003 bf39 	b.w	27886 <memset>
   23a14:	200010f0 	.word	0x200010f0
   23a18:	20003f70 	.word	0x20003f70

00023a1c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   23a1c:	b580      	push	{r7, lr}
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
   23a1e:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 23ae8 <z_cstart+0xcc>
   23a22:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   23a24:	f388 8808 	msr	MSP, r8
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   23a28:	4d30      	ldr	r5, [pc, #192]	; (23aec <z_cstart+0xd0>)
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
   23a2a:	4e31      	ldr	r6, [pc, #196]	; (23af0 <z_cstart+0xd4>)
   23a2c:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   23a2e:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 23af4 <z_cstart+0xd8>
   23a32:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23a36:	2400      	movs	r4, #0
   23a38:	616b      	str	r3, [r5, #20]
   23a3a:	23e0      	movs	r3, #224	; 0xe0
   23a3c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   23a40:	77ec      	strb	r4, [r5, #31]
   23a42:	762c      	strb	r4, [r5, #24]
   23a44:	766c      	strb	r4, [r5, #25]
   23a46:	76ac      	strb	r4, [r5, #26]
   23a48:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   23a4c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   23a4e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   23a52:	626b      	str	r3, [r5, #36]	; 0x24
   23a54:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   23a58:	f7e1 fa0e 	bl	4e78 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   23a5c:	f7e0 fd78 	bl	4550 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   23a60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23a64:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   23a66:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   23a68:	f7e1 fafe 	bl	5068 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   23a6c:	f7e1 fa4c 	bl	4f08 <z_arm_configure_static_mpu_regions>
	gcov_static_init();

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
   23a70:	f7df f8fa 	bl	2c68 <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
   23a74:	f240 1301 	movw	r3, #257	; 0x101
   23a78:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   23a7c:	ab06      	add	r3, sp, #24
   23a7e:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   23a80:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
	dummy_thread->resource_pool = NULL;
   23a84:	9423      	str	r4, [sp, #140]	; 0x8c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   23a86:	f008 ff38 	bl	2c8fa <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   23a8a:	4620      	mov	r0, r4
   23a8c:	f7ff feaa 	bl	237e4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   23a90:	2001      	movs	r0, #1
	_kernel.ready_q.cache = &z_main_thread;
   23a92:	4d19      	ldr	r5, [pc, #100]	; (23af8 <z_cstart+0xdc>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   23a94:	f7ff fea6 	bl	237e4 <z_sys_init_run_level>
	z_sched_init();
   23a98:	f000 feac 	bl	247f4 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   23a9c:	4b17      	ldr	r3, [pc, #92]	; (23afc <z_cstart+0xe0>)
   23a9e:	9305      	str	r3, [sp, #20]
   23aa0:	2301      	movs	r3, #1
   23aa2:	4917      	ldr	r1, [pc, #92]	; (23b00 <z_cstart+0xe4>)
   23aa4:	9400      	str	r4, [sp, #0]
   23aa6:	e9cd 4303 	strd	r4, r3, [sp, #12]
   23aaa:	f44f 6280 	mov.w	r2, #1024	; 0x400
   23aae:	464b      	mov	r3, r9
   23ab0:	e9cd 4401 	strd	r4, r4, [sp, #4]
   23ab4:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
   23ab6:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   23ab8:	f000 f888 	bl	23bcc <z_setup_new_thread>
   23abc:	7b6a      	ldrb	r2, [r5, #13]
   23abe:	4607      	mov	r7, r0
   23ac0:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
   23ac4:	4628      	mov	r0, r5
   23ac6:	736a      	strb	r2, [r5, #13]
   23ac8:	f009 fa38 	bl	2cf3c <z_ready_thread>
		init_idle_thread(i);
   23acc:	4620      	mov	r0, r4
   23ace:	f7ff ff55 	bl	2397c <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   23ad2:	4b0c      	ldr	r3, [pc, #48]	; (23b04 <z_cstart+0xe8>)
   23ad4:	60f3      	str	r3, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   23ad6:	464a      	mov	r2, r9
   23ad8:	4639      	mov	r1, r7
   23ada:	4628      	mov	r0, r5
		_kernel.cpus[i].id = i;
   23adc:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   23ade:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   23ae2:	f7e0 febf 	bl	4864 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   23ae6:	bf00      	nop
   23ae8:	200064a0 	.word	0x200064a0
   23aec:	e000ed00 	.word	0xe000ed00
   23af0:	2000384c 	.word	0x2000384c
   23af4:	000239d5 	.word	0x000239d5
   23af8:	20002380 	.word	0x20002380
   23afc:	000307bf 	.word	0x000307bf
   23b00:	20005700 	.word	0x20005700
   23b04:	20002300 	.word	0x20002300

00023b08 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   23b08:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   23b0a:	4c06      	ldr	r4, [pc, #24]	; (23b24 <statics_init+0x1c>)
   23b0c:	4d06      	ldr	r5, [pc, #24]	; (23b28 <statics_init+0x20>)
   23b0e:	42ac      	cmp	r4, r5
   23b10:	d301      	bcc.n	23b16 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   23b12:	2000      	movs	r0, #0
   23b14:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   23b16:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   23b1a:	4620      	mov	r0, r4
   23b1c:	f008 ff10 	bl	2c940 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   23b20:	3414      	adds	r4, #20
   23b22:	e7f4      	b.n	23b0e <statics_init+0x6>
   23b24:	20000ed4 	.word	0x20000ed4
   23b28:	20000ed4 	.word	0x20000ed4

00023b2c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
   23b2c:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23b2e:	4b0e      	ldr	r3, [pc, #56]	; (23b68 <init_mem_slab_module+0x3c>)
   23b30:	4c0e      	ldr	r4, [pc, #56]	; (23b6c <init_mem_slab_module+0x40>)
   23b32:	42a3      	cmp	r3, r4
   23b34:	d301      	bcc.n	23b3a <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
   23b36:	2000      	movs	r0, #0
	return rc;
}
   23b38:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   23b3a:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   23b3e:	ea41 0200 	orr.w	r2, r1, r0
   23b42:	f012 0203 	ands.w	r2, r2, #3
   23b46:	d10b      	bne.n	23b60 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   23b48:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   23b4a:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   23b4c:	42aa      	cmp	r2, r5
   23b4e:	d101      	bne.n	23b54 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23b50:	331c      	adds	r3, #28
   23b52:	e7ee      	b.n	23b32 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   23b54:	695e      	ldr	r6, [r3, #20]
   23b56:	600e      	str	r6, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   23b58:	3201      	adds	r2, #1
		slab->free_list = p;
   23b5a:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   23b5c:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   23b5e:	e7f5      	b.n	23b4c <init_mem_slab_module+0x20>
	return rc;
   23b60:	f06f 0015 	mvn.w	r0, #21
   23b64:	e7e8      	b.n	23b38 <init_mem_slab_module+0xc>
   23b66:	bf00      	nop
   23b68:	20000e48 	.word	0x20000e48
   23b6c:	20000ed4 	.word	0x20000ed4

00023b70 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   23b70:	b537      	push	{r0, r1, r2, r4, r5, lr}
   23b72:	460c      	mov	r4, r1
	__asm__ volatile(
   23b74:	f04f 0520 	mov.w	r5, #32
   23b78:	f3ef 8111 	mrs	r1, BASEPRI
   23b7c:	f385 8812 	msr	BASEPRI_MAX, r5
   23b80:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   23b84:	6945      	ldr	r5, [r0, #20]
   23b86:	b15d      	cbz	r5, 23ba0 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
   23b88:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   23b8a:	682b      	ldr	r3, [r5, #0]
   23b8c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   23b8e:	6983      	ldr	r3, [r0, #24]
   23b90:	3301      	adds	r3, #1
   23b92:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   23b94:	2000      	movs	r0, #0
	__asm__ volatile(
   23b96:	f381 8811 	msr	BASEPRI, r1
   23b9a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   23b9e:	e011      	b.n	23bc4 <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   23ba0:	ea52 0c03 	orrs.w	ip, r2, r3
   23ba4:	d103      	bne.n	23bae <k_mem_slab_alloc+0x3e>
		*mem = NULL;
   23ba6:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
   23ba8:	f06f 000b 	mvn.w	r0, #11
   23bac:	e7f3      	b.n	23b96 <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   23bae:	e9cd 2300 	strd	r2, r3, [sp]
   23bb2:	4602      	mov	r2, r0
   23bb4:	3008      	adds	r0, #8
   23bb6:	f000 fd73 	bl	246a0 <z_pend_curr>
		if (result == 0) {
   23bba:	b918      	cbnz	r0, 23bc4 <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   23bbc:	4b02      	ldr	r3, [pc, #8]	; (23bc8 <k_mem_slab_alloc+0x58>)
   23bbe:	689b      	ldr	r3, [r3, #8]
   23bc0:	695b      	ldr	r3, [r3, #20]
   23bc2:	6023      	str	r3, [r4, #0]
}
   23bc4:	b003      	add	sp, #12
   23bc6:	bd30      	pop	{r4, r5, pc}
   23bc8:	2000384c 	.word	0x2000384c

00023bcc <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   23bcc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   23bd0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   23bd2:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   23bd4:	2604      	movs	r6, #4
   23bd6:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   23bd8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   23bda:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   23bdc:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
   23be0:	460f      	mov	r7, r1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   23be2:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   23be4:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   23be8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
   23bea:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   23bec:	f026 0607 	bic.w	r6, r6, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
   23bf0:	3720      	adds	r7, #32
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   23bf2:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
   23bf6:	e9c0 761a 	strd	r7, r6, [r0, #104]	; 0x68
	thread_base->pended_on = NULL;
   23bfa:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   23bfc:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   23bfe:	6705      	str	r5, [r0, #112]	; 0x70
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   23c00:	f106 0820 	add.w	r8, r6, #32
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   23c04:	9202      	str	r2, [sp, #8]
   23c06:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   23c08:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
   23c0a:	4488      	add	r8, r1
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   23c0c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   23c0e:	9200      	str	r2, [sp, #0]
   23c10:	4642      	mov	r2, r8
{
   23c12:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   23c14:	f7e0 fdf4 	bl	4800 <arch_new_thread>
	if (!_current) {
   23c18:	4b04      	ldr	r3, [pc, #16]	; (23c2c <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
   23c1a:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   23c1c:	689b      	ldr	r3, [r3, #8]
   23c1e:	b103      	cbz	r3, 23c22 <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
   23c20:	6f5b      	ldr	r3, [r3, #116]	; 0x74
	return stack_ptr;
   23c22:	6763      	str	r3, [r4, #116]	; 0x74
}
   23c24:	4640      	mov	r0, r8
   23c26:	b004      	add	sp, #16
   23c28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23c2c:	2000384c 	.word	0x2000384c

00023c30 <z_impl_k_thread_create>:
{
   23c30:	b5f0      	push	{r4, r5, r6, r7, lr}
   23c32:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23c34:	2700      	movs	r7, #0
   23c36:	9705      	str	r7, [sp, #20]
   23c38:	9f10      	ldr	r7, [sp, #64]	; 0x40
   23c3a:	9704      	str	r7, [sp, #16]
   23c3c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
   23c3e:	9703      	str	r7, [sp, #12]
   23c40:	9f0e      	ldr	r7, [sp, #56]	; 0x38
   23c42:	9702      	str	r7, [sp, #8]
{
   23c44:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23c48:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   23c4a:	9701      	str	r7, [sp, #4]
   23c4c:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   23c4e:	9700      	str	r7, [sp, #0]
{
   23c50:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23c52:	f7ff ffbb 	bl	23bcc <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   23c56:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
   23c5a:	bf08      	it	eq
   23c5c:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   23c60:	d005      	beq.n	23c6e <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23c62:	ea55 0306 	orrs.w	r3, r5, r6
   23c66:	d105      	bne.n	23c74 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
   23c68:	4620      	mov	r0, r4
   23c6a:	f000 fcbd 	bl	245e8 <z_sched_start>
}
   23c6e:	4620      	mov	r0, r4
   23c70:	b007      	add	sp, #28
   23c72:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23c74:	4903      	ldr	r1, [pc, #12]	; (23c84 <z_impl_k_thread_create+0x54>)
   23c76:	4632      	mov	r2, r6
   23c78:	462b      	mov	r3, r5
   23c7a:	f104 0018 	add.w	r0, r4, #24
   23c7e:	f000 ff6b 	bl	24b58 <z_add_timeout>
   23c82:	e7f4      	b.n	23c6e <z_impl_k_thread_create+0x3e>
   23c84:	0002cf5d 	.word	0x0002cf5d

00023c88 <z_init_static_threads>:
{
   23c88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   23c8c:	4c29      	ldr	r4, [pc, #164]	; (23d34 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
   23c8e:	4d2a      	ldr	r5, [pc, #168]	; (23d38 <z_init_static_threads+0xb0>)
{
   23c90:	b087      	sub	sp, #28
   23c92:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
   23c94:	42ae      	cmp	r6, r5
   23c96:	f104 0430 	add.w	r4, r4, #48	; 0x30
   23c9a:	d30f      	bcc.n	23cbc <z_init_static_threads+0x34>
	k_sched_lock();
   23c9c:	f000 fbc0 	bl	24420 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   23ca0:	4c24      	ldr	r4, [pc, #144]	; (23d34 <z_init_static_threads+0xac>)
   23ca2:	f8df 9098 	ldr.w	r9, [pc, #152]	; 23d3c <z_init_static_threads+0xb4>
   23ca6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   23caa:	f240 37e7 	movw	r7, #999	; 0x3e7
   23cae:	42ac      	cmp	r4, r5
   23cb0:	d320      	bcc.n	23cf4 <z_init_static_threads+0x6c>
}
   23cb2:	b007      	add	sp, #28
   23cb4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   23cb8:	f000 bd80 	b.w	247bc <k_sched_unlock>
		z_setup_new_thread(
   23cbc:	f854 3c04 	ldr.w	r3, [r4, #-4]
   23cc0:	9305      	str	r3, [sp, #20]
   23cc2:	f854 3c10 	ldr.w	r3, [r4, #-16]
   23cc6:	9304      	str	r3, [sp, #16]
   23cc8:	f854 3c14 	ldr.w	r3, [r4, #-20]
   23ccc:	9303      	str	r3, [sp, #12]
   23cce:	f854 3c18 	ldr.w	r3, [r4, #-24]
   23cd2:	9302      	str	r3, [sp, #8]
   23cd4:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   23cd8:	9301      	str	r3, [sp, #4]
   23cda:	f854 3c20 	ldr.w	r3, [r4, #-32]
   23cde:	9300      	str	r3, [sp, #0]
   23ce0:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   23ce4:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   23ce8:	f7ff ff70 	bl	23bcc <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   23cec:	f854 3c30 	ldr.w	r3, [r4, #-48]
   23cf0:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   23cf2:	e7ce      	b.n	23c92 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   23cf4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   23cf6:	1c5a      	adds	r2, r3, #1
   23cf8:	d00d      	beq.n	23d16 <z_init_static_threads+0x8e>
					    K_MSEC(thread_data->init_delay));
   23cfa:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   23cfe:	2100      	movs	r1, #0
   23d00:	4638      	mov	r0, r7
   23d02:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23d06:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
   23d0a:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23d0e:	d104      	bne.n	23d1a <z_init_static_threads+0x92>
	z_sched_start(thread);
   23d10:	4640      	mov	r0, r8
   23d12:	f000 fc69 	bl	245e8 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   23d16:	3430      	adds	r4, #48	; 0x30
   23d18:	e7c9      	b.n	23cae <z_init_static_threads+0x26>
   23d1a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   23d1e:	2300      	movs	r3, #0
   23d20:	f7dc f9de 	bl	e0 <__aeabi_uldivmod>
   23d24:	4602      	mov	r2, r0
   23d26:	460b      	mov	r3, r1
   23d28:	f108 0018 	add.w	r0, r8, #24
   23d2c:	4649      	mov	r1, r9
   23d2e:	f000 ff13 	bl	24b58 <z_add_timeout>
   23d32:	e7f0      	b.n	23d16 <z_init_static_threads+0x8e>
   23d34:	20000e48 	.word	0x20000e48
   23d38:	20000e48 	.word	0x20000e48
   23d3c:	0002cf5d 	.word	0x0002cf5d

00023d40 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   23d40:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   23d42:	4c0b      	ldr	r4, [pc, #44]	; (23d70 <idle+0x30>)
	return !z_sys_post_kernel;
   23d44:	4d0b      	ldr	r5, [pc, #44]	; (23d74 <idle+0x34>)
	__asm__ volatile(
   23d46:	f04f 0220 	mov.w	r2, #32
   23d4a:	f3ef 8311 	mrs	r3, BASEPRI
   23d4e:	f382 8812 	msr	BASEPRI_MAX, r2
   23d52:	f3bf 8f6f 	isb	sy
   23d56:	f009 f9cd 	bl	2d0f4 <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   23d5a:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
   23d5c:	61a0      	str	r0, [r4, #24]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   23d5e:	b913      	cbnz	r3, 23d66 <idle+0x26>
	arch_cpu_idle();
   23d60:	f7e0 fbfc 	bl	455c <arch_cpu_idle>
}
   23d64:	e7ef      	b.n	23d46 <idle+0x6>
   23d66:	f7e0 f9f3 	bl	4150 <pm_system_suspend>
   23d6a:	2800      	cmp	r0, #0
   23d6c:	d1eb      	bne.n	23d46 <idle+0x6>
   23d6e:	e7f7      	b.n	23d60 <idle+0x20>
   23d70:	2000384c 	.word	0x2000384c
   23d74:	20003f6d 	.word	0x20003f6d

00023d78 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   23d78:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   23d7c:	4604      	mov	r4, r0
   23d7e:	4617      	mov	r7, r2
   23d80:	461e      	mov	r6, r3
   23d82:	f04f 0320 	mov.w	r3, #32
   23d86:	f3ef 8811 	mrs	r8, BASEPRI
   23d8a:	f383 8812 	msr	BASEPRI_MAX, r3
   23d8e:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   23d92:	68c3      	ldr	r3, [r0, #12]
   23d94:	4a32      	ldr	r2, [pc, #200]	; (23e60 <z_impl_k_mutex_lock+0xe8>)
   23d96:	b16b      	cbz	r3, 23db4 <z_impl_k_mutex_lock+0x3c>
   23d98:	6880      	ldr	r0, [r0, #8]
   23d9a:	6891      	ldr	r1, [r2, #8]
   23d9c:	4288      	cmp	r0, r1
   23d9e:	d019      	beq.n	23dd4 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   23da0:	ea57 0306 	orrs.w	r3, r7, r6
   23da4:	d118      	bne.n	23dd8 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   23da6:	f388 8811 	msr	BASEPRI, r8
   23daa:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   23dae:	f06f 000f 	mvn.w	r0, #15
   23db2:	e00c      	b.n	23dce <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   23db4:	6891      	ldr	r1, [r2, #8]
   23db6:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   23dba:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
   23dbc:	3301      	adds	r3, #1
   23dbe:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   23dc0:	6893      	ldr	r3, [r2, #8]
   23dc2:	60a3      	str	r3, [r4, #8]
   23dc4:	f388 8811 	msr	BASEPRI, r8
   23dc8:	f3bf 8f6f 	isb	sy
		return 0;
   23dcc:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   23dce:	b002      	add	sp, #8
   23dd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   23dd4:	6921      	ldr	r1, [r4, #16]
   23dd6:	e7f0      	b.n	23dba <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   23dd8:	f991 100e 	ldrsb.w	r1, [r1, #14]
   23ddc:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   23de0:	4299      	cmp	r1, r3
   23de2:	bfa8      	it	ge
   23de4:	4619      	movge	r1, r3
   23de6:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   23dea:	4291      	cmp	r1, r2
   23dec:	bfb8      	it	lt
   23dee:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   23df0:	428b      	cmp	r3, r1
   23df2:	dd2e      	ble.n	23e52 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
   23df4:	f008 fe47 	bl	2ca86 <adjust_owner_prio.isra.0>
   23df8:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   23dfa:	e9cd 7600 	strd	r7, r6, [sp]
   23dfe:	4819      	ldr	r0, [pc, #100]	; (23e64 <z_impl_k_mutex_lock+0xec>)
   23e00:	4622      	mov	r2, r4
   23e02:	4641      	mov	r1, r8
   23e04:	f000 fc4c 	bl	246a0 <z_pend_curr>
	if (got_mutex == 0) {
   23e08:	2800      	cmp	r0, #0
   23e0a:	d0e0      	beq.n	23dce <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   23e0c:	f04f 0320 	mov.w	r3, #32
   23e10:	f3ef 8611 	mrs	r6, BASEPRI
   23e14:	f383 8812 	msr	BASEPRI_MAX, r3
   23e18:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   23e1c:	6823      	ldr	r3, [r4, #0]
   23e1e:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23e20:	429c      	cmp	r4, r3
   23e22:	d00a      	beq.n	23e3a <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   23e24:	b14b      	cbz	r3, 23e3a <z_impl_k_mutex_lock+0xc2>
   23e26:	f993 300e 	ldrsb.w	r3, [r3, #14]
   23e2a:	4299      	cmp	r1, r3
   23e2c:	bfa8      	it	ge
   23e2e:	4619      	movge	r1, r3
   23e30:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   23e34:	4299      	cmp	r1, r3
   23e36:	bfb8      	it	lt
   23e38:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   23e3a:	68a0      	ldr	r0, [r4, #8]
   23e3c:	f008 fe23 	bl	2ca86 <adjust_owner_prio.isra.0>
   23e40:	b900      	cbnz	r0, 23e44 <z_impl_k_mutex_lock+0xcc>
	if (resched) {
   23e42:	b145      	cbz	r5, 23e56 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   23e44:	4807      	ldr	r0, [pc, #28]	; (23e64 <z_impl_k_mutex_lock+0xec>)
   23e46:	4631      	mov	r1, r6
   23e48:	f000 fad8 	bl	243fc <z_reschedule>
	return -EAGAIN;
   23e4c:	f06f 000a 	mvn.w	r0, #10
   23e50:	e7bd      	b.n	23dce <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   23e52:	2500      	movs	r5, #0
   23e54:	e7d1      	b.n	23dfa <z_impl_k_mutex_lock+0x82>
	__asm__ volatile(
   23e56:	f386 8811 	msr	BASEPRI, r6
   23e5a:	f3bf 8f6f 	isb	sy
   23e5e:	e7f5      	b.n	23e4c <z_impl_k_mutex_lock+0xd4>
   23e60:	2000384c 	.word	0x2000384c
   23e64:	20003f6e 	.word	0x20003f6e

00023e68 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   23e68:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   23e6a:	6883      	ldr	r3, [r0, #8]
{
   23e6c:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   23e6e:	2b00      	cmp	r3, #0
   23e70:	d032      	beq.n	23ed8 <z_impl_k_mutex_unlock+0x70>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   23e72:	4a1c      	ldr	r2, [pc, #112]	; (23ee4 <z_impl_k_mutex_unlock+0x7c>)
   23e74:	6892      	ldr	r2, [r2, #8]
   23e76:	4293      	cmp	r3, r2
   23e78:	d131      	bne.n	23ede <z_impl_k_mutex_unlock+0x76>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   23e7a:	7bda      	ldrb	r2, [r3, #15]
   23e7c:	3a01      	subs	r2, #1
   23e7e:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   23e80:	68c3      	ldr	r3, [r0, #12]
   23e82:	2b01      	cmp	r3, #1
   23e84:	d905      	bls.n	23e92 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   23e86:	3b01      	subs	r3, #1
   23e88:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   23e8a:	f000 fc97 	bl	247bc <k_sched_unlock>

	return 0;
   23e8e:	2000      	movs	r0, #0
}
   23e90:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   23e92:	f04f 0320 	mov.w	r3, #32
   23e96:	f3ef 8511 	mrs	r5, BASEPRI
   23e9a:	f383 8812 	msr	BASEPRI_MAX, r3
   23e9e:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   23ea2:	6901      	ldr	r1, [r0, #16]
   23ea4:	6880      	ldr	r0, [r0, #8]
   23ea6:	f008 fdee 	bl	2ca86 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   23eaa:	4620      	mov	r0, r4
   23eac:	f009 f8b7 	bl	2d01e <z_unpend_first_thread>
	mutex->owner = new_owner;
   23eb0:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   23eb2:	b158      	cbz	r0, 23ecc <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
   23eb4:	f990 200e 	ldrsb.w	r2, [r0, #14]
   23eb8:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   23eba:	2200      	movs	r2, #0
   23ebc:	67c2      	str	r2, [r0, #124]	; 0x7c
		z_ready_thread(new_owner);
   23ebe:	f009 f83d 	bl	2cf3c <z_ready_thread>
		z_reschedule(&lock, key);
   23ec2:	4809      	ldr	r0, [pc, #36]	; (23ee8 <z_impl_k_mutex_unlock+0x80>)
   23ec4:	4629      	mov	r1, r5
   23ec6:	f000 fa99 	bl	243fc <z_reschedule>
   23eca:	e7de      	b.n	23e8a <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   23ecc:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   23ece:	f385 8811 	msr	BASEPRI, r5
   23ed2:	f3bf 8f6f 	isb	sy
   23ed6:	e7d8      	b.n	23e8a <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   23ed8:	f06f 0015 	mvn.w	r0, #21
   23edc:	e7d8      	b.n	23e90 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   23ede:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   23ee2:	e7d5      	b.n	23e90 <z_impl_k_mutex_unlock+0x28>
   23ee4:	2000384c 	.word	0x2000384c
   23ee8:	20003f6e 	.word	0x20003f6e

00023eec <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   23eec:	b537      	push	{r0, r1, r2, r4, r5, lr}
   23eee:	4611      	mov	r1, r2
	__asm__ volatile(
   23ef0:	f04f 0220 	mov.w	r2, #32
   23ef4:	f3ef 8511 	mrs	r5, BASEPRI
   23ef8:	f382 8812 	msr	BASEPRI_MAX, r2
   23efc:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   23f00:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   23f02:	b19c      	cbz	r4, 23f2c <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   23f04:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   23f06:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   23f08:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   23f0c:	4294      	cmp	r4, r2
	list->head = node;
   23f0e:	6003      	str	r3, [r0, #0]
	list->tail = node;
   23f10:	bf08      	it	eq
   23f12:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   23f14:	2101      	movs	r1, #1
   23f16:	4620      	mov	r0, r4
   23f18:	f008 fe28 	bl	2cb6c <z_queue_node_peek>
   23f1c:	4604      	mov	r4, r0
	__asm__ volatile(
   23f1e:	f385 8811 	msr	BASEPRI, r5
   23f22:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   23f26:	4620      	mov	r0, r4
   23f28:	b003      	add	sp, #12
   23f2a:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23f2c:	ea51 0203 	orrs.w	r2, r1, r3
   23f30:	d0f5      	beq.n	23f1e <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   23f32:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   23f36:	e9cd 1300 	strd	r1, r3, [sp]
   23f3a:	4610      	mov	r0, r2
   23f3c:	4629      	mov	r1, r5
   23f3e:	f000 fbaf 	bl	246a0 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   23f42:	2800      	cmp	r0, #0
   23f44:	d1ef      	bne.n	23f26 <z_impl_k_queue_get+0x3a>
   23f46:	4b02      	ldr	r3, [pc, #8]	; (23f50 <z_impl_k_queue_get+0x64>)
   23f48:	689b      	ldr	r3, [r3, #8]
   23f4a:	695c      	ldr	r4, [r3, #20]
   23f4c:	e7eb      	b.n	23f26 <z_impl_k_queue_get+0x3a>
   23f4e:	bf00      	nop
   23f50:	2000384c 	.word	0x2000384c

00023f54 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   23f54:	b538      	push	{r3, r4, r5, lr}
   23f56:	4604      	mov	r4, r0
	__asm__ volatile(
   23f58:	f04f 0320 	mov.w	r3, #32
   23f5c:	f3ef 8511 	mrs	r5, BASEPRI
   23f60:	f383 8812 	msr	BASEPRI_MAX, r3
   23f64:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   23f68:	f009 f859 	bl	2d01e <z_unpend_first_thread>

	if (thread != NULL) {
   23f6c:	b148      	cbz	r0, 23f82 <z_impl_k_sem_give+0x2e>
   23f6e:	2200      	movs	r2, #0
   23f70:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   23f72:	f008 ffe3 	bl	2cf3c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   23f76:	4629      	mov	r1, r5
   23f78:	4808      	ldr	r0, [pc, #32]	; (23f9c <z_impl_k_sem_give+0x48>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   23f7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   23f7e:	f000 ba3d 	b.w	243fc <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   23f82:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   23f86:	429a      	cmp	r2, r3
   23f88:	bf18      	it	ne
   23f8a:	3301      	addne	r3, #1
   23f8c:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   23f8e:	2102      	movs	r1, #2
   23f90:	f104 0010 	add.w	r0, r4, #16
   23f94:	f009 fa74 	bl	2d480 <z_handle_obj_poll_events>
}
   23f98:	e7ed      	b.n	23f76 <z_impl_k_sem_give+0x22>
   23f9a:	bf00      	nop
   23f9c:	20003f6e 	.word	0x20003f6e

00023fa0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   23fa0:	b513      	push	{r0, r1, r4, lr}
   23fa2:	f04f 0420 	mov.w	r4, #32
   23fa6:	f3ef 8111 	mrs	r1, BASEPRI
   23faa:	f384 8812 	msr	BASEPRI_MAX, r4
   23fae:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   23fb2:	6884      	ldr	r4, [r0, #8]
   23fb4:	b144      	cbz	r4, 23fc8 <z_impl_k_sem_take+0x28>
		sem->count--;
   23fb6:	3c01      	subs	r4, #1
   23fb8:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   23fba:	f381 8811 	msr	BASEPRI, r1
   23fbe:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   23fc2:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   23fc4:	b002      	add	sp, #8
   23fc6:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23fc8:	ea52 0403 	orrs.w	r4, r2, r3
   23fcc:	d106      	bne.n	23fdc <z_impl_k_sem_take+0x3c>
   23fce:	f381 8811 	msr	BASEPRI, r1
   23fd2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   23fd6:	f06f 000f 	mvn.w	r0, #15
   23fda:	e7f3      	b.n	23fc4 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   23fdc:	e9cd 2300 	strd	r2, r3, [sp]
   23fe0:	4602      	mov	r2, r0
   23fe2:	4802      	ldr	r0, [pc, #8]	; (23fec <z_impl_k_sem_take+0x4c>)
   23fe4:	f000 fb5c 	bl	246a0 <z_pend_curr>
	return ret;
   23fe8:	e7ec      	b.n	23fc4 <z_impl_k_sem_take+0x24>
   23fea:	bf00      	nop
   23fec:	20003f6e 	.word	0x20003f6e

00023ff0 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   23ff0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
   23ff2:	4b09      	ldr	r3, [pc, #36]	; (24018 <k_sys_work_q_init+0x28>)
   23ff4:	9302      	str	r3, [sp, #8]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   23ff6:	ab02      	add	r3, sp, #8
	struct k_work_queue_config cfg = {
   23ff8:	2400      	movs	r4, #0
	k_work_queue_start(&k_sys_work_q,
   23ffa:	9300      	str	r3, [sp, #0]
   23ffc:	4907      	ldr	r1, [pc, #28]	; (2401c <k_sys_work_q_init+0x2c>)
   23ffe:	4808      	ldr	r0, [pc, #32]	; (24020 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
   24000:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
   24004:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24008:	f44f 6200 	mov.w	r2, #2048	; 0x800
   2400c:	f000 f914 	bl	24238 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   24010:	4620      	mov	r0, r4
   24012:	b004      	add	sp, #16
   24014:	bd10      	pop	{r4, pc}
   24016:	bf00      	nop
   24018:	00034ea0 	.word	0x00034ea0
   2401c:	200064a0 	.word	0x200064a0
   24020:	20002400 	.word	0x20002400

00024024 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
   24024:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return list->head;
   24028:	4e47      	ldr	r6, [pc, #284]	; (24148 <work_queue_main+0x124>)
   2402a:	b085      	sub	sp, #20
   2402c:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
   2402e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   24032:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
   24036:	f04f 0320 	mov.w	r3, #32
   2403a:	f3ef 8711 	mrs	r7, BASEPRI
   2403e:	f383 8812 	msr	BASEPRI_MAX, r3
   24042:	f3bf 8f6f 	isb	sy
   24046:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
Z_GENLIST_GET(slist, snode)
   2404a:	b98d      	cbnz	r5, 24070 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
   2404c:	2102      	movs	r1, #2
   2404e:	f104 0098 	add.w	r0, r4, #152	; 0x98
   24052:	f008 fe24 	bl	2cc9e <flag_test_and_clear>
   24056:	2800      	cmp	r0, #0
   24058:	d135      	bne.n	240c6 <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   2405a:	2300      	movs	r3, #0
   2405c:	e9cd 8900 	strd	r8, r9, [sp]
   24060:	9302      	str	r3, [sp, #8]
   24062:	f104 0288 	add.w	r2, r4, #136	; 0x88
   24066:	4639      	mov	r1, r7
   24068:	4838      	ldr	r0, [pc, #224]	; (2414c <work_queue_main+0x128>)
   2406a:	f000 fcd9 	bl	24a20 <z_sched_wait>
			continue;
   2406e:	e7e2      	b.n	24036 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   24070:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
   24074:	682b      	ldr	r3, [r5, #0]
	list->head = node;
   24076:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2407a:	4295      	cmp	r5, r2
   2407c:	d101      	bne.n	24082 <work_queue_main+0x5e>
	list->tail = node;
   2407e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
   24082:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   24086:	f043 0302 	orr.w	r3, r3, #2
   2408a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
   2408e:	68eb      	ldr	r3, [r5, #12]
   24090:	f023 0304 	bic.w	r3, r3, #4
   24094:	f043 0301 	orr.w	r3, r3, #1
   24098:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
   2409a:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
   2409c:	f387 8811 	msr	BASEPRI, r7
   240a0:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
   240a4:	4628      	mov	r0, r5
   240a6:	4798      	blx	r3
	__asm__ volatile(
   240a8:	f04f 0320 	mov.w	r3, #32
   240ac:	f3ef 8b11 	mrs	fp, BASEPRI
   240b0:	f383 8812 	msr	BASEPRI_MAX, r3
   240b4:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   240b8:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   240ba:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
   240bc:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   240c0:	d40b      	bmi.n	240da <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
   240c2:	60ea      	str	r2, [r5, #12]
   240c4:	e00e      	b.n	240e4 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   240c6:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   240ca:	2200      	movs	r2, #0
   240cc:	2101      	movs	r1, #1
   240ce:	4628      	mov	r0, r5
   240d0:	f008 ffcd 	bl	2d06e <z_sched_wake>
   240d4:	2800      	cmp	r0, #0
   240d6:	d1f8      	bne.n	240ca <work_queue_main+0xa6>
   240d8:	e7bf      	b.n	2405a <work_queue_main+0x36>
	return list->head;
   240da:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
   240dc:	f023 0303 	bic.w	r3, r3, #3
   240e0:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   240e2:	b970      	cbnz	r0, 24102 <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
   240e4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   240e8:	f023 0302 	bic.w	r3, r3, #2
   240ec:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
   240f0:	f38b 8811 	msr	BASEPRI, fp
   240f4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
   240f8:	05d8      	lsls	r0, r3, #23
   240fa:	d49c      	bmi.n	24036 <work_queue_main+0x12>
	z_impl_k_yield();
   240fc:	f000 fb86 	bl	2480c <z_impl_k_yield>
}
   24100:	e799      	b.n	24036 <work_queue_main+0x12>
	return node->next;
   24102:	2700      	movs	r7, #0
   24104:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
   24108:	463b      	mov	r3, r7
		if (wc->work == work) {
   2410a:	6842      	ldr	r2, [r0, #4]
   2410c:	4295      	cmp	r5, r2
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   2410e:	4601      	mov	r1, r0
		if (wc->work == work) {
   24110:	d10c      	bne.n	2412c <work_queue_main+0x108>
	return node->next;
   24112:	6801      	ldr	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   24114:	b997      	cbnz	r7, 2413c <work_queue_main+0x118>
   24116:	6872      	ldr	r2, [r6, #4]
	list->head = node;
   24118:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   2411a:	4282      	cmp	r2, r0
   2411c:	d100      	bne.n	24120 <work_queue_main+0xfc>
	list->tail = node;
   2411e:	6071      	str	r1, [r6, #4]
	parent->next = child;
   24120:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
   24124:	f7ff ff16 	bl	23f54 <z_impl_k_sem_give>
}
   24128:	4639      	mov	r1, r7
   2412a:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   2412c:	f1ba 0f00 	cmp.w	sl, #0
   24130:	d0d8      	beq.n	240e4 <work_queue_main+0xc0>
	return node->next;
   24132:	4650      	mov	r0, sl
   24134:	460f      	mov	r7, r1
   24136:	f8da a000 	ldr.w	sl, [sl]
   2413a:	e7e6      	b.n	2410a <work_queue_main+0xe6>
	return list->tail;
   2413c:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
   2413e:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   24140:	4290      	cmp	r0, r2
	list->tail = node;
   24142:	bf08      	it	eq
   24144:	6077      	streq	r7, [r6, #4]
}
   24146:	e7eb      	b.n	24120 <work_queue_main+0xfc>
   24148:	20003874 	.word	0x20003874
   2414c:	20003f6e 	.word	0x20003f6e

00024150 <cancel_sync_locked>:
	return (*flagp & BIT(bit)) != 0U;
   24150:	68c3      	ldr	r3, [r0, #12]
{
   24152:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
   24154:	f3c3 0640 	ubfx	r6, r3, #1, #1
	if (ret) {
   24158:	079b      	lsls	r3, r3, #30
{
   2415a:	4605      	mov	r5, r0
   2415c:	460c      	mov	r4, r1
	if (ret) {
   2415e:	d50d      	bpl.n	2417c <cancel_sync_locked+0x2c>
	return z_impl_k_sem_init(sem, initial_count, limit);
   24160:	2201      	movs	r2, #1
   24162:	2100      	movs	r1, #0
   24164:	f104 0008 	add.w	r0, r4, #8
   24168:	f008 fd89 	bl	2cc7e <z_impl_k_sem_init>
	parent->next = child;
   2416c:	2300      	movs	r3, #0
   2416e:	6023      	str	r3, [r4, #0]
	return list->tail;
   24170:	4b05      	ldr	r3, [pc, #20]	; (24188 <cancel_sync_locked+0x38>)
	canceler->work = work;
   24172:	6065      	str	r5, [r4, #4]
   24174:	685a      	ldr	r2, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
   24176:	b91a      	cbnz	r2, 24180 <cancel_sync_locked+0x30>
	list->head = node;
   24178:	e9c3 4400 	strd	r4, r4, [r3]
}
   2417c:	4630      	mov	r0, r6
   2417e:	bd70      	pop	{r4, r5, r6, pc}
	parent->next = child;
   24180:	6014      	str	r4, [r2, #0]
	list->tail = node;
   24182:	605c      	str	r4, [r3, #4]
}
   24184:	e7fa      	b.n	2417c <cancel_sync_locked+0x2c>
   24186:	bf00      	nop
   24188:	20003874 	.word	0x20003874

0002418c <submit_to_queue_locked>:
{
   2418c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
   2418e:	68c3      	ldr	r3, [r0, #12]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   24190:	079a      	lsls	r2, r3, #30
{
   24192:	4604      	mov	r4, r0
   24194:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   24196:	f3c3 0540 	ubfx	r5, r3, #1, #1
   2419a:	d41f      	bmi.n	241dc <submit_to_queue_locked+0x50>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   2419c:	075f      	lsls	r7, r3, #29
   2419e:	d41f      	bmi.n	241e0 <submit_to_queue_locked+0x54>
		if (*queuep == NULL) {
   241a0:	680a      	ldr	r2, [r1, #0]
   241a2:	b90a      	cbnz	r2, 241a8 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
   241a4:	6882      	ldr	r2, [r0, #8]
   241a6:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   241a8:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
   241aa:	bf44      	itt	mi
   241ac:	68a3      	ldrmi	r3, [r4, #8]
   241ae:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
   241b0:	6837      	ldr	r7, [r6, #0]
			ret = 2;
   241b2:	bf4c      	ite	mi
   241b4:	2502      	movmi	r5, #2
		ret = 1;
   241b6:	2501      	movpl	r5, #1
	if (queue == NULL) {
   241b8:	b37f      	cbz	r7, 2421a <submit_to_queue_locked+0x8e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   241ba:	4b1b      	ldr	r3, [pc, #108]	; (24228 <submit_to_queue_locked+0x9c>)
   241bc:	689b      	ldr	r3, [r3, #8]
   241be:	42bb      	cmp	r3, r7
   241c0:	d111      	bne.n	241e6 <submit_to_queue_locked+0x5a>
   241c2:	f008 fc4c 	bl	2ca5e <k_is_in_isr>
   241c6:	f080 0001 	eor.w	r0, r0, #1
   241ca:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
   241cc:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   241d0:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   241d2:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   241d6:	d523      	bpl.n	24220 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
   241d8:	b13a      	cbz	r2, 241ea <submit_to_queue_locked+0x5e>
   241da:	b940      	cbnz	r0, 241ee <submit_to_queue_locked+0x62>
		ret = -EBUSY;
   241dc:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
   241e0:	2300      	movs	r3, #0
   241e2:	6033      	str	r3, [r6, #0]
	return ret;
   241e4:	e013      	b.n	2420e <submit_to_queue_locked+0x82>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   241e6:	2000      	movs	r0, #0
   241e8:	e7f0      	b.n	241cc <submit_to_queue_locked+0x40>
	} else if (plugged && !draining) {
   241ea:	071b      	lsls	r3, r3, #28
   241ec:	d4f6      	bmi.n	241dc <submit_to_queue_locked+0x50>
	parent->next = child;
   241ee:	2300      	movs	r3, #0
   241f0:	6023      	str	r3, [r4, #0]
	return list->tail;
   241f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
   241f6:	b963      	cbnz	r3, 24212 <submit_to_queue_locked+0x86>
	list->head = node;
   241f8:	e9c7 4420 	strd	r4, r4, [r7, #128]	; 0x80
		(void)notify_queue_locked(queue);
   241fc:	4638      	mov	r0, r7
   241fe:	f008 fd67 	bl	2ccd0 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
   24202:	68e3      	ldr	r3, [r4, #12]
   24204:	f043 0304 	orr.w	r3, r3, #4
   24208:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
   2420a:	6833      	ldr	r3, [r6, #0]
   2420c:	60a3      	str	r3, [r4, #8]
}
   2420e:	4628      	mov	r0, r5
   24210:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
   24212:	601c      	str	r4, [r3, #0]
	list->tail = node;
   24214:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
}
   24218:	e7f0      	b.n	241fc <submit_to_queue_locked+0x70>
		return -EINVAL;
   2421a:	f06f 0515 	mvn.w	r5, #21
   2421e:	e7df      	b.n	241e0 <submit_to_queue_locked+0x54>
		ret = -ENODEV;
   24220:	f06f 0512 	mvn.w	r5, #18
   24224:	e7dc      	b.n	241e0 <submit_to_queue_locked+0x54>
   24226:	bf00      	nop
   24228:	2000384c 	.word	0x2000384c

0002422c <k_work_submit>:
{
   2422c:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
   2422e:	4801      	ldr	r0, [pc, #4]	; (24234 <k_work_submit+0x8>)
   24230:	f008 bdbe 	b.w	2cdb0 <k_work_submit_to_queue>
   24234:	20002400 	.word	0x20002400

00024238 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
   24238:	b5f0      	push	{r4, r5, r6, r7, lr}
   2423a:	b089      	sub	sp, #36	; 0x24
   2423c:	4604      	mov	r4, r0
	list->head = NULL;
   2423e:	2000      	movs	r0, #0
	list->tail = NULL;
   24240:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
   24244:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   24246:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
   2424a:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
   2424e:	f104 0090 	add.w	r0, r4, #144	; 0x90
   24252:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
   24256:	b31d      	cbz	r5, 242a0 <k_work_queue_start+0x68>
   24258:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
   2425a:	2800      	cmp	r0, #0
   2425c:	f240 1001 	movw	r0, #257	; 0x101
   24260:	bf08      	it	eq
   24262:	2001      	moveq	r0, #1
	*flagp = flags;
   24264:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   24268:	2000      	movs	r0, #0
   2426a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2426e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   24272:	e9cd 3003 	strd	r3, r0, [sp, #12]
   24276:	e9cd 0001 	strd	r0, r0, [sp, #4]
   2427a:	e9cd 6706 	strd	r6, r7, [sp, #24]
   2427e:	4b09      	ldr	r3, [pc, #36]	; (242a4 <k_work_queue_start+0x6c>)
   24280:	9400      	str	r4, [sp, #0]
   24282:	4620      	mov	r0, r4
   24284:	f7ff fcd4 	bl	23c30 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
   24288:	b125      	cbz	r5, 24294 <k_work_queue_start+0x5c>
   2428a:	6829      	ldr	r1, [r5, #0]
   2428c:	b111      	cbz	r1, 24294 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
   2428e:	4620      	mov	r0, r4
   24290:	f008 fbeb 	bl	2ca6a <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   24294:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
   24296:	b009      	add	sp, #36	; 0x24
   24298:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   2429c:	f008 bbea 	b.w	2ca74 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   242a0:	2001      	movs	r0, #1
   242a2:	e7df      	b.n	24264 <k_work_queue_start+0x2c>
   242a4:	00024025 	.word	0x00024025

000242a8 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   242a8:	b513      	push	{r0, r1, r4, lr}
   242aa:	9001      	str	r0, [sp, #4]
   242ac:	4608      	mov	r0, r1
	__asm__ volatile(
   242ae:	f04f 0120 	mov.w	r1, #32
   242b2:	f3ef 8411 	mrs	r4, BASEPRI
   242b6:	f381 8812 	msr	BASEPRI_MAX, r1
   242ba:	f3bf 8f6f 	isb	sy
	return *flagp;
   242be:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   242c0:	f011 0f0e 	tst.w	r1, #14
   242c4:	d116      	bne.n	242f4 <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   242c6:	ea53 0c02 	orrs.w	ip, r3, r2
   242ca:	d108      	bne.n	242de <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
   242cc:	a901      	add	r1, sp, #4
   242ce:	f7ff ff5d 	bl	2418c <submit_to_queue_locked>
	__asm__ volatile(
   242d2:	f384 8811 	msr	BASEPRI, r4
   242d6:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   242da:	b002      	add	sp, #8
   242dc:	bd10      	pop	{r4, pc}
	*flagp |= BIT(bit);
   242de:	f041 0108 	orr.w	r1, r1, #8
   242e2:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
   242e4:	9901      	ldr	r1, [sp, #4]
   242e6:	6281      	str	r1, [r0, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   242e8:	3010      	adds	r0, #16
   242ea:	4903      	ldr	r1, [pc, #12]	; (242f8 <k_work_schedule_for_queue+0x50>)
   242ec:	f000 fc34 	bl	24b58 <z_add_timeout>
	return ret;
   242f0:	2001      	movs	r0, #1
   242f2:	e7ee      	b.n	242d2 <k_work_schedule_for_queue+0x2a>
	int ret = 0;
   242f4:	2000      	movs	r0, #0
   242f6:	e7ec      	b.n	242d2 <k_work_schedule_for_queue+0x2a>
   242f8:	0002cd41 	.word	0x0002cd41

000242fc <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
   242fc:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
   242fe:	4801      	ldr	r0, [pc, #4]	; (24304 <k_work_schedule+0x8>)
   24300:	f7ff bfd2 	b.w	242a8 <k_work_schedule_for_queue>
   24304:	20002400 	.word	0x20002400

00024308 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
   24308:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2430a:	460c      	mov	r4, r1
   2430c:	9001      	str	r0, [sp, #4]
   2430e:	4616      	mov	r6, r2
   24310:	461d      	mov	r5, r3
	__asm__ volatile(
   24312:	f04f 0320 	mov.w	r3, #32
   24316:	f3ef 8711 	mrs	r7, BASEPRI
   2431a:	f383 8812 	msr	BASEPRI_MAX, r3
   2431e:	f3bf 8f6f 	isb	sy

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
   24322:	4608      	mov	r0, r1
   24324:	f008 fcc6 	bl	2ccb4 <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   24328:	ea55 0306 	orrs.w	r3, r5, r6
   2432c:	d109      	bne.n	24342 <k_work_reschedule_for_queue+0x3a>
		return submit_to_queue_locked(work, queuep);
   2432e:	a901      	add	r1, sp, #4
   24330:	4620      	mov	r0, r4
   24332:	f7ff ff2b 	bl	2418c <submit_to_queue_locked>
	__asm__ volatile(
   24336:	f387 8811 	msr	BASEPRI, r7
   2433a:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   2433e:	b003      	add	sp, #12
   24340:	bdf0      	pop	{r4, r5, r6, r7, pc}
	*flagp |= BIT(bit);
   24342:	68e3      	ldr	r3, [r4, #12]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   24344:	4906      	ldr	r1, [pc, #24]	; (24360 <k_work_reschedule_for_queue+0x58>)
	*flagp |= BIT(bit);
   24346:	f043 0308 	orr.w	r3, r3, #8
   2434a:	60e3      	str	r3, [r4, #12]
	dwork->queue = *queuep;
   2434c:	9b01      	ldr	r3, [sp, #4]
   2434e:	62a3      	str	r3, [r4, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   24350:	f104 0010 	add.w	r0, r4, #16
   24354:	4632      	mov	r2, r6
   24356:	462b      	mov	r3, r5
   24358:	f000 fbfe 	bl	24b58 <z_add_timeout>
	return ret;
   2435c:	2001      	movs	r0, #1
   2435e:	e7ea      	b.n	24336 <k_work_reschedule_for_queue+0x2e>
   24360:	0002cd41 	.word	0x0002cd41

00024364 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   24364:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
   24366:	4801      	ldr	r0, [pc, #4]	; (2436c <k_work_reschedule+0x8>)
   24368:	f7ff bfce 	b.w	24308 <k_work_reschedule_for_queue>
   2436c:	20002400 	.word	0x20002400

00024370 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   24370:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   24372:	4c08      	ldr	r4, [pc, #32]	; (24394 <z_reset_time_slice+0x24>)
   24374:	6823      	ldr	r3, [r4, #0]
   24376:	b15b      	cbz	r3, 24390 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   24378:	f7fe f88c 	bl	22494 <sys_clock_elapsed>
   2437c:	4603      	mov	r3, r0
   2437e:	6820      	ldr	r0, [r4, #0]
   24380:	4a05      	ldr	r2, [pc, #20]	; (24398 <z_reset_time_slice+0x28>)
   24382:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
	}
}
   24384:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   24388:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   2438a:	2100      	movs	r1, #0
   2438c:	f008 bec2 	b.w	2d114 <z_set_timeout_expiry>
}
   24390:	bd10      	pop	{r4, pc}
   24392:	bf00      	nop
   24394:	20003884 	.word	0x20003884
   24398:	2000384c 	.word	0x2000384c

0002439c <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   2439c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2439e:	4604      	mov	r4, r0
   243a0:	460d      	mov	r5, r1
	__asm__ volatile(
   243a2:	f04f 0320 	mov.w	r3, #32
   243a6:	f3ef 8611 	mrs	r6, BASEPRI
   243aa:	f383 8812 	msr	BASEPRI_MAX, r3
   243ae:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   243b2:	4b0f      	ldr	r3, [pc, #60]	; (243f0 <k_sched_time_slice_set+0x54>)
   243b4:	2100      	movs	r1, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
   243b6:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   243ba:	f240 30e7 	movw	r0, #999	; 0x3e7
   243be:	6119      	str	r1, [r3, #16]
   243c0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   243c4:	2300      	movs	r3, #0
   243c6:	fbe4 0107 	umlal	r0, r1, r4, r7
   243ca:	f7db fe89 	bl	e0 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   243ce:	2c00      	cmp	r4, #0
   243d0:	4b08      	ldr	r3, [pc, #32]	; (243f4 <k_sched_time_slice_set+0x58>)
   243d2:	dc09      	bgt.n	243e8 <k_sched_time_slice_set+0x4c>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   243d4:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   243d6:	4b08      	ldr	r3, [pc, #32]	; (243f8 <k_sched_time_slice_set+0x5c>)
   243d8:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   243da:	f7ff ffc9 	bl	24370 <z_reset_time_slice>
	__asm__ volatile(
   243de:	f386 8811 	msr	BASEPRI, r6
   243e2:	f3bf 8f6f 	isb	sy
	}
}
   243e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			slice_time = MAX(2, slice_time);
   243e8:	2802      	cmp	r0, #2
   243ea:	bfb8      	it	lt
   243ec:	2002      	movlt	r0, #2
   243ee:	e7f1      	b.n	243d4 <k_sched_time_slice_set+0x38>
   243f0:	2000384c 	.word	0x2000384c
   243f4:	20003884 	.word	0x20003884
   243f8:	20003880 	.word	0x20003880

000243fc <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   243fc:	b949      	cbnz	r1, 24412 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   243fe:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   24402:	b930      	cbnz	r0, 24412 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   24404:	4b05      	ldr	r3, [pc, #20]	; (2441c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   24406:	69da      	ldr	r2, [r3, #28]
   24408:	689b      	ldr	r3, [r3, #8]
   2440a:	429a      	cmp	r2, r3
   2440c:	d001      	beq.n	24412 <z_reschedule+0x16>
	ret = arch_swap(key);
   2440e:	f7e0 b9a3 	b.w	4758 <arch_swap>
   24412:	f381 8811 	msr	BASEPRI, r1
   24416:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   2441a:	4770      	bx	lr
   2441c:	2000384c 	.word	0x2000384c

00024420 <k_sched_lock>:
	__asm__ volatile(
   24420:	f04f 0320 	mov.w	r3, #32
   24424:	f3ef 8111 	mrs	r1, BASEPRI
   24428:	f383 8812 	msr	BASEPRI_MAX, r3
   2442c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   24430:	4b04      	ldr	r3, [pc, #16]	; (24444 <k_sched_lock+0x24>)
   24432:	689a      	ldr	r2, [r3, #8]
   24434:	7bd3      	ldrb	r3, [r2, #15]
   24436:	3b01      	subs	r3, #1
   24438:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   2443a:	f381 8811 	msr	BASEPRI, r1
   2443e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   24442:	4770      	bx	lr
   24444:	2000384c 	.word	0x2000384c

00024448 <update_cache>:
{
   24448:	b538      	push	{r3, r4, r5, lr}
   2444a:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   2444c:	480c      	ldr	r0, [pc, #48]	; (24480 <update_cache+0x38>)
   2444e:	4d0d      	ldr	r5, [pc, #52]	; (24484 <update_cache+0x3c>)
   24450:	f008 fd6e 	bl	2cf30 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   24454:	4604      	mov	r4, r0
   24456:	b900      	cbnz	r0, 2445a <update_cache+0x12>
   24458:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
   2445a:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
   2445c:	b94a      	cbnz	r2, 24472 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   2445e:	7b5a      	ldrb	r2, [r3, #13]
   24460:	06d2      	lsls	r2, r2, #27
   24462:	d106      	bne.n	24472 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   24464:	69a2      	ldr	r2, [r4, #24]
   24466:	b922      	cbnz	r2, 24472 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   24468:	89da      	ldrh	r2, [r3, #14]
   2446a:	2a7f      	cmp	r2, #127	; 0x7f
   2446c:	d901      	bls.n	24472 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   2446e:	61eb      	str	r3, [r5, #28]
}
   24470:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   24472:	429c      	cmp	r4, r3
   24474:	d001      	beq.n	2447a <update_cache+0x32>
			z_reset_time_slice();
   24476:	f7ff ff7b 	bl	24370 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   2447a:	61ec      	str	r4, [r5, #28]
}
   2447c:	e7f8      	b.n	24470 <update_cache+0x28>
   2447e:	bf00      	nop
   24480:	2000386c 	.word	0x2000386c
   24484:	2000384c 	.word	0x2000384c

00024488 <move_thread_to_end_of_prio_q>:
{
   24488:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   2448a:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
   2448e:	7b43      	ldrb	r3, [r0, #13]
   24490:	2a00      	cmp	r2, #0
{
   24492:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   24494:	da04      	bge.n	244a0 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   24496:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2449a:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   2449c:	f008 fcf3 	bl	2ce86 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   244a0:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
   244a2:	4a15      	ldr	r2, [pc, #84]	; (244f8 <move_thread_to_end_of_prio_q+0x70>)
   244a4:	f063 037f 	orn	r3, r3, #127	; 0x7f
   244a8:	734b      	strb	r3, [r1, #13]
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   244aa:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   244ae:	f102 0520 	add.w	r5, r2, #32
   244b2:	42ab      	cmp	r3, r5
   244b4:	d01b      	beq.n	244ee <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   244b6:	b1d3      	cbz	r3, 244ee <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
   244b8:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   244bc:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
   244c0:	4286      	cmp	r6, r0
   244c2:	d00f      	beq.n	244e4 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
   244c4:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   244c6:	2800      	cmp	r0, #0
   244c8:	dd0c      	ble.n	244e4 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   244ca:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   244cc:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   244d0:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   244d2:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   244d4:	6890      	ldr	r0, [r2, #8]
   244d6:	1a43      	subs	r3, r0, r1
   244d8:	4258      	negs	r0, r3
}
   244da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   244de:	4158      	adcs	r0, r3
   244e0:	f7ff bfb2 	b.w	24448 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   244e4:	42a3      	cmp	r3, r4
   244e6:	d002      	beq.n	244ee <move_thread_to_end_of_prio_q+0x66>
   244e8:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   244ea:	2b00      	cmp	r3, #0
   244ec:	d1e6      	bne.n	244bc <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
   244ee:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
   244f2:	6021      	str	r1, [r4, #0]
	list->tail = node;
   244f4:	6251      	str	r1, [r2, #36]	; 0x24
}
   244f6:	e7ed      	b.n	244d4 <move_thread_to_end_of_prio_q+0x4c>
   244f8:	2000384c 	.word	0x2000384c

000244fc <z_time_slice>:
{
   244fc:	b538      	push	{r3, r4, r5, lr}
   244fe:	4601      	mov	r1, r0
	__asm__ volatile(
   24500:	f04f 0320 	mov.w	r3, #32
   24504:	f3ef 8411 	mrs	r4, BASEPRI
   24508:	f383 8812 	msr	BASEPRI_MAX, r3
   2450c:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   24510:	4b15      	ldr	r3, [pc, #84]	; (24568 <z_time_slice+0x6c>)
   24512:	4a16      	ldr	r2, [pc, #88]	; (2456c <z_time_slice+0x70>)
   24514:	6898      	ldr	r0, [r3, #8]
   24516:	6815      	ldr	r5, [r2, #0]
   24518:	42a8      	cmp	r0, r5
   2451a:	d106      	bne.n	2452a <z_time_slice+0x2e>
			z_reset_time_slice();
   2451c:	f7ff ff28 	bl	24370 <z_reset_time_slice>
	__asm__ volatile(
   24520:	f384 8811 	msr	BASEPRI, r4
   24524:	f3bf 8f6f 	isb	sy
}
   24528:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
   2452a:	2500      	movs	r5, #0
   2452c:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
   2452e:	4a10      	ldr	r2, [pc, #64]	; (24570 <z_time_slice+0x74>)
   24530:	6812      	ldr	r2, [r2, #0]
   24532:	b1ba      	cbz	r2, 24564 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
   24534:	89c2      	ldrh	r2, [r0, #14]
   24536:	2a7f      	cmp	r2, #127	; 0x7f
   24538:	d814      	bhi.n	24564 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
   2453a:	7b42      	ldrb	r2, [r0, #13]
   2453c:	06d2      	lsls	r2, r2, #27
   2453e:	d111      	bne.n	24564 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   24540:	4a0c      	ldr	r2, [pc, #48]	; (24574 <z_time_slice+0x78>)
   24542:	f990 500e 	ldrsb.w	r5, [r0, #14]
   24546:	6812      	ldr	r2, [r2, #0]
   24548:	4295      	cmp	r5, r2
   2454a:	db0b      	blt.n	24564 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
   2454c:	4a0a      	ldr	r2, [pc, #40]	; (24578 <z_time_slice+0x7c>)
   2454e:	4290      	cmp	r0, r2
   24550:	d008      	beq.n	24564 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
   24552:	691a      	ldr	r2, [r3, #16]
   24554:	428a      	cmp	r2, r1
   24556:	dc02      	bgt.n	2455e <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
   24558:	f7ff ff96 	bl	24488 <move_thread_to_end_of_prio_q>
   2455c:	e7de      	b.n	2451c <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
   2455e:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
   24560:	611a      	str	r2, [r3, #16]
   24562:	e7dd      	b.n	24520 <z_time_slice+0x24>
   24564:	2200      	movs	r2, #0
   24566:	e7fb      	b.n	24560 <z_time_slice+0x64>
   24568:	2000384c 	.word	0x2000384c
   2456c:	2000387c 	.word	0x2000387c
   24570:	20003884 	.word	0x20003884
   24574:	20003880 	.word	0x20003880
   24578:	20002300 	.word	0x20002300

0002457c <ready_thread>:
{
   2457c:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   2457e:	f990 200d 	ldrsb.w	r2, [r0, #13]
   24582:	7b43      	ldrb	r3, [r0, #13]
   24584:	2a00      	cmp	r2, #0
   24586:	db2a      	blt.n	245de <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   24588:	06da      	lsls	r2, r3, #27
   2458a:	d128      	bne.n	245de <ready_thread+0x62>
   2458c:	6982      	ldr	r2, [r0, #24]
   2458e:	bb32      	cbnz	r2, 245de <ready_thread+0x62>
	return list->head == list;
   24590:	4a14      	ldr	r2, [pc, #80]	; (245e4 <ready_thread+0x68>)
	thread->base.thread_state |= _THREAD_QUEUED;
   24592:	f063 037f 	orn	r3, r3, #127	; 0x7f
   24596:	7343      	strb	r3, [r0, #13]
	return (node == list->tail) ? NULL : node->next;
   24598:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2459c:	f102 0520 	add.w	r5, r2, #32
   245a0:	42ab      	cmp	r3, r5
   245a2:	d017      	beq.n	245d4 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   245a4:	b1b3      	cbz	r3, 245d4 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
   245a6:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   245aa:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
   245ae:	428e      	cmp	r6, r1
   245b0:	d00b      	beq.n	245ca <ready_thread+0x4e>
		return b2 - b1;
   245b2:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   245b4:	2900      	cmp	r1, #0
   245b6:	dd08      	ble.n	245ca <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
   245b8:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   245ba:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   245be:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   245c0:	6058      	str	r0, [r3, #4]
}
   245c2:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   245c4:	2000      	movs	r0, #0
   245c6:	f7ff bf3f 	b.w	24448 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   245ca:	42a3      	cmp	r3, r4
   245cc:	d002      	beq.n	245d4 <ready_thread+0x58>
   245ce:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   245d0:	2b00      	cmp	r3, #0
   245d2:	d1ea      	bne.n	245aa <ready_thread+0x2e>
	node->prev = tail;
   245d4:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
   245d8:	6020      	str	r0, [r4, #0]
	list->tail = node;
   245da:	6250      	str	r0, [r2, #36]	; 0x24
}
   245dc:	e7f1      	b.n	245c2 <ready_thread+0x46>
}
   245de:	bc70      	pop	{r4, r5, r6}
   245e0:	4770      	bx	lr
   245e2:	bf00      	nop
   245e4:	2000384c 	.word	0x2000384c

000245e8 <z_sched_start>:
{
   245e8:	b510      	push	{r4, lr}
	__asm__ volatile(
   245ea:	f04f 0220 	mov.w	r2, #32
   245ee:	f3ef 8411 	mrs	r4, BASEPRI
   245f2:	f382 8812 	msr	BASEPRI_MAX, r2
   245f6:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   245fa:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
   245fc:	0751      	lsls	r1, r2, #29
   245fe:	d404      	bmi.n	2460a <z_sched_start+0x22>
	__asm__ volatile(
   24600:	f384 8811 	msr	BASEPRI, r4
   24604:	f3bf 8f6f 	isb	sy
}
   24608:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2460a:	f022 0204 	bic.w	r2, r2, #4
   2460e:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   24610:	f7ff ffb4 	bl	2457c <ready_thread>
	z_reschedule(&sched_spinlock, key);
   24614:	4621      	mov	r1, r4
   24616:	4802      	ldr	r0, [pc, #8]	; (24620 <z_sched_start+0x38>)
}
   24618:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   2461c:	f7ff beee 	b.w	243fc <z_reschedule>
   24620:	20003f6e 	.word	0x20003f6e

00024624 <unready_thread>:
{
   24624:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   24626:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
   2462a:	7b43      	ldrb	r3, [r0, #13]
   2462c:	2a00      	cmp	r2, #0
{
   2462e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   24630:	da04      	bge.n	2463c <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   24632:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   24636:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   24638:	f008 fc25 	bl	2ce86 <sys_dlist_remove>
	update_cache(thread == _current);
   2463c:	4b04      	ldr	r3, [pc, #16]	; (24650 <unready_thread+0x2c>)
   2463e:	6898      	ldr	r0, [r3, #8]
   24640:	1a43      	subs	r3, r0, r1
   24642:	4258      	negs	r0, r3
   24644:	4158      	adcs	r0, r3
}
   24646:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   2464a:	f7ff befd 	b.w	24448 <update_cache>
   2464e:	bf00      	nop
   24650:	2000384c 	.word	0x2000384c

00024654 <pend>:
{
   24654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24658:	4606      	mov	r6, r0
   2465a:	4615      	mov	r5, r2
   2465c:	461c      	mov	r4, r3
	__asm__ volatile(
   2465e:	f04f 0320 	mov.w	r3, #32
   24662:	f3ef 8711 	mrs	r7, BASEPRI
   24666:	f383 8812 	msr	BASEPRI_MAX, r3
   2466a:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   2466e:	f008 fc97 	bl	2cfa0 <add_to_waitq_locked>
	__asm__ volatile(
   24672:	f387 8811 	msr	BASEPRI, r7
   24676:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2467a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   2467e:	bf08      	it	eq
   24680:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   24684:	d008      	beq.n	24698 <pend+0x44>
   24686:	462a      	mov	r2, r5
   24688:	4623      	mov	r3, r4
   2468a:	f106 0018 	add.w	r0, r6, #24
   2468e:	4903      	ldr	r1, [pc, #12]	; (2469c <pend+0x48>)
}
   24690:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   24694:	f000 ba60 	b.w	24b58 <z_add_timeout>
   24698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2469c:	0002cf5d 	.word	0x0002cf5d

000246a0 <z_pend_curr>:
{
   246a0:	b510      	push	{r4, lr}
	pending_current = _current;
   246a2:	4b07      	ldr	r3, [pc, #28]	; (246c0 <z_pend_curr+0x20>)
   246a4:	6898      	ldr	r0, [r3, #8]
   246a6:	4b07      	ldr	r3, [pc, #28]	; (246c4 <z_pend_curr+0x24>)
{
   246a8:	460c      	mov	r4, r1
	pending_current = _current;
   246aa:	6018      	str	r0, [r3, #0]
{
   246ac:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
   246ae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   246b2:	f7ff ffcf 	bl	24654 <pend>
   246b6:	4620      	mov	r0, r4
}
   246b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   246bc:	f7e0 b84c 	b.w	4758 <arch_swap>
   246c0:	2000384c 	.word	0x2000384c
   246c4:	2000387c 	.word	0x2000387c

000246c8 <z_set_prio>:
{
   246c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   246ca:	4604      	mov	r4, r0
	__asm__ volatile(
   246cc:	f04f 0320 	mov.w	r3, #32
   246d0:	f3ef 8611 	mrs	r6, BASEPRI
   246d4:	f383 8812 	msr	BASEPRI_MAX, r3
   246d8:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
   246dc:	7b43      	ldrb	r3, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   246de:	06da      	lsls	r2, r3, #27
				thread->base.prio = prio;
   246e0:	b249      	sxtb	r1, r1
   246e2:	d133      	bne.n	2474c <z_set_prio+0x84>
		if (need_sched) {
   246e4:	6982      	ldr	r2, [r0, #24]
   246e6:	bb8a      	cbnz	r2, 2474c <z_set_prio+0x84>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   246e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   246ec:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   246ee:	f008 fbca 	bl	2ce86 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   246f2:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
   246f4:	4a17      	ldr	r2, [pc, #92]	; (24754 <z_set_prio+0x8c>)
				thread->base.prio = prio;
   246f6:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   246f8:	f063 037f 	orn	r3, r3, #127	; 0x7f
   246fc:	7343      	strb	r3, [r0, #13]
   246fe:	4610      	mov	r0, r2
   24700:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24704:	4283      	cmp	r3, r0
   24706:	d01b      	beq.n	24740 <z_set_prio+0x78>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   24708:	b1d3      	cbz	r3, 24740 <z_set_prio+0x78>
	return (node == list->tail) ? NULL : node->next;
   2470a:	6a57      	ldr	r7, [r2, #36]	; 0x24
	int32_t b2 = thread_2->base.prio;
   2470c:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   24710:	42a9      	cmp	r1, r5
   24712:	d010      	beq.n	24736 <z_set_prio+0x6e>
		return b2 - b1;
   24714:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   24716:	2d00      	cmp	r5, #0
   24718:	dd0d      	ble.n	24736 <z_set_prio+0x6e>
	sys_dnode_t *const prev = successor->prev;
   2471a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2471c:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   24720:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   24722:	605c      	str	r4, [r3, #4]
			update_cache(1);
   24724:	2001      	movs	r0, #1
   24726:	f7ff fe8f 	bl	24448 <update_cache>
   2472a:	2001      	movs	r0, #1
	__asm__ volatile(
   2472c:	f386 8811 	msr	BASEPRI, r6
   24730:	f3bf 8f6f 	isb	sy
}
   24734:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   24736:	42bb      	cmp	r3, r7
   24738:	d002      	beq.n	24740 <z_set_prio+0x78>
   2473a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2473c:	2b00      	cmp	r3, #0
   2473e:	d1e5      	bne.n	2470c <z_set_prio+0x44>
	sys_dnode_t *const tail = list->tail;
   24740:	6a53      	ldr	r3, [r2, #36]	; 0x24
	node->prev = tail;
   24742:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
   24746:	601c      	str	r4, [r3, #0]
	list->tail = node;
   24748:	6254      	str	r4, [r2, #36]	; 0x24
}
   2474a:	e7eb      	b.n	24724 <z_set_prio+0x5c>
			thread->base.prio = prio;
   2474c:	73a1      	strb	r1, [r4, #14]
   2474e:	2000      	movs	r0, #0
   24750:	e7ec      	b.n	2472c <z_set_prio+0x64>
   24752:	bf00      	nop
   24754:	2000384c 	.word	0x2000384c

00024758 <z_impl_k_thread_suspend>:
{
   24758:	b570      	push	{r4, r5, r6, lr}
   2475a:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   2475c:	3018      	adds	r0, #24
   2475e:	f008 fca3 	bl	2d0a8 <z_abort_timeout>
	__asm__ volatile(
   24762:	f04f 0320 	mov.w	r3, #32
   24766:	f3ef 8611 	mrs	r6, BASEPRI
   2476a:	f383 8812 	msr	BASEPRI_MAX, r3
   2476e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   24772:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
   24776:	7b63      	ldrb	r3, [r4, #13]
   24778:	2a00      	cmp	r2, #0
   2477a:	da05      	bge.n	24788 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   2477c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   24780:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   24782:	4620      	mov	r0, r4
   24784:	f008 fb7f 	bl	2ce86 <sys_dlist_remove>
		update_cache(thread == _current);
   24788:	4d0b      	ldr	r5, [pc, #44]	; (247b8 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   2478a:	7b63      	ldrb	r3, [r4, #13]
   2478c:	68a8      	ldr	r0, [r5, #8]
   2478e:	f043 0310 	orr.w	r3, r3, #16
   24792:	7363      	strb	r3, [r4, #13]
   24794:	1b03      	subs	r3, r0, r4
   24796:	4258      	negs	r0, r3
   24798:	4158      	adcs	r0, r3
   2479a:	f7ff fe55 	bl	24448 <update_cache>
	__asm__ volatile(
   2479e:	f386 8811 	msr	BASEPRI, r6
   247a2:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   247a6:	68ab      	ldr	r3, [r5, #8]
   247a8:	42a3      	cmp	r3, r4
   247aa:	d103      	bne.n	247b4 <z_impl_k_thread_suspend+0x5c>
}
   247ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   247b0:	f008 bbb4 	b.w	2cf1c <z_reschedule_unlocked>
}
   247b4:	bd70      	pop	{r4, r5, r6, pc}
   247b6:	bf00      	nop
   247b8:	2000384c 	.word	0x2000384c

000247bc <k_sched_unlock>:
{
   247bc:	b510      	push	{r4, lr}
	__asm__ volatile(
   247be:	f04f 0320 	mov.w	r3, #32
   247c2:	f3ef 8411 	mrs	r4, BASEPRI
   247c6:	f383 8812 	msr	BASEPRI_MAX, r3
   247ca:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   247ce:	4b08      	ldr	r3, [pc, #32]	; (247f0 <k_sched_unlock+0x34>)
   247d0:	689a      	ldr	r2, [r3, #8]
   247d2:	7bd3      	ldrb	r3, [r2, #15]
   247d4:	3301      	adds	r3, #1
   247d6:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   247d8:	2000      	movs	r0, #0
   247da:	f7ff fe35 	bl	24448 <update_cache>
	__asm__ volatile(
   247de:	f384 8811 	msr	BASEPRI, r4
   247e2:	f3bf 8f6f 	isb	sy
}
   247e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   247ea:	f008 bb97 	b.w	2cf1c <z_reschedule_unlocked>
   247ee:	bf00      	nop
   247f0:	2000384c 	.word	0x2000384c

000247f4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   247f4:	4b04      	ldr	r3, [pc, #16]	; (24808 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   247f6:	2100      	movs	r1, #0
   247f8:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   247fc:	e9c3 2208 	strd	r2, r2, [r3, #32]
   24800:	4608      	mov	r0, r1
   24802:	f7ff bdcb 	b.w	2439c <k_sched_time_slice_set>
   24806:	bf00      	nop
   24808:	2000384c 	.word	0x2000384c

0002480c <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   2480c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   2480e:	f04f 0320 	mov.w	r3, #32
   24812:	f3ef 8511 	mrs	r5, BASEPRI
   24816:	f383 8812 	msr	BASEPRI_MAX, r3
   2481a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   2481e:	491a      	ldr	r1, [pc, #104]	; (24888 <z_impl_k_yield+0x7c>)
   24820:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   24822:	7b43      	ldrb	r3, [r0, #13]
   24824:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   24828:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   2482a:	f008 fb2c 	bl	2ce86 <sys_dlist_remove>
	}
	queue_thread(_current);
   2482e:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   24830:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
   24832:	4608      	mov	r0, r1
   24834:	f062 027f 	orn	r2, r2, #127	; 0x7f
   24838:	735a      	strb	r2, [r3, #13]
   2483a:	f850 2f20 	ldr.w	r2, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2483e:	4282      	cmp	r2, r0
   24840:	d01c      	beq.n	2487c <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   24842:	b1da      	cbz	r2, 2487c <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
   24844:	6a4f      	ldr	r7, [r1, #36]	; 0x24
	int32_t b1 = thread_1->base.prio;
   24846:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
   2484a:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
   2484e:	42a6      	cmp	r6, r4
   24850:	d00f      	beq.n	24872 <z_impl_k_yield+0x66>
		return b2 - b1;
   24852:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   24854:	2c00      	cmp	r4, #0
   24856:	dd0c      	ble.n	24872 <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
   24858:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   2485a:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
   2485e:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   24860:	6053      	str	r3, [r2, #4]
	update_cache(1);
   24862:	2001      	movs	r0, #1
   24864:	f7ff fdf0 	bl	24448 <update_cache>
   24868:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
   2486a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2486e:	f7df bf73 	b.w	4758 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   24872:	42ba      	cmp	r2, r7
   24874:	d002      	beq.n	2487c <z_impl_k_yield+0x70>
   24876:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   24878:	2a00      	cmp	r2, #0
   2487a:	d1e6      	bne.n	2484a <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
   2487c:	6a4a      	ldr	r2, [r1, #36]	; 0x24
	node->prev = tail;
   2487e:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
   24882:	6013      	str	r3, [r2, #0]
	list->tail = node;
   24884:	624b      	str	r3, [r1, #36]	; 0x24
}
   24886:	e7ec      	b.n	24862 <z_impl_k_yield+0x56>
   24888:	2000384c 	.word	0x2000384c

0002488c <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   2488c:	ea50 0301 	orrs.w	r3, r0, r1
{
   24890:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24894:	4605      	mov	r5, r0
   24896:	460e      	mov	r6, r1
	if (ticks == 0) {
   24898:	d103      	bne.n	248a2 <z_tick_sleep+0x16>
	z_impl_k_yield();
   2489a:	f7ff ffb7 	bl	2480c <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
   2489e:	2000      	movs	r0, #0
   248a0:	e033      	b.n	2490a <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
   248a2:	f06f 0401 	mvn.w	r4, #1
   248a6:	1a24      	subs	r4, r4, r0
   248a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   248ac:	eb63 0301 	sbc.w	r3, r3, r1
   248b0:	2c01      	cmp	r4, #1
   248b2:	f173 0300 	sbcs.w	r3, r3, #0
   248b6:	da02      	bge.n	248be <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   248b8:	f008 fc46 	bl	2d148 <sys_clock_tick_get_32>
   248bc:	1944      	adds	r4, r0, r5
   248be:	f04f 0320 	mov.w	r3, #32
   248c2:	f3ef 8811 	mrs	r8, BASEPRI
   248c6:	f383 8812 	msr	BASEPRI_MAX, r3
   248ca:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   248ce:	4f10      	ldr	r7, [pc, #64]	; (24910 <z_tick_sleep+0x84>)
   248d0:	4b10      	ldr	r3, [pc, #64]	; (24914 <z_tick_sleep+0x88>)
   248d2:	68b8      	ldr	r0, [r7, #8]
   248d4:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   248d6:	f7ff fea5 	bl	24624 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   248da:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   248dc:	490e      	ldr	r1, [pc, #56]	; (24918 <z_tick_sleep+0x8c>)
   248de:	462a      	mov	r2, r5
   248e0:	4633      	mov	r3, r6
   248e2:	3018      	adds	r0, #24
   248e4:	f000 f938 	bl	24b58 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   248e8:	68ba      	ldr	r2, [r7, #8]
   248ea:	7b53      	ldrb	r3, [r2, #13]
   248ec:	f043 0310 	orr.w	r3, r3, #16
   248f0:	7353      	strb	r3, [r2, #13]
   248f2:	4640      	mov	r0, r8
   248f4:	f7df ff30 	bl	4758 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   248f8:	f008 fc26 	bl	2d148 <sys_clock_tick_get_32>
   248fc:	1a20      	subs	r0, r4, r0
   248fe:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   24902:	2801      	cmp	r0, #1
   24904:	f173 0300 	sbcs.w	r3, r3, #0
   24908:	dbc9      	blt.n	2489e <z_tick_sleep+0x12>
}
   2490a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2490e:	bf00      	nop
   24910:	2000384c 	.word	0x2000384c
   24914:	2000387c 	.word	0x2000387c
   24918:	0002cf5d 	.word	0x0002cf5d

0002491c <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2491c:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   24920:	bf08      	it	eq
   24922:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   24926:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24928:	d106      	bne.n	24938 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   2492a:	4b08      	ldr	r3, [pc, #32]	; (2494c <z_impl_k_sleep+0x30>)
   2492c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   2492e:	f7ff ff13 	bl	24758 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   24932:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   24936:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   24938:	f7ff ffa8 	bl	2488c <z_tick_sleep>
			return ((t * to_hz + off) / from_hz);
   2493c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   24940:	fb80 0303 	smull	r0, r3, r0, r3
   24944:	0bc0      	lsrs	r0, r0, #15
   24946:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   2494a:	e7f4      	b.n	24936 <z_impl_k_sleep+0x1a>
   2494c:	2000384c 	.word	0x2000384c

00024950 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   24950:	4b01      	ldr	r3, [pc, #4]	; (24958 <z_impl_z_current_get+0x8>)
   24952:	6898      	ldr	r0, [r3, #8]
   24954:	4770      	bx	lr
   24956:	bf00      	nop
   24958:	2000384c 	.word	0x2000384c

0002495c <z_impl_k_is_preempt_thread>:
   2495c:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
   24960:	b93b      	cbnz	r3, 24972 <z_impl_k_is_preempt_thread+0x16>
   24962:	4b05      	ldr	r3, [pc, #20]	; (24978 <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   24964:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
   24966:	89d8      	ldrh	r0, [r3, #14]
   24968:	287f      	cmp	r0, #127	; 0x7f
   2496a:	bf8c      	ite	hi
   2496c:	2000      	movhi	r0, #0
   2496e:	2001      	movls	r0, #1
   24970:	4770      	bx	lr
   24972:	2000      	movs	r0, #0
}
   24974:	4770      	bx	lr
   24976:	bf00      	nop
   24978:	2000384c 	.word	0x2000384c

0002497c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   2497c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24980:	4604      	mov	r4, r0
   24982:	f04f 0320 	mov.w	r3, #32
   24986:	f3ef 8611 	mrs	r6, BASEPRI
   2498a:	f383 8812 	msr	BASEPRI_MAX, r3
   2498e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   24992:	7b43      	ldrb	r3, [r0, #13]
   24994:	071a      	lsls	r2, r3, #28
   24996:	d505      	bpl.n	249a4 <z_thread_abort+0x28>
	__asm__ volatile(
   24998:	f386 8811 	msr	BASEPRI, r6
   2499c:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   249a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   249a4:	f023 0220 	bic.w	r2, r3, #32
   249a8:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   249ac:	09d2      	lsrs	r2, r2, #7
   249ae:	d120      	bne.n	249f2 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   249b0:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   249b2:	68a3      	ldr	r3, [r4, #8]
   249b4:	b113      	cbz	r3, 249bc <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   249b6:	4620      	mov	r0, r4
   249b8:	f008 fa6d 	bl	2ce96 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   249bc:	f104 0018 	add.w	r0, r4, #24
   249c0:	f008 fb72 	bl	2d0a8 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   249c4:	f104 0758 	add.w	r7, r4, #88	; 0x58
   249c8:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
   249cc:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   249ce:	42bd      	cmp	r5, r7
   249d0:	d000      	beq.n	249d4 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   249d2:	b9b5      	cbnz	r5, 24a02 <z_thread_abort+0x86>
		update_cache(1);
   249d4:	2001      	movs	r0, #1
   249d6:	f7ff fd37 	bl	24448 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   249da:	4b10      	ldr	r3, [pc, #64]	; (24a1c <z_thread_abort+0xa0>)
   249dc:	689b      	ldr	r3, [r3, #8]
   249de:	42a3      	cmp	r3, r4
   249e0:	d1da      	bne.n	24998 <z_thread_abort+0x1c>
   249e2:	f3ef 8305 	mrs	r3, IPSR
   249e6:	2b00      	cmp	r3, #0
   249e8:	d1d6      	bne.n	24998 <z_thread_abort+0x1c>
   249ea:	4630      	mov	r0, r6
   249ec:	f7df feb4 	bl	4758 <arch_swap>
	return ret;
   249f0:	e7d2      	b.n	24998 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   249f2:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   249f6:	f043 0308 	orr.w	r3, r3, #8
   249fa:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   249fc:	f008 fa43 	bl	2ce86 <sys_dlist_remove>
}
   24a00:	e7d7      	b.n	249b2 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   24a02:	4628      	mov	r0, r5
   24a04:	f008 fa47 	bl	2ce96 <unpend_thread_no_timeout>
   24a08:	f105 0018 	add.w	r0, r5, #24
   24a0c:	f008 fb4c 	bl	2d0a8 <z_abort_timeout>
   24a10:	f8c5 807c 	str.w	r8, [r5, #124]	; 0x7c
		ready_thread(thread);
   24a14:	4628      	mov	r0, r5
   24a16:	f7ff fdb1 	bl	2457c <ready_thread>
   24a1a:	e7d7      	b.n	249cc <z_thread_abort+0x50>
   24a1c:	2000384c 	.word	0x2000384c

00024a20 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   24a20:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   24a22:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
   24a26:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   24a28:	e9cd 6700 	strd	r6, r7, [sp]
   24a2c:	f7ff fe38 	bl	246a0 <z_pend_curr>

	if (data != NULL) {
   24a30:	b11c      	cbz	r4, 24a3a <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
   24a32:	4b03      	ldr	r3, [pc, #12]	; (24a40 <z_sched_wait+0x20>)
   24a34:	689b      	ldr	r3, [r3, #8]
   24a36:	695b      	ldr	r3, [r3, #20]
   24a38:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   24a3a:	b002      	add	sp, #8
   24a3c:	bdd0      	pop	{r4, r6, r7, pc}
   24a3e:	bf00      	nop
   24a40:	2000384c 	.word	0x2000384c

00024a44 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   24a44:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   24a46:	4806      	ldr	r0, [pc, #24]	; (24a60 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   24a48:	4a06      	ldr	r2, [pc, #24]	; (24a64 <z_data_copy+0x20>)
   24a4a:	4907      	ldr	r1, [pc, #28]	; (24a68 <z_data_copy+0x24>)
   24a4c:	1a12      	subs	r2, r2, r0
   24a4e:	f002 ff0f 	bl	27870 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   24a52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   24a56:	4a05      	ldr	r2, [pc, #20]	; (24a6c <z_data_copy+0x28>)
   24a58:	4905      	ldr	r1, [pc, #20]	; (24a70 <z_data_copy+0x2c>)
   24a5a:	4806      	ldr	r0, [pc, #24]	; (24a74 <z_data_copy+0x30>)
   24a5c:	f002 bf08 	b.w	27870 <memcpy>
   24a60:	20000000 	.word	0x20000000
   24a64:	200010ec 	.word	0x200010ec
   24a68:	00034ee0 	.word	0x00034ee0
   24a6c:	00000000 	.word	0x00000000
   24a70:	00034ee0 	.word	0x00034ee0
   24a74:	20000000 	.word	0x20000000

00024a78 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   24a78:	4b03      	ldr	r3, [pc, #12]	; (24a88 <elapsed+0x10>)
   24a7a:	681b      	ldr	r3, [r3, #0]
   24a7c:	b90b      	cbnz	r3, 24a82 <elapsed+0xa>
   24a7e:	f7fd bd09 	b.w	22494 <sys_clock_elapsed>
}
   24a82:	2000      	movs	r0, #0
   24a84:	4770      	bx	lr
   24a86:	bf00      	nop
   24a88:	20003888 	.word	0x20003888

00024a8c <next_timeout>:
	return list->head == list;
   24a8c:	4b10      	ldr	r3, [pc, #64]	; (24ad0 <next_timeout+0x44>)

static int32_t next_timeout(void)
{
   24a8e:	b510      	push	{r4, lr}
   24a90:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24a92:	429c      	cmp	r4, r3
   24a94:	bf08      	it	eq
   24a96:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   24a98:	f7ff ffee 	bl	24a78 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
   24a9c:	b1a4      	cbz	r4, 24ac8 <next_timeout+0x3c>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   24a9e:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   24aa2:	1a1b      	subs	r3, r3, r0
   24aa4:	eb62 70e0 	sbc.w	r0, r2, r0, asr #31
	if ((to == NULL) ||
   24aa8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   24aac:	f170 0200 	sbcs.w	r2, r0, #0
   24ab0:	da0a      	bge.n	24ac8 <next_timeout+0x3c>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
   24ab2:	2800      	cmp	r0, #0
   24ab4:	bfac      	ite	ge
   24ab6:	4618      	movge	r0, r3
   24ab8:	2000      	movlt	r0, #0
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   24aba:	4b06      	ldr	r3, [pc, #24]	; (24ad4 <next_timeout+0x48>)
   24abc:	691b      	ldr	r3, [r3, #16]
   24abe:	b113      	cbz	r3, 24ac6 <next_timeout+0x3a>
   24ac0:	4298      	cmp	r0, r3
   24ac2:	bfa8      	it	ge
   24ac4:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   24ac6:	bd10      	pop	{r4, pc}
		ret = MAX_WAIT;
   24ac8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   24acc:	e7f5      	b.n	24aba <next_timeout+0x2e>
   24ace:	bf00      	nop
   24ad0:	20000cdc 	.word	0x20000cdc
   24ad4:	2000384c 	.word	0x2000384c

00024ad8 <remove_timeout>:
{
   24ad8:	b530      	push	{r4, r5, lr}
	return (node == list->tail) ? NULL : node->next;
   24ada:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   24adc:	b168      	cbz	r0, 24afa <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   24ade:	4a0a      	ldr	r2, [pc, #40]	; (24b08 <remove_timeout+0x30>)
   24ae0:	6852      	ldr	r2, [r2, #4]
   24ae2:	4290      	cmp	r0, r2
   24ae4:	d009      	beq.n	24afa <remove_timeout+0x22>
	if (next(t) != NULL) {
   24ae6:	b143      	cbz	r3, 24afa <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   24ae8:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   24aec:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   24af0:	1912      	adds	r2, r2, r4
   24af2:	eb41 0105 	adc.w	r1, r1, r5
   24af6:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   24afa:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   24afc:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   24afe:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   24b00:	2300      	movs	r3, #0
	node->prev = NULL;
   24b02:	e9c0 3300 	strd	r3, r3, [r0]
}
   24b06:	bd30      	pop	{r4, r5, pc}
   24b08:	20000cdc 	.word	0x20000cdc

00024b0c <timeout_rem>:
	return ret;
}

/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
   24b0c:	b570      	push	{r4, r5, r6, lr}
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   24b0e:	6804      	ldr	r4, [r0, #0]
   24b10:	b1e4      	cbz	r4, 24b4c <timeout_rem+0x40>
	return list->head == list;
   24b12:	4a10      	ldr	r2, [pc, #64]	; (24b54 <timeout_rem+0x48>)
   24b14:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24b16:	4293      	cmp	r3, r2
   24b18:	d015      	beq.n	24b46 <timeout_rem+0x3a>
	return (node == list->tail) ? NULL : node->next;
   24b1a:	2400      	movs	r4, #0
   24b1c:	6851      	ldr	r1, [r2, #4]
   24b1e:	4625      	mov	r5, r4
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   24b20:	b933      	cbnz	r3, 24b30 <timeout_rem+0x24>
		if (timeout == t) {
			break;
		}
	}

	return ticks - elapsed();
   24b22:	f7ff ffa9 	bl	24a78 <elapsed>
   24b26:	4601      	mov	r1, r0
   24b28:	1a20      	subs	r0, r4, r0
   24b2a:	eb65 71e1 	sbc.w	r1, r5, r1, asr #31
}
   24b2e:	bd70      	pop	{r4, r5, r6, pc}
		ticks += t->dticks;
   24b30:	e9d3 2604 	ldrd	r2, r6, [r3, #16]
   24b34:	18a4      	adds	r4, r4, r2
   24b36:	eb45 0506 	adc.w	r5, r5, r6
		if (timeout == t) {
   24b3a:	4283      	cmp	r3, r0
   24b3c:	d0f1      	beq.n	24b22 <timeout_rem+0x16>
   24b3e:	428b      	cmp	r3, r1
   24b40:	d0ef      	beq.n	24b22 <timeout_rem+0x16>
   24b42:	681b      	ldr	r3, [r3, #0]
   24b44:	e7ec      	b.n	24b20 <timeout_rem+0x14>
   24b46:	2400      	movs	r4, #0
   24b48:	4625      	mov	r5, r4
   24b4a:	e7ea      	b.n	24b22 <timeout_rem+0x16>
		return 0;
   24b4c:	4620      	mov	r0, r4
   24b4e:	4621      	mov	r1, r4
   24b50:	e7ed      	b.n	24b2e <timeout_rem+0x22>
   24b52:	bf00      	nop
   24b54:	20000cdc 	.word	0x20000cdc

00024b58 <z_add_timeout>:
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24b58:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24b5c:	bf08      	it	eq
   24b5e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   24b62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24b64:	4604      	mov	r4, r0
   24b66:	461f      	mov	r7, r3
   24b68:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24b6a:	d067      	beq.n	24c3c <z_add_timeout+0xe4>
	to->fn = fn;
   24b6c:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   24b6e:	f04f 0320 	mov.w	r3, #32
   24b72:	f3ef 8611 	mrs	r6, BASEPRI
   24b76:	f383 8812 	msr	BASEPRI_MAX, r3
   24b7a:	f3bf 8f6f 	isb	sy
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   24b7e:	f06f 0201 	mvn.w	r2, #1
   24b82:	1b53      	subs	r3, r2, r5
   24b84:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   24b88:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   24b8c:	2b00      	cmp	r3, #0
   24b8e:	db1b      	blt.n	24bc8 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   24b90:	4b2b      	ldr	r3, [pc, #172]	; (24c40 <z_add_timeout+0xe8>)
   24b92:	e9d3 1300 	ldrd	r1, r3, [r3]
   24b96:	1a52      	subs	r2, r2, r1
   24b98:	eb6c 0303 	sbc.w	r3, ip, r3
   24b9c:	1b55      	subs	r5, r2, r5
			to->dticks = MAX(1, ticks);
   24b9e:	eb63 0307 	sbc.w	r3, r3, r7
   24ba2:	2d01      	cmp	r5, #1
   24ba4:	f173 0200 	sbcs.w	r2, r3, #0
   24ba8:	bfbc      	itt	lt
   24baa:	2501      	movlt	r5, #1
   24bac:	2300      	movlt	r3, #0
   24bae:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
   24bb2:	4824      	ldr	r0, [pc, #144]	; (24c44 <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
   24bb4:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24bb8:	4283      	cmp	r3, r0
   24bba:	d118      	bne.n	24bee <z_add_timeout+0x96>
	node->prev = tail;
   24bbc:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
   24bc0:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   24bc4:	6044      	str	r4, [r0, #4]
}
   24bc6:	e026      	b.n	24c16 <z_add_timeout+0xbe>
			to->dticks = timeout.ticks + 1 + elapsed();
   24bc8:	f7ff ff56 	bl	24a78 <elapsed>
   24bcc:	3501      	adds	r5, #1
   24bce:	f147 0700 	adc.w	r7, r7, #0
   24bd2:	182d      	adds	r5, r5, r0
   24bd4:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
   24bd8:	e9c4 5704 	strd	r5, r7, [r4, #16]
   24bdc:	e7e9      	b.n	24bb2 <z_add_timeout+0x5a>
			to->dticks -= t->dticks;
   24bde:	1a52      	subs	r2, r2, r1
   24be0:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
   24be4:	459c      	cmp	ip, r3
   24be6:	e9c4 2504 	strd	r2, r5, [r4, #16]
   24bea:	d0e7      	beq.n	24bbc <z_add_timeout+0x64>
   24bec:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   24bee:	2b00      	cmp	r3, #0
   24bf0:	d0e4      	beq.n	24bbc <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
   24bf2:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
   24bf6:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
   24bfa:	428a      	cmp	r2, r1
   24bfc:	eb75 0e07 	sbcs.w	lr, r5, r7
   24c00:	daed      	bge.n	24bde <z_add_timeout+0x86>
				t->dticks -= to->dticks;
   24c02:	1a8a      	subs	r2, r1, r2
   24c04:	eb67 0505 	sbc.w	r5, r7, r5
   24c08:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   24c0c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   24c0e:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   24c12:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   24c14:	605c      	str	r4, [r3, #4]
	return list->head == list;
   24c16:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24c18:	4283      	cmp	r3, r0
   24c1a:	d00b      	beq.n	24c34 <z_add_timeout+0xdc>
		if (to == first()) {
   24c1c:	429c      	cmp	r4, r3
   24c1e:	d109      	bne.n	24c34 <z_add_timeout+0xdc>
			int32_t next_time = next_timeout();
   24c20:	f7ff ff34 	bl	24a8c <next_timeout>
			if (next_time == 0 ||
   24c24:	b118      	cbz	r0, 24c2e <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
   24c26:	4b08      	ldr	r3, [pc, #32]	; (24c48 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
   24c28:	691b      	ldr	r3, [r3, #16]
   24c2a:	4283      	cmp	r3, r0
   24c2c:	d002      	beq.n	24c34 <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
   24c2e:	2100      	movs	r1, #0
   24c30:	f7fd fbfe 	bl	22430 <sys_clock_set_timeout>
	__asm__ volatile(
   24c34:	f386 8811 	msr	BASEPRI, r6
   24c38:	f3bf 8f6f 	isb	sy
}
   24c3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24c3e:	bf00      	nop
   24c40:	200024a0 	.word	0x200024a0
   24c44:	20000cdc 	.word	0x20000cdc
   24c48:	2000384c 	.word	0x2000384c

00024c4c <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   24c4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24c50:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   24c52:	f7ff fc53 	bl	244fc <z_time_slice>
	__asm__ volatile(
   24c56:	f04f 0320 	mov.w	r3, #32
   24c5a:	f3ef 8411 	mrs	r4, BASEPRI
   24c5e:	f383 8812 	msr	BASEPRI_MAX, r3
   24c62:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   24c66:	4e24      	ldr	r6, [pc, #144]	; (24cf8 <sys_clock_announce+0xac>)
	return list->head == list;
   24c68:	f8df 8090 	ldr.w	r8, [pc, #144]	; 24cfc <sys_clock_announce+0xb0>
   24c6c:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   24c6e:	4d24      	ldr	r5, [pc, #144]	; (24d00 <sys_clock_announce+0xb4>)
   24c70:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
   24c74:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24c76:	4540      	cmp	r0, r8
		curr_tick += dt;
   24c78:	e9d5 1e00 	ldrd	r1, lr, [r5]
   24c7c:	ea4f 77e2 	mov.w	r7, r2, asr #31
   24c80:	d00b      	beq.n	24c9a <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
   24c82:	b150      	cbz	r0, 24c9a <sys_clock_announce+0x4e>
   24c84:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
   24c88:	429a      	cmp	r2, r3
   24c8a:	eb77 090c 	sbcs.w	r9, r7, ip
   24c8e:	da16      	bge.n	24cbe <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   24c90:	1a9b      	subs	r3, r3, r2
   24c92:	eb6c 0c07 	sbc.w	ip, ip, r7
   24c96:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
   24c9a:	1852      	adds	r2, r2, r1
   24c9c:	eb4e 0707 	adc.w	r7, lr, r7
   24ca0:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
   24ca4:	2500      	movs	r5, #0
   24ca6:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
   24ca8:	f7ff fef0 	bl	24a8c <next_timeout>
   24cac:	4629      	mov	r1, r5
   24cae:	f7fd fbbf 	bl	22430 <sys_clock_set_timeout>
	__asm__ volatile(
   24cb2:	f384 8811 	msr	BASEPRI, r4
   24cb6:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   24cba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
   24cbe:	1859      	adds	r1, r3, r1
   24cc0:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
   24cc4:	1ad3      	subs	r3, r2, r3
   24cc6:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   24cc8:	2200      	movs	r2, #0
   24cca:	2300      	movs	r3, #0
   24ccc:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
   24cd0:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
   24cd4:	f7ff ff00 	bl	24ad8 <remove_timeout>
   24cd8:	f384 8811 	msr	BASEPRI, r4
   24cdc:	f3bf 8f6f 	isb	sy
		t->fn(t);
   24ce0:	6883      	ldr	r3, [r0, #8]
   24ce2:	4798      	blx	r3
	__asm__ volatile(
   24ce4:	f04f 0320 	mov.w	r3, #32
   24ce8:	f3ef 8411 	mrs	r4, BASEPRI
   24cec:	f383 8812 	msr	BASEPRI_MAX, r3
   24cf0:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   24cf4:	e7bc      	b.n	24c70 <sys_clock_announce+0x24>
   24cf6:	bf00      	nop
   24cf8:	20003888 	.word	0x20003888
   24cfc:	20000cdc 	.word	0x20000cdc
   24d00:	200024a0 	.word	0x200024a0

00024d04 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   24d04:	b510      	push	{r4, lr}
   24d06:	f04f 0320 	mov.w	r3, #32
   24d0a:	f3ef 8411 	mrs	r4, BASEPRI
   24d0e:	f383 8812 	msr	BASEPRI_MAX, r3
   24d12:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   24d16:	f7fd fbbd 	bl	22494 <sys_clock_elapsed>
   24d1a:	4a05      	ldr	r2, [pc, #20]	; (24d30 <sys_clock_tick_get+0x2c>)
   24d1c:	e9d2 3100 	ldrd	r3, r1, [r2]
   24d20:	18c0      	adds	r0, r0, r3
   24d22:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
   24d26:	f384 8811 	msr	BASEPRI, r4
   24d2a:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   24d2e:	bd10      	pop	{r4, pc}
   24d30:	200024a0 	.word	0x200024a0

00024d34 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   24d34:	b570      	push	{r4, r5, r6, lr}
   24d36:	4604      	mov	r4, r0
	__asm__ volatile(
   24d38:	f04f 0320 	mov.w	r3, #32
   24d3c:	f3ef 8511 	mrs	r5, BASEPRI
   24d40:	f383 8812 	msr	BASEPRI_MAX, r3
   24d44:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   24d48:	e9d0 320a 	ldrd	r3, r2, [r0, #40]	; 0x28
   24d4c:	3301      	adds	r3, #1
   24d4e:	f142 0200 	adc.w	r2, r2, #0
   24d52:	2b02      	cmp	r3, #2
   24d54:	f172 0300 	sbcs.w	r3, r2, #0
   24d58:	d304      	bcc.n	24d64 <z_timer_expiration_handler+0x30>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24d5a:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   24d5e:	4917      	ldr	r1, [pc, #92]	; (24dbc <z_timer_expiration_handler+0x88>)
   24d60:	f7ff fefa 	bl	24b58 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   24d64:	6b23      	ldr	r3, [r4, #48]	; 0x30
   24d66:	3301      	adds	r3, #1
   24d68:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   24d6a:	6a23      	ldr	r3, [r4, #32]
   24d6c:	b173      	cbz	r3, 24d8c <z_timer_expiration_handler+0x58>
	__asm__ volatile(
   24d6e:	f385 8811 	msr	BASEPRI, r5
   24d72:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   24d76:	6a23      	ldr	r3, [r4, #32]
   24d78:	4620      	mov	r0, r4
   24d7a:	4798      	blx	r3
	__asm__ volatile(
   24d7c:	f04f 0320 	mov.w	r3, #32
   24d80:	f3ef 8511 	mrs	r5, BASEPRI
   24d84:	f383 8812 	msr	BASEPRI_MAX, r3
   24d88:	f3bf 8f6f 	isb	sy
	return list->head == list;
   24d8c:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24d90:	42a6      	cmp	r6, r4
   24d92:	d000      	beq.n	24d96 <z_timer_expiration_handler+0x62>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   24d94:	b926      	cbnz	r6, 24da0 <z_timer_expiration_handler+0x6c>
	__asm__ volatile(
   24d96:	f385 8811 	msr	BASEPRI, r5
   24d9a:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   24d9e:	bd70      	pop	{r4, r5, r6, pc}
	z_unpend_thread_no_timeout(thread);
   24da0:	4630      	mov	r0, r6
   24da2:	f008 f88b 	bl	2cebc <z_unpend_thread_no_timeout>
   24da6:	2300      	movs	r3, #0
   24da8:	67f3      	str	r3, [r6, #124]	; 0x7c
   24daa:	f385 8811 	msr	BASEPRI, r5
   24dae:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   24db2:	4630      	mov	r0, r6
}
   24db4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
   24db8:	f008 b8c0 	b.w	2cf3c <z_ready_thread>
   24dbc:	00024d35 	.word	0x00024d35

00024dc0 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   24dc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24dc4:	4611      	mov	r1, r2
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24dc6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24dca:	bf08      	it	eq
   24dcc:	f1b1 3fff 	cmpeq.w	r1, #4294967295	; 0xffffffff
{
   24dd0:	4606      	mov	r6, r0
   24dd2:	461c      	mov	r4, r3
   24dd4:	e9dd 2008 	ldrd	r2, r0, [sp, #32]
   24dd8:	4689      	mov	r9, r1
   24dda:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24ddc:	d03e      	beq.n	24e5c <z_impl_k_timer_start+0x9c>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   24dde:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   24de2:	bf08      	it	eq
   24de4:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   24de8:	4615      	mov	r5, r2
   24dea:	4607      	mov	r7, r0
   24dec:	d014      	beq.n	24e18 <z_impl_k_timer_start+0x58>
   24dee:	ea50 0302 	orrs.w	r3, r0, r2
   24df2:	d011      	beq.n	24e18 <z_impl_k_timer_start+0x58>
	    Z_TICK_ABS(period.ticks) < 0) {
   24df4:	f06f 0301 	mvn.w	r3, #1
   24df8:	1a9b      	subs	r3, r3, r2
   24dfa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24dfe:	eb63 0300 	sbc.w	r3, r3, r0
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   24e02:	2b00      	cmp	r3, #0
   24e04:	da08      	bge.n	24e18 <z_impl_k_timer_start+0x58>
		period.ticks = MAX(period.ticks - 1, 1);
   24e06:	2a02      	cmp	r2, #2
   24e08:	f170 0300 	sbcs.w	r3, r0, #0
   24e0c:	bfbc      	itt	lt
   24e0e:	2502      	movlt	r5, #2
   24e10:	2700      	movlt	r7, #0
   24e12:	3d01      	subs	r5, #1
   24e14:	f147 37ff 	adc.w	r7, r7, #4294967295	; 0xffffffff
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   24e18:	f06f 0301 	mvn.w	r3, #1
   24e1c:	1a5b      	subs	r3, r3, r1
   24e1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24e22:	eb63 0304 	sbc.w	r3, r3, r4
   24e26:	2b00      	cmp	r3, #0
   24e28:	da09      	bge.n	24e3e <z_impl_k_timer_start+0x7e>
		duration.ticks = MAX(duration.ticks - 1, 0);
   24e2a:	2901      	cmp	r1, #1
   24e2c:	f174 0300 	sbcs.w	r3, r4, #0
   24e30:	bfbc      	itt	lt
   24e32:	2101      	movlt	r1, #1
   24e34:	2400      	movlt	r4, #0
   24e36:	f111 39ff 	adds.w	r9, r1, #4294967295	; 0xffffffff
   24e3a:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
   24e3e:	4630      	mov	r0, r6
   24e40:	f008 f932 	bl	2d0a8 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   24e44:	2300      	movs	r3, #0
   24e46:	6333      	str	r3, [r6, #48]	; 0x30
	timer->period = period;
   24e48:	e9c6 570a 	strd	r5, r7, [r6, #40]	; 0x28

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24e4c:	464a      	mov	r2, r9
   24e4e:	4643      	mov	r3, r8
   24e50:	4630      	mov	r0, r6
   24e52:	4903      	ldr	r1, [pc, #12]	; (24e60 <z_impl_k_timer_start+0xa0>)
		     duration);
}
   24e54:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24e58:	f7ff be7e 	b.w	24b58 <z_add_timeout>
}
   24e5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24e60:	00024d35 	.word	0x00024d35

00024e64 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   24e64:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   24e68:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
   24e6a:	4b29      	ldr	r3, [pc, #164]	; (24f10 <z_impl_k_poll+0xac>)
   24e6c:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
   24e6e:	2301      	movs	r3, #1
   24e70:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	poller->mode = MODE_POLL;
   24e74:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
   24e78:	ea52 0305 	orrs.w	r3, r2, r5
{
   24e7c:	4616      	mov	r6, r2
	events_registered = register_events(events, num_events, poller,
   24e7e:	bf0c      	ite	eq
   24e80:	2301      	moveq	r3, #1
   24e82:	2300      	movne	r3, #0
   24e84:	f107 0260 	add.w	r2, r7, #96	; 0x60
{
   24e88:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
   24e8a:	f008 f9ea 	bl	2d262 <register_events>
   24e8e:	4681      	mov	r9, r0
	__asm__ volatile(
   24e90:	f04f 0320 	mov.w	r3, #32
   24e94:	f3ef 8a11 	mrs	sl, BASEPRI
   24e98:	f383 8812 	msr	BASEPRI_MAX, r3
   24e9c:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
   24ea0:	f897 4060 	ldrb.w	r4, [r7, #96]	; 0x60
   24ea4:	b964      	cbnz	r4, 24ec0 <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
   24ea6:	4601      	mov	r1, r0
   24ea8:	4652      	mov	r2, sl
   24eaa:	4640      	mov	r0, r8
   24eac:	f008 faaa 	bl	2d404 <clear_event_registrations>
	__asm__ volatile(
   24eb0:	f38a 8811 	msr	BASEPRI, sl
   24eb4:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
   24eb8:	4620      	mov	r0, r4
   24eba:	b002      	add	sp, #8
   24ebc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
   24ec0:	2300      	movs	r3, #0
   24ec2:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   24ec6:	ea56 0305 	orrs.w	r3, r6, r5
   24eca:	d106      	bne.n	24eda <z_impl_k_poll+0x76>
   24ecc:	f38a 8811 	msr	BASEPRI, sl
   24ed0:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   24ed4:	f06f 040a 	mvn.w	r4, #10
   24ed8:	e7ee      	b.n	24eb8 <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   24eda:	e9cd 6500 	strd	r6, r5, [sp]
   24ede:	4a0d      	ldr	r2, [pc, #52]	; (24f14 <z_impl_k_poll+0xb0>)
   24ee0:	480d      	ldr	r0, [pc, #52]	; (24f18 <z_impl_k_poll+0xb4>)
   24ee2:	4651      	mov	r1, sl
   24ee4:	f7ff fbdc 	bl	246a0 <z_pend_curr>
   24ee8:	4604      	mov	r4, r0
	__asm__ volatile(
   24eea:	f04f 0320 	mov.w	r3, #32
   24eee:	f3ef 8511 	mrs	r5, BASEPRI
   24ef2:	f383 8812 	msr	BASEPRI_MAX, r3
   24ef6:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
   24efa:	462a      	mov	r2, r5
   24efc:	4649      	mov	r1, r9
   24efe:	4640      	mov	r0, r8
   24f00:	f008 fa80 	bl	2d404 <clear_event_registrations>
	__asm__ volatile(
   24f04:	f385 8811 	msr	BASEPRI, r5
   24f08:	f3bf 8f6f 	isb	sy
	return swap_rc;
   24f0c:	e7d4      	b.n	24eb8 <z_impl_k_poll+0x54>
   24f0e:	bf00      	nop
   24f10:	2000384c 	.word	0x2000384c
   24f14:	20000ce4 	.word	0x20000ce4
   24f18:	20003f6e 	.word	0x20003f6e

00024f1c <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
   24f1c:	b538      	push	{r3, r4, r5, lr}
   24f1e:	4603      	mov	r3, r0
	__asm__ volatile(
   24f20:	f04f 0220 	mov.w	r2, #32
   24f24:	f3ef 8511 	mrs	r5, BASEPRI
   24f28:	f382 8812 	msr	BASEPRI_MAX, r2
   24f2c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
   24f30:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
   24f32:	2101      	movs	r1, #1
   24f34:	6081      	str	r1, [r0, #8]
	return list->head == list;
   24f36:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   24f38:	4283      	cmp	r3, r0
   24f3a:	d106      	bne.n	24f4a <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   24f3c:	f385 8811 	msr	BASEPRI, r5
   24f40:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
   24f44:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
   24f46:	4620      	mov	r0, r4
   24f48:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
   24f4a:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   24f4e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   24f50:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   24f52:	2300      	movs	r3, #0
	node->prev = NULL;
   24f54:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   24f58:	f008 f9fa 	bl	2d350 <signal_poll_event>
	z_reschedule(&lock, key);
   24f5c:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   24f5e:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   24f60:	4801      	ldr	r0, [pc, #4]	; (24f68 <z_impl_k_poll_signal_raise+0x4c>)
   24f62:	f7ff fa4b 	bl	243fc <z_reschedule>
	return rc;
   24f66:	e7ee      	b.n	24f46 <z_impl_k_poll_signal_raise+0x2a>
   24f68:	20003f6e 	.word	0x20003f6e

00024f6c <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   24f6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   24f6e:	4606      	mov	r6, r0
   24f70:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   24f72:	f007 fd74 	bl	2ca5e <k_is_in_isr>
   24f76:	b978      	cbnz	r0, 24f98 <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   24f78:	4b0b      	ldr	r3, [pc, #44]	; (24fa8 <z_thread_aligned_alloc+0x3c>)
   24f7a:	689b      	ldr	r3, [r3, #8]
   24f7c:	6f5c      	ldr	r4, [r3, #116]	; 0x74
	}

	if (heap != NULL) {
   24f7e:	b17c      	cbz	r4, 24fa0 <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   24f80:	1d2a      	adds	r2, r5, #4
   24f82:	d209      	bcs.n	24f98 <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   24f84:	2000      	movs	r0, #0
   24f86:	2100      	movs	r1, #0
   24f88:	e9cd 0100 	strd	r0, r1, [sp]
   24f8c:	f046 0104 	orr.w	r1, r6, #4
   24f90:	4620      	mov	r0, r4
   24f92:	f007 fcdd 	bl	2c950 <k_heap_aligned_alloc>
	if (mem == NULL) {
   24f96:	b908      	cbnz	r0, 24f9c <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
   24f98:	2400      	movs	r4, #0
	}

	return ret;
   24f9a:	e001      	b.n	24fa0 <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
   24f9c:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
   24f9e:	1d04      	adds	r4, r0, #4
}
   24fa0:	4620      	mov	r0, r4
   24fa2:	b002      	add	sp, #8
   24fa4:	bd70      	pop	{r4, r5, r6, pc}
   24fa6:	bf00      	nop
   24fa8:	2000384c 	.word	0x2000384c

00024fac <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   24fac:	4a02      	ldr	r2, [pc, #8]	; (24fb8 <boot_banner+0xc>)
   24fae:	4903      	ldr	r1, [pc, #12]	; (24fbc <boot_banner+0x10>)
   24fb0:	4803      	ldr	r0, [pc, #12]	; (24fc0 <boot_banner+0x14>)
   24fb2:	f000 b903 	b.w	251bc <printk>
   24fb6:	bf00      	nop
   24fb8:	0003175b 	.word	0x0003175b
   24fbc:	00034ea9 	.word	0x00034ea9
   24fc0:	00034eb7 	.word	0x00034eb7

00024fc4 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   24fc4:	4770      	bx	lr

00024fc6 <prov_reset>:
	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
   24fc6:	2003      	movs	r0, #3
   24fc8:	f7f2 bb2a 	b.w	17620 <bt_mesh_prov_enable>

00024fcc <attention_off>:
	board_led_set(false);
   24fcc:	2000      	movs	r0, #0
   24fce:	f7dc be85 	b.w	1cdc <board_led_set>

00024fd2 <attention_on>:
	board_led_set(true);
   24fd2:	2001      	movs	r0, #1
   24fd4:	f7dc be82 	b.w	1cdc <board_led_set>

00024fd8 <prov_complete>:
	board_prov_complete();
   24fd8:	f000 b811 	b.w	24ffe <board_prov_complete>

00024fdc <gen_onoff_get>:
{
   24fdc:	b508      	push	{r3, lr}
	onoff_status_send(model, ctx);
   24fde:	f7dc fd19 	bl	1a14 <onoff_status_send.isra.0>
}
   24fe2:	2000      	movs	r0, #0
   24fe4:	bd08      	pop	{r3, pc}

00024fe6 <gen_onoff_set>:
{
   24fe6:	b538      	push	{r3, r4, r5, lr}
   24fe8:	4604      	mov	r4, r0
   24fea:	460d      	mov	r5, r1
	(void)gen_onoff_set_unack(model, ctx, buf);
   24fec:	f7dc fd78 	bl	1ae0 <gen_onoff_set_unack>
	onoff_status_send(model, ctx);
   24ff0:	4620      	mov	r0, r4
   24ff2:	4629      	mov	r1, r5
   24ff4:	f7dc fd0e 	bl	1a14 <onoff_status_send.isra.0>
}
   24ff8:	2000      	movs	r0, #0
   24ffa:	bd38      	pop	{r3, r4, r5, pc}

00024ffc <board_output_number>:
#endif
}

void board_output_number(bt_mesh_output_action_t action, uint32_t number)
{
}
   24ffc:	4770      	bx	lr

00024ffe <board_prov_complete>:

void board_prov_complete(void)
{
}
   24ffe:	4770      	bx	lr

00025000 <cbpprintf_external>:
}

int cbpprintf_external(cbprintf_cb out,
		       cbvprintf_exteral_formatter_func formatter,
		       void *ctx, void *packaged)
{
   25000:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   25004:	4607      	mov	r7, r0
   25006:	460e      	mov	r6, r1
   25008:	4690      	mov	r8, r2
	uint8_t *buf = packaged;
	char *fmt, *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, s_idx;

	if (buf == NULL) {
   2500a:	461d      	mov	r5, r3
   2500c:	b1fb      	cbz	r3, 2504e <cbpprintf_external+0x4e>
	args_size = buf[0] * sizeof(int);
	s_nbr     = buf[1];
	ros_nbr   = buf[2];

	/* Locate the string table */
	s = (char *)(buf + args_size + ros_nbr);
   2500e:	7818      	ldrb	r0, [r3, #0]
   25010:	789c      	ldrb	r4, [r3, #2]
	s_nbr     = buf[1];
   25012:	f893 a001 	ldrb.w	sl, [r3, #1]
	s = (char *)(buf + args_size + ros_nbr);
   25016:	eb04 0480 	add.w	r4, r4, r0, lsl #2
   2501a:	441c      	add	r4, r3

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
   2501c:	f04f 0900 	mov.w	r9, #0
   25020:	45d1      	cmp	r9, sl
   25022:	d308      	bcc.n	25036 <cbpprintf_external+0x36>
	return formatter(out, ctx, fmt, u.ap);
   25024:	686a      	ldr	r2, [r5, #4]
   25026:	f105 0308 	add.w	r3, r5, #8
   2502a:	4641      	mov	r1, r8
   2502c:	4638      	mov	r0, r7
   2502e:	46b4      	mov	ip, r6
	/* skip past format string pointer */
	buf += sizeof(char *) * 2;

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, fmt, buf);
}
   25030:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return formatter(out, ctx, fmt, u.ap);
   25034:	4760      	bx	ip
		ps = (char **)(buf + s_idx * sizeof(int));
   25036:	f814 3b01 	ldrb.w	r3, [r4], #1
		*ps = s;
   2503a:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
		s += strlen(s) + 1;
   2503e:	4620      	mov	r0, r4
   25040:	f002 fbd8 	bl	277f4 <strlen>
   25044:	3001      	adds	r0, #1
   25046:	4404      	add	r4, r0
	for (i = 0; i < s_nbr; i++) {
   25048:	f109 0901 	add.w	r9, r9, #1
   2504c:	e7e8      	b.n	25020 <cbpprintf_external+0x20>
}
   2504e:	f06f 0015 	mvn.w	r0, #21
   25052:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00025056 <u8_to_dec>:
 */

#include <sys/util.h>

uint8_t u8_to_dec(char *buf, uint8_t buflen, uint8_t value)
{
   25056:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t divisor = 100;
   25058:	2364      	movs	r3, #100	; 0x64
{
   2505a:	4604      	mov	r4, r0
	uint8_t num_digits = 0;
	uint8_t digit;

	while (buflen > 0 && divisor > 0) {
   2505c:	2504      	movs	r5, #4
	uint8_t num_digits = 0;
   2505e:	2000      	movs	r0, #0
			buflen--;
			num_digits++;
		}

		value -= digit * divisor;
		divisor /= 10;
   25060:	f04f 0c0a 	mov.w	ip, #10
	while (buflen > 0 && divisor > 0) {
   25064:	b111      	cbz	r1, 2506c <u8_to_dec+0x16>
   25066:	3d01      	subs	r5, #1
   25068:	d101      	bne.n	2506e <u8_to_dec+0x18>
	}

	if (buflen) {
		*buf = '\0';
   2506a:	7025      	strb	r5, [r4, #0]
	}

	return num_digits;
}
   2506c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   2506e:	429a      	cmp	r2, r3
		digit = value / divisor;
   25070:	fbb2 f7f3 	udiv	r7, r2, r3
   25074:	b2fe      	uxtb	r6, r7
		if (digit != 0 || divisor == 1 || num_digits != 0) {
   25076:	d202      	bcs.n	2507e <u8_to_dec+0x28>
   25078:	2b01      	cmp	r3, #1
   2507a:	d000      	beq.n	2507e <u8_to_dec+0x28>
   2507c:	b130      	cbz	r0, 2508c <u8_to_dec+0x36>
			*buf = (char)digit + '0';
   2507e:	3630      	adds	r6, #48	; 0x30
			buflen--;
   25080:	3901      	subs	r1, #1
			num_digits++;
   25082:	3001      	adds	r0, #1
			*buf = (char)digit + '0';
   25084:	f804 6b01 	strb.w	r6, [r4], #1
			buflen--;
   25088:	b2c9      	uxtb	r1, r1
			num_digits++;
   2508a:	b2c0      	uxtb	r0, r0
		value -= digit * divisor;
   2508c:	fb03 2217 	mls	r2, r3, r7, r2
   25090:	b2d2      	uxtb	r2, r2
		divisor /= 10;
   25092:	fbb3 f3fc 	udiv	r3, r3, ip
   25096:	e7e5      	b.n	25064 <u8_to_dec+0xe>

00025098 <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
   25098:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   2509c:	b2db      	uxtb	r3, r3
   2509e:	2b09      	cmp	r3, #9
   250a0:	d802      	bhi.n	250a8 <char2hex+0x10>
		*x = c - '0';
   250a2:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   250a4:	2000      	movs	r0, #0
   250a6:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   250a8:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   250ac:	2b05      	cmp	r3, #5
   250ae:	d802      	bhi.n	250b6 <char2hex+0x1e>
		*x = c - 'a' + 10;
   250b0:	3857      	subs	r0, #87	; 0x57
   250b2:	7008      	strb	r0, [r1, #0]
   250b4:	e7f6      	b.n	250a4 <char2hex+0xc>
	} else if (c >= 'A' && c <= 'F') {
   250b6:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   250ba:	2b05      	cmp	r3, #5
   250bc:	d801      	bhi.n	250c2 <char2hex+0x2a>
		*x = c - 'A' + 10;
   250be:	3837      	subs	r0, #55	; 0x37
   250c0:	e7f7      	b.n	250b2 <char2hex+0x1a>
		return -EINVAL;
   250c2:	f06f 0015 	mvn.w	r0, #21
}
   250c6:	4770      	bx	lr

000250c8 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
   250c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   250ca:	4604      	mov	r4, r0
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
   250cc:	f001 0001 	and.w	r0, r1, #1
   250d0:	eb00 0551 	add.w	r5, r0, r1, lsr #1
   250d4:	429d      	cmp	r5, r3
   250d6:	ea4f 0651 	mov.w	r6, r1, lsr #1
   250da:	d903      	bls.n	250e4 <hex2bin+0x1c>
		return 0;
   250dc:	2500      	movs	r5, #0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
   250de:	4628      	mov	r0, r5
   250e0:	b003      	add	sp, #12
   250e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (hexlen % 2) {
   250e4:	b158      	cbz	r0, 250fe <hex2bin+0x36>
		if (char2hex(hex[0], &dec) < 0) {
   250e6:	7820      	ldrb	r0, [r4, #0]
   250e8:	f10d 0107 	add.w	r1, sp, #7
   250ec:	f7ff ffd4 	bl	25098 <char2hex>
   250f0:	2800      	cmp	r0, #0
   250f2:	dbf3      	blt.n	250dc <hex2bin+0x14>
		buf[0] = dec;
   250f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   250f8:	f802 3b01 	strb.w	r3, [r2], #1
		hex++;
   250fc:	3401      	adds	r4, #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   250fe:	3401      	adds	r4, #1
   25100:	4416      	add	r6, r2
   25102:	42b2      	cmp	r2, r6
   25104:	d0eb      	beq.n	250de <hex2bin+0x16>
		if (char2hex(hex[2 * i], &dec) < 0) {
   25106:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   2510a:	f10d 0107 	add.w	r1, sp, #7
   2510e:	f7ff ffc3 	bl	25098 <char2hex>
   25112:	2800      	cmp	r0, #0
   25114:	dbe2      	blt.n	250dc <hex2bin+0x14>
		buf[i] = dec << 4;
   25116:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2511a:	011b      	lsls	r3, r3, #4
   2511c:	7013      	strb	r3, [r2, #0]
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
   2511e:	f814 0b02 	ldrb.w	r0, [r4], #2
   25122:	f7ff ffb9 	bl	25098 <char2hex>
   25126:	2800      	cmp	r0, #0
   25128:	dbd8      	blt.n	250dc <hex2bin+0x14>
		buf[i] += dec;
   2512a:	7813      	ldrb	r3, [r2, #0]
   2512c:	f89d 1007 	ldrb.w	r1, [sp, #7]
   25130:	440b      	add	r3, r1
   25132:	f802 3b01 	strb.w	r3, [r2], #1
	for (size_t i = 0; i < hexlen / 2; i++) {
   25136:	e7e4      	b.n	25102 <hex2bin+0x3a>

00025138 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   25138:	4603      	mov	r3, r0
   2513a:	b140      	cbz	r0, 2514e <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   2513c:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   2513e:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   25142:	2a02      	cmp	r2, #2
   25144:	d006      	beq.n	25154 <sys_notify_validate+0x1c>
   25146:	2a03      	cmp	r2, #3
   25148:	d004      	beq.n	25154 <sys_notify_validate+0x1c>
   2514a:	2a01      	cmp	r2, #1
   2514c:	d005      	beq.n	2515a <sys_notify_validate+0x22>
		return -EINVAL;
   2514e:	f06f 0015 	mvn.w	r0, #21
	if (rv == 0) {
		notify->result = 0;
	}

	return rv;
}
   25152:	4770      	bx	lr
		if (notify->method.signal == NULL) {
   25154:	681a      	ldr	r2, [r3, #0]
   25156:	2a00      	cmp	r2, #0
   25158:	d0f9      	beq.n	2514e <sys_notify_validate+0x16>
		notify->result = 0;
   2515a:	2000      	movs	r0, #0
   2515c:	6098      	str	r0, [r3, #8]
   2515e:	4770      	bx	lr

00025160 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   25160:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   25162:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   25166:	2a02      	cmp	r2, #2
{
   25168:	b510      	push	{r4, lr}
   2516a:	4603      	mov	r3, r0
	notify->result = res;
   2516c:	6081      	str	r1, [r0, #8]
	switch (method) {
   2516e:	d00a      	beq.n	25186 <sys_notify_finalize+0x26>
   25170:	2a03      	cmp	r2, #3
   25172:	d10b      	bne.n	2518c <sys_notify_finalize+0x2c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   25174:	6804      	ldr	r4, [r0, #0]
	struct k_poll_signal *sig = NULL;
   25176:	2000      	movs	r0, #0
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   25178:	2200      	movs	r2, #0
   2517a:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
   2517c:	b108      	cbz	r0, 25182 <sys_notify_finalize+0x22>
	return z_impl_k_poll_signal_raise(sig, result);
   2517e:	f7ff fecd 	bl	24f1c <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   25182:	4620      	mov	r0, r4
   25184:	bd10      	pop	{r4, pc}
		sig = notify->method.signal;
   25186:	6800      	ldr	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
   25188:	2400      	movs	r4, #0
		break;
   2518a:	e7f5      	b.n	25178 <sys_notify_finalize+0x18>
	switch (method) {
   2518c:	2400      	movs	r4, #0
   2518e:	4620      	mov	r0, r4
   25190:	e7f2      	b.n	25178 <sys_notify_finalize+0x18>

00025192 <arch_printk_char_out>:
}
   25192:	2000      	movs	r0, #0
   25194:	4770      	bx	lr

00025196 <str_out>:
{
   25196:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   25198:	688a      	ldr	r2, [r1, #8]
   2519a:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
   2519c:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   2519e:	b114      	cbz	r4, 251a6 <str_out+0x10>
   251a0:	684b      	ldr	r3, [r1, #4]
   251a2:	4293      	cmp	r3, r2
   251a4:	dc01      	bgt.n	251aa <str_out+0x14>
		ctx->count++;
   251a6:	608d      	str	r5, [r1, #8]
}
   251a8:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   251aa:	3b01      	subs	r3, #1
   251ac:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   251ae:	bf08      	it	eq
   251b0:	2200      	moveq	r2, #0
   251b2:	608d      	str	r5, [r1, #8]
   251b4:	bf0c      	ite	eq
   251b6:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   251b8:	54a0      	strbne	r0, [r4, r2]
   251ba:	e7f5      	b.n	251a8 <str_out+0x12>

000251bc <printk>:
{
   251bc:	b40f      	push	{r0, r1, r2, r3}
   251be:	b507      	push	{r0, r1, r2, lr}
   251c0:	a904      	add	r1, sp, #16
   251c2:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   251c6:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
   251c8:	f7dc ffca 	bl	2160 <vprintk>
}
   251cc:	b003      	add	sp, #12
   251ce:	f85d eb04 	ldr.w	lr, [sp], #4
   251d2:	b004      	add	sp, #16
   251d4:	4770      	bx	lr

000251d6 <snprintk>:
{
   251d6:	b40c      	push	{r2, r3}
   251d8:	b507      	push	{r0, r1, r2, lr}
   251da:	ab04      	add	r3, sp, #16
   251dc:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   251e0:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   251e2:	f7dc ffcb 	bl	217c <vsnprintk>
}
   251e6:	b003      	add	sp, #12
   251e8:	f85d eb04 	ldr.w	lr, [sp], #4
   251ec:	b002      	add	sp, #8
   251ee:	4770      	bx	lr

000251f0 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   251f0:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   251f2:	f013 0307 	ands.w	r3, r3, #7
   251f6:	d105      	bne.n	25204 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   251f8:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
   251fa:	2b00      	cmp	r3, #0
   251fc:	bf0c      	ite	eq
   251fe:	2000      	moveq	r0, #0
   25200:	2003      	movne	r0, #3
   25202:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   25204:	2b02      	cmp	r3, #2
   25206:	d105      	bne.n	25214 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   25208:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
   2520a:	2b00      	cmp	r3, #0
   2520c:	bf14      	ite	ne
   2520e:	2000      	movne	r0, #0
   25210:	2004      	moveq	r0, #4
   25212:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   25214:	2b01      	cmp	r3, #1
   25216:	d105      	bne.n	25224 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   25218:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
   2521a:	2b00      	cmp	r3, #0
   2521c:	bf0c      	ite	eq
   2521e:	2000      	moveq	r0, #0
   25220:	2005      	movne	r0, #5
   25222:	4770      	bx	lr
	int evt = EVT_NOP;
   25224:	2000      	movs	r0, #0
}
   25226:	4770      	bx	lr

00025228 <notify_one>:
{
   25228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2522c:	460d      	mov	r5, r1
   2522e:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   25230:	4619      	mov	r1, r3
   25232:	1d28      	adds	r0, r5, #4
{
   25234:	4690      	mov	r8, r2
   25236:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   25238:	f7ff ff92 	bl	25160 <sys_notify_finalize>
	if (cb) {
   2523c:	4604      	mov	r4, r0
   2523e:	b138      	cbz	r0, 25250 <notify_one+0x28>
		cb(mgr, cli, state, res);
   25240:	4633      	mov	r3, r6
   25242:	4642      	mov	r2, r8
   25244:	4629      	mov	r1, r5
   25246:	4638      	mov	r0, r7
   25248:	46a4      	mov	ip, r4
}
   2524a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   2524e:	4760      	bx	ip
}
   25250:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00025254 <transition_complete>:
{
   25254:	b410      	push	{r4}
	__asm__ volatile(
   25256:	f04f 0420 	mov.w	r4, #32
   2525a:	f3ef 8211 	mrs	r2, BASEPRI
   2525e:	f384 8812 	msr	BASEPRI_MAX, r4
   25262:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   25266:	6141      	str	r1, [r0, #20]
}
   25268:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   2526a:	2101      	movs	r1, #1
   2526c:	f7dc bf9a 	b.w	21a4 <process_event>

00025270 <validate_args>:
{
   25270:	b510      	push	{r4, lr}
   25272:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   25274:	b140      	cbz	r0, 25288 <validate_args+0x18>
   25276:	b139      	cbz	r1, 25288 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   25278:	1d08      	adds	r0, r1, #4
   2527a:	f7ff ff5d 	bl	25138 <sys_notify_validate>
	if ((rv == 0)
   2527e:	b928      	cbnz	r0, 2528c <validate_args+0x1c>
	    && ((cli->notify.flags
   25280:	68a3      	ldr	r3, [r4, #8]
   25282:	f033 0303 	bics.w	r3, r3, #3
   25286:	d001      	beq.n	2528c <validate_args+0x1c>
		rv = -EINVAL;
   25288:	f06f 0015 	mvn.w	r0, #21
}
   2528c:	bd10      	pop	{r4, pc}

0002528e <onoff_manager_init>:
{
   2528e:	b538      	push	{r3, r4, r5, lr}
   25290:	460c      	mov	r4, r1
	if ((mgr == NULL)
   25292:	4605      	mov	r5, r0
   25294:	b158      	cbz	r0, 252ae <onoff_manager_init+0x20>
	    || (transitions == NULL)
   25296:	b151      	cbz	r1, 252ae <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   25298:	680b      	ldr	r3, [r1, #0]
   2529a:	b143      	cbz	r3, 252ae <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   2529c:	684b      	ldr	r3, [r1, #4]
   2529e:	b133      	cbz	r3, 252ae <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   252a0:	221c      	movs	r2, #28
   252a2:	2100      	movs	r1, #0
   252a4:	f002 faef 	bl	27886 <memset>
   252a8:	612c      	str	r4, [r5, #16]
	return 0;
   252aa:	2000      	movs	r0, #0
}
   252ac:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   252ae:	f06f 0015 	mvn.w	r0, #21
   252b2:	e7fb      	b.n	252ac <onoff_manager_init+0x1e>

000252b4 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   252b4:	b570      	push	{r4, r5, r6, lr}
   252b6:	4604      	mov	r4, r0
   252b8:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   252ba:	f7ff ffd9 	bl	25270 <validate_args>

	if (rv < 0) {
   252be:	1e05      	subs	r5, r0, #0
   252c0:	db31      	blt.n	25326 <onoff_request+0x72>
   252c2:	f04f 0320 	mov.w	r3, #32
   252c6:	f3ef 8111 	mrs	r1, BASEPRI
   252ca:	f383 8812 	msr	BASEPRI_MAX, r3
   252ce:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   252d2:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   252d4:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   252d6:	f64f 75ff 	movw	r5, #65535	; 0xffff
   252da:	42ab      	cmp	r3, r5
   252dc:	f000 0207 	and.w	r2, r0, #7
   252e0:	d02e      	beq.n	25340 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   252e2:	2a02      	cmp	r2, #2
   252e4:	d10e      	bne.n	25304 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   252e6:	3301      	adds	r3, #1
   252e8:	8363      	strh	r3, [r4, #26]
	rv = state;
   252ea:	4615      	mov	r5, r2
		notify = true;
   252ec:	2301      	movs	r3, #1
	__asm__ volatile(
   252ee:	f381 8811 	msr	BASEPRI, r1
   252f2:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   252f6:	b1b3      	cbz	r3, 25326 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   252f8:	2300      	movs	r3, #0
   252fa:	4631      	mov	r1, r6
   252fc:	4620      	mov	r0, r4
   252fe:	f7ff ff93 	bl	25228 <notify_one>
   25302:	e010      	b.n	25326 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   25304:	0783      	lsls	r3, r0, #30
   25306:	d001      	beq.n	2530c <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   25308:	2a06      	cmp	r2, #6
   2530a:	d10e      	bne.n	2532a <onoff_request+0x76>
	parent->next = child;
   2530c:	2300      	movs	r3, #0
   2530e:	6033      	str	r3, [r6, #0]
	return list->tail;
   25310:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
   25312:	b993      	cbnz	r3, 2533a <onoff_request+0x86>
	list->head = node;
   25314:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   25318:	4615      	mov	r5, r2
   2531a:	b962      	cbnz	r2, 25336 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   2531c:	460a      	mov	r2, r1
   2531e:	4620      	mov	r0, r4
   25320:	2102      	movs	r1, #2
   25322:	f7dc ff3f 	bl	21a4 <process_event>
		}
	}

	return rv;
}
   25326:	4628      	mov	r0, r5
   25328:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   2532a:	2a05      	cmp	r2, #5
   2532c:	bf0c      	ite	eq
   2532e:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   25332:	f06f 0504 	mvnne.w	r5, #4
   25336:	2300      	movs	r3, #0
   25338:	e7d9      	b.n	252ee <onoff_request+0x3a>
	parent->next = child;
   2533a:	601e      	str	r6, [r3, #0]
	list->tail = node;
   2533c:	6066      	str	r6, [r4, #4]
}
   2533e:	e7eb      	b.n	25318 <onoff_request+0x64>
		rv = -EAGAIN;
   25340:	f06f 050a 	mvn.w	r5, #10
   25344:	e7f7      	b.n	25336 <onoff_request+0x82>

00025346 <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
   25346:	b510      	push	{r4, lr}
	__asm__ volatile(
   25348:	f04f 0320 	mov.w	r3, #32
   2534c:	f3ef 8211 	mrs	r2, BASEPRI
   25350:	f383 8812 	msr	BASEPRI_MAX, r3
   25354:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   25358:	8b04      	ldrh	r4, [r0, #24]
   2535a:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
   2535e:	2c02      	cmp	r4, #2
   25360:	d00a      	beq.n	25378 <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
   25362:	2c01      	cmp	r4, #1
   25364:	bf0c      	ite	eq
   25366:	f06f 0004 	mvneq.w	r0, #4
   2536a:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
   2536e:	f382 8811 	msr	BASEPRI, r2
   25372:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
   25376:	e008      	b.n	2538a <onoff_release+0x44>
	mgr->refs -= 1U;
   25378:	8b43      	ldrh	r3, [r0, #26]
   2537a:	3b01      	subs	r3, #1
   2537c:	b29b      	uxth	r3, r3
   2537e:	8343      	strh	r3, [r0, #26]
	if (stop) {
   25380:	b923      	cbnz	r3, 2538c <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
   25382:	4621      	mov	r1, r4
   25384:	f7dc ff0e 	bl	21a4 <process_event>
	int rv = state;
   25388:	4620      	mov	r0, r4
}
   2538a:	bd10      	pop	{r4, pc}
	int rv = state;
   2538c:	4620      	mov	r0, r4
   2538e:	e7ee      	b.n	2536e <onoff_release+0x28>

00025390 <onoff_sync_lock>:
	__asm__ volatile(
   25390:	f04f 0220 	mov.w	r2, #32
   25394:	f3ef 8311 	mrs	r3, BASEPRI
   25398:	f382 8812 	msr	BASEPRI_MAX, r2
   2539c:	f3bf 8f6f 	isb	sy
int onoff_sync_lock(struct onoff_sync_service *srv,
		    k_spinlock_key_t *keyp)
{
	*keyp = k_spin_lock(&srv->lock);
	return srv->count;
}
   253a0:	6800      	ldr	r0, [r0, #0]
	*keyp = k_spin_lock(&srv->lock);
   253a2:	600b      	str	r3, [r1, #0]
}
   253a4:	4770      	bx	lr

000253a6 <onoff_sync_finalize>:
int onoff_sync_finalize(struct onoff_sync_service *srv,
			k_spinlock_key_t key,
			struct onoff_client *cli,
			int res,
			bool on)
{
   253a6:	b538      	push	{r3, r4, r5, lr}

	/* Clear errors visible when locked.  If they are to be
	 * preserved the caller must finalize with the previous
	 * error code.
	 */
	if (srv->count < 0) {
   253a8:	6804      	ldr	r4, [r0, #0]
   253aa:	2c00      	cmp	r4, #0
		srv->count = 0;
   253ac:	bfbc      	itt	lt
   253ae:	2400      	movlt	r4, #0
   253b0:	6004      	strlt	r4, [r0, #0]
	}
	if (res < 0) {
   253b2:	2b00      	cmp	r3, #0
{
   253b4:	460d      	mov	r5, r1
   253b6:	4611      	mov	r1, r2
   253b8:	f89d 2010 	ldrb.w	r2, [sp, #16]
	if (res < 0) {
   253bc:	da0c      	bge.n	253d8 <onoff_sync_finalize+0x32>
		srv->count = res;
   253be:	6003      	str	r3, [r0, #0]
		state = ONOFF_STATE_ERROR;
   253c0:	2201      	movs	r2, #1
		 * callbacks are used only when turning on don't
		 * bother changing it.
		 */
	}

	int rv = srv->count;
   253c2:	6804      	ldr	r4, [r0, #0]
	__asm__ volatile(
   253c4:	f385 8811 	msr	BASEPRI, r5
   253c8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&srv->lock, key);

	if (cli) {
   253cc:	b111      	cbz	r1, 253d4 <onoff_sync_finalize+0x2e>
		/* Detect service mis-use: onoff does not callback on transition
		 * to off, so no client should have been passed.
		 */
		__ASSERT_NO_MSG(on);
		notify_one(NULL, cli, state, res);
   253ce:	2000      	movs	r0, #0
   253d0:	f7ff ff2a 	bl	25228 <notify_one>
	}

	return rv;
}
   253d4:	4620      	mov	r0, r4
   253d6:	bd38      	pop	{r3, r4, r5, pc}
		srv->count += 1;
   253d8:	6804      	ldr	r4, [r0, #0]
	} else if (on) {
   253da:	b11a      	cbz	r2, 253e4 <onoff_sync_finalize+0x3e>
		srv->count += 1;
   253dc:	3401      	adds	r4, #1
		srv->count -= 1;
   253de:	6004      	str	r4, [r0, #0]
	uint32_t state = ONOFF_STATE_ON;
   253e0:	2202      	movs	r2, #2
   253e2:	e7ee      	b.n	253c2 <onoff_sync_finalize+0x1c>
		srv->count -= 1;
   253e4:	3c01      	subs	r4, #1
   253e6:	e7fa      	b.n	253de <onoff_sync_finalize+0x38>

000253e8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   253e8:	4604      	mov	r4, r0
   253ea:	b508      	push	{r3, lr}
   253ec:	4608      	mov	r0, r1
   253ee:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   253f0:	461a      	mov	r2, r3
   253f2:	47a0      	blx	r4
	return z_impl_z_current_get();
   253f4:	f7ff faac 	bl	24950 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   253f8:	f7df fd74 	bl	4ee4 <z_impl_k_thread_abort>

000253fc <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   253fc:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   25400:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   25402:	0840      	lsrs	r0, r0, #1
   25404:	4770      	bx	lr

00025406 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   25406:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25408:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   2540a:	f7ff fff7 	bl	253fc <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   2540e:	fab0 f080 	clz	r0, r0
   25412:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   25416:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
   2541a:	00ca      	lsls	r2, r1, #3
   2541c:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   25420:	1d17      	adds	r7, r2, #4
{
   25422:	460c      	mov	r4, r1
   25424:	3206      	adds	r2, #6
   25426:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
   25428:	b956      	cbnz	r6, 25440 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   2542a:	2101      	movs	r1, #1
   2542c:	fa01 f000 	lsl.w	r0, r1, r0
   25430:	68d9      	ldr	r1, [r3, #12]
   25432:	4301      	orrs	r1, r0
   25434:	60d9      	str	r1, [r3, #12]
		b->next = c;
   25436:	f8cc 4010 	str.w	r4, [ip, #16]
   2543a:	53dd      	strh	r5, [r3, r7]
   2543c:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   2543e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   25440:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   25442:	3104      	adds	r1, #4
   25444:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   25446:	53d8      	strh	r0, [r3, r7]
   25448:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   2544c:	529e      	strh	r6, [r3, r2]
   2544e:	80c5      	strh	r5, [r0, #6]
   25450:	525d      	strh	r5, [r3, r1]
   25452:	e7f4      	b.n	2543e <free_list_add+0x38>

00025454 <free_list_remove_bidx>:
{
   25454:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   25456:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   2545a:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   2545c:	4299      	cmp	r1, r3
   2545e:	f102 0104 	add.w	r1, r2, #4
   25462:	d10a      	bne.n	2547a <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   25464:	2301      	movs	r3, #1
   25466:	fa03 f202 	lsl.w	r2, r3, r2
   2546a:	68c3      	ldr	r3, [r0, #12]
   2546c:	ea23 0302 	bic.w	r3, r3, r2
   25470:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   25472:	2300      	movs	r3, #0
   25474:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   25478:	bd10      	pop	{r4, pc}
   2547a:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   2547c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   25480:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   25484:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   25488:	80cb      	strh	r3, [r1, #6]
   2548a:	8082      	strh	r2, [r0, #4]
}
   2548c:	e7f4      	b.n	25478 <free_list_remove_bidx+0x24>

0002548e <free_list_remove>:
{
   2548e:	b508      	push	{r3, lr}
   25490:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   25492:	f7ff ffb3 	bl	253fc <chunk_size>
	return 31 - __builtin_clz(usable_sz);
   25496:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   2549a:	f1c2 021f 	rsb	r2, r2, #31
   2549e:	4618      	mov	r0, r3
}
   254a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
   254a4:	f7ff bfd6 	b.w	25454 <free_list_remove_bidx>

000254a8 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   254a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   254ac:	fab1 f581 	clz	r5, r1
   254b0:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   254b4:	eb00 0789 	add.w	r7, r0, r9, lsl #2
{
   254b8:	4603      	mov	r3, r0
	if (b->next) {
   254ba:	693a      	ldr	r2, [r7, #16]
{
   254bc:	460e      	mov	r6, r1
	if (b->next) {
   254be:	b1c2      	cbz	r2, 254f2 <alloc_chunk+0x4a>
   254c0:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   254c4:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   254c6:	4618      	mov	r0, r3
   254c8:	4621      	mov	r1, r4
   254ca:	f7ff ff97 	bl	253fc <chunk_size>
   254ce:	42b0      	cmp	r0, r6
   254d0:	d306      	bcc.n	254e0 <alloc_chunk+0x38>
				free_list_remove_bidx(h, c, bi);
   254d2:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   254d4:	4618      	mov	r0, r3
   254d6:	f7ff ffbd 	bl	25454 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   254da:	4620      	mov	r0, r4
   254dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   254e0:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
		} while (--i && b->next != first);
   254e4:	f1b8 0801 	subs.w	r8, r8, #1
   254e8:	88c0      	ldrh	r0, [r0, #6]
			b->next = next_free_chunk(h, c);
   254ea:	6138      	str	r0, [r7, #16]
		} while (--i && b->next != first);
   254ec:	d001      	beq.n	254f2 <alloc_chunk+0x4a>
   254ee:	4282      	cmp	r2, r0
   254f0:	d1e8      	bne.n	254c4 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   254f2:	f1c5 0220 	rsb	r2, r5, #32
   254f6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   254fa:	4094      	lsls	r4, r2
   254fc:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
   254fe:	4014      	ands	r4, r2
   25500:	d0eb      	beq.n	254da <alloc_chunk+0x32>
		int minbucket = __builtin_ctz(bmask);
   25502:	fa94 f2a4 	rbit	r2, r4
   25506:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   2550a:	1d11      	adds	r1, r2, #4
   2550c:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   25510:	4621      	mov	r1, r4
   25512:	e7df      	b.n	254d4 <alloc_chunk+0x2c>

00025514 <merge_chunks>:
{
   25514:	b538      	push	{r3, r4, r5, lr}
   25516:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   25518:	f7ff ff70 	bl	253fc <chunk_size>
{
   2551c:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   2551e:	4604      	mov	r4, r0
   25520:	4611      	mov	r1, r2
   25522:	4618      	mov	r0, r3
   25524:	f7ff ff6a 	bl	253fc <chunk_size>
		((uint16_t *)cmem)[f] = val;
   25528:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   2552c:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2552e:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
   25530:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
   25532:	4618      	mov	r0, r3
   25534:	f7ff ff62 	bl	253fc <chunk_size>
	void *cmem = &buf[c];
   25538:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   2553a:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
   2553e:	bd38      	pop	{r3, r4, r5, pc}

00025540 <split_chunks>:
{
   25540:	b538      	push	{r3, r4, r5, lr}
   25542:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
   25544:	f7ff ff5a 	bl	253fc <chunk_size>
{
   25548:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
   2554a:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
   2554c:	1a51      	subs	r1, r2, r1
   2554e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
   25552:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   25554:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   25556:	8060      	strh	r0, [r4, #2]
   25558:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2555c:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   2555e:	8044      	strh	r4, [r0, #2]
   25560:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   25564:	4618      	mov	r0, r3
   25566:	4611      	mov	r1, r2
   25568:	f7ff ff48 	bl	253fc <chunk_size>
	void *cmem = &buf[c];
   2556c:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   2556e:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
   25572:	bd38      	pop	{r3, r4, r5, pc}

00025574 <free_chunk>:
{
   25574:	b538      	push	{r3, r4, r5, lr}
   25576:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   25578:	f7ff ff40 	bl	253fc <chunk_size>
   2557c:	460c      	mov	r4, r1
   2557e:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   25580:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   25584:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   25586:	07da      	lsls	r2, r3, #31
   25588:	d40a      	bmi.n	255a0 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   2558a:	4628      	mov	r0, r5
   2558c:	f7ff ff7f 	bl	2548e <free_list_remove>
	return c + chunk_size(h, c);
   25590:	4621      	mov	r1, r4
   25592:	4628      	mov	r0, r5
   25594:	f7ff ff32 	bl	253fc <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   25598:	1822      	adds	r2, r4, r0
   2559a:	4628      	mov	r0, r5
   2559c:	f7ff ffba 	bl	25514 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   255a0:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   255a4:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   255a6:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   255aa:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   255ac:	07db      	lsls	r3, r3, #31
   255ae:	d40c      	bmi.n	255ca <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   255b0:	4628      	mov	r0, r5
   255b2:	f7ff ff6c 	bl	2548e <free_list_remove>
		return ((uint16_t *)cmem)[f];
   255b6:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   255ba:	4622      	mov	r2, r4
   255bc:	1a61      	subs	r1, r4, r1
   255be:	4628      	mov	r0, r5
   255c0:	f7ff ffa8 	bl	25514 <merge_chunks>
   255c4:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   255c8:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   255ca:	4621      	mov	r1, r4
   255cc:	4628      	mov	r0, r5
}
   255ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   255d2:	f7ff bf18 	b.w	25406 <free_list_add>

000255d6 <sys_heap_free>:
	if (mem == NULL) {
   255d6:	b161      	cbz	r1, 255f2 <sys_heap_free+0x1c>
   255d8:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   255da:	3904      	subs	r1, #4
   255dc:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   255de:	f021 0307 	bic.w	r3, r1, #7
   255e2:	4403      	add	r3, r0
	free_chunk(h, c);
   255e4:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   255e6:	885a      	ldrh	r2, [r3, #2]
   255e8:	f022 0201 	bic.w	r2, r2, #1
   255ec:	805a      	strh	r2, [r3, #2]
   255ee:	f7ff bfc1 	b.w	25574 <free_chunk>
}
   255f2:	4770      	bx	lr

000255f4 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   255f4:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   255f6:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   255f8:	b909      	cbnz	r1, 255fe <sys_heap_alloc+0xa>
		return NULL;
   255fa:	2000      	movs	r0, #0
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
   255fc:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   255fe:	68ab      	ldr	r3, [r5, #8]
   25600:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   25604:	d9f9      	bls.n	255fa <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   25606:	310b      	adds	r1, #11
   25608:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   2560a:	4621      	mov	r1, r4
   2560c:	4628      	mov	r0, r5
   2560e:	f7ff ff4b 	bl	254a8 <alloc_chunk>
	if (c == 0U) {
   25612:	4606      	mov	r6, r0
   25614:	2800      	cmp	r0, #0
   25616:	d0f0      	beq.n	255fa <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   25618:	4601      	mov	r1, r0
   2561a:	4628      	mov	r0, r5
   2561c:	f7ff feee 	bl	253fc <chunk_size>
   25620:	42a0      	cmp	r0, r4
   25622:	d907      	bls.n	25634 <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
   25624:	1932      	adds	r2, r6, r4
   25626:	4628      	mov	r0, r5
   25628:	f7ff ff8a 	bl	25540 <split_chunks>
		free_list_add(h, c + chunk_sz);
   2562c:	4611      	mov	r1, r2
   2562e:	4628      	mov	r0, r5
   25630:	f7ff fee9 	bl	25406 <free_list_add>
	void *cmem = &buf[c];
   25634:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   25638:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   2563a:	8853      	ldrh	r3, [r2, #2]
   2563c:	f043 0301 	orr.w	r3, r3, #1
   25640:	8053      	strh	r3, [r2, #2]
   25642:	3004      	adds	r0, #4
	return mem;
   25644:	e7da      	b.n	255fc <sys_heap_alloc+0x8>

00025646 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   25646:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2564a:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   2564c:	424a      	negs	r2, r1
   2564e:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   25652:	ea31 0202 	bics.w	r2, r1, r2
{
   25656:	4603      	mov	r3, r0
	if (align != rew) {
   25658:	d00a      	beq.n	25670 <sys_heap_aligned_alloc+0x2a>
		return false;
   2565a:	2f04      	cmp	r7, #4
   2565c:	463a      	mov	r2, r7
   2565e:	46b9      	mov	r9, r7
   25660:	bf28      	it	cs
   25662:	2204      	movcs	r2, #4
		align -= rew;
   25664:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   25666:	b974      	cbnz	r4, 25686 <sys_heap_aligned_alloc+0x40>
		return NULL;
   25668:	2500      	movs	r5, #0
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
   2566a:	4628      	mov	r0, r5
   2566c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   25670:	2904      	cmp	r1, #4
   25672:	d804      	bhi.n	2567e <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   25674:	4621      	mov	r1, r4
}
   25676:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   2567a:	f7ff bfbb 	b.w	255f4 <sys_heap_alloc>
		rew = 0;
   2567e:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   25682:	2204      	movs	r2, #4
   25684:	e7ef      	b.n	25666 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   25686:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   25688:	68b3      	ldr	r3, [r6, #8]
   2568a:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   2568e:	d9eb      	bls.n	25668 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   25690:	f104 010b 	add.w	r1, r4, #11
   25694:	4439      	add	r1, r7
   25696:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   25698:	08c9      	lsrs	r1, r1, #3
   2569a:	4630      	mov	r0, r6
   2569c:	f7ff ff04 	bl	254a8 <alloc_chunk>
	if (c0 == 0) {
   256a0:	4680      	mov	r8, r0
   256a2:	2800      	cmp	r0, #0
   256a4:	d0e0      	beq.n	25668 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   256a6:	f109 0504 	add.w	r5, r9, #4
   256aa:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   256ae:	1e7b      	subs	r3, r7, #1
   256b0:	4435      	add	r5, r6
   256b2:	441d      	add	r5, r3
   256b4:	427f      	negs	r7, r7
   256b6:	403d      	ands	r5, r7
   256b8:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   256bc:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   256be:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   256c0:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   256c2:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   256c4:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   256c8:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   256ca:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   256ce:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   256d2:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   256d6:	d208      	bcs.n	256ea <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   256d8:	4601      	mov	r1, r0
   256da:	463a      	mov	r2, r7
   256dc:	4630      	mov	r0, r6
   256de:	f7ff ff2f 	bl	25540 <split_chunks>
		free_list_add(h, c0);
   256e2:	4641      	mov	r1, r8
   256e4:	4630      	mov	r0, r6
   256e6:	f7ff fe8e 	bl	25406 <free_list_add>
	return c + chunk_size(h, c);
   256ea:	4639      	mov	r1, r7
   256ec:	4630      	mov	r0, r6
   256ee:	f7ff fe85 	bl	253fc <chunk_size>
   256f2:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   256f4:	4284      	cmp	r4, r0
   256f6:	d207      	bcs.n	25708 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   256f8:	4630      	mov	r0, r6
   256fa:	4622      	mov	r2, r4
   256fc:	f7ff ff20 	bl	25540 <split_chunks>
		free_list_add(h, c_end);
   25700:	4621      	mov	r1, r4
   25702:	4630      	mov	r0, r6
   25704:	f7ff fe7f 	bl	25406 <free_list_add>
	void *cmem = &buf[c];
   25708:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   2570c:	8873      	ldrh	r3, [r6, #2]
   2570e:	f043 0301 	orr.w	r3, r3, #1
   25712:	8073      	strh	r3, [r6, #2]
   25714:	e7a9      	b.n	2566a <sys_heap_aligned_alloc+0x24>

00025716 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   25716:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   25718:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   2571a:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   2571c:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   25720:	f021 0107 	bic.w	r1, r1, #7
{
   25724:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   25726:	1acd      	subs	r5, r1, r3
   25728:	08ea      	lsrs	r2, r5, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   2572a:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   2572c:	fab2 f082 	clz	r0, r2
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   25730:	f1c0 0424 	rsb	r4, r0, #36	; 0x24
   25734:	00a4      	lsls	r4, r4, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   25736:	3407      	adds	r4, #7
	h->avail_buckets = 0;
   25738:	2600      	movs	r6, #0
   2573a:	08e1      	lsrs	r1, r4, #3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   2573c:	f1c0 0020 	rsb	r0, r0, #32
   25740:	f103 0410 	add.w	r4, r3, #16
	h->end_chunk = heap_sz;
   25744:	609a      	str	r2, [r3, #8]
	h->avail_buckets = 0;
   25746:	60de      	str	r6, [r3, #12]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   25748:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   2574c:	4284      	cmp	r4, r0
   2574e:	d118      	bne.n	25782 <sys_heap_init+0x6c>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   25750:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   25752:	f040 0001 	orr.w	r0, r0, #1
   25756:	8058      	strh	r0, [r3, #2]
		((uint16_t *)cmem)[f] = val;
   25758:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   2575c:	1a50      	subs	r0, r2, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2575e:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   25760:	801e      	strh	r6, [r3, #0]
   25762:	8067      	strh	r7, [r4, #2]
   25764:	195c      	adds	r4, r3, r5
   25766:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   2576a:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
		((uint16_t *)cmem)[f] = val;
   2576e:	8066      	strh	r6, [r4, #2]
   25770:	5358      	strh	r0, [r3, r5]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   25772:	8850      	ldrh	r0, [r2, #2]
   25774:	f040 0001 	orr.w	r0, r0, #1
   25778:	8050      	strh	r0, [r2, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
   2577a:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   2577c:	4618      	mov	r0, r3
   2577e:	f7ff be42 	b.w	25406 <free_list_add>
		h->buckets[i].next = 0;
   25782:	f844 6b04 	str.w	r6, [r4], #4
	for (int i = 0; i < nb_buckets; i++) {
   25786:	e7e1      	b.n	2574c <sys_heap_init+0x36>

00025788 <encode_uint>:
{
   25788:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2578c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
   2578e:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
   25790:	2b6f      	cmp	r3, #111	; 0x6f
{
   25792:	4680      	mov	r8, r0
   25794:	460f      	mov	r7, r1
   25796:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   25798:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
   2579c:	d029      	beq.n	257f2 <encode_uint+0x6a>
   2579e:	d824      	bhi.n	257ea <encode_uint+0x62>
		return 16;
   257a0:	2b58      	cmp	r3, #88	; 0x58
   257a2:	bf14      	ite	ne
   257a4:	260a      	movne	r6, #10
   257a6:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
   257a8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
   257ac:	4632      	mov	r2, r6
   257ae:	2300      	movs	r3, #0
   257b0:	4640      	mov	r0, r8
   257b2:	4639      	mov	r1, r7
   257b4:	f7da fc94 	bl	e0 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   257b8:	2a09      	cmp	r2, #9
   257ba:	b2d4      	uxtb	r4, r2
   257bc:	d81e      	bhi.n	257fc <encode_uint+0x74>
   257be:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   257c0:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
   257c2:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
   257c4:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
   257c8:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
   257cc:	d301      	bcc.n	257d2 <encode_uint+0x4a>
   257ce:	45d1      	cmp	r9, sl
   257d0:	d811      	bhi.n	257f6 <encode_uint+0x6e>
	if (conv->flag_hash) {
   257d2:	782b      	ldrb	r3, [r5, #0]
   257d4:	069b      	lsls	r3, r3, #26
   257d6:	d505      	bpl.n	257e4 <encode_uint+0x5c>
		if (radix == 8) {
   257d8:	2e08      	cmp	r6, #8
   257da:	d115      	bne.n	25808 <encode_uint+0x80>
			conv->altform_0 = true;
   257dc:	78ab      	ldrb	r3, [r5, #2]
   257de:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   257e2:	70ab      	strb	r3, [r5, #2]
}
   257e4:	4648      	mov	r0, r9
   257e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   257ea:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   257ee:	2b70      	cmp	r3, #112	; 0x70
   257f0:	e7d7      	b.n	257a2 <encode_uint+0x1a>
	switch (specifier) {
   257f2:	2608      	movs	r6, #8
   257f4:	e7d8      	b.n	257a8 <encode_uint+0x20>
		value /= radix;
   257f6:	4680      	mov	r8, r0
   257f8:	460f      	mov	r7, r1
   257fa:	e7d7      	b.n	257ac <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   257fc:	f1bb 0f19 	cmp.w	fp, #25
   25800:	bf94      	ite	ls
   25802:	3437      	addls	r4, #55	; 0x37
   25804:	3457      	addhi	r4, #87	; 0x57
   25806:	e7db      	b.n	257c0 <encode_uint+0x38>
		} else if (radix == 16) {
   25808:	2e10      	cmp	r6, #16
   2580a:	d1eb      	bne.n	257e4 <encode_uint+0x5c>
			conv->altform_0c = true;
   2580c:	78ab      	ldrb	r3, [r5, #2]
   2580e:	f043 0310 	orr.w	r3, r3, #16
   25812:	e7e6      	b.n	257e2 <encode_uint+0x5a>

00025814 <outs>:
{
   25814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   25818:	4607      	mov	r7, r0
   2581a:	4688      	mov	r8, r1
   2581c:	4615      	mov	r5, r2
   2581e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   25820:	4614      	mov	r4, r2
   25822:	42b4      	cmp	r4, r6
   25824:	eba4 0005 	sub.w	r0, r4, r5
   25828:	d302      	bcc.n	25830 <outs+0x1c>
   2582a:	b93e      	cbnz	r6, 2583c <outs+0x28>
   2582c:	7823      	ldrb	r3, [r4, #0]
   2582e:	b12b      	cbz	r3, 2583c <outs+0x28>
		int rc = out((int)*sp++, ctx);
   25830:	f814 0b01 	ldrb.w	r0, [r4], #1
   25834:	4641      	mov	r1, r8
   25836:	47b8      	blx	r7
		if (rc < 0) {
   25838:	2800      	cmp	r0, #0
   2583a:	daf2      	bge.n	25822 <outs+0xe>
}
   2583c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00025840 <free_space>:
	err = k_sem_init(&buffer->sem, 0, 1);
	__ASSERT_NO_MSG(err == 0);
}

static inline bool free_space(struct mpsc_pbuf_buffer *buffer, uint32_t *res)
{
   25840:	4602      	mov	r2, r0
   25842:	b510      	push	{r4, lr}
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
   25844:	68c0      	ldr	r0, [r0, #12]
   25846:	6814      	ldr	r4, [r2, #0]
   25848:	42a0      	cmp	r0, r4
   2584a:	d904      	bls.n	25856 <free_space+0x16>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
   2584c:	3801      	subs	r0, #1
   2584e:	1b00      	subs	r0, r0, r4
   25850:	6008      	str	r0, [r1, #0]

		return false;
   25852:	2000      	movs	r0, #0
	}

	*res = buffer->size - buffer->tmp_wr_idx;

	return true;
}
   25854:	bd10      	pop	{r4, pc}
		*res = buffer->size - buffer->tmp_wr_idx - 1;
   25856:	6a13      	ldr	r3, [r2, #32]
	} else if (!buffer->rd_idx) {
   25858:	b918      	cbnz	r0, 25862 <free_space+0x22>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
   2585a:	3b01      	subs	r3, #1
   2585c:	1b1b      	subs	r3, r3, r4
   2585e:	600b      	str	r3, [r1, #0]
		return false;
   25860:	e7f8      	b.n	25854 <free_space+0x14>
	*res = buffer->size - buffer->tmp_wr_idx;
   25862:	1b1b      	subs	r3, r3, r4
   25864:	600b      	str	r3, [r1, #0]
	return true;
   25866:	2001      	movs	r0, #1
   25868:	e7f4      	b.n	25854 <free_space+0x14>

0002586a <idx_inc>:
	return !item->hdr.valid && !item->hdr.busy;
}

static inline uint32_t idx_inc(struct mpsc_pbuf_buffer *buffer,
				uint32_t idx, uint32_t val)
{
   2586a:	b510      	push	{r4, lr}
   2586c:	4604      	mov	r4, r0
	uint32_t i = idx + val;
   2586e:	1888      	adds	r0, r1, r2

	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   25870:	6922      	ldr	r2, [r4, #16]
		return i & (buffer->size - 1);
   25872:	6a23      	ldr	r3, [r4, #32]
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   25874:	07d2      	lsls	r2, r2, #31
   25876:	d502      	bpl.n	2587e <idx_inc+0x14>
		return i & (buffer->size - 1);
   25878:	3b01      	subs	r3, #1
   2587a:	4018      	ands	r0, r3
	}

	return (i >= buffer->size) ? i - buffer->size : i;
}
   2587c:	bd10      	pop	{r4, pc}
	return (i >= buffer->size) ? i - buffer->size : i;
   2587e:	4298      	cmp	r0, r3
   25880:	bf28      	it	cs
   25882:	1ac0      	subcs	r0, r0, r3
   25884:	e7fa      	b.n	2587c <idx_inc+0x12>

00025886 <add_skip_item>:

	return 0;
}

static void add_skip_item(struct mpsc_pbuf_buffer *buffer, uint32_t wlen)
{
   25886:	b538      	push	{r3, r4, r5, lr}
	union mpsc_pbuf_generic skip = {
		.skip = { .valid = 0, .busy = 1, .len = wlen }
	};

	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
   25888:	69c2      	ldr	r2, [r0, #28]
{
   2588a:	460d      	mov	r5, r1
	union mpsc_pbuf_generic skip = {
   2588c:	008b      	lsls	r3, r1, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
   2588e:	6801      	ldr	r1, [r0, #0]
	union mpsc_pbuf_generic skip = {
   25890:	f043 0302 	orr.w	r3, r3, #2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
   25894:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
   25898:	462a      	mov	r2, r5
   2589a:	6801      	ldr	r1, [r0, #0]
{
   2589c:	4604      	mov	r4, r0
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
   2589e:	f7ff ffe4 	bl	2586a <idx_inc>
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   258a2:	6861      	ldr	r1, [r4, #4]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
   258a4:	6020      	str	r0, [r4, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   258a6:	462a      	mov	r2, r5
   258a8:	4620      	mov	r0, r4
   258aa:	f7ff ffde 	bl	2586a <idx_inc>
   258ae:	6060      	str	r0, [r4, #4]
}
   258b0:	bd38      	pop	{r3, r4, r5, pc}

000258b2 <drop_item_locked>:
 */
static union mpsc_pbuf_generic *drop_item_locked(struct mpsc_pbuf_buffer *buffer,
						 uint32_t free_wlen,
						 bool allow_drop,
						 bool *user_packet)
{
   258b2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	union mpsc_pbuf_generic *item;
	uint32_t rd_wlen;
	uint32_t skip_wlen;

	*user_packet = false;
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
   258b6:	f8d0 a00c 	ldr.w	sl, [r0, #12]
   258ba:	f8d0 901c 	ldr.w	r9, [r0, #28]
{
   258be:	461f      	mov	r7, r3
	*user_packet = false;
   258c0:	2300      	movs	r3, #0
   258c2:	703b      	strb	r3, [r7, #0]
	if (item->hdr.busy && !item->hdr.valid) {
   258c4:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
   258c8:	f003 0303 	and.w	r3, r3, #3
   258cc:	2b02      	cmp	r3, #2
{
   258ce:	4604      	mov	r4, r0
   258d0:	468b      	mov	fp, r1
   258d2:	4690      	mov	r8, r2
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
   258d4:	eb09 068a 	add.w	r6, r9, sl, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
   258d8:	d103      	bne.n	258e2 <drop_item_locked+0x30>
		return item->skip.len;
   258da:	f859 502a 	ldr.w	r5, [r9, sl, lsl #2]
	skip_wlen = get_skip(item);

	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
   258de:	08ad      	lsrs	r5, r5, #2
   258e0:	d12e      	bne.n	25940 <drop_item_locked+0x8e>
   258e2:	69a3      	ldr	r3, [r4, #24]
   258e4:	4630      	mov	r0, r6
   258e6:	4798      	blx	r3
   258e8:	4605      	mov	r5, r0
	if (skip_wlen) {
		allow_drop = true;
	} else if (allow_drop) {
   258ea:	f1b8 0f00 	cmp.w	r8, #0
   258ee:	d036      	beq.n	2595e <drop_item_locked+0xac>
		if (item->hdr.busy) {
   258f0:	f819 302a 	ldrb.w	r3, [r9, sl, lsl #2]
   258f4:	079b      	lsls	r3, r3, #30
   258f6:	d52f      	bpl.n	25958 <drop_item_locked+0xa6>
			/* item is currently processed and cannot be overwritten. */
			add_skip_item(buffer, free_wlen + 1);
   258f8:	f10b 0101 	add.w	r1, fp, #1
   258fc:	4620      	mov	r0, r4
   258fe:	f7ff ffc2 	bl	25886 <add_skip_item>
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
   25902:	6861      	ldr	r1, [r4, #4]
   25904:	462a      	mov	r2, r5
   25906:	4620      	mov	r0, r4
   25908:	f7ff ffaf 	bl	2586a <idx_inc>
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
   2590c:	6821      	ldr	r1, [r4, #0]
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
   2590e:	6060      	str	r0, [r4, #4]
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
   25910:	462a      	mov	r2, r5
   25912:	4620      	mov	r0, r4
   25914:	f7ff ffa9 	bl	2586a <idx_inc>

			/* Get next itme followed the busy one. */
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   25918:	462a      	mov	r2, r5
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
   2591a:	6020      	str	r0, [r4, #0]
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   2591c:	68e1      	ldr	r1, [r4, #12]
   2591e:	4620      	mov	r0, r4
   25920:	f7ff ffa3 	bl	2586a <idx_inc>

			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
   25924:	69e3      	ldr	r3, [r4, #28]
	if (item->hdr.busy && !item->hdr.valid) {
   25926:	f813 2020 	ldrb.w	r2, [r3, r0, lsl #2]
   2592a:	f002 0203 	and.w	r2, r2, #3
   2592e:	2a02      	cmp	r2, #2
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
   25930:	eb03 0680 	add.w	r6, r3, r0, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
   25934:	d10c      	bne.n	25950 <drop_item_locked+0x9e>
		return item->skip.len;
   25936:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			skip_wlen = get_skip(item);
			if (skip_wlen) {
   2593a:	089b      	lsrs	r3, r3, #2
   2593c:	d008      	beq.n	25950 <drop_item_locked+0x9e>
				rd_wlen += skip_wlen;
   2593e:	441d      	add	r5, r3
	} else {
		item = NULL;
	}

	if (allow_drop) {
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   25940:	68e1      	ldr	r1, [r4, #12]
   25942:	462a      	mov	r2, r5
   25944:	4620      	mov	r0, r4
   25946:	f7ff ff90 	bl	2586a <idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
   2594a:	e9c4 0002 	strd	r0, r0, [r4, #8]
   2594e:	e007      	b.n	25960 <drop_item_locked+0xae>
				rd_wlen += buffer->get_wlen(item);
   25950:	69a3      	ldr	r3, [r4, #24]
   25952:	4630      	mov	r0, r6
   25954:	4798      	blx	r3
   25956:	4405      	add	r5, r0
			*user_packet = true;
   25958:	2301      	movs	r3, #1
   2595a:	703b      	strb	r3, [r7, #0]
   2595c:	e7f0      	b.n	25940 <drop_item_locked+0x8e>
		item = NULL;
   2595e:	4646      	mov	r6, r8
	}

	return item;
}
   25960:	4630      	mov	r0, r6
   25962:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00025966 <mpsc_pbuf_init>:
{
   25966:	b538      	push	{r3, r4, r5, lr}
   25968:	460d      	mov	r5, r1
   2596a:	4604      	mov	r4, r0
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
   2596c:	221c      	movs	r2, #28
   2596e:	2100      	movs	r1, #0
   25970:	f001 ff89 	bl	27886 <memset>
	buffer->get_wlen = cfg->get_wlen;
   25974:	68eb      	ldr	r3, [r5, #12]
	buffer->size = cfg->size;
   25976:	686a      	ldr	r2, [r5, #4]
	buffer->get_wlen = cfg->get_wlen;
   25978:	61a3      	str	r3, [r4, #24]
	buffer->notify_drop = cfg->notify_drop;
   2597a:	68ab      	ldr	r3, [r5, #8]
   2597c:	6163      	str	r3, [r4, #20]
	buffer->buf = cfg->buf;
   2597e:	682b      	ldr	r3, [r5, #0]
   25980:	61e3      	str	r3, [r4, #28]
	buffer->size = cfg->size;
   25982:	6222      	str	r2, [r4, #32]
	buffer->flags = cfg->flags;
   25984:	692b      	ldr	r3, [r5, #16]
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return (x != 0U) && ((x & (x - 1U)) == 0U);
   25986:	b122      	cbz	r2, 25992 <mpsc_pbuf_init+0x2c>
   25988:	1e51      	subs	r1, r2, #1
   2598a:	4211      	tst	r1, r2
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
   2598c:	bf08      	it	eq
   2598e:	f043 0301 	orreq.w	r3, r3, #1
	buffer->flags = cfg->flags;
   25992:	6123      	str	r3, [r4, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
   25994:	2201      	movs	r2, #1
   25996:	f104 0024 	add.w	r0, r4, #36	; 0x24
   2599a:	2100      	movs	r1, #0
}
   2599c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   259a0:	f007 b96d 	b.w	2cc7e <z_impl_k_sem_init>

000259a4 <mpsc_pbuf_alloc>:

}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
   259a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   259a8:	4699      	mov	r9, r3
	uint32_t free_wlen;
	bool valid_drop;

	MPSC_PBUF_DBG(buffer, "alloc %d words, ", (int)wlen);

	if (wlen > (buffer->size - 1)) {
   259aa:	6a03      	ldr	r3, [r0, #32]
   259ac:	3b01      	subs	r3, #1
   259ae:	428b      	cmp	r3, r1
{
   259b0:	b085      	sub	sp, #20
   259b2:	4604      	mov	r4, r0
   259b4:	460f      	mov	r7, r1
   259b6:	4690      	mov	r8, r2
	if (wlen > (buffer->size - 1)) {
   259b8:	d364      	bcc.n	25a84 <mpsc_pbuf_alloc+0xe0>
	union mpsc_pbuf_generic *dropped_item = NULL;
   259ba:	2500      	movs	r5, #0
	union mpsc_pbuf_generic *item = NULL;
   259bc:	46aa      	mov	sl, r5
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
			   !k_is_in_isr()) {
			int err;

			k_spin_unlock(&buffer->lock, key);
			err = k_sem_take(&buffer->sem, timeout);
   259be:	f100 0b24 	add.w	fp, r0, #36	; 0x24
	__asm__ volatile(
   259c2:	f04f 0320 	mov.w	r3, #32
   259c6:	f3ef 8611 	mrs	r6, BASEPRI
   259ca:	f383 8812 	msr	BASEPRI_MAX, r3
   259ce:	f3bf 8f6f 	isb	sy
		wrap = free_space(buffer, &free_wlen);
   259d2:	a903      	add	r1, sp, #12
   259d4:	4620      	mov	r0, r4
   259d6:	f7ff ff33 	bl	25840 <free_space>
		if (free_wlen >= wlen) {
   259da:	9903      	ldr	r1, [sp, #12]
   259dc:	42b9      	cmp	r1, r7
   259de:	d321      	bcc.n	25a24 <mpsc_pbuf_alloc+0x80>
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
   259e0:	6821      	ldr	r1, [r4, #0]
			item =
   259e2:	69e3      	ldr	r3, [r4, #28]
			item->hdr.valid = 0;
   259e4:	f813 2021 	ldrb.w	r2, [r3, r1, lsl #2]
   259e8:	f022 0203 	bic.w	r2, r2, #3
   259ec:	f803 2021 	strb.w	r2, [r3, r1, lsl #2]
			buffer->tmp_wr_idx = idx_inc(buffer,
   259f0:	4620      	mov	r0, r4
   259f2:	463a      	mov	r2, r7
			item =
   259f4:	eb03 0a81 	add.w	sl, r3, r1, lsl #2
			buffer->tmp_wr_idx = idx_inc(buffer,
   259f8:	f7ff ff37 	bl	2586a <idx_inc>
		cont = false;
   259fc:	2300      	movs	r3, #0
			buffer->tmp_wr_idx = idx_inc(buffer,
   259fe:	6020      	str	r0, [r4, #0]
	__asm__ volatile(
   25a00:	f386 8811 	msr	BASEPRI, r6
   25a04:	f3bf 8f6f 	isb	sy
			cont = dropped_item != NULL;
		}

		k_spin_unlock(&buffer->lock, key);

		if (cont && dropped_item && valid_drop) {
   25a08:	2b00      	cmp	r3, #0
   25a0a:	d03d      	beq.n	25a88 <mpsc_pbuf_alloc+0xe4>
   25a0c:	2d00      	cmp	r5, #0
   25a0e:	d0d8      	beq.n	259c2 <mpsc_pbuf_alloc+0x1e>
   25a10:	f89d 300b 	ldrb.w	r3, [sp, #11]
   25a14:	2b00      	cmp	r3, #0
   25a16:	d0d4      	beq.n	259c2 <mpsc_pbuf_alloc+0x1e>
			/* Notify about item being dropped. */
			buffer->notify_drop(buffer, dropped_item);
   25a18:	4629      	mov	r1, r5
   25a1a:	6963      	ldr	r3, [r4, #20]
   25a1c:	4620      	mov	r0, r4
   25a1e:	4798      	blx	r3
			dropped_item = NULL;
   25a20:	2500      	movs	r5, #0
   25a22:	e7ce      	b.n	259c2 <mpsc_pbuf_alloc+0x1e>
		} else if (wrap) {
   25a24:	b128      	cbz	r0, 25a32 <mpsc_pbuf_alloc+0x8e>
   25a26:	9001      	str	r0, [sp, #4]
			add_skip_item(buffer, free_wlen);
   25a28:	4620      	mov	r0, r4
   25a2a:	f7ff ff2c 	bl	25886 <add_skip_item>
			cont = true;
   25a2e:	9b01      	ldr	r3, [sp, #4]
   25a30:	e7e6      	b.n	25a00 <mpsc_pbuf_alloc+0x5c>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   25a32:	ea58 0309 	orrs.w	r3, r8, r9
   25a36:	d017      	beq.n	25a68 <mpsc_pbuf_alloc+0xc4>
			   !k_is_in_isr()) {
   25a38:	f007 f811 	bl	2ca5e <k_is_in_isr>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   25a3c:	b9a0      	cbnz	r0, 25a68 <mpsc_pbuf_alloc+0xc4>
   25a3e:	f386 8811 	msr	BASEPRI, r6
   25a42:	f3bf 8f6f 	isb	sy
	return z_impl_k_sem_take(sem, timeout);
   25a46:	4642      	mov	r2, r8
   25a48:	464b      	mov	r3, r9
   25a4a:	4658      	mov	r0, fp
   25a4c:	f7fe faa8 	bl	23fa0 <z_impl_k_sem_take>
	__asm__ volatile(
   25a50:	f04f 0320 	mov.w	r3, #32
   25a54:	f3ef 8611 	mrs	r6, BASEPRI
   25a58:	f383 8812 	msr	BASEPRI_MAX, r3
   25a5c:	f3bf 8f6f 	isb	sy
			if (err == 0) {
   25a60:	fab0 f380 	clz	r3, r0
   25a64:	095b      	lsrs	r3, r3, #5
   25a66:	e7cb      	b.n	25a00 <mpsc_pbuf_alloc+0x5c>
			bool user_drop = buffer->flags & MPSC_PBUF_MODE_OVERWRITE;
   25a68:	6922      	ldr	r2, [r4, #16]
			dropped_item = drop_item_locked(buffer, free_wlen,
   25a6a:	9903      	ldr	r1, [sp, #12]
   25a6c:	f10d 030b 	add.w	r3, sp, #11
   25a70:	f3c2 0240 	ubfx	r2, r2, #1, #1
   25a74:	4620      	mov	r0, r4
   25a76:	f7ff ff1c 	bl	258b2 <drop_item_locked>
			cont = dropped_item != NULL;
   25a7a:	1e03      	subs	r3, r0, #0
   25a7c:	4605      	mov	r5, r0
   25a7e:	bf18      	it	ne
   25a80:	2301      	movne	r3, #1
   25a82:	e7bd      	b.n	25a00 <mpsc_pbuf_alloc+0x5c>
		return NULL;
   25a84:	f04f 0a00 	mov.w	sl, #0
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
   25a88:	4650      	mov	r0, sl
   25a8a:	b005      	add	sp, #20
   25a8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00025a90 <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
   25a90:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
   25a92:	6983      	ldr	r3, [r0, #24]
{
   25a94:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
   25a96:	4608      	mov	r0, r1
{
   25a98:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
   25a9a:	4798      	blx	r3
   25a9c:	4602      	mov	r2, r0
   25a9e:	f04f 0320 	mov.w	r3, #32
   25aa2:	f3ef 8611 	mrs	r6, BASEPRI
   25aa6:	f383 8812 	msr	BASEPRI_MAX, r3
   25aaa:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);

	item->hdr.valid = 1;
   25aae:	782b      	ldrb	r3, [r5, #0]
   25ab0:	f043 0301 	orr.w	r3, r3, #1
   25ab4:	702b      	strb	r3, [r5, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   25ab6:	6861      	ldr	r1, [r4, #4]
   25ab8:	4620      	mov	r0, r4
   25aba:	f7ff fed6 	bl	2586a <idx_inc>
   25abe:	6060      	str	r0, [r4, #4]
	__asm__ volatile(
   25ac0:	f386 8811 	msr	BASEPRI, r6
   25ac4:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p ", item);
}
   25ac8:	bd70      	pop	{r4, r5, r6, pc}

00025aca <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
   25aca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   25ace:	4604      	mov	r4, r0
	__asm__ volatile(
   25ad0:	f04f 0320 	mov.w	r3, #32
   25ad4:	f3ef 8611 	mrs	r6, BASEPRI
   25ad8:	f383 8812 	msr	BASEPRI_MAX, r3
   25adc:	f3bf 8f6f 	isb	sy
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
   25ae0:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
   25ae4:	429f      	cmp	r7, r3
	*res = buffer->size - buffer->tmp_rd_idx;
   25ae6:	bf88      	it	hi
   25ae8:	6a23      	ldrhi	r3, [r4, #32]
   25aea:	1bdb      	subs	r3, r3, r7
		key = k_spin_lock(&buffer->lock);
		wrap = available(buffer, &a);
		item = (union mpsc_pbuf_generic *)
			&buffer->buf[buffer->tmp_rd_idx];

		if (!a || is_invalid(item)) {
   25aec:	b1f3      	cbz	r3, 25b2c <mpsc_pbuf_claim+0x62>
		item = (union mpsc_pbuf_generic *)
   25aee:	69e1      	ldr	r1, [r4, #28]
	return !item->hdr.valid && !item->hdr.busy;
   25af0:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
		if (!a || is_invalid(item)) {
   25af4:	f012 0303 	ands.w	r3, r2, #3
		item = (union mpsc_pbuf_generic *)
   25af8:	eb01 0887 	add.w	r8, r1, r7, lsl #2
		if (!a || is_invalid(item)) {
   25afc:	d016      	beq.n	25b2c <mpsc_pbuf_claim+0x62>
	if (item->hdr.busy && !item->hdr.valid) {
   25afe:	2b02      	cmp	r3, #2
   25b00:	d103      	bne.n	25b0a <mpsc_pbuf_claim+0x40>
		return item->skip.len;
   25b02:	f851 5027 	ldr.w	r5, [r1, r7, lsl #2]
			item = NULL;
		} else {
			uint32_t skip = get_skip(item);

			if (skip || !is_valid(item)) {
   25b06:	08ad      	lsrs	r5, r5, #2
   25b08:	d115      	bne.n	25b36 <mpsc_pbuf_claim+0x6c>
   25b0a:	07d0      	lsls	r0, r2, #31
				cont = true;
			} else {
				item->hdr.busy = 1;
				buffer->tmp_rd_idx =
					idx_inc(buffer, buffer->tmp_rd_idx,
						buffer->get_wlen(item));
   25b0c:	69a3      	ldr	r3, [r4, #24]
			if (skip || !is_valid(item)) {
   25b0e:	d50f      	bpl.n	25b30 <mpsc_pbuf_claim+0x66>
				item->hdr.busy = 1;
   25b10:	f042 0202 	orr.w	r2, r2, #2
   25b14:	f801 2027 	strb.w	r2, [r1, r7, lsl #2]
					idx_inc(buffer, buffer->tmp_rd_idx,
   25b18:	4640      	mov	r0, r8
   25b1a:	4798      	blx	r3
   25b1c:	4639      	mov	r1, r7
   25b1e:	4602      	mov	r2, r0
   25b20:	4620      	mov	r0, r4
   25b22:	f7ff fea2 	bl	2586a <idx_inc>
		cont = false;
   25b26:	2300      	movs	r3, #0
				buffer->tmp_rd_idx =
   25b28:	60a0      	str	r0, [r4, #8]
   25b2a:	e011      	b.n	25b50 <mpsc_pbuf_claim+0x86>
			item = NULL;
   25b2c:	4698      	mov	r8, r3
   25b2e:	e00f      	b.n	25b50 <mpsc_pbuf_claim+0x86>
					skip ? skip : buffer->get_wlen(item);
   25b30:	4640      	mov	r0, r8
   25b32:	4798      	blx	r3
   25b34:	4605      	mov	r5, r0
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
   25b36:	68a1      	ldr	r1, [r4, #8]
   25b38:	462a      	mov	r2, r5
   25b3a:	4620      	mov	r0, r4
   25b3c:	f7ff fe95 	bl	2586a <idx_inc>
					idx_inc(buffer, buffer->rd_idx, inc);
   25b40:	68e1      	ldr	r1, [r4, #12]
				buffer->tmp_rd_idx =
   25b42:	60a0      	str	r0, [r4, #8]
					idx_inc(buffer, buffer->rd_idx, inc);
   25b44:	462a      	mov	r2, r5
   25b46:	4620      	mov	r0, r4
   25b48:	f7ff fe8f 	bl	2586a <idx_inc>
				cont = true;
   25b4c:	2301      	movs	r3, #1
				buffer->rd_idx =
   25b4e:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   25b50:	f386 8811 	msr	BASEPRI, r6
   25b54:	f3bf 8f6f 	isb	sy

		if (!cont) {
			MPSC_PBUF_DBG(buffer, "claimed: %p ", item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);
   25b58:	2b00      	cmp	r3, #0
   25b5a:	d1b9      	bne.n	25ad0 <mpsc_pbuf_claim+0x6>

	return item;
}
   25b5c:	4640      	mov	r0, r8
   25b5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00025b62 <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
   25b62:	b570      	push	{r4, r5, r6, lr}
	uint32_t wlen = buffer->get_wlen(item);
   25b64:	6983      	ldr	r3, [r0, #24]
{
   25b66:	4604      	mov	r4, r0
	uint32_t wlen = buffer->get_wlen(item);
   25b68:	4608      	mov	r0, r1
{
   25b6a:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
   25b6c:	4798      	blx	r3
   25b6e:	4602      	mov	r2, r0
	__asm__ volatile(
   25b70:	f04f 0320 	mov.w	r3, #32
   25b74:	f3ef 8611 	mrs	r6, BASEPRI
   25b78:	f383 8812 	msr	BASEPRI_MAX, r3
   25b7c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
   25b80:	782b      	ldrb	r3, [r5, #0]
   25b82:	f36f 0300 	bfc	r3, #0, #1
   25b86:	702b      	strb	r3, [r5, #0]
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
   25b88:	6923      	ldr	r3, [r4, #16]
   25b8a:	079b      	lsls	r3, r3, #30
   25b8c:	d505      	bpl.n	25b9a <mpsc_pbuf_free+0x38>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
   25b8e:	68e1      	ldr	r1, [r4, #12]
   25b90:	69e3      	ldr	r3, [r4, #28]
   25b92:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
   25b96:	429d      	cmp	r5, r3
   25b98:	d112      	bne.n	25bc0 <mpsc_pbuf_free+0x5e>
		witem->hdr.busy = 0;
   25b9a:	782b      	ldrb	r3, [r5, #0]
   25b9c:	f36f 0341 	bfc	r3, #1, #1
   25ba0:	702b      	strb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
   25ba2:	68e1      	ldr	r1, [r4, #12]
   25ba4:	4620      	mov	r0, r4
   25ba6:	f7ff fe60 	bl	2586a <idx_inc>
   25baa:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   25bac:	f386 8811 	msr	BASEPRI, r6
   25bb0:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
   25bb4:	f104 0024 	add.w	r0, r4, #36	; 0x24
	}
	MPSC_PBUF_DBG(buffer, "freed: %p ", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
}
   25bb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   25bbc:	f7fe b9ca 	b.w	23f54 <z_impl_k_sem_give>
		witem->skip.len = wlen;
   25bc0:	682b      	ldr	r3, [r5, #0]
   25bc2:	f360 039f 	bfi	r3, r0, #2, #30
   25bc6:	602b      	str	r3, [r5, #0]
   25bc8:	e7f0      	b.n	25bac <mpsc_pbuf_free+0x4a>

00025bca <mpsc_pbuf_is_pending>:
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
   25bca:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   25bce:	4293      	cmp	r3, r2
	*res = buffer->size - buffer->tmp_rd_idx;
   25bd0:	bf8a      	itet	hi
   25bd2:	6a00      	ldrhi	r0, [r0, #32]
		*res = (buffer->wr_idx - buffer->tmp_rd_idx);
   25bd4:	1ad3      	subls	r3, r2, r3
	*res = buffer->size - buffer->tmp_rd_idx;
   25bd6:	1ac3      	subhi	r3, r0, r3
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
   25bd8:	1e18      	subs	r0, r3, #0
   25bda:	bf18      	it	ne
   25bdc:	2001      	movne	r0, #1
   25bde:	4770      	bx	lr

00025be0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   25be0:	4770      	bx	lr

00025be2 <log_msg2_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG2_LOG;
   25be2:	7803      	ldrb	r3, [r0, #0]
	if (z_log_item_is_msg(generic_msg)) {
   25be4:	075b      	lsls	r3, r3, #29
   25be6:	d40b      	bmi.n	25c00 <log_msg2_generic_get_wlen+0x1e>
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
   25be8:	6803      	ldr	r3, [r0, #0]
   25bea:	8840      	ldrh	r0, [r0, #2]
   25bec:	f3c3 2349 	ubfx	r3, r3, #9, #10
   25bf0:	f3c0 00cb 	ubfx	r0, r0, #3, #12
   25bf4:	4418      	add	r0, r3
   25bf6:	3013      	adds	r0, #19
   25bf8:	f020 0007 	bic.w	r0, r0, #7
   25bfc:	0880      	lsrs	r0, r0, #2
		return log_msg2_get_total_wlen(msg->hdr.desc);
   25bfe:	4770      	bx	lr
	return 0;
   25c00:	2000      	movs	r0, #0
}
   25c02:	4770      	bx	lr

00025c04 <default_get_timestamp>:
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   25c04:	f006 be07 	b.w	2c816 <sys_clock_cycle_get_32>

00025c08 <dummy_timestamp>:
   25c08:	2000      	movs	r0, #0
   25c0a:	4770      	bx	lr

00025c0c <notify_drop>:
	z_log_dropped(true);
   25c0c:	2001      	movs	r0, #1
   25c0e:	f7dc bfd9 	b.w	2bc4 <z_log_dropped>

00025c12 <get_msg>:
{
   25c12:	b508      	push	{r3, lr}
		msg.msg2 = z_log_msg2_claim();
   25c14:	f7dd f84a 	bl	2cac <z_log_msg2_claim>
}
   25c18:	bd08      	pop	{r3, pc}

00025c1a <z_log_get_tag>:
}
   25c1a:	2000      	movs	r0, #0
   25c1c:	4770      	bx	lr

00025c1e <buffer_write>:
{
   25c1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25c20:	4606      	mov	r6, r0
   25c22:	460d      	mov	r5, r1
   25c24:	4614      	mov	r4, r2
   25c26:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   25c28:	4621      	mov	r1, r4
   25c2a:	4628      	mov	r0, r5
   25c2c:	463a      	mov	r2, r7
   25c2e:	47b0      	blx	r6
	} while (len != 0);
   25c30:	1a24      	subs	r4, r4, r0
		buf += processed;
   25c32:	4405      	add	r5, r0
	} while (len != 0);
   25c34:	d1f8      	bne.n	25c28 <buffer_write+0xa>
}
   25c36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00025c38 <log_output_flush>:
		     output->control_block->offset,
   25c38:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
   25c3a:	6881      	ldr	r1, [r0, #8]
{
   25c3c:	b510      	push	{r4, lr}
   25c3e:	4604      	mov	r4, r0
	buffer_write(output->func, output->buf,
   25c40:	e9d2 2300 	ldrd	r2, r3, [r2]
   25c44:	6800      	ldr	r0, [r0, #0]
   25c46:	f7ff ffea 	bl	25c1e <buffer_write>
	output->control_block->offset = 0;
   25c4a:	6863      	ldr	r3, [r4, #4]
   25c4c:	2200      	movs	r2, #0
   25c4e:	601a      	str	r2, [r3, #0]
}
   25c50:	bd10      	pop	{r4, pc}

00025c52 <out_func>:
{
   25c52:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
   25c54:	684b      	ldr	r3, [r1, #4]
   25c56:	681a      	ldr	r2, [r3, #0]
   25c58:	68cb      	ldr	r3, [r1, #12]
   25c5a:	429a      	cmp	r2, r3
{
   25c5c:	4605      	mov	r5, r0
   25c5e:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   25c60:	d102      	bne.n	25c68 <out_func+0x16>
		log_output_flush(out_ctx);
   25c62:	4608      	mov	r0, r1
   25c64:	f7ff ffe8 	bl	25c38 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   25c68:	6863      	ldr	r3, [r4, #4]
   25c6a:	f3bf 8f5b 	dmb	ish
   25c6e:	e853 2f00 	ldrex	r2, [r3]
   25c72:	1c51      	adds	r1, r2, #1
   25c74:	e843 1000 	strex	r0, r1, [r3]
   25c78:	2800      	cmp	r0, #0
   25c7a:	d1f8      	bne.n	25c6e <out_func+0x1c>
   25c7c:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
   25c80:	68a3      	ldr	r3, [r4, #8]
   25c82:	549d      	strb	r5, [r3, r2]
}
   25c84:	2000      	movs	r0, #0
   25c86:	bd38      	pop	{r3, r4, r5, pc}

00025c88 <cr_out_func>:
{
   25c88:	b538      	push	{r3, r4, r5, lr}
   25c8a:	4605      	mov	r5, r0
   25c8c:	460c      	mov	r4, r1
	out_func(c, ctx);
   25c8e:	f7ff ffe0 	bl	25c52 <out_func>
	if (c == '\n') {
   25c92:	2d0a      	cmp	r5, #10
   25c94:	d103      	bne.n	25c9e <cr_out_func+0x16>
		out_func((int)'\r', ctx);
   25c96:	4621      	mov	r1, r4
   25c98:	200d      	movs	r0, #13
   25c9a:	f7ff ffda 	bl	25c52 <out_func>
}
   25c9e:	2000      	movs	r0, #0
   25ca0:	bd38      	pop	{r3, r4, r5, pc}

00025ca2 <z_log_msg2_finalize>:
{
   25ca2:	b570      	push	{r4, r5, r6, lr}
   25ca4:	460e      	mov	r6, r1
   25ca6:	4615      	mov	r5, r2
   25ca8:	4619      	mov	r1, r3
	if (!msg) {
   25caa:	4604      	mov	r4, r0
   25cac:	b918      	cbnz	r0, 25cb6 <z_log_msg2_finalize+0x14>
}
   25cae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_log_dropped(false);
   25cb2:	f7dc bf87 	b.w	2bc4 <z_log_dropped>
	if (data) {
   25cb6:	b143      	cbz	r3, 25cca <z_log_msg2_finalize+0x28>
		uint8_t *d = msg->data + desc.package_len;
   25cb8:	f100 030c 	add.w	r3, r0, #12
   25cbc:	f3c2 2049 	ubfx	r0, r2, #9, #10
		memcpy(d, data, desc.data_len);
   25cc0:	4418      	add	r0, r3
   25cc2:	f3c2 42cb 	ubfx	r2, r2, #19, #12
   25cc6:	f001 fdd3 	bl	27870 <memcpy>
	msg->hdr.source = source;
   25cca:	e9c4 5600 	strd	r5, r6, [r4]
	z_log_msg2_commit(msg);
   25cce:	4620      	mov	r0, r4
}
   25cd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_log_msg2_commit(msg);
   25cd4:	f7dd b8ac 	b.w	2e30 <z_log_msg2_commit>

00025cd8 <z_impl_z_log_msg2_static_create>:
{
   25cd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
   25cdc:	f3c1 2949 	ubfx	r9, r1, #9, #10
   25ce0:	f3c1 44cb 	ubfx	r4, r1, #19, #12
   25ce4:	444c      	add	r4, r9
   25ce6:	3413      	adds	r4, #19
   25ce8:	f024 0407 	bic.w	r4, r4, #7
   25cec:	4606      	mov	r6, r0
	struct log_msg2 *msg = z_log_msg2_alloc(msg_wlen);
   25cee:	08a0      	lsrs	r0, r4, #2
{
   25cf0:	460d      	mov	r5, r1
   25cf2:	4690      	mov	r8, r2
   25cf4:	461f      	mov	r7, r3
	struct log_msg2 *msg = z_log_msg2_alloc(msg_wlen);
   25cf6:	f7dc ffd1 	bl	2c9c <z_log_msg2_alloc>
	if (msg) {
   25cfa:	4604      	mov	r4, r0
   25cfc:	b120      	cbz	r0, 25d08 <z_impl_z_log_msg2_static_create+0x30>
		memcpy(msg->data, package, desc.package_len);
   25cfe:	464a      	mov	r2, r9
   25d00:	4641      	mov	r1, r8
   25d02:	300c      	adds	r0, #12
   25d04:	f001 fdb4 	bl	27870 <memcpy>
	z_log_msg2_finalize(msg, source, desc, data);
   25d08:	463b      	mov	r3, r7
   25d0a:	462a      	mov	r2, r5
   25d0c:	4631      	mov	r1, r6
   25d0e:	4620      	mov	r0, r4
}
   25d10:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_log_msg2_finalize(msg, source, desc, data);
   25d14:	f7ff bfc5 	b.w	25ca2 <z_log_msg2_finalize>

00025d18 <nvs_flash_rd>:
{
   25d18:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   25d1a:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25d1c:	8984      	ldrh	r4, [r0, #12]
	rc = flash_read(fs->flash_device, offset, data, len);
   25d1e:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25d20:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   25d22:	fa16 f181 	uxtah	r1, r6, r1
   25d26:	fb05 1104 	mla	r1, r5, r4, r1
	return api->read(dev, offset, data, len);
   25d2a:	6884      	ldr	r4, [r0, #8]
   25d2c:	6824      	ldr	r4, [r4, #0]
   25d2e:	46a4      	mov	ip, r4
}
   25d30:	bc70      	pop	{r4, r5, r6}
   25d32:	4760      	bx	ip

00025d34 <nvs_flash_block_cmp>:
{
   25d34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   25d38:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   25d3a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   25d3c:	681d      	ldr	r5, [r3, #0]
   25d3e:	426d      	negs	r5, r5
{
   25d40:	b089      	sub	sp, #36	; 0x24
   25d42:	4681      	mov	r9, r0
   25d44:	460e      	mov	r6, r1
   25d46:	4617      	mov	r7, r2
	block_size =
   25d48:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   25d4c:	b91c      	cbnz	r4, 25d56 <nvs_flash_block_cmp+0x22>
	return 0;
   25d4e:	4620      	mov	r0, r4
}
   25d50:	b009      	add	sp, #36	; 0x24
   25d52:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   25d56:	42ac      	cmp	r4, r5
   25d58:	46a0      	mov	r8, r4
   25d5a:	bf28      	it	cs
   25d5c:	46a8      	movcs	r8, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   25d5e:	4643      	mov	r3, r8
   25d60:	466a      	mov	r2, sp
   25d62:	4631      	mov	r1, r6
   25d64:	4648      	mov	r0, r9
   25d66:	f7ff ffd7 	bl	25d18 <nvs_flash_rd>
		if (rc) {
   25d6a:	2800      	cmp	r0, #0
   25d6c:	d1f0      	bne.n	25d50 <nvs_flash_block_cmp+0x1c>
		rc = memcmp(data8, buf, bytes_to_cmp);
   25d6e:	4642      	mov	r2, r8
   25d70:	4669      	mov	r1, sp
   25d72:	4638      	mov	r0, r7
   25d74:	f001 fd6b 	bl	2784e <memcmp>
		if (rc) {
   25d78:	b920      	cbnz	r0, 25d84 <nvs_flash_block_cmp+0x50>
		len -= bytes_to_cmp;
   25d7a:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   25d7e:	4446      	add	r6, r8
		data8 += bytes_to_cmp;
   25d80:	4447      	add	r7, r8
   25d82:	e7e3      	b.n	25d4c <nvs_flash_block_cmp+0x18>
			return 1;
   25d84:	2001      	movs	r0, #1
   25d86:	e7e3      	b.n	25d50 <nvs_flash_block_cmp+0x1c>

00025d88 <nvs_flash_cmp_const>:
{
   25d88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   25d8c:	461c      	mov	r4, r3
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   25d8e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   25d90:	681d      	ldr	r5, [r3, #0]
   25d92:	426d      	negs	r5, r5
{
   25d94:	b088      	sub	sp, #32
	block_size =
   25d96:	f005 0520 	and.w	r5, r5, #32
{
   25d9a:	4607      	mov	r7, r0
   25d9c:	460e      	mov	r6, r1
	(void)memset(cmp, value, block_size);
   25d9e:	4668      	mov	r0, sp
{
   25da0:	4611      	mov	r1, r2
	(void)memset(cmp, value, block_size);
   25da2:	462a      	mov	r2, r5
   25da4:	f001 fd6f 	bl	27886 <memset>
	while (len) {
   25da8:	b91c      	cbnz	r4, 25db2 <nvs_flash_cmp_const+0x2a>
	return 0;
   25daa:	4620      	mov	r0, r4
}
   25dac:	b008      	add	sp, #32
   25dae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   25db2:	42ac      	cmp	r4, r5
   25db4:	46a0      	mov	r8, r4
   25db6:	bf28      	it	cs
   25db8:	46a8      	movcs	r8, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   25dba:	4643      	mov	r3, r8
   25dbc:	466a      	mov	r2, sp
   25dbe:	4631      	mov	r1, r6
   25dc0:	4638      	mov	r0, r7
   25dc2:	f7ff ffb7 	bl	25d34 <nvs_flash_block_cmp>
		if (rc) {
   25dc6:	2800      	cmp	r0, #0
   25dc8:	d1f0      	bne.n	25dac <nvs_flash_cmp_const+0x24>
		len -= bytes_to_cmp;
   25dca:	eba4 0408 	sub.w	r4, r4, r8
		addr += bytes_to_cmp;
   25dce:	4446      	add	r6, r8
   25dd0:	e7ea      	b.n	25da8 <nvs_flash_cmp_const+0x20>

00025dd2 <nvs_flash_erase_sector>:
{
   25dd2:	b538      	push	{r3, r4, r5, lr}
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25dd4:	8982      	ldrh	r2, [r0, #12]
   25dd6:	6803      	ldr	r3, [r0, #0]
	addr &= ADDR_SECT_MASK;
   25dd8:	0c0d      	lsrs	r5, r1, #16
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25dda:	0c09      	lsrs	r1, r1, #16
{
   25ddc:	4604      	mov	r4, r0
	addr &= ADDR_SECT_MASK;
   25dde:	042d      	lsls	r5, r5, #16
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   25de0:	6a80      	ldr	r0, [r0, #40]	; 0x28
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25de2:	fb02 3101 	mla	r1, r2, r1, r3
	rc = api->erase(dev, offset, size);
   25de6:	6883      	ldr	r3, [r0, #8]
   25de8:	689b      	ldr	r3, [r3, #8]
   25dea:	4798      	blx	r3
	if (rc) {
   25dec:	b950      	cbnz	r0, 25e04 <nvs_flash_erase_sector+0x32>
	if (nvs_flash_cmp_const(fs, addr, fs->flash_parameters->erase_value,
   25dee:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   25df0:	89a3      	ldrh	r3, [r4, #12]
   25df2:	7912      	ldrb	r2, [r2, #4]
   25df4:	4629      	mov	r1, r5
   25df6:	4620      	mov	r0, r4
   25df8:	f7ff ffc6 	bl	25d88 <nvs_flash_cmp_const>
		rc = -ENXIO;
   25dfc:	2800      	cmp	r0, #0
   25dfe:	bf18      	it	ne
   25e00:	f06f 0005 	mvnne.w	r0, #5
}
   25e04:	bd38      	pop	{r3, r4, r5, pc}

00025e06 <nvs_ate_crc8_update>:
{
   25e06:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   25e08:	4601      	mov	r1, r0
{
   25e0a:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   25e0c:	2207      	movs	r2, #7
   25e0e:	20ff      	movs	r0, #255	; 0xff
   25e10:	f7dc f980 	bl	2114 <crc8_ccitt>
	entry->crc8 = crc8;
   25e14:	71e0      	strb	r0, [r4, #7]
}
   25e16:	bd10      	pop	{r4, pc}

00025e18 <z_log_msg2_static_create.constprop.0>:
   25e18:	2300      	movs	r3, #0
   25e1a:	f7ff bf5d 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00025e1e <nvs_sector_advance.isra.0>:
	*addr += (1 << ADDR_SECT_SHIFT);
   25e1e:	680b      	ldr	r3, [r1, #0]
   25e20:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   25e24:	0c1a      	lsrs	r2, r3, #16
   25e26:	ebb0 4f13 	cmp.w	r0, r3, lsr #16
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   25e2a:	bf08      	it	eq
   25e2c:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   25e30:	600b      	str	r3, [r1, #0]
}
   25e32:	4770      	bx	lr

00025e34 <nvs_al_size.isra.0>:
	if (write_block_size <= 1U) {
   25e34:	7803      	ldrb	r3, [r0, #0]
   25e36:	2b01      	cmp	r3, #1
	return (len + (write_block_size - 1U)) & ~(write_block_size - 1U);
   25e38:	bf81      	itttt	hi
   25e3a:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   25e3e:	18c9      	addhi	r1, r1, r3
   25e40:	425b      	neghi	r3, r3
   25e42:	4019      	andhi	r1, r3
}
   25e44:	4608      	mov	r0, r1
   25e46:	4770      	bx	lr

00025e48 <nvs_ate_valid>:
{
   25e48:	b570      	push	{r4, r5, r6, lr}
   25e4a:	460c      	mov	r4, r1
   25e4c:	4605      	mov	r5, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   25e4e:	2108      	movs	r1, #8
   25e50:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   25e52:	f7ff ffef 	bl	25e34 <nvs_al_size.isra.0>
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   25e56:	2207      	movs	r2, #7
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   25e58:	4606      	mov	r6, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   25e5a:	4621      	mov	r1, r4
   25e5c:	20ff      	movs	r0, #255	; 0xff
   25e5e:	f7dc f959 	bl	2114 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   25e62:	79e3      	ldrb	r3, [r4, #7]
   25e64:	4283      	cmp	r3, r0
   25e66:	d107      	bne.n	25e78 <nvs_ate_valid+0x30>
	    (entry->offset >= (fs->sector_size - ate_size))) {
   25e68:	89a8      	ldrh	r0, [r5, #12]
   25e6a:	8863      	ldrh	r3, [r4, #2]
   25e6c:	1b80      	subs	r0, r0, r6
	if ((nvs_ate_crc8_check(entry)) ||
   25e6e:	4283      	cmp	r3, r0
   25e70:	bf2c      	ite	cs
   25e72:	2000      	movcs	r0, #0
   25e74:	2001      	movcc	r0, #1
}
   25e76:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
   25e78:	2000      	movs	r0, #0
   25e7a:	e7fc      	b.n	25e76 <nvs_ate_valid+0x2e>

00025e7c <nvs_close_ate_valid>:
{
   25e7c:	b538      	push	{r3, r4, r5, lr}
   25e7e:	4605      	mov	r5, r0
   25e80:	460c      	mov	r4, r1
	if ((!nvs_ate_valid(fs, entry)) || (entry->len != 0U) ||
   25e82:	f7ff ffe1 	bl	25e48 <nvs_ate_valid>
   25e86:	b1a0      	cbz	r0, 25eb2 <nvs_close_ate_valid+0x36>
   25e88:	88a0      	ldrh	r0, [r4, #4]
   25e8a:	b998      	cbnz	r0, 25eb4 <nvs_close_ate_valid+0x38>
   25e8c:	8822      	ldrh	r2, [r4, #0]
   25e8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   25e92:	429a      	cmp	r2, r3
   25e94:	d10d      	bne.n	25eb2 <nvs_close_ate_valid+0x36>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   25e96:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   25e98:	2108      	movs	r1, #8
   25e9a:	f7ff ffcb 	bl	25e34 <nvs_al_size.isra.0>
	if ((fs->sector_size - entry->offset) % ate_size) {
   25e9e:	8862      	ldrh	r2, [r4, #2]
   25ea0:	89ab      	ldrh	r3, [r5, #12]
   25ea2:	1a9b      	subs	r3, r3, r2
   25ea4:	fbb3 f2f0 	udiv	r2, r3, r0
   25ea8:	fb02 3010 	mls	r0, r2, r0, r3
   25eac:	fab0 f080 	clz	r0, r0
   25eb0:	0940      	lsrs	r0, r0, #5
}
   25eb2:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   25eb4:	2000      	movs	r0, #0
   25eb6:	e7fc      	b.n	25eb2 <nvs_close_ate_valid+0x36>

00025eb8 <nvs_prev_ate>:
{
   25eb8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   25eba:	4605      	mov	r5, r0
   25ebc:	460e      	mov	r6, r1
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   25ebe:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   25ec0:	2108      	movs	r1, #8
   25ec2:	f7ff ffb7 	bl	25e34 <nvs_al_size.isra.0>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   25ec6:	6831      	ldr	r1, [r6, #0]
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   25ec8:	4607      	mov	r7, r0
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   25eca:	2308      	movs	r3, #8
   25ecc:	4628      	mov	r0, r5
   25ece:	f7ff ff23 	bl	25d18 <nvs_flash_rd>
	if (rc) {
   25ed2:	4604      	mov	r4, r0
   25ed4:	2800      	cmp	r0, #0
   25ed6:	d138      	bne.n	25f4a <nvs_prev_ate+0x92>
	*addr += ate_size;
   25ed8:	6833      	ldr	r3, [r6, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   25eda:	89a8      	ldrh	r0, [r5, #12]
	*addr += ate_size;
   25edc:	443b      	add	r3, r7
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   25ede:	b29a      	uxth	r2, r3
   25ee0:	1bc7      	subs	r7, r0, r7
   25ee2:	42ba      	cmp	r2, r7
	*addr += ate_size;
   25ee4:	6033      	str	r3, [r6, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   25ee6:	d130      	bne.n	25f4a <nvs_prev_ate+0x92>
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
   25ee8:	0c1a      	lsrs	r2, r3, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   25eea:	bf03      	ittte	eq
   25eec:	89e9      	ldrheq	r1, [r5, #14]
   25eee:	f101 31ff 	addeq.w	r1, r1, #4294967295	; 0xffffffff
   25ef2:	eb03 4101 	addeq.w	r1, r3, r1, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
   25ef6:	f5a3 3180 	subne.w	r1, r3, #65536	; 0x10000
   25efa:	6031      	str	r1, [r6, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   25efc:	2308      	movs	r3, #8
   25efe:	466a      	mov	r2, sp
   25f00:	4628      	mov	r0, r5
   25f02:	f7ff ff09 	bl	25d18 <nvs_flash_rd>
	if (rc) {
   25f06:	4604      	mov	r4, r0
   25f08:	b9f8      	cbnz	r0, 25f4a <nvs_prev_ate+0x92>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
   25f0a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   25f0c:	466a      	mov	r2, sp
   25f0e:	7919      	ldrb	r1, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   25f10:	4603      	mov	r3, r0
		if (data8[i] != value) {
   25f12:	f812 0b01 	ldrb.w	r0, [r2], #1
   25f16:	4281      	cmp	r1, r0
   25f18:	d10c      	bne.n	25f34 <nvs_prev_ate+0x7c>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   25f1a:	3301      	adds	r3, #1
   25f1c:	2b08      	cmp	r3, #8
   25f1e:	d1f8      	bne.n	25f12 <nvs_prev_ate+0x5a>
		*addr = fs->ate_wra;
   25f20:	686b      	ldr	r3, [r5, #4]
   25f22:	e005      	b.n	25f30 <nvs_prev_ate+0x78>
		(*addr) &= ADDR_SECT_MASK;
   25f24:	6833      	ldr	r3, [r6, #0]
		(*addr) += close_ate.offset;
   25f26:	f8bd 2002 	ldrh.w	r2, [sp, #2]
		(*addr) &= ADDR_SECT_MASK;
   25f2a:	0c1b      	lsrs	r3, r3, #16
   25f2c:	041b      	lsls	r3, r3, #16
		(*addr) += close_ate.offset;
   25f2e:	4413      	add	r3, r2
		*addr = fs->ate_wra;
   25f30:	6033      	str	r3, [r6, #0]
		return 0;
   25f32:	e00a      	b.n	25f4a <nvs_prev_ate+0x92>
	if (nvs_close_ate_valid(fs, &close_ate)) {
   25f34:	4669      	mov	r1, sp
   25f36:	4628      	mov	r0, r5
   25f38:	f7ff ffa0 	bl	25e7c <nvs_close_ate_valid>
   25f3c:	2800      	cmp	r0, #0
   25f3e:	d1f1      	bne.n	25f24 <nvs_prev_ate+0x6c>
	return nvs_recover_last_ate(fs, addr);
   25f40:	4631      	mov	r1, r6
   25f42:	4628      	mov	r0, r5
   25f44:	f7dd faa6 	bl	3494 <nvs_recover_last_ate>
   25f48:	4604      	mov	r4, r0
}
   25f4a:	4620      	mov	r0, r4
   25f4c:	b003      	add	sp, #12
   25f4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025f50 <nvs_flash_al_wrt.part.0>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, uint32_t addr, const void *data,
   25f50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25f54:	8985      	ldrh	r5, [r0, #12]
static int nvs_flash_al_wrt(struct nvs_fs *fs, uint32_t addr, const void *data,
   25f56:	4607      	mov	r7, r0
	offset += addr & ADDR_OFFS_MASK;
   25f58:	6800      	ldr	r0, [r0, #0]
static int nvs_flash_al_wrt(struct nvs_fs *fs, uint32_t addr, const void *data,
   25f5a:	461c      	mov	r4, r3
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   25f5c:	0c0b      	lsrs	r3, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   25f5e:	fa10 f181 	uxtah	r1, r0, r1
   25f62:	fb03 1505 	mla	r5, r3, r5, r1
	blen = len & ~(fs->flash_parameters->write_block_size - 1U);
   25f66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   25f68:	681e      	ldr	r6, [r3, #0]
   25f6a:	4276      	negs	r6, r6
	if (blen > 0) {
   25f6c:	4026      	ands	r6, r4
static int nvs_flash_al_wrt(struct nvs_fs *fs, uint32_t addr, const void *data,
   25f6e:	b089      	sub	sp, #36	; 0x24
   25f70:	4690      	mov	r8, r2
	if (blen > 0) {
   25f72:	d00a      	beq.n	25f8a <nvs_flash_al_wrt.part.0+0x3a>
		rc = flash_write(fs->flash_device, offset, data8, blen);
   25f74:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	rc = api->write(dev, offset, data, len);
   25f76:	6883      	ldr	r3, [r0, #8]
   25f78:	4629      	mov	r1, r5
   25f7a:	f8d3 9004 	ldr.w	r9, [r3, #4]
   25f7e:	4633      	mov	r3, r6
   25f80:	47c8      	blx	r9
		if (rc) {
   25f82:	b9c0      	cbnz	r0, 25fb6 <nvs_flash_al_wrt.part.0+0x66>
		len -= blen;
   25f84:	1ba4      	subs	r4, r4, r6
		offset += blen;
   25f86:	4435      	add	r5, r6
		data8 += blen;
   25f88:	44b0      	add	r8, r6
	if (len) {
   25f8a:	b1bc      	cbz	r4, 25fbc <nvs_flash_al_wrt.part.0+0x6c>
		memcpy(buf, data8, len);
   25f8c:	4622      	mov	r2, r4
   25f8e:	4641      	mov	r1, r8
   25f90:	4668      	mov	r0, sp
   25f92:	f001 fc6d 	bl	27870 <memcpy>
		(void)memset(buf + len, fs->flash_parameters->erase_value,
   25f96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   25f98:	681a      	ldr	r2, [r3, #0]
   25f9a:	7919      	ldrb	r1, [r3, #4]
   25f9c:	1b12      	subs	r2, r2, r4
   25f9e:	eb0d 0004 	add.w	r0, sp, r4
   25fa2:	f001 fc70 	bl	27886 <memset>
		rc = flash_write(fs->flash_device, offset, buf,
   25fa6:	e9d7 030a 	ldrd	r0, r3, [r7, #40]	; 0x28
   25faa:	681b      	ldr	r3, [r3, #0]
   25fac:	6882      	ldr	r2, [r0, #8]
   25fae:	4629      	mov	r1, r5
   25fb0:	6854      	ldr	r4, [r2, #4]
   25fb2:	466a      	mov	r2, sp
   25fb4:	47a0      	blx	r4
}
   25fb6:	b009      	add	sp, #36	; 0x24
   25fb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
end:
   25fbc:	4620      	mov	r0, r4
   25fbe:	e7fa      	b.n	25fb6 <nvs_flash_al_wrt.part.0+0x66>

00025fc0 <nvs_flash_data_wrt>:
{
   25fc0:	b538      	push	{r3, r4, r5, lr}
   25fc2:	4604      	mov	r4, r0
	if (!len) {
   25fc4:	4615      	mov	r5, r2
   25fc6:	b12a      	cbz	r2, 25fd4 <nvs_flash_data_wrt+0x14>
   25fc8:	4613      	mov	r3, r2
   25fca:	460a      	mov	r2, r1
   25fcc:	6881      	ldr	r1, [r0, #8]
   25fce:	f7ff ffbf 	bl	25f50 <nvs_flash_al_wrt.part.0>
   25fd2:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
   25fd4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   25fd6:	4629      	mov	r1, r5
   25fd8:	f7ff ff2c 	bl	25e34 <nvs_al_size.isra.0>
   25fdc:	68a3      	ldr	r3, [r4, #8]
   25fde:	4403      	add	r3, r0
   25fe0:	60a3      	str	r3, [r4, #8]
}
   25fe2:	4610      	mov	r0, r2
   25fe4:	bd38      	pop	{r3, r4, r5, pc}

00025fe6 <nvs_flash_ate_wrt>:
{
   25fe6:	b510      	push	{r4, lr}
   25fe8:	460a      	mov	r2, r1
	if (!len) {
   25fea:	2308      	movs	r3, #8
   25fec:	6841      	ldr	r1, [r0, #4]
{
   25fee:	4604      	mov	r4, r0
   25ff0:	f7ff ffae 	bl	25f50 <nvs_flash_al_wrt.part.0>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   25ff4:	2108      	movs	r1, #8
   25ff6:	4602      	mov	r2, r0
   25ff8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   25ffa:	f7ff ff1b 	bl	25e34 <nvs_al_size.isra.0>
   25ffe:	6863      	ldr	r3, [r4, #4]
   26000:	1a1b      	subs	r3, r3, r0
   26002:	6063      	str	r3, [r4, #4]
}
   26004:	4610      	mov	r0, r2
   26006:	bd10      	pop	{r4, pc}

00026008 <nvs_add_gc_done_ate>:
{
   26008:	b513      	push	{r0, r1, r4, lr}
	gc_done_ate.id = 0xffff;
   2600a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2600e:	f8ad 3000 	strh.w	r3, [sp]
	gc_done_ate.len = 0U;
   26012:	2300      	movs	r3, #0
{
   26014:	4604      	mov	r4, r0
	gc_done_ate.len = 0U;
   26016:	f8ad 3004 	strh.w	r3, [sp, #4]
	gc_done_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
   2601a:	6883      	ldr	r3, [r0, #8]
   2601c:	f8ad 3002 	strh.w	r3, [sp, #2]
	nvs_ate_crc8_update(&gc_done_ate);
   26020:	4668      	mov	r0, sp
   26022:	f7ff fef0 	bl	25e06 <nvs_ate_crc8_update>
	return nvs_flash_ate_wrt(fs, &gc_done_ate);
   26026:	4669      	mov	r1, sp
   26028:	4620      	mov	r0, r4
   2602a:	f7ff ffdc 	bl	25fe6 <nvs_flash_ate_wrt>
}
   2602e:	b002      	add	sp, #8
   26030:	bd10      	pop	{r4, pc}

00026032 <nvs_gc>:
{
   26032:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26036:	4604      	mov	r4, r0
   26038:	b093      	sub	sp, #76	; 0x4c
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2603a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   2603c:	2108      	movs	r1, #8
   2603e:	f7ff fef9 	bl	25e34 <nvs_al_size.isra.0>
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   26042:	6863      	ldr	r3, [r4, #4]
   26044:	0c1b      	lsrs	r3, r3, #16
   26046:	041b      	lsls	r3, r3, #16
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   26048:	4605      	mov	r5, r0
	nvs_sector_advance(fs, &sec_addr);
   2604a:	a901      	add	r1, sp, #4
   2604c:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   2604e:	9301      	str	r3, [sp, #4]
	nvs_sector_advance(fs, &sec_addr);
   26050:	f7ff fee5 	bl	25e1e <nvs_sector_advance.isra.0>
	gc_addr = sec_addr + fs->sector_size - ate_size;
   26054:	9b01      	ldr	r3, [sp, #4]
   26056:	89a1      	ldrh	r1, [r4, #12]
   26058:	4419      	add	r1, r3
   2605a:	1b49      	subs	r1, r1, r5
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   2605c:	2308      	movs	r3, #8
   2605e:	aa04      	add	r2, sp, #16
   26060:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
   26062:	9102      	str	r1, [sp, #8]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   26064:	f7ff fe58 	bl	25d18 <nvs_flash_rd>
	if (rc < 0) {
   26068:	2800      	cmp	r0, #0
   2606a:	f2c0 8094 	blt.w	26196 <nvs_gc+0x164>
	rc = nvs_ate_cmp_const(&close_ate, fs->flash_parameters->erase_value);
   2606e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   26070:	aa04      	add	r2, sp, #16
   26072:	7919      	ldrb	r1, [r3, #4]
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   26074:	2300      	movs	r3, #0
		if (data8[i] != value) {
   26076:	f812 0b01 	ldrb.w	r0, [r2], #1
   2607a:	4281      	cmp	r1, r0
   2607c:	d17c      	bne.n	26178 <nvs_gc+0x146>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   2607e:	3301      	adds	r3, #1
   26080:	2b08      	cmp	r3, #8
   26082:	d1f8      	bne.n	26076 <nvs_gc+0x44>
	if (fs->ate_wra >= (fs->data_wra + ate_size)) {
   26084:	68a0      	ldr	r0, [r4, #8]
   26086:	6863      	ldr	r3, [r4, #4]
   26088:	4428      	add	r0, r5
   2608a:	4283      	cmp	r3, r0
   2608c:	d26e      	bcs.n	2616c <nvs_gc+0x13a>
	rc = nvs_flash_erase_sector(fs, sec_addr);
   2608e:	9901      	ldr	r1, [sp, #4]
   26090:	4620      	mov	r0, r4
   26092:	f7ff fe9e 	bl	25dd2 <nvs_flash_erase_sector>
	if (rc) {
   26096:	e07e      	b.n	26196 <nvs_gc+0x164>
		gc_addr &= ADDR_SECT_MASK;
   26098:	9b02      	ldr	r3, [sp, #8]
		gc_addr += close_ate.offset;
   2609a:	f8bd 2012 	ldrh.w	r2, [sp, #18]
		gc_addr &= ADDR_SECT_MASK;
   2609e:	0c1b      	lsrs	r3, r3, #16
   260a0:	041b      	lsls	r3, r3, #16
		gc_addr += close_ate.offset;
   260a2:	4413      	add	r3, r2
   260a4:	9302      	str	r3, [sp, #8]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   260a6:	aa06      	add	r2, sp, #24
   260a8:	a902      	add	r1, sp, #8
   260aa:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
   260ac:	f8dd a008 	ldr.w	sl, [sp, #8]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   260b0:	f7ff ff02 	bl	25eb8 <nvs_prev_ate>
		if (rc) {
   260b4:	2800      	cmp	r0, #0
   260b6:	d16e      	bne.n	26196 <nvs_gc+0x164>
		if (!nvs_ate_valid(fs, &gc_ate)) {
   260b8:	a906      	add	r1, sp, #24
   260ba:	4620      	mov	r0, r4
   260bc:	f7ff fec4 	bl	25e48 <nvs_ate_valid>
   260c0:	2800      	cmp	r0, #0
   260c2:	d034      	beq.n	2612e <nvs_gc+0xfc>
		wlk_addr = fs->ate_wra;
   260c4:	6863      	ldr	r3, [r4, #4]
   260c6:	9303      	str	r3, [sp, #12]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   260c8:	aa08      	add	r2, sp, #32
   260ca:	a903      	add	r1, sp, #12
   260cc:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
   260ce:	9e03      	ldr	r6, [sp, #12]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   260d0:	f7ff fef2 	bl	25eb8 <nvs_prev_ate>
			if (rc) {
   260d4:	2800      	cmp	r0, #0
   260d6:	d15e      	bne.n	26196 <nvs_gc+0x164>
			if ((wlk_ate.id == gc_ate.id) &&
   260d8:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   260dc:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   260e0:	429a      	cmp	r2, r3
   260e2:	d027      	beq.n	26134 <nvs_gc+0x102>
		} while (wlk_addr != fs->ate_wra);
   260e4:	6862      	ldr	r2, [r4, #4]
   260e6:	9b03      	ldr	r3, [sp, #12]
   260e8:	429a      	cmp	r2, r3
   260ea:	d1ed      	bne.n	260c8 <nvs_gc+0x96>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
   260ec:	4556      	cmp	r6, sl
   260ee:	d11e      	bne.n	2612e <nvs_gc+0xfc>
   260f0:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   260f4:	b1db      	cbz	r3, 2612e <nvs_gc+0xfc>
			data_addr += gc_ate.offset;
   260f6:	f8bd 301a 	ldrh.w	r3, [sp, #26]
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   260fa:	ea4f 471a 	mov.w	r7, sl, lsr #16
   260fe:	043f      	lsls	r7, r7, #16
			data_addr += gc_ate.offset;
   26100:	441f      	add	r7, r3
			nvs_ate_crc8_update(&gc_ate);
   26102:	a806      	add	r0, sp, #24
			gc_ate.offset = (uint16_t)(fs->data_wra & ADDR_OFFS_MASK);
   26104:	68a3      	ldr	r3, [r4, #8]
   26106:	f8ad 301a 	strh.w	r3, [sp, #26]
			nvs_ate_crc8_update(&gc_ate);
   2610a:	f7ff fe7c 	bl	25e06 <nvs_ate_crc8_update>
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   2610e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
   26110:	f8bd 801c 	ldrh.w	r8, [sp, #28]
		NVS_BLOCK_SIZE & ~(fs->flash_parameters->write_block_size - 1U);
   26114:	681e      	ldr	r6, [r3, #0]
   26116:	4276      	negs	r6, r6
	block_size =
   26118:	f006 0620 	and.w	r6, r6, #32
	while (len) {
   2611c:	f1b8 0f00 	cmp.w	r8, #0
   26120:	d10f      	bne.n	26142 <nvs_gc+0x110>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
   26122:	a906      	add	r1, sp, #24
   26124:	4620      	mov	r0, r4
   26126:	f7ff ff5e 	bl	25fe6 <nvs_flash_ate_wrt>
			if (rc) {
   2612a:	2800      	cmp	r0, #0
   2612c:	d133      	bne.n	26196 <nvs_gc+0x164>
	} while (gc_prev_addr != stop_addr);
   2612e:	45ca      	cmp	sl, r9
   26130:	d1b9      	bne.n	260a6 <nvs_gc+0x74>
gc_done:
   26132:	e7a7      	b.n	26084 <nvs_gc+0x52>
			    (nvs_ate_valid(fs, &wlk_ate))) {
   26134:	a908      	add	r1, sp, #32
   26136:	4620      	mov	r0, r4
   26138:	f7ff fe86 	bl	25e48 <nvs_ate_valid>
			if ((wlk_ate.id == gc_ate.id) &&
   2613c:	2800      	cmp	r0, #0
   2613e:	d0d1      	beq.n	260e4 <nvs_gc+0xb2>
   26140:	e7d4      	b.n	260ec <nvs_gc+0xba>
		bytes_to_copy = MIN(block_size, len);
   26142:	4546      	cmp	r6, r8
   26144:	46b3      	mov	fp, r6
   26146:	bf28      	it	cs
   26148:	46c3      	movcs	fp, r8
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
   2614a:	465b      	mov	r3, fp
   2614c:	aa0a      	add	r2, sp, #40	; 0x28
   2614e:	4639      	mov	r1, r7
   26150:	4620      	mov	r0, r4
   26152:	f7ff fde1 	bl	25d18 <nvs_flash_rd>
		if (rc) {
   26156:	b9f0      	cbnz	r0, 26196 <nvs_gc+0x164>
		rc = nvs_flash_data_wrt(fs, buf, bytes_to_copy);
   26158:	465a      	mov	r2, fp
   2615a:	a90a      	add	r1, sp, #40	; 0x28
   2615c:	4620      	mov	r0, r4
   2615e:	f7ff ff2f 	bl	25fc0 <nvs_flash_data_wrt>
		if (rc) {
   26162:	b9c0      	cbnz	r0, 26196 <nvs_gc+0x164>
		len -= bytes_to_copy;
   26164:	eba8 080b 	sub.w	r8, r8, fp
		addr += bytes_to_copy;
   26168:	445f      	add	r7, fp
   2616a:	e7d7      	b.n	2611c <nvs_gc+0xea>
		rc = nvs_add_gc_done_ate(fs);
   2616c:	4620      	mov	r0, r4
   2616e:	f7ff ff4b 	bl	26008 <nvs_add_gc_done_ate>
		if (rc) {
   26172:	2800      	cmp	r0, #0
   26174:	d08b      	beq.n	2608e <nvs_gc+0x5c>
   26176:	e00e      	b.n	26196 <nvs_gc+0x164>
	stop_addr = gc_addr - ate_size;
   26178:	9b02      	ldr	r3, [sp, #8]
	if (nvs_close_ate_valid(fs, &close_ate)) {
   2617a:	a904      	add	r1, sp, #16
   2617c:	4620      	mov	r0, r4
	stop_addr = gc_addr - ate_size;
   2617e:	eba3 0905 	sub.w	r9, r3, r5
	if (nvs_close_ate_valid(fs, &close_ate)) {
   26182:	f7ff fe7b 	bl	25e7c <nvs_close_ate_valid>
   26186:	2800      	cmp	r0, #0
   26188:	d186      	bne.n	26098 <nvs_gc+0x66>
		rc = nvs_recover_last_ate(fs, &gc_addr);
   2618a:	a902      	add	r1, sp, #8
   2618c:	4620      	mov	r0, r4
   2618e:	f7dd f981 	bl	3494 <nvs_recover_last_ate>
		if (rc) {
   26192:	2800      	cmp	r0, #0
   26194:	d087      	beq.n	260a6 <nvs_gc+0x74>
}
   26196:	b013      	add	sp, #76	; 0x4c
   26198:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0002619c <nvs_delete>:
	return nvs_write(fs, id, NULL, 0);
   2619c:	2300      	movs	r3, #0
   2619e:	461a      	mov	r2, r3
   261a0:	f7dd bba2 	b.w	38e8 <nvs_write>

000261a4 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, uint16_t id, void *data, size_t len)
{
   261a4:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   261a6:	2400      	movs	r4, #0
   261a8:	9400      	str	r4, [sp, #0]
   261aa:	f7dd fc6f 	bl	3a8c <nvs_read_hist>
	return rc;
}
   261ae:	b002      	add	sp, #8
   261b0:	bd10      	pop	{r4, pc}

000261b2 <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
   261b2:	4770      	bx	lr

000261b4 <get_sectors_cb>:
{
   261b4:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
   261b6:	6802      	ldr	r2, [r0, #0]
   261b8:	684c      	ldr	r4, [r1, #4]
   261ba:	42a2      	cmp	r2, r4
   261bc:	d316      	bcc.n	261ec <get_sectors_cb+0x38>
	} else if (info->start_offset >= data->area_off + data->area_len) {
   261be:	688b      	ldr	r3, [r1, #8]
   261c0:	4423      	add	r3, r4
   261c2:	429a      	cmp	r2, r3
   261c4:	d206      	bcs.n	261d4 <get_sectors_cb+0x20>
	} else if (data->ret_idx >= data->ret_len) {
   261c6:	e9d1 3504 	ldrd	r3, r5, [r1, #16]
   261ca:	42ab      	cmp	r3, r5
   261cc:	d304      	bcc.n	261d8 <get_sectors_cb+0x24>
		data->status = -ENOMEM;
   261ce:	f06f 030b 	mvn.w	r3, #11
   261d2:	618b      	str	r3, [r1, #24]
		*bail_value = false;
   261d4:	2000      	movs	r0, #0
   261d6:	e00a      	b.n	261ee <get_sectors_cb+0x3a>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
   261d8:	68cd      	ldr	r5, [r1, #12]
   261da:	1b12      	subs	r2, r2, r4
   261dc:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
   261e0:	f845 2033 	str.w	r2, [r5, r3, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
   261e4:	6842      	ldr	r2, [r0, #4]
   261e6:	6072      	str	r2, [r6, #4]
	data->ret_idx++;
   261e8:	3301      	adds	r3, #1
   261ea:	610b      	str	r3, [r1, #16]
		*bail_value = true;
   261ec:	2001      	movs	r0, #1
}
   261ee:	bd70      	pop	{r4, r5, r6, pc}

000261f0 <settings_load>:
	return settings_load_subtree(NULL);
   261f0:	2000      	movs	r0, #0
   261f2:	f7dd bd3f 	b.w	3c74 <settings_load_subtree>

000261f6 <settings_delete>:
	return settings_save_one(name, NULL, 0);
   261f6:	2200      	movs	r2, #0
   261f8:	4611      	mov	r1, r2
   261fa:	f7dd bd01 	b.w	3c00 <settings_save_one>

000261fe <settings_name_steq>:
{
   261fe:	4603      	mov	r3, r0
   26200:	b530      	push	{r4, r5, lr}
   26202:	4608      	mov	r0, r1
	if (next) {
   26204:	b10a      	cbz	r2, 2620a <settings_name_steq+0xc>
		*next = NULL;
   26206:	2100      	movs	r1, #0
   26208:	6011      	str	r1, [r2, #0]
	if ((!name) || (!key)) {
   2620a:	b163      	cbz	r3, 26226 <settings_name_steq+0x28>
   2620c:	b190      	cbz	r0, 26234 <settings_name_steq+0x36>
   2620e:	1e41      	subs	r1, r0, #1
   26210:	4618      	mov	r0, r3
	while ((*key != '\0') && (*key == *name) &&
   26212:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   26216:	4604      	mov	r4, r0
   26218:	f810 3b01 	ldrb.w	r3, [r0], #1
   2621c:	b15d      	cbz	r5, 26236 <settings_name_steq+0x38>
   2621e:	429d      	cmp	r5, r3
   26220:	d101      	bne.n	26226 <settings_name_steq+0x28>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   26222:	2d3d      	cmp	r5, #61	; 0x3d
   26224:	d1f5      	bne.n	26212 <settings_name_steq+0x14>
	return 0;
   26226:	2000      	movs	r0, #0
   26228:	e004      	b.n	26234 <settings_name_steq+0x36>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   2622a:	2b3d      	cmp	r3, #61	; 0x3d
   2622c:	d008      	beq.n	26240 <settings_name_steq+0x42>
   2622e:	fab3 f083 	clz	r0, r3
   26232:	0940      	lsrs	r0, r0, #5
}
   26234:	bd30      	pop	{r4, r5, pc}
	if (*name == SETTINGS_NAME_SEPARATOR) {
   26236:	2b2f      	cmp	r3, #47	; 0x2f
   26238:	d1f7      	bne.n	2622a <settings_name_steq+0x2c>
		if (next) {
   2623a:	b10a      	cbz	r2, 26240 <settings_name_steq+0x42>
			*next = name + 1;
   2623c:	3401      	adds	r4, #1
   2623e:	6014      	str	r4, [r2, #0]
		return 1;
   26240:	2001      	movs	r0, #1
   26242:	e7f7      	b.n	26234 <settings_name_steq+0x36>

00026244 <settings_name_next>:
{
   26244:	b530      	push	{r4, r5, lr}
   26246:	4603      	mov	r3, r0
	if (next) {
   26248:	b109      	cbz	r1, 2624e <settings_name_next+0xa>
		*next = NULL;
   2624a:	2200      	movs	r2, #0
   2624c:	600a      	str	r2, [r1, #0]
	if (!name) {
   2624e:	b16b      	cbz	r3, 2626c <settings_name_next+0x28>
   26250:	461a      	mov	r2, r3
   26252:	4614      	mov	r4, r2
   26254:	1ad0      	subs	r0, r2, r3
	while ((*name != '\0') && (*name != SETTINGS_NAME_END) &&
   26256:	f812 5b01 	ldrb.w	r5, [r2], #1
   2625a:	b135      	cbz	r5, 2626a <settings_name_next+0x26>
   2625c:	2d3d      	cmp	r5, #61	; 0x3d
   2625e:	d004      	beq.n	2626a <settings_name_next+0x26>
   26260:	2d2f      	cmp	r5, #47	; 0x2f
   26262:	d1f6      	bne.n	26252 <settings_name_next+0xe>
		if (next) {
   26264:	b109      	cbz	r1, 2626a <settings_name_next+0x26>
			*next = name + 1;
   26266:	3401      	adds	r4, #1
   26268:	600c      	str	r4, [r1, #0]
}
   2626a:	bd30      	pop	{r4, r5, pc}
		return 0;
   2626c:	4618      	mov	r0, r3
   2626e:	e7fc      	b.n	2626a <settings_name_next+0x26>

00026270 <settings_nvs_read_fn>:
{
   26270:	b510      	push	{r4, lr}
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   26272:	4613      	mov	r3, r2
{
   26274:	4614      	mov	r4, r2
	rc = nvs_read(rd_fn_arg->fs, rd_fn_arg->id, data, len);
   26276:	460a      	mov	r2, r1
   26278:	8881      	ldrh	r1, [r0, #4]
   2627a:	6800      	ldr	r0, [r0, #0]
   2627c:	f7ff ff92 	bl	261a4 <nvs_read>
}
   26280:	42a0      	cmp	r0, r4
   26282:	bfa8      	it	ge
   26284:	4620      	movge	r0, r4
   26286:	bd10      	pop	{r4, pc}

00026288 <settings_nvs_save>:
{
   26288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2628c:	b097      	sub	sp, #92	; 0x5c
   2628e:	4604      	mov	r4, r0
   26290:	9201      	str	r2, [sp, #4]
   26292:	469b      	mov	fp, r3
	if (!name) {
   26294:	4689      	mov	r9, r1
   26296:	2900      	cmp	r1, #0
   26298:	d069      	beq.n	2636e <settings_nvs_save+0xe6>
	delete = ((value == NULL) || (val_len == 0));
   2629a:	b1da      	cbz	r2, 262d4 <settings_nvs_save+0x4c>
   2629c:	fabb f78b 	clz	r7, fp
   262a0:	097f      	lsrs	r7, r7, #5
	name_id = cf->last_name_id + 1;
   262a2:	8f25      	ldrh	r5, [r4, #56]	; 0x38
   262a4:	3501      	adds	r5, #1
   262a6:	b2ad      	uxth	r5, r5
	write_name_id = cf->last_name_id + 1;
   262a8:	46a8      	mov	r8, r5
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   262aa:	f104 0a08 	add.w	sl, r4, #8
		name_id--;
   262ae:	1e6e      	subs	r6, r5, #1
   262b0:	b2b6      	uxth	r6, r6
		if (name_id == NVS_NAMECNT_ID) {
   262b2:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   262b6:	d02e      	beq.n	26316 <settings_nvs_save+0x8e>
		rc = nvs_read(&cf->cf_nvs, name_id, &rdname, sizeof(rdname));
   262b8:	234a      	movs	r3, #74	; 0x4a
   262ba:	aa03      	add	r2, sp, #12
   262bc:	4631      	mov	r1, r6
   262be:	4650      	mov	r0, sl
   262c0:	f7ff ff70 	bl	261a4 <nvs_read>
		if (rc < 0) {
   262c4:	2800      	cmp	r0, #0
   262c6:	da07      	bge.n	262d8 <settings_nvs_save+0x50>
			if (rc == -ENOENT) {
   262c8:	f110 0f02 	cmn.w	r0, #2
   262cc:	bf08      	it	eq
   262ce:	46b0      	moveq	r8, r6
   262d0:	4635      	mov	r5, r6
   262d2:	e7ec      	b.n	262ae <settings_nvs_save+0x26>
	delete = ((value == NULL) || (val_len == 0));
   262d4:	2701      	movs	r7, #1
   262d6:	e7e4      	b.n	262a2 <settings_nvs_save+0x1a>
		rdname[rc] = '\0';
   262d8:	ab16      	add	r3, sp, #88	; 0x58
   262da:	4418      	add	r0, r3
   262dc:	2300      	movs	r3, #0
   262de:	f800 3c4c 	strb.w	r3, [r0, #-76]
		if (strcmp(name, rdname)) {
   262e2:	a903      	add	r1, sp, #12
   262e4:	4648      	mov	r0, r9
   262e6:	f001 fa95 	bl	27814 <strcmp>
   262ea:	2800      	cmp	r0, #0
   262ec:	d1f0      	bne.n	262d0 <settings_nvs_save+0x48>
		if ((delete) && (name_id == cf->last_name_id)) {
   262ee:	2f00      	cmp	r7, #0
   262f0:	d03b      	beq.n	2636a <settings_nvs_save+0xe2>
   262f2:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   262f4:	42b3      	cmp	r3, r6
   262f6:	d142      	bne.n	2637e <settings_nvs_save+0xf6>
			cf->last_name_id--;
   262f8:	4622      	mov	r2, r4
   262fa:	1e73      	subs	r3, r6, #1
   262fc:	f822 3f38 	strh.w	r3, [r2, #56]!
			rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID,
   26300:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   26304:	2302      	movs	r3, #2
   26306:	4650      	mov	r0, sl
   26308:	f7dd faee 	bl	38e8 <nvs_write>
			if (rc < 0) {
   2630c:	2800      	cmp	r0, #0
   2630e:	da36      	bge.n	2637e <settings_nvs_save+0xf6>
}
   26310:	b017      	add	sp, #92	; 0x5c
   26312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delete) {
   26316:	bb6f      	cbnz	r7, 26374 <settings_nvs_save+0xec>
	write_name = true;
   26318:	2701      	movs	r7, #1
	if (write_name_id == NVS_NAMECNT_ID + NVS_NAME_ID_OFFSET) {
   2631a:	f5b8 4f40 	cmp.w	r8, #49152	; 0xc000
   2631e:	d02b      	beq.n	26378 <settings_nvs_save+0xf0>
	rc = nvs_write(&cf->cf_nvs, write_name_id + NVS_NAME_ID_OFFSET,
   26320:	f104 0508 	add.w	r5, r4, #8
   26324:	f508 4180 	add.w	r1, r8, #16384	; 0x4000
   26328:	9a01      	ldr	r2, [sp, #4]
   2632a:	465b      	mov	r3, fp
   2632c:	b289      	uxth	r1, r1
   2632e:	4628      	mov	r0, r5
   26330:	f7dd fada 	bl	38e8 <nvs_write>
	if (rc < 0) {
   26334:	2800      	cmp	r0, #0
   26336:	dbeb      	blt.n	26310 <settings_nvs_save+0x88>
	if (write_name) {
   26338:	b157      	cbz	r7, 26350 <settings_nvs_save+0xc8>
		rc = nvs_write(&cf->cf_nvs, write_name_id, name, strlen(name));
   2633a:	4648      	mov	r0, r9
   2633c:	f001 fa5a 	bl	277f4 <strlen>
   26340:	464a      	mov	r2, r9
   26342:	4603      	mov	r3, r0
   26344:	4641      	mov	r1, r8
   26346:	4628      	mov	r0, r5
   26348:	f7dd face 	bl	38e8 <nvs_write>
		if (rc < 0) {
   2634c:	2800      	cmp	r0, #0
   2634e:	dbdf      	blt.n	26310 <settings_nvs_save+0x88>
	if (write_name_id > cf->last_name_id) {
   26350:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   26352:	4543      	cmp	r3, r8
   26354:	d220      	bcs.n	26398 <settings_nvs_save+0x110>
		cf->last_name_id = write_name_id;
   26356:	4622      	mov	r2, r4
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   26358:	2302      	movs	r3, #2
		cf->last_name_id = write_name_id;
   2635a:	f822 8f38 	strh.w	r8, [r2, #56]!
		rc = nvs_write(&cf->cf_nvs, NVS_NAMECNT_ID, &cf->last_name_id,
   2635e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   26362:	4628      	mov	r0, r5
   26364:	f7dd fac0 	bl	38e8 <nvs_write>
   26368:	e016      	b.n	26398 <settings_nvs_save+0x110>
   2636a:	46b0      	mov	r8, r6
   2636c:	e7d5      	b.n	2631a <settings_nvs_save+0x92>
		return -EINVAL;
   2636e:	f06f 0015 	mvn.w	r0, #21
   26372:	e7cd      	b.n	26310 <settings_nvs_save+0x88>
		return 0;
   26374:	2000      	movs	r0, #0
   26376:	e7cb      	b.n	26310 <settings_nvs_save+0x88>
		return -ENOMEM;
   26378:	f06f 000b 	mvn.w	r0, #11
   2637c:	e7c8      	b.n	26310 <settings_nvs_save+0x88>
			rc = nvs_delete(&cf->cf_nvs, name_id);
   2637e:	4631      	mov	r1, r6
   26380:	4650      	mov	r0, sl
   26382:	f7ff ff0b 	bl	2619c <nvs_delete>
			if (rc >= 0) {
   26386:	2800      	cmp	r0, #0
   26388:	dbc2      	blt.n	26310 <settings_nvs_save+0x88>
				rc = nvs_delete(&cf->cf_nvs, name_id +
   2638a:	f505 517f 	add.w	r1, r5, #16320	; 0x3fc0
   2638e:	313f      	adds	r1, #63	; 0x3f
   26390:	b289      	uxth	r1, r1
   26392:	4650      	mov	r0, sl
   26394:	f7ff ff02 	bl	2619c <nvs_delete>
	if (rc < 0) {
   26398:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   2639c:	e7b8      	b.n	26310 <settings_nvs_save+0x88>

0002639e <settings_nvs_backend_init>:
{
   2639e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   263a0:	f100 0608 	add.w	r6, r0, #8
   263a4:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
{
   263a6:	4604      	mov	r4, r0
	rc = nvs_init(&cf->cf_nvs, cf->flash_dev_name);
   263a8:	4630      	mov	r0, r6
   263aa:	f7dd f8a5 	bl	34f8 <nvs_init>
	if (rc) {
   263ae:	4605      	mov	r5, r0
   263b0:	b970      	cbnz	r0, 263d0 <settings_nvs_backend_init+0x32>
	rc = nvs_read(&cf->cf_nvs, NVS_NAMECNT_ID, &last_name_id,
   263b2:	2302      	movs	r3, #2
   263b4:	f10d 0206 	add.w	r2, sp, #6
   263b8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   263bc:	4630      	mov	r0, r6
   263be:	f7ff fef1 	bl	261a4 <nvs_read>
	if (rc < 0) {
   263c2:	2800      	cmp	r0, #0
		cf->last_name_id = last_name_id;
   263c4:	bfac      	ite	ge
   263c6:	f8bd 3006 	ldrhge.w	r3, [sp, #6]
		cf->last_name_id = NVS_NAMECNT_ID;
   263ca:	f44f 4300 	movlt.w	r3, #32768	; 0x8000
		cf->last_name_id = last_name_id;
   263ce:	8723      	strh	r3, [r4, #56]	; 0x38
}
   263d0:	4628      	mov	r0, r5
   263d2:	b002      	add	sp, #8
   263d4:	bd70      	pop	{r4, r5, r6, pc}

000263d6 <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
   263d6:	b538      	push	{r3, r4, r5, lr}
   263d8:	460d      	mov	r5, r1
	if (from_len <= to_len) {
   263da:	42ab      	cmp	r3, r5
{
   263dc:	4611      	mov	r1, r2
   263de:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   263e0:	d804      	bhi.n	263ec <_copy+0x16>
		(void)memcpy(to, from, from_len);
   263e2:	461a      	mov	r2, r3
   263e4:	f001 fa44 	bl	27870 <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   263e8:	4620      	mov	r0, r4
   263ea:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   263ec:	2400      	movs	r4, #0
   263ee:	e7fb      	b.n	263e8 <_copy+0x12>

000263f0 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
   263f0:	f001 ba49 	b.w	27886 <memset>

000263f4 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   263f4:	09c3      	lsrs	r3, r0, #7
   263f6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   263fa:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   263fe:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   26402:	b2c0      	uxtb	r0, r0
   26404:	4770      	bx	lr

00026406 <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
   26406:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2640a:	4606      	mov	r6, r0
   2640c:	b0a9      	sub	sp, #164	; 0xa4
   2640e:	4688      	mov	r8, r1
   26410:	4614      	mov	r4, r2
   26412:	2740      	movs	r7, #64	; 0x40
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   26414:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   26418:	f7dd ff72 	bl	4300 <uECC_get_rng>
		if (!rng_function ||
   2641c:	4603      	mov	r3, r0
   2641e:	2800      	cmp	r0, #0
   26420:	d03e      	beq.n	264a0 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   26422:	2140      	movs	r1, #64	; 0x40
   26424:	a808      	add	r0, sp, #32
   26426:	4798      	blx	r3
		if (!rng_function ||
   26428:	b3d0      	cbz	r0, 264a0 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   2642a:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
   2642e:	f112 031f 	adds.w	r3, r2, #31
   26432:	bf48      	it	mi
   26434:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   26438:	466d      	mov	r5, sp
   2643a:	464a      	mov	r2, r9
   2643c:	a908      	add	r1, sp, #32
   2643e:	4628      	mov	r0, r5
   26440:	f343 1347 	sbfx	r3, r3, #5, #8
   26444:	f000 f9ee 	bl	26824 <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
   26448:	4622      	mov	r2, r4
   2644a:	4629      	mov	r1, r5
   2644c:	a818      	add	r0, sp, #96	; 0x60
   2644e:	f000 fe03 	bl	27058 <EccPoint_compute_public_key>
   26452:	b318      	cbz	r0, 2649c <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
   26454:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
   26458:	1dd9      	adds	r1, r3, #7
   2645a:	bf48      	it	mi
   2645c:	f103 010e 	addmi.w	r1, r3, #14
   26460:	462a      	mov	r2, r5
   26462:	4640      	mov	r0, r8
   26464:	10c9      	asrs	r1, r1, #3
   26466:	f000 fe1f 	bl	270a8 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
   2646a:	f994 1001 	ldrsb.w	r1, [r4, #1]
   2646e:	aa18      	add	r2, sp, #96	; 0x60
   26470:	4630      	mov	r0, r6
   26472:	f000 fe19 	bl	270a8 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   26476:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
   2647a:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
   2647e:	ab18      	add	r3, sp, #96	; 0x60
   26480:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   26484:	1870      	adds	r0, r6, r1
   26486:	f000 fe0f 	bl	270a8 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
   2648a:	2220      	movs	r2, #32
   2648c:	2100      	movs	r1, #0
   2648e:	4628      	mov	r0, r5
   26490:	f001 f9f9 	bl	27886 <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
   26494:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
   26496:	b029      	add	sp, #164	; 0xa4
   26498:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   2649c:	3f01      	subs	r7, #1
   2649e:	d1bb      	bne.n	26418 <uECC_make_key+0x12>
        		return 0;
   264a0:	2000      	movs	r0, #0
   264a2:	e7f8      	b.n	26496 <uECC_make_key+0x90>

000264a4 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
   264a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   264a8:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
   264aa:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
   264ae:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
   264b2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   264b6:	b0a4      	sub	sp, #144	; 0x90
   264b8:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
   264ba:	1dda      	adds	r2, r3, #7
   264bc:	bf48      	it	mi
   264be:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
   264c2:	ad04      	add	r5, sp, #16
{
   264c4:	4681      	mov	r9, r0
	uECC_word_t *p2[2] = {_private, tmp};
   264c6:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
   264c8:	4628      	mov	r0, r5
   264ca:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
   264cc:	9502      	str	r5, [sp, #8]
   264ce:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
   264d0:	f000 fdfe 	bl	270d0 <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
   264d4:	463a      	mov	r2, r7
   264d6:	4649      	mov	r1, r9
   264d8:	a814      	add	r0, sp, #80	; 0x50
   264da:	f000 fdf9 	bl	270d0 <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
   264de:	ab14      	add	r3, sp, #80	; 0x50
   264e0:	eb09 0107 	add.w	r1, r9, r7
   264e4:	eb03 008a 	add.w	r0, r3, sl, lsl #2
   264e8:	463a      	mov	r2, r7
   264ea:	f000 fdf1 	bl	270d0 <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
   264ee:	4623      	mov	r3, r4
   264f0:	4632      	mov	r2, r6
   264f2:	4629      	mov	r1, r5
   264f4:	4628      	mov	r0, r5
   264f6:	f000 fd83 	bl	27000 <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
   264fa:	fab0 f380 	clz	r3, r0
   264fe:	9401      	str	r4, [sp, #4]
   26500:	aa24      	add	r2, sp, #144	; 0x90
   26502:	095b      	lsrs	r3, r3, #5
   26504:	eb02 0183 	add.w	r1, r2, r3, lsl #2
   26508:	8863      	ldrh	r3, [r4, #2]
   2650a:	3301      	adds	r3, #1
   2650c:	b21b      	sxth	r3, r3
   2650e:	9300      	str	r3, [sp, #0]
   26510:	f851 2c88 	ldr.w	r2, [r1, #-136]
   26514:	a914      	add	r1, sp, #80	; 0x50
   26516:	2300      	movs	r3, #0
   26518:	4608      	mov	r0, r1
   2651a:	f000 fca4 	bl	26e66 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
   2651e:	aa14      	add	r2, sp, #80	; 0x50
   26520:	4639      	mov	r1, r7
   26522:	4640      	mov	r0, r8
   26524:	f000 fdc0 	bl	270a8 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
   26528:	4621      	mov	r1, r4
   2652a:	a814      	add	r0, sp, #80	; 0x50
   2652c:	f000 fc10 	bl	26d50 <EccPoint_isZero>
   26530:	af02      	add	r7, sp, #8
   26532:	4604      	mov	r4, r0
   26534:	2208      	movs	r2, #8
   26536:	2100      	movs	r1, #0
   26538:	4638      	mov	r0, r7
   2653a:	f001 f9a4 	bl	27886 <memset>
   2653e:	2220      	movs	r2, #32
   26540:	2100      	movs	r1, #0
   26542:	4630      	mov	r0, r6
   26544:	f001 f99f 	bl	27886 <memset>
   26548:	2220      	movs	r2, #32
   2654a:	2100      	movs	r1, #0
   2654c:	4628      	mov	r0, r5
   2654e:	f001 f99a 	bl	27886 <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
   26552:	fab4 f084 	clz	r0, r4
   26556:	0940      	lsrs	r0, r0, #5
   26558:	b024      	add	sp, #144	; 0x90
   2655a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002655e <uECC_vli_add>:
{
   2655e:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   26560:	2400      	movs	r4, #0
{
   26562:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
   26564:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   26566:	b265      	sxtb	r5, r4
   26568:	42ab      	cmp	r3, r5
   2656a:	dc00      	bgt.n	2656e <uECC_vli_add+0x10>
}
   2656c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   2656e:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   26572:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   26576:	443d      	add	r5, r7
   26578:	4405      	add	r5, r0
	return (p_true*(cond)) | (p_false*(!cond));
   2657a:	42af      	cmp	r7, r5
   2657c:	f000 0001 	and.w	r0, r0, #1
   26580:	bf18      	it	ne
   26582:	2000      	movne	r0, #0
		result[i] = sum;
   26584:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   26588:	bf88      	it	hi
   2658a:	f040 0001 	orrhi.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
   2658e:	3401      	adds	r4, #1
   26590:	e7e9      	b.n	26566 <uECC_vli_add+0x8>

00026592 <uECC_vli_rshift1>:
	vli += num_words;
   26592:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
   26596:	2300      	movs	r3, #0
	while (vli-- > end) {
   26598:	4288      	cmp	r0, r1
   2659a:	d300      	bcc.n	2659e <uECC_vli_rshift1+0xc>
}
   2659c:	4770      	bx	lr
		uECC_word_t temp = *vli;
   2659e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   265a2:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   265a6:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   265a8:	07d3      	lsls	r3, r2, #31
   265aa:	e7f5      	b.n	26598 <uECC_vli_rshift1+0x6>

000265ac <vli_modInv_update>:
	if (!EVEN(uv)) {
   265ac:	6803      	ldr	r3, [r0, #0]
{
   265ae:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   265b0:	f013 0601 	ands.w	r6, r3, #1
{
   265b4:	4605      	mov	r5, r0
   265b6:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   265b8:	d005      	beq.n	265c6 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   265ba:	4613      	mov	r3, r2
   265bc:	460a      	mov	r2, r1
   265be:	4601      	mov	r1, r0
   265c0:	f7ff ffcd 	bl	2655e <uECC_vli_add>
   265c4:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   265c6:	4621      	mov	r1, r4
   265c8:	4628      	mov	r0, r5
   265ca:	f7ff ffe2 	bl	26592 <uECC_vli_rshift1>
	if (carry) {
   265ce:	b146      	cbz	r6, 265e2 <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
   265d0:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   265d4:	3a01      	subs	r2, #1
   265d6:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
   265da:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   265de:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
   265e2:	bd70      	pop	{r4, r5, r6, pc}

000265e4 <uECC_vli_mult>:
	for (k = 0; k < num_words; ++k) {
   265e4:	f04f 0c00 	mov.w	ip, #0
{
   265e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uECC_word_t r1 = 0;
   265ec:	4665      	mov	r5, ip
	uECC_word_t r0 = 0;
   265ee:	4664      	mov	r4, ip
	for (k = 0; k < num_words; ++k) {
   265f0:	fa4f f98c 	sxtb.w	r9, ip
   265f4:	454b      	cmp	r3, r9
   265f6:	dc16      	bgt.n	26626 <uECC_vli_mult+0x42>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   265f8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   265fc:	eb06 0643 	add.w	r6, r6, r3, lsl #1
   26600:	9601      	str	r6, [sp, #4]
   26602:	f04f 0800 	mov.w	r8, #0
   26606:	9f01      	ldr	r7, [sp, #4]
   26608:	fa53 fe88 	uxtab	lr, r3, r8
   2660c:	fa4f fe8e 	sxtb.w	lr, lr
   26610:	45be      	cmp	lr, r7
   26612:	fa5f f688 	uxtb.w	r6, r8
   26616:	db26      	blt.n	26666 <uECC_vli_mult+0x82>
	result[num_words * 2 - 1] = r0;
   26618:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   2661c:	f840 4c04 	str.w	r4, [r0, #-4]
}
   26620:	b003      	add	sp, #12
   26622:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
   26626:	f04f 0e00 	mov.w	lr, #0
   2662a:	eb02 0a8c 	add.w	sl, r2, ip, lsl #2
   2662e:	46f0      	mov	r8, lr
	uECC_dword_t p = (uECC_dword_t)a * b;
   26630:	f851 702e 	ldr.w	r7, [r1, lr, lsl #2]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   26634:	f85a 6904 	ldr.w	r6, [sl], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   26638:	fba6 6707 	umull	r6, r7, r6, r7
   2663c:	1934      	adds	r4, r6, r4
		for (i = 0; i <= k; ++i) {
   2663e:	f10e 0e01 	add.w	lr, lr, #1
   26642:	417d      	adcs	r5, r7
   26644:	fa4f f68e 	sxtb.w	r6, lr
   26648:	f04f 0b00 	mov.w	fp, #0
   2664c:	bf28      	it	cs
   2664e:	f04f 0b01 	movcs.w	fp, #1
   26652:	454e      	cmp	r6, r9
	*r2 += (r01 < p);
   26654:	44d8      	add	r8, fp
		for (i = 0; i <= k; ++i) {
   26656:	ddeb      	ble.n	26630 <uECC_vli_mult+0x4c>
		result[k] = r0;
   26658:	f840 402c 	str.w	r4, [r0, ip, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
   2665c:	462c      	mov	r4, r5
   2665e:	f10c 0c01 	add.w	ip, ip, #1
	*r2 += (r01 < p);
   26662:	4645      	mov	r5, r8
   26664:	e7c4      	b.n	265f0 <uECC_vli_mult+0xc>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   26666:	3601      	adds	r6, #1
   26668:	46a9      	mov	r9, r5
   2666a:	b276      	sxtb	r6, r6
   2666c:	eb02 0a8e 	add.w	sl, r2, lr, lsl #2
   26670:	2500      	movs	r5, #0
   26672:	b277      	sxtb	r7, r6
   26674:	42bb      	cmp	r3, r7
   26676:	dc05      	bgt.n	26684 <uECC_vli_mult+0xa0>
		result[k] = r0;
   26678:	f840 402e 	str.w	r4, [r0, lr, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   2667c:	f108 0801 	add.w	r8, r8, #1
		result[k] = r0;
   26680:	464c      	mov	r4, r9
   26682:	e7c0      	b.n	26606 <uECC_vli_mult+0x22>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   26684:	f06f 0703 	mvn.w	r7, #3
   26688:	4377      	muls	r7, r6
	uECC_dword_t p = (uECC_dword_t)a * b;
   2668a:	f851 c026 	ldr.w	ip, [r1, r6, lsl #2]
   2668e:	f85a 7007 	ldr.w	r7, [sl, r7]
   26692:	fba7 7c0c 	umull	r7, ip, r7, ip
   26696:	193c      	adds	r4, r7, r4
   26698:	eb5c 0909 	adcs.w	r9, ip, r9
   2669c:	f04f 0b00 	mov.w	fp, #0
   266a0:	bf28      	it	cs
   266a2:	f04f 0b01 	movcs.w	fp, #1
	*r2 += (r01 < p);
   266a6:	445d      	add	r5, fp
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   266a8:	3601      	adds	r6, #1
   266aa:	e7e2      	b.n	26672 <uECC_vli_mult+0x8e>

000266ac <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   266ac:	2300      	movs	r3, #0
{
   266ae:	b510      	push	{r4, lr}
		 vli[i] = 0;
   266b0:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   266b2:	b25a      	sxtb	r2, r3
   266b4:	4291      	cmp	r1, r2
   266b6:	dc00      	bgt.n	266ba <uECC_vli_clear+0xe>
}
   266b8:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   266ba:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   266be:	3301      	adds	r3, #1
   266c0:	e7f7      	b.n	266b2 <uECC_vli_clear+0x6>

000266c2 <uECC_vli_isZero>:
{
   266c2:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   266c4:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   266c6:	461a      	mov	r2, r3
	for (i = 0; i < num_words; ++i) {
   266c8:	b25c      	sxtb	r4, r3
   266ca:	42a1      	cmp	r1, r4
   266cc:	dc03      	bgt.n	266d6 <uECC_vli_isZero+0x14>
}
   266ce:	fab2 f082 	clz	r0, r2
   266d2:	0940      	lsrs	r0, r0, #5
   266d4:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   266d6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   266da:	3301      	adds	r3, #1
   266dc:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
   266de:	e7f3      	b.n	266c8 <uECC_vli_isZero+0x6>

000266e0 <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   266e0:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   266e2:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   266e4:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   266e8:	f001 011f 	and.w	r1, r1, #31
   266ec:	fa03 f101 	lsl.w	r1, r3, r1
}
   266f0:	4008      	ands	r0, r1
   266f2:	4770      	bx	lr

000266f4 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   266f4:	3901      	subs	r1, #1
{
   266f6:	b510      	push	{r4, lr}
   266f8:	4602      	mov	r2, r0
   266fa:	b249      	sxtb	r1, r1
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   266fc:	1d04      	adds	r4, r0, #4
   266fe:	0608      	lsls	r0, r1, #24
   26700:	b2cb      	uxtb	r3, r1
   26702:	d404      	bmi.n	2670e <uECC_vli_numBits+0x1a>
   26704:	3901      	subs	r1, #1
   26706:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
   2670a:	2800      	cmp	r0, #0
   2670c:	d0f7      	beq.n	266fe <uECC_vli_numBits+0xa>
	return (i + 1);
   2670e:	3301      	adds	r3, #1
   26710:	b258      	sxtb	r0, r3
	if (num_digits == 0) {
   26712:	b150      	cbz	r0, 2672a <uECC_vli_numBits+0x36>
	digit = vli[num_digits - 1];
   26714:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
   26718:	3b01      	subs	r3, #1
   2671a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
	for (i = 0; digit; ++i) {
   2671e:	2300      	movs	r3, #0
   26720:	b922      	cbnz	r2, 2672c <uECC_vli_numBits+0x38>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   26722:	3801      	subs	r0, #1
   26724:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   26728:	b200      	sxth	r0, r0
}
   2672a:	bd10      	pop	{r4, pc}
		digit >>= 1;
   2672c:	0852      	lsrs	r2, r2, #1
	for (i = 0; digit; ++i) {
   2672e:	3301      	adds	r3, #1
   26730:	e7f6      	b.n	26720 <uECC_vli_numBits+0x2c>

00026732 <uECC_vli_set>:
{
   26732:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   26734:	2300      	movs	r3, #0
   26736:	b25c      	sxtb	r4, r3
   26738:	42a2      	cmp	r2, r4
   2673a:	dc00      	bgt.n	2673e <uECC_vli_set+0xc>
}
   2673c:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   2673e:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   26742:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
   26746:	3301      	adds	r3, #1
   26748:	e7f5      	b.n	26736 <uECC_vli_set+0x4>

0002674a <uECC_vli_cmp_unsafe>:
{
   2674a:	b510      	push	{r4, lr}
	for (i = num_words - 1; i >= 0; --i) {
   2674c:	3a01      	subs	r2, #1
   2674e:	b252      	sxtb	r2, r2
   26750:	0613      	lsls	r3, r2, #24
   26752:	d501      	bpl.n	26758 <uECC_vli_cmp_unsafe+0xe>
	return 0;
   26754:	2000      	movs	r0, #0
}
   26756:	bd10      	pop	{r4, pc}
		if (left[i] > right[i]) {
   26758:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
   2675c:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
   26760:	429c      	cmp	r4, r3
   26762:	d805      	bhi.n	26770 <uECC_vli_cmp_unsafe+0x26>
		} else if (left[i] < right[i]) {
   26764:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
   26768:	d2f2      	bcs.n	26750 <uECC_vli_cmp_unsafe+0x6>
			return -1;
   2676a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2676e:	e7f2      	b.n	26756 <uECC_vli_cmp_unsafe+0xc>
			return 1;
   26770:	2001      	movs	r0, #1
   26772:	e7f0      	b.n	26756 <uECC_vli_cmp_unsafe+0xc>

00026774 <uECC_vli_equal>:
{
   26774:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   26776:	3a01      	subs	r2, #1
   26778:	b252      	sxtb	r2, r2
	uECC_word_t diff = 0;
   2677a:	2300      	movs	r3, #0
	for (i = num_words - 1; i >= 0; --i) {
   2677c:	0614      	lsls	r4, r2, #24
   2677e:	d503      	bpl.n	26788 <uECC_vli_equal+0x14>
}
   26780:	1e18      	subs	r0, r3, #0
   26782:	bf18      	it	ne
   26784:	2001      	movne	r0, #1
   26786:	bd30      	pop	{r4, r5, pc}
		diff |= (left[i] ^ right[i]);
   26788:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
   2678c:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   26790:	406c      	eors	r4, r5
   26792:	4323      	orrs	r3, r4
	for (i = num_words - 1; i >= 0; --i) {
   26794:	3a01      	subs	r2, #1
   26796:	e7f1      	b.n	2677c <uECC_vli_equal+0x8>

00026798 <uECC_vli_sub>:
{
   26798:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   2679a:	2400      	movs	r4, #0
{
   2679c:	4606      	mov	r6, r0
   2679e:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   267a0:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   267a2:	b265      	sxtb	r5, r4
   267a4:	4565      	cmp	r5, ip
   267a6:	db00      	blt.n	267aa <uECC_vli_sub+0x12>
}
   267a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   267aa:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
   267ae:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   267b2:	1a3d      	subs	r5, r7, r0
   267b4:	1aed      	subs	r5, r5, r3
	return (p_true*(cond)) | (p_false*(!cond));
   267b6:	42af      	cmp	r7, r5
   267b8:	f000 0001 	and.w	r0, r0, #1
   267bc:	bf18      	it	ne
   267be:	2000      	movne	r0, #0
		result[i] = diff;
   267c0:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   267c4:	bf38      	it	cc
   267c6:	f040 0001 	orrcc.w	r0, r0, #1
	for (i = 0; i < num_words; ++i) {
   267ca:	3401      	adds	r4, #1
   267cc:	e7e9      	b.n	267a2 <uECC_vli_sub+0xa>

000267ce <uECC_vli_modAdd>:
{
   267ce:	b570      	push	{r4, r5, r6, lr}
   267d0:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   267d4:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   267d6:	4633      	mov	r3, r6
{
   267d8:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   267da:	f7ff fec0 	bl	2655e <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   267de:	b930      	cbnz	r0, 267ee <uECC_vli_modAdd+0x20>
   267e0:	4632      	mov	r2, r6
   267e2:	4621      	mov	r1, r4
   267e4:	4628      	mov	r0, r5
   267e6:	f7ff ffb0 	bl	2674a <uECC_vli_cmp_unsafe>
   267ea:	2801      	cmp	r0, #1
   267ec:	d007      	beq.n	267fe <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   267ee:	4633      	mov	r3, r6
   267f0:	462a      	mov	r2, r5
   267f2:	4621      	mov	r1, r4
   267f4:	4620      	mov	r0, r4
}
   267f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   267fa:	f7ff bfcd 	b.w	26798 <uECC_vli_sub>
}
   267fe:	bd70      	pop	{r4, r5, r6, pc}

00026800 <uECC_vli_modSub>:
{
   26800:	b570      	push	{r4, r5, r6, lr}
   26802:	f99d 6010 	ldrsb.w	r6, [sp, #16]
   26806:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   26808:	4633      	mov	r3, r6
{
   2680a:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   2680c:	f7ff ffc4 	bl	26798 <uECC_vli_sub>
	if (l_borrow) {
   26810:	b138      	cbz	r0, 26822 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   26812:	4633      	mov	r3, r6
   26814:	462a      	mov	r2, r5
   26816:	4621      	mov	r1, r4
   26818:	4620      	mov	r0, r4
}
   2681a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   2681e:	f7ff be9e 	b.w	2655e <uECC_vli_add>
}
   26822:	bd70      	pop	{r4, r5, r6, pc}

00026824 <uECC_vli_mmod>:
{
   26824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26828:	b0a5      	sub	sp, #148	; 0x94
   2682a:	461d      	mov	r5, r3
	uECC_word_t *v[2] = {tmp, product};
   2682c:	ab14      	add	r3, sp, #80	; 0x50
   2682e:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   26832:	4680      	mov	r8, r0
			   uECC_vli_numBits(mod, num_words);
   26834:	4629      	mov	r1, r5
   26836:	4610      	mov	r0, r2
{
   26838:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
   2683a:	f7ff ff5b 	bl	266f4 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   2683e:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
   26842:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   26844:	2c00      	cmp	r4, #0
   26846:	4621      	mov	r1, r4
   26848:	bfb8      	it	lt
   2684a:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   2684e:	4263      	negs	r3, r4
   26850:	f003 031f 	and.w	r3, r3, #31
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   26854:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   26858:	f004 061f 	and.w	r6, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
   2685c:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   2685e:	bf58      	it	pl
   26860:	425e      	negpl	r6, r3
	uECC_vli_clear(mod_multiple, word_shift);
   26862:	f7ff ff23 	bl	266ac <uECC_vli_clear>
	if (bit_shift > 0) {
   26866:	2e00      	cmp	r6, #0
   26868:	b208      	sxth	r0, r1
   2686a:	dd2b      	ble.n	268c4 <uECC_vli_mmod+0xa0>
   2686c:	ab04      	add	r3, sp, #16
	uECC_word_t carry = 0;
   2686e:	2200      	movs	r2, #0
   26870:	eb03 0080 	add.w	r0, r3, r0, lsl #2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   26874:	f1c6 0e20 	rsb	lr, r6, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   26878:	4613      	mov	r3, r2
   2687a:	429d      	cmp	r5, r3
   2687c:	d817      	bhi.n	268ae <uECC_vli_mmod+0x8a>
		for (i = 0; i < num_words * 2; ++i) {
   2687e:	006b      	lsls	r3, r5, #1
   26880:	9301      	str	r3, [sp, #4]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   26882:	ab04      	add	r3, sp, #16
   26884:	eb03 0985 	add.w	r9, r3, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   26888:	1e6f      	subs	r7, r5, #1
   2688a:	ab24      	add	r3, sp, #144	; 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   2688c:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   2688e:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
   26892:	2c00      	cmp	r4, #0
   26894:	da54      	bge.n	26940 <uECC_vli_mmod+0x11c>
	uECC_vli_set(result, v[index], num_words);
   26896:	ab24      	add	r3, sp, #144	; 0x90
   26898:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2689c:	462a      	mov	r2, r5
   2689e:	f856 1c88 	ldr.w	r1, [r6, #-136]
   268a2:	4640      	mov	r0, r8
   268a4:	f7ff ff45 	bl	26732 <uECC_vli_set>
}
   268a8:	b025      	add	sp, #148	; 0x94
   268aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   268ae:	f857 c023 	ldr.w	ip, [r7, r3, lsl #2]
   268b2:	fa0c f106 	lsl.w	r1, ip, r6
   268b6:	430a      	orrs	r2, r1
   268b8:	f840 2b04 	str.w	r2, [r0], #4
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   268bc:	3301      	adds	r3, #1
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   268be:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   268c2:	e7da      	b.n	2687a <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   268c4:	ab04      	add	r3, sp, #16
   268c6:	462a      	mov	r2, r5
   268c8:	4639      	mov	r1, r7
   268ca:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   268ce:	f7ff ff30 	bl	26732 <uECC_vli_set>
   268d2:	e7d4      	b.n	2687e <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   268d4:	fa0f fe82 	sxth.w	lr, r2
   268d8:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   268dc:	f853 b02e 	ldr.w	fp, [r3, lr, lsl #2]
   268e0:	ab24      	add	r3, sp, #144	; 0x90
   268e2:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   268e6:	3001      	adds	r0, #1
   268e8:	f852 3c80 	ldr.w	r3, [r2, #-128]
   268ec:	440b      	add	r3, r1
   268ee:	ebbb 0303 	subs.w	r3, fp, r3
   268f2:	bf34      	ite	cc
   268f4:	2201      	movcc	r2, #1
   268f6:	2200      	movcs	r2, #0
			if (diff != v[index][i]) {
   268f8:	459b      	cmp	fp, r3
				borrow = (diff > v[index][i]);
   268fa:	bf18      	it	ne
   268fc:	4611      	movne	r1, r2
			v[1 - index][i] = diff;
   268fe:	f85c 2c88 	ldr.w	r2, [ip, #-136]
   26902:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
   26906:	9b01      	ldr	r3, [sp, #4]
   26908:	b242      	sxtb	r2, r0
   2690a:	429a      	cmp	r2, r3
   2690c:	dbe2      	blt.n	268d4 <uECC_vli_mmod+0xb0>
		index = !(index ^ borrow);
   2690e:	1a73      	subs	r3, r6, r1
   26910:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   26912:	4629      	mov	r1, r5
   26914:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   26916:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   26918:	f7ff fe3b 	bl	26592 <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   2691c:	ab24      	add	r3, sp, #144	; 0x90
   2691e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   26922:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   26924:	f853 2c80 	ldr.w	r2, [r3, #-128]
   26928:	f857 3c80 	ldr.w	r3, [r7, #-128]
   2692c:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
   26930:	f847 3c80 	str.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   26934:	4648      	mov	r0, r9
   26936:	3c01      	subs	r4, #1
   26938:	f7ff fe2b 	bl	26592 <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
   2693c:	b224      	sxth	r4, r4
   2693e:	e7a8      	b.n	26892 <uECC_vli_mmod+0x6e>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   26940:	ab24      	add	r3, sp, #144	; 0x90
   26942:	2000      	movs	r0, #0
			v[1 - index][i] = diff;
   26944:	f1c6 0c01 	rsb	ip, r6, #1
		uECC_word_t borrow = 0;
   26948:	4601      	mov	r1, r0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   2694a:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   2694e:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   26952:	e7d8      	b.n	26906 <uECC_vli_mmod+0xe2>

00026954 <uECC_vli_modMult_fast>:
{
   26954:	b530      	push	{r4, r5, lr}
   26956:	461c      	mov	r4, r3
   26958:	b091      	sub	sp, #68	; 0x44
   2695a:	4605      	mov	r5, r0
	uECC_vli_mult(product, left, right, curve->num_words);
   2695c:	f993 3000 	ldrsb.w	r3, [r3]
   26960:	4668      	mov	r0, sp
   26962:	f7ff fe3f 	bl	265e4 <uECC_vli_mult>
	curve->mmod_fast(result, product);
   26966:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   2696a:	4669      	mov	r1, sp
   2696c:	4628      	mov	r0, r5
   2696e:	4798      	blx	r3
}
   26970:	b011      	add	sp, #68	; 0x44
   26972:	bd30      	pop	{r4, r5, pc}

00026974 <uECC_vli_modSquare_fast>:
{
   26974:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
   26976:	460a      	mov	r2, r1
   26978:	f7ff bfec 	b.w	26954 <uECC_vli_modMult_fast>

0002697c <double_jacobian_default>:
{
   2697c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   26980:	f993 6000 	ldrsb.w	r6, [r3]
{
   26984:	b092      	sub	sp, #72	; 0x48
   26986:	4604      	mov	r4, r0
   26988:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   2698a:	4610      	mov	r0, r2
   2698c:	4631      	mov	r1, r6
{
   2698e:	4615      	mov	r5, r2
   26990:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   26992:	f7ff fe96 	bl	266c2 <uECC_vli_isZero>
   26996:	2800      	cmp	r0, #0
   26998:	f040 8091 	bne.w	26abe <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   2699c:	463a      	mov	r2, r7
   2699e:	4649      	mov	r1, r9
   269a0:	a802      	add	r0, sp, #8
   269a2:	f7ff ffe7 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   269a6:	463b      	mov	r3, r7
   269a8:	aa02      	add	r2, sp, #8
   269aa:	4621      	mov	r1, r4
   269ac:	a80a      	add	r0, sp, #40	; 0x28
   269ae:	f7ff ffd1 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   269b2:	a902      	add	r1, sp, #8
   269b4:	4608      	mov	r0, r1
   269b6:	463a      	mov	r2, r7
   269b8:	f7ff ffdc 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   269bc:	463b      	mov	r3, r7
   269be:	462a      	mov	r2, r5
   269c0:	4649      	mov	r1, r9
   269c2:	4648      	mov	r0, r9
   269c4:	f7ff ffc6 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   269c8:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   269cc:	463a      	mov	r2, r7
   269ce:	4629      	mov	r1, r5
   269d0:	4628      	mov	r0, r5
   269d2:	f7ff ffcf 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   269d6:	4643      	mov	r3, r8
   269d8:	462a      	mov	r2, r5
   269da:	4621      	mov	r1, r4
   269dc:	4620      	mov	r0, r4
   269de:	9600      	str	r6, [sp, #0]
   269e0:	f7ff fef5 	bl	267ce <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   269e4:	4643      	mov	r3, r8
   269e6:	462a      	mov	r2, r5
   269e8:	4629      	mov	r1, r5
   269ea:	4628      	mov	r0, r5
   269ec:	9600      	str	r6, [sp, #0]
   269ee:	f7ff feee 	bl	267ce <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   269f2:	4643      	mov	r3, r8
   269f4:	462a      	mov	r2, r5
   269f6:	4621      	mov	r1, r4
   269f8:	4628      	mov	r0, r5
   269fa:	9600      	str	r6, [sp, #0]
   269fc:	f7ff ff00 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   26a00:	463b      	mov	r3, r7
   26a02:	462a      	mov	r2, r5
   26a04:	4621      	mov	r1, r4
   26a06:	4620      	mov	r0, r4
   26a08:	f7ff ffa4 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   26a0c:	4643      	mov	r3, r8
   26a0e:	4622      	mov	r2, r4
   26a10:	4621      	mov	r1, r4
   26a12:	4628      	mov	r0, r5
   26a14:	9600      	str	r6, [sp, #0]
   26a16:	f7ff feda 	bl	267ce <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   26a1a:	4643      	mov	r3, r8
   26a1c:	9600      	str	r6, [sp, #0]
   26a1e:	462a      	mov	r2, r5
   26a20:	4621      	mov	r1, r4
   26a22:	4620      	mov	r0, r4
   26a24:	f7ff fed3 	bl	267ce <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   26a28:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   26a2a:	07db      	lsls	r3, r3, #31
   26a2c:	d54a      	bpl.n	26ac4 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   26a2e:	4633      	mov	r3, r6
   26a30:	4642      	mov	r2, r8
   26a32:	4621      	mov	r1, r4
   26a34:	4620      	mov	r0, r4
   26a36:	f7ff fd92 	bl	2655e <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
   26a3a:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   26a3c:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   26a3e:	4620      	mov	r0, r4
   26a40:	f7ff fda7 	bl	26592 <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   26a44:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   26a48:	3b01      	subs	r3, #1
   26a4a:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
   26a4e:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
   26a52:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   26a56:	463a      	mov	r2, r7
   26a58:	4621      	mov	r1, r4
   26a5a:	4628      	mov	r0, r5
   26a5c:	f7ff ff8a 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   26a60:	4643      	mov	r3, r8
   26a62:	aa0a      	add	r2, sp, #40	; 0x28
   26a64:	4629      	mov	r1, r5
   26a66:	4628      	mov	r0, r5
   26a68:	9600      	str	r6, [sp, #0]
   26a6a:	f7ff fec9 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   26a6e:	4643      	mov	r3, r8
   26a70:	aa0a      	add	r2, sp, #40	; 0x28
   26a72:	4629      	mov	r1, r5
   26a74:	4628      	mov	r0, r5
   26a76:	9600      	str	r6, [sp, #0]
   26a78:	f7ff fec2 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   26a7c:	a90a      	add	r1, sp, #40	; 0x28
   26a7e:	4608      	mov	r0, r1
   26a80:	4643      	mov	r3, r8
   26a82:	462a      	mov	r2, r5
   26a84:	9600      	str	r6, [sp, #0]
   26a86:	f7ff febb 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   26a8a:	463b      	mov	r3, r7
   26a8c:	aa0a      	add	r2, sp, #40	; 0x28
   26a8e:	4621      	mov	r1, r4
   26a90:	4620      	mov	r0, r4
   26a92:	f7ff ff5f 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   26a96:	aa02      	add	r2, sp, #8
   26a98:	4643      	mov	r3, r8
   26a9a:	4610      	mov	r0, r2
   26a9c:	4621      	mov	r1, r4
   26a9e:	9600      	str	r6, [sp, #0]
   26aa0:	f7ff feae 	bl	26800 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   26aa4:	4632      	mov	r2, r6
   26aa6:	4629      	mov	r1, r5
   26aa8:	4620      	mov	r0, r4
   26aaa:	f7ff fe42 	bl	26732 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   26aae:	4649      	mov	r1, r9
   26ab0:	4628      	mov	r0, r5
   26ab2:	f7ff fe3e 	bl	26732 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   26ab6:	a902      	add	r1, sp, #8
   26ab8:	4648      	mov	r0, r9
   26aba:	f7ff fe3a 	bl	26732 <uECC_vli_set>
}
   26abe:	b012      	add	sp, #72	; 0x48
   26ac0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   26ac4:	4631      	mov	r1, r6
   26ac6:	4620      	mov	r0, r4
   26ac8:	f7ff fd63 	bl	26592 <uECC_vli_rshift1>
   26acc:	e7c3      	b.n	26a56 <double_jacobian_default+0xda>

00026ace <x_side_default>:
{
   26ace:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26ad2:	4615      	mov	r5, r2
   26ad4:	b08a      	sub	sp, #40	; 0x28
   26ad6:	4604      	mov	r4, r0
   26ad8:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   26ada:	221c      	movs	r2, #28
   26adc:	2100      	movs	r1, #0
   26ade:	a803      	add	r0, sp, #12
   26ae0:	f000 fed1 	bl	27886 <memset>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   26ae4:	1d2f      	adds	r7, r5, #4
	wordcount_t num_words = curve->num_words;
   26ae6:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   26aea:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   26aec:	462a      	mov	r2, r5
   26aee:	4631      	mov	r1, r6
   26af0:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   26af2:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   26af4:	f7ff ff3e 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   26af8:	463b      	mov	r3, r7
   26afa:	aa02      	add	r2, sp, #8
   26afc:	4621      	mov	r1, r4
   26afe:	4620      	mov	r0, r4
   26b00:	f8cd 8000 	str.w	r8, [sp]
   26b04:	f7ff fe7c 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   26b08:	462b      	mov	r3, r5
   26b0a:	4632      	mov	r2, r6
   26b0c:	4621      	mov	r1, r4
   26b0e:	4620      	mov	r0, r4
   26b10:	f7ff ff20 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   26b14:	f8cd 8000 	str.w	r8, [sp]
   26b18:	463b      	mov	r3, r7
   26b1a:	f105 0284 	add.w	r2, r5, #132	; 0x84
   26b1e:	4621      	mov	r1, r4
   26b20:	4620      	mov	r0, r4
   26b22:	f7ff fe54 	bl	267ce <uECC_vli_modAdd>
}
   26b26:	b00a      	add	sp, #40	; 0x28
   26b28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00026b2c <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   26b2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26b30:	b09a      	sub	sp, #104	; 0x68
   26b32:	4616      	mov	r6, r2
   26b34:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   26b38:	4644      	mov	r4, r8
{
   26b3a:	4699      	mov	r9, r3
	wordcount_t num_words = curve->num_words;
   26b3c:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   26b40:	9500      	str	r5, [sp, #0]
{
   26b42:	4607      	mov	r7, r0
   26b44:	468a      	mov	sl, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   26b46:	4623      	mov	r3, r4
   26b48:	4602      	mov	r2, r0
   26b4a:	4631      	mov	r1, r6
   26b4c:	a802      	add	r0, sp, #8
   26b4e:	f7ff fe57 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   26b52:	a902      	add	r1, sp, #8
   26b54:	4642      	mov	r2, r8
   26b56:	4608      	mov	r0, r1
   26b58:	f7ff ff0c 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   26b5c:	4643      	mov	r3, r8
   26b5e:	aa02      	add	r2, sp, #8
   26b60:	4639      	mov	r1, r7
   26b62:	4638      	mov	r0, r7
   26b64:	f7ff fef6 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   26b68:	4643      	mov	r3, r8
   26b6a:	aa02      	add	r2, sp, #8
   26b6c:	4631      	mov	r1, r6
   26b6e:	4630      	mov	r0, r6
   26b70:	f7ff fef0 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   26b74:	4623      	mov	r3, r4
   26b76:	4652      	mov	r2, sl
   26b78:	4649      	mov	r1, r9
   26b7a:	a802      	add	r0, sp, #8
   26b7c:	9500      	str	r5, [sp, #0]
   26b7e:	f7ff fe26 	bl	267ce <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   26b82:	4623      	mov	r3, r4
   26b84:	4652      	mov	r2, sl
   26b86:	4649      	mov	r1, r9
   26b88:	4648      	mov	r0, r9
   26b8a:	9500      	str	r5, [sp, #0]
   26b8c:	f7ff fe38 	bl	26800 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   26b90:	4623      	mov	r3, r4
   26b92:	463a      	mov	r2, r7
   26b94:	4631      	mov	r1, r6
   26b96:	a80a      	add	r0, sp, #40	; 0x28
   26b98:	9500      	str	r5, [sp, #0]
   26b9a:	f7ff fe31 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   26b9e:	4643      	mov	r3, r8
   26ba0:	aa0a      	add	r2, sp, #40	; 0x28
   26ba2:	4651      	mov	r1, sl
   26ba4:	4650      	mov	r0, sl
   26ba6:	f7ff fed5 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   26baa:	4623      	mov	r3, r4
   26bac:	4632      	mov	r2, r6
   26bae:	4639      	mov	r1, r7
   26bb0:	a80a      	add	r0, sp, #40	; 0x28
   26bb2:	9500      	str	r5, [sp, #0]
   26bb4:	f7ff fe0b 	bl	267ce <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   26bb8:	4642      	mov	r2, r8
   26bba:	4649      	mov	r1, r9
   26bbc:	4630      	mov	r0, r6
   26bbe:	f7ff fed9 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   26bc2:	4623      	mov	r3, r4
   26bc4:	aa0a      	add	r2, sp, #40	; 0x28
   26bc6:	4631      	mov	r1, r6
   26bc8:	4630      	mov	r0, r6
   26bca:	9500      	str	r5, [sp, #0]
   26bcc:	f7ff fe18 	bl	26800 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   26bd0:	4623      	mov	r3, r4
   26bd2:	4632      	mov	r2, r6
   26bd4:	4639      	mov	r1, r7
   26bd6:	a812      	add	r0, sp, #72	; 0x48
   26bd8:	9500      	str	r5, [sp, #0]
   26bda:	f7ff fe11 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   26bde:	4643      	mov	r3, r8
   26be0:	aa12      	add	r2, sp, #72	; 0x48
   26be2:	4649      	mov	r1, r9
   26be4:	4648      	mov	r0, r9
   26be6:	f7ff feb5 	bl	26954 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   26bea:	4623      	mov	r3, r4
   26bec:	4652      	mov	r2, sl
   26bee:	4649      	mov	r1, r9
   26bf0:	4648      	mov	r0, r9
   26bf2:	9500      	str	r5, [sp, #0]
   26bf4:	f7ff fe04 	bl	26800 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   26bf8:	4642      	mov	r2, r8
   26bfa:	a902      	add	r1, sp, #8
   26bfc:	a812      	add	r0, sp, #72	; 0x48
   26bfe:	f7ff feb9 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   26c02:	a912      	add	r1, sp, #72	; 0x48
   26c04:	4623      	mov	r3, r4
   26c06:	aa0a      	add	r2, sp, #40	; 0x28
   26c08:	4608      	mov	r0, r1
   26c0a:	9500      	str	r5, [sp, #0]
   26c0c:	f7ff fdf8 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   26c10:	4623      	mov	r3, r4
   26c12:	463a      	mov	r2, r7
   26c14:	a912      	add	r1, sp, #72	; 0x48
   26c16:	a80a      	add	r0, sp, #40	; 0x28
   26c18:	9500      	str	r5, [sp, #0]
   26c1a:	f7ff fdf1 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   26c1e:	a90a      	add	r1, sp, #40	; 0x28
   26c20:	4643      	mov	r3, r8
   26c22:	aa02      	add	r2, sp, #8
   26c24:	4608      	mov	r0, r1
   26c26:	f7ff fe95 	bl	26954 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   26c2a:	4623      	mov	r3, r4
   26c2c:	4652      	mov	r2, sl
   26c2e:	a90a      	add	r1, sp, #40	; 0x28
   26c30:	4650      	mov	r0, sl
   26c32:	9500      	str	r5, [sp, #0]
   26c34:	f7ff fde4 	bl	26800 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   26c38:	462a      	mov	r2, r5
   26c3a:	a912      	add	r1, sp, #72	; 0x48
   26c3c:	4638      	mov	r0, r7
   26c3e:	f7ff fd78 	bl	26732 <uECC_vli_set>
}
   26c42:	b01a      	add	sp, #104	; 0x68
   26c44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00026c48 <uECC_vli_modInv>:
{
   26c48:	b5f0      	push	{r4, r5, r6, r7, lr}
   26c4a:	460f      	mov	r7, r1
   26c4c:	b0a1      	sub	sp, #132	; 0x84
   26c4e:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   26c50:	4619      	mov	r1, r3
   26c52:	4638      	mov	r0, r7
{
   26c54:	4615      	mov	r5, r2
   26c56:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   26c58:	f7ff fd33 	bl	266c2 <uECC_vli_isZero>
   26c5c:	b128      	cbz	r0, 26c6a <uECC_vli_modInv+0x22>
		uECC_vli_clear(result, num_words);
   26c5e:	4630      	mov	r0, r6
}
   26c60:	b021      	add	sp, #132	; 0x84
   26c62:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		uECC_vli_clear(result, num_words);
   26c66:	f7ff bd21 	b.w	266ac <uECC_vli_clear>
	uECC_vli_set(a, input, num_words);
   26c6a:	4622      	mov	r2, r4
   26c6c:	4639      	mov	r1, r7
   26c6e:	4668      	mov	r0, sp
   26c70:	f7ff fd5f 	bl	26732 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   26c74:	4629      	mov	r1, r5
   26c76:	a808      	add	r0, sp, #32
   26c78:	f7ff fd5b 	bl	26732 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   26c7c:	a810      	add	r0, sp, #64	; 0x40
   26c7e:	4621      	mov	r1, r4
   26c80:	f7ff fd14 	bl	266ac <uECC_vli_clear>
	u[0] = 1;
   26c84:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   26c86:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   26c88:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   26c8a:	f7ff fd0f 	bl	266ac <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   26c8e:	4622      	mov	r2, r4
   26c90:	a908      	add	r1, sp, #32
   26c92:	4668      	mov	r0, sp
   26c94:	f7ff fd59 	bl	2674a <uECC_vli_cmp_unsafe>
   26c98:	b930      	cbnz	r0, 26ca8 <uECC_vli_modInv+0x60>
  	uECC_vli_set(result, u, num_words);
   26c9a:	4622      	mov	r2, r4
   26c9c:	a910      	add	r1, sp, #64	; 0x40
   26c9e:	4630      	mov	r0, r6
   26ca0:	f7ff fd47 	bl	26732 <uECC_vli_set>
}
   26ca4:	b021      	add	sp, #132	; 0x84
   26ca6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (EVEN(a)) {
   26ca8:	9b00      	ldr	r3, [sp, #0]
   26caa:	07da      	lsls	r2, r3, #31
   26cac:	d409      	bmi.n	26cc2 <uECC_vli_modInv+0x7a>
			uECC_vli_rshift1(a, num_words);
   26cae:	4621      	mov	r1, r4
   26cb0:	4668      	mov	r0, sp
   26cb2:	f7ff fc6e 	bl	26592 <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   26cb6:	4622      	mov	r2, r4
   26cb8:	4629      	mov	r1, r5
   26cba:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   26cbc:	f7ff fc76 	bl	265ac <vli_modInv_update>
   26cc0:	e7e5      	b.n	26c8e <uECC_vli_modInv+0x46>
    		} else if (EVEN(b)) {
   26cc2:	9b08      	ldr	r3, [sp, #32]
   26cc4:	07db      	lsls	r3, r3, #31
   26cc6:	d407      	bmi.n	26cd8 <uECC_vli_modInv+0x90>
			uECC_vli_rshift1(b, num_words);
   26cc8:	4621      	mov	r1, r4
   26cca:	a808      	add	r0, sp, #32
   26ccc:	f7ff fc61 	bl	26592 <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   26cd0:	4622      	mov	r2, r4
   26cd2:	4629      	mov	r1, r5
   26cd4:	a818      	add	r0, sp, #96	; 0x60
   26cd6:	e7f1      	b.n	26cbc <uECC_vli_modInv+0x74>
		} else if (cmpResult > 0) {
   26cd8:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   26cda:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   26cdc:	dd1c      	ble.n	26d18 <uECC_vli_modInv+0xd0>
			uECC_vli_sub(a, a, b, num_words);
   26cde:	aa08      	add	r2, sp, #32
   26ce0:	4669      	mov	r1, sp
   26ce2:	4668      	mov	r0, sp
   26ce4:	f7ff fd58 	bl	26798 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   26ce8:	4621      	mov	r1, r4
   26cea:	4668      	mov	r0, sp
   26cec:	f7ff fc51 	bl	26592 <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   26cf0:	4622      	mov	r2, r4
   26cf2:	a918      	add	r1, sp, #96	; 0x60
   26cf4:	a810      	add	r0, sp, #64	; 0x40
   26cf6:	f7ff fd28 	bl	2674a <uECC_vli_cmp_unsafe>
   26cfa:	2800      	cmp	r0, #0
   26cfc:	da05      	bge.n	26d0a <uECC_vli_modInv+0xc2>
        			uECC_vli_add(u, u, mod, num_words);
   26cfe:	a910      	add	r1, sp, #64	; 0x40
   26d00:	4623      	mov	r3, r4
   26d02:	462a      	mov	r2, r5
   26d04:	4608      	mov	r0, r1
   26d06:	f7ff fc2a 	bl	2655e <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   26d0a:	a910      	add	r1, sp, #64	; 0x40
   26d0c:	4623      	mov	r3, r4
   26d0e:	aa18      	add	r2, sp, #96	; 0x60
   26d10:	4608      	mov	r0, r1
   26d12:	f7ff fd41 	bl	26798 <uECC_vli_sub>
   26d16:	e7ce      	b.n	26cb6 <uECC_vli_modInv+0x6e>
      			uECC_vli_sub(b, b, a, num_words);
   26d18:	466a      	mov	r2, sp
   26d1a:	a808      	add	r0, sp, #32
   26d1c:	f7ff fd3c 	bl	26798 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   26d20:	4621      	mov	r1, r4
   26d22:	a808      	add	r0, sp, #32
   26d24:	f7ff fc35 	bl	26592 <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   26d28:	4622      	mov	r2, r4
   26d2a:	a910      	add	r1, sp, #64	; 0x40
   26d2c:	a818      	add	r0, sp, #96	; 0x60
   26d2e:	f7ff fd0c 	bl	2674a <uECC_vli_cmp_unsafe>
   26d32:	2800      	cmp	r0, #0
   26d34:	da05      	bge.n	26d42 <uECC_vli_modInv+0xfa>
        			uECC_vli_add(v, v, mod, num_words);
   26d36:	a918      	add	r1, sp, #96	; 0x60
   26d38:	4623      	mov	r3, r4
   26d3a:	462a      	mov	r2, r5
   26d3c:	4608      	mov	r0, r1
   26d3e:	f7ff fc0e 	bl	2655e <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   26d42:	a918      	add	r1, sp, #96	; 0x60
   26d44:	4623      	mov	r3, r4
   26d46:	aa10      	add	r2, sp, #64	; 0x40
   26d48:	4608      	mov	r0, r1
   26d4a:	f7ff fd25 	bl	26798 <uECC_vli_sub>
   26d4e:	e7bf      	b.n	26cd0 <uECC_vli_modInv+0x88>

00026d50 <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
   26d50:	7809      	ldrb	r1, [r1, #0]
   26d52:	0049      	lsls	r1, r1, #1
   26d54:	b249      	sxtb	r1, r1
   26d56:	f7ff bcb4 	b.w	266c2 <uECC_vli_isZero>

00026d5a <apply_z>:
{
   26d5a:	b5f0      	push	{r4, r5, r6, r7, lr}
   26d5c:	4615      	mov	r5, r2
   26d5e:	b089      	sub	sp, #36	; 0x24
   26d60:	461c      	mov	r4, r3
   26d62:	4607      	mov	r7, r0
   26d64:	460e      	mov	r6, r1
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   26d66:	461a      	mov	r2, r3
   26d68:	4629      	mov	r1, r5
   26d6a:	4668      	mov	r0, sp
   26d6c:	f7ff fe02 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   26d70:	4623      	mov	r3, r4
   26d72:	466a      	mov	r2, sp
   26d74:	4639      	mov	r1, r7
   26d76:	4638      	mov	r0, r7
   26d78:	f7ff fdec 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   26d7c:	4623      	mov	r3, r4
   26d7e:	462a      	mov	r2, r5
   26d80:	4669      	mov	r1, sp
   26d82:	4668      	mov	r0, sp
   26d84:	f7ff fde6 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   26d88:	4623      	mov	r3, r4
   26d8a:	466a      	mov	r2, sp
   26d8c:	4631      	mov	r1, r6
   26d8e:	4630      	mov	r0, r6
   26d90:	f7ff fde0 	bl	26954 <uECC_vli_modMult_fast>
}
   26d94:	b009      	add	sp, #36	; 0x24
   26d96:	bdf0      	pop	{r4, r5, r6, r7, pc}

00026d98 <XYcZ_add>:
{
   26d98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26d9c:	b08a      	sub	sp, #40	; 0x28
   26d9e:	4614      	mov	r4, r2
   26da0:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
	wordcount_t num_words = curve->num_words;
   26da4:	4655      	mov	r5, sl
{
   26da6:	461f      	mov	r7, r3
	wordcount_t num_words = curve->num_words;
   26da8:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   26dac:	9600      	str	r6, [sp, #0]
{
   26dae:	4680      	mov	r8, r0
   26db0:	4689      	mov	r9, r1
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   26db2:	462b      	mov	r3, r5
   26db4:	4602      	mov	r2, r0
   26db6:	4621      	mov	r1, r4
   26db8:	a802      	add	r0, sp, #8
   26dba:	f7ff fd21 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   26dbe:	a902      	add	r1, sp, #8
   26dc0:	4652      	mov	r2, sl
   26dc2:	4608      	mov	r0, r1
   26dc4:	f7ff fdd6 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   26dc8:	4653      	mov	r3, sl
   26dca:	aa02      	add	r2, sp, #8
   26dcc:	4641      	mov	r1, r8
   26dce:	4640      	mov	r0, r8
   26dd0:	f7ff fdc0 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   26dd4:	4653      	mov	r3, sl
   26dd6:	aa02      	add	r2, sp, #8
   26dd8:	4621      	mov	r1, r4
   26dda:	4620      	mov	r0, r4
   26ddc:	f7ff fdba 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   26de0:	462b      	mov	r3, r5
   26de2:	464a      	mov	r2, r9
   26de4:	4639      	mov	r1, r7
   26de6:	4638      	mov	r0, r7
   26de8:	9600      	str	r6, [sp, #0]
   26dea:	f7ff fd09 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   26dee:	4652      	mov	r2, sl
   26df0:	4639      	mov	r1, r7
   26df2:	a802      	add	r0, sp, #8
   26df4:	f7ff fdbe 	bl	26974 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   26df8:	a902      	add	r1, sp, #8
   26dfa:	462b      	mov	r3, r5
   26dfc:	4642      	mov	r2, r8
   26dfe:	4608      	mov	r0, r1
   26e00:	9600      	str	r6, [sp, #0]
   26e02:	f7ff fcfd 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   26e06:	a902      	add	r1, sp, #8
   26e08:	462b      	mov	r3, r5
   26e0a:	4622      	mov	r2, r4
   26e0c:	4608      	mov	r0, r1
   26e0e:	9600      	str	r6, [sp, #0]
   26e10:	f7ff fcf6 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   26e14:	462b      	mov	r3, r5
   26e16:	4642      	mov	r2, r8
   26e18:	4621      	mov	r1, r4
   26e1a:	4620      	mov	r0, r4
   26e1c:	9600      	str	r6, [sp, #0]
   26e1e:	f7ff fcef 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   26e22:	4653      	mov	r3, sl
   26e24:	4622      	mov	r2, r4
   26e26:	4649      	mov	r1, r9
   26e28:	4648      	mov	r0, r9
   26e2a:	f7ff fd93 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   26e2e:	462b      	mov	r3, r5
   26e30:	aa02      	add	r2, sp, #8
   26e32:	4641      	mov	r1, r8
   26e34:	4620      	mov	r0, r4
   26e36:	9600      	str	r6, [sp, #0]
   26e38:	f7ff fce2 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   26e3c:	4653      	mov	r3, sl
   26e3e:	4622      	mov	r2, r4
   26e40:	4639      	mov	r1, r7
   26e42:	4638      	mov	r0, r7
   26e44:	f7ff fd86 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   26e48:	462b      	mov	r3, r5
   26e4a:	464a      	mov	r2, r9
   26e4c:	4639      	mov	r1, r7
   26e4e:	4638      	mov	r0, r7
   26e50:	9600      	str	r6, [sp, #0]
   26e52:	f7ff fcd5 	bl	26800 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   26e56:	4632      	mov	r2, r6
   26e58:	a902      	add	r1, sp, #8
   26e5a:	4620      	mov	r0, r4
   26e5c:	f7ff fc69 	bl	26732 <uECC_vli_set>
}
   26e60:	b00a      	add	sp, #40	; 0x28
   26e62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00026e66 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   26e66:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26e6a:	b0b1      	sub	sp, #196	; 0xc4
   26e6c:	e9cd 0103 	strd	r0, r1, [sp, #12]
   26e70:	9c3b      	ldr	r4, [sp, #236]	; 0xec
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   26e72:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
   26e76:	a818      	add	r0, sp, #96	; 0x60
{
   26e78:	4692      	mov	sl, r2
	uECC_vli_set(Rx[1], point, num_words);
   26e7a:	463a      	mov	r2, r7
{
   26e7c:	461d      	mov	r5, r3
	uECC_vli_set(Rx[1], point, num_words);
   26e7e:	f7ff fc58 	bl	26732 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   26e82:	00bb      	lsls	r3, r7, #2
   26e84:	9305      	str	r3, [sp, #20]
   26e86:	9b04      	ldr	r3, [sp, #16]
   26e88:	eb03 0387 	add.w	r3, r3, r7, lsl #2
   26e8c:	4619      	mov	r1, r3
   26e8e:	a828      	add	r0, sp, #160	; 0xa0
   26e90:	9302      	str	r3, [sp, #8]
   26e92:	f7ff fc4e 	bl	26732 <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
   26e96:	f994 6000 	ldrsb.w	r6, [r4]
	if (initial_Z) {
   26e9a:	2d00      	cmp	r5, #0
   26e9c:	f000 8086 	beq.w	26fac <EccPoint_mult+0x146>
		uECC_vli_set(z, initial_Z, num_words);
   26ea0:	4632      	mov	r2, r6
   26ea2:	4629      	mov	r1, r5
   26ea4:	a808      	add	r0, sp, #32
   26ea6:	f7ff fc44 	bl	26732 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   26eaa:	f10d 0840 	add.w	r8, sp, #64	; 0x40
   26eae:	4632      	mov	r2, r6
   26eb0:	a918      	add	r1, sp, #96	; 0x60
   26eb2:	4640      	mov	r0, r8
	uECC_vli_set(Y2, Y1, num_words);
   26eb4:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
   26eb8:	f7ff fc3b 	bl	26732 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   26ebc:	a928      	add	r1, sp, #160	; 0xa0
   26ebe:	4648      	mov	r0, r9
   26ec0:	f7ff fc37 	bl	26732 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   26ec4:	4623      	mov	r3, r4
   26ec6:	aa08      	add	r2, sp, #32
   26ec8:	a818      	add	r0, sp, #96	; 0x60
   26eca:	f7ff ff46 	bl	26d5a <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   26ece:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   26ed2:	4623      	mov	r3, r4
   26ed4:	aa08      	add	r2, sp, #32
   26ed6:	a928      	add	r1, sp, #160	; 0xa0
   26ed8:	a818      	add	r0, sp, #96	; 0x60
   26eda:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   26edc:	4623      	mov	r3, r4
   26ede:	aa08      	add	r2, sp, #32
   26ee0:	4649      	mov	r1, r9
   26ee2:	4640      	mov	r0, r8
   26ee4:	f7ff ff39 	bl	26d5a <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   26ee8:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
   26eec:	3d02      	subs	r5, #2
   26eee:	b22d      	sxth	r5, r5
   26ef0:	2d00      	cmp	r5, #0
   26ef2:	dc62      	bgt.n	26fba <EccPoint_mult+0x154>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   26ef4:	f8da 5000 	ldr.w	r5, [sl]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   26ef8:	9400      	str	r4, [sp, #0]
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   26efa:	f005 0601 	and.w	r6, r5, #1
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   26efe:	ab10      	add	r3, sp, #64	; 0x40
   26f00:	eb03 1846 	add.w	r8, r3, r6, lsl #5
   26f04:	43ed      	mvns	r5, r5
   26f06:	ab20      	add	r3, sp, #128	; 0x80
   26f08:	eb03 1646 	add.w	r6, r3, r6, lsl #5
   26f0c:	f005 0501 	and.w	r5, r5, #1
   26f10:	ab10      	add	r3, sp, #64	; 0x40
   26f12:	eb03 1945 	add.w	r9, r3, r5, lsl #5
   26f16:	ab20      	add	r3, sp, #128	; 0x80
   26f18:	eb03 1545 	add.w	r5, r3, r5, lsl #5
   26f1c:	462b      	mov	r3, r5
   26f1e:	464a      	mov	r2, r9
   26f20:	4631      	mov	r1, r6
   26f22:	4640      	mov	r0, r8

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   26f24:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   26f28:	f7ff fe00 	bl	26b2c <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   26f2c:	4653      	mov	r3, sl
   26f2e:	aa10      	add	r2, sp, #64	; 0x40
   26f30:	a918      	add	r1, sp, #96	; 0x60
   26f32:	a808      	add	r0, sp, #32
   26f34:	9700      	str	r7, [sp, #0]
   26f36:	f7ff fc63 	bl	26800 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   26f3a:	a908      	add	r1, sp, #32
   26f3c:	4623      	mov	r3, r4
   26f3e:	4632      	mov	r2, r6
   26f40:	4608      	mov	r0, r1
   26f42:	f7ff fd07 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   26f46:	a908      	add	r1, sp, #32
   26f48:	9a04      	ldr	r2, [sp, #16]
   26f4a:	4623      	mov	r3, r4
   26f4c:	4608      	mov	r0, r1
   26f4e:	f7ff fd01 	bl	26954 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   26f52:	a908      	add	r1, sp, #32
   26f54:	463b      	mov	r3, r7
   26f56:	4652      	mov	r2, sl
   26f58:	4608      	mov	r0, r1
   26f5a:	f7ff fe75 	bl	26c48 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   26f5e:	a908      	add	r1, sp, #32
   26f60:	9a02      	ldr	r2, [sp, #8]
   26f62:	4623      	mov	r3, r4
   26f64:	4608      	mov	r0, r1
   26f66:	f7ff fcf5 	bl	26954 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   26f6a:	a908      	add	r1, sp, #32
   26f6c:	4623      	mov	r3, r4
   26f6e:	4642      	mov	r2, r8
   26f70:	4608      	mov	r0, r1
   26f72:	f7ff fcef 	bl	26954 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   26f76:	4633      	mov	r3, r6
   26f78:	4642      	mov	r2, r8
   26f7a:	4629      	mov	r1, r5
   26f7c:	4648      	mov	r0, r9
   26f7e:	9400      	str	r4, [sp, #0]
   26f80:	f7ff ff0a 	bl	26d98 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   26f84:	4623      	mov	r3, r4
   26f86:	aa08      	add	r2, sp, #32
   26f88:	a920      	add	r1, sp, #128	; 0x80
   26f8a:	a810      	add	r0, sp, #64	; 0x40
   26f8c:	f7ff fee5 	bl	26d5a <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   26f90:	9803      	ldr	r0, [sp, #12]
   26f92:	463a      	mov	r2, r7
   26f94:	a910      	add	r1, sp, #64	; 0x40
   26f96:	f7ff fbcc 	bl	26732 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   26f9a:	9803      	ldr	r0, [sp, #12]
   26f9c:	9b05      	ldr	r3, [sp, #20]
   26f9e:	a920      	add	r1, sp, #128	; 0x80
   26fa0:	4418      	add	r0, r3
   26fa2:	f7ff fbc6 	bl	26732 <uECC_vli_set>
}
   26fa6:	b031      	add	sp, #196	; 0xc4
   26fa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   26fac:	4631      	mov	r1, r6
   26fae:	a808      	add	r0, sp, #32
   26fb0:	f7ff fb7c 	bl	266ac <uECC_vli_clear>
		z[0] = 1;
   26fb4:	2301      	movs	r3, #1
   26fb6:	9308      	str	r3, [sp, #32]
   26fb8:	e777      	b.n	26eaa <EccPoint_mult+0x44>
		nb = !uECC_vli_testBit(scalar, i);
   26fba:	4629      	mov	r1, r5
   26fbc:	4650      	mov	r0, sl
   26fbe:	f7ff fb8f 	bl	266e0 <uECC_vli_testBit>
   26fc2:	fab0 f680 	clz	r6, r0
   26fc6:	0976      	lsrs	r6, r6, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   26fc8:	f1c6 0101 	rsb	r1, r6, #1
   26fcc:	eb08 1b46 	add.w	fp, r8, r6, lsl #5
   26fd0:	eb09 1646 	add.w	r6, r9, r6, lsl #5
   26fd4:	eb08 1041 	add.w	r0, r8, r1, lsl #5
   26fd8:	4633      	mov	r3, r6
   26fda:	eb09 1141 	add.w	r1, r9, r1, lsl #5
   26fde:	465a      	mov	r2, fp
   26fe0:	9400      	str	r4, [sp, #0]
   26fe2:	e9cd 0106 	strd	r0, r1, [sp, #24]
   26fe6:	f7ff fda1 	bl	26b2c <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   26fea:	9907      	ldr	r1, [sp, #28]
   26fec:	9806      	ldr	r0, [sp, #24]
   26fee:	9400      	str	r4, [sp, #0]
   26ff0:	460b      	mov	r3, r1
   26ff2:	4602      	mov	r2, r0
   26ff4:	4631      	mov	r1, r6
   26ff6:	4658      	mov	r0, fp
   26ff8:	f7ff fece 	bl	26d98 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   26ffc:	3d01      	subs	r5, #1
   26ffe:	e776      	b.n	26eee <EccPoint_mult+0x88>

00027000 <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   27000:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   27004:	f9b3 9002 	ldrsh.w	r9, [r3, #2]
   27008:	f119 081f 	adds.w	r8, r9, #31
{
   2700c:	461d      	mov	r5, r3
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   2700e:	bf48      	it	mi
   27010:	f109 083e 	addmi.w	r8, r9, #62	; 0x3e
{
   27014:	460e      	mov	r6, r1
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   27016:	f348 1847 	sbfx	r8, r8, #5, #8

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   2701a:	3524      	adds	r5, #36	; 0x24
   2701c:	4601      	mov	r1, r0
{
   2701e:	4617      	mov	r7, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   27020:	4643      	mov	r3, r8
   27022:	462a      	mov	r2, r5
   27024:	4630      	mov	r0, r6
   27026:	f7ff fa9a 	bl	2655e <uECC_vli_add>
   2702a:	4604      	mov	r4, r0
   2702c:	b990      	cbnz	r0, 27054 <regularize_k+0x54>
   2702e:	ebb9 1f48 	cmp.w	r9, r8, lsl #5
   27032:	da06      	bge.n	27042 <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   27034:	4649      	mov	r1, r9
   27036:	4630      	mov	r0, r6
   27038:	f7ff fb52 	bl	266e0 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   2703c:	1e04      	subs	r4, r0, #0
   2703e:	bf18      	it	ne
   27040:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   27042:	4643      	mov	r3, r8
   27044:	462a      	mov	r2, r5
   27046:	4631      	mov	r1, r6
   27048:	4638      	mov	r0, r7
   2704a:	f7ff fa88 	bl	2655e <uECC_vli_add>

	return carry;
}
   2704e:	4620      	mov	r0, r4
   27050:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   27054:	2401      	movs	r4, #1
   27056:	e7f4      	b.n	27042 <regularize_k+0x42>

00027058 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
   27058:	b530      	push	{r4, r5, lr}
   2705a:	4614      	mov	r4, r2
   2705c:	b095      	sub	sp, #84	; 0x54
   2705e:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
   27060:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   27062:	4623      	mov	r3, r4
{
   27064:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
   27066:	a904      	add	r1, sp, #16
   27068:	9102      	str	r1, [sp, #8]
   2706a:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
   2706c:	f7ff ffc8 	bl	27000 <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
   27070:	fab0 f380 	clz	r3, r0
   27074:	095b      	lsrs	r3, r3, #5
   27076:	aa14      	add	r2, sp, #80	; 0x50
   27078:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   2707c:	8863      	ldrh	r3, [r4, #2]
   2707e:	9401      	str	r4, [sp, #4]
   27080:	3301      	adds	r3, #1
   27082:	b21b      	sxth	r3, r3
   27084:	9300      	str	r3, [sp, #0]
   27086:	f852 2c48 	ldr.w	r2, [r2, #-72]
   2708a:	2300      	movs	r3, #0
   2708c:	f104 0144 	add.w	r1, r4, #68	; 0x44
   27090:	4628      	mov	r0, r5
   27092:	f7ff fee8 	bl	26e66 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
   27096:	4621      	mov	r1, r4
   27098:	4628      	mov	r0, r5
   2709a:	f7ff fe59 	bl	26d50 <EccPoint_isZero>
		return 0;
	}
	return 1;
}
   2709e:	fab0 f080 	clz	r0, r0
   270a2:	0940      	lsrs	r0, r0, #5
   270a4:	b015      	add	sp, #84	; 0x54
   270a6:	bd30      	pop	{r4, r5, pc}

000270a8 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   270a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   270aa:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   270ac:	1e4f      	subs	r7, r1, #1
   270ae:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   270b0:	428c      	cmp	r4, r1
   270b2:	f105 0501 	add.w	r5, r5, #1
   270b6:	db00      	blt.n	270ba <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   270b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   270ba:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   270bc:	f023 0603 	bic.w	r6, r3, #3
   270c0:	f003 0303 	and.w	r3, r3, #3
   270c4:	5996      	ldr	r6, [r2, r6]
   270c6:	00db      	lsls	r3, r3, #3
   270c8:	fa26 f303 	lsr.w	r3, r6, r3
   270cc:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
   270ce:	e7ee      	b.n	270ae <uECC_vli_nativeToBytes+0x6>

000270d0 <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   270d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   270d2:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   270d4:	1cd1      	adds	r1, r2, #3
   270d6:	bf48      	it	mi
   270d8:	1d91      	addmi	r1, r2, #6
   270da:	f341 0187 	sbfx	r1, r1, #2, #8
{
   270de:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   270e0:	f7ff fae4 	bl	266ac <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   270e4:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   270e6:	1e67      	subs	r7, r4, #1
   270e8:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
   270ea:	42a2      	cmp	r2, r4
   270ec:	f105 0501 	add.w	r5, r5, #1
   270f0:	db00      	blt.n	270f4 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   270f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   270f4:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   270f6:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   270fa:	5cb2      	ldrb	r2, [r6, r2]
   270fc:	f003 0303 	and.w	r3, r3, #3
   27100:	00db      	lsls	r3, r3, #3
   27102:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
   27106:	5842      	ldr	r2, [r0, r1]
   27108:	431a      	orrs	r2, r3
   2710a:	5042      	str	r2, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
   2710c:	e7ec      	b.n	270e8 <uECC_vli_bytesToNative+0x18>

0002710e <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
   2710e:	b5f0      	push	{r4, r5, r6, r7, lr}
   27110:	b091      	sub	sp, #68	; 0x44
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   27112:	f991 6000 	ldrsb.w	r6, [r1]
{
   27116:	4605      	mov	r5, r0
   27118:	460c      	mov	r4, r1

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
   2711a:	f7ff fe19 	bl	26d50 <EccPoint_isZero>
   2711e:	bb28      	cbnz	r0, 2716c <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   27120:	1d27      	adds	r7, r4, #4
   27122:	4632      	mov	r2, r6
   27124:	4629      	mov	r1, r5
   27126:	4638      	mov	r0, r7
   27128:	f7ff fb0f 	bl	2674a <uECC_vli_cmp_unsafe>
   2712c:	2801      	cmp	r0, #1
   2712e:	d120      	bne.n	27172 <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
   27130:	4632      	mov	r2, r6
   27132:	eb05 0186 	add.w	r1, r5, r6, lsl #2
   27136:	4638      	mov	r0, r7
   27138:	f7ff fb07 	bl	2674a <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
   2713c:	2801      	cmp	r0, #1
   2713e:	d118      	bne.n	27172 <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
   27140:	4622      	mov	r2, r4
   27142:	4668      	mov	r0, sp
   27144:	f7ff fc16 	bl	26974 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
   27148:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
   2714c:	4622      	mov	r2, r4
   2714e:	4629      	mov	r1, r5
   27150:	a808      	add	r0, sp, #32
   27152:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
   27154:	4632      	mov	r2, r6
   27156:	a908      	add	r1, sp, #32
   27158:	4668      	mov	r0, sp
   2715a:	f7ff fb0b 	bl	26774 <uECC_vli_equal>
		return -3;
   2715e:	2800      	cmp	r0, #0
   27160:	bf0c      	ite	eq
   27162:	2000      	moveq	r0, #0
   27164:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
   27168:	b011      	add	sp, #68	; 0x44
   2716a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
   2716c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27170:	e7fa      	b.n	27168 <uECC_valid_point+0x5a>
		return -2;
   27172:	f06f 0001 	mvn.w	r0, #1
   27176:	e7f7      	b.n	27168 <uECC_valid_point+0x5a>

00027178 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
   27178:	b570      	push	{r4, r5, r6, lr}
   2717a:	460c      	mov	r4, r1
   2717c:	b090      	sub	sp, #64	; 0x40

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
   2717e:	4626      	mov	r6, r4
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   27180:	f991 2001 	ldrsb.w	r2, [r1, #1]
{
   27184:	4605      	mov	r5, r0
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
   27186:	4601      	mov	r1, r0
   27188:	4668      	mov	r0, sp
   2718a:	f7ff ffa1 	bl	270d0 <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
   2718e:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
   27192:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
   27196:	18a9      	adds	r1, r5, r2
   27198:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
   2719c:	f7ff ff98 	bl	270d0 <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
   271a0:	2210      	movs	r2, #16
   271a2:	4631      	mov	r1, r6
   271a4:	4668      	mov	r0, sp
   271a6:	f7ff fad0 	bl	2674a <uECC_vli_cmp_unsafe>
   271aa:	b128      	cbz	r0, 271b8 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
   271ac:	4621      	mov	r1, r4
   271ae:	4668      	mov	r0, sp
   271b0:	f7ff ffad 	bl	2710e <uECC_valid_point>
}
   271b4:	b010      	add	sp, #64	; 0x40
   271b6:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
   271b8:	f06f 0003 	mvn.w	r0, #3
   271bc:	e7fa      	b.n	271b4 <uECC_valid_public_key+0x3c>

000271be <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   271be:	78cb      	ldrb	r3, [r1, #3]
   271c0:	7802      	ldrb	r2, [r0, #0]
   271c2:	4053      	eors	r3, r2
   271c4:	7003      	strb	r3, [r0, #0]
   271c6:	884b      	ldrh	r3, [r1, #2]
   271c8:	7842      	ldrb	r2, [r0, #1]
   271ca:	4053      	eors	r3, r2
   271cc:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   271ce:	680a      	ldr	r2, [r1, #0]
   271d0:	7883      	ldrb	r3, [r0, #2]
   271d2:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   271d6:	7083      	strb	r3, [r0, #2]
   271d8:	680a      	ldr	r2, [r1, #0]
   271da:	78c3      	ldrb	r3, [r0, #3]
   271dc:	4053      	eors	r3, r2
   271de:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   271e0:	79cb      	ldrb	r3, [r1, #7]
   271e2:	7902      	ldrb	r2, [r0, #4]
   271e4:	4053      	eors	r3, r2
   271e6:	7103      	strb	r3, [r0, #4]
   271e8:	88cb      	ldrh	r3, [r1, #6]
   271ea:	7942      	ldrb	r2, [r0, #5]
   271ec:	4053      	eors	r3, r2
   271ee:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   271f0:	684a      	ldr	r2, [r1, #4]
   271f2:	7983      	ldrb	r3, [r0, #6]
   271f4:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   271f8:	7183      	strb	r3, [r0, #6]
   271fa:	684a      	ldr	r2, [r1, #4]
   271fc:	79c3      	ldrb	r3, [r0, #7]
   271fe:	4053      	eors	r3, r2
   27200:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   27202:	7acb      	ldrb	r3, [r1, #11]
   27204:	7a02      	ldrb	r2, [r0, #8]
   27206:	4053      	eors	r3, r2
   27208:	7203      	strb	r3, [r0, #8]
   2720a:	7a42      	ldrb	r2, [r0, #9]
   2720c:	894b      	ldrh	r3, [r1, #10]
   2720e:	4053      	eors	r3, r2
   27210:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   27212:	688a      	ldr	r2, [r1, #8]
   27214:	7a83      	ldrb	r3, [r0, #10]
   27216:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   2721a:	7283      	strb	r3, [r0, #10]
   2721c:	688a      	ldr	r2, [r1, #8]
   2721e:	7ac3      	ldrb	r3, [r0, #11]
   27220:	4053      	eors	r3, r2
   27222:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   27224:	7bcb      	ldrb	r3, [r1, #15]
   27226:	7b02      	ldrb	r2, [r0, #12]
   27228:	4053      	eors	r3, r2
   2722a:	7303      	strb	r3, [r0, #12]
   2722c:	89cb      	ldrh	r3, [r1, #14]
   2722e:	7b42      	ldrb	r2, [r0, #13]
   27230:	4053      	eors	r3, r2
   27232:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   27234:	68ca      	ldr	r2, [r1, #12]
   27236:	7b83      	ldrb	r3, [r0, #14]
   27238:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   2723c:	7383      	strb	r3, [r0, #14]
   2723e:	68ca      	ldr	r2, [r1, #12]
   27240:	7bc3      	ldrb	r3, [r0, #15]
   27242:	4053      	eors	r3, r2
   27244:	73c3      	strb	r3, [r0, #15]
}
   27246:	4770      	bx	lr

00027248 <shift_rows>:
/*
 * This shift_rows also implements the matrix flip required for mix_columns, but
 * performs it here to reduce the number of memory operations.
 */
static inline void shift_rows(uint8_t *s)
{
   27248:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint8_t t[Nb * Nk];

	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   2724a:	7802      	ldrb	r2, [r0, #0]
   2724c:	f88d 2000 	strb.w	r2, [sp]
   27250:	7942      	ldrb	r2, [r0, #5]
   27252:	f88d 2001 	strb.w	r2, [sp, #1]
   27256:	7a82      	ldrb	r2, [r0, #10]
   27258:	f88d 2002 	strb.w	r2, [sp, #2]
   2725c:	7bc2      	ldrb	r2, [r0, #15]
   2725e:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   27262:	7902      	ldrb	r2, [r0, #4]
   27264:	f88d 2004 	strb.w	r2, [sp, #4]
   27268:	7a42      	ldrb	r2, [r0, #9]
   2726a:	f88d 2005 	strb.w	r2, [sp, #5]
   2726e:	7b82      	ldrb	r2, [r0, #14]
   27270:	f88d 2006 	strb.w	r2, [sp, #6]
   27274:	78c2      	ldrb	r2, [r0, #3]
   27276:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   2727a:	7a02      	ldrb	r2, [r0, #8]
   2727c:	f88d 2008 	strb.w	r2, [sp, #8]
   27280:	7b42      	ldrb	r2, [r0, #13]
   27282:	f88d 2009 	strb.w	r2, [sp, #9]
   27286:	7882      	ldrb	r2, [r0, #2]
   27288:	f88d 200a 	strb.w	r2, [sp, #10]
   2728c:	79c2      	ldrb	r2, [r0, #7]
   2728e:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   27292:	7b02      	ldrb	r2, [r0, #12]
   27294:	f88d 200c 	strb.w	r2, [sp, #12]
   27298:	7842      	ldrb	r2, [r0, #1]
   2729a:	7ac3      	ldrb	r3, [r0, #11]
   2729c:	f88d 200d 	strb.w	r2, [sp, #13]
   272a0:	7982      	ldrb	r2, [r0, #6]
   272a2:	f88d 200e 	strb.w	r2, [sp, #14]
   272a6:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   272aa:	2310      	movs	r3, #16
   272ac:	466a      	mov	r2, sp
   272ae:	4619      	mov	r1, r3
   272b0:	f7ff f891 	bl	263d6 <_copy>
}
   272b4:	b005      	add	sp, #20
   272b6:	f85d fb04 	ldr.w	pc, [sp], #4

000272ba <mult_row_column>:
{
   272ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   272bc:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   272be:	7808      	ldrb	r0, [r1, #0]
{
   272c0:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   272c2:	f7ff f897 	bl	263f4 <_double_byte>
   272c6:	4605      	mov	r5, r0
   272c8:	7860      	ldrb	r0, [r4, #1]
   272ca:	f7ff f893 	bl	263f4 <_double_byte>
   272ce:	78a2      	ldrb	r2, [r4, #2]
   272d0:	7863      	ldrb	r3, [r4, #1]
   272d2:	4053      	eors	r3, r2
   272d4:	78e2      	ldrb	r2, [r4, #3]
   272d6:	4053      	eors	r3, r2
   272d8:	405d      	eors	r5, r3
   272da:	4045      	eors	r5, r0
   272dc:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   272de:	7860      	ldrb	r0, [r4, #1]
   272e0:	7827      	ldrb	r7, [r4, #0]
   272e2:	f7ff f887 	bl	263f4 <_double_byte>
   272e6:	4605      	mov	r5, r0
   272e8:	78a0      	ldrb	r0, [r4, #2]
   272ea:	f7ff f883 	bl	263f4 <_double_byte>
   272ee:	78a3      	ldrb	r3, [r4, #2]
   272f0:	405f      	eors	r7, r3
   272f2:	78e3      	ldrb	r3, [r4, #3]
   272f4:	405f      	eors	r7, r3
   272f6:	407d      	eors	r5, r7
   272f8:	4045      	eors	r5, r0
   272fa:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   272fc:	78a0      	ldrb	r0, [r4, #2]
   272fe:	7865      	ldrb	r5, [r4, #1]
   27300:	7827      	ldrb	r7, [r4, #0]
   27302:	f7ff f877 	bl	263f4 <_double_byte>
   27306:	406f      	eors	r7, r5
   27308:	4605      	mov	r5, r0
   2730a:	78e0      	ldrb	r0, [r4, #3]
   2730c:	f7ff f872 	bl	263f4 <_double_byte>
   27310:	78e3      	ldrb	r3, [r4, #3]
   27312:	405f      	eors	r7, r3
   27314:	407d      	eors	r5, r7
   27316:	4045      	eors	r5, r0
   27318:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   2731a:	7820      	ldrb	r0, [r4, #0]
   2731c:	f7ff f86a 	bl	263f4 <_double_byte>
   27320:	7863      	ldrb	r3, [r4, #1]
   27322:	7825      	ldrb	r5, [r4, #0]
   27324:	405d      	eors	r5, r3
   27326:	78a3      	ldrb	r3, [r4, #2]
   27328:	405d      	eors	r5, r3
   2732a:	4045      	eors	r5, r0
   2732c:	78e0      	ldrb	r0, [r4, #3]
   2732e:	f7ff f861 	bl	263f4 <_double_byte>
   27332:	b2ed      	uxtb	r5, r5
   27334:	4045      	eors	r5, r0
   27336:	70f5      	strb	r5, [r6, #3]
}
   27338:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002733a <tc_aes_encrypt>:

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
   2733a:	b570      	push	{r4, r5, r6, lr}
   2733c:	4614      	mov	r4, r2
   2733e:	b088      	sub	sp, #32
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
   27340:	4605      	mov	r5, r0
   27342:	2800      	cmp	r0, #0
   27344:	d049      	beq.n	273da <tc_aes_encrypt+0xa0>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
   27346:	2900      	cmp	r1, #0
   27348:	d049      	beq.n	273de <tc_aes_encrypt+0xa4>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
   2734a:	2a00      	cmp	r2, #0
   2734c:	d049      	beq.n	273e2 <tc_aes_encrypt+0xa8>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
   2734e:	2310      	movs	r3, #16
   27350:	460a      	mov	r2, r1
   27352:	4668      	mov	r0, sp
   27354:	4619      	mov	r1, r3
   27356:	f7ff f83e 	bl	263d6 <_copy>
	add_round_key(state, s->words);
   2735a:	4621      	mov	r1, r4
   2735c:	4668      	mov	r0, sp
   2735e:	f7ff ff2e 	bl	271be <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
   27362:	3410      	adds	r4, #16
   27364:	f101 06a0 	add.w	r6, r1, #160	; 0xa0
		sub_bytes(state);
   27368:	4668      	mov	r0, sp
   2736a:	f7dd f893 	bl	4494 <sub_bytes>
		shift_rows(state);
   2736e:	4668      	mov	r0, sp
   27370:	f7ff ff6a 	bl	27248 <shift_rows>
	mult_row_column(t, s);
   27374:	4669      	mov	r1, sp
   27376:	a804      	add	r0, sp, #16
   27378:	f7ff ff9f 	bl	272ba <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
   2737c:	a901      	add	r1, sp, #4
   2737e:	a805      	add	r0, sp, #20
   27380:	f7ff ff9b 	bl	272ba <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
   27384:	a902      	add	r1, sp, #8
   27386:	a806      	add	r0, sp, #24
   27388:	f7ff ff97 	bl	272ba <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
   2738c:	a903      	add	r1, sp, #12
   2738e:	a807      	add	r0, sp, #28
   27390:	f7ff ff93 	bl	272ba <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
   27394:	2310      	movs	r3, #16
   27396:	4619      	mov	r1, r3
   27398:	eb0d 0203 	add.w	r2, sp, r3
   2739c:	4668      	mov	r0, sp
   2739e:	f7ff f81a 	bl	263d6 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
   273a2:	4621      	mov	r1, r4
   273a4:	4668      	mov	r0, sp
	for (i = 0; i < (Nr - 1); ++i) {
   273a6:	3410      	adds	r4, #16
		add_round_key(state, s->words + Nb*(i+1));
   273a8:	f7ff ff09 	bl	271be <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
   273ac:	42a6      	cmp	r6, r4
   273ae:	d1db      	bne.n	27368 <tc_aes_encrypt+0x2e>
	}

	sub_bytes(state);
   273b0:	f7dd f870 	bl	4494 <sub_bytes>
	shift_rows(state);
   273b4:	4668      	mov	r0, sp
   273b6:	f7ff ff47 	bl	27248 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
   273ba:	4631      	mov	r1, r6
   273bc:	4668      	mov	r0, sp
   273be:	f7ff fefe 	bl	271be <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
   273c2:	2310      	movs	r3, #16
   273c4:	4619      	mov	r1, r3
   273c6:	466a      	mov	r2, sp
   273c8:	4628      	mov	r0, r5
   273ca:	f7ff f804 	bl	263d6 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
   273ce:	4668      	mov	r0, sp
   273d0:	2210      	movs	r2, #16
   273d2:	2100      	movs	r1, #0
   273d4:	f7ff f80c 	bl	263f0 <_set>

	return TC_CRYPTO_SUCCESS;
   273d8:	2001      	movs	r0, #1
}
   273da:	b008      	add	sp, #32
   273dc:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   273de:	4608      	mov	r0, r1
   273e0:	e7fb      	b.n	273da <tc_aes_encrypt+0xa0>
   273e2:	4610      	mov	r0, r2
   273e4:	e7f9      	b.n	273da <tc_aes_encrypt+0xa0>

000273e6 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   273e6:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   273e8:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   273ea:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   273ec:	f912 3b10 	ldrsb.w	r3, [r2], #16
   273f0:	2b00      	cmp	r3, #0
   273f2:	bfb4      	ite	lt
   273f4:	2387      	movlt	r3, #135	; 0x87
   273f6:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   273f8:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   273fc:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   27400:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   27402:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   27406:	d002      	beq.n	2740e <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   27408:	7813      	ldrb	r3, [r2, #0]
   2740a:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   2740c:	e7f4      	b.n	273f8 <gf_double+0x12>
	}
}
   2740e:	bd10      	pop	{r4, pc}

00027410 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   27410:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   27412:	b120      	cbz	r0, 2741e <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   27414:	2258      	movs	r2, #88	; 0x58
   27416:	2100      	movs	r1, #0
   27418:	f7fe ffea 	bl	263f0 <_set>
   2741c:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   2741e:	bd08      	pop	{r3, pc}

00027420 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   27420:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   27422:	4604      	mov	r4, r0
   27424:	b188      	cbz	r0, 2744a <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   27426:	2210      	movs	r2, #16
   27428:	2100      	movs	r1, #0
   2742a:	f7fe ffe1 	bl	263f0 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   2742e:	2210      	movs	r2, #16
   27430:	f104 0030 	add.w	r0, r4, #48	; 0x30
   27434:	2100      	movs	r1, #0
   27436:	f7fe ffdb 	bl	263f0 <_set>
	s->leftover_offset = 0;
   2743a:	2300      	movs	r3, #0
   2743c:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   2743e:	2200      	movs	r2, #0
   27440:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   27444:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   27448:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   2744a:	bd10      	pop	{r4, pc}

0002744c <tc_cmac_setup>:
{
   2744c:	b570      	push	{r4, r5, r6, lr}
   2744e:	460d      	mov	r5, r1
   27450:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   27452:	4604      	mov	r4, r0
   27454:	b310      	cbz	r0, 2749c <tc_cmac_setup+0x50>
   27456:	b311      	cbz	r1, 2749e <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   27458:	2258      	movs	r2, #88	; 0x58
   2745a:	2100      	movs	r1, #0
   2745c:	f7fe ffc8 	bl	263f0 <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   27460:	4629      	mov	r1, r5
	s->sched = sched;
   27462:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   27464:	4630      	mov	r0, r6
   27466:	f7dd f821 	bl	44ac <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   2746a:	2210      	movs	r2, #16
   2746c:	2100      	movs	r1, #0
   2746e:	4620      	mov	r0, r4
   27470:	f7fe ffbe 	bl	263f0 <_set>
	gf_double (s->K1, s->iv);
   27474:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   27478:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2747a:	4621      	mov	r1, r4
   2747c:	4620      	mov	r0, r4
   2747e:	f7ff ff5c 	bl	2733a <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   27482:	4621      	mov	r1, r4
   27484:	4628      	mov	r0, r5
   27486:	f7ff ffae 	bl	273e6 <gf_double>
	gf_double (s->K2, s->K1);
   2748a:	4629      	mov	r1, r5
   2748c:	f104 0020 	add.w	r0, r4, #32
   27490:	f7ff ffa9 	bl	273e6 <gf_double>
	tc_cmac_init(s);
   27494:	4620      	mov	r0, r4
   27496:	f7ff ffc3 	bl	27420 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   2749a:	2001      	movs	r0, #1
}
   2749c:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   2749e:	4608      	mov	r0, r1
   274a0:	e7fc      	b.n	2749c <tc_cmac_setup+0x50>

000274a2 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   274a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   274a6:	460d      	mov	r5, r1
   274a8:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   274aa:	4604      	mov	r4, r0
   274ac:	2800      	cmp	r0, #0
   274ae:	d061      	beq.n	27574 <tc_cmac_update+0xd2>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   274b0:	b912      	cbnz	r2, 274b8 <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   274b2:	2001      	movs	r0, #1
}
   274b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   274b8:	2900      	cmp	r1, #0
   274ba:	d05b      	beq.n	27574 <tc_cmac_update+0xd2>
	if (s->countdown == 0) {
   274bc:	e9d0 3214 	ldrd	r3, r2, [r0, #80]	; 0x50
   274c0:	ea53 0102 	orrs.w	r1, r3, r2
   274c4:	d056      	beq.n	27574 <tc_cmac_update+0xd2>
	s->countdown--;
   274c6:	3b01      	subs	r3, #1
	if (s->leftover_offset > 0) {
   274c8:	f8d0 8044 	ldr.w	r8, [r0, #68]	; 0x44
	s->countdown--;
   274cc:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   274d0:	e9c0 3214 	strd	r3, r2, [r0, #80]	; 0x50
	if (s->leftover_offset > 0) {
   274d4:	f1b8 0f00 	cmp.w	r8, #0
   274d8:	d02a      	beq.n	27530 <tc_cmac_update+0x8e>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   274da:	f1c8 0710 	rsb	r7, r8, #16
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   274de:	f108 0030 	add.w	r0, r8, #48	; 0x30
		if (data_length < remaining_space) {
   274e2:	42be      	cmp	r6, r7
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   274e4:	4420      	add	r0, r4
		if (data_length < remaining_space) {
   274e6:	d208      	bcs.n	274fa <tc_cmac_update+0x58>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   274e8:	462a      	mov	r2, r5
   274ea:	4633      	mov	r3, r6
   274ec:	4631      	mov	r1, r6
   274ee:	f7fe ff72 	bl	263d6 <_copy>
			s->leftover_offset += data_length;
   274f2:	6c62      	ldr	r2, [r4, #68]	; 0x44
   274f4:	4432      	add	r2, r6
   274f6:	6462      	str	r2, [r4, #68]	; 0x44
			return TC_CRYPTO_SUCCESS;
   274f8:	e7db      	b.n	274b2 <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   274fa:	463b      	mov	r3, r7
   274fc:	462a      	mov	r2, r5
   274fe:	4639      	mov	r1, r7
   27500:	f7fe ff69 	bl	263d6 <_copy>
		data_length -= remaining_space;
   27504:	3e10      	subs	r6, #16
		s->leftover_offset = 0;
   27506:	2300      	movs	r3, #0
   27508:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   2750a:	4446      	add	r6, r8
		data += remaining_space;
   2750c:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2750e:	1e63      	subs	r3, r4, #1
   27510:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   27514:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   27518:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2751c:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   2751e:	ea82 0200 	eor.w	r2, r2, r0
   27522:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   27524:	d1f6      	bne.n	27514 <tc_cmac_update+0x72>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   27526:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   27528:	4621      	mov	r1, r4
   2752a:	4620      	mov	r0, r4
   2752c:	f7ff ff05 	bl	2733a <tc_aes_encrypt>
   27530:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   27534:	2e10      	cmp	r6, #16
   27536:	d80a      	bhi.n	2754e <tc_cmac_update+0xac>
	if (data_length > 0) {
   27538:	2e00      	cmp	r6, #0
   2753a:	d0ba      	beq.n	274b2 <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   2753c:	4633      	mov	r3, r6
   2753e:	462a      	mov	r2, r5
   27540:	4631      	mov	r1, r6
   27542:	f104 0030 	add.w	r0, r4, #48	; 0x30
   27546:	f7fe ff46 	bl	263d6 <_copy>
		s->leftover_offset = data_length;
   2754a:	6466      	str	r6, [r4, #68]	; 0x44
   2754c:	e7b1      	b.n	274b2 <tc_cmac_update+0x10>
   2754e:	1e63      	subs	r3, r4, #1
   27550:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   27552:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   27556:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2755a:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   2755c:	ea82 0200 	eor.w	r2, r2, r0
   27560:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   27562:	d1f6      	bne.n	27552 <tc_cmac_update+0xb0>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   27564:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   27566:	4621      	mov	r1, r4
   27568:	4620      	mov	r0, r4
   2756a:	f7ff fee6 	bl	2733a <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   2756e:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   27570:	3e10      	subs	r6, #16
   27572:	e7df      	b.n	27534 <tc_cmac_update+0x92>
		return TC_CRYPTO_FAIL;
   27574:	2000      	movs	r0, #0
   27576:	e79d      	b.n	274b4 <tc_cmac_update+0x12>

00027578 <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   27578:	b570      	push	{r4, r5, r6, lr}
   2757a:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   2757c:	4605      	mov	r5, r0
   2757e:	b1e8      	cbz	r0, 275bc <tc_cmac_final+0x44>
   27580:	b369      	cbz	r1, 275de <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   27582:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   27584:	2a10      	cmp	r2, #16
   27586:	d11a      	bne.n	275be <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   27588:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2758a:	1e63      	subs	r3, r4, #1
   2758c:	3901      	subs	r1, #1
   2758e:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   27592:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   27596:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   2759a:	4072      	eors	r2, r6
   2759c:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   275a0:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   275a2:	ea82 0206 	eor.w	r2, r2, r6
   275a6:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   275a8:	d1f3      	bne.n	27592 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   275aa:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   275ac:	4621      	mov	r1, r4
   275ae:	4628      	mov	r0, r5
   275b0:	f7ff fec3 	bl	2733a <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   275b4:	4620      	mov	r0, r4
   275b6:	f7ff ff2b 	bl	27410 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   275ba:	2001      	movs	r0, #1
}
   275bc:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   275be:	f102 0030 	add.w	r0, r2, #48	; 0x30
   275c2:	2100      	movs	r1, #0
   275c4:	f1c2 0210 	rsb	r2, r2, #16
   275c8:	4420      	add	r0, r4
   275ca:	f7fe ff11 	bl	263f0 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   275ce:	6c63      	ldr	r3, [r4, #68]	; 0x44
   275d0:	4423      	add	r3, r4
   275d2:	2280      	movs	r2, #128	; 0x80
   275d4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   275d8:	f104 0120 	add.w	r1, r4, #32
   275dc:	e7d5      	b.n	2758a <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   275de:	4608      	mov	r0, r1
   275e0:	e7ec      	b.n	275bc <tc_cmac_final+0x44>

000275e2 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   275e2:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   275e4:	6800      	ldr	r0, [r0, #0]
   275e6:	f7dc bfd1 	b.w	458c <z_arm_fatal_error>

000275ea <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   275ea:	2100      	movs	r1, #0
   275ec:	2001      	movs	r0, #1
   275ee:	f7dc bfcd 	b.w	458c <z_arm_fatal_error>

000275f2 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   275f2:	b508      	push	{r3, lr}
	handler();
   275f4:	f7dd f888 	bl	4708 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   275f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   275fc:	f7dd b968 	b.w	48d0 <z_arm_exc_exit>

00027600 <z_log_msg2_static_create.constprop.0>:
   27600:	2300      	movs	r3, #0
   27602:	f7fe bb69 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00027606 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
   27606:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2760a:	4684      	mov	ip, r0
   2760c:	4688      	mov	r8, r1
	register const char *s = nptr;
   2760e:	4604      	mov	r4, r0
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
   27610:	4621      	mov	r1, r4
   27612:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   27616:	2b20      	cmp	r3, #32
   27618:	d0fa      	beq.n	27610 <strtol+0xa>
   2761a:	f1a3 0009 	sub.w	r0, r3, #9
   2761e:	2804      	cmp	r0, #4
   27620:	d9f6      	bls.n	27610 <strtol+0xa>
	} while (isspace(c));
	if (c == '-') {
   27622:	2b2d      	cmp	r3, #45	; 0x2d
   27624:	d12d      	bne.n	27682 <strtol+0x7c>
		neg = 1;
		c = *s++;
   27626:	784b      	ldrb	r3, [r1, #1]
   27628:	1c8c      	adds	r4, r1, #2
		neg = 1;
   2762a:	2101      	movs	r1, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   2762c:	2a00      	cmp	r2, #0
   2762e:	d05a      	beq.n	276e6 <strtol+0xe0>
   27630:	2a10      	cmp	r2, #16
   27632:	d109      	bne.n	27648 <strtol+0x42>
   27634:	2b30      	cmp	r3, #48	; 0x30
   27636:	d107      	bne.n	27648 <strtol+0x42>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   27638:	7823      	ldrb	r3, [r4, #0]
   2763a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   2763e:	2b58      	cmp	r3, #88	; 0x58
   27640:	d14c      	bne.n	276dc <strtol+0xd6>
		c = s[1];
   27642:	7863      	ldrb	r3, [r4, #1]
		s += 2;
		base = 16;
   27644:	2210      	movs	r2, #16
		s += 2;
   27646:	3402      	adds	r4, #2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
   27648:	f101 4700 	add.w	r7, r1, #2147483648	; 0x80000000
   2764c:	3f01      	subs	r7, #1
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   2764e:	2600      	movs	r6, #0
	cutlim = cutoff % (unsigned long)base;
   27650:	fbb7 fef2 	udiv	lr, r7, r2
	for (acc = 0, any = 0;; c = *s++) {
   27654:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
   27656:	fb02 791e 	mls	r9, r2, lr, r7
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   2765a:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   2765e:	2d09      	cmp	r5, #9
   27660:	d815      	bhi.n	2768e <strtol+0x88>
			c -= '0';
   27662:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   27664:	429a      	cmp	r2, r3
   27666:	dd22      	ble.n	276ae <strtol+0xa8>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   27668:	1c75      	adds	r5, r6, #1
   2766a:	d007      	beq.n	2767c <strtol+0x76>
   2766c:	4570      	cmp	r0, lr
   2766e:	d81b      	bhi.n	276a8 <strtol+0xa2>
   27670:	d101      	bne.n	27676 <strtol+0x70>
   27672:	454b      	cmp	r3, r9
   27674:	dc18      	bgt.n	276a8 <strtol+0xa2>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   27676:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   2767a:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
   2767c:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   27680:	e7eb      	b.n	2765a <strtol+0x54>
	} else if (c == '+') {
   27682:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   27684:	bf04      	itt	eq
   27686:	784b      	ldrbeq	r3, [r1, #1]
   27688:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
   2768a:	2100      	movs	r1, #0
   2768c:	e7ce      	b.n	2762c <strtol+0x26>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   2768e:	f043 0520 	orr.w	r5, r3, #32
   27692:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   27694:	2d19      	cmp	r5, #25
   27696:	d80a      	bhi.n	276ae <strtol+0xa8>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   27698:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   2769c:	2d1a      	cmp	r5, #26
   2769e:	bf34      	ite	cc
   276a0:	2537      	movcc	r5, #55	; 0x37
   276a2:	2557      	movcs	r5, #87	; 0x57
   276a4:	1b5b      	subs	r3, r3, r5
   276a6:	e7dd      	b.n	27664 <strtol+0x5e>
			any = -1;
   276a8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   276ac:	e7e6      	b.n	2767c <strtol+0x76>
		}
	}

	if (any < 0) {
   276ae:	1c73      	adds	r3, r6, #1
   276b0:	d109      	bne.n	276c6 <strtol+0xc0>
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   276b2:	f7fc f8e1 	bl	23878 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
   276b6:	2322      	movs	r3, #34	; 0x22
   276b8:	6003      	str	r3, [r0, #0]
		acc = neg ? LONG_MIN : LONG_MAX;
   276ba:	4638      	mov	r0, r7
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
   276bc:	f1b8 0f00 	cmp.w	r8, #0
   276c0:	d107      	bne.n	276d2 <strtol+0xcc>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   276c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (neg) {
   276c6:	b101      	cbz	r1, 276ca <strtol+0xc4>
		acc = -acc;
   276c8:	4240      	negs	r0, r0
	if (endptr != NULL) {
   276ca:	f1b8 0f00 	cmp.w	r8, #0
   276ce:	d0f8      	beq.n	276c2 <strtol+0xbc>
		*endptr = (char *)(any ? s - 1 : nptr);
   276d0:	b10e      	cbz	r6, 276d6 <strtol+0xd0>
   276d2:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   276d6:	f8c8 c000 	str.w	ip, [r8]
	return acc;
   276da:	e7f2      	b.n	276c2 <strtol+0xbc>
	if (base == 0) {
   276dc:	2330      	movs	r3, #48	; 0x30
   276de:	2a00      	cmp	r2, #0
   276e0:	d1b2      	bne.n	27648 <strtol+0x42>
		base = c == '0' ? 8 : 10;
   276e2:	2208      	movs	r2, #8
   276e4:	e7b0      	b.n	27648 <strtol+0x42>
	if ((base == 0 || base == 16) &&
   276e6:	2b30      	cmp	r3, #48	; 0x30
   276e8:	d0a6      	beq.n	27638 <strtol+0x32>
		base = c == '0' ? 8 : 10;
   276ea:	220a      	movs	r2, #10
   276ec:	e7ac      	b.n	27648 <strtol+0x42>

000276ee <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
   276ee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   276f2:	4607      	mov	r7, r0
   276f4:	4688      	mov	r8, r1
	register const char *s = nptr;
   276f6:	4604      	mov	r4, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
   276f8:	4621      	mov	r1, r4
   276fa:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   276fe:	2b20      	cmp	r3, #32
   27700:	d0fa      	beq.n	276f8 <strtoul+0xa>
   27702:	f1a3 0009 	sub.w	r0, r3, #9
   27706:	2804      	cmp	r0, #4
   27708:	d9f6      	bls.n	276f8 <strtoul+0xa>
	} while (isspace(c));
	if (c == '-') {
   2770a:	2b2d      	cmp	r3, #45	; 0x2d
   2770c:	d12f      	bne.n	2776e <strtoul+0x80>
		neg = 1;
		c = *s++;
   2770e:	784b      	ldrb	r3, [r1, #1]
   27710:	1c8c      	adds	r4, r1, #2
		neg = 1;
   27712:	f04f 0c01 	mov.w	ip, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   27716:	2a00      	cmp	r2, #0
   27718:	d05e      	beq.n	277d8 <strtoul+0xea>
   2771a:	2a10      	cmp	r2, #16
   2771c:	d109      	bne.n	27732 <strtoul+0x44>
   2771e:	2b30      	cmp	r3, #48	; 0x30
   27720:	d107      	bne.n	27732 <strtoul+0x44>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   27722:	7823      	ldrb	r3, [r4, #0]
   27724:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   27728:	2b58      	cmp	r3, #88	; 0x58
   2772a:	d150      	bne.n	277ce <strtoul+0xe0>
		c = s[1];
   2772c:	7863      	ldrb	r3, [r4, #1]
		s += 2;
		base = 16;
   2772e:	2210      	movs	r2, #16
		s += 2;
   27730:	3402      	adds	r4, #2

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   27732:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   27736:	2600      	movs	r6, #0
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   27738:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
   2773c:	fb02 fe01 	mul.w	lr, r2, r1
   27740:	ea6f 0e0e 	mvn.w	lr, lr
	for (acc = 0, any = 0;; c = *s++) {
   27744:	4630      	mov	r0, r6
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   27746:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   2774a:	2d09      	cmp	r5, #9
   2774c:	d816      	bhi.n	2777c <strtoul+0x8e>
			c -= '0';
   2774e:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   27750:	429a      	cmp	r2, r3
   27752:	dd23      	ble.n	2779c <strtoul+0xae>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   27754:	2e00      	cmp	r6, #0
   27756:	db1e      	blt.n	27796 <strtoul+0xa8>
   27758:	4288      	cmp	r0, r1
   2775a:	d81c      	bhi.n	27796 <strtoul+0xa8>
   2775c:	d101      	bne.n	27762 <strtoul+0x74>
   2775e:	4573      	cmp	r3, lr
   27760:	dc19      	bgt.n	27796 <strtoul+0xa8>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   27762:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   27766:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
   27768:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   2776c:	e7eb      	b.n	27746 <strtoul+0x58>
	} else if (c == '+') {
   2776e:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   27770:	bf04      	itt	eq
   27772:	784b      	ldrbeq	r3, [r1, #1]
   27774:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
   27776:	f04f 0c00 	mov.w	ip, #0
   2777a:	e7cc      	b.n	27716 <strtoul+0x28>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   2777c:	f043 0520 	orr.w	r5, r3, #32
   27780:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   27782:	2d19      	cmp	r5, #25
   27784:	d80a      	bhi.n	2779c <strtoul+0xae>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   27786:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   2778a:	2d1a      	cmp	r5, #26
   2778c:	bf34      	ite	cc
   2778e:	2537      	movcc	r5, #55	; 0x37
   27790:	2557      	movcs	r5, #87	; 0x57
   27792:	1b5b      	subs	r3, r3, r5
   27794:	e7dc      	b.n	27750 <strtoul+0x62>
			any = -1;
   27796:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2779a:	e7e5      	b.n	27768 <strtoul+0x7a>
		}
	}
	if (any < 0) {
   2779c:	2e00      	cmp	r6, #0
   2779e:	da0a      	bge.n	277b6 <strtoul+0xc8>
   277a0:	f7fc f86a 	bl	23878 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
   277a4:	2322      	movs	r3, #34	; 0x22
   277a6:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
   277a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
   277ac:	f1b8 0f00 	cmp.w	r8, #0
   277b0:	d109      	bne.n	277c6 <strtoul+0xd8>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   277b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
   277b6:	f1bc 0f00 	cmp.w	ip, #0
   277ba:	d000      	beq.n	277be <strtoul+0xd0>
		acc = -acc;
   277bc:	4240      	negs	r0, r0
	if (endptr != NULL) {
   277be:	f1b8 0f00 	cmp.w	r8, #0
   277c2:	d0f6      	beq.n	277b2 <strtoul+0xc4>
		*endptr = (char *)(any ? s - 1 : nptr);
   277c4:	b106      	cbz	r6, 277c8 <strtoul+0xda>
   277c6:	1e67      	subs	r7, r4, #1
   277c8:	f8c8 7000 	str.w	r7, [r8]
	return acc;
   277cc:	e7f1      	b.n	277b2 <strtoul+0xc4>
	if (base == 0) {
   277ce:	2330      	movs	r3, #48	; 0x30
   277d0:	2a00      	cmp	r2, #0
   277d2:	d1ae      	bne.n	27732 <strtoul+0x44>
		base = c == '0' ? 8 : 10;
   277d4:	2208      	movs	r2, #8
   277d6:	e7ac      	b.n	27732 <strtoul+0x44>
	if ((base == 0 || base == 16) &&
   277d8:	2b30      	cmp	r3, #48	; 0x30
   277da:	d0a2      	beq.n	27722 <strtoul+0x34>
		base = c == '0' ? 8 : 10;
   277dc:	220a      	movs	r2, #10
   277de:	e7a8      	b.n	27732 <strtoul+0x44>

000277e0 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   277e0:	3901      	subs	r1, #1
   277e2:	4603      	mov	r3, r0
   277e4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   277e8:	b90a      	cbnz	r2, 277ee <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   277ea:	701a      	strb	r2, [r3, #0]

	return dest;
}
   277ec:	4770      	bx	lr
		*d = *s;
   277ee:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   277f2:	e7f7      	b.n	277e4 <strcpy+0x4>

000277f4 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   277f4:	4603      	mov	r3, r0
	size_t n = 0;
   277f6:	2000      	movs	r0, #0

	while (*s != '\0') {
   277f8:	5c1a      	ldrb	r2, [r3, r0]
   277fa:	b902      	cbnz	r2, 277fe <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   277fc:	4770      	bx	lr
		n++;
   277fe:	3001      	adds	r0, #1
   27800:	e7fa      	b.n	277f8 <strlen+0x4>

00027802 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   27802:	4603      	mov	r3, r0
	size_t n = 0;
   27804:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   27806:	5c1a      	ldrb	r2, [r3, r0]
   27808:	b10a      	cbz	r2, 2780e <strnlen+0xc>
   2780a:	4288      	cmp	r0, r1
   2780c:	d100      	bne.n	27810 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   2780e:	4770      	bx	lr
		n++;
   27810:	3001      	adds	r0, #1
   27812:	e7f8      	b.n	27806 <strnlen+0x4>

00027814 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   27814:	1e43      	subs	r3, r0, #1
   27816:	3901      	subs	r1, #1
   27818:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   2781c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   27820:	4282      	cmp	r2, r0
   27822:	d101      	bne.n	27828 <strcmp+0x14>
   27824:	2a00      	cmp	r2, #0
   27826:	d1f7      	bne.n	27818 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   27828:	1a10      	subs	r0, r2, r0
   2782a:	4770      	bx	lr

0002782c <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   2782c:	b510      	push	{r4, lr}
   2782e:	3901      	subs	r1, #1
   27830:	4402      	add	r2, r0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   27832:	4282      	cmp	r2, r0
   27834:	d009      	beq.n	2784a <strncmp+0x1e>
   27836:	7803      	ldrb	r3, [r0, #0]
   27838:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   2783c:	42a3      	cmp	r3, r4
   2783e:	d100      	bne.n	27842 <strncmp+0x16>
   27840:	b90b      	cbnz	r3, 27846 <strncmp+0x1a>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   27842:	1b18      	subs	r0, r3, r4
   27844:	e002      	b.n	2784c <strncmp+0x20>
		s1++;
   27846:	3001      	adds	r0, #1
		n--;
   27848:	e7f3      	b.n	27832 <strncmp+0x6>
	return (n == 0) ? 0 : (*s1 - *s2);
   2784a:	2000      	movs	r0, #0
}
   2784c:	bd10      	pop	{r4, pc}

0002784e <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   2784e:	b510      	push	{r4, lr}
   27850:	4603      	mov	r3, r0
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   27852:	b15a      	cbz	r2, 2786c <memcmp+0x1e>
   27854:	3901      	subs	r1, #1
   27856:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   27858:	f813 0b01 	ldrb.w	r0, [r3], #1
   2785c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   27860:	42a3      	cmp	r3, r4
   27862:	d001      	beq.n	27868 <memcmp+0x1a>
   27864:	4290      	cmp	r0, r2
   27866:	d0f7      	beq.n	27858 <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   27868:	1a80      	subs	r0, r0, r2
}
   2786a:	bd10      	pop	{r4, pc}
		return 0;
   2786c:	4610      	mov	r0, r2
   2786e:	e7fc      	b.n	2786a <memcmp+0x1c>

00027870 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   27870:	b510      	push	{r4, lr}
   27872:	1e43      	subs	r3, r0, #1
   27874:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   27876:	4291      	cmp	r1, r2
   27878:	d100      	bne.n	2787c <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   2787a:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   2787c:	f811 4b01 	ldrb.w	r4, [r1], #1
   27880:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   27884:	e7f7      	b.n	27876 <memcpy+0x6>

00027886 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   27886:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   27888:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
   2788a:	4603      	mov	r3, r0
	while (n > 0) {
   2788c:	4293      	cmp	r3, r2
   2788e:	d100      	bne.n	27892 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   27890:	4770      	bx	lr
		*(d_byte++) = c_byte;
   27892:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   27896:	e7f9      	b.n	2788c <memset+0x6>

00027898 <_stdout_hook_default>:
}
   27898:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2789c:	4770      	bx	lr

0002789e <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   2789e:	b084      	sub	sp, #16
   278a0:	ab04      	add	r3, sp, #16
   278a2:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   278a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
   278aa:	2b06      	cmp	r3, #6
   278ac:	d108      	bne.n	278c0 <pm_power_state_set+0x22>
#endif // defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)

#if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
{
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
   278ae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   278b2:	2201      	movs	r2, #1
   278b4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   278b8:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   278bc:	bf20      	wfe
    while (true)
   278be:	e7fd      	b.n	278bc <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   278c0:	b004      	add	sp, #16
   278c2:	4770      	bx	lr

000278c4 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   278c4:	b084      	sub	sp, #16
   278c6:	ab04      	add	r3, sp, #16
   278c8:	e903 0007 	stmdb	r3, {r0, r1, r2}
   278cc:	2300      	movs	r3, #0
   278ce:	f383 8811 	msr	BASEPRI, r3
   278d2:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   278d6:	b004      	add	sp, #16
   278d8:	4770      	bx	lr

000278da <send_cmd_status>:
{
   278da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   278de:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   278e2:	4606      	mov	r6, r0
   278e4:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   278e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   278ea:	2100      	movs	r1, #0
   278ec:	200f      	movs	r0, #15
   278ee:	f7de f855 	bl	599c <bt_buf_get_evt>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   278f2:	2701      	movs	r7, #1
	return net_buf_simple_add(&buf->b, len);
   278f4:	f100 0808 	add.w	r8, r0, #8
   278f8:	4604      	mov	r4, r0
   278fa:	7507      	strb	r7, [r0, #20]
   278fc:	2102      	movs	r1, #2
   278fe:	4640      	mov	r0, r8
   27900:	f004 fa1c 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   27904:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
   27906:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
   27908:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
   2790a:	7041      	strb	r1, [r0, #1]
   2790c:	4640      	mov	r0, r8
   2790e:	f004 fa15 	bl	2bd3c <net_buf_simple_add>
	evt->ncmd = 1U;
   27912:	7047      	strb	r7, [r0, #1]
	evt->status = status;
   27914:	7005      	strb	r5, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
   27916:	8046      	strh	r6, [r0, #2]
		bt_recv_prio(buf);
   27918:	4620      	mov	r0, r4
}
   2791a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_recv_prio(buf);
   2791e:	f7df b80f 	b.w	6940 <bt_recv_prio>

00027922 <sys_memcpy_swap.constprop.0>:
	for (; length > 0; length--) {
   27922:	f101 0320 	add.w	r3, r1, #32
   27926:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
   27928:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   2792c:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
   27930:	428b      	cmp	r3, r1
   27932:	d1f9      	bne.n	27928 <sys_memcpy_swap.constprop.0+0x6>
}
   27934:	4770      	bx	lr

00027936 <bt_hci_ecc_supported_commands>:
	supported_commands[34] |= BIT(2);
   27936:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
   2793a:	f043 0306 	orr.w	r3, r3, #6
   2793e:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
	supported_commands[41] |= BIT(2);
   27942:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
   27946:	f043 0304 	orr.w	r3, r3, #4
   2794a:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
}
   2794e:	4770      	bx	lr

00027950 <default_CSPRNG>:
{
   27950:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
   27952:	f003 fada 	bl	2af0a <bt_rand>
}
   27956:	fab0 f080 	clz	r0, r0
   2795a:	0940      	lsrs	r0, r0, #5
   2795c:	bd08      	pop	{r3, pc}

0002795e <bt_settings_decode_key>:
{
   2795e:	b570      	push	{r4, r5, r6, lr}
   27960:	460d      	mov	r5, r1
	if (settings_name_next(key, NULL) != 13) {
   27962:	2100      	movs	r1, #0
{
   27964:	4604      	mov	r4, r0
	if (settings_name_next(key, NULL) != 13) {
   27966:	f7fe fc6d 	bl	26244 <settings_name_next>
   2796a:	280d      	cmp	r0, #13
   2796c:	d118      	bne.n	279a0 <bt_settings_decode_key+0x42>
	if (key[12] == '0') {
   2796e:	7b23      	ldrb	r3, [r4, #12]
   27970:	2b30      	cmp	r3, #48	; 0x30
   27972:	d111      	bne.n	27998 <bt_settings_decode_key+0x3a>
		addr->type = BT_ADDR_LE_PUBLIC;
   27974:	2300      	movs	r3, #0
   27976:	702b      	strb	r3, [r5, #0]
   27978:	f104 060c 	add.w	r6, r4, #12
   2797c:	3506      	adds	r5, #6
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   2797e:	462a      	mov	r2, r5
   27980:	4620      	mov	r0, r4
   27982:	2301      	movs	r3, #1
   27984:	2102      	movs	r1, #2
	for (uint8_t i = 0; i < 6; i++) {
   27986:	3402      	adds	r4, #2
		hex2bin(&key[i * 2], 2, &addr->a.val[5 - i], 1);
   27988:	f7fd fb9e 	bl	250c8 <hex2bin>
	for (uint8_t i = 0; i < 6; i++) {
   2798c:	42b4      	cmp	r4, r6
   2798e:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   27992:	d1f4      	bne.n	2797e <bt_settings_decode_key+0x20>
	return 0;
   27994:	2000      	movs	r0, #0
}
   27996:	bd70      	pop	{r4, r5, r6, pc}
	} else if (key[12] == '1') {
   27998:	2b31      	cmp	r3, #49	; 0x31
   2799a:	d101      	bne.n	279a0 <bt_settings_decode_key+0x42>
		addr->type = BT_ADDR_LE_RANDOM;
   2799c:	2301      	movs	r3, #1
   2799e:	e7ea      	b.n	27976 <bt_settings_decode_key+0x18>
		return -EINVAL;
   279a0:	f06f 0015 	mvn.w	r0, #21
   279a4:	e7f7      	b.n	27996 <bt_settings_decode_key+0x38>

000279a6 <xor16>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_HCI_CORE)
#define LOG_MODULE_NAME bt_aes_ccm
#include "common/log.h"

static inline void xor16(uint8_t *dst, const uint8_t *a, const uint8_t *b)
{
   279a6:	b510      	push	{r4, lr}
	dst[0] = a[0] ^ b[0];
   279a8:	780b      	ldrb	r3, [r1, #0]
   279aa:	7814      	ldrb	r4, [r2, #0]
   279ac:	4063      	eors	r3, r4
   279ae:	7003      	strb	r3, [r0, #0]
	dst[1] = a[1] ^ b[1];
   279b0:	7854      	ldrb	r4, [r2, #1]
   279b2:	784b      	ldrb	r3, [r1, #1]
   279b4:	4063      	eors	r3, r4
   279b6:	7043      	strb	r3, [r0, #1]
	dst[2] = a[2] ^ b[2];
   279b8:	7894      	ldrb	r4, [r2, #2]
   279ba:	788b      	ldrb	r3, [r1, #2]
   279bc:	4063      	eors	r3, r4
   279be:	7083      	strb	r3, [r0, #2]
	dst[3] = a[3] ^ b[3];
   279c0:	78d4      	ldrb	r4, [r2, #3]
   279c2:	78cb      	ldrb	r3, [r1, #3]
   279c4:	4063      	eors	r3, r4
   279c6:	70c3      	strb	r3, [r0, #3]
	dst[4] = a[4] ^ b[4];
   279c8:	7914      	ldrb	r4, [r2, #4]
   279ca:	790b      	ldrb	r3, [r1, #4]
   279cc:	4063      	eors	r3, r4
   279ce:	7103      	strb	r3, [r0, #4]
	dst[5] = a[5] ^ b[5];
   279d0:	7954      	ldrb	r4, [r2, #5]
   279d2:	794b      	ldrb	r3, [r1, #5]
   279d4:	4063      	eors	r3, r4
   279d6:	7143      	strb	r3, [r0, #5]
	dst[6] = a[6] ^ b[6];
   279d8:	7994      	ldrb	r4, [r2, #6]
   279da:	798b      	ldrb	r3, [r1, #6]
   279dc:	4063      	eors	r3, r4
   279de:	7183      	strb	r3, [r0, #6]
	dst[7] = a[7] ^ b[7];
   279e0:	79d4      	ldrb	r4, [r2, #7]
   279e2:	79cb      	ldrb	r3, [r1, #7]
   279e4:	4063      	eors	r3, r4
   279e6:	71c3      	strb	r3, [r0, #7]
	dst[8] = a[8] ^ b[8];
   279e8:	7a14      	ldrb	r4, [r2, #8]
   279ea:	7a0b      	ldrb	r3, [r1, #8]
   279ec:	4063      	eors	r3, r4
   279ee:	7203      	strb	r3, [r0, #8]
	dst[9] = a[9] ^ b[9];
   279f0:	7a54      	ldrb	r4, [r2, #9]
   279f2:	7a4b      	ldrb	r3, [r1, #9]
   279f4:	4063      	eors	r3, r4
   279f6:	7243      	strb	r3, [r0, #9]
	dst[10] = a[10] ^ b[10];
   279f8:	7a8b      	ldrb	r3, [r1, #10]
   279fa:	7a94      	ldrb	r4, [r2, #10]
   279fc:	4063      	eors	r3, r4
   279fe:	7283      	strb	r3, [r0, #10]
	dst[11] = a[11] ^ b[11];
   27a00:	7ad4      	ldrb	r4, [r2, #11]
   27a02:	7acb      	ldrb	r3, [r1, #11]
   27a04:	4063      	eors	r3, r4
   27a06:	72c3      	strb	r3, [r0, #11]
	dst[12] = a[12] ^ b[12];
   27a08:	7b14      	ldrb	r4, [r2, #12]
   27a0a:	7b0b      	ldrb	r3, [r1, #12]
   27a0c:	4063      	eors	r3, r4
   27a0e:	7303      	strb	r3, [r0, #12]
	dst[13] = a[13] ^ b[13];
   27a10:	7b54      	ldrb	r4, [r2, #13]
   27a12:	7b4b      	ldrb	r3, [r1, #13]
   27a14:	4063      	eors	r3, r4
   27a16:	7343      	strb	r3, [r0, #13]
	dst[14] = a[14] ^ b[14];
   27a18:	7b94      	ldrb	r4, [r2, #14]
   27a1a:	7b8b      	ldrb	r3, [r1, #14]
   27a1c:	4063      	eors	r3, r4
   27a1e:	7383      	strb	r3, [r0, #14]
	dst[15] = a[15] ^ b[15];
   27a20:	7bcb      	ldrb	r3, [r1, #15]
   27a22:	7bd2      	ldrb	r2, [r2, #15]
   27a24:	4053      	eors	r3, r2
   27a26:	73c3      	strb	r3, [r0, #15]
}
   27a28:	bd10      	pop	{r4, pc}

00027a2a <ccm_crypt.isra.0>:
	}

	return 0;
}

static int ccm_crypt(const uint8_t key[16], const uint8_t nonce[13],
   27a2a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27a2e:	b08b      	sub	sp, #44	; 0x2c
   27a30:	4607      	mov	r7, r0
   27a32:	9d14      	ldr	r5, [sp, #80]	; 0x50
   27a34:	4690      	mov	r8, r2
	uint16_t last_blk, blk_cnt;
	size_t i, j;
	int err;

	last_blk = msg_len % 16;
	blk_cnt = (msg_len + 15) / 16;
   27a36:	f105 060f 	add.w	r6, r5, #15
	if (!last_blk) {
		last_blk = 16U;
	}

	a_i[0] = 0x01;
   27a3a:	2401      	movs	r4, #1
		last_blk = 16U;
   27a3c:	f015 050f 	ands.w	r5, r5, #15
	memcpy(&a_i[1], nonce, 13);
   27a40:	f04f 020d 	mov.w	r2, #13
   27a44:	f10d 0009 	add.w	r0, sp, #9
static int ccm_crypt(const uint8_t key[16], const uint8_t nonce[13],
   27a48:	4699      	mov	r9, r3
	blk_cnt = (msg_len + 15) / 16;
   27a4a:	ea4f 1616 	mov.w	r6, r6, lsr #4
		last_blk = 16U;
   27a4e:	bf08      	it	eq
   27a50:	2510      	moveq	r5, #16
	a_i[0] = 0x01;
   27a52:	f88d 4008 	strb.w	r4, [sp, #8]
	memcpy(&a_i[1], nonce, 13);
   27a56:	f7ff ff0b 	bl	27870 <memcpy>

	for (j = 0; j < blk_cnt; j++) {
   27a5a:	b2b6      	uxth	r6, r6
   27a5c:	f04f 0b00 	mov.w	fp, #0
		if (err) {
			return err;
		}

		/* Encrypted = Payload[0-15] ^ C_1 */
		if (j < blk_cnt - 1) {
   27a60:	f106 3aff 	add.w	sl, r6, #4294967295	; 0xffffffff
	for (j = 0; j < blk_cnt; j++) {
   27a64:	1e63      	subs	r3, r4, #1
   27a66:	429e      	cmp	r6, r3
   27a68:	d802      	bhi.n	27a70 <ccm_crypt.isra.0+0x46>
					in_msg[(j * 16) + i] ^ s_i[i];
			}
		}
	}
	return 0;
}
   27a6a:	b00b      	add	sp, #44	; 0x2c
   27a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dst[0] = val >> 8;
   27a70:	f3c4 2207 	ubfx	r2, r4, #8, #8
   27a74:	f88d 2016 	strb.w	r2, [sp, #22]
		err = bt_encrypt_be(key, a_i, s_i);
   27a78:	a902      	add	r1, sp, #8
   27a7a:	aa06      	add	r2, sp, #24
   27a7c:	4638      	mov	r0, r7
   27a7e:	9301      	str	r3, [sp, #4]
	dst[1] = val;
   27a80:	f88d 4017 	strb.w	r4, [sp, #23]
   27a84:	f003 fa43 	bl	2af0e <bt_encrypt_be>
		if (err) {
   27a88:	4601      	mov	r1, r0
   27a8a:	2800      	cmp	r0, #0
   27a8c:	d1ed      	bne.n	27a6a <ccm_crypt.isra.0+0x40>
		if (j < blk_cnt - 1) {
   27a8e:	9b01      	ldr	r3, [sp, #4]
   27a90:	459a      	cmp	sl, r3
   27a92:	eb08 020b 	add.w	r2, r8, fp
   27a96:	eb09 000b 	add.w	r0, r9, fp
   27a9a:	d906      	bls.n	27aaa <ccm_crypt.isra.0+0x80>
			xor16(&out_msg[j * 16], s_i, &in_msg[j * 16]);
   27a9c:	a906      	add	r1, sp, #24
   27a9e:	f7ff ff82 	bl	279a6 <xor16>
	for (j = 0; j < blk_cnt; j++) {
   27aa2:	3401      	adds	r4, #1
   27aa4:	f10b 0b10 	add.w	fp, fp, #16
   27aa8:	e7dc      	b.n	27a64 <ccm_crypt.isra.0+0x3a>
   27aaa:	f10d 0c18 	add.w	ip, sp, #24
					in_msg[(j * 16) + i] ^ s_i[i];
   27aae:	f812 3b01 	ldrb.w	r3, [r2], #1
   27ab2:	f81c eb01 	ldrb.w	lr, [ip], #1
			for (i = 0; i < last_blk; i++) {
   27ab6:	3101      	adds	r1, #1
				out_msg[(j * 16) + i] =
   27ab8:	ea83 030e 	eor.w	r3, r3, lr
			for (i = 0; i < last_blk; i++) {
   27abc:	42a9      	cmp	r1, r5
				out_msg[(j * 16) + i] =
   27abe:	f800 3b01 	strb.w	r3, [r0], #1
			for (i = 0; i < last_blk; i++) {
   27ac2:	d3f4      	bcc.n	27aae <ccm_crypt.isra.0+0x84>
   27ac4:	e7ed      	b.n	27aa2 <ccm_crypt.isra.0+0x78>

00027ac6 <ccm_auth.isra.0>:
static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
   27ac6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		last_blk = 16U;
   27aca:	f013 080f 	ands.w	r8, r3, #15
static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
   27ace:	b08d      	sub	sp, #52	; 0x34
   27ad0:	461d      	mov	r5, r3
	b[0] = 0x01;
   27ad2:	f04f 0301 	mov.w	r3, #1
static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
   27ad6:	4607      	mov	r7, r0
   27ad8:	4616      	mov	r6, r2
	memcpy(b + 1, nonce, 13);
   27ada:	eb0d 0003 	add.w	r0, sp, r3
   27ade:	f04f 020d 	mov.w	r2, #13
   27ae2:	46e9      	mov	r9, sp
		last_blk = 16U;
   27ae4:	bf08      	it	eq
   27ae6:	f04f 0810 	moveq.w	r8, #16
	b[0] = 0x01;
   27aea:	f88d 3000 	strb.w	r3, [sp]
static int ccm_auth(const uint8_t key[16], uint8_t nonce[13],
   27aee:	9c17      	ldr	r4, [sp, #92]	; 0x5c
	memcpy(b + 1, nonce, 13);
   27af0:	f7ff febe 	bl	27870 <memcpy>
	dst[0] = val >> 8;
   27af4:	2300      	movs	r3, #0
	err = bt_encrypt_be(key, b, s0);
   27af6:	aa08      	add	r2, sp, #32
   27af8:	4649      	mov	r1, r9
   27afa:	4638      	mov	r0, r7
   27afc:	f88d 300e 	strb.w	r3, [sp, #14]
	dst[1] = val;
   27b00:	f88d 300f 	strb.w	r3, [sp, #15]
   27b04:	f003 fa03 	bl	2af0e <bt_encrypt_be>
	if (err) {
   27b08:	2800      	cmp	r0, #0
   27b0a:	f040 809e 	bne.w	27c4a <ccm_auth.isra.0+0x184>
	b[0] = (((mic_size - 2) / 2) << 3) | ((!!aad_len) << 6) | 0x01;
   27b0e:	9b19      	ldr	r3, [sp, #100]	; 0x64
	dst[0] = val >> 8;
   27b10:	f88d 000e 	strb.w	r0, [sp, #14]
   27b14:	3b02      	subs	r3, #2
   27b16:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   27b1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
   27b1e:	bf14      	ite	ne
   27b20:	2240      	movne	r2, #64	; 0x40
   27b22:	2200      	moveq	r2, #0
   27b24:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   27b28:	4313      	orrs	r3, r2
	err = bt_encrypt_be(key, b, X0);
   27b2a:	f10d 0b10 	add.w	fp, sp, #16
	b[0] = (((mic_size - 2) / 2) << 3) | ((!!aad_len) << 6) | 0x01;
   27b2e:	f043 0301 	orr.w	r3, r3, #1
	err = bt_encrypt_be(key, b, X0);
   27b32:	465a      	mov	r2, fp
   27b34:	4649      	mov	r1, r9
   27b36:	4638      	mov	r0, r7
	b[0] = (((mic_size - 2) / 2) << 3) | ((!!aad_len) << 6) | 0x01;
   27b38:	f88d 3000 	strb.w	r3, [sp]
	dst[1] = val;
   27b3c:	f88d 500f 	strb.w	r5, [sp, #15]
	err = bt_encrypt_be(key, b, X0);
   27b40:	f003 f9e5 	bl	2af0e <bt_encrypt_be>
	if (err) {
   27b44:	4682      	mov	sl, r0
   27b46:	bbb8      	cbnz	r0, 27bb8 <ccm_auth.isra.0+0xf2>
	if (aad_len) {
   27b48:	b3b4      	cbz	r4, 27bb8 <ccm_auth.isra.0+0xf2>
			b[i] = X0[i] ^ b[i];
   27b4a:	f89d 3010 	ldrb.w	r3, [sp, #16]
   27b4e:	f88d 3000 	strb.w	r3, [sp]
   27b52:	f89d 3011 	ldrb.w	r3, [sp, #17]
   27b56:	4063      	eors	r3, r4
		aad_len += sizeof(uint16_t);
   27b58:	3402      	adds	r4, #2
			b[i] = X0[i] ^ b[i];
   27b5a:	f88d 3001 	strb.w	r3, [sp, #1]
		aad_len += sizeof(uint16_t);
   27b5e:	b2e4      	uxtb	r4, r4
		while (aad_len > 16) {
   27b60:	2302      	movs	r3, #2
				b[i] = X0[i] ^ aad[j];
   27b62:	4649      	mov	r1, r9
		while (aad_len > 16) {
   27b64:	9a16      	ldr	r2, [sp, #88]	; 0x58
   27b66:	2c10      	cmp	r4, #16
   27b68:	4452      	add	r2, sl
   27b6a:	d80b      	bhi.n	27b84 <ccm_auth.isra.0+0xbe>
   27b6c:	4611      	mov	r1, r2
   27b6e:	aa04      	add	r2, sp, #16
		for (; i < aad_len; i++, j++) {
   27b70:	42a3      	cmp	r3, r4
   27b72:	4620      	mov	r0, r4
   27b74:	db38      	blt.n	27be8 <ccm_auth.isra.0+0x122>
		for (i = aad_len; i < 16; i++) {
   27b76:	280f      	cmp	r0, #15
   27b78:	dd40      	ble.n	27bfc <ccm_auth.isra.0+0x136>
		err = bt_encrypt_be(key, b, X0);
   27b7a:	4669      	mov	r1, sp
   27b7c:	4638      	mov	r0, r7
   27b7e:	f003 f9c6 	bl	2af0e <bt_encrypt_be>
		if (err) {
   27b82:	e019      	b.n	27bb8 <ccm_auth.isra.0+0xf2>
		while (aad_len > 16) {
   27b84:	4618      	mov	r0, r3
				b[i] = X0[i] ^ aad[j];
   27b86:	f810 e00b 	ldrb.w	lr, [r0, fp]
   27b8a:	f812 cb01 	ldrb.w	ip, [r2], #1
   27b8e:	ea8c 0c0e 	eor.w	ip, ip, lr
   27b92:	f800 c001 	strb.w	ip, [r0, r1]
				i++, j++;
   27b96:	3001      	adds	r0, #1
			} while (i < 16);
   27b98:	2810      	cmp	r0, #16
   27b9a:	d1f4      	bne.n	27b86 <ccm_auth.isra.0+0xc0>
				i++, j++;
   27b9c:	f10a 0a10 	add.w	sl, sl, #16
			err = bt_encrypt_be(key, b, X0);
   27ba0:	465a      	mov	r2, fp
   27ba2:	4638      	mov	r0, r7
				i++, j++;
   27ba4:	ebaa 0a03 	sub.w	sl, sl, r3
			err = bt_encrypt_be(key, b, X0);
   27ba8:	f003 f9b1 	bl	2af0e <bt_encrypt_be>
			aad_len -= 16;
   27bac:	3c10      	subs	r4, #16
   27bae:	b2e4      	uxtb	r4, r4
			if (err) {
   27bb0:	4603      	mov	r3, r0
   27bb2:	4669      	mov	r1, sp
   27bb4:	2800      	cmp	r0, #0
   27bb6:	d0d5      	beq.n	27b64 <ccm_auth.isra.0+0x9e>
	blk_cnt = (msg_len + 15) / 16;
   27bb8:	350f      	adds	r5, #15
			memcpy(&b[i], &Xn[i], 16 - i);
   27bba:	ab04      	add	r3, sp, #16
	blk_cnt = (msg_len + 15) / 16;
   27bbc:	2400      	movs	r4, #0
	for (j = 0; j < blk_cnt; j++) {
   27bbe:	f3c5 150f 	ubfx	r5, r5, #4, #16
			memcpy(&b[i], &Xn[i], 16 - i);
   27bc2:	eb03 0a08 	add.w	sl, r3, r8
	for (j = 0; j < blk_cnt; j++) {
   27bc6:	42ac      	cmp	r4, r5
   27bc8:	db1d      	blt.n	27c06 <ccm_auth.isra.0+0x140>
   27bca:	e9dd 2118 	ldrd	r2, r1, [sp, #96]	; 0x60
   27bce:	ac08      	add	r4, sp, #32
   27bd0:	ab04      	add	r3, sp, #16
   27bd2:	1851      	adds	r1, r2, r1
	for (i = 0; i < mic_size; i++) {
   27bd4:	4291      	cmp	r1, r2
   27bd6:	d038      	beq.n	27c4a <ccm_auth.isra.0+0x184>
		mic[i] = s0[i] ^ Xn[i];
   27bd8:	f814 0b01 	ldrb.w	r0, [r4], #1
   27bdc:	f813 5b01 	ldrb.w	r5, [r3], #1
   27be0:	4068      	eors	r0, r5
   27be2:	f802 0b01 	strb.w	r0, [r2], #1
	for (i = 0; i < mic_size; i++) {
   27be6:	e7f5      	b.n	27bd4 <ccm_auth.isra.0+0x10e>
			b[i] = X0[i] ^ aad[j];
   27be8:	f812 c003 	ldrb.w	ip, [r2, r3]
   27bec:	f811 0b01 	ldrb.w	r0, [r1], #1
   27bf0:	ea80 000c 	eor.w	r0, r0, ip
   27bf4:	f80d 0003 	strb.w	r0, [sp, r3]
		for (; i < aad_len; i++, j++) {
   27bf8:	3301      	adds	r3, #1
   27bfa:	e7b9      	b.n	27b70 <ccm_auth.isra.0+0xaa>
			b[i] = X0[i];
   27bfc:	5c13      	ldrb	r3, [r2, r0]
   27bfe:	f80d 3000 	strb.w	r3, [sp, r0]
		for (i = aad_len; i < 16; i++) {
   27c02:	3001      	adds	r0, #1
   27c04:	e7b7      	b.n	27b76 <ccm_auth.isra.0+0xb0>
		if (j + 1 == blk_cnt) {
   27c06:	3401      	adds	r4, #1
   27c08:	42ac      	cmp	r4, r5
   27c0a:	d121      	bne.n	27c50 <ccm_auth.isra.0+0x18a>
   27c0c:	f10d 0c10 	add.w	ip, sp, #16
   27c10:	466b      	mov	r3, sp
   27c12:	4630      	mov	r0, r6
			for (i = 0; i < last_blk; i++) {
   27c14:	2200      	movs	r2, #0
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   27c16:	f81c 1b01 	ldrb.w	r1, [ip], #1
   27c1a:	f810 eb01 	ldrb.w	lr, [r0], #1
			for (i = 0; i < last_blk; i++) {
   27c1e:	3201      	adds	r2, #1
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   27c20:	ea81 010e 	eor.w	r1, r1, lr
			for (i = 0; i < last_blk; i++) {
   27c24:	4542      	cmp	r2, r8
				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
   27c26:	f803 1b01 	strb.w	r1, [r3], #1
			for (i = 0; i < last_blk; i++) {
   27c2a:	dbf4      	blt.n	27c16 <ccm_auth.isra.0+0x150>
			memcpy(&b[i], &Xn[i], 16 - i);
   27c2c:	f1c8 0210 	rsb	r2, r8, #16
   27c30:	4651      	mov	r1, sl
   27c32:	eb0d 0008 	add.w	r0, sp, r8
   27c36:	f7ff fe1b 	bl	27870 <memcpy>
		err = bt_encrypt_be(key, b, Xn);
   27c3a:	aa04      	add	r2, sp, #16
   27c3c:	4649      	mov	r1, r9
   27c3e:	4638      	mov	r0, r7
   27c40:	f003 f965 	bl	2af0e <bt_encrypt_be>
		if (err) {
   27c44:	3610      	adds	r6, #16
   27c46:	2800      	cmp	r0, #0
   27c48:	d0bd      	beq.n	27bc6 <ccm_auth.isra.0+0x100>
}
   27c4a:	b00d      	add	sp, #52	; 0x34
   27c4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xor16(b, Xn, &cleartext_msg[j * 16]);
   27c50:	4632      	mov	r2, r6
   27c52:	a904      	add	r1, sp, #16
   27c54:	4668      	mov	r0, sp
   27c56:	f7ff fea6 	bl	279a6 <xor16>
   27c5a:	e7ee      	b.n	27c3a <ccm_auth.isra.0+0x174>

00027c5c <bt_ccm_decrypt>:

int bt_ccm_decrypt(const uint8_t key[16], uint8_t nonce[13],
		   const uint8_t *enc_data, size_t len, const uint8_t *aad,
		   size_t aad_len, uint8_t *plaintext, size_t mic_size)
{
   27c5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27c60:	b089      	sub	sp, #36	; 0x24
   27c62:	e9dd ba13 	ldrd	fp, sl, [sp, #76]	; 0x4c
	uint8_t mic[16];

	if (aad_len >= 0xff00 || mic_size > sizeof(mic)) {
   27c66:	f5bb 4f7f 	cmp.w	fp, #65280	; 0xff00
{
   27c6a:	9e15      	ldr	r6, [sp, #84]	; 0x54
   27c6c:	4607      	mov	r7, r0
   27c6e:	4688      	mov	r8, r1
   27c70:	4615      	mov	r5, r2
   27c72:	461c      	mov	r4, r3
	if (aad_len >= 0xff00 || mic_size > sizeof(mic)) {
   27c74:	d21e      	bcs.n	27cb4 <bt_ccm_decrypt+0x58>
   27c76:	2e10      	cmp	r6, #16
   27c78:	d81c      	bhi.n	27cb4 <bt_ccm_decrypt+0x58>
		return -EINVAL;
	}

	ccm_crypt(key, nonce, enc_data, plaintext, len);
   27c7a:	9300      	str	r3, [sp, #0]
   27c7c:	4653      	mov	r3, sl
   27c7e:	f7ff fed4 	bl	27a2a <ccm_crypt.isra.0>

	ccm_auth(key, nonce, plaintext, len, aad, aad_len, mic, mic_size);
   27c82:	f10d 0910 	add.w	r9, sp, #16
   27c86:	9b12      	ldr	r3, [sp, #72]	; 0x48
   27c88:	9300      	str	r3, [sp, #0]
   27c8a:	4652      	mov	r2, sl
   27c8c:	4623      	mov	r3, r4
   27c8e:	4641      	mov	r1, r8
   27c90:	4638      	mov	r0, r7
   27c92:	e9cd b901 	strd	fp, r9, [sp, #4]
   27c96:	9603      	str	r6, [sp, #12]
   27c98:	f7ff ff15 	bl	27ac6 <ccm_auth.isra.0>

	if (memcmp(mic, enc_data + len, mic_size)) {
   27c9c:	4632      	mov	r2, r6
   27c9e:	1929      	adds	r1, r5, r4
   27ca0:	4648      	mov	r0, r9
   27ca2:	f7ff fdd4 	bl	2784e <memcmp>
		return -EBADMSG;
   27ca6:	2800      	cmp	r0, #0
   27ca8:	bf18      	it	ne
   27caa:	f06f 004c 	mvnne.w	r0, #76	; 0x4c
	}

	return 0;
}
   27cae:	b009      	add	sp, #36	; 0x24
   27cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   27cb4:	f06f 0015 	mvn.w	r0, #21
   27cb8:	e7f9      	b.n	27cae <bt_ccm_decrypt+0x52>

00027cba <bt_ccm_encrypt>:

int bt_ccm_encrypt(const uint8_t key[16], uint8_t nonce[13],
		   const uint8_t *plaintext, size_t len, const uint8_t *aad,
		   size_t aad_len, uint8_t *enc_data, size_t mic_size)
{
   27cba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27cbe:	b085      	sub	sp, #20
   27cc0:	e9dd 790d 	ldrd	r7, r9, [sp, #52]	; 0x34
	BT_DBG("nonce %s", bt_hex(nonce, 13));
	BT_DBG("msg (len %zu) %s", len, bt_hex(plaintext, len));
	BT_DBG("aad_len %zu mic_size %zu", aad_len, mic_size);

	/* Unsupported AAD size */
	if (aad_len >= 0xff00 || mic_size > 16) {
   27cc4:	f5b7 4f7f 	cmp.w	r7, #65280	; 0xff00
{
   27cc8:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
   27ccc:	4605      	mov	r5, r0
   27cce:	460e      	mov	r6, r1
   27cd0:	4690      	mov	r8, r2
   27cd2:	461c      	mov	r4, r3
	uint8_t *mic = enc_data + len;
   27cd4:	eb09 0e03 	add.w	lr, r9, r3
	if (aad_len >= 0xff00 || mic_size > 16) {
   27cd8:	d214      	bcs.n	27d04 <bt_ccm_encrypt+0x4a>
   27cda:	f1bc 0f10 	cmp.w	ip, #16
   27cde:	d811      	bhi.n	27d04 <bt_ccm_encrypt+0x4a>
		return -EINVAL;
	}

	ccm_auth(key, nonce, plaintext, len, aad, aad_len, mic, mic_size);
   27ce0:	9701      	str	r7, [sp, #4]
   27ce2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   27ce4:	9700      	str	r7, [sp, #0]
   27ce6:	e9cd ec02 	strd	lr, ip, [sp, #8]
   27cea:	f7ff feec 	bl	27ac6 <ccm_auth.isra.0>

	ccm_crypt(key, nonce, plaintext, enc_data, len);
   27cee:	4628      	mov	r0, r5
   27cf0:	9400      	str	r4, [sp, #0]
   27cf2:	464b      	mov	r3, r9
   27cf4:	4642      	mov	r2, r8
   27cf6:	4631      	mov	r1, r6
   27cf8:	f7ff fe97 	bl	27a2a <ccm_crypt.isra.0>

	return 0;
   27cfc:	2000      	movs	r0, #0
}
   27cfe:	b005      	add	sp, #20
   27d00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -EINVAL;
   27d04:	f06f 0015 	mvn.w	r0, #21
   27d08:	e7f9      	b.n	27cfe <bt_ccm_encrypt+0x44>

00027d0a <bt_uuid_cmp>:
{
   27d0a:	b510      	push	{r4, lr}
   27d0c:	460c      	mov	r4, r1
	if (u1->type != u2->type) {
   27d0e:	7801      	ldrb	r1, [r0, #0]
   27d10:	7822      	ldrb	r2, [r4, #0]
   27d12:	428a      	cmp	r2, r1
{
   27d14:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   27d16:	d00f      	beq.n	27d38 <bt_uuid_cmp+0x2e>
	uuid_to_uuid128(u1, &uuid1);
   27d18:	4669      	mov	r1, sp
   27d1a:	f7dd fd81 	bl	5820 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   27d1e:	a905      	add	r1, sp, #20
   27d20:	4620      	mov	r0, r4
   27d22:	f7dd fd7d 	bl	5820 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   27d26:	2210      	movs	r2, #16
   27d28:	f10d 0115 	add.w	r1, sp, #21
   27d2c:	f10d 0001 	add.w	r0, sp, #1
   27d30:	f7ff fd8d 	bl	2784e <memcmp>
}
   27d34:	b00a      	add	sp, #40	; 0x28
   27d36:	bd10      	pop	{r4, pc}
	switch (u1->type) {
   27d38:	2a01      	cmp	r2, #1
   27d3a:	d006      	beq.n	27d4a <bt_uuid_cmp+0x40>
   27d3c:	2a02      	cmp	r2, #2
   27d3e:	d007      	beq.n	27d50 <bt_uuid_cmp+0x46>
   27d40:	b972      	cbnz	r2, 27d60 <bt_uuid_cmp+0x56>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   27d42:	8840      	ldrh	r0, [r0, #2]
   27d44:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   27d46:	1ac0      	subs	r0, r0, r3
   27d48:	e7f4      	b.n	27d34 <bt_uuid_cmp+0x2a>
   27d4a:	6840      	ldr	r0, [r0, #4]
   27d4c:	6863      	ldr	r3, [r4, #4]
   27d4e:	e7fa      	b.n	27d46 <bt_uuid_cmp+0x3c>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   27d50:	2210      	movs	r2, #16
   27d52:	1c61      	adds	r1, r4, #1
   27d54:	3001      	adds	r0, #1
}
   27d56:	b00a      	add	sp, #40	; 0x28
   27d58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   27d5c:	f7ff bd77 	b.w	2784e <memcmp>
	switch (u1->type) {
   27d60:	f06f 0015 	mvn.w	r0, #21
   27d64:	e7e6      	b.n	27d34 <bt_uuid_cmp+0x2a>

00027d66 <bt_uuid_create>:
	switch (data_len) {
   27d66:	2a04      	cmp	r2, #4
{
   27d68:	b510      	push	{r4, lr}
	switch (data_len) {
   27d6a:	d00a      	beq.n	27d82 <bt_uuid_create+0x1c>
   27d6c:	2a10      	cmp	r2, #16
   27d6e:	d00d      	beq.n	27d8c <bt_uuid_create+0x26>
   27d70:	2a02      	cmp	r2, #2
   27d72:	f04f 0300 	mov.w	r3, #0
   27d76:	d10f      	bne.n	27d98 <bt_uuid_create+0x32>
		uuid->type = BT_UUID_TYPE_16;
   27d78:	7003      	strb	r3, [r0, #0]
	return ((uint16_t)src[1] << 8) | src[0];
   27d7a:	880b      	ldrh	r3, [r1, #0]
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   27d7c:	8043      	strh	r3, [r0, #2]
	return true;
   27d7e:	2001      	movs	r0, #1
}
   27d80:	bd10      	pop	{r4, pc}
		uuid->type = BT_UUID_TYPE_32;
   27d82:	2301      	movs	r3, #1
   27d84:	7003      	strb	r3, [r0, #0]
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   27d86:	680a      	ldr	r2, [r1, #0]
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   27d88:	6042      	str	r2, [r0, #4]
		break;
   27d8a:	e7f8      	b.n	27d7e <bt_uuid_create+0x18>
		uuid->type = BT_UUID_TYPE_128;
   27d8c:	2302      	movs	r3, #2
   27d8e:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   27d92:	f7ff fd6d 	bl	27870 <memcpy>
		break;
   27d96:	e7f2      	b.n	27d7e <bt_uuid_create+0x18>
	switch (data_len) {
   27d98:	4618      	mov	r0, r3
   27d9a:	e7f1      	b.n	27d80 <bt_uuid_create+0x1a>

00027d9c <bt_addr_le_create_static>:
#include <bluetooth/addr.h>
#include <bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
   27d9c:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
   27d9e:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   27da0:	2106      	movs	r1, #6
{
   27da2:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   27da4:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   27da8:	f003 f8af 	bl	2af0a <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
   27dac:	b918      	cbnz	r0, 27db6 <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
   27dae:	79a3      	ldrb	r3, [r4, #6]
   27db0:	f063 033f 	orn	r3, r3, #63	; 0x3f
   27db4:	71a3      	strb	r3, [r4, #6]

	return 0;
}
   27db6:	bd10      	pop	{r4, pc}

00027db8 <bt_hci_evt_get_flags>:
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
   27db8:	280f      	cmp	r0, #15
   27dba:	d806      	bhi.n	27dca <bt_hci_evt_get_flags+0x12>
   27dbc:	280d      	cmp	r0, #13
   27dbe:	d80b      	bhi.n	27dd8 <bt_hci_evt_get_flags+0x20>
	case BT_HCI_EVT_DISCONN_COMPLETE:
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
   27dc0:	2805      	cmp	r0, #5
   27dc2:	bf14      	ite	ne
   27dc4:	2002      	movne	r0, #2
   27dc6:	2003      	moveq	r0, #3
   27dc8:	4770      	bx	lr
	switch (evt) {
   27dca:	2813      	cmp	r0, #19
   27dcc:	d004      	beq.n	27dd8 <bt_hci_evt_get_flags+0x20>
   27dce:	281a      	cmp	r0, #26
   27dd0:	bf14      	ite	ne
   27dd2:	2002      	movne	r0, #2
   27dd4:	2001      	moveq	r0, #1
   27dd6:	4770      	bx	lr
   27dd8:	2001      	movs	r0, #1
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
	}
}
   27dda:	4770      	bx	lr

00027ddc <atomic_or>:
{
   27ddc:	4603      	mov	r3, r0
}
   27dde:	f3bf 8f5b 	dmb	ish
   27de2:	e853 0f00 	ldrex	r0, [r3]
   27de6:	ea40 0201 	orr.w	r2, r0, r1
   27dea:	e843 2c00 	strex	ip, r2, [r3]
   27dee:	f1bc 0f00 	cmp.w	ip, #0
   27df2:	d1f6      	bne.n	27de2 <atomic_or+0x6>
   27df4:	f3bf 8f5b 	dmb	ish
   27df8:	4770      	bx	lr

00027dfa <z_log_msg2_static_create.constprop.0>:
   27dfa:	2300      	movs	r3, #0
   27dfc:	f7fd bf6c 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00027e00 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   27e00:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   27e02:	ab0a      	add	r3, sp, #40	; 0x28
   27e04:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   27e06:	9302      	str	r3, [sp, #8]
   27e08:	9b09      	ldr	r3, [sp, #36]	; 0x24
   27e0a:	9301      	str	r3, [sp, #4]
   27e0c:	2300      	movs	r3, #0
   27e0e:	9300      	str	r3, [sp, #0]
   27e10:	4618      	mov	r0, r3
   27e12:	f7db fa49 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   27e16:	b007      	add	sp, #28
   27e18:	f85d fb04 	ldr.w	pc, [sp], #4

00027e1c <bt_hci_disconnect>:
{
   27e1c:	b570      	push	{r4, r5, r6, lr}
   27e1e:	4606      	mov	r6, r0
   27e20:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   27e22:	f240 4006 	movw	r0, #1030	; 0x406
   27e26:	2103      	movs	r1, #3
   27e28:	f7de f99a 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
   27e2c:	4604      	mov	r4, r0
   27e2e:	b168      	cbz	r0, 27e4c <bt_hci_disconnect+0x30>
   27e30:	2103      	movs	r1, #3
   27e32:	3008      	adds	r0, #8
   27e34:	f003 ff82 	bl	2bd3c <net_buf_simple_add>
	disconn->reason = reason;
   27e38:	7085      	strb	r5, [r0, #2]
	disconn->handle = sys_cpu_to_le16(handle);
   27e3a:	8006      	strh	r6, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   27e3c:	4621      	mov	r1, r4
   27e3e:	2200      	movs	r2, #0
}
   27e40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   27e44:	f240 4006 	movw	r0, #1030	; 0x406
   27e48:	f7de bae6 	b.w	6418 <bt_hci_cmd_send_sync>
}
   27e4c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   27e50:	bd70      	pop	{r4, r5, r6, pc}

00027e52 <le_enh_conn_complete>:
	bt_hci_le_enh_conn_complete(evt);
   27e52:	6880      	ldr	r0, [r0, #8]
   27e54:	f7de bb60 	b.w	6518 <bt_hci_le_enh_conn_complete>

00027e58 <le_legacy_conn_complete>:
{
   27e58:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   27e5a:	6881      	ldr	r1, [r0, #8]
{
   27e5c:	b08a      	sub	sp, #40	; 0x28
	enh.status         = evt->status;
   27e5e:	780b      	ldrb	r3, [r1, #0]
   27e60:	f88d 3008 	strb.w	r3, [sp, #8]
	enh.handle         = evt->handle;
   27e64:	f8b1 3001 	ldrh.w	r3, [r1, #1]
   27e68:	f8ad 3009 	strh.w	r3, [sp, #9]
	enh.role           = evt->role;
   27e6c:	78cb      	ldrb	r3, [r1, #3]
   27e6e:	f88d 300b 	strb.w	r3, [sp, #11]
	enh.interval       = evt->interval;
   27e72:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   27e76:	f8ad 301f 	strh.w	r3, [sp, #31]
	enh.latency        = evt->latency;
   27e7a:	f8b1 300d 	ldrh.w	r3, [r1, #13]
   27e7e:	f8ad 3021 	strh.w	r3, [sp, #33]	; 0x21
	enh.supv_timeout   = evt->supv_timeout;
   27e82:	f8b1 300f 	ldrh.w	r3, [r1, #15]
   27e86:	f8ad 3023 	strh.w	r3, [sp, #35]	; 0x23
	enh.clock_accuracy = evt->clock_accuracy;
   27e8a:	7c4b      	ldrb	r3, [r1, #17]
   27e8c:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
   27e90:	2207      	movs	r2, #7
   27e92:	3104      	adds	r1, #4
   27e94:	a803      	add	r0, sp, #12
   27e96:	f7ff fceb 	bl	27870 <memcpy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   27e9a:	2400      	movs	r4, #0
	memcpy(dst, src, sizeof(*dst));
   27e9c:	4669      	mov	r1, sp
   27e9e:	2206      	movs	r2, #6
   27ea0:	f10d 0013 	add.w	r0, sp, #19
   27ea4:	9400      	str	r4, [sp, #0]
   27ea6:	f8ad 4004 	strh.w	r4, [sp, #4]
   27eaa:	f7ff fce1 	bl	27870 <memcpy>
   27eae:	2206      	movs	r2, #6
   27eb0:	4669      	mov	r1, sp
   27eb2:	f10d 0019 	add.w	r0, sp, #25
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   27eb6:	9400      	str	r4, [sp, #0]
   27eb8:	f8ad 4004 	strh.w	r4, [sp, #4]
   27ebc:	f7ff fcd8 	bl	27870 <memcpy>
	bt_hci_le_enh_conn_complete(evt);
   27ec0:	a802      	add	r0, sp, #8
   27ec2:	f7de fb29 	bl	6518 <bt_hci_le_enh_conn_complete>
}
   27ec6:	b00a      	add	sp, #40	; 0x28
   27ec8:	bd10      	pop	{r4, pc}

00027eca <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   27eca:	8803      	ldrh	r3, [r0, #0]
   27ecc:	8842      	ldrh	r2, [r0, #2]
   27ece:	4293      	cmp	r3, r2
{
   27ed0:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   27ed2:	d819      	bhi.n	27f08 <bt_le_conn_params_valid+0x3e>
   27ed4:	2b05      	cmp	r3, #5
   27ed6:	d917      	bls.n	27f08 <bt_le_conn_params_valid+0x3e>
	    param->interval_min < 6 || param->interval_max > 3200) {
   27ed8:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
   27edc:	d814      	bhi.n	27f08 <bt_le_conn_params_valid+0x3e>
	if (param->latency > 499) {
   27ede:	8883      	ldrh	r3, [r0, #4]
   27ee0:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   27ee4:	d210      	bcs.n	27f08 <bt_le_conn_params_valid+0x3e>
	if (param->timeout < 10 || param->timeout > 3200 ||
   27ee6:	88c0      	ldrh	r0, [r0, #6]
   27ee8:	f1a0 010a 	sub.w	r1, r0, #10
   27eec:	b289      	uxth	r1, r1
   27eee:	f640 4476 	movw	r4, #3190	; 0xc76
   27ef2:	42a1      	cmp	r1, r4
   27ef4:	d808      	bhi.n	27f08 <bt_le_conn_params_valid+0x3e>
	     ((1U + param->latency) * param->interval_max))) {
   27ef6:	3301      	adds	r3, #1
   27ef8:	b29b      	uxth	r3, r3
   27efa:	4353      	muls	r3, r2
	if (param->timeout < 10 || param->timeout > 3200 ||
   27efc:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
   27f00:	bf34      	ite	cc
   27f02:	2001      	movcc	r0, #1
   27f04:	2000      	movcs	r0, #0
}
   27f06:	bd10      	pop	{r4, pc}
		return false;
   27f08:	2000      	movs	r0, #0
   27f0a:	e7fc      	b.n	27f06 <bt_le_conn_params_valid+0x3c>

00027f0c <bt_send>:
		return bt_hci_ecc_send(buf);
   27f0c:	f7dd baca 	b.w	54a4 <bt_hci_ecc_send>

00027f10 <bt_addr_le_is_bonded>:
		/* if there are any keys stored then device is bonded */
		return keys && keys->keys;
	} else {
		return false;
	}
}
   27f10:	2000      	movs	r0, #0
   27f12:	4770      	bx	lr

00027f14 <bt_hci_evt_create>:
#include <stdint.h>
#include <sys/byteorder.h>
#include <drivers/bluetooth/hci_driver.h>

struct net_buf *bt_hci_evt_create(uint8_t evt, uint8_t len)
{
   27f14:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_hdr *hdr;
	struct net_buf *buf;

	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   27f16:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   27f1a:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   27f1c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   27f20:	2100      	movs	r1, #0
{
   27f22:	4606      	mov	r6, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
   27f24:	f7dd fd3a 	bl	599c <bt_buf_get_evt>
   27f28:	2102      	movs	r1, #2
   27f2a:	4604      	mov	r4, r0
   27f2c:	3008      	adds	r0, #8
   27f2e:	f003 ff05 	bl	2bd3c <net_buf_simple_add>

	hdr = net_buf_add(buf, sizeof(*hdr));
	hdr->evt = evt;
   27f32:	7006      	strb	r6, [r0, #0]
	hdr->len = len;
   27f34:	7045      	strb	r5, [r0, #1]

	return buf;
}
   27f36:	4620      	mov	r0, r4
   27f38:	bd70      	pop	{r4, r5, r6, pc}

00027f3a <bt_hci_cmd_complete_create>:
struct net_buf *bt_hci_cmd_complete_create(uint16_t op, uint8_t plen)
{
	struct net_buf *buf;
	struct bt_hci_evt_cmd_complete *cc;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   27f3a:	3103      	adds	r1, #3
{
   27f3c:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   27f3e:	b2c9      	uxtb	r1, r1
{
   27f40:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   27f42:	200e      	movs	r0, #14
   27f44:	f7ff ffe6 	bl	27f14 <bt_hci_evt_create>
   27f48:	2103      	movs	r1, #3
   27f4a:	4604      	mov	r4, r0
   27f4c:	3008      	adds	r0, #8
   27f4e:	f003 fef5 	bl	2bd3c <net_buf_simple_add>

	cc = net_buf_add(buf, sizeof(*cc));
	cc->ncmd = 1U;
   27f52:	2301      	movs	r3, #1
   27f54:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
   27f56:	f8a0 5001 	strh.w	r5, [r0, #1]

	return buf;
}
   27f5a:	4620      	mov	r0, r4
   27f5c:	bd38      	pop	{r3, r4, r5, pc}

00027f5e <bt_hci_cmd_status_create>:

struct net_buf *bt_hci_cmd_status_create(uint16_t op, uint8_t status)
{
   27f5e:	b570      	push	{r4, r5, r6, lr}
   27f60:	4605      	mov	r5, r0
   27f62:	460e      	mov	r6, r1
	struct net_buf *buf;
	struct bt_hci_evt_cmd_status *cs;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   27f64:	200f      	movs	r0, #15
   27f66:	2104      	movs	r1, #4
   27f68:	f7ff ffd4 	bl	27f14 <bt_hci_evt_create>
   27f6c:	2104      	movs	r1, #4
   27f6e:	4604      	mov	r4, r0
   27f70:	3008      	adds	r0, #8
   27f72:	f003 fee3 	bl	2bd3c <net_buf_simple_add>

	cs = net_buf_add(buf, sizeof(*cs));
	cs->status = status;
	cs->ncmd = 1U;
   27f76:	2201      	movs	r2, #1
	cs->status = status;
   27f78:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
   27f7a:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
   27f7c:	8045      	strh	r5, [r0, #2]

	return buf;
}
   27f7e:	4620      	mov	r0, r4
   27f80:	bd70      	pop	{r4, r5, r6, pc}

00027f82 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   27f82:	f3bf 8f5b 	dmb	ish
   27f86:	6800      	ldr	r0, [r0, #0]
   27f88:	f3bf 8f5b 	dmb	ish
}
   27f8c:	4770      	bx	lr

00027f8e <is_adv_using_rand_addr>:
{
   27f8e:	b508      	push	{r3, lr}
	adv = bt_le_adv_lookup_legacy();
   27f90:	f7df fbc0 	bl	7714 <bt_le_adv_lookup_legacy>
	return adv && atomic_test_bit(adv->flags, BT_ADV_ENABLED);
   27f94:	b120      	cbz	r0, 27fa0 <is_adv_using_rand_addr+0x12>
   27f96:	3010      	adds	r0, #16
   27f98:	f7ff fff3 	bl	27f82 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   27f9c:	f3c0 1080 	ubfx	r0, r0, #6, #1
}
   27fa0:	bd08      	pop	{r3, pc}

00027fa2 <bt_lookup_id_addr>:
}
   27fa2:	4608      	mov	r0, r1
   27fa4:	4770      	bx	lr

00027fa6 <bt_id_set_private_addr>:
{
   27fa6:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   27fa8:	2106      	movs	r1, #6
   27faa:	4668      	mov	r0, sp
   27fac:	f002 ffad 	bl	2af0a <bt_rand>
	if (err) {
   27fb0:	b940      	cbnz	r0, 27fc4 <bt_id_set_private_addr+0x1e>
	BT_ADDR_SET_NRPA(&nrpa);
   27fb2:	f89d 3005 	ldrb.w	r3, [sp, #5]
	err = set_random_address(&nrpa);
   27fb6:	4668      	mov	r0, sp
	BT_ADDR_SET_NRPA(&nrpa);
   27fb8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   27fbc:	f88d 3005 	strb.w	r3, [sp, #5]
	err = set_random_address(&nrpa);
   27fc0:	f7df f85c 	bl	707c <set_random_address>
}
   27fc4:	b003      	add	sp, #12
   27fc6:	f85d fb04 	ldr.w	pc, [sp], #4

00027fca <bt_id_set_adv_private_addr>:
{
   27fca:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   27fcc:	2106      	movs	r1, #6
   27fce:	4668      	mov	r0, sp
   27fd0:	f002 ff9b 	bl	2af0a <bt_rand>
	if (err) {
   27fd4:	b940      	cbnz	r0, 27fe8 <bt_id_set_adv_private_addr+0x1e>
	BT_ADDR_SET_NRPA(&nrpa);
   27fd6:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
   27fda:	4668      	mov	r0, sp
	BT_ADDR_SET_NRPA(&nrpa);
   27fdc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   27fe0:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
   27fe4:	f7df f84a 	bl	707c <set_random_address>
}
   27fe8:	b003      	add	sp, #12
   27fea:	f85d fb04 	ldr.w	pc, [sp], #4

00027fee <bt_id_scan_random_addr_check>:
{
   27fee:	b508      	push	{r3, lr}
	adv = bt_le_adv_lookup_legacy();
   27ff0:	f7df fb90 	bl	7714 <bt_le_adv_lookup_legacy>
	if (!adv) {
   27ff4:	b110      	cbz	r0, 27ffc <bt_id_scan_random_addr_check+0xe>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   27ff6:	3010      	adds	r0, #16
   27ff8:	f7ff ffc3 	bl	27f82 <atomic_get>
}
   27ffc:	2001      	movs	r0, #1
   27ffe:	bd08      	pop	{r3, pc}

00028000 <bt_id_init>:
#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
}
   28000:	2000      	movs	r0, #0
   28002:	4770      	bx	lr

00028004 <get_adv_channel_map>:
{
   28004:	4603      	mov	r3, r0
		channel_map &= ~0x01;
   28006:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   2800a:	bf0c      	ite	eq
   2800c:	2007      	moveq	r0, #7
   2800e:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
   28010:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
   28012:	bf48      	it	mi
   28014:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
   28018:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
   2801a:	bf48      	it	mi
   2801c:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
   28020:	4770      	bx	lr

00028022 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   28022:	f3bf 8f5b 	dmb	ish
   28026:	6800      	ldr	r0, [r0, #0]
   28028:	f3bf 8f5b 	dmb	ish
}
   2802c:	4770      	bx	lr

0002802e <atomic_and>:
{
   2802e:	4603      	mov	r3, r0
}
   28030:	f3bf 8f5b 	dmb	ish
   28034:	e853 0f00 	ldrex	r0, [r3]
   28038:	ea00 0201 	and.w	r2, r0, r1
   2803c:	e843 2c00 	strex	ip, r2, [r3]
   28040:	f1bc 0f00 	cmp.w	ip, #0
   28044:	d1f6      	bne.n	28034 <atomic_and+0x6>
   28046:	f3bf 8f5b 	dmb	ish
   2804a:	4770      	bx	lr

0002804c <atomic_set_bit_to>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   2804c:	2301      	movs	r3, #1
{
   2804e:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
   28050:	fa03 f101 	lsl.w	r1, r3, r1
{
   28054:	4604      	mov	r4, r0
	if (val) {
   28056:	b162      	cbz	r2, 28072 <atomic_set_bit_to+0x26>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   28058:	f3bf 8f5b 	dmb	ish
   2805c:	e854 3f00 	ldrex	r3, [r4]
   28060:	430b      	orrs	r3, r1
   28062:	e844 3200 	strex	r2, r3, [r4]
   28066:	2a00      	cmp	r2, #0
   28068:	d1f8      	bne.n	2805c <atomic_set_bit_to+0x10>
   2806a:	f3bf 8f5b 	dmb	ish
}
   2806e:	bc10      	pop	{r4}
   28070:	4770      	bx	lr
   28072:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   28074:	43c9      	mvns	r1, r1
   28076:	f7ff bfda 	b.w	2802e <atomic_and>

0002807a <le_adv_update.constprop.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
   2807a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2807e:	b087      	sub	sp, #28
   28080:	4605      	mov	r5, r0
   28082:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
   28086:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
   2808a:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
   2808e:	460c      	mov	r4, r1
   28090:	4690      	mov	r8, r2
	struct bt_ad d[2] = {};
   28092:	2100      	movs	r1, #0
   28094:	2210      	movs	r2, #16
   28096:	a802      	add	r0, sp, #8
static int le_adv_update(struct bt_le_ext_adv *adv,
   28098:	461f      	mov	r7, r3
	struct bt_ad d[2] = {};
   2809a:	f7ff fbf4 	bl	27886 <memset>
	if (name_type != ADV_NAME_TYPE_NONE) {
   2809e:	b186      	cbz	r6, 280c2 <le_adv_update.constprop.0+0x48>
		const char *name = bt_get_name();
   280a0:	f7de ffce 	bl	7040 <bt_get_name>
   280a4:	4683      	mov	fp, r0
		if ((ad && ad_has_name(ad, ad_len)) ||
   280a6:	2c00      	cmp	r4, #0
   280a8:	d139      	bne.n	2811e <le_adv_update.constprop.0+0xa4>
   280aa:	2f00      	cmp	r7, #0
   280ac:	d142      	bne.n	28134 <le_adv_update.constprop.0+0xba>
		data = (struct bt_data)BT_DATA(
   280ae:	4658      	mov	r0, fp
   280b0:	f7ff fba0 	bl	277f4 <strlen>
   280b4:	2309      	movs	r3, #9
   280b6:	f88d 3000 	strb.w	r3, [sp]
   280ba:	f88d 0001 	strb.w	r0, [sp, #1]
   280be:	f8cd b004 	str.w	fp, [sp, #4]
		if (name_type == ADV_NAME_TYPE_AD) {
   280c2:	2e01      	cmp	r6, #1
			d_len = 2;
   280c4:	bf0c      	ite	eq
   280c6:	2202      	moveq	r2, #2
		d_len = 1;
   280c8:	2201      	movne	r2, #1
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   280ca:	a902      	add	r1, sp, #8
   280cc:	f242 0008 	movw	r0, #8200	; 0x2008
		d[0].len = ad_len;
   280d0:	e9cd 4802 	strd	r4, r8, [sp, #8]
			d[1].data = &data;
   280d4:	bf04      	itt	eq
   280d6:	f8cd d010 	streq.w	sp, [sp, #16]
			d[1].len = 1;
   280da:	9605      	streq	r6, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   280dc:	f7df fa64 	bl	75a8 <hci_set_ad>
		if (err) {
   280e0:	4604      	mov	r4, r0
   280e2:	b978      	cbnz	r0, 28104 <le_adv_update.constprop.0+0x8a>
	if (scannable) {
   280e4:	f1ba 0f00 	cmp.w	sl, #0
   280e8:	d126      	bne.n	28138 <le_adv_update.constprop.0+0xbe>
   280ea:	3510      	adds	r5, #16
   280ec:	f3bf 8f5b 	dmb	ish
   280f0:	e855 3f00 	ldrex	r3, [r5]
   280f4:	f043 0304 	orr.w	r3, r3, #4
   280f8:	e845 3200 	strex	r2, r3, [r5]
   280fc:	2a00      	cmp	r2, #0
   280fe:	d1f7      	bne.n	280f0 <le_adv_update.constprop.0+0x76>
   28100:	f3bf 8f5b 	dmb	ish
}
   28104:	4620      	mov	r0, r4
   28106:	b007      	add	sp, #28
   28108:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   2810c:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
   28110:	3a08      	subs	r2, #8
   28112:	2a01      	cmp	r2, #1
   28114:	d925      	bls.n	28162 <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
   28116:	3301      	adds	r3, #1
   28118:	4598      	cmp	r8, r3
   2811a:	d1f7      	bne.n	2810c <le_adv_update.constprop.0+0x92>
   2811c:	e7c5      	b.n	280aa <le_adv_update.constprop.0+0x30>
   2811e:	2300      	movs	r3, #0
   28120:	e7fa      	b.n	28118 <le_adv_update.constprop.0+0x9e>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   28122:	f817 2033 	ldrb.w	r2, [r7, r3, lsl #3]
   28126:	3a08      	subs	r2, #8
   28128:	2a01      	cmp	r2, #1
   2812a:	d91a      	bls.n	28162 <le_adv_update.constprop.0+0xe8>
	for (i = 0; i < ad_len; i++) {
   2812c:	3301      	adds	r3, #1
   2812e:	4599      	cmp	r9, r3
   28130:	d1f7      	bne.n	28122 <le_adv_update.constprop.0+0xa8>
   28132:	e7bc      	b.n	280ae <le_adv_update.constprop.0+0x34>
   28134:	2300      	movs	r3, #0
   28136:	e7fa      	b.n	2812e <le_adv_update.constprop.0+0xb4>
		if (name_type == ADV_NAME_TYPE_SD) {
   28138:	2e02      	cmp	r6, #2
   2813a:	f04f 0201 	mov.w	r2, #1
			d[1].len = 1;
   2813e:	bf08      	it	eq
   28140:	9205      	streq	r2, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   28142:	a902      	add	r1, sp, #8
			d_len = 2;
   28144:	bf08      	it	eq
   28146:	4632      	moveq	r2, r6
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   28148:	f242 0009 	movw	r0, #8201	; 0x2009
			d[1].data = &data;
   2814c:	bf08      	it	eq
   2814e:	f8cd d010 	streq.w	sp, [sp, #16]
		d[0].len = sd_len;
   28152:	e9cd 7902 	strd	r7, r9, [sp, #8]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   28156:	f7df fa27 	bl	75a8 <hci_set_ad>
		if (err) {
   2815a:	2800      	cmp	r0, #0
   2815c:	d0c5      	beq.n	280ea <le_adv_update.constprop.0+0x70>
   2815e:	4604      	mov	r4, r0
   28160:	e7d0      	b.n	28104 <le_adv_update.constprop.0+0x8a>
			return -EINVAL;
   28162:	f06f 0415 	mvn.w	r4, #21
   28166:	e7cd      	b.n	28104 <le_adv_update.constprop.0+0x8a>

00028168 <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
   28168:	6843      	ldr	r3, [r0, #4]
   2816a:	f013 0008 	ands.w	r0, r3, #8
   2816e:	d00a      	beq.n	28186 <get_adv_name_type_param+0x1e>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
   28170:	035a      	lsls	r2, r3, #13
   28172:	d407      	bmi.n	28184 <get_adv_name_type_param+0x1c>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
   28174:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
		return ADV_NAME_TYPE_SD;
   28178:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   2817c:	bf0c      	ite	eq
   2817e:	2001      	moveq	r0, #1
   28180:	2002      	movne	r0, #2
   28182:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   28184:	2001      	movs	r0, #1
}
   28186:	4770      	bx	lr

00028188 <bt_le_adv_set_enable_legacy>:
{
   28188:	b570      	push	{r4, r5, r6, lr}
   2818a:	4606      	mov	r6, r0
   2818c:	b086      	sub	sp, #24
   2818e:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   28190:	f242 000a 	movw	r0, #8202	; 0x200a
   28194:	2101      	movs	r1, #1
   28196:	f7dd ffe3 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
   2819a:	4604      	mov	r4, r0
   2819c:	b1b0      	cbz	r0, 281cc <bt_le_adv_set_enable_legacy+0x44>
	return net_buf_simple_add_u8(&buf->b, val);
   2819e:	3008      	adds	r0, #8
	if (enable) {
   281a0:	b195      	cbz	r5, 281c8 <bt_le_adv_set_enable_legacy+0x40>
   281a2:	2101      	movs	r1, #1
   281a4:	f003 fdd9 	bl	2bd5a <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
   281a8:	f106 0210 	add.w	r2, r6, #16
   281ac:	a903      	add	r1, sp, #12
   281ae:	4620      	mov	r0, r4
   281b0:	9500      	str	r5, [sp, #0]
   281b2:	2306      	movs	r3, #6
   281b4:	f7dd ffc2 	bl	613c <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
   281b8:	2200      	movs	r2, #0
   281ba:	4621      	mov	r1, r4
   281bc:	f242 000a 	movw	r0, #8202	; 0x200a
   281c0:	f7de f92a 	bl	6418 <bt_hci_cmd_send_sync>
}
   281c4:	b006      	add	sp, #24
   281c6:	bd70      	pop	{r4, r5, r6, pc}
   281c8:	4629      	mov	r1, r5
   281ca:	e7eb      	b.n	281a4 <bt_le_adv_set_enable_legacy+0x1c>
		return -ENOBUFS;
   281cc:	f06f 0068 	mvn.w	r0, #104	; 0x68
   281d0:	e7f8      	b.n	281c4 <bt_le_adv_set_enable_legacy+0x3c>

000281d2 <bt_le_lim_adv_cancel_timeout>:
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
   281d2:	3018      	adds	r0, #24
   281d4:	f004 be17 	b.w	2ce06 <k_work_cancel_delayable>

000281d8 <atomic_and>:
{
   281d8:	4603      	mov	r3, r0
}
   281da:	f3bf 8f5b 	dmb	ish
   281de:	e853 0f00 	ldrex	r0, [r3]
   281e2:	ea00 0201 	and.w	r2, r0, r1
   281e6:	e843 2c00 	strex	ip, r2, [r3]
   281ea:	f1bc 0f00 	cmp.w	ip, #0
   281ee:	d1f6      	bne.n	281de <atomic_and+0x6>
   281f0:	f3bf 8f5b 	dmb	ish
   281f4:	4770      	bx	lr

000281f6 <bt_le_scan_set_enable>:
	return bt_le_scan_set_enable_legacy(enable);
   281f6:	f7df bcaf 	b.w	7b58 <bt_le_scan_set_enable_legacy>

000281fa <z_log_msg2_static_create.constprop.0>:
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   281fa:	2300      	movs	r3, #0
   281fc:	f7fd bd6c 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00028200 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   28200:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   28202:	ab0a      	add	r3, sp, #40	; 0x28
   28204:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   28206:	9302      	str	r3, [sp, #8]
   28208:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2820a:	9301      	str	r3, [sp, #4]
   2820c:	2300      	movs	r3, #0
   2820e:	9300      	str	r3, [sp, #0]
   28210:	2202      	movs	r2, #2
   28212:	4618      	mov	r0, r3
   28214:	f7db f848 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   28218:	b007      	add	sp, #28
   2821a:	f85d fb04 	ldr.w	pc, [sp], #4

0002821e <tx_notify>:
{
   2821e:	b570      	push	{r4, r5, r6, lr}
   28220:	4604      	mov	r4, r0
	__asm__ volatile(
   28222:	f04f 0220 	mov.w	r2, #32
   28226:	f3ef 8311 	mrs	r3, BASEPRI
   2822a:	f382 8812 	msr	BASEPRI_MAX, r2
   2822e:	f3bf 8f6f 	isb	sy
	return list->head;
   28232:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   28234:	b920      	cbnz	r0, 28240 <tx_notify+0x22>
	__asm__ volatile(
   28236:	f383 8811 	msr	BASEPRI, r3
   2823a:	f3bf 8f6f 	isb	sy
}
   2823e:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   28240:	6a61      	ldr	r1, [r4, #36]	; 0x24
	return node->next;
   28242:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   28244:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   28246:	4288      	cmp	r0, r1
	list->tail = node;
   28248:	bf08      	it	eq
   2824a:	6262      	streq	r2, [r4, #36]	; 0x24
   2824c:	f383 8811 	msr	BASEPRI, r3
   28250:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   28254:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   28258:	f7df ffc4 	bl	81e4 <tx_free>
		cb(conn, user_data);
   2825c:	4631      	mov	r1, r6
   2825e:	4620      	mov	r0, r4
   28260:	47a8      	blx	r5
	while (1) {
   28262:	e7de      	b.n	28222 <tx_notify+0x4>

00028264 <tx_complete_work>:
	tx_notify(conn);
   28264:	3828      	subs	r0, #40	; 0x28
   28266:	f7ff bfda 	b.w	2821e <tx_notify>

0002826a <bt_conn_reset_rx_state>:
{
   2826a:	b510      	push	{r4, lr}
   2826c:	4604      	mov	r4, r0
	if (!conn->rx) {
   2826e:	6900      	ldr	r0, [r0, #16]
   28270:	b118      	cbz	r0, 2827a <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
   28272:	f7f8 fb0f 	bl	20894 <net_buf_unref>
	conn->rx = NULL;
   28276:	2300      	movs	r3, #0
   28278:	6123      	str	r3, [r4, #16]
}
   2827a:	bd10      	pop	{r4, pc}

0002827c <conn_cleanup>:
{
   2827c:	b570      	push	{r4, r5, r6, lr}
   2827e:	4604      	mov	r4, r0
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   28280:	f100 0638 	add.w	r6, r0, #56	; 0x38
   28284:	2200      	movs	r2, #0
   28286:	2300      	movs	r3, #0
   28288:	4630      	mov	r0, r6
   2828a:	f003 fcd1 	bl	2bc30 <net_buf_get>
   2828e:	4605      	mov	r5, r0
   28290:	b950      	cbnz	r0, 282a8 <conn_cleanup+0x2c>
	bt_conn_reset_rx_state(conn);
   28292:	4620      	mov	r0, r4
   28294:	f7ff ffe9 	bl	2826a <bt_conn_reset_rx_state>
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
   28298:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2829c:	2200      	movs	r2, #0
}
   2829e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
   282a2:	2300      	movs	r3, #0
   282a4:	f7fc b85e 	b.w	24364 <k_work_reschedule>
		if (tx_data(buf)->tx) {
   282a8:	6968      	ldr	r0, [r5, #20]
   282aa:	b108      	cbz	r0, 282b0 <conn_cleanup+0x34>
			tx_free(tx_data(buf)->tx);
   282ac:	f7df ff9a 	bl	81e4 <tx_free>
		net_buf_unref(buf);
   282b0:	4628      	mov	r0, r5
   282b2:	f7f8 faef 	bl	20894 <net_buf_unref>
   282b6:	e7e5      	b.n	28284 <conn_cleanup+0x8>

000282b8 <bt_conn_ref>:
{
   282b8:	b510      	push	{r4, lr}
		old = atomic_get(&conn->ref);
   282ba:	f100 02b8 	add.w	r2, r0, #184	; 0xb8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   282be:	f3bf 8f5b 	dmb	ish
   282c2:	6813      	ldr	r3, [r2, #0]
   282c4:	f3bf 8f5b 	dmb	ish
		if (!old) {
   282c8:	b17b      	cbz	r3, 282ea <bt_conn_ref+0x32>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   282ca:	f3bf 8f5b 	dmb	ish
	} while (!atomic_cas(&conn->ref, old, old + 1));
   282ce:	1c59      	adds	r1, r3, #1
   282d0:	e852 4f00 	ldrex	r4, [r2]
   282d4:	429c      	cmp	r4, r3
   282d6:	d104      	bne.n	282e2 <bt_conn_ref+0x2a>
   282d8:	e842 1c00 	strex	ip, r1, [r2]
   282dc:	f1bc 0f00 	cmp.w	ip, #0
   282e0:	d1f6      	bne.n	282d0 <bt_conn_ref+0x18>
   282e2:	f3bf 8f5b 	dmb	ish
   282e6:	d1ea      	bne.n	282be <bt_conn_ref+0x6>
}
   282e8:	bd10      	pop	{r4, pc}
			return NULL;
   282ea:	4618      	mov	r0, r3
   282ec:	e7fc      	b.n	282e8 <bt_conn_ref+0x30>

000282ee <bt_conn_unref>:
	old = atomic_dec(&conn->ref);
   282ee:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   282f2:	f3bf 8f5b 	dmb	ish
   282f6:	e853 2f00 	ldrex	r2, [r3]
   282fa:	3a01      	subs	r2, #1
   282fc:	e843 2100 	strex	r1, r2, [r3]
   28300:	2900      	cmp	r1, #0
   28302:	d1f8      	bne.n	282f6 <bt_conn_unref+0x8>
   28304:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   28308:	7883      	ldrb	r3, [r0, #2]
   2830a:	2b01      	cmp	r3, #1
   2830c:	d108      	bne.n	28320 <bt_conn_unref+0x32>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2830e:	f3bf 8f5b 	dmb	ish
   28312:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
   28316:	f3bf 8f5b 	dmb	ish
   2831a:	b90b      	cbnz	r3, 28320 <bt_conn_unref+0x32>
		bt_le_adv_resume();
   2831c:	f7df bbdc 	b.w	7ad8 <bt_le_adv_resume>
}
   28320:	4770      	bx	lr

00028322 <conn_lookup_handle>:
{
   28322:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   28326:	4607      	mov	r7, r0
   28328:	460e      	mov	r6, r1
   2832a:	4690      	mov	r8, r2
	for (i = 0; i < size; i++) {
   2832c:	2400      	movs	r4, #0
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   2832e:	f04f 09c0 	mov.w	r9, #192	; 0xc0
	for (i = 0; i < size; i++) {
   28332:	42b4      	cmp	r4, r6
   28334:	d103      	bne.n	2833e <conn_lookup_handle+0x1c>
	return NULL;
   28336:	2300      	movs	r3, #0
}
   28338:	4618      	mov	r0, r3
   2833a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   2833e:	fb09 7004 	mla	r0, r9, r4, r7
   28342:	f7ff ffb9 	bl	282b8 <bt_conn_ref>
   28346:	4603      	mov	r3, r0
		if (!conn) {
   28348:	b158      	cbz	r0, 28362 <conn_lookup_handle+0x40>
		if (!bt_conn_is_handle_valid(conn)) {
   2834a:	7a85      	ldrb	r5, [r0, #10]
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
   2834c:	2d01      	cmp	r5, #1
   2834e:	d002      	beq.n	28356 <conn_lookup_handle+0x34>
   28350:	3d07      	subs	r5, #7
   28352:	2d01      	cmp	r5, #1
   28354:	d803      	bhi.n	2835e <conn_lookup_handle+0x3c>
		if (conn->handle != handle) {
   28356:	881a      	ldrh	r2, [r3, #0]
   28358:	4542      	cmp	r2, r8
   2835a:	d0ed      	beq.n	28338 <conn_lookup_handle+0x16>
			bt_conn_unref(conn);
   2835c:	4618      	mov	r0, r3
   2835e:	f7ff ffc6 	bl	282ee <bt_conn_unref>
	for (i = 0; i < size; i++) {
   28362:	3401      	adds	r4, #1
   28364:	e7e5      	b.n	28332 <conn_lookup_handle+0x10>

00028366 <bt_conn_connected>:
{
   28366:	b510      	push	{r4, lr}
   28368:	4604      	mov	r4, r0
	bt_l2cap_connected(conn);
   2836a:	f7e0 fda1 	bl	8eb0 <bt_l2cap_connected>
	notify_connected(conn);
   2836e:	4620      	mov	r0, r4
}
   28370:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	notify_connected(conn);
   28374:	f7df bf40 	b.w	81f8 <notify_connected>

00028378 <bt_conn_disconnect>:
{
   28378:	b538      	push	{r3, r4, r5, lr}
	switch (conn->state) {
   2837a:	7a83      	ldrb	r3, [r0, #10]
   2837c:	3b02      	subs	r3, #2
{
   2837e:	4604      	mov	r4, r0
	switch (conn->state) {
   28380:	2b06      	cmp	r3, #6
   28382:	d805      	bhi.n	28390 <bt_conn_disconnect+0x18>
   28384:	e8df f003 	tbb	[pc, r3]
   28388:	04040408 	.word	0x04040408
   2838c:	0e0c      	.short	0x0e0c
   2838e:	0c          	.byte	0x0c
   2838f:	00          	.byte	0x00
   28390:	f06f 057f 	mvn.w	r5, #127	; 0x7f
}
   28394:	4628      	mov	r0, r5
   28396:	bd38      	pop	{r3, r4, r5, pc}
		conn->err = reason;
   28398:	7241      	strb	r1, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2839a:	2100      	movs	r1, #0
   2839c:	f7e0 f968 	bl	8670 <bt_conn_set_state>
		return 0;
   283a0:	2500      	movs	r5, #0
   283a2:	e7f7      	b.n	28394 <bt_conn_disconnect+0x1c>
	err = bt_hci_disconnect(conn->handle, reason);
   283a4:	8800      	ldrh	r0, [r0, #0]
   283a6:	f7ff fd39 	bl	27e1c <bt_hci_disconnect>
	if (err) {
   283aa:	4605      	mov	r5, r0
   283ac:	2800      	cmp	r0, #0
   283ae:	d1f1      	bne.n	28394 <bt_conn_disconnect+0x1c>
	if (conn->state == BT_CONN_CONNECTED) {
   283b0:	7aa3      	ldrb	r3, [r4, #10]
   283b2:	2b07      	cmp	r3, #7
   283b4:	d1ee      	bne.n	28394 <bt_conn_disconnect+0x1c>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT);
   283b6:	2108      	movs	r1, #8
   283b8:	4620      	mov	r0, r4
   283ba:	f7e0 f959 	bl	8670 <bt_conn_set_state>
   283be:	e7e9      	b.n	28394 <bt_conn_disconnect+0x1c>

000283c0 <bt_conn_get_security>:
}
   283c0:	2001      	movs	r0, #1
   283c2:	4770      	bx	lr

000283c4 <bt_conn_is_peer_addr_le>:
{
   283c4:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   283c6:	7a03      	ldrb	r3, [r0, #8]
   283c8:	428b      	cmp	r3, r1
{
   283ca:	4604      	mov	r4, r0
   283cc:	4615      	mov	r5, r2
	if (id != conn->id) {
   283ce:	d115      	bne.n	283fc <bt_conn_is_peer_addr_le+0x38>
	return memcmp(a, b, sizeof(*a));
   283d0:	f100 0188 	add.w	r1, r0, #136	; 0x88
   283d4:	2207      	movs	r2, #7
   283d6:	4628      	mov	r0, r5
   283d8:	f7ff fa39 	bl	2784e <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   283dc:	b180      	cbz	r0, 28400 <bt_conn_is_peer_addr_le+0x3c>
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   283de:	78e3      	ldrb	r3, [r4, #3]
   283e0:	2207      	movs	r2, #7
   283e2:	b943      	cbnz	r3, 283f6 <bt_conn_is_peer_addr_le+0x32>
   283e4:	f104 0196 	add.w	r1, r4, #150	; 0x96
   283e8:	4628      	mov	r0, r5
   283ea:	f7ff fa30 	bl	2784e <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   283ee:	fab0 f080 	clz	r0, r0
   283f2:	0940      	lsrs	r0, r0, #5
}
   283f4:	bd38      	pop	{r3, r4, r5, pc}
   283f6:	f104 018f 	add.w	r1, r4, #143	; 0x8f
   283fa:	e7f5      	b.n	283e8 <bt_conn_is_peer_addr_le+0x24>
		return false;
   283fc:	2000      	movs	r0, #0
   283fe:	e7f9      	b.n	283f4 <bt_conn_is_peer_addr_le+0x30>
		return true;
   28400:	2001      	movs	r0, #1
   28402:	e7f7      	b.n	283f4 <bt_conn_is_peer_addr_le+0x30>

00028404 <bt_conn_le_conn_update>:
{
   28404:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28406:	4607      	mov	r7, r0
   28408:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   2840a:	f242 0013 	movw	r0, #8211	; 0x2013
   2840e:	210e      	movs	r1, #14
   28410:	f7dd fea6 	bl	6160 <bt_hci_cmd_create>
	if (!buf) {
   28414:	4606      	mov	r6, r0
   28416:	b1d0      	cbz	r0, 2844e <bt_conn_le_conn_update+0x4a>
	return net_buf_simple_add(&buf->b, len);
   28418:	210e      	movs	r1, #14
   2841a:	3008      	adds	r0, #8
   2841c:	f003 fc8e 	bl	2bd3c <net_buf_simple_add>
	(void)memset(conn_update, 0, sizeof(*conn_update));
   28420:	220e      	movs	r2, #14
   28422:	4604      	mov	r4, r0
   28424:	2100      	movs	r1, #0
   28426:	f7ff fa2e 	bl	27886 <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   2842a:	883b      	ldrh	r3, [r7, #0]
   2842c:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   2842e:	882b      	ldrh	r3, [r5, #0]
   28430:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   28432:	886b      	ldrh	r3, [r5, #2]
   28434:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   28436:	88ab      	ldrh	r3, [r5, #4]
   28438:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   2843a:	88eb      	ldrh	r3, [r5, #6]
   2843c:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   2843e:	4631      	mov	r1, r6
   28440:	2200      	movs	r2, #0
}
   28442:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   28446:	f242 0013 	movw	r0, #8211	; 0x2013
   2844a:	f7dd bfe5 	b.w	6418 <bt_hci_cmd_send_sync>
}
   2844e:	f06f 0068 	mvn.w	r0, #104	; 0x68
   28452:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00028454 <l2cap_connected>:
}
   28454:	4770      	bx	lr

00028456 <l2cap_disconnected>:
	(void)k_work_cancel_delayable(&chan->rtx_work);
   28456:	3010      	adds	r0, #16
   28458:	f004 bcd5 	b.w	2ce06 <k_work_cancel_delayable>

0002845c <z_log_msg2_static_create.constprop.0>:
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   2845c:	2300      	movs	r3, #0
   2845e:	f7fd bc3b 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00028462 <bt_l2cap_chan_remove>:
	return list->head;
   28462:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   28464:	b530      	push	{r4, r5, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   28466:	b173      	cbz	r3, 28486 <bt_l2cap_chan_remove+0x24>
   28468:	3b08      	subs	r3, #8
   2846a:	2500      	movs	r5, #0
	return node->next;
   2846c:	461a      	mov	r2, r3
		if (chan == ch) {
   2846e:	4299      	cmp	r1, r3
   28470:	f852 4f08 	ldr.w	r4, [r2, #8]!
   28474:	d10d      	bne.n	28492 <bt_l2cap_chan_remove+0x30>
	return list->tail;
   28476:	6d41      	ldr	r1, [r0, #84]	; 0x54
Z_GENLIST_REMOVE(slist, snode)
   28478:	b935      	cbnz	r5, 28488 <bt_l2cap_chan_remove+0x26>
   2847a:	4291      	cmp	r1, r2
	list->head = node;
   2847c:	6504      	str	r4, [r0, #80]	; 0x50
Z_GENLIST_REMOVE(slist, snode)
   2847e:	d100      	bne.n	28482 <bt_l2cap_chan_remove+0x20>
	list->tail = node;
   28480:	6544      	str	r4, [r0, #84]	; 0x54
	parent->next = child;
   28482:	2200      	movs	r2, #0
   28484:	609a      	str	r2, [r3, #8]
}
   28486:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_REMOVE(slist, snode)
   28488:	4291      	cmp	r1, r2
	parent->next = child;
   2848a:	602c      	str	r4, [r5, #0]
	list->tail = node;
   2848c:	bf08      	it	eq
   2848e:	6545      	streq	r5, [r0, #84]	; 0x54
}
   28490:	e7f7      	b.n	28482 <bt_l2cap_chan_remove+0x20>
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   28492:	2c00      	cmp	r4, #0
   28494:	d0f7      	beq.n	28486 <bt_l2cap_chan_remove+0x24>
   28496:	f1a4 0308 	sub.w	r3, r4, #8
			sys_slist_remove(&conn->channels, prev, &chan->node);
   2849a:	4615      	mov	r5, r2
   2849c:	e7e6      	b.n	2846c <bt_l2cap_chan_remove+0xa>

0002849e <bt_l2cap_chan_del>:
{
   2849e:	b570      	push	{r4, r5, r6, lr}
	if (!chan->conn) {
   284a0:	e9d0 3500 	ldrd	r3, r5, [r0]
{
   284a4:	4604      	mov	r4, r0
	if (!chan->conn) {
   284a6:	b123      	cbz	r3, 284b2 <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
   284a8:	686b      	ldr	r3, [r5, #4]
   284aa:	b103      	cbz	r3, 284ae <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
   284ac:	4798      	blx	r3
	chan->conn = NULL;
   284ae:	2300      	movs	r3, #0
   284b0:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   284b2:	68e3      	ldr	r3, [r4, #12]
   284b4:	b10b      	cbz	r3, 284ba <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   284b6:	4620      	mov	r0, r4
   284b8:	4798      	blx	r3
	if (ops->released) {
   284ba:	69eb      	ldr	r3, [r5, #28]
   284bc:	b11b      	cbz	r3, 284c6 <bt_l2cap_chan_del+0x28>
		ops->released(chan);
   284be:	4620      	mov	r0, r4
}
   284c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ops->released(chan);
   284c4:	4718      	bx	r3
}
   284c6:	bd70      	pop	{r4, r5, r6, pc}

000284c8 <bt_l2cap_disconnected>:
	return list->head;
   284c8:	6d00      	ldr	r0, [r0, #80]	; 0x50
{
   284ca:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   284cc:	b160      	cbz	r0, 284e8 <bt_l2cap_disconnected+0x20>
	return node->next;
   284ce:	f850 4908 	ldr.w	r4, [r0], #-8
   284d2:	b104      	cbz	r4, 284d6 <bt_l2cap_disconnected+0xe>
   284d4:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   284d6:	f7ff ffe2 	bl	2849e <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   284da:	b12c      	cbz	r4, 284e8 <bt_l2cap_disconnected+0x20>
   284dc:	68a3      	ldr	r3, [r4, #8]
   284de:	b103      	cbz	r3, 284e2 <bt_l2cap_disconnected+0x1a>
   284e0:	3b08      	subs	r3, #8
{
   284e2:	4620      	mov	r0, r4
   284e4:	461c      	mov	r4, r3
   284e6:	e7f6      	b.n	284d6 <bt_l2cap_disconnected+0xe>
}
   284e8:	bd10      	pop	{r4, pc}

000284ea <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   284ea:	3104      	adds	r1, #4
   284ec:	f7e0 b9be 	b.w	886c <bt_conn_create_pdu_timeout>

000284f0 <bt_l2cap_send_cb>:
{
   284f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   284f4:	4614      	mov	r4, r2
   284f6:	4605      	mov	r5, r0
   284f8:	460f      	mov	r7, r1
	return net_buf_simple_push(&buf->b, len);
   284fa:	f102 0008 	add.w	r0, r2, #8
   284fe:	2104      	movs	r1, #4
   28500:	461e      	mov	r6, r3
   28502:	f8dd 8018 	ldr.w	r8, [sp, #24]
   28506:	f003 fc5c 	bl	2bdc2 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2850a:	89a2      	ldrh	r2, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   2850c:	8047      	strh	r7, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2850e:	3a04      	subs	r2, #4
   28510:	8002      	strh	r2, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   28512:	4643      	mov	r3, r8
   28514:	4632      	mov	r2, r6
   28516:	4621      	mov	r1, r4
   28518:	4628      	mov	r0, r5
}
   2851a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   2851e:	f7df bffb 	b.w	8518 <bt_conn_send_cb>

00028522 <bt_l2cap_le_lookup_tx_cid>:
	return list->head;
   28522:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   28524:	b138      	cbz	r0, 28536 <bt_l2cap_le_lookup_tx_cid+0x14>
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   28526:	f8b0 3078 	ldrh.w	r3, [r0, #120]	; 0x78
   2852a:	428b      	cmp	r3, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2852c:	f1a0 0008 	sub.w	r0, r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   28530:	d001      	beq.n	28536 <bt_l2cap_le_lookup_tx_cid+0x14>
	return node->next;
   28532:	6880      	ldr	r0, [r0, #8]
   28534:	e7f6      	b.n	28524 <bt_l2cap_le_lookup_tx_cid+0x2>
}
   28536:	4770      	bx	lr

00028538 <bt_l2cap_le_lookup_rx_cid>:
	return list->head;
   28538:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2853a:	b138      	cbz	r0, 2854c <bt_l2cap_le_lookup_rx_cid+0x14>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   2853c:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
   28540:	428b      	cmp	r3, r1
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   28542:	f1a0 0008 	sub.w	r0, r0, #8
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   28546:	d001      	beq.n	2854c <bt_l2cap_le_lookup_rx_cid+0x14>
	return node->next;
   28548:	6880      	ldr	r0, [r0, #8]
   2854a:	e7f6      	b.n	2853a <bt_l2cap_le_lookup_rx_cid+0x2>
}
   2854c:	4770      	bx	lr

0002854e <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   2854e:	4770      	bx	lr

00028550 <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
   28550:	4603      	mov	r3, r0
	return list->head;
   28552:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   28554:	b128      	cbz	r0, 28562 <sys_slist_get+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   28556:	6859      	ldr	r1, [r3, #4]
	return node->next;
   28558:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2855a:	601a      	str	r2, [r3, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2855c:	4288      	cmp	r0, r1
	list->tail = node;
   2855e:	bf08      	it	eq
   28560:	605a      	streq	r2, [r3, #4]
Z_GENLIST_GET(slist, snode)
   28562:	4770      	bx	lr

00028564 <net_buf_frags_len>:
 * @param buf Buffer to start off with.
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
   28564:	4603      	mov	r3, r0
	size_t bytes = 0;
   28566:	2000      	movs	r0, #0

	while (buf) {
   28568:	b903      	cbnz	r3, 2856c <net_buf_frags_len+0x8>
		bytes += buf->len;
		buf = buf->frags;
	}

	return bytes;
}
   2856a:	4770      	bx	lr
		bytes += buf->len;
   2856c:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   2856e:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   28570:	4410      	add	r0, r2
		buf = buf->frags;
   28572:	e7f9      	b.n	28568 <net_buf_frags_len+0x4>

00028574 <att_sent>:
	if (chan->ops->sent) {
   28574:	684b      	ldr	r3, [r1, #4]
   28576:	695b      	ldr	r3, [r3, #20]
{
   28578:	4608      	mov	r0, r1
	if (chan->ops->sent) {
   2857a:	b103      	cbz	r3, 2857e <att_sent+0xa>
		chan->ops->sent(chan);
   2857c:	4718      	bx	r3
}
   2857e:	4770      	bx	lr

00028580 <attr_read_type_cb>:
{
   28580:	b510      	push	{r4, lr}
	if (!data->rsp->len) {
   28582:	68d4      	ldr	r4, [r2, #12]
   28584:	7823      	ldrb	r3, [r4, #0]
   28586:	3102      	adds	r1, #2
   28588:	b913      	cbnz	r3, 28590 <attr_read_type_cb+0x10>
		data->rsp->len = read + sizeof(*data->item);
   2858a:	7021      	strb	r1, [r4, #0]
	return true;
   2858c:	2001      	movs	r0, #1
   2858e:	e006      	b.n	2859e <attr_read_type_cb+0x1e>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   28590:	428b      	cmp	r3, r1
   28592:	d0fb      	beq.n	2858c <attr_read_type_cb+0xc>
		frag->len -= sizeof(*data->item);
   28594:	8983      	ldrh	r3, [r0, #12]
   28596:	3b02      	subs	r3, #2
   28598:	8183      	strh	r3, [r0, #12]
		data->item = NULL;
   2859a:	2000      	movs	r0, #0
   2859c:	6110      	str	r0, [r2, #16]
}
   2859e:	bd10      	pop	{r4, pc}

000285a0 <att_prepare_write_req>:
}
   285a0:	2006      	movs	r0, #6
   285a2:	4770      	bx	lr

000285a4 <att_op_get_type>:
	switch (op) {
   285a4:	281e      	cmp	r0, #30
   285a6:	d816      	bhi.n	285d6 <att_op_get_type+0x32>
   285a8:	b308      	cbz	r0, 285ee <att_op_get_type+0x4a>
   285aa:	1e43      	subs	r3, r0, #1
   285ac:	2b1d      	cmp	r3, #29
   285ae:	d81e      	bhi.n	285ee <att_op_get_type+0x4a>
   285b0:	e8df f003 	tbb	[pc, r3]
   285b4:	23172317 	.word	0x23172317
   285b8:	23172317 	.word	0x23172317
   285bc:	23172317 	.word	0x23172317
   285c0:	23172317 	.word	0x23172317
   285c4:	1d172317 	.word	0x1d172317
   285c8:	2317231d 	.word	0x2317231d
   285cc:	1d191d17 	.word	0x1d191d17
   285d0:	0f1b      	.short	0x0f1b
   285d2:	2004      	movs	r0, #4
   285d4:	4770      	bx	lr
   285d6:	f000 037f 	and.w	r3, r0, #127	; 0x7f
   285da:	2b52      	cmp	r3, #82	; 0x52
   285dc:	d107      	bne.n	285ee <att_op_get_type+0x4a>
		return ATT_COMMAND;
   285de:	2000      	movs	r0, #0
}
   285e0:	4770      	bx	lr
		return ATT_RESPONSE;
   285e2:	2002      	movs	r0, #2
   285e4:	4770      	bx	lr
		return ATT_NOTIFICATION;
   285e6:	2003      	movs	r0, #3
   285e8:	4770      	bx	lr
		return ATT_INDICATION;
   285ea:	2005      	movs	r0, #5
   285ec:	4770      	bx	lr
		return ATT_COMMAND;
   285ee:	f010 0f40 	tst.w	r0, #64	; 0x40
   285f2:	bf0c      	ite	eq
   285f4:	2006      	moveq	r0, #6
   285f6:	2000      	movne	r0, #0
   285f8:	4770      	bx	lr
		return ATT_REQUEST;
   285fa:	2001      	movs	r0, #1
   285fc:	4770      	bx	lr

000285fe <bt_gatt_foreach_attr>:
 *  @param user_data Data to pass to the callback.
 */
static inline void bt_gatt_foreach_attr(uint16_t start_handle, uint16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
   285fe:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   28600:	e9cd 2301 	strd	r2, r3, [sp, #4]
   28604:	2300      	movs	r3, #0
   28606:	9300      	str	r3, [sp, #0]
   28608:	461a      	mov	r2, r3
   2860a:	f7e2 fa57 	bl	aabc <bt_gatt_foreach_attr_type>
				  user_data);
}
   2860e:	b005      	add	sp, #20
   28610:	f85d fb04 	ldr.w	pc, [sp], #4

00028614 <find_info_cb>:
{
   28614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!data->rsp) {
   28616:	6893      	ldr	r3, [r2, #8]
	struct bt_att_chan *chan = data->chan;
   28618:	6817      	ldr	r7, [r2, #0]
{
   2861a:	4605      	mov	r5, r0
   2861c:	460e      	mov	r6, r1
   2861e:	4614      	mov	r4, r2
	if (!data->rsp) {
   28620:	b963      	cbnz	r3, 2863c <find_info_cb+0x28>
	return net_buf_simple_add(&buf->b, len);
   28622:	6850      	ldr	r0, [r2, #4]
   28624:	2101      	movs	r1, #1
   28626:	3008      	adds	r0, #8
   28628:	f003 fb88 	bl	2bd3c <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2862c:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2862e:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   28630:	781b      	ldrb	r3, [r3, #0]
   28632:	2b00      	cmp	r3, #0
   28634:	bf0c      	ite	eq
   28636:	2301      	moveq	r3, #1
   28638:	2302      	movne	r3, #2
   2863a:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   2863c:	68a3      	ldr	r3, [r4, #8]
   2863e:	781b      	ldrb	r3, [r3, #0]
   28640:	2b01      	cmp	r3, #1
   28642:	d003      	beq.n	2864c <find_info_cb+0x38>
   28644:	2b02      	cmp	r3, #2
   28646:	d019      	beq.n	2867c <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   28648:	2000      	movs	r0, #0
   2864a:	e016      	b.n	2867a <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   2864c:	682b      	ldr	r3, [r5, #0]
   2864e:	781b      	ldrb	r3, [r3, #0]
   28650:	2b00      	cmp	r3, #0
   28652:	d1f9      	bne.n	28648 <find_info_cb+0x34>
   28654:	6860      	ldr	r0, [r4, #4]
   28656:	2104      	movs	r1, #4
   28658:	3008      	adds	r0, #8
   2865a:	f003 fb6f 	bl	2bd3c <net_buf_simple_add>
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   2865e:	682b      	ldr	r3, [r5, #0]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   28660:	60e0      	str	r0, [r4, #12]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   28662:	885b      	ldrh	r3, [r3, #2]
   28664:	8043      	strh	r3, [r0, #2]
		if (chan->chan.tx.mtu - data->buf->len >
   28666:	6863      	ldr	r3, [r4, #4]
		data->info16->handle = sys_cpu_to_le16(handle);
   28668:	8006      	strh	r6, [r0, #0]
		if (chan->chan.tx.mtu - data->buf->len >
   2866a:	899b      	ldrh	r3, [r3, #12]
   2866c:	f8b7 008a 	ldrh.w	r0, [r7, #138]	; 0x8a
   28670:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   28672:	2804      	cmp	r0, #4
   28674:	bf94      	ite	ls
   28676:	2000      	movls	r0, #0
   28678:	2001      	movhi	r0, #1
}
   2867a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   2867c:	682b      	ldr	r3, [r5, #0]
   2867e:	781b      	ldrb	r3, [r3, #0]
   28680:	2b02      	cmp	r3, #2
   28682:	d1e1      	bne.n	28648 <find_info_cb+0x34>
   28684:	6860      	ldr	r0, [r4, #4]
   28686:	2112      	movs	r1, #18
   28688:	3008      	adds	r0, #8
   2868a:	f003 fb57 	bl	2bd3c <net_buf_simple_add>
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   2868e:	6829      	ldr	r1, [r5, #0]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   28690:	60e0      	str	r0, [r4, #12]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   28692:	2210      	movs	r2, #16
		data->info128->handle = sys_cpu_to_le16(handle);
   28694:	f820 6b02 	strh.w	r6, [r0], #2
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   28698:	3101      	adds	r1, #1
   2869a:	f7ff f8e9 	bl	27870 <memcpy>
		if (chan->chan.tx.mtu - data->buf->len >
   2869e:	6863      	ldr	r3, [r4, #4]
   286a0:	f8b7 008a 	ldrh.w	r0, [r7, #138]	; 0x8a
   286a4:	899b      	ldrh	r3, [r3, #12]
   286a6:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   286a8:	2812      	cmp	r0, #18
   286aa:	e7e3      	b.n	28674 <find_info_cb+0x60>

000286ac <att_chan_mtu_updated>:
{
   286ac:	b470      	push	{r4, r5, r6}
	struct bt_att *att = updated_chan->att;
   286ae:	6806      	ldr	r6, [r0, #0]
	return list->head;
   286b0:	6a73      	ldr	r3, [r6, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   286b2:	b1e3      	cbz	r3, 286ee <att_chan_mtu_updated+0x42>
	return node->next;
   286b4:	681a      	ldr	r2, [r3, #0]
   286b6:	f5a3 75a2 	sub.w	r5, r3, #324	; 0x144
   286ba:	b10a      	cbz	r2, 286c0 <att_chan_mtu_updated+0x14>
   286bc:	f5a2 72a2 	sub.w	r2, r2, #324	; 0x144
{
   286c0:	2300      	movs	r3, #0
   286c2:	4619      	mov	r1, r3
		if (chan == updated_chan) {
   286c4:	42a8      	cmp	r0, r5
   286c6:	d009      	beq.n	286dc <att_chan_mtu_updated+0x30>
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
   286c8:	f8b5 408a 	ldrh.w	r4, [r5, #138]	; 0x8a
   286cc:	42a1      	cmp	r1, r4
   286ce:	bf38      	it	cc
   286d0:	4621      	movcc	r1, r4
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
   286d2:	f8b5 407a 	ldrh.w	r4, [r5, #122]	; 0x7a
   286d6:	42a3      	cmp	r3, r4
   286d8:	bf38      	it	cc
   286da:	4623      	movcc	r3, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   286dc:	b142      	cbz	r2, 286f0 <att_chan_mtu_updated+0x44>
   286de:	f8d2 4144 	ldr.w	r4, [r2, #324]	; 0x144
   286e2:	b10c      	cbz	r4, 286e8 <att_chan_mtu_updated+0x3c>
   286e4:	f5a4 74a2 	sub.w	r4, r4, #324	; 0x144
{
   286e8:	4615      	mov	r5, r2
   286ea:	4622      	mov	r2, r4
   286ec:	e7ea      	b.n	286c4 <att_chan_mtu_updated+0x18>
   286ee:	4619      	mov	r1, r3
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   286f0:	f8b0 408a 	ldrh.w	r4, [r0, #138]	; 0x8a
	    (updated_chan->chan.rx.mtu > max_rx)) {
   286f4:	f8b0 207a 	ldrh.w	r2, [r0, #122]	; 0x7a
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   286f8:	428c      	cmp	r4, r1
   286fa:	d801      	bhi.n	28700 <att_chan_mtu_updated+0x54>
   286fc:	429a      	cmp	r2, r3
   286fe:	d909      	bls.n	28714 <att_chan_mtu_updated+0x68>
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   28700:	429a      	cmp	r2, r3
   28702:	bf38      	it	cc
   28704:	461a      	movcc	r2, r3
   28706:	42a1      	cmp	r1, r4
   28708:	6830      	ldr	r0, [r6, #0]
   2870a:	bf38      	it	cc
   2870c:	4621      	movcc	r1, r4
}
   2870e:	bc70      	pop	{r4, r5, r6}
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   28710:	f7e2 bf48 	b.w	b5a4 <bt_gatt_att_max_mtu_changed>
}
   28714:	bc70      	pop	{r4, r5, r6}
   28716:	4770      	bx	lr

00028718 <attr_read_group_cb>:
	if (!data->rsp->len) {
   28718:	68d0      	ldr	r0, [r2, #12]
   2871a:	7803      	ldrb	r3, [r0, #0]
   2871c:	3104      	adds	r1, #4
   2871e:	b913      	cbnz	r3, 28726 <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
   28720:	7001      	strb	r1, [r0, #0]
	return true;
   28722:	2001      	movs	r0, #1
}
   28724:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   28726:	428b      	cmp	r3, r1
   28728:	d0fb      	beq.n	28722 <attr_read_group_cb+0xa>
		data->buf->len -= sizeof(*data->group);
   2872a:	6891      	ldr	r1, [r2, #8]
   2872c:	898b      	ldrh	r3, [r1, #12]
		data->group = NULL;
   2872e:	2000      	movs	r0, #0
		data->buf->len -= sizeof(*data->group);
   28730:	3b04      	subs	r3, #4
   28732:	818b      	strh	r3, [r1, #12]
		data->group = NULL;
   28734:	6110      	str	r0, [r2, #16]
		return false;
   28736:	4770      	bx	lr

00028738 <chan_req_sent>:
	if (chan->req) {
   28738:	f8d0 30f4 	ldr.w	r3, [r0, #244]	; 0xf4
   2873c:	b133      	cbz	r3, 2874c <chan_req_sent+0x14>
		k_work_reschedule(&chan->timeout_work, BT_ATT_TIMEOUT);
   2873e:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   28742:	2300      	movs	r3, #0
   28744:	f500 7088 	add.w	r0, r0, #272	; 0x110
   28748:	f7fb be0c 	b.w	24364 <k_work_reschedule>
}
   2874c:	4770      	bx	lr

0002874e <write_cb>:
{
   2874e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   28750:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
   28752:	4601      	mov	r1, r0
{
   28754:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   28756:	222a      	movs	r2, #42	; 0x2a
   28758:	6820      	ldr	r0, [r4, #0]
   2875a:	f000 fd57 	bl	2920c <bt_gatt_check_perm>
   2875e:	4605      	mov	r5, r0
   28760:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   28762:	bb20      	cbnz	r0, 287ae <write_cb+0x60>
	if (!data->req) {
   28764:	7a23      	ldrb	r3, [r4, #8]
   28766:	b1ab      	cbz	r3, 28794 <write_cb+0x46>
		flags |= BT_GATT_WRITE_FLAG_EXECUTE;
   28768:	2b18      	cmp	r3, #24
   2876a:	bf14      	ite	ne
   2876c:	2300      	movne	r3, #0
   2876e:	2304      	moveq	r3, #4
	write = attr->write(data->conn, attr, data->value, data->len,
   28770:	9301      	str	r3, [sp, #4]
   28772:	8a63      	ldrh	r3, [r4, #18]
   28774:	9300      	str	r3, [sp, #0]
   28776:	68b7      	ldr	r7, [r6, #8]
   28778:	8a23      	ldrh	r3, [r4, #16]
   2877a:	68e2      	ldr	r2, [r4, #12]
   2877c:	6820      	ldr	r0, [r4, #0]
   2877e:	4631      	mov	r1, r6
   28780:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   28782:	1e03      	subs	r3, r0, #0
   28784:	db08      	blt.n	28798 <write_cb+0x4a>
   28786:	8a22      	ldrh	r2, [r4, #16]
   28788:	4293      	cmp	r3, r2
   2878a:	d10e      	bne.n	287aa <write_cb+0x5c>
	data->err = 0U;
   2878c:	2300      	movs	r3, #0
   2878e:	7523      	strb	r3, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   28790:	2501      	movs	r5, #1
   28792:	e007      	b.n	287a4 <write_cb+0x56>
		flags |= BT_GATT_WRITE_FLAG_CMD;
   28794:	2302      	movs	r3, #2
   28796:	e7eb      	b.n	28770 <write_cb+0x22>
	if (err < 0 && err >= -0xff) {
   28798:	f113 0fff 	cmn.w	r3, #255	; 0xff
   2879c:	d305      	bcc.n	287aa <write_cb+0x5c>
		return -err;
   2879e:	425b      	negs	r3, r3
   287a0:	b2db      	uxtb	r3, r3
		data->err = err_to_att(write);
   287a2:	7523      	strb	r3, [r4, #20]
}
   287a4:	4628      	mov	r0, r5
   287a6:	b003      	add	sp, #12
   287a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   287aa:	230e      	movs	r3, #14
   287ac:	e7f9      	b.n	287a2 <write_cb+0x54>
		return BT_GATT_ITER_STOP;
   287ae:	2500      	movs	r5, #0
   287b0:	e7f8      	b.n	287a4 <write_cb+0x56>

000287b2 <z_log_msg2_static_create.constprop.0>:
   287b2:	2300      	movs	r3, #0
   287b4:	f7fd ba90 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

000287b8 <att_chan_read>:
{
   287b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   287bc:	4680      	mov	r8, r0
   287be:	b085      	sub	sp, #20
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   287c0:	4610      	mov	r0, r2
{
   287c2:	4699      	mov	r9, r3
   287c4:	4616      	mov	r6, r2
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   287c6:	f7ff fecd 	bl	28564 <net_buf_frags_len>
   287ca:	f8b8 308a 	ldrh.w	r3, [r8, #138]	; 0x8a
   287ce:	4283      	cmp	r3, r0
{
   287d0:	468b      	mov	fp, r1
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   287d2:	d97a      	bls.n	288ca <att_chan_read+0x112>
	struct bt_conn *conn = chan->chan.chan.conn;
   287d4:	f8d8 3008 	ldr.w	r3, [r8, #8]
   287d8:	9303      	str	r3, [sp, #12]
	frag = net_buf_frag_last(buf);
   287da:	4630      	mov	r0, r6
   287dc:	f003 fa7a 	bl	2bcd4 <net_buf_frag_last>
	size_t len, total = 0;
   287e0:	f04f 0a00 	mov.w	sl, #0
	frag = net_buf_frag_last(buf);
   287e4:	4605      	mov	r5, r0
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   287e6:	4630      	mov	r0, r6
   287e8:	f7ff febc 	bl	28564 <net_buf_frags_len>
   287ec:	f8b8 408a 	ldrh.w	r4, [r8, #138]	; 0x8a
	return net_buf_simple_tailroom(&buf->b);
   287f0:	f105 0708 	add.w	r7, r5, #8
   287f4:	1a24      	subs	r4, r4, r0
   287f6:	4638      	mov	r0, r7
   287f8:	f003 fb47 	bl	2be8a <net_buf_simple_tailroom>
   287fc:	4284      	cmp	r4, r0
   287fe:	d211      	bcs.n	28824 <att_chan_read+0x6c>
   28800:	4630      	mov	r0, r6
   28802:	f7ff feaf 	bl	28564 <net_buf_frags_len>
   28806:	f8b8 408a 	ldrh.w	r4, [r8, #138]	; 0x8a
   2880a:	1a24      	subs	r4, r4, r0
		if (!len) {
   2880c:	bb34      	cbnz	r4, 2885c <att_chan_read+0xa4>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   2880e:	79b0      	ldrb	r0, [r6, #6]
   28810:	f7f7 ff7c 	bl	2070c <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   28814:	2200      	movs	r2, #0
   28816:	2300      	movs	r3, #0
   28818:	f003 fa05 	bl	2bc26 <net_buf_alloc_fixed>
			if (!frag) {
   2881c:	4605      	mov	r5, r0
   2881e:	b930      	cbnz	r0, 2882e <att_chan_read+0x76>
	return total;
   28820:	4657      	mov	r7, sl
   28822:	e02c      	b.n	2887e <att_chan_read+0xc6>
	return net_buf_simple_tailroom(&buf->b);
   28824:	4638      	mov	r0, r7
   28826:	f003 fb30 	bl	2be8a <net_buf_simple_tailroom>
   2882a:	4604      	mov	r4, r0
   2882c:	e7ee      	b.n	2880c <att_chan_read+0x54>
			net_buf_frag_add(buf, frag);
   2882e:	4601      	mov	r1, r0
   28830:	4630      	mov	r0, r6
   28832:	f003 fa60 	bl	2bcf6 <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   28836:	4630      	mov	r0, r6
   28838:	f7ff fe94 	bl	28564 <net_buf_frags_len>
   2883c:	f8b8 408a 	ldrh.w	r4, [r8, #138]	; 0x8a
   28840:	f105 0708 	add.w	r7, r5, #8
   28844:	1a24      	subs	r4, r4, r0
   28846:	4638      	mov	r0, r7
   28848:	f003 fb1f 	bl	2be8a <net_buf_simple_tailroom>
   2884c:	4284      	cmp	r4, r0
   2884e:	d21a      	bcs.n	28886 <att_chan_read+0xce>
   28850:	4630      	mov	r0, r6
   28852:	f7ff fe87 	bl	28564 <net_buf_frags_len>
   28856:	f8b8 408a 	ldrh.w	r4, [r8, #138]	; 0x8a
   2885a:	1a24      	subs	r4, r4, r0
		read = attr->read(conn, attr, frag->data + frag->len, len,
   2885c:	68a9      	ldr	r1, [r5, #8]
   2885e:	89aa      	ldrh	r2, [r5, #12]
   28860:	f8db 7004 	ldr.w	r7, [fp, #4]
   28864:	9803      	ldr	r0, [sp, #12]
   28866:	f8cd 9000 	str.w	r9, [sp]
   2886a:	440a      	add	r2, r1
   2886c:	b2a3      	uxth	r3, r4
   2886e:	4659      	mov	r1, fp
   28870:	47b8      	blx	r7
		if (read < 0) {
   28872:	1e07      	subs	r7, r0, #0
   28874:	da0c      	bge.n	28890 <att_chan_read+0xd8>
				return total;
   28876:	f1ba 0f00 	cmp.w	sl, #0
   2887a:	bf18      	it	ne
   2887c:	4657      	movne	r7, sl
}
   2887e:	4638      	mov	r0, r7
   28880:	b005      	add	sp, #20
   28882:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   28886:	4638      	mov	r0, r7
   28888:	f003 faff 	bl	2be8a <net_buf_simple_tailroom>
   2888c:	4604      	mov	r4, r0
   2888e:	e7e5      	b.n	2885c <att_chan_read+0xa4>
		if (cb && !cb(frag, read, user_data)) {
   28890:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   28892:	b993      	cbnz	r3, 288ba <att_chan_read+0x102>
	return net_buf_simple_add(&buf->b, len);
   28894:	4639      	mov	r1, r7
   28896:	f105 0008 	add.w	r0, r5, #8
   2889a:	f003 fa4f 	bl	2bd3c <net_buf_simple_add>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   2889e:	4630      	mov	r0, r6
   288a0:	f7ff fe60 	bl	28564 <net_buf_frags_len>
   288a4:	f8b8 308a 	ldrh.w	r3, [r8, #138]	; 0x8a
		offset += read;
   288a8:	44b9      	add	r9, r7
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   288aa:	4283      	cmp	r3, r0
		total += read;
   288ac:	44ba      	add	sl, r7
		offset += read;
   288ae:	fa1f f989 	uxth.w	r9, r9
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   288b2:	d9b5      	bls.n	28820 <att_chan_read+0x68>
   288b4:	42a7      	cmp	r7, r4
   288b6:	d096      	beq.n	287e6 <att_chan_read+0x2e>
   288b8:	e7b2      	b.n	28820 <att_chan_read+0x68>
		if (cb && !cb(frag, read, user_data)) {
   288ba:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   288bc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   288be:	4639      	mov	r1, r7
   288c0:	4628      	mov	r0, r5
   288c2:	4798      	blx	r3
   288c4:	2800      	cmp	r0, #0
   288c6:	d1e5      	bne.n	28894 <att_chan_read+0xdc>
   288c8:	e7aa      	b.n	28820 <att_chan_read+0x68>
		return 0;
   288ca:	2700      	movs	r7, #0
   288cc:	e7d7      	b.n	2887e <att_chan_read+0xc6>

000288ce <chan_req_send>:
{
   288ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   288d0:	688f      	ldr	r7, [r1, #8]
{
   288d2:	4604      	mov	r4, r0
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   288d4:	4638      	mov	r0, r7
   288d6:	f7ff fe45 	bl	28564 <net_buf_frags_len>
   288da:	f8b4 308a 	ldrh.w	r3, [r4, #138]	; 0x8a
   288de:	4283      	cmp	r3, r0
{
   288e0:	460d      	mov	r5, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   288e2:	d30d      	bcc.n	28900 <chan_req_send+0x32>
	req->buf = NULL;
   288e4:	2600      	movs	r6, #0
	chan->req = req;
   288e6:	f8c4 10f4 	str.w	r1, [r4, #244]	; 0xf4
	err = chan_send(chan, buf, NULL);
   288ea:	4632      	mov	r2, r6
	req->buf = NULL;
   288ec:	608e      	str	r6, [r1, #8]
	err = chan_send(chan, buf, NULL);
   288ee:	4620      	mov	r0, r4
   288f0:	4639      	mov	r1, r7
   288f2:	f7e0 fddd 	bl	94b0 <chan_send>
	if (err) {
   288f6:	b110      	cbz	r0, 288fe <chan_req_send+0x30>
		req->buf = buf;
   288f8:	60af      	str	r7, [r5, #8]
		chan->req = NULL;
   288fa:	f8c4 60f4 	str.w	r6, [r4, #244]	; 0xf4
}
   288fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EMSGSIZE;
   28900:	f06f 0079 	mvn.w	r0, #121	; 0x79
   28904:	e7fb      	b.n	288fe <chan_req_send+0x30>

00028906 <process_queue>:
{
   28906:	b570      	push	{r4, r5, r6, lr}
	buf = net_buf_get(queue, K_NO_WAIT);
   28908:	2200      	movs	r2, #0
{
   2890a:	4604      	mov	r4, r0
	buf = net_buf_get(queue, K_NO_WAIT);
   2890c:	2300      	movs	r3, #0
   2890e:	4608      	mov	r0, r1
{
   28910:	460e      	mov	r6, r1
	buf = net_buf_get(queue, K_NO_WAIT);
   28912:	f003 f98d 	bl	2bc30 <net_buf_get>
	if (buf) {
   28916:	4605      	mov	r5, r0
   28918:	b160      	cbz	r0, 28934 <process_queue+0x2e>
		err = chan_send(chan, buf, NULL);
   2891a:	4601      	mov	r1, r0
   2891c:	2200      	movs	r2, #0
   2891e:	4620      	mov	r0, r4
   28920:	f7e0 fdc6 	bl	94b0 <chan_send>
		if (err) {
   28924:	4604      	mov	r4, r0
   28926:	b118      	cbz	r0, 28930 <process_queue+0x2a>
			k_queue_prepend(&queue->_queue, buf);
   28928:	4629      	mov	r1, r5
   2892a:	4630      	mov	r0, r6
   2892c:	f004 f961 	bl	2cbf2 <k_queue_prepend>
}
   28930:	4620      	mov	r0, r4
   28932:	bd70      	pop	{r4, r5, r6, pc}
	return -ENOENT;
   28934:	f06f 0401 	mvn.w	r4, #1
   28938:	e7fa      	b.n	28930 <process_queue+0x2a>

0002893a <sys_slist_find_and_remove.isra.0>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2893a:	b510      	push	{r4, lr}
	return list->head;
   2893c:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2893e:	2200      	movs	r2, #0
   28940:	b153      	cbz	r3, 28958 <sys_slist_find_and_remove.isra.0+0x1e>
   28942:	428b      	cmp	r3, r1
   28944:	d10e      	bne.n	28964 <sys_slist_find_and_remove.isra.0+0x2a>
	return node->next;
   28946:	680b      	ldr	r3, [r1, #0]
	return list->tail;
   28948:	6844      	ldr	r4, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
   2894a:	b932      	cbnz	r2, 2895a <sys_slist_find_and_remove.isra.0+0x20>
   2894c:	42a1      	cmp	r1, r4
	list->head = node;
   2894e:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   28950:	d100      	bne.n	28954 <sys_slist_find_and_remove.isra.0+0x1a>
	list->tail = node;
   28952:	6043      	str	r3, [r0, #4]
	parent->next = child;
   28954:	2300      	movs	r3, #0
   28956:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   28958:	bd10      	pop	{r4, pc}
Z_GENLIST_REMOVE(slist, snode)
   2895a:	42a1      	cmp	r1, r4
	parent->next = child;
   2895c:	6013      	str	r3, [r2, #0]
	list->tail = node;
   2895e:	bf08      	it	eq
   28960:	6042      	streq	r2, [r0, #4]
}
   28962:	e7f7      	b.n	28954 <sys_slist_find_and_remove.isra.0+0x1a>
	return node->next;
   28964:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   28966:	681b      	ldr	r3, [r3, #0]
   28968:	e7ea      	b.n	28940 <sys_slist_find_and_remove.isra.0+0x6>

0002896a <att_exec_write_req>:
   2896a:	2006      	movs	r0, #6
   2896c:	4770      	bx	lr

0002896e <chan_rsp_sent>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2896e:	30f0      	adds	r0, #240	; 0xf0
   28970:	f3bf 8f5b 	dmb	ish
   28974:	e850 3f00 	ldrex	r3, [r0]
   28978:	f023 0301 	bic.w	r3, r3, #1
   2897c:	e840 3200 	strex	r2, r3, [r0]
   28980:	2a00      	cmp	r2, #0
   28982:	d1f7      	bne.n	28974 <chan_rsp_sent+0x6>
   28984:	f3bf 8f5b 	dmb	ish
}
   28988:	4770      	bx	lr

0002898a <chan_cfm_sent>:
   2898a:	30f0      	adds	r0, #240	; 0xf0
   2898c:	f3bf 8f5b 	dmb	ish
   28990:	e850 3f00 	ldrex	r3, [r0]
   28994:	f023 0302 	bic.w	r3, r3, #2
   28998:	e840 3200 	strex	r2, r3, [r0]
   2899c:	2a00      	cmp	r2, #0
   2899e:	d1f7      	bne.n	28990 <chan_cfm_sent+0x6>
   289a0:	f3bf 8f5b 	dmb	ish
}
   289a4:	4770      	bx	lr

000289a6 <read_cb>:
{
   289a6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_att_chan *chan = data->chan;
   289aa:	f8d2 8000 	ldr.w	r8, [r2]
{
   289ae:	4606      	mov	r6, r0
	data->err = 0x00;
   289b0:	2700      	movs	r7, #0
	struct bt_conn *conn = chan->chan.chan.conn;
   289b2:	f8d8 0008 	ldr.w	r0, [r8, #8]
	data->err = 0x00;
   289b6:	7317      	strb	r7, [r2, #12]
{
   289b8:	4615      	mov	r5, r2
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   289ba:	4631      	mov	r1, r6
   289bc:	2215      	movs	r2, #21
   289be:	f000 fc25 	bl	2920c <bt_gatt_check_perm>
   289c2:	4604      	mov	r4, r0
   289c4:	7328      	strb	r0, [r5, #12]
	if (data->err) {
   289c6:	b9a0      	cbnz	r0, 289f2 <read_cb+0x4c>
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   289c8:	e9cd 0000 	strd	r0, r0, [sp]
   289cc:	88ab      	ldrh	r3, [r5, #4]
   289ce:	68aa      	ldr	r2, [r5, #8]
   289d0:	4631      	mov	r1, r6
   289d2:	4640      	mov	r0, r8
   289d4:	f7ff fef0 	bl	287b8 <att_chan_read>
	if (ret < 0) {
   289d8:	1e03      	subs	r3, r0, #0
   289da:	da0c      	bge.n	289f6 <read_cb+0x50>
	if (err < 0 && err >= -0xff) {
   289dc:	f113 0fff 	cmn.w	r3, #255	; 0xff
		return -err;
   289e0:	bf26      	itte	cs
   289e2:	425b      	negcs	r3, r3
   289e4:	b2db      	uxtbcs	r3, r3
	return BT_ATT_ERR_UNLIKELY;
   289e6:	230e      	movcc	r3, #14
		data->err = err_to_att(ret);
   289e8:	732b      	strb	r3, [r5, #12]
}
   289ea:	4620      	mov	r0, r4
   289ec:	b002      	add	sp, #8
   289ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ITER_STOP;
   289f2:	463c      	mov	r4, r7
   289f4:	e7f9      	b.n	289ea <read_cb+0x44>
	return BT_GATT_ITER_CONTINUE;
   289f6:	2401      	movs	r4, #1
   289f8:	e7f7      	b.n	289ea <read_cb+0x44>

000289fa <bt_att_sent>:
{
   289fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (chan->sent) {
   289fc:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
	struct bt_att *att = chan->att;
   28a00:	f850 4c08 	ldr.w	r4, [r0, #-8]
{
   28a04:	4605      	mov	r5, r0
	struct bt_att_chan *chan = ATT_CHAN(ch);
   28a06:	f1a0 0708 	sub.w	r7, r0, #8
	if (chan->sent) {
   28a0a:	b10b      	cbz	r3, 28a10 <bt_att_sent+0x16>
		chan->sent(chan);
   28a0c:	4638      	mov	r0, r7
   28a0e:	4798      	blx	r3
   28a10:	f3bf 8f5b 	dmb	ish
   28a14:	f105 03e8 	add.w	r3, r5, #232	; 0xe8
   28a18:	e853 2f00 	ldrex	r2, [r3]
   28a1c:	f022 0210 	bic.w	r2, r2, #16
   28a20:	e843 2100 	strex	r1, r2, [r3]
   28a24:	2900      	cmp	r1, #0
   28a26:	d1f7      	bne.n	28a18 <bt_att_sent+0x1e>
   28a28:	f3bf 8f5b 	dmb	ish
	if (!att) {
   28a2c:	b30c      	cbz	r4, 28a72 <bt_att_sent+0x78>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   28a2e:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
   28a32:	b98b      	cbnz	r3, 28a58 <bt_att_sent+0x5e>
   28a34:	6863      	ldr	r3, [r4, #4]
   28a36:	b17b      	cbz	r3, 28a58 <bt_att_sent+0x5e>
		sys_snode_t *node = sys_slist_get(&att->reqs);
   28a38:	1d20      	adds	r0, r4, #4
   28a3a:	f7ff fd89 	bl	28550 <sys_slist_get>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   28a3e:	4601      	mov	r1, r0
		sys_snode_t *node = sys_slist_get(&att->reqs);
   28a40:	4606      	mov	r6, r0
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   28a42:	4638      	mov	r0, r7
   28a44:	f7ff ff43 	bl	288ce <chan_req_send>
   28a48:	2800      	cmp	r0, #0
   28a4a:	da12      	bge.n	28a72 <bt_att_sent+0x78>
	parent->next = child;
   28a4c:	6863      	ldr	r3, [r4, #4]
   28a4e:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
   28a50:	68a3      	ldr	r3, [r4, #8]
	list->head = node;
   28a52:	6066      	str	r6, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
   28a54:	b903      	cbnz	r3, 28a58 <bt_att_sent+0x5e>
	list->tail = node;
   28a56:	60a6      	str	r6, [r4, #8]
	err = process_queue(chan, &chan->tx_queue);
   28a58:	f105 01f0 	add.w	r1, r5, #240	; 0xf0
   28a5c:	4638      	mov	r0, r7
   28a5e:	f7ff ff52 	bl	28906 <process_queue>
	if (!err) {
   28a62:	b130      	cbz	r0, 28a72 <bt_att_sent+0x78>
	(void)process_queue(chan, &att->tx_queue);
   28a64:	f104 010c 	add.w	r1, r4, #12
   28a68:	4638      	mov	r0, r7
}
   28a6a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	(void)process_queue(chan, &att->tx_queue);
   28a6e:	f7ff bf4a 	b.w	28906 <process_queue>
}
   28a72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00028a74 <att_req_send_process>:
{
   28a74:	b570      	push	{r4, r5, r6, lr}
   28a76:	4604      	mov	r4, r0
	node = sys_slist_get(&att->reqs);
   28a78:	3004      	adds	r0, #4
   28a7a:	f7ff fd69 	bl	28550 <sys_slist_get>
	if (!node) {
   28a7e:	4605      	mov	r5, r0
   28a80:	b1b8      	cbz	r0, 28ab2 <att_req_send_process+0x3e>
	return list->head;
   28a82:	6a63      	ldr	r3, [r4, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28a84:	b14b      	cbz	r3, 28a9a <att_req_send_process+0x26>
	return node->next;
   28a86:	681e      	ldr	r6, [r3, #0]
   28a88:	f5a3 70a2 	sub.w	r0, r3, #324	; 0x144
   28a8c:	b10e      	cbz	r6, 28a92 <att_req_send_process+0x1e>
   28a8e:	f5a6 76a2 	sub.w	r6, r6, #324	; 0x144
		if (!chan->req) {
   28a92:	f8d0 30f4 	ldr.w	r3, [r0, #244]	; 0xf4
   28a96:	b13b      	cbz	r3, 28aa8 <att_req_send_process+0x34>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28a98:	b966      	cbnz	r6, 28ab4 <att_req_send_process+0x40>
	parent->next = child;
   28a9a:	6863      	ldr	r3, [r4, #4]
   28a9c:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   28a9e:	68a3      	ldr	r3, [r4, #8]
	list->head = node;
   28aa0:	6065      	str	r5, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
   28aa2:	b933      	cbnz	r3, 28ab2 <att_req_send_process+0x3e>
	list->tail = node;
   28aa4:	60a5      	str	r5, [r4, #8]
}
   28aa6:	e004      	b.n	28ab2 <att_req_send_process+0x3e>
	return chan_req_send(chan, req);
   28aa8:	4629      	mov	r1, r5
   28aaa:	f7ff ff10 	bl	288ce <chan_req_send>
			if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   28aae:	2800      	cmp	r0, #0
   28ab0:	dbf2      	blt.n	28a98 <att_req_send_process+0x24>
}
   28ab2:	bd70      	pop	{r4, r5, r6, pc}
	return node->next;
   28ab4:	f8d6 3144 	ldr.w	r3, [r6, #324]	; 0x144
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28ab8:	b10b      	cbz	r3, 28abe <att_req_send_process+0x4a>
   28aba:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
{
   28abe:	4630      	mov	r0, r6
   28ac0:	461e      	mov	r6, r3
   28ac2:	e7e6      	b.n	28a92 <att_req_send_process+0x1e>

00028ac4 <bt_att_status>:
{
   28ac4:	b538      	push	{r3, r4, r5, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   28ac6:	f3bf 8f5b 	dmb	ish
   28aca:	680b      	ldr	r3, [r1, #0]
   28acc:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   28ad0:	07db      	lsls	r3, r3, #31
{
   28ad2:	4605      	mov	r5, r0
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   28ad4:	d519      	bpl.n	28b0a <bt_att_status+0x46>
	if (!chan->att) {
   28ad6:	f850 0c08 	ldr.w	r0, [r0, #-8]
   28ada:	b1b0      	cbz	r0, 28b0a <bt_att_status+0x46>
	if (chan->req) {
   28adc:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
   28ae0:	b99b      	cbnz	r3, 28b0a <bt_att_status+0x46>
	node = sys_slist_get(&chan->att->reqs);
   28ae2:	3004      	adds	r0, #4
   28ae4:	f7ff fd34 	bl	28550 <sys_slist_get>
	if (!node) {
   28ae8:	4604      	mov	r4, r0
   28aea:	b170      	cbz	r0, 28b0a <bt_att_status+0x46>
	return chan_req_send(chan, req);
   28aec:	4601      	mov	r1, r0
   28aee:	f1a5 0008 	sub.w	r0, r5, #8
   28af2:	f7ff feec 	bl	288ce <chan_req_send>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   28af6:	2800      	cmp	r0, #0
   28af8:	da07      	bge.n	28b0a <bt_att_status+0x46>
	sys_slist_prepend(&chan->att->reqs, node);
   28afa:	f855 3c08 	ldr.w	r3, [r5, #-8]
	parent->next = child;
   28afe:	685a      	ldr	r2, [r3, #4]
   28b00:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   28b02:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   28b04:	605c      	str	r4, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   28b06:	b902      	cbnz	r2, 28b0a <bt_att_status+0x46>
	list->tail = node;
   28b08:	609c      	str	r4, [r3, #8]
}
   28b0a:	bd38      	pop	{r3, r4, r5, pc}

00028b0c <send_err_rsp.part.0>:
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   28b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28b10:	4688      	mov	r8, r1
   28b12:	4617      	mov	r7, r2
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   28b14:	2101      	movs	r1, #1
   28b16:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   28b18:	4605      	mov	r5, r0
   28b1a:	461e      	mov	r6, r3
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   28b1c:	f7e0 fdd0 	bl	96c0 <bt_att_chan_create_pdu>
	if (!buf) {
   28b20:	4604      	mov	r4, r0
   28b22:	b170      	cbz	r0, 28b42 <send_err_rsp.part.0+0x36>
   28b24:	2104      	movs	r1, #4
   28b26:	3008      	adds	r0, #8
   28b28:	f003 f908 	bl	2bd3c <net_buf_simple_add>
	rsp->request = req;
   28b2c:	f880 8000 	strb.w	r8, [r0]
	rsp->error = err;
   28b30:	70c6      	strb	r6, [r0, #3]
	rsp->handle = sys_cpu_to_le16(handle);
   28b32:	f8a0 7001 	strh.w	r7, [r0, #1]
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   28b36:	4621      	mov	r1, r4
   28b38:	4628      	mov	r0, r5
}
   28b3a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   28b3e:	f7e0 bd25 	b.w	958c <bt_att_chan_send_rsp.constprop.0>
}
   28b42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00028b46 <att_write_req>:
{
   28b46:	b537      	push	{r0, r1, r2, r4, r5, lr}
   28b48:	460c      	mov	r4, r1
   28b4a:	4605      	mov	r5, r0
	return net_buf_simple_pull_le16(&buf->b);
   28b4c:	f101 0008 	add.w	r0, r1, #8
   28b50:	f003 f97c 	bl	2be4c <net_buf_simple_pull_le16>
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   28b54:	89a2      	ldrh	r2, [r4, #12]
   28b56:	9201      	str	r2, [sp, #4]
   28b58:	68a2      	ldr	r2, [r4, #8]
   28b5a:	9200      	str	r2, [sp, #0]
   28b5c:	4603      	mov	r3, r0
   28b5e:	2213      	movs	r2, #19
   28b60:	2112      	movs	r1, #18
   28b62:	4628      	mov	r0, r5
   28b64:	f7e0 feba 	bl	98dc <att_write_rsp.constprop.0>
}
   28b68:	b003      	add	sp, #12
   28b6a:	bd30      	pop	{r4, r5, pc}

00028b6c <att_write_cmd>:
{
   28b6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   28b6e:	460c      	mov	r4, r1
   28b70:	4605      	mov	r5, r0
   28b72:	f101 0008 	add.w	r0, r1, #8
   28b76:	f003 f969 	bl	2be4c <net_buf_simple_pull_le16>
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
   28b7a:	89a2      	ldrh	r2, [r4, #12]
   28b7c:	9201      	str	r2, [sp, #4]
   28b7e:	68a2      	ldr	r2, [r4, #8]
   28b80:	9200      	str	r2, [sp, #0]
   28b82:	2200      	movs	r2, #0
   28b84:	4603      	mov	r3, r0
   28b86:	4611      	mov	r1, r2
   28b88:	4628      	mov	r0, r5
   28b8a:	f7e0 fea7 	bl	98dc <att_write_rsp.constprop.0>
}
   28b8e:	b003      	add	sp, #12
   28b90:	bd30      	pop	{r4, r5, pc}

00028b92 <att_read_blob_req>:
{
   28b92:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   28b94:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   28b96:	8813      	ldrh	r3, [r2, #0]
   28b98:	8852      	ldrh	r2, [r2, #2]
   28b9a:	9200      	str	r2, [sp, #0]
   28b9c:	210c      	movs	r1, #12
   28b9e:	220d      	movs	r2, #13
   28ba0:	f7e1 f802 	bl	9ba8 <att_read_rsp>
}
   28ba4:	b003      	add	sp, #12
   28ba6:	f85d fb04 	ldr.w	pc, [sp], #4

00028baa <att_read_req>:
{
   28baa:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   28bac:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   28bae:	2200      	movs	r2, #0
   28bb0:	881b      	ldrh	r3, [r3, #0]
   28bb2:	9200      	str	r2, [sp, #0]
   28bb4:	210a      	movs	r1, #10
   28bb6:	220b      	movs	r2, #11
   28bb8:	f7e0 fff6 	bl	9ba8 <att_read_rsp>
}
   28bbc:	b003      	add	sp, #12
   28bbe:	f85d fb04 	ldr.w	pc, [sp], #4

00028bc2 <att_mtu_req>:
{
   28bc2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn *conn = chan->att->conn;
   28bc4:	6803      	ldr	r3, [r0, #0]
{
   28bc6:	4604      	mov	r4, r0
	struct bt_conn *conn = chan->att->conn;
   28bc8:	6818      	ldr	r0, [r3, #0]
   28bca:	f3bf 8f5b 	dmb	ish
   28bce:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   28bd2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   28bd6:	f3c3 05c0 	ubfx	r5, r3, #3, #1
   28bda:	071b      	lsls	r3, r3, #28
   28bdc:	d420      	bmi.n	28c20 <att_mtu_req+0x5e>
	mtu_client = sys_le16_to_cpu(req->mtu);
   28bde:	688b      	ldr	r3, [r1, #8]
   28be0:	881e      	ldrh	r6, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   28be2:	2e16      	cmp	r6, #22
   28be4:	d91e      	bls.n	28c24 <att_mtu_req+0x62>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   28be6:	2202      	movs	r2, #2
   28be8:	2103      	movs	r1, #3
   28bea:	f7e0 fed9 	bl	99a0 <bt_att_create_pdu>
	if (!pdu) {
   28bee:	4607      	mov	r7, r0
   28bf0:	b1d0      	cbz	r0, 28c28 <att_mtu_req+0x66>
	return net_buf_simple_add(&buf->b, len);
   28bf2:	2102      	movs	r1, #2
   28bf4:	3008      	adds	r0, #8
   28bf6:	f003 f8a1 	bl	2bd3c <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   28bfa:	2345      	movs	r3, #69	; 0x45
   28bfc:	7003      	strb	r3, [r0, #0]
   28bfe:	7045      	strb	r5, [r0, #1]
	bt_att_chan_send_rsp(chan, pdu, chan_rsp_sent);
   28c00:	4639      	mov	r1, r7
   28c02:	4620      	mov	r0, r4
   28c04:	f7e0 fcc2 	bl	958c <bt_att_chan_send_rsp.constprop.0>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   28c08:	2e45      	cmp	r6, #69	; 0x45
   28c0a:	bf28      	it	cs
   28c0c:	2645      	movcs	r6, #69	; 0x45
	att_chan_mtu_updated(chan);
   28c0e:	4620      	mov	r0, r4
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   28c10:	f8a4 607a 	strh.w	r6, [r4, #122]	; 0x7a
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   28c14:	f8a4 608a 	strh.w	r6, [r4, #138]	; 0x8a
	att_chan_mtu_updated(chan);
   28c18:	f7ff fd48 	bl	286ac <att_chan_mtu_updated>
	return 0;
   28c1c:	4628      	mov	r0, r5
}
   28c1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
   28c20:	2006      	movs	r0, #6
   28c22:	e7fc      	b.n	28c1e <att_mtu_req+0x5c>
		return BT_ATT_ERR_INVALID_PDU;
   28c24:	2004      	movs	r0, #4
   28c26:	e7fa      	b.n	28c1e <att_mtu_req+0x5c>
		return BT_ATT_ERR_UNLIKELY;
   28c28:	200e      	movs	r0, #14
   28c2a:	e7f8      	b.n	28c1e <att_mtu_req+0x5c>

00028c2c <bt_att_init>:
	bt_gatt_init();
   28c2c:	f7e1 bec4 	b.w	a9b8 <bt_gatt_init>

00028c30 <bt_att_get_mtu>:
{
   28c30:	b508      	push	{r3, lr}
	att = att_get(conn);
   28c32:	f7e0 fb4d 	bl	92d0 <att_get>
	if (!att) {
   28c36:	b1b0      	cbz	r0, 28c66 <bt_att_get_mtu+0x36>
	return list->head;
   28c38:	6a40      	ldr	r0, [r0, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28c3a:	b1a0      	cbz	r0, 28c66 <bt_att_get_mtu+0x36>
	return node->next;
   28c3c:	6803      	ldr	r3, [r0, #0]
   28c3e:	f5a0 71a2 	sub.w	r1, r0, #324	; 0x144
   28c42:	b10b      	cbz	r3, 28c48 <bt_att_get_mtu+0x18>
   28c44:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
{
   28c48:	2000      	movs	r0, #0
		if (chan->chan.tx.mtu > mtu) {
   28c4a:	f8b1 208a 	ldrh.w	r2, [r1, #138]	; 0x8a
   28c4e:	4290      	cmp	r0, r2
   28c50:	bf38      	it	cc
   28c52:	4610      	movcc	r0, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28c54:	b13b      	cbz	r3, 28c66 <bt_att_get_mtu+0x36>
   28c56:	f8d3 2144 	ldr.w	r2, [r3, #324]	; 0x144
   28c5a:	b10a      	cbz	r2, 28c60 <bt_att_get_mtu+0x30>
   28c5c:	f5a2 72a2 	sub.w	r2, r2, #324	; 0x144
{
   28c60:	4619      	mov	r1, r3
   28c62:	4613      	mov	r3, r2
   28c64:	e7f1      	b.n	28c4a <bt_att_get_mtu+0x1a>
}
   28c66:	bd08      	pop	{r3, pc}

00028c68 <att_confirm>:
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   28c68:	898a      	ldrh	r2, [r1, #12]
   28c6a:	6889      	ldr	r1, [r1, #8]
   28c6c:	2300      	movs	r3, #0
   28c6e:	f7e1 b919 	b.w	9ea4 <att_handle_rsp>

00028c72 <bt_att_send>:

int bt_att_send(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb,
		void *user_data)
{
   28c72:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   28c76:	4607      	mov	r7, r0
   28c78:	460d      	mov	r5, r1
   28c7a:	4616      	mov	r6, r2
   28c7c:	4698      	mov	r8, r3
	struct bt_att *att;

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(buf);

	att = att_get(conn);
   28c7e:	f7e0 fb27 	bl	92d0 <att_get>
	if (!att) {
   28c82:	4604      	mov	r4, r0
   28c84:	b938      	cbnz	r0, 28c96 <bt_att_send+0x24>
		net_buf_unref(buf);
   28c86:	4628      	mov	r0, r5
   28c88:	f7f7 fe04 	bl	20894 <net_buf_unref>
		return -ENOTCONN;
   28c8c:	f06f 007f 	mvn.w	r0, #127	; 0x7f

	net_buf_put(&att->tx_queue, buf);
	att_send_process(att);

	return 0;
}
   28c90:	b002      	add	sp, #8
   28c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (cb) {
   28c96:	b146      	cbz	r6, 28caa <bt_att_send+0x38>
		return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, cb,
   28c98:	f8cd 8000 	str.w	r8, [sp]
   28c9c:	4633      	mov	r3, r6
   28c9e:	462a      	mov	r2, r5
   28ca0:	2104      	movs	r1, #4
   28ca2:	4638      	mov	r0, r7
   28ca4:	f7ff fc24 	bl	284f0 <bt_l2cap_send_cb>
   28ca8:	e7f2      	b.n	28c90 <bt_att_send+0x1e>
	net_buf_put(&att->tx_queue, buf);
   28caa:	f100 060c 	add.w	r6, r0, #12
   28cae:	4629      	mov	r1, r5
   28cb0:	4630      	mov	r0, r6
   28cb2:	f002 fffe 	bl	2bcb2 <net_buf_put>
	buf = net_buf_get(&att->tx_queue, K_NO_WAIT);
   28cb6:	2200      	movs	r2, #0
   28cb8:	2300      	movs	r3, #0
   28cba:	4630      	mov	r0, r6
   28cbc:	f002 ffb8 	bl	2bc30 <net_buf_get>
	if (!buf) {
   28cc0:	4605      	mov	r5, r0
   28cc2:	b908      	cbnz	r0, 28cc8 <bt_att_send+0x56>
	return 0;
   28cc4:	2000      	movs	r0, #0
   28cc6:	e7e3      	b.n	28c90 <bt_att_send+0x1e>
	return list->head;
   28cc8:	6a63      	ldr	r3, [r4, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28cca:	b1a3      	cbz	r3, 28cf6 <bt_att_send+0x84>
	return node->next;
   28ccc:	681c      	ldr	r4, [r3, #0]
   28cce:	f5a3 70a2 	sub.w	r0, r3, #324	; 0x144
   28cd2:	b10c      	cbz	r4, 28cd8 <bt_att_send+0x66>
   28cd4:	f5a4 74a2 	sub.w	r4, r4, #324	; 0x144
	return chan_send(chan, buf, cb);
   28cd8:	2200      	movs	r2, #0
   28cda:	4629      	mov	r1, r5
   28cdc:	f7e0 fbe8 	bl	94b0 <chan_send>
		if (err >= 0) {
   28ce0:	2800      	cmp	r0, #0
   28ce2:	daef      	bge.n	28cc4 <bt_att_send+0x52>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   28ce4:	b13c      	cbz	r4, 28cf6 <bt_att_send+0x84>
   28ce6:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
   28cea:	b10b      	cbz	r3, 28cf0 <bt_att_send+0x7e>
   28cec:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
{
   28cf0:	4620      	mov	r0, r4
   28cf2:	461c      	mov	r4, r3
   28cf4:	e7f0      	b.n	28cd8 <bt_att_send+0x66>
		k_queue_prepend(&att->tx_queue._queue, buf);
   28cf6:	4629      	mov	r1, r5
   28cf8:	4630      	mov	r0, r6
   28cfa:	f003 ff7a 	bl	2cbf2 <k_queue_prepend>
   28cfe:	e7e1      	b.n	28cc4 <bt_att_send+0x52>

00028d00 <bt_att_req_send>:

int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
{
   28d00:	b510      	push	{r4, lr}
   28d02:	460c      	mov	r4, r1
	BT_DBG("conn %p req %p", conn, req);

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(req);

	att = att_get(conn);
   28d04:	f7e0 fae4 	bl	92d0 <att_get>
	if (!att) {
   28d08:	b160      	cbz	r0, 28d24 <bt_att_req_send+0x24>
	parent->next = child;
   28d0a:	2300      	movs	r3, #0
   28d0c:	6023      	str	r3, [r4, #0]
	return list->tail;
   28d0e:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
   28d10:	b92b      	cbnz	r3, 28d1e <bt_att_req_send+0x1e>
	list->head = node;
   28d12:	e9c0 4401 	strd	r4, r4, [r0, #4]
		return -ENOTCONN;
	}

	sys_slist_append(&att->reqs, &req->node);
	att_req_send_process(att);
   28d16:	f7ff fead 	bl	28a74 <att_req_send_process>

	return 0;
   28d1a:	2000      	movs	r0, #0
}
   28d1c:	bd10      	pop	{r4, pc}
	parent->next = child;
   28d1e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   28d20:	6084      	str	r4, [r0, #8]
}
   28d22:	e7f8      	b.n	28d16 <bt_att_req_send+0x16>
		return -ENOTCONN;
   28d24:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   28d28:	e7f8      	b.n	28d1c <bt_att_req_send+0x1c>

00028d2a <found_attr>:
	*found = attr;
   28d2a:	6010      	str	r0, [r2, #0]
}
   28d2c:	2000      	movs	r0, #0
   28d2e:	4770      	bx	lr

00028d30 <gatt_ccc_changed>:
{
   28d30:	460b      	mov	r3, r1
		if (ccc->cfg[i].value > value) {
   28d32:	8909      	ldrh	r1, [r1, #8]
	if (value != ccc->value) {
   28d34:	895a      	ldrh	r2, [r3, #10]
   28d36:	428a      	cmp	r2, r1
   28d38:	d003      	beq.n	28d42 <gatt_ccc_changed+0x12>
		ccc->value = value;
   28d3a:	8159      	strh	r1, [r3, #10]
		if (ccc->cfg_changed) {
   28d3c:	68db      	ldr	r3, [r3, #12]
   28d3e:	b103      	cbz	r3, 28d42 <gatt_ccc_changed+0x12>
			ccc->cfg_changed(attr, value);
   28d40:	4718      	bx	r3
}
   28d42:	4770      	bx	lr

00028d44 <gatt_indicate_rsp>:
{
   28d44:	b510      	push	{r4, lr}
   28d46:	9c02      	ldr	r4, [sp, #8]
	if (params->func) {
   28d48:	68a3      	ldr	r3, [r4, #8]
{
   28d4a:	460a      	mov	r2, r1
	if (params->func) {
   28d4c:	b10b      	cbz	r3, 28d52 <gatt_indicate_rsp+0xe>
		params->func(conn, params, err);
   28d4e:	4621      	mov	r1, r4
   28d50:	4798      	blx	r3
	params->_ref--;
   28d52:	7da3      	ldrb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   28d54:	68e2      	ldr	r2, [r4, #12]
	params->_ref--;
   28d56:	3b01      	subs	r3, #1
   28d58:	b2db      	uxtb	r3, r3
   28d5a:	75a3      	strb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   28d5c:	b122      	cbz	r2, 28d68 <gatt_indicate_rsp+0x24>
   28d5e:	b91b      	cbnz	r3, 28d68 <gatt_indicate_rsp+0x24>
		params->destroy(params);
   28d60:	4620      	mov	r0, r4
}
   28d62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		params->destroy(params);
   28d66:	4710      	bx	r2
}
   28d68:	bd10      	pop	{r4, pc}

00028d6a <match_uuid>:
	data->attr = attr;
   28d6a:	6010      	str	r0, [r2, #0]
	data->handle = handle;
   28d6c:	8091      	strh	r1, [r2, #4]
}
   28d6e:	2000      	movs	r0, #0
   28d70:	4770      	bx	lr

00028d72 <ccc_set_cb>:
}
   28d72:	2000      	movs	r0, #0
   28d74:	4770      	bx	lr

00028d76 <atomic_get>:
   28d76:	f3bf 8f5b 	dmb	ish
   28d7a:	6800      	ldr	r0, [r0, #0]
   28d7c:	f3bf 8f5b 	dmb	ish
}
   28d80:	4770      	bx	lr

00028d82 <gen_hash_m>:
{
   28d82:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   28d84:	6807      	ldr	r7, [r0, #0]
   28d86:	783d      	ldrb	r5, [r7, #0]
{
   28d88:	b089      	sub	sp, #36	; 0x24
   28d8a:	4606      	mov	r6, r0
   28d8c:	4614      	mov	r4, r2
	if (attr->uuid->type != BT_UUID_TYPE_16)
   28d8e:	b10d      	cbz	r5, 28d94 <gen_hash_m+0x12>
	switch (u16->val) {
   28d90:	2501      	movs	r5, #1
   28d92:	e014      	b.n	28dbe <gen_hash_m+0x3c>
   28d94:	887b      	ldrh	r3, [r7, #2]
   28d96:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   28d9a:	d004      	beq.n	28da6 <gen_hash_m+0x24>
   28d9c:	d812      	bhi.n	28dc4 <gen_hash_m+0x42>
   28d9e:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   28da2:	2b03      	cmp	r3, #3
   28da4:	d8f4      	bhi.n	28d90 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(handle);
   28da6:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   28daa:	2202      	movs	r2, #2
   28dac:	f10d 010a 	add.w	r1, sp, #10
   28db0:	4620      	mov	r0, r4
   28db2:	f7fe fb76 	bl	274a2 <tc_cmac_update>
   28db6:	b9e0      	cbnz	r0, 28df2 <gen_hash_m+0x70>
			state->err = -EINVAL;
   28db8:	f06f 0315 	mvn.w	r3, #21
   28dbc:	65a3      	str	r3, [r4, #88]	; 0x58
}
   28dbe:	4628      	mov	r0, r5
   28dc0:	b009      	add	sp, #36	; 0x24
   28dc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   28dc4:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
   28dc8:	33ff      	adds	r3, #255	; 0xff
   28dca:	b29b      	uxth	r3, r3
   28dcc:	2b04      	cmp	r3, #4
   28dce:	d8df      	bhi.n	28d90 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(handle);
   28dd0:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   28dd4:	2202      	movs	r2, #2
   28dd6:	f10d 010a 	add.w	r1, sp, #10
   28dda:	4620      	mov	r0, r4
   28ddc:	f7fe fb61 	bl	274a2 <tc_cmac_update>
   28de0:	2800      	cmp	r0, #0
   28de2:	d0e9      	beq.n	28db8 <gen_hash_m+0x36>
		value = sys_cpu_to_le16(u16->val);
   28de4:	887b      	ldrh	r3, [r7, #2]
   28de6:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   28dea:	2202      	movs	r2, #2
   28dec:	f10d 010a 	add.w	r1, sp, #10
   28df0:	e016      	b.n	28e20 <gen_hash_m+0x9e>
		value = sys_cpu_to_le16(u16->val);
   28df2:	887b      	ldrh	r3, [r7, #2]
   28df4:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   28df8:	2202      	movs	r2, #2
   28dfa:	f10d 010a 	add.w	r1, sp, #10
   28dfe:	4620      	mov	r0, r4
   28e00:	f7fe fb4f 	bl	274a2 <tc_cmac_update>
   28e04:	2800      	cmp	r0, #0
   28e06:	d0d7      	beq.n	28db8 <gen_hash_m+0x36>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   28e08:	2000      	movs	r0, #0
   28e0a:	aa03      	add	r2, sp, #12
   28e0c:	6877      	ldr	r7, [r6, #4]
   28e0e:	9000      	str	r0, [sp, #0]
   28e10:	2313      	movs	r3, #19
   28e12:	4631      	mov	r1, r6
   28e14:	47b8      	blx	r7
		if (len < 0) {
   28e16:	1e02      	subs	r2, r0, #0
   28e18:	da01      	bge.n	28e1e <gen_hash_m+0x9c>
			state->err = len;
   28e1a:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   28e1c:	e7cf      	b.n	28dbe <gen_hash_m+0x3c>
		if (tc_cmac_update(&state->state, data, len) ==
   28e1e:	a903      	add	r1, sp, #12
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   28e20:	4620      	mov	r0, r4
   28e22:	f7fe fb3e 	bl	274a2 <tc_cmac_update>
   28e26:	2800      	cmp	r0, #0
   28e28:	d1b2      	bne.n	28d90 <gen_hash_m+0xe>
   28e2a:	e7c5      	b.n	28db8 <gen_hash_m+0x36>

00028e2c <atomic_or>:
{
   28e2c:	4603      	mov	r3, r0
}
   28e2e:	f3bf 8f5b 	dmb	ish
   28e32:	e853 0f00 	ldrex	r0, [r3]
   28e36:	ea40 0201 	orr.w	r2, r0, r1
   28e3a:	e843 2c00 	strex	ip, r2, [r3]
   28e3e:	f1bc 0f00 	cmp.w	ip, #0
   28e42:	d1f6      	bne.n	28e32 <atomic_or+0x6>
   28e44:	f3bf 8f5b 	dmb	ish
   28e48:	4770      	bx	lr

00028e4a <bt_addr_le_cmp>:
   28e4a:	2207      	movs	r2, #7
   28e4c:	f7fe bcff 	b.w	2784e <memcmp>

00028e50 <find_ccc_cfg>:
{
   28e50:	b513      	push	{r0, r1, r4, lr}
						    &cfg->peer)) {
   28e52:	1c4a      	adds	r2, r1, #1
{
   28e54:	460c      	mov	r4, r1
		if (conn) {
   28e56:	b140      	cbz	r0, 28e6a <find_ccc_cfg+0x1a>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   28e58:	7809      	ldrb	r1, [r1, #0]
   28e5a:	f7ff fab3 	bl	283c4 <bt_conn_is_peer_addr_le>
	return NULL;
   28e5e:	2800      	cmp	r0, #0
   28e60:	bf08      	it	eq
   28e62:	2400      	moveq	r4, #0
}
   28e64:	4620      	mov	r0, r4
   28e66:	b002      	add	sp, #8
   28e68:	bd10      	pop	{r4, pc}
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   28e6a:	9000      	str	r0, [sp, #0]
   28e6c:	4669      	mov	r1, sp
   28e6e:	f8cd 0003 	str.w	r0, [sp, #3]
   28e72:	4610      	mov	r0, r2
   28e74:	f7ff ffe9 	bl	28e4a <bt_addr_le_cmp>
	return NULL;
   28e78:	2800      	cmp	r0, #0
   28e7a:	bf18      	it	ne
   28e7c:	2400      	movne	r4, #0
   28e7e:	e7f1      	b.n	28e64 <find_ccc_cfg+0x14>

00028e80 <ccc_find_cfg>:
{
   28e80:	b510      	push	{r4, lr}
		if (id == ccc->cfg[i].id &&
   28e82:	7803      	ldrb	r3, [r0, #0]
   28e84:	4293      	cmp	r3, r2
{
   28e86:	4604      	mov	r4, r0
		if (id == ccc->cfg[i].id &&
   28e88:	d001      	beq.n	28e8e <ccc_find_cfg+0xe>
	return NULL;
   28e8a:	2000      	movs	r0, #0
}
   28e8c:	bd10      	pop	{r4, pc}
		    !bt_addr_le_cmp(&ccc->cfg[i].peer, addr)) {
   28e8e:	3001      	adds	r0, #1
   28e90:	f7ff ffdb 	bl	28e4a <bt_addr_le_cmp>
		if (id == ccc->cfg[i].id &&
   28e94:	2800      	cmp	r0, #0
   28e96:	d1f8      	bne.n	28e8a <ccc_find_cfg+0xa>
			return &ccc->cfg[i];
   28e98:	4620      	mov	r0, r4
   28e9a:	e7f7      	b.n	28e8c <ccc_find_cfg+0xc>

00028e9c <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   28e9c:	2207      	movs	r2, #7
   28e9e:	f7fe bce7 	b.w	27870 <memcpy>

00028ea2 <clear_ccc_cfg>:
{
   28ea2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   28ea4:	2500      	movs	r5, #0
{
   28ea6:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   28ea8:	4669      	mov	r1, sp
   28eaa:	3001      	adds	r0, #1
   28eac:	9500      	str	r5, [sp, #0]
   28eae:	f8cd 5003 	str.w	r5, [sp, #3]
   28eb2:	f7ff fff3 	bl	28e9c <bt_addr_le_copy>
	cfg->id = 0U;
   28eb6:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
   28eb8:	8125      	strh	r5, [r4, #8]
}
   28eba:	b003      	add	sp, #12
   28ebc:	bd30      	pop	{r4, r5, pc}

00028ebe <atomic_and>:
{
   28ebe:	4603      	mov	r3, r0
}
   28ec0:	f3bf 8f5b 	dmb	ish
   28ec4:	e853 0f00 	ldrex	r0, [r3]
   28ec8:	ea00 0201 	and.w	r2, r0, r1
   28ecc:	e843 2c00 	strex	ip, r2, [r3]
   28ed0:	f1bc 0f00 	cmp.w	ip, #0
   28ed4:	d1f6      	bne.n	28ec4 <atomic_and+0x6>
   28ed6:	f3bf 8f5b 	dmb	ish
   28eda:	4770      	bx	lr

00028edc <gatt_foreach_iter>:
{
   28edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (handle > end_handle) {
   28ede:	4299      	cmp	r1, r3
{
   28ee0:	4604      	mov	r4, r0
   28ee2:	9e08      	ldr	r6, [sp, #32]
   28ee4:	e9dd 0706 	ldrd	r0, r7, [sp, #24]
   28ee8:	460d      	mov	r5, r1
	if (handle > end_handle) {
   28eea:	d810      	bhi.n	28f0e <gatt_foreach_iter+0x32>
	if (handle < start_handle) {
   28eec:	4291      	cmp	r1, r2
   28eee:	d201      	bcs.n	28ef4 <gatt_foreach_iter+0x18>
		return BT_GATT_ITER_CONTINUE;
   28ef0:	2001      	movs	r0, #1
}
   28ef2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   28ef4:	b968      	cbnz	r0, 28f12 <gatt_foreach_iter+0x36>
	if (attr_data && attr_data != attr->user_data) {
   28ef6:	b997      	cbnz	r7, 28f1e <gatt_foreach_iter+0x42>
	*num_matches -= 1;
   28ef8:	8833      	ldrh	r3, [r6, #0]
	result = func(attr, handle, user_data);
   28efa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	*num_matches -= 1;
   28efc:	3b01      	subs	r3, #1
   28efe:	8033      	strh	r3, [r6, #0]
	result = func(attr, handle, user_data);
   28f00:	4629      	mov	r1, r5
   28f02:	9b09      	ldr	r3, [sp, #36]	; 0x24
   28f04:	4620      	mov	r0, r4
   28f06:	4798      	blx	r3
	if (!*num_matches) {
   28f08:	8833      	ldrh	r3, [r6, #0]
   28f0a:	2b00      	cmp	r3, #0
   28f0c:	d1f1      	bne.n	28ef2 <gatt_foreach_iter+0x16>
		return BT_GATT_ITER_STOP;
   28f0e:	2000      	movs	r0, #0
   28f10:	e7ef      	b.n	28ef2 <gatt_foreach_iter+0x16>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   28f12:	6821      	ldr	r1, [r4, #0]
   28f14:	f7fe fef9 	bl	27d0a <bt_uuid_cmp>
   28f18:	2800      	cmp	r0, #0
   28f1a:	d0ec      	beq.n	28ef6 <gatt_foreach_iter+0x1a>
   28f1c:	e7e8      	b.n	28ef0 <gatt_foreach_iter+0x14>
	if (attr_data && attr_data != attr->user_data) {
   28f1e:	68e3      	ldr	r3, [r4, #12]
   28f20:	429f      	cmp	r7, r3
   28f22:	d1e5      	bne.n	28ef0 <gatt_foreach_iter+0x14>
   28f24:	e7e8      	b.n	28ef8 <gatt_foreach_iter+0x1c>

00028f26 <z_log_msg2_static_create.constprop.0>:
   28f26:	2300      	movs	r3, #0
   28f28:	f7fc bed6 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00028f2c <clear_cf_cfg>:
{
   28f2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   28f2e:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   28f30:	2500      	movs	r5, #0
   28f32:	4669      	mov	r1, sp
   28f34:	3001      	adds	r0, #1
   28f36:	9500      	str	r5, [sp, #0]
   28f38:	f8cd 5003 	str.w	r5, [sp, #3]
   28f3c:	f7ff ffae 	bl	28e9c <bt_addr_le_copy>
	memset(cfg->data, 0, sizeof(cfg->data));
   28f40:	f104 0008 	add.w	r0, r4, #8
   28f44:	2201      	movs	r2, #1
   28f46:	4629      	mov	r1, r5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   28f48:	340c      	adds	r4, #12
   28f4a:	f7fe fc9c 	bl	27886 <memset>
   28f4e:	f3bf 8f5b 	dmb	ish
   28f52:	e854 3f00 	ldrex	r3, [r4]
   28f56:	e844 5200 	strex	r2, r5, [r4]
   28f5a:	2a00      	cmp	r2, #0
   28f5c:	d1f9      	bne.n	28f52 <clear_cf_cfg+0x26>
   28f5e:	f3bf 8f5b 	dmb	ish
}
   28f62:	b003      	add	sp, #12
   28f64:	bd30      	pop	{r4, r5, pc}

00028f66 <sc_ccc_cfg_write>:
	if (value == BT_GATT_CCC_INDICATE) {
   28f66:	2a02      	cmp	r2, #2
{
   28f68:	b510      	push	{r4, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   28f6a:	d108      	bne.n	28f7e <sc_ccc_cfg_write+0x18>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   28f6c:	2300      	movs	r3, #0
   28f6e:	f100 0188 	add.w	r1, r0, #136	; 0x88
   28f72:	461a      	mov	r2, r3
   28f74:	7a00      	ldrb	r0, [r0, #8]
   28f76:	f7e1 f95f 	bl	a238 <sc_save>
}
   28f7a:	2002      	movs	r0, #2
   28f7c:	bd10      	pop	{r4, pc}
		sc_clear(conn);
   28f7e:	f7e1 fc3f 	bl	a800 <sc_clear>
   28f82:	e7fa      	b.n	28f7a <sc_ccc_cfg_write+0x14>

00028f84 <read_ppcp>:
{
   28f84:	b513      	push	{r0, r1, r4, lr}
   28f86:	4610      	mov	r0, r2
	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
   28f88:	2218      	movs	r2, #24
{
   28f8a:	f8bd 1010 	ldrh.w	r1, [sp, #16]
	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
   28f8e:	f8ad 2000 	strh.w	r2, [sp]
	ppcp.max_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MAX_INT);
   28f92:	2228      	movs	r2, #40	; 0x28
   28f94:	f8ad 2002 	strh.w	r2, [sp, #2]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   28f98:	2200      	movs	r2, #0
   28f9a:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (offset > value_len) {
   28f9e:	2908      	cmp	r1, #8
	ppcp.timeout = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
   28fa0:	f04f 022a 	mov.w	r2, #42	; 0x2a
   28fa4:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   28fa8:	d80b      	bhi.n	28fc2 <read_ppcp+0x3e>
	len = MIN(buf_len, value_len - offset);
   28faa:	f1c1 0408 	rsb	r4, r1, #8
   28fae:	429c      	cmp	r4, r3
   28fb0:	bfa8      	it	ge
   28fb2:	461c      	movge	r4, r3
	memcpy(buf, (uint8_t *)value + offset, len);
   28fb4:	4622      	mov	r2, r4
   28fb6:	4469      	add	r1, sp
   28fb8:	f7fe fc5a 	bl	27870 <memcpy>
}
   28fbc:	4620      	mov	r0, r4
   28fbe:	b002      	add	sp, #8
   28fc0:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   28fc2:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   28fc6:	e7f9      	b.n	28fbc <read_ppcp+0x38>

00028fc8 <read_appearance>:
{
   28fc8:	b513      	push	{r0, r1, r4, lr}
   28fca:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   28fce:	4610      	mov	r0, r2
	if (offset > value_len) {
   28fd0:	2902      	cmp	r1, #2
	uint16_t appearance = sys_cpu_to_le16(gap_appearance);
   28fd2:	f04f 0200 	mov.w	r2, #0
   28fd6:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   28fda:	d80d      	bhi.n	28ff8 <read_appearance+0x30>
	len = MIN(buf_len, value_len - offset);
   28fdc:	f1c1 0402 	rsb	r4, r1, #2
   28fe0:	429c      	cmp	r4, r3
   28fe2:	bfa8      	it	ge
   28fe4:	461c      	movge	r4, r3
	memcpy(buf, (uint8_t *)value + offset, len);
   28fe6:	f10d 0306 	add.w	r3, sp, #6
   28fea:	4622      	mov	r2, r4
   28fec:	4419      	add	r1, r3
   28fee:	f7fe fc3f 	bl	27870 <memcpy>
}
   28ff2:	4620      	mov	r0, r4
   28ff4:	b002      	add	sp, #8
   28ff6:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   28ff8:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   28ffc:	e7f9      	b.n	28ff2 <read_appearance+0x2a>

00028ffe <read_name>:
{
   28ffe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29002:	4698      	mov	r8, r3
   29004:	f8bd 6018 	ldrh.w	r6, [sp, #24]
   29008:	4615      	mov	r5, r2
	const char *name = bt_get_name();
   2900a:	f7de f819 	bl	7040 <bt_get_name>
   2900e:	4607      	mov	r7, r0
				 strlen(name));
   29010:	f7fe fbf0 	bl	277f4 <strlen>
	if (offset > value_len) {
   29014:	b283      	uxth	r3, r0
   29016:	42b3      	cmp	r3, r6
   29018:	d30c      	bcc.n	29034 <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
   2901a:	1b9c      	subs	r4, r3, r6
   2901c:	4544      	cmp	r4, r8
   2901e:	bfa8      	it	ge
   29020:	4644      	movge	r4, r8
   29022:	b2a4      	uxth	r4, r4
	memcpy(buf, (uint8_t *)value + offset, len);
   29024:	4622      	mov	r2, r4
   29026:	19b9      	adds	r1, r7, r6
   29028:	4628      	mov	r0, r5
   2902a:	f7fe fc21 	bl	27870 <memcpy>
}
   2902e:	4620      	mov	r0, r4
   29030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   29034:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   29038:	e7f9      	b.n	2902e <read_name+0x30>

0002903a <cf_read>:
{
   2903a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2903c:	461f      	mov	r7, r3
	uint8_t data[1] = {};
   2903e:	2300      	movs	r3, #0
{
   29040:	f8bd 6020 	ldrh.w	r6, [sp, #32]
	uint8_t data[1] = {};
   29044:	f88d 3004 	strb.w	r3, [sp, #4]
{
   29048:	4615      	mov	r5, r2
	cfg = find_cf_cfg(conn);
   2904a:	f7e0 ffe3 	bl	a014 <find_cf_cfg>
	if (cfg) {
   2904e:	b128      	cbz	r0, 2905c <cf_read+0x22>
		memcpy(data, cfg->data, sizeof(data));
   29050:	f100 0108 	add.w	r1, r0, #8
   29054:	2201      	movs	r2, #1
   29056:	a801      	add	r0, sp, #4
   29058:	f7fe fc0a 	bl	27870 <memcpy>
	if (offset > value_len) {
   2905c:	2e01      	cmp	r6, #1
   2905e:	d80d      	bhi.n	2907c <cf_read+0x42>
	len = MIN(buf_len, value_len - offset);
   29060:	f1c6 0401 	rsb	r4, r6, #1
   29064:	42bc      	cmp	r4, r7
   29066:	bfa8      	it	ge
   29068:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   2906a:	ab01      	add	r3, sp, #4
   2906c:	4622      	mov	r2, r4
   2906e:	1999      	adds	r1, r3, r6
   29070:	4628      	mov	r0, r5
   29072:	f7fe fbfd 	bl	27870 <memcpy>
}
   29076:	4620      	mov	r0, r4
   29078:	b003      	add	sp, #12
   2907a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2907c:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   29080:	e7f9      	b.n	29076 <cf_read+0x3c>

00029082 <bt_gatt_attr_read_service>:
{
   29082:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_uuid *uuid = attr->user_data;
   29084:	68c9      	ldr	r1, [r1, #12]
{
   29086:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   2908a:	461c      	mov	r4, r3
	if (uuid->type == BT_UUID_TYPE_16) {
   2908c:	780b      	ldrb	r3, [r1, #0]
{
   2908e:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   29090:	b993      	cbnz	r3, 290b8 <bt_gatt_attr_read_service+0x36>
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   29092:	884b      	ldrh	r3, [r1, #2]
   29094:	f8ad 3006 	strh.w	r3, [sp, #6]
	if (offset > value_len) {
   29098:	2d02      	cmp	r5, #2
   2909a:	d819      	bhi.n	290d0 <bt_gatt_attr_read_service+0x4e>
	len = MIN(buf_len, value_len - offset);
   2909c:	f1c5 0202 	rsb	r2, r5, #2
   290a0:	4294      	cmp	r4, r2
   290a2:	bfa8      	it	ge
   290a4:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
   290a6:	f10d 0306 	add.w	r3, sp, #6
   290aa:	4622      	mov	r2, r4
   290ac:	1959      	adds	r1, r3, r5
   290ae:	f7fe fbdf 	bl	27870 <memcpy>
}
   290b2:	4620      	mov	r0, r4
   290b4:	b003      	add	sp, #12
   290b6:	bd30      	pop	{r4, r5, pc}
	if (offset > value_len) {
   290b8:	2d10      	cmp	r5, #16
				 BT_UUID_128(uuid)->val, 16);
   290ba:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
   290be:	d807      	bhi.n	290d0 <bt_gatt_attr_read_service+0x4e>
	len = MIN(buf_len, value_len - offset);
   290c0:	f1c5 0210 	rsb	r2, r5, #16
   290c4:	4294      	cmp	r4, r2
   290c6:	bfa8      	it	ge
   290c8:	4614      	movge	r4, r2
	memcpy(buf, (uint8_t *)value + offset, len);
   290ca:	4622      	mov	r2, r4
   290cc:	4429      	add	r1, r5
   290ce:	e7ee      	b.n	290ae <bt_gatt_attr_read_service+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   290d0:	f06f 0406 	mvn.w	r4, #6
   290d4:	e7ed      	b.n	290b2 <bt_gatt_attr_read_service+0x30>

000290d6 <bt_gatt_attr_read_ccc>:
{
   290d6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
   290d8:	68c9      	ldr	r1, [r1, #12]
{
   290da:	f8bd 6020 	ldrh.w	r6, [sp, #32]
   290de:	4615      	mov	r5, r2
   290e0:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   290e2:	f7ff feb5 	bl	28e50 <find_ccc_cfg>
	if (cfg) {
   290e6:	b100      	cbz	r0, 290ea <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
   290e8:	8900      	ldrh	r0, [r0, #8]
   290ea:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   290ee:	2e02      	cmp	r6, #2
   290f0:	d80e      	bhi.n	29110 <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
   290f2:	f1c6 0402 	rsb	r4, r6, #2
   290f6:	42bc      	cmp	r4, r7
   290f8:	bfa8      	it	ge
   290fa:	463c      	movge	r4, r7
	memcpy(buf, (uint8_t *)value + offset, len);
   290fc:	f10d 0306 	add.w	r3, sp, #6
   29100:	4622      	mov	r2, r4
   29102:	1999      	adds	r1, r3, r6
   29104:	4628      	mov	r0, r5
   29106:	f7fe fbb3 	bl	27870 <memcpy>
}
   2910a:	4620      	mov	r0, r4
   2910c:	b003      	add	sp, #12
   2910e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   29110:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   29114:	e7f9      	b.n	2910a <bt_gatt_attr_read_ccc+0x34>

00029116 <sc_restore_rsp>:
{
   29116:	b538      	push	{r3, r4, r5, lr}
   29118:	4604      	mov	r4, r0
   2911a:	4615      	mov	r5, r2
	cfg = find_cf_cfg(conn);
   2911c:	f7e0 ff7a 	bl	a014 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   29120:	b130      	cbz	r0, 29130 <sc_restore_rsp+0x1a>
   29122:	7a03      	ldrb	r3, [r0, #8]
   29124:	07db      	lsls	r3, r3, #31
   29126:	d503      	bpl.n	29130 <sc_restore_rsp+0x1a>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   29128:	2101      	movs	r1, #1
   2912a:	300c      	adds	r0, #12
   2912c:	f7ff fe7e 	bl	28e2c <atomic_or>
	if (!err && IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
   29130:	b985      	cbnz	r5, 29154 <sc_restore_rsp+0x3e>
		struct gatt_sc_cfg *sc_cfg = find_sc_cfg(conn->id, &conn->le.dst);
   29132:	7a20      	ldrb	r0, [r4, #8]
   29134:	f104 0188 	add.w	r1, r4, #136	; 0x88
   29138:	f7e0 ff8a 	bl	a050 <find_sc_cfg>
		if (sc_cfg) {
   2913c:	4604      	mov	r4, r0
   2913e:	b148      	cbz	r0, 29154 <sc_restore_rsp+0x3e>
	memset(&cfg->data, 0, sizeof(cfg->data));
   29140:	4629      	mov	r1, r5
   29142:	2204      	movs	r2, #4
   29144:	3008      	adds	r0, #8
   29146:	f7fe fb9e 	bl	27886 <memset>
		sc_store(cfg);
   2914a:	4620      	mov	r0, r4
}
   2914c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		sc_store(cfg);
   29150:	f7e1 b842 	b.w	a1d8 <sc_store>
}
   29154:	bd38      	pop	{r3, r4, r5, pc}

00029156 <bt_gatt_attr_value_handle>:
{
   29156:	b513      	push	{r0, r1, r4, lr}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   29158:	4604      	mov	r4, r0
   2915a:	b910      	cbnz	r0, 29162 <bt_gatt_attr_value_handle+0xc>
	uint16_t handle = 0;
   2915c:	2000      	movs	r0, #0
}
   2915e:	b002      	add	sp, #8
   29160:	bd10      	pop	{r4, pc}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   29162:	2300      	movs	r3, #0
   29164:	f88d 3004 	strb.w	r3, [sp, #4]
   29168:	6800      	ldr	r0, [r0, #0]
   2916a:	f642 0303 	movw	r3, #10243	; 0x2803
   2916e:	a901      	add	r1, sp, #4
   29170:	f8ad 3006 	strh.w	r3, [sp, #6]
   29174:	f7fe fdc9 	bl	27d0a <bt_uuid_cmp>
   29178:	2800      	cmp	r0, #0
   2917a:	d1ef      	bne.n	2915c <bt_gatt_attr_value_handle+0x6>
		handle = chrc->value_handle;
   2917c:	68e3      	ldr	r3, [r4, #12]
   2917e:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
   29180:	2800      	cmp	r0, #0
   29182:	d1ec      	bne.n	2915e <bt_gatt_attr_value_handle+0x8>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   29184:	4620      	mov	r0, r4
   29186:	f7e1 fc69 	bl	aa5c <bt_gatt_attr_get_handle>
   2918a:	3001      	adds	r0, #1
   2918c:	b280      	uxth	r0, r0
	return handle;
   2918e:	e7e6      	b.n	2915e <bt_gatt_attr_value_handle+0x8>

00029190 <bt_gatt_attr_read_chrc>:
{
   29190:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   29192:	68cf      	ldr	r7, [r1, #12]
{
   29194:	b087      	sub	sp, #28
   29196:	4608      	mov	r0, r1
   29198:	461c      	mov	r4, r3
	pdu.properties = chrc->properties;
   2919a:	79bb      	ldrb	r3, [r7, #6]
   2919c:	f88d 3004 	strb.w	r3, [sp, #4]
{
   291a0:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
   291a4:	4615      	mov	r5, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   291a6:	f7ff ffd6 	bl	29156 <bt_gatt_attr_value_handle>
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   291aa:	6839      	ldr	r1, [r7, #0]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   291ac:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   291b0:	780b      	ldrb	r3, [r1, #0]
   291b2:	b99b      	cbnz	r3, 291dc <bt_gatt_attr_read_chrc+0x4c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   291b4:	884b      	ldrh	r3, [r1, #2]
   291b6:	f8ad 3007 	strh.w	r3, [sp, #7]
		value_len += 2U;
   291ba:	2105      	movs	r1, #5
	if (offset > value_len) {
   291bc:	42b1      	cmp	r1, r6
   291be:	d315      	bcc.n	291ec <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
   291c0:	1b89      	subs	r1, r1, r6
   291c2:	42a1      	cmp	r1, r4
   291c4:	bfa8      	it	ge
   291c6:	4621      	movge	r1, r4
   291c8:	b28c      	uxth	r4, r1
	memcpy(buf, (uint8_t *)value + offset, len);
   291ca:	ab01      	add	r3, sp, #4
   291cc:	4622      	mov	r2, r4
   291ce:	1999      	adds	r1, r3, r6
   291d0:	4628      	mov	r0, r5
   291d2:	f7fe fb4d 	bl	27870 <memcpy>
}
   291d6:	4620      	mov	r0, r4
   291d8:	b007      	add	sp, #28
   291da:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   291dc:	3101      	adds	r1, #1
   291de:	2210      	movs	r2, #16
   291e0:	f10d 0007 	add.w	r0, sp, #7
   291e4:	f7fe fb44 	bl	27870 <memcpy>
		value_len += 16U;
   291e8:	2113      	movs	r1, #19
   291ea:	e7e7      	b.n	291bc <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   291ec:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   291f0:	e7f1      	b.n	291d6 <bt_gatt_attr_read_chrc+0x46>

000291f2 <bt_gatt_foreach_attr>:
{
   291f2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   291f4:	e9cd 2301 	strd	r2, r3, [sp, #4]
   291f8:	2300      	movs	r3, #0
   291fa:	9300      	str	r3, [sp, #0]
   291fc:	461a      	mov	r2, r3
   291fe:	f7e1 fc5d 	bl	aabc <bt_gatt_foreach_attr_type>
}
   29202:	b005      	add	sp, #20
   29204:	f85d fb04 	ldr.w	pc, [sp], #4

00029208 <bt_gatt_get_mtu>:
	return bt_att_get_mtu(conn);
   29208:	f7ff bd12 	b.w	28c30 <bt_att_get_mtu>

0002920c <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   2920c:	07d3      	lsls	r3, r2, #31
{
   2920e:	b510      	push	{r4, lr}
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   29210:	7c8c      	ldrb	r4, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   29212:	d504      	bpl.n	2921e <bt_gatt_check_perm+0x12>
   29214:	f014 0f15 	tst.w	r4, #21
   29218:	d017      	beq.n	2924a <bt_gatt_check_perm+0x3e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   2921a:	684b      	ldr	r3, [r1, #4]
   2921c:	b1ab      	cbz	r3, 2924a <bt_gatt_check_perm+0x3e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   2921e:	0793      	lsls	r3, r2, #30
   29220:	d504      	bpl.n	2922c <bt_gatt_check_perm+0x20>
   29222:	f014 0f2a 	tst.w	r4, #42	; 0x2a
   29226:	d012      	beq.n	2924e <bt_gatt_check_perm+0x42>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   29228:	688b      	ldr	r3, [r1, #8]
   2922a:	b183      	cbz	r3, 2924e <bt_gatt_check_perm+0x42>
	mask &= attr->perm;
   2922c:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   2922e:	f014 0f30 	tst.w	r4, #48	; 0x30
   29232:	d104      	bne.n	2923e <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   29234:	f014 000c 	ands.w	r0, r4, #12
   29238:	bf18      	it	ne
   2923a:	200f      	movne	r0, #15
}
   2923c:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   2923e:	f7ff f8bf 	bl	283c0 <bt_conn_get_security>
   29242:	2802      	cmp	r0, #2
   29244:	d8f6      	bhi.n	29234 <bt_gatt_check_perm+0x28>
			return BT_ATT_ERR_AUTHENTICATION;
   29246:	2005      	movs	r0, #5
   29248:	e7f8      	b.n	2923c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   2924a:	2002      	movs	r0, #2
   2924c:	e7f6      	b.n	2923c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   2924e:	2003      	movs	r0, #3
   29250:	e7f4      	b.n	2923c <bt_gatt_check_perm+0x30>

00029252 <bt_gatt_change_aware>:
{
   29252:	b538      	push	{r3, r4, r5, lr}
   29254:	460d      	mov	r5, r1
	cfg = find_cf_cfg(conn);
   29256:	f7e0 fedd 	bl	a014 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   2925a:	b910      	cbnz	r0, 29262 <bt_gatt_change_aware+0x10>
		return true;
   2925c:	2501      	movs	r5, #1
}
   2925e:	4628      	mov	r0, r5
   29260:	bd38      	pop	{r3, r4, r5, pc}
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   29262:	7a03      	ldrb	r3, [r0, #8]
   29264:	07d9      	lsls	r1, r3, #31
   29266:	d5f9      	bpl.n	2925c <bt_gatt_change_aware+0xa>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   29268:	f100 040c 	add.w	r4, r0, #12
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2926c:	4620      	mov	r0, r4
   2926e:	f7ff fd82 	bl	28d76 <atomic_get>
   29272:	07c2      	lsls	r2, r0, #31
   29274:	d4f2      	bmi.n	2925c <bt_gatt_change_aware+0xa>
	if (!req) {
   29276:	2d00      	cmp	r5, #0
   29278:	d0f1      	beq.n	2925e <bt_gatt_change_aware+0xc>
   2927a:	4620      	mov	r0, r4
   2927c:	f7ff fd7b 	bl	28d76 <atomic_get>
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   29280:	0783      	lsls	r3, r0, #30
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   29282:	f3c0 0540 	ubfx	r5, r0, #1, #1
   29286:	d509      	bpl.n	2929c <bt_gatt_change_aware+0x4a>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   29288:	f06f 0102 	mvn.w	r1, #2
   2928c:	4620      	mov	r0, r4
   2928e:	f7ff fe16 	bl	28ebe <atomic_and>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   29292:	2101      	movs	r1, #1
   29294:	4620      	mov	r0, r4
   29296:	f7ff fdc9 	bl	28e2c <atomic_or>
}
   2929a:	e7e0      	b.n	2925e <bt_gatt_change_aware+0xc>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2929c:	2102      	movs	r1, #2
   2929e:	e7f9      	b.n	29294 <bt_gatt_change_aware+0x42>

000292a0 <ccc_delayed_store>:
{
   292a0:	b570      	push	{r4, r5, r6, lr}
		struct bt_conn *conn = ccc_store->conn_list[i];
   292a2:	f850 4c08 	ldr.w	r4, [r0, #-8]
{
   292a6:	4605      	mov	r5, r0
		if (!conn) {
   292a8:	b194      	cbz	r4, 292d0 <ccc_delayed_store+0x30>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   292aa:	f104 0688 	add.w	r6, r4, #136	; 0x88
   292ae:	7a20      	ldrb	r0, [r4, #8]
   292b0:	4631      	mov	r1, r6
   292b2:	f7fe fe2d 	bl	27f10 <bt_addr_le_is_bonded>
   292b6:	b158      	cbz	r0, 292d0 <ccc_delayed_store+0x30>
			ccc_store->conn_list[i] = NULL;
   292b8:	2300      	movs	r3, #0
   292ba:	f845 3c08 	str.w	r3, [r5, #-8]
			bt_gatt_store_ccc(conn->id, &conn->le.dst);
   292be:	7a20      	ldrb	r0, [r4, #8]
   292c0:	4631      	mov	r1, r6
   292c2:	f7e2 f9b3 	bl	b62c <bt_gatt_store_ccc>
			bt_conn_unref(conn);
   292c6:	4620      	mov	r0, r4
}
   292c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			bt_conn_unref(conn);
   292cc:	f7ff b80f 	b.w	282ee <bt_conn_unref>
}
   292d0:	bd70      	pop	{r4, r5, r6, pc}

000292d2 <bt_smp_recv>:
{
   292d2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	buf = bt_l2cap_create_pdu(NULL, 0);
   292d4:	2100      	movs	r1, #0
   292d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   292da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	struct bt_conn *conn = chan->conn;
   292de:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   292e0:	4608      	mov	r0, r1
   292e2:	f7ff f902 	bl	284ea <bt_l2cap_create_pdu_timeout>
   292e6:	f100 0608 	add.w	r6, r0, #8
   292ea:	4604      	mov	r4, r0
   292ec:	2101      	movs	r1, #1
   292ee:	4630      	mov	r0, r6
   292f0:	f002 fd24 	bl	2bd3c <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   292f4:	2505      	movs	r5, #5
   292f6:	7005      	strb	r5, [r0, #0]
   292f8:	2101      	movs	r1, #1
   292fa:	4630      	mov	r0, r6
   292fc:	f002 fd1e 	bl	2bd3c <net_buf_simple_add>
   29300:	2300      	movs	r3, #0
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   29302:	7005      	strb	r5, [r0, #0]
   29304:	4622      	mov	r2, r4
   29306:	9300      	str	r3, [sp, #0]
   29308:	2106      	movs	r1, #6
   2930a:	4638      	mov	r0, r7
   2930c:	f7ff f8f0 	bl	284f0 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, BT_L2CAP_CID_SMP, buf)) {
   29310:	b110      	cbz	r0, 29318 <bt_smp_recv+0x46>
		net_buf_unref(buf);
   29312:	4620      	mov	r0, r4
   29314:	f7f7 fabe 	bl	20894 <net_buf_unref>
}
   29318:	2000      	movs	r0, #0
   2931a:	b003      	add	sp, #12
   2931c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002931e <bt_smp_sign>:
   2931e:	f06f 0085 	mvn.w	r0, #133	; 0x85
   29322:	4770      	bx	lr

00029324 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   29324:	2000      	movs	r0, #0
   29326:	4770      	bx	lr

00029328 <model_start>:
	if (mod->cb && mod->cb->start) {
   29328:	6983      	ldr	r3, [r0, #24]
   2932a:	b113      	cbz	r3, 29332 <model_start+0xa>
   2932c:	685b      	ldr	r3, [r3, #4]
   2932e:	b103      	cbz	r3, 29332 <model_start+0xa>
		mod->cb->start(mod);
   29330:	4718      	bx	r3
}
   29332:	4770      	bx	lr

00029334 <bt_mesh_init>:
{
   29334:	b538      	push	{r3, r4, r5, lr}
   29336:	4605      	mov	r5, r0
	err = bt_mesh_comp_register(comp);
   29338:	4608      	mov	r0, r1
   2933a:	f7e7 fd5f 	bl	10dfc <bt_mesh_comp_register>
	if (err) {
   2933e:	4604      	mov	r4, r0
   29340:	b990      	cbnz	r0, 29368 <bt_mesh_init+0x34>
		err = bt_mesh_prov_init(prov);
   29342:	4628      	mov	r0, r5
   29344:	f7ed fc86 	bl	16c54 <bt_mesh_prov_init>
		if (err) {
   29348:	4604      	mov	r4, r0
   2934a:	b968      	cbnz	r0, 29368 <bt_mesh_init+0x34>
	bt_mesh_cfg_default_set();
   2934c:	f7e2 fd6e 	bl	be2c <bt_mesh_cfg_default_set>
	bt_mesh_net_init();
   29350:	f7e4 f8a8 	bl	d4a4 <bt_mesh_net_init>
	bt_mesh_trans_init();
   29354:	f7e5 fd24 	bl	eda0 <bt_mesh_trans_init>
	bt_mesh_hb_init();
   29358:	f7e6 ff84 	bl	10264 <bt_mesh_hb_init>
	bt_mesh_beacon_init();
   2935c:	f7e3 f8b2 	bl	c4c4 <bt_mesh_beacon_init>
	bt_mesh_adv_init();
   29360:	f7eb fe32 	bl	14fc8 <bt_mesh_adv_init>
		bt_mesh_settings_init();
   29364:	f7eb ff5a 	bl	1521c <bt_mesh_settings_init>
}
   29368:	4620      	mov	r0, r4
   2936a:	bd38      	pop	{r3, r4, r5, pc}

0002936c <node_id_is_running>:
	return sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING;
   2936c:	7fc0      	ldrb	r0, [r0, #31]
}
   2936e:	1e43      	subs	r3, r0, #1
   29370:	4258      	negs	r0, r3
   29372:	4158      	adcs	r0, r3
   29374:	4770      	bx	lr

00029376 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   29376:	f3bf 8f5b 	dmb	ish
   2937a:	6800      	ldr	r0, [r0, #0]
   2937c:	f3bf 8f5b 	dmb	ish
}
   29380:	4770      	bx	lr

00029382 <atomic_or.isra.0>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   29382:	f3bf 8f5b 	dmb	ish
   29386:	e850 3f00 	ldrex	r3, [r0]
   2938a:	430b      	orrs	r3, r1
   2938c:	e840 3200 	strex	r2, r3, [r0]
   29390:	2a00      	cmp	r2, #0
   29392:	d1f8      	bne.n	29386 <atomic_or.isra.0+0x4>
   29394:	f3bf 8f5b 	dmb	ish
}
   29398:	4770      	bx	lr

0002939a <bt_mesh_fixed_group_match>:
	switch (addr) {
   2939a:	f5a0 407f 	sub.w	r0, r0, #65280	; 0xff00
   2939e:	38fc      	subs	r0, #252	; 0xfc
{
   293a0:	b508      	push	{r3, lr}
	switch (addr) {
   293a2:	2803      	cmp	r0, #3
   293a4:	d803      	bhi.n	293ae <bt_mesh_fixed_group_match+0x14>
   293a6:	e8df f000 	tbb	[pc, r0]
   293aa:	0a04      	.short	0x0a04
   293ac:	100d      	.short	0x100d
   293ae:	2000      	movs	r0, #0
}
   293b0:	bd08      	pop	{r3, pc}
		return (bt_mesh_gatt_proxy_get() == BT_MESH_FEATURE_ENABLED);
   293b2:	f7e2 fc59 	bl	bc68 <bt_mesh_gatt_proxy_get>
		return (bt_mesh_friend_get() == BT_MESH_FEATURE_ENABLED);
   293b6:	1e43      	subs	r3, r0, #1
   293b8:	4258      	negs	r0, r3
   293ba:	4158      	adcs	r0, r3
   293bc:	e7f8      	b.n	293b0 <bt_mesh_fixed_group_match+0x16>
   293be:	f7e2 fc9b 	bl	bcf8 <bt_mesh_friend_get>
   293c2:	e7f8      	b.n	293b6 <bt_mesh_fixed_group_match+0x1c>
		return (bt_mesh_relay_get() == BT_MESH_FEATURE_ENABLED);
   293c4:	f7e2 fd22 	bl	be0c <bt_mesh_relay_get>
   293c8:	e7f5      	b.n	293b6 <bt_mesh_fixed_group_match+0x1c>
		return true;
   293ca:	2001      	movs	r0, #1
   293cc:	e7f0      	b.n	293b0 <bt_mesh_fixed_group_match+0x16>

000293ce <adv_buf_destroy>:
{
   293ce:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct bt_mesh_adv adv = *BT_MESH_ADV(buf);
   293d0:	6943      	ldr	r3, [r0, #20]
{
   293d2:	4604      	mov	r4, r0
	struct bt_mesh_adv adv = *BT_MESH_ADV(buf);
   293d4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   293d8:	ab04      	add	r3, sp, #16
   293da:	e903 0007 	stmdb	r3, {r0, r1, r2}
   293de:	4605      	mov	r5, r0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   293e0:	79a0      	ldrb	r0, [r4, #6]
   293e2:	460e      	mov	r6, r1
   293e4:	f7f7 f992 	bl	2070c <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   293e8:	4621      	mov	r1, r4
   293ea:	f003 fc02 	bl	2cbf2 <k_queue_prepend>
}

static inline void bt_mesh_adv_send_end(
	int err, struct bt_mesh_adv const *adv)
{
	if (adv->started && adv->cb && adv->cb->end) {
   293ee:	f89d 300c 	ldrb.w	r3, [sp, #12]
   293f2:	075b      	lsls	r3, r3, #29
   293f4:	d508      	bpl.n	29408 <adv_buf_destroy+0x3a>
   293f6:	b13d      	cbz	r5, 29408 <adv_buf_destroy+0x3a>
   293f8:	686b      	ldr	r3, [r5, #4]
   293fa:	b12b      	cbz	r3, 29408 <adv_buf_destroy+0x3a>
		adv->cb->end(err, adv->cb_data);
   293fc:	4631      	mov	r1, r6
   293fe:	2000      	movs	r0, #0
}
   29400:	b004      	add	sp, #16
   29402:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   29406:	4718      	bx	r3
   29408:	b004      	add	sp, #16
   2940a:	bd70      	pop	{r4, r5, r6, pc}

0002940c <bt_mesh_adv_gatt_send>:
{
   2940c:	b508      	push	{r3, lr}
	if (bt_mesh_is_provisioned()) {
   2940e:	f7e2 fad7 	bl	b9c0 <bt_mesh_is_provisioned>
   29412:	b118      	cbz	r0, 2941c <bt_mesh_adv_gatt_send+0x10>
}
   29414:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			return bt_mesh_proxy_adv_start();
   29418:	f7ef bd98 	b.w	18f4c <bt_mesh_proxy_adv_start>
}
   2941c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return bt_mesh_pb_gatt_adv_start();
   29420:	f7ef b97e 	b.w	18720 <bt_mesh_pb_gatt_adv_start>

00029424 <sub_update_beacon_observation>:
	sub->beacons_last = sub->beacons_cur;
   29424:	7943      	ldrb	r3, [r0, #5]
   29426:	7103      	strb	r3, [r0, #4]
	sub->beacons_cur = 0U;
   29428:	2300      	movs	r3, #0
   2942a:	7143      	strb	r3, [r0, #5]
}
   2942c:	4770      	bx	lr

0002942e <beacon_cache_match>:
{
   2942e:	b508      	push	{r3, lr}
	return !memcmp(sub->beacon_cache, beacon_data, 21);
   29430:	2215      	movs	r2, #21
   29432:	3006      	adds	r0, #6
   29434:	f7fe fa0b 	bl	2784e <memcmp>
}
   29438:	fab0 f080 	clz	r0, r0
   2943c:	0940      	lsrs	r0, r0, #5
   2943e:	bd08      	pop	{r3, pc}

00029440 <z_log_msg2_static_create.constprop.0>:
   29440:	2300      	movs	r3, #0
   29442:	f7fc bc49 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00029446 <beacon_complete>:
{
   29446:	b510      	push	{r4, lr}
   29448:	460c      	mov	r4, r1
	return z_impl_k_uptime_ticks();
   2944a:	f003 fe81 	bl	2d150 <z_impl_k_uptime_ticks>
   2944e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   29452:	fba0 0302 	umull	r0, r3, r0, r2
   29456:	fb02 3301 	mla	r3, r2, r1, r3
   2945a:	0bc0      	lsrs	r0, r0, #15
   2945c:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return (uint32_t)k_uptime_get();
   29460:	6020      	str	r0, [r4, #0]
}
   29462:	bd10      	pop	{r4, pc}

00029464 <subnet_evt>:
	if (evt != BT_MESH_KEY_DELETED) {
   29464:	2901      	cmp	r1, #1
   29466:	d001      	beq.n	2946c <subnet_evt+0x8>
		bt_mesh_beacon_update(sub);
   29468:	f7e2 bffc 	b.w	c464 <bt_mesh_beacon_update>
}
   2946c:	4770      	bx	lr

0002946e <subnet_beacon_enable>:
	sub->beacons_last = 0U;
   2946e:	2200      	movs	r2, #0
   29470:	8082      	strh	r2, [r0, #4]
	bt_mesh_beacon_update(sub);
   29472:	f7e2 bff7 	b.w	c464 <bt_mesh_beacon_update>

00029476 <sys_get_be24>:
	return ((uint32_t)src[0] << 16) | sys_get_be16(&src[1]);
   29476:	f8b0 3001 	ldrh.w	r3, [r0, #1]
   2947a:	7802      	ldrb	r2, [r0, #0]
   2947c:	ba5b      	rev16	r3, r3
   2947e:	b29b      	uxth	r3, r3
}
   29480:	ea43 4002 	orr.w	r0, r3, r2, lsl #16
   29484:	4770      	bx	lr

00029486 <z_log_msg2_static_create.constprop.0>:
   29486:	2300      	movs	r3, #0
   29488:	f7fc bc26 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002948c <net_encrypt>:
{
   2948c:	b570      	push	{r4, r5, r6, lr}
   2948e:	460d      	mov	r5, r1
   29490:	4604      	mov	r4, r0
	err = bt_mesh_net_encrypt(cred->enc, buf, iv_index, proxy);
   29492:	4601      	mov	r1, r0
   29494:	1c68      	adds	r0, r5, #1
{
   29496:	4616      	mov	r6, r2
	err = bt_mesh_net_encrypt(cred->enc, buf, iv_index, proxy);
   29498:	f000 fc44 	bl	29d24 <bt_mesh_net_encrypt>
	if (err) {
   2949c:	b938      	cbnz	r0, 294ae <net_encrypt+0x22>
	return bt_mesh_net_obfuscate(buf->data, iv_index, cred->privacy);
   2949e:	6820      	ldr	r0, [r4, #0]
   294a0:	f105 0211 	add.w	r2, r5, #17
   294a4:	4631      	mov	r1, r6
}
   294a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_mesh_net_obfuscate(buf->data, iv_index, cred->privacy);
   294aa:	f7e7 b81d 	b.w	104e8 <bt_mesh_net_obfuscate>
}
   294ae:	bd70      	pop	{r4, r5, r6, pc}

000294b0 <bt_mesh_net_clear>:
{
   294b0:	b508      	push	{r3, lr}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_NET_PENDING);
   294b2:	2003      	movs	r0, #3
   294b4:	f7eb fe3e 	bl	15134 <bt_mesh_settings_store_schedule>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_IV_PENDING);
   294b8:	2004      	movs	r0, #4
   294ba:	f7eb fe3b 	bl	15134 <bt_mesh_settings_store_schedule>
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_CFG_PENDING);
   294be:	2007      	movs	r0, #7
   294c0:	f7eb fe38 	bl	15134 <bt_mesh_settings_store_schedule>
}
   294c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_SEQ_PENDING);
   294c8:	2005      	movs	r0, #5
   294ca:	f7eb be33 	b.w	15134 <bt_mesh_settings_store_schedule>

000294ce <z_log_msg2_static_create.constprop.0>:
   294ce:	2300      	movs	r3, #0
   294d0:	f7fc bc02 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

000294d4 <bt_mesh_friend_cred_create>:
{
   294d4:	b530      	push	{r4, r5, lr}
   294d6:	b087      	sub	sp, #28
	p[0] = 0x01;
   294d8:	2501      	movs	r5, #1
{
   294da:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
	p[0] = 0x01;
   294de:	f88d 500c 	strb.w	r5, [sp, #12]
	dst[1] = val;
   294e2:	f88d 100e 	strb.w	r1, [sp, #14]
	dst[0] = val >> 8;
   294e6:	0a0d      	lsrs	r5, r1, #8
	dst[1] = val;
   294e8:	f88d 2010 	strb.w	r2, [sp, #16]
	dst[0] = val >> 8;
   294ec:	0a11      	lsrs	r1, r2, #8
	dst[1] = val;
   294ee:	f88d 3012 	strb.w	r3, [sp, #18]
	dst[0] = val >> 8;
   294f2:	0a1a      	lsrs	r2, r3, #8
   294f4:	0a23      	lsrs	r3, r4, #8
   294f6:	f88d 3013 	strb.w	r3, [sp, #19]
	return bt_mesh_k2(key, p, p_len, &cred->nid, cred->enc, cred->privacy);
   294fa:	f100 0311 	add.w	r3, r0, #17
   294fe:	9301      	str	r3, [sp, #4]
   29500:	1c43      	adds	r3, r0, #1
   29502:	f88d 100f 	strb.w	r1, [sp, #15]
   29506:	f88d 2011 	strb.w	r2, [sp, #17]
   2950a:	9300      	str	r3, [sp, #0]
   2950c:	2209      	movs	r2, #9
   2950e:	4603      	mov	r3, r0
   29510:	a903      	add	r1, sp, #12
   29512:	980b      	ldr	r0, [sp, #44]	; 0x2c
   29514:	f88d 500d 	strb.w	r5, [sp, #13]
	dst[1] = val;
   29518:	f88d 4014 	strb.w	r4, [sp, #20]
   2951c:	f7e6 ff20 	bl	10360 <bt_mesh_k2>
}
   29520:	b007      	add	sp, #28
   29522:	bd30      	pop	{r4, r5, pc}

00029524 <bt_mesh_subnet_store>:
	update_subnet_settings(net_idx, true);
   29524:	2101      	movs	r1, #1
   29526:	f7e4 b9bf 	b.w	d8a8 <update_subnet_settings>

0002952a <key_refresh>:
{
   2952a:	b538      	push	{r3, r4, r5, lr}
   2952c:	4604      	mov	r4, r0
	switch (new_phase) {
   2952e:	2903      	cmp	r1, #3
   29530:	d809      	bhi.n	29546 <key_refresh+0x1c>
   29532:	e8df f001 	tbb	[pc, r1]
   29536:	0213      	.short	0x0213
   29538:	110d      	.short	0x110d
		sub->kr_phase = new_phase;
   2953a:	2301      	movs	r3, #1
   2953c:	7783      	strb	r3, [r0, #30]
		subnet_evt(sub, BT_MESH_KEY_UPDATED);
   2953e:	2102      	movs	r1, #2
		subnet_evt(sub, BT_MESH_KEY_REVOKED);
   29540:	4620      	mov	r0, r4
   29542:	f7e4 f87d 	bl	d640 <subnet_evt>
		bt_mesh_subnet_store(sub->net_idx);
   29546:	8ba0      	ldrh	r0, [r4, #28]
}
   29548:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_mesh_subnet_store(sub->net_idx);
   2954c:	f7ff bfea 	b.w	29524 <bt_mesh_subnet_store>
		sub->kr_phase = new_phase;
   29550:	2302      	movs	r3, #2
   29552:	7783      	strb	r3, [r0, #30]
		subnet_evt(sub, BT_MESH_KEY_SWAPPED);
   29554:	2103      	movs	r1, #3
   29556:	e7f3      	b.n	29540 <key_refresh+0x16>
		if (sub->kr_phase == BT_MESH_KR_NORMAL) {
   29558:	7f83      	ldrb	r3, [r0, #30]
   2955a:	b163      	cbz	r3, 29576 <key_refresh+0x4c>
		sub->kr_phase = BT_MESH_KR_NORMAL;
   2955c:	2500      	movs	r5, #0
		memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
   2955e:	f104 0186 	add.w	r1, r4, #134	; 0x86
		sub->kr_phase = BT_MESH_KR_NORMAL;
   29562:	77a5      	strb	r5, [r4, #30]
		memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
   29564:	225a      	movs	r2, #90	; 0x5a
   29566:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   2956a:	f7fe f981 	bl	27870 <memcpy>
		sub->keys[1].valid = 0U;
   2956e:	f884 5086 	strb.w	r5, [r4, #134]	; 0x86
		subnet_evt(sub, BT_MESH_KEY_REVOKED);
   29572:	2104      	movs	r1, #4
   29574:	e7e4      	b.n	29540 <key_refresh+0x16>
}
   29576:	bd38      	pop	{r3, r4, r5, pc}

00029578 <bt_mesh_kr_update>:
	if (!new_key) {
   29578:	b16a      	cbz	r2, 29596 <bt_mesh_kr_update+0x1e>
	if (sub->kr_phase == BT_MESH_KR_PHASE_1) {
   2957a:	7f83      	ldrb	r3, [r0, #30]
   2957c:	2b01      	cmp	r3, #1
   2957e:	d105      	bne.n	2958c <bt_mesh_kr_update+0x14>
		key_refresh(sub, (kr_flag ? BT_MESH_KR_PHASE_2 :
   29580:	2900      	cmp	r1, #0
   29582:	bf14      	ite	ne
   29584:	2102      	movne	r1, #2
   29586:	2103      	moveq	r1, #3
		key_refresh(sub, BT_MESH_KR_PHASE_3);
   29588:	f7ff bfcf 	b.w	2952a <key_refresh>
	} else if (sub->kr_phase == BT_MESH_KR_PHASE_2 && !kr_flag) {
   2958c:	2b02      	cmp	r3, #2
   2958e:	d102      	bne.n	29596 <bt_mesh_kr_update+0x1e>
   29590:	b909      	cbnz	r1, 29596 <bt_mesh_kr_update+0x1e>
		key_refresh(sub, BT_MESH_KR_PHASE_3);
   29592:	2103      	movs	r1, #3
   29594:	e7f8      	b.n	29588 <bt_mesh_kr_update+0x10>
}
   29596:	4770      	bx	lr

00029598 <bt_mesh_subnet_add>:
{
   29598:	b570      	push	{r4, r5, r6, lr}
   2959a:	4606      	mov	r6, r0
   2959c:	460c      	mov	r4, r1
	sub = subnet_alloc(net_idx);
   2959e:	f7e4 f861 	bl	d664 <subnet_alloc>
	if (!sub) {
   295a2:	4605      	mov	r5, r0
   295a4:	b1f0      	cbz	r0, 295e4 <bt_mesh_subnet_add+0x4c>
	if (sub->net_idx == net_idx) {
   295a6:	8b83      	ldrh	r3, [r0, #28]
   295a8:	42b3      	cmp	r3, r6
   295aa:	d10a      	bne.n	295c2 <bt_mesh_subnet_add+0x2a>
		if (memcmp(key, sub->keys[0].net, 16)) {
   295ac:	f100 012d 	add.w	r1, r0, #45	; 0x2d
   295b0:	2210      	movs	r2, #16
   295b2:	4620      	mov	r0, r4
   295b4:	f7fe f94b 	bl	2784e <memcmp>
		return STATUS_SUCCESS;
   295b8:	2800      	cmp	r0, #0
   295ba:	bf14      	ite	ne
   295bc:	2006      	movne	r0, #6
   295be:	2000      	moveq	r0, #0
}
   295c0:	bd70      	pop	{r4, r5, r6, pc}
	err = net_keys_create(&sub->keys[0], key);
   295c2:	4621      	mov	r1, r4
   295c4:	302c      	adds	r0, #44	; 0x2c
   295c6:	f7e4 f86d 	bl	d6a4 <net_keys_create>
	if (err) {
   295ca:	4604      	mov	r4, r0
   295cc:	b960      	cbnz	r0, 295e8 <bt_mesh_subnet_add+0x50>
	subnet_evt(sub, BT_MESH_KEY_ADDED);
   295ce:	4601      	mov	r1, r0
	sub->kr_phase = BT_MESH_KR_NORMAL;
   295d0:	83e8      	strh	r0, [r5, #30]
	sub->net_idx = net_idx;
   295d2:	83ae      	strh	r6, [r5, #28]
	subnet_evt(sub, BT_MESH_KEY_ADDED);
   295d4:	4628      	mov	r0, r5
   295d6:	f7e4 f833 	bl	d640 <subnet_evt>
		bt_mesh_subnet_store(sub->net_idx);
   295da:	8ba8      	ldrh	r0, [r5, #28]
   295dc:	f7ff ffa2 	bl	29524 <bt_mesh_subnet_store>
	return STATUS_SUCCESS;
   295e0:	4620      	mov	r0, r4
   295e2:	e7ed      	b.n	295c0 <bt_mesh_subnet_add+0x28>
		return STATUS_INSUFF_RESOURCES;
   295e4:	2005      	movs	r0, #5
   295e6:	e7eb      	b.n	295c0 <bt_mesh_subnet_add+0x28>
		return STATUS_UNSPECIFIED;
   295e8:	2010      	movs	r0, #16
   295ea:	e7e9      	b.n	295c0 <bt_mesh_subnet_add+0x28>

000295ec <subnet_del>:
{
   295ec:	b510      	push	{r4, lr}
   295ee:	4604      	mov	r4, r0
		update_subnet_settings(sub->net_idx, false);
   295f0:	2100      	movs	r1, #0
   295f2:	8b80      	ldrh	r0, [r0, #28]
   295f4:	f7e4 f958 	bl	d8a8 <update_subnet_settings>
	bt_mesh_net_loopback_clear(sub->net_idx);
   295f8:	8ba0      	ldrh	r0, [r4, #28]
   295fa:	f7e3 fcfb 	bl	cff4 <bt_mesh_net_loopback_clear>
	subnet_evt(sub, BT_MESH_KEY_DELETED);
   295fe:	2101      	movs	r1, #1
   29600:	4620      	mov	r0, r4
   29602:	f7e4 f81d 	bl	d640 <subnet_evt>
	(void)memset(sub, 0, sizeof(*sub));
   29606:	22e0      	movs	r2, #224	; 0xe0
   29608:	2100      	movs	r1, #0
   2960a:	4620      	mov	r0, r4
   2960c:	f7fe f93b 	bl	27886 <memset>
	sub->net_idx = BT_MESH_KEY_UNUSED;
   29610:	f64f 73ff 	movw	r3, #65535	; 0xffff
   29614:	83a3      	strh	r3, [r4, #28]
}
   29616:	bd10      	pop	{r4, pc}

00029618 <bt_mesh_subnet_exists>:
{
   29618:	b508      	push	{r3, lr}
	return !!bt_mesh_subnet_get(net_idx);
   2961a:	f7e4 f8f1 	bl	d800 <bt_mesh_subnet_get>
}
   2961e:	3800      	subs	r0, #0
   29620:	bf18      	it	ne
   29622:	2001      	movne	r0, #1
   29624:	bd08      	pop	{r3, pc}

00029626 <bt_mesh_subnet_update>:
{
   29626:	b538      	push	{r3, r4, r5, lr}
	sub = bt_mesh_subnet_get(net_idx);
   29628:	f7e4 f8ea 	bl	d800 <bt_mesh_subnet_get>
{
   2962c:	460c      	mov	r4, r1
	if (!sub) {
   2962e:	4605      	mov	r5, r0
   29630:	b340      	cbz	r0, 29684 <bt_mesh_subnet_update+0x5e>
	switch (sub->kr_phase) {
   29632:	7f83      	ldrb	r3, [r0, #30]
   29634:	2b01      	cmp	r3, #1
   29636:	d00e      	beq.n	29656 <bt_mesh_subnet_update+0x30>
   29638:	d904      	bls.n	29644 <bt_mesh_subnet_update+0x1e>
   2963a:	3b02      	subs	r3, #2
   2963c:	2b01      	cmp	r3, #1
   2963e:	d813      	bhi.n	29668 <bt_mesh_subnet_update+0x42>
		return STATUS_CANNOT_UPDATE;
   29640:	200b      	movs	r0, #11
   29642:	e010      	b.n	29666 <bt_mesh_subnet_update+0x40>
		if (!memcmp(key, sub->keys[0].net, 16)) {
   29644:	f100 012d 	add.w	r1, r0, #45	; 0x2d
   29648:	2210      	movs	r2, #16
   2964a:	4620      	mov	r0, r4
   2964c:	f7fe f8ff 	bl	2784e <memcmp>
   29650:	b950      	cbnz	r0, 29668 <bt_mesh_subnet_update+0x42>
			return STATUS_IDX_ALREADY_STORED;
   29652:	2006      	movs	r0, #6
   29654:	e007      	b.n	29666 <bt_mesh_subnet_update+0x40>
		if (!memcmp(key, sub->keys[1].net, 16)) {
   29656:	f100 0187 	add.w	r1, r0, #135	; 0x87
   2965a:	2210      	movs	r2, #16
   2965c:	4620      	mov	r0, r4
   2965e:	f7fe f8f6 	bl	2784e <memcmp>
   29662:	2800      	cmp	r0, #0
   29664:	d1ec      	bne.n	29640 <bt_mesh_subnet_update+0x1a>
}
   29666:	bd38      	pop	{r3, r4, r5, pc}
	err = net_keys_create(&sub->keys[1], key);
   29668:	4621      	mov	r1, r4
   2966a:	f105 0086 	add.w	r0, r5, #134	; 0x86
   2966e:	f7e4 f819 	bl	d6a4 <net_keys_create>
	if (err) {
   29672:	4604      	mov	r4, r0
   29674:	2800      	cmp	r0, #0
   29676:	d1e3      	bne.n	29640 <bt_mesh_subnet_update+0x1a>
	key_refresh(sub, BT_MESH_KR_PHASE_1);
   29678:	4628      	mov	r0, r5
   2967a:	2101      	movs	r1, #1
   2967c:	f7ff ff55 	bl	2952a <key_refresh>
	return STATUS_SUCCESS;
   29680:	4620      	mov	r0, r4
   29682:	e7f0      	b.n	29666 <bt_mesh_subnet_update+0x40>
		return STATUS_INVALID_NETKEY;
   29684:	2004      	movs	r0, #4
   29686:	e7ee      	b.n	29666 <bt_mesh_subnet_update+0x40>

00029688 <bt_mesh_subnet_del>:
{
   29688:	b508      	push	{r3, lr}
	sub = bt_mesh_subnet_get(net_idx);
   2968a:	f7e4 f8b9 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
   2968e:	b118      	cbz	r0, 29698 <bt_mesh_subnet_del+0x10>
	subnet_del(sub);
   29690:	f7ff ffac 	bl	295ec <subnet_del>
	return STATUS_SUCCESS;
   29694:	2000      	movs	r0, #0
}
   29696:	bd08      	pop	{r3, pc}
		return STATUS_INVALID_NETKEY;
   29698:	2004      	movs	r0, #4
   2969a:	e7fc      	b.n	29696 <bt_mesh_subnet_del+0xe>

0002969c <bt_mesh_subnet_kr_phase_get>:
{
   2969c:	b508      	push	{r3, lr}
	sub = bt_mesh_subnet_get(net_idx);
   2969e:	f7e4 f8af 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
   296a2:	b118      	cbz	r0, 296ac <bt_mesh_subnet_kr_phase_get+0x10>
	*phase = sub->kr_phase;
   296a4:	7f83      	ldrb	r3, [r0, #30]
	return STATUS_SUCCESS;
   296a6:	2000      	movs	r0, #0
   296a8:	700b      	strb	r3, [r1, #0]
}
   296aa:	bd08      	pop	{r3, pc}
		*phase = BT_MESH_KR_NORMAL;
   296ac:	4603      	mov	r3, r0
		return STATUS_INVALID_NETKEY;
   296ae:	2004      	movs	r0, #4
   296b0:	e7fa      	b.n	296a8 <bt_mesh_subnet_kr_phase_get+0xc>

000296b2 <bt_mesh_subnet_node_id_set>:
	if (node_id == BT_MESH_FEATURE_NOT_SUPPORTED) {
   296b2:	2902      	cmp	r1, #2
{
   296b4:	b508      	push	{r3, lr}
	if (node_id == BT_MESH_FEATURE_NOT_SUPPORTED) {
   296b6:	d00c      	beq.n	296d2 <bt_mesh_subnet_node_id_set+0x20>
	sub = bt_mesh_subnet_get(net_idx);
   296b8:	f7e4 f8a2 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
   296bc:	b158      	cbz	r0, 296d6 <bt_mesh_subnet_node_id_set+0x24>
	if (node_id) {
   296be:	b129      	cbz	r1, 296cc <bt_mesh_subnet_node_id_set+0x1a>
		bt_mesh_proxy_identity_start(sub);
   296c0:	f7ef fb06 	bl	18cd0 <bt_mesh_proxy_identity_start>
	bt_mesh_adv_gatt_update();
   296c4:	f000 fdd1 	bl	2a26a <bt_mesh_adv_gatt_update>
	return STATUS_SUCCESS;
   296c8:	2000      	movs	r0, #0
}
   296ca:	bd08      	pop	{r3, pc}
		bt_mesh_proxy_identity_stop(sub);
   296cc:	f7ef fb0a 	bl	18ce4 <bt_mesh_proxy_identity_stop>
   296d0:	e7f8      	b.n	296c4 <bt_mesh_subnet_node_id_set+0x12>
		return STATUS_CANNOT_SET;
   296d2:	200f      	movs	r0, #15
   296d4:	e7f9      	b.n	296ca <bt_mesh_subnet_node_id_set+0x18>
		return STATUS_INVALID_NETKEY;
   296d6:	2004      	movs	r0, #4
   296d8:	e7f7      	b.n	296ca <bt_mesh_subnet_node_id_set+0x18>

000296da <bt_mesh_subnet_node_id_get>:
{
   296da:	b508      	push	{r3, lr}
	sub = bt_mesh_subnet_get(net_idx);
   296dc:	f7e4 f890 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
   296e0:	b118      	cbz	r0, 296ea <bt_mesh_subnet_node_id_get+0x10>
	*node_id = sub->node_id;
   296e2:	7fc3      	ldrb	r3, [r0, #31]
	return STATUS_SUCCESS;
   296e4:	2000      	movs	r0, #0
   296e6:	700b      	strb	r3, [r1, #0]
}
   296e8:	bd08      	pop	{r3, pc}
		*node_id = 0x00;
   296ea:	4603      	mov	r3, r0
		return STATUS_INVALID_NETKEY;
   296ec:	2004      	movs	r0, #4
   296ee:	e7fa      	b.n	296e6 <bt_mesh_subnet_node_id_get+0xc>

000296f0 <bt_mesh_subnet_set>:
{
   296f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   296f4:	4606      	mov	r6, r0
   296f6:	4688      	mov	r8, r1
   296f8:	4617      	mov	r7, r2
   296fa:	461d      	mov	r5, r3
	sub = subnet_alloc(net_idx);
   296fc:	f7e3 ffb2 	bl	d664 <subnet_alloc>
	if (!sub) {
   29700:	4604      	mov	r4, r0
   29702:	b300      	cbz	r0, 29746 <bt_mesh_subnet_set+0x56>
	if (sub->net_idx == net_idx) {
   29704:	8b83      	ldrh	r3, [r0, #28]
   29706:	42b3      	cmp	r3, r6
   29708:	d020      	beq.n	2974c <bt_mesh_subnet_set+0x5c>
		if (!keys[i]) {
   2970a:	b957      	cbnz	r7, 29722 <bt_mesh_subnet_set+0x32>
   2970c:	b99d      	cbnz	r5, 29736 <bt_mesh_subnet_set+0x46>
		sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   2970e:	2500      	movs	r5, #0
	bt_mesh_beacon_update(sub);
   29710:	4620      	mov	r0, r4
	sub->net_idx = net_idx;
   29712:	83a6      	strh	r6, [r4, #28]
	sub->kr_phase = kr_phase;
   29714:	f884 801e 	strb.w	r8, [r4, #30]
		sub->node_id = BT_MESH_NODE_IDENTITY_STOPPED;
   29718:	77e5      	strb	r5, [r4, #31]
	bt_mesh_beacon_update(sub);
   2971a:	f7e2 fea3 	bl	c464 <bt_mesh_beacon_update>
	return 0;
   2971e:	4628      	mov	r0, r5
   29720:	e007      	b.n	29732 <bt_mesh_subnet_set+0x42>
		if (net_keys_create(&sub->keys[i], keys[i])) {
   29722:	4639      	mov	r1, r7
   29724:	302c      	adds	r0, #44	; 0x2c
   29726:	f7e3 ffbd 	bl	d6a4 <net_keys_create>
   2972a:	2800      	cmp	r0, #0
   2972c:	d0ee      	beq.n	2970c <bt_mesh_subnet_set+0x1c>
			return -EIO;
   2972e:	f06f 0004 	mvn.w	r0, #4
}
   29732:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (net_keys_create(&sub->keys[i], keys[i])) {
   29736:	4629      	mov	r1, r5
   29738:	f104 0086 	add.w	r0, r4, #134	; 0x86
   2973c:	f7e3 ffb2 	bl	d6a4 <net_keys_create>
   29740:	2800      	cmp	r0, #0
   29742:	d0e4      	beq.n	2970e <bt_mesh_subnet_set+0x1e>
   29744:	e7f3      	b.n	2972e <bt_mesh_subnet_set+0x3e>
		return -ENOMEM;
   29746:	f06f 000b 	mvn.w	r0, #11
   2974a:	e7f2      	b.n	29732 <bt_mesh_subnet_set+0x42>
		return -EALREADY;
   2974c:	f06f 0077 	mvn.w	r0, #119	; 0x77
   29750:	e7ef      	b.n	29732 <bt_mesh_subnet_set+0x42>

00029752 <app_key_del>:
{
   29752:	b510      	push	{r4, lr}
		update_app_key_settings(app->app_idx, false);
   29754:	2100      	movs	r1, #0
{
   29756:	4604      	mov	r4, r0
		update_app_key_settings(app->app_idx, false);
   29758:	8840      	ldrh	r0, [r0, #2]
   2975a:	f7e4 fb3f 	bl	dddc <update_app_key_settings>
	app_key_evt(app, BT_MESH_KEY_DELETED);
   2975e:	4620      	mov	r0, r4
   29760:	2101      	movs	r1, #1
   29762:	f7e4 fa89 	bl	dc78 <app_key_evt>
	app->net_idx = BT_MESH_KEY_UNUSED;
   29766:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2976a:	8023      	strh	r3, [r4, #0]
	app->app_idx = BT_MESH_KEY_UNUSED;
   2976c:	8063      	strh	r3, [r4, #2]
	(void)memset(app->keys, 0, sizeof(app->keys));
   2976e:	1d60      	adds	r0, r4, #5
   29770:	2222      	movs	r2, #34	; 0x22
}
   29772:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)memset(app->keys, 0, sizeof(app->keys));
   29776:	2100      	movs	r1, #0
   29778:	f7fe b885 	b.w	27886 <memset>

0002977c <bt_mesh_app_key_add>:
{
   2977c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29780:	4607      	mov	r7, r0
	if (!bt_mesh_subnet_get(net_idx)) {
   29782:	4608      	mov	r0, r1
{
   29784:	4688      	mov	r8, r1
   29786:	4616      	mov	r6, r2
	if (!bt_mesh_subnet_get(net_idx)) {
   29788:	f7e4 f83a 	bl	d800 <bt_mesh_subnet_get>
   2978c:	b380      	cbz	r0, 297f0 <bt_mesh_app_key_add+0x74>
	app = app_key_alloc(app_idx);
   2978e:	4638      	mov	r0, r7
   29790:	f7e4 fa86 	bl	dca0 <app_key_alloc>
	if (!app) {
   29794:	4605      	mov	r5, r0
   29796:	b348      	cbz	r0, 297ec <bt_mesh_app_key_add+0x70>
	if (app->app_idx == app_idx) {
   29798:	8843      	ldrh	r3, [r0, #2]
   2979a:	42bb      	cmp	r3, r7
   2979c:	d10d      	bne.n	297ba <bt_mesh_app_key_add+0x3e>
		if (app->net_idx != net_idx) {
   2979e:	8803      	ldrh	r3, [r0, #0]
   297a0:	4543      	cmp	r3, r8
   297a2:	d125      	bne.n	297f0 <bt_mesh_app_key_add+0x74>
		if (memcmp(key, app->keys[0].val, 16)) {
   297a4:	1d81      	adds	r1, r0, #6
   297a6:	2210      	movs	r2, #16
   297a8:	4630      	mov	r0, r6
   297aa:	f7fe f850 	bl	2784e <memcmp>
		return STATUS_SUCCESS;
   297ae:	2800      	cmp	r0, #0
   297b0:	bf14      	ite	ne
   297b2:	2006      	movne	r0, #6
   297b4:	2000      	moveq	r0, #0
}
   297b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return bt_mesh_k4(app_key, app_id);
   297ba:	1d41      	adds	r1, r0, #5
   297bc:	4630      	mov	r0, r6
   297be:	f7e6 fe55 	bl	1046c <bt_mesh_k4>
	if (bt_mesh_app_id(key, &app->keys[0].id)) {
   297c2:	4604      	mov	r4, r0
   297c4:	b9b0      	cbnz	r0, 297f4 <bt_mesh_app_key_add+0x78>
	memcpy(app->keys[0].val, key, 16);
   297c6:	2210      	movs	r2, #16
	app->updated = false;
   297c8:	7128      	strb	r0, [r5, #4]
	memcpy(app->keys[0].val, key, 16);
   297ca:	4631      	mov	r1, r6
	app->net_idx = net_idx;
   297cc:	f8a5 8000 	strh.w	r8, [r5]
	app->app_idx = app_idx;
   297d0:	806f      	strh	r7, [r5, #2]
	memcpy(app->keys[0].val, key, 16);
   297d2:	1da8      	adds	r0, r5, #6
   297d4:	f7fe f84c 	bl	27870 <memcpy>
		update_app_key_settings(app->app_idx, true);
   297d8:	8868      	ldrh	r0, [r5, #2]
   297da:	2101      	movs	r1, #1
   297dc:	f7e4 fafe 	bl	dddc <update_app_key_settings>
	app_key_evt(app, BT_MESH_KEY_ADDED);
   297e0:	4628      	mov	r0, r5
   297e2:	4621      	mov	r1, r4
   297e4:	f7e4 fa48 	bl	dc78 <app_key_evt>
	return STATUS_SUCCESS;
   297e8:	4620      	mov	r0, r4
   297ea:	e7e4      	b.n	297b6 <bt_mesh_app_key_add+0x3a>
		return STATUS_INSUFF_RESOURCES;
   297ec:	2005      	movs	r0, #5
   297ee:	e7e2      	b.n	297b6 <bt_mesh_app_key_add+0x3a>
		return STATUS_INVALID_NETKEY;
   297f0:	2004      	movs	r0, #4
   297f2:	e7e0      	b.n	297b6 <bt_mesh_app_key_add+0x3a>
		return STATUS_CANNOT_SET;
   297f4:	200f      	movs	r0, #15
   297f6:	e7de      	b.n	297b6 <bt_mesh_app_key_add+0x3a>

000297f8 <bt_mesh_app_key_update>:
{
   297f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   297fa:	4616      	mov	r6, r2
	app = app_get(app_idx);
   297fc:	f7e4 fa2a 	bl	dc54 <app_get>
	if (!app) {
   29800:	4605      	mov	r5, r0
   29802:	b3a0      	cbz	r0, 2986e <bt_mesh_app_key_update+0x76>
	if (net_idx != BT_MESH_KEY_UNUSED && app->net_idx != net_idx) {
   29804:	f64f 73ff 	movw	r3, #65535	; 0xffff
   29808:	4299      	cmp	r1, r3
   2980a:	8800      	ldrh	r0, [r0, #0]
   2980c:	d001      	beq.n	29812 <bt_mesh_app_key_update+0x1a>
   2980e:	4281      	cmp	r1, r0
   29810:	d12f      	bne.n	29872 <bt_mesh_app_key_update+0x7a>
	sub = bt_mesh_subnet_get(app->net_idx);
   29812:	f7e3 fff5 	bl	d800 <bt_mesh_subnet_get>
	if (!sub) {
   29816:	b370      	cbz	r0, 29876 <bt_mesh_app_key_update+0x7e>
	if (sub->kr_phase != BT_MESH_KR_PHASE_1) {
   29818:	7f87      	ldrb	r7, [r0, #30]
   2981a:	2f01      	cmp	r7, #1
   2981c:	d001      	beq.n	29822 <bt_mesh_app_key_update+0x2a>
		return STATUS_CANNOT_UPDATE;
   2981e:	200b      	movs	r0, #11
}
   29820:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (app->updated) {
   29822:	792b      	ldrb	r3, [r5, #4]
   29824:	b153      	cbz	r3, 2983c <bt_mesh_app_key_update+0x44>
		if (memcmp(app->keys[1].val, key, 16)) {
   29826:	2210      	movs	r2, #16
   29828:	4631      	mov	r1, r6
   2982a:	f105 0017 	add.w	r0, r5, #23
   2982e:	f7fe f80e 	bl	2784e <memcmp>
		return STATUS_SUCCESS;
   29832:	2800      	cmp	r0, #0
   29834:	bf14      	ite	ne
   29836:	2006      	movne	r0, #6
   29838:	2000      	moveq	r0, #0
   2983a:	e7f1      	b.n	29820 <bt_mesh_app_key_update+0x28>
   2983c:	f105 0116 	add.w	r1, r5, #22
   29840:	4630      	mov	r0, r6
   29842:	f7e6 fe13 	bl	1046c <bt_mesh_k4>
	if (bt_mesh_app_id(key, &app->keys[1].id)) {
   29846:	4604      	mov	r4, r0
   29848:	2800      	cmp	r0, #0
   2984a:	d1e8      	bne.n	2981e <bt_mesh_app_key_update+0x26>
	memcpy(app->keys[1].val, key, 16);
   2984c:	2210      	movs	r2, #16
   2984e:	4631      	mov	r1, r6
	app->updated = true;
   29850:	712f      	strb	r7, [r5, #4]
	memcpy(app->keys[1].val, key, 16);
   29852:	f105 0017 	add.w	r0, r5, #23
   29856:	f7fe f80b 	bl	27870 <memcpy>
		update_app_key_settings(app->app_idx, true);
   2985a:	8868      	ldrh	r0, [r5, #2]
   2985c:	4639      	mov	r1, r7
   2985e:	f7e4 fabd 	bl	dddc <update_app_key_settings>
	app_key_evt(app, BT_MESH_KEY_UPDATED);
   29862:	4628      	mov	r0, r5
   29864:	2102      	movs	r1, #2
   29866:	f7e4 fa07 	bl	dc78 <app_key_evt>
	return STATUS_SUCCESS;
   2986a:	4620      	mov	r0, r4
   2986c:	e7d8      	b.n	29820 <bt_mesh_app_key_update+0x28>
		return STATUS_INVALID_APPKEY;
   2986e:	2003      	movs	r0, #3
   29870:	e7d6      	b.n	29820 <bt_mesh_app_key_update+0x28>
		return STATUS_INVALID_BINDING;
   29872:	2011      	movs	r0, #17
   29874:	e7d4      	b.n	29820 <bt_mesh_app_key_update+0x28>
		return STATUS_INVALID_NETKEY;
   29876:	2004      	movs	r0, #4
   29878:	e7d2      	b.n	29820 <bt_mesh_app_key_update+0x28>

0002987a <bt_mesh_app_key_del>:
{
   2987a:	b538      	push	{r3, r4, r5, lr}
	if (net_idx != BT_MESH_KEY_UNUSED && !bt_mesh_subnet_get(net_idx)) {
   2987c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   29880:	4299      	cmp	r1, r3
{
   29882:	4605      	mov	r5, r0
   29884:	460c      	mov	r4, r1
	if (net_idx != BT_MESH_KEY_UNUSED && !bt_mesh_subnet_get(net_idx)) {
   29886:	d104      	bne.n	29892 <bt_mesh_app_key_del+0x18>
	app = app_get(app_idx);
   29888:	4628      	mov	r0, r5
   2988a:	f7e4 f9e3 	bl	dc54 <app_get>
	if (!app) {
   2988e:	b938      	cbnz	r0, 298a0 <bt_mesh_app_key_del+0x26>
}
   29890:	bd38      	pop	{r3, r4, r5, pc}
	if (net_idx != BT_MESH_KEY_UNUSED && !bt_mesh_subnet_get(net_idx)) {
   29892:	4608      	mov	r0, r1
   29894:	f7e3 ffb4 	bl	d800 <bt_mesh_subnet_get>
   29898:	2800      	cmp	r0, #0
   2989a:	d1f5      	bne.n	29888 <bt_mesh_app_key_del+0xe>
		return STATUS_INVALID_NETKEY;
   2989c:	2004      	movs	r0, #4
   2989e:	e7f7      	b.n	29890 <bt_mesh_app_key_del+0x16>
	if (net_idx != BT_MESH_KEY_UNUSED && net_idx != app->net_idx) {
   298a0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   298a4:	429c      	cmp	r4, r3
   298a6:	d002      	beq.n	298ae <bt_mesh_app_key_del+0x34>
   298a8:	8803      	ldrh	r3, [r0, #0]
   298aa:	42a3      	cmp	r3, r4
   298ac:	d103      	bne.n	298b6 <bt_mesh_app_key_del+0x3c>
	app_key_del(app);
   298ae:	f7ff ff50 	bl	29752 <app_key_del>
	return STATUS_SUCCESS;
   298b2:	2000      	movs	r0, #0
   298b4:	e7ec      	b.n	29890 <bt_mesh_app_key_del+0x16>
		return STATUS_INVALID_BINDING;
   298b6:	2011      	movs	r0, #17
   298b8:	e7ea      	b.n	29890 <bt_mesh_app_key_del+0x16>

000298ba <bt_mesh_app_key_set>:
{
   298ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   298be:	4607      	mov	r7, r0
   298c0:	4688      	mov	r8, r1
   298c2:	4616      	mov	r6, r2
   298c4:	461d      	mov	r5, r3
	app = app_key_alloc(app_idx);
   298c6:	f7e4 f9eb 	bl	dca0 <app_key_alloc>
	if (!app) {
   298ca:	4604      	mov	r4, r0
   298cc:	b348      	cbz	r0, 29922 <bt_mesh_app_key_set+0x68>
	if (app->app_idx == app_idx) {
   298ce:	8843      	ldrh	r3, [r0, #2]
   298d0:	42bb      	cmp	r3, r7
   298d2:	d029      	beq.n	29928 <bt_mesh_app_key_set+0x6e>
	memcpy(app->keys[0].val, old_key, 16);
   298d4:	4631      	mov	r1, r6
   298d6:	2210      	movs	r2, #16
   298d8:	3006      	adds	r0, #6
   298da:	f7fd ffc9 	bl	27870 <memcpy>
   298de:	4630      	mov	r0, r6
   298e0:	1d61      	adds	r1, r4, #5
   298e2:	f7e6 fdc3 	bl	1046c <bt_mesh_k4>
	if (bt_mesh_app_id(old_key, &app->keys[0].id)) {
   298e6:	4606      	mov	r6, r0
   298e8:	b120      	cbz	r0, 298f4 <bt_mesh_app_key_set+0x3a>
		return -EIO;
   298ea:	f06f 0604 	mvn.w	r6, #4
}
   298ee:	4630      	mov	r0, r6
   298f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (new_key) {
   298f4:	b93d      	cbnz	r5, 29906 <bt_mesh_app_key_set+0x4c>
	app->updated = !!new_key;
   298f6:	3d00      	subs	r5, #0
   298f8:	bf18      	it	ne
   298fa:	2501      	movne	r5, #1
	app->net_idx = net_idx;
   298fc:	f8a4 8000 	strh.w	r8, [r4]
	app->app_idx = app_idx;
   29900:	8067      	strh	r7, [r4, #2]
	app->updated = !!new_key;
   29902:	7125      	strb	r5, [r4, #4]
	return 0;
   29904:	e7f3      	b.n	298ee <bt_mesh_app_key_set+0x34>
		memcpy(app->keys[1].val, new_key, 16);
   29906:	4629      	mov	r1, r5
   29908:	2210      	movs	r2, #16
   2990a:	f104 0017 	add.w	r0, r4, #23
   2990e:	f7fd ffaf 	bl	27870 <memcpy>
   29912:	f104 0116 	add.w	r1, r4, #22
   29916:	4628      	mov	r0, r5
   29918:	f7e6 fda8 	bl	1046c <bt_mesh_k4>
		if (bt_mesh_app_id(new_key, &app->keys[1].id)) {
   2991c:	2800      	cmp	r0, #0
   2991e:	d0ea      	beq.n	298f6 <bt_mesh_app_key_set+0x3c>
   29920:	e7e3      	b.n	298ea <bt_mesh_app_key_set+0x30>
		return -ENOMEM;
   29922:	f06f 060b 	mvn.w	r6, #11
   29926:	e7e2      	b.n	298ee <bt_mesh_app_key_set+0x34>
		return 0;
   29928:	2600      	movs	r6, #0
   2992a:	e7e0      	b.n	298ee <bt_mesh_app_key_set+0x34>

0002992c <send_cb_finalize>:
{
   2992c:	b570      	push	{r4, r5, r6, lr}
   2992e:	460d      	mov	r5, r1
	if (!cb) {
   29930:	4604      	mov	r4, r0
   29932:	b160      	cbz	r0, 2994e <send_cb_finalize+0x22>
	if (cb->start) {
   29934:	6803      	ldr	r3, [r0, #0]
   29936:	b11b      	cbz	r3, 29940 <send_cb_finalize+0x14>
		cb->start(0, 0, cb_data);
   29938:	460a      	mov	r2, r1
   2993a:	2100      	movs	r1, #0
   2993c:	4608      	mov	r0, r1
   2993e:	4798      	blx	r3
	if (cb->end) {
   29940:	6863      	ldr	r3, [r4, #4]
   29942:	b123      	cbz	r3, 2994e <send_cb_finalize+0x22>
		cb->end(0, cb_data);
   29944:	4629      	mov	r1, r5
   29946:	2000      	movs	r0, #0
	}
}
   29948:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		cb->end(0, cb_data);
   2994c:	4718      	bx	r3
}
   2994e:	bd70      	pop	{r4, r5, r6, pc}

00029950 <seg_tx_buf_build>:
{
   29950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   29954:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
	uint16_t seq_zero = tx->seq_auth & TRANS_SEQ_ZERO_MASK;
   29958:	f8b0 8010 	ldrh.w	r8, [r0, #16]
		return BT_MESH_APP_SEG_SDU_MAX;
   2995c:	f013 0f02 	tst.w	r3, #2
	uint8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   29960:	8b83      	ldrh	r3, [r0, #28]
		return BT_MESH_APP_SEG_SDU_MAX;
   29962:	bf14      	ite	ne
   29964:	2708      	movne	r7, #8
   29966:	270c      	moveq	r7, #12
	uint8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   29968:	fb07 3311 	mls	r3, r7, r1, r3
{
   2996c:	4604      	mov	r4, r0
	uint8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   2996e:	429f      	cmp	r7, r3
{
   29970:	460e      	mov	r6, r1
	net_buf_simple_add_u8(buf, tx->hdr);
   29972:	7f81      	ldrb	r1, [r0, #30]
   29974:	4610      	mov	r0, r2
{
   29976:	4615      	mov	r5, r2
	uint8_t len = MIN(seg_len(tx->ctl), tx->len - (seg_len(tx->ctl) * seg_o));
   29978:	bfa8      	it	ge
   2997a:	b2df      	uxtbge	r7, r3
	net_buf_simple_add_u8(buf, tx->hdr);
   2997c:	f002 f9ed 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, (tx->aszmic << 7) | seq_zero >> 6);
   29980:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
	uint16_t seq_zero = tx->seq_auth & TRANS_SEQ_ZERO_MASK;
   29984:	f3c8 080c 	ubfx	r8, r8, #0, #13
	net_buf_simple_add_u8(buf, (tx->aszmic << 7) | seq_zero >> 6);
   29988:	f3c3 0380 	ubfx	r3, r3, #2, #1
   2998c:	ea4f 1198 	mov.w	r1, r8, lsr #6
   29990:	ea41 11c3 	orr.w	r1, r1, r3, lsl #7
   29994:	4628      	mov	r0, r5
   29996:	f002 f9e0 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, (((seq_zero & 0x3f) << 2) | (seg_o >> 3)));
   2999a:	08f1      	lsrs	r1, r6, #3
   2999c:	ea41 0188 	orr.w	r1, r1, r8, lsl #2
   299a0:	b2c9      	uxtb	r1, r1
   299a2:	4628      	mov	r0, r5
   299a4:	f002 f9d9 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_u8(buf, ((seg_o & 0x07) << 5) | tx->seg_n);
   299a8:	f894 1020 	ldrb.w	r1, [r4, #32]
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   299ac:	eb04 0486 	add.w	r4, r4, r6, lsl #2
	net_buf_simple_add_u8(buf, ((seg_o & 0x07) << 5) | tx->seg_n);
   299b0:	ea41 1146 	orr.w	r1, r1, r6, lsl #5
   299b4:	b2c9      	uxtb	r1, r1
   299b6:	4628      	mov	r0, r5
   299b8:	f002 f9cf 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   299bc:	6861      	ldr	r1, [r4, #4]
   299be:	463a      	mov	r2, r7
   299c0:	4628      	mov	r0, r5
}
   299c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	net_buf_simple_add_mem(buf, tx->seg[seg_o], len);
   299c6:	f002 b9bf 	b.w	2bd48 <net_buf_simple_add_mem>

000299ca <seg_rx_assemble>:
{
   299ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf->data = buf->__buf;
   299ce:	688b      	ldr	r3, [r1, #8]
   299d0:	600b      	str	r3, [r1, #0]
	buf->len  = 0U;
   299d2:	2500      	movs	r5, #0
   299d4:	4606      	mov	r6, r0
   299d6:	460c      	mov	r4, r1
   299d8:	4617      	mov	r7, r2
   299da:	808d      	strh	r5, [r1, #4]
	for (i = 0; i <= rx->seg_n; i++) {
   299dc:	f100 0804 	add.w	r8, r0, #4
				       MIN(seg_len(rx->ctl),
   299e0:	7ff3      	ldrb	r3, [r6, #31]
		net_buf_simple_add_mem(buf, rx->seg[i],
   299e2:	f858 1b04 	ldr.w	r1, [r8], #4
		return BT_MESH_APP_SEG_SDU_MAX;
   299e6:	f013 0f20 	tst.w	r3, #32
				       MIN(seg_len(rx->ctl),
   299ea:	8bb3      	ldrh	r3, [r6, #28]
		return BT_MESH_APP_SEG_SDU_MAX;
   299ec:	bf14      	ite	ne
   299ee:	2208      	movne	r2, #8
   299f0:	220c      	moveq	r2, #12
				       MIN(seg_len(rx->ctl),
   299f2:	fb05 3312 	mls	r3, r5, r2, r3
		net_buf_simple_add_mem(buf, rx->seg[i],
   299f6:	429a      	cmp	r2, r3
   299f8:	bfa8      	it	ge
   299fa:	461a      	movge	r2, r3
   299fc:	4620      	mov	r0, r4
   299fe:	f002 f9a3 	bl	2bd48 <net_buf_simple_add_mem>
	for (i = 0; i <= rx->seg_n; i++) {
   29a02:	7ff3      	ldrb	r3, [r6, #31]
   29a04:	3501      	adds	r5, #1
   29a06:	461a      	mov	r2, r3
   29a08:	f003 031f 	and.w	r3, r3, #31
   29a0c:	42ab      	cmp	r3, r5
   29a0e:	dae7      	bge.n	299e0 <seg_rx_assemble+0x16>
	if (!rx->ctl) {
   29a10:	0693      	lsls	r3, r2, #26
   29a12:	d406      	bmi.n	29a22 <seg_rx_assemble+0x58>
		buf->len -= APP_MIC_LEN(aszmic);
   29a14:	88a3      	ldrh	r3, [r4, #4]
   29a16:	2f00      	cmp	r7, #0
   29a18:	bf14      	ite	ne
   29a1a:	2208      	movne	r2, #8
   29a1c:	2204      	moveq	r2, #4
   29a1e:	1a9b      	subs	r3, r3, r2
   29a20:	80a3      	strh	r3, [r4, #4]
}
   29a22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00029a26 <ack_timeout>:
{
   29a26:	b538      	push	{r3, r4, r5, lr}
	if (rx->ttl == BT_MESH_TTL_DEFAULT) {
   29a28:	f890 4020 	ldrb.w	r4, [r0, #32]
   29a2c:	2cff      	cmp	r4, #255	; 0xff
{
   29a2e:	4605      	mov	r5, r0
	if (rx->ttl == BT_MESH_TTL_DEFAULT) {
   29a30:	d102      	bne.n	29a38 <ack_timeout+0x12>
		ttl = bt_mesh_default_ttl_get();
   29a32:	f7e2 f941 	bl	bcb8 <bt_mesh_default_ttl_get>
   29a36:	4604      	mov	r4, r0
	to += ((rx->seg_n + 1) - popcount(rx->block)) * 100U;
   29a38:	6a68      	ldr	r0, [r5, #36]	; 0x24
   29a3a:	f7d6 fb6b 	bl	114 <__popcountsi2>
   29a3e:	7feb      	ldrb	r3, [r5, #31]
   29a40:	f003 031f 	and.w	r3, r3, #31
   29a44:	1a18      	subs	r0, r3, r0
   29a46:	2364      	movs	r3, #100	; 0x64
   29a48:	fb00 3303 	mla	r3, r0, r3, r3
	to = 150 + (ttl * 50U);
   29a4c:	2296      	movs	r2, #150	; 0x96
   29a4e:	2032      	movs	r0, #50	; 0x32
   29a50:	fb10 2004 	smlabb	r0, r0, r4, r2
	to += ((rx->seg_n + 1) - popcount(rx->block)) * 100U;
   29a54:	4418      	add	r0, r3
}
   29a56:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
   29a5a:	bfb8      	it	lt
   29a5c:	f44f 70c8 	movlt.w	r0, #400	; 0x190
   29a60:	bd38      	pop	{r3, r4, r5, pc}

00029a62 <sdu_try_decrypt>:
	if (ctx->seg) {
   29a62:	69d0      	ldr	r0, [r2, #28]
{
   29a64:	b570      	push	{r4, r5, r6, lr}
   29a66:	460d      	mov	r5, r1
   29a68:	4614      	mov	r4, r2
	if (ctx->seg) {
   29a6a:	b118      	cbz	r0, 29a74 <sdu_try_decrypt+0x12>
		seg_rx_assemble(ctx->seg, ctx->buf, ctx->crypto.aszmic);
   29a6c:	7852      	ldrb	r2, [r2, #1]
   29a6e:	6961      	ldr	r1, [r4, #20]
   29a70:	f7ff ffab 	bl	299ca <seg_rx_assemble>
	net_buf_simple_reset(ctx->sdu);
   29a74:	69a3      	ldr	r3, [r4, #24]
   29a76:	2200      	movs	r2, #0
   29a78:	809a      	strh	r2, [r3, #4]
	buf->data = buf->__buf;
   29a7a:	689a      	ldr	r2, [r3, #8]
   29a7c:	601a      	str	r2, [r3, #0]
	return bt_mesh_app_decrypt(key, &ctx->crypto, ctx->buf, ctx->sdu);
   29a7e:	4621      	mov	r1, r4
   29a80:	6962      	ldr	r2, [r4, #20]
   29a82:	4628      	mov	r0, r5
}
   29a84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_mesh_app_decrypt(key, &ctx->crypto, ctx->buf, ctx->sdu);
   29a88:	f000 ba09 	b.w	29e9e <bt_mesh_app_decrypt>

00029a8c <schedule_retransmit>:
{
   29a8c:	b510      	push	{r4, lr}
	if (!tx->nack_count) {
   29a8e:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
   29a92:	b38b      	cbz	r3, 29af8 <schedule_retransmit+0x6c>
	if (--tx->seg_pending || tx->sending) {
   29a94:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
   29a98:	3b01      	subs	r3, #1
   29a9a:	b2db      	uxtb	r3, r3
   29a9c:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
   29aa0:	bb53      	cbnz	r3, 29af8 <schedule_retransmit+0x6c>
   29aa2:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
   29aa6:	06db      	lsls	r3, r3, #27
   29aa8:	d426      	bmi.n	29af8 <schedule_retransmit+0x6c>
	k_work_reschedule(&tx->retransmit,
   29aaa:	f890 1021 	ldrb.w	r1, [r0, #33]	; 0x21
   29aae:	f100 0430 	add.w	r4, r0, #48	; 0x30
   29ab2:	b131      	cbz	r1, 29ac2 <schedule_retransmit+0x36>
   29ab4:	2200      	movs	r2, #0
   29ab6:	4613      	mov	r3, r2
   29ab8:	4620      	mov	r0, r4
}
   29aba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_reschedule(&tx->retransmit,
   29abe:	f7fa bc51 	b.w	24364 <k_work_reschedule>
			  K_MSEC(SEG_RETRANSMIT_TIMEOUT(tx)));
   29ac2:	f9b0 301a 	ldrsh.w	r3, [r0, #26]
   29ac6:	2b00      	cmp	r3, #0
   29ac8:	bfc8      	it	gt
   29aca:	f890 2024 	ldrbgt.w	r2, [r0, #36]	; 0x24
   29ace:	f04f 0332 	mov.w	r3, #50	; 0x32
   29ad2:	bfc5      	ittet	gt
   29ad4:	f44f 70c8 	movgt.w	r0, #400	; 0x190
   29ad8:	fb03 0002 	mlagt	r0, r3, r2, r0
   29adc:	4618      	movle	r0, r3
   29ade:	2100      	movgt	r1, #0
   29ae0:	03c0      	lsls	r0, r0, #15
   29ae2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   29ae6:	2300      	movs	r3, #0
   29ae8:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   29aec:	03c9      	lsls	r1, r1, #15
   29aee:	f7d6 faf7 	bl	e0 <__aeabi_uldivmod>
   29af2:	4602      	mov	r2, r0
   29af4:	460b      	mov	r3, r1
   29af6:	e7df      	b.n	29ab8 <schedule_retransmit+0x2c>
}
   29af8:	bd10      	pop	{r4, pc}

00029afa <seg_sent>:
	schedule_retransmit(tx);
   29afa:	4608      	mov	r0, r1
   29afc:	f7ff bfc6 	b.w	29a8c <schedule_retransmit>

00029b00 <seg_send_start>:
{
   29b00:	b538      	push	{r3, r4, r5, lr}
	if (!tx->started && tx->cb && tx->cb->start) {
   29b02:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
   29b06:	071b      	lsls	r3, r3, #28
{
   29b08:	460d      	mov	r5, r1
   29b0a:	4614      	mov	r4, r2
	if (!tx->started && tx->cb && tx->cb->start) {
   29b0c:	d40b      	bmi.n	29b26 <seg_send_start+0x26>
   29b0e:	6a93      	ldr	r3, [r2, #40]	; 0x28
   29b10:	b14b      	cbz	r3, 29b26 <seg_send_start+0x26>
   29b12:	681b      	ldr	r3, [r3, #0]
   29b14:	b13b      	cbz	r3, 29b26 <seg_send_start+0x26>
		tx->cb->start(duration, err, tx->cb_data);
   29b16:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   29b18:	4798      	blx	r3
		tx->started = 1U;
   29b1a:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
   29b1e:	f043 0308 	orr.w	r3, r3, #8
   29b22:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
	if (err) {
   29b26:	b125      	cbz	r5, 29b32 <seg_send_start+0x32>
		schedule_retransmit(tx);
   29b28:	4620      	mov	r0, r4
}
   29b2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		schedule_retransmit(tx);
   29b2e:	f7ff bfad 	b.w	29a8c <schedule_retransmit>
}
   29b32:	bd38      	pop	{r3, r4, r5, pc}

00029b34 <z_log_msg2_static_create.constprop.0>:
   29b34:	2300      	movs	r3, #0
   29b36:	f7fc b8cf 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00029b3a <seg_retransmit>:
	seg_tx_send_unacked(tx);
   29b3a:	3830      	subs	r0, #48	; 0x30
   29b3c:	f7e4 bc9c 	b.w	e478 <seg_tx_send_unacked>

00029b40 <send_ack.isra.0>:
static int send_ack(struct bt_mesh_subnet *sub, uint16_t src, uint16_t dst,
   29b40:	b5f0      	push	{r4, r5, r6, r7, lr}
   29b42:	b08b      	sub	sp, #44	; 0x2c
	struct bt_mesh_msg_ctx ctx = {
   29b44:	8b87      	ldrh	r7, [r0, #28]
static int send_ack(struct bt_mesh_subnet *sub, uint16_t src, uint16_t dst,
   29b46:	f89d 4048 	ldrb.w	r4, [sp, #72]	; 0x48
	struct bt_mesh_msg_ctx ctx = {
   29b4a:	f8ad 7010 	strh.w	r7, [sp, #16]
static int send_ack(struct bt_mesh_subnet *sub, uint16_t src, uint16_t dst,
   29b4e:	460d      	mov	r5, r1
	struct bt_mesh_msg_ctx ctx = {
   29b50:	f64f 77ff 	movw	r7, #65535	; 0xffff
   29b54:	2100      	movs	r1, #0
   29b56:	f88d 301b 	strb.w	r3, [sp, #27]
	struct bt_mesh_net_tx tx = {
   29b5a:	ab04      	add	r3, sp, #16
static int send_ack(struct bt_mesh_subnet *sub, uint16_t src, uint16_t dst,
   29b5c:	9e11      	ldr	r6, [sp, #68]	; 0x44
	struct bt_mesh_msg_ctx ctx = {
   29b5e:	f8cd 1016 	str.w	r1, [sp, #22]
   29b62:	f88d 101a 	strb.w	r1, [sp, #26]
   29b66:	f8ad 7012 	strh.w	r7, [sp, #18]
   29b6a:	f8ad 2014 	strh.w	r2, [sp, #20]
	struct bt_mesh_net_tx tx = {
   29b6e:	9109      	str	r1, [sp, #36]	; 0x24
   29b70:	9007      	str	r0, [sp, #28]
   29b72:	9308      	str	r3, [sp, #32]
   29b74:	b36c      	cbz	r4, 29bd2 <send_ack.isra.0+0x92>
		.src = obo ? bt_mesh_primary_addr() : src,
   29b76:	f7e7 f975 	bl	10e64 <bt_mesh_primary_addr>
	struct bt_mesh_net_tx tx = {
   29b7a:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
		.xmit = bt_mesh_net_transmit_get(),
   29b7e:	f7e2 f8db 	bl	bd38 <bt_mesh_net_transmit_get>
	if (!BT_MESH_ADDR_IS_UNICAST(src)) {
   29b82:	b22d      	sxth	r5, r5
   29b84:	2d00      	cmp	r5, #0
	struct bt_mesh_net_tx tx = {
   29b86:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
	if (!BT_MESH_ADDR_IS_UNICAST(src)) {
   29b8a:	dd20      	ble.n	29bce <send_ack.isra.0+0x8e>
	uint16_t seq_zero = *seq_auth & TRANS_SEQ_ZERO_MASK;
   29b8c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   29b8e:	f88d 600d 	strb.w	r6, [sp, #13]
   29b92:	881b      	ldrh	r3, [r3, #0]
	sys_put_be16(((seq_zero << 2) & 0x7ffc) | (obo << 15), buf);
   29b94:	03e4      	lsls	r4, r4, #15
   29b96:	f3c3 030c 	ubfx	r3, r3, #0, #13
   29b9a:	ea44 0483 	orr.w	r4, r4, r3, lsl #2
	dst[0] = val >> 8;
   29b9e:	f3c4 2307 	ubfx	r3, r4, #8, #8
   29ba2:	f88d 3008 	strb.w	r3, [sp, #8]
	sys_put_be16(val >> 16, dst);
   29ba6:	0c33      	lsrs	r3, r6, #16
	dst[0] = val >> 8;
   29ba8:	0e32      	lsrs	r2, r6, #24
	dst[1] = val;
   29baa:	f88d 300b 	strb.w	r3, [sp, #11]
	return bt_mesh_ctl_send(&tx, TRANS_CTL_OP_ACK, buf, sizeof(buf),
   29bae:	2100      	movs	r1, #0
	dst[0] = val >> 8;
   29bb0:	f3c6 2307 	ubfx	r3, r6, #8, #8
   29bb4:	f88d 200a 	strb.w	r2, [sp, #10]
   29bb8:	f88d 300c 	strb.w	r3, [sp, #12]
   29bbc:	e9cd 1100 	strd	r1, r1, [sp]
   29bc0:	2306      	movs	r3, #6
   29bc2:	aa02      	add	r2, sp, #8
   29bc4:	a807      	add	r0, sp, #28
	dst[1] = val;
   29bc6:	f88d 4009 	strb.w	r4, [sp, #9]
   29bca:	f7e4 fffd 	bl	ebc8 <bt_mesh_ctl_send>
}
   29bce:	b00b      	add	sp, #44	; 0x2c
   29bd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct bt_mesh_net_tx tx = {
   29bd2:	4628      	mov	r0, r5
   29bd4:	e7d1      	b.n	29b7a <send_ack.isra.0+0x3a>

00029bd6 <bt_mesh_rpl_update>:
	if (rpl->old_iv && !rx->old_iv) {
   29bd6:	f990 3001 	ldrsb.w	r3, [r0, #1]
   29bda:	2b00      	cmp	r3, #0
   29bdc:	da07      	bge.n	29bee <bt_mesh_rpl_update+0x18>
   29bde:	7d0b      	ldrb	r3, [r1, #20]
   29be0:	f013 0301 	ands.w	r3, r3, #1
		rpl->seg = 0;
   29be4:	bf02      	ittt	eq
   29be6:	6842      	ldreq	r2, [r0, #4]
   29be8:	f363 221f 	bfieq	r2, r3, #8, #24
   29bec:	6042      	streq	r2, [r0, #4]
	rpl->seq = rx->seq;
   29bee:	8a0a      	ldrh	r2, [r1, #16]
	rpl->src = rx->ctx.addr;
   29bf0:	890b      	ldrh	r3, [r1, #8]
	rpl->seq = rx->seq;
   29bf2:	8042      	strh	r2, [r0, #2]
   29bf4:	7c8a      	ldrb	r2, [r1, #18]
   29bf6:	7102      	strb	r2, [r0, #4]
	rpl->old_iv = rx->old_iv;
   29bf8:	7d0a      	ldrb	r2, [r1, #20]
	rpl->src = rx->ctx.addr;
   29bfa:	f3c3 030e 	ubfx	r3, r3, #0, #15
   29bfe:	f002 0201 	and.w	r2, r2, #1
   29c02:	ea43 33c2 	orr.w	r3, r3, r2, lsl #15
   29c06:	8003      	strh	r3, [r0, #0]
		schedule_rpl_store(rpl, false);
   29c08:	f7e5 bed0 	b.w	f9ac <schedule_rpl_store.constprop.0>

00029c0c <bt_mesh_rpl_clear>:
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_RPL_PENDING);
   29c0c:	2000      	movs	r0, #0
   29c0e:	f7eb ba91 	b.w	15134 <bt_mesh_settings_store_schedule>

00029c12 <hb_publish_start_cb>:
{
   29c12:	4608      	mov	r0, r1
   29c14:	4611      	mov	r1, r2
	if (err) {
   29c16:	b108      	cbz	r0, 29c1c <hb_publish_start_cb+0xa>
		hb_publish_end_cb(err, cb_data);
   29c18:	f7e6 b8d4 	b.w	fdc4 <hb_publish_end_cb>
}
   29c1c:	4770      	bx	lr

00029c1e <sys_put_be32>:
	sys_put_be16(val >> 16, dst);
   29c1e:	0c03      	lsrs	r3, r0, #16
	dst[0] = val >> 8;
   29c20:	0e02      	lsrs	r2, r0, #24
	dst[1] = val;
   29c22:	704b      	strb	r3, [r1, #1]
	dst[0] = val >> 8;
   29c24:	f3c0 2307 	ubfx	r3, r0, #8, #8
   29c28:	700a      	strb	r2, [r1, #0]
   29c2a:	708b      	strb	r3, [r1, #2]
	dst[1] = val;
   29c2c:	70c8      	strb	r0, [r1, #3]
}
   29c2e:	4770      	bx	lr

00029c30 <create_app_nonce>:
{
   29c30:	b538      	push	{r3, r4, r5, lr}
	if (ctx->dev_key) {
   29c32:	780b      	ldrb	r3, [r1, #0]
{
   29c34:	460c      	mov	r4, r1
		nonce[0] = 0x01;
   29c36:	2b00      	cmp	r3, #0
   29c38:	4601      	mov	r1, r0
   29c3a:	bf14      	ite	ne
   29c3c:	2302      	movne	r3, #2
   29c3e:	2301      	moveq	r3, #1
   29c40:	f801 3b01 	strb.w	r3, [r1], #1
{
   29c44:	4605      	mov	r5, r0
	sys_put_be32((ctx->seq_num | ((uint32_t)ctx->aszmic << 31)), &nonce[1]);
   29c46:	68a3      	ldr	r3, [r4, #8]
   29c48:	7860      	ldrb	r0, [r4, #1]
   29c4a:	ea43 70c0 	orr.w	r0, r3, r0, lsl #31
   29c4e:	f7ff ffe6 	bl	29c1e <sys_put_be32>
	sys_put_be16(ctx->src, &nonce[5]);
   29c52:	8863      	ldrh	r3, [r4, #2]
	dst[1] = val;
   29c54:	71ab      	strb	r3, [r5, #6]
	dst[0] = val >> 8;
   29c56:	0a1a      	lsrs	r2, r3, #8
   29c58:	716a      	strb	r2, [r5, #5]
	sys_put_be16(ctx->dst, &nonce[7]);
   29c5a:	88a3      	ldrh	r3, [r4, #4]
	dst[1] = val;
   29c5c:	722b      	strb	r3, [r5, #8]
	dst[0] = val >> 8;
   29c5e:	0a1a      	lsrs	r2, r3, #8
   29c60:	71ea      	strb	r2, [r5, #7]
	sys_put_be32(ctx->iv_index, &nonce[9]);
   29c62:	68e0      	ldr	r0, [r4, #12]
   29c64:	f105 0109 	add.w	r1, r5, #9
}
   29c68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	sys_put_be32(ctx->iv_index, &nonce[9]);
   29c6c:	f7ff bfd7 	b.w	29c1e <sys_put_be32>

00029c70 <bt_mesh_aes_cmac>:
{
   29c70:	b570      	push	{r4, r5, r6, lr}
   29c72:	b0c2      	sub	sp, #264	; 0x108
   29c74:	460d      	mov	r5, r1
   29c76:	4614      	mov	r4, r2
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   29c78:	4601      	mov	r1, r0
   29c7a:	aa16      	add	r2, sp, #88	; 0x58
   29c7c:	4668      	mov	r0, sp
{
   29c7e:	461e      	mov	r6, r3
	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
   29c80:	f7fd fbe4 	bl	2744c <tc_cmac_setup>
   29c84:	b130      	cbz	r0, 29c94 <bt_mesh_aes_cmac+0x24>
   29c86:	3508      	adds	r5, #8
	for (; sg_len; sg_len--, sg++) {
   29c88:	b944      	cbnz	r4, 29c9c <bt_mesh_aes_cmac+0x2c>
	if (tc_cmac_final(mac, &state) == TC_CRYPTO_FAIL) {
   29c8a:	4669      	mov	r1, sp
   29c8c:	4630      	mov	r0, r6
   29c8e:	f7fd fc73 	bl	27578 <tc_cmac_final>
   29c92:	b968      	cbnz	r0, 29cb0 <bt_mesh_aes_cmac+0x40>
		return -EIO;
   29c94:	f06f 0004 	mvn.w	r0, #4
}
   29c98:	b042      	add	sp, #264	; 0x108
   29c9a:	bd70      	pop	{r4, r5, r6, pc}
		if (tc_cmac_update(&state, sg->data,
   29c9c:	e955 1202 	ldrd	r1, r2, [r5, #-8]
   29ca0:	4668      	mov	r0, sp
   29ca2:	f7fd fbfe 	bl	274a2 <tc_cmac_update>
   29ca6:	3508      	adds	r5, #8
   29ca8:	2800      	cmp	r0, #0
   29caa:	d0f3      	beq.n	29c94 <bt_mesh_aes_cmac+0x24>
	for (; sg_len; sg_len--, sg++) {
   29cac:	3c01      	subs	r4, #1
   29cae:	e7eb      	b.n	29c88 <bt_mesh_aes_cmac+0x18>
	return 0;
   29cb0:	4620      	mov	r0, r4
   29cb2:	e7f1      	b.n	29c98 <bt_mesh_aes_cmac+0x28>

00029cb4 <bt_mesh_aes_cmac_one>:
{
   29cb4:	b507      	push	{r0, r1, r2, lr}
	struct bt_mesh_sg sg = { m, len };
   29cb6:	e9cd 1200 	strd	r1, r2, [sp]
	return bt_mesh_aes_cmac(key, &sg, 1, mac);
   29cba:	2201      	movs	r2, #1
   29cbc:	4669      	mov	r1, sp
   29cbe:	f7ff ffd7 	bl	29c70 <bt_mesh_aes_cmac>
}
   29cc2:	b003      	add	sp, #12
   29cc4:	f85d fb04 	ldr.w	pc, [sp], #4

00029cc8 <bt_mesh_s1>:
{
   29cc8:	b530      	push	{r4, r5, lr}
	const uint8_t zero[16] = { 0 };
   29cca:	2200      	movs	r2, #0
{
   29ccc:	b085      	sub	sp, #20
   29cce:	460d      	mov	r5, r1
	const uint8_t zero[16] = { 0 };
   29cd0:	e9cd 2200 	strd	r2, r2, [sp]
   29cd4:	e9cd 2202 	strd	r2, r2, [sp, #8]
{
   29cd8:	4604      	mov	r4, r0
	return bt_mesh_aes_cmac_one(zero, m, strlen(m), salt);
   29cda:	f7fd fd8b 	bl	277f4 <strlen>
   29cde:	462b      	mov	r3, r5
   29ce0:	4602      	mov	r2, r0
   29ce2:	4621      	mov	r1, r4
   29ce4:	4668      	mov	r0, sp
   29ce6:	f7ff ffe5 	bl	29cb4 <bt_mesh_aes_cmac_one>
}
   29cea:	3800      	subs	r0, #0
   29cec:	bf18      	it	ne
   29cee:	2001      	movne	r0, #1
   29cf0:	b005      	add	sp, #20
   29cf2:	bd30      	pop	{r4, r5, pc}

00029cf4 <bt_mesh_k1>:
{
   29cf4:	b570      	push	{r4, r5, r6, lr}
   29cf6:	9d04      	ldr	r5, [sp, #16]
   29cf8:	4606      	mov	r6, r0
   29cfa:	461c      	mov	r4, r3
   29cfc:	4610      	mov	r0, r2
	err = bt_mesh_aes_cmac_one(salt, ikm, ikm_len, okm);
   29cfe:	462b      	mov	r3, r5
   29d00:	460a      	mov	r2, r1
   29d02:	4631      	mov	r1, r6
   29d04:	f7ff ffd6 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (err < 0) {
   29d08:	2800      	cmp	r0, #0
   29d0a:	db0a      	blt.n	29d22 <bt_mesh_k1+0x2e>
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
   29d0c:	4620      	mov	r0, r4
   29d0e:	f7fd fd71 	bl	277f4 <strlen>
   29d12:	462b      	mov	r3, r5
   29d14:	4602      	mov	r2, r0
   29d16:	4621      	mov	r1, r4
   29d18:	4628      	mov	r0, r5
}
   29d1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_mesh_aes_cmac_one(okm, info, strlen(info), okm);
   29d1e:	f7ff bfc9 	b.w	29cb4 <bt_mesh_aes_cmac_one>
}
   29d22:	bd70      	pop	{r4, r5, r6, pc}

00029d24 <bt_mesh_net_encrypt>:
{
   29d24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29d28:	680c      	ldr	r4, [r1, #0]
{
   29d2a:	4607      	mov	r7, r0
   29d2c:	4610      	mov	r0, r2
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29d2e:	f994 2001 	ldrsb.w	r2, [r4, #1]
   29d32:	f894 9001 	ldrb.w	r9, [r4, #1]
	nonce[2] = pdu[2];
   29d36:	f894 8002 	ldrb.w	r8, [r4, #2]
	nonce[3] = pdu[3];
   29d3a:	f894 e003 	ldrb.w	lr, [r4, #3]
	nonce[4] = pdu[4];
   29d3e:	f894 c004 	ldrb.w	ip, [r4, #4]
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29d42:	2a00      	cmp	r2, #0
{
   29d44:	460d      	mov	r5, r1
	nonce[6] = pdu[6];
   29d46:	79a2      	ldrb	r2, [r4, #6]
	nonce[5] = pdu[5];
   29d48:	7961      	ldrb	r1, [r4, #5]
{
   29d4a:	b089      	sub	sp, #36	; 0x24
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29d4c:	bfb4      	ite	lt
   29d4e:	2608      	movlt	r6, #8
   29d50:	2604      	movge	r6, #4
	if (IS_ENABLED(CONFIG_BT_MESH_PROXY) && proxy) {
   29d52:	b373      	cbz	r3, 29db2 <bt_mesh_net_encrypt+0x8e>
	nonce[0] = 0x03;
   29d54:	2303      	movs	r3, #3
   29d56:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = 0x00;
   29d5a:	2300      	movs	r3, #0
   29d5c:	f88d 3011 	strb.w	r3, [sp, #17]
	nonce[5] = pdu[5];
   29d60:	f88d 1015 	strb.w	r1, [sp, #21]
	sys_put_be32(iv_index, &nonce[9]);
   29d64:	f10d 0119 	add.w	r1, sp, #25
	nonce[3] = pdu[3];
   29d68:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   29d6c:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[6] = pdu[6];
   29d70:	f88d 2016 	strb.w	r2, [sp, #22]
	nonce[7] = 0U;
   29d74:	f88d 3017 	strb.w	r3, [sp, #23]
	nonce[8] = 0U;
   29d78:	f88d 3018 	strb.w	r3, [sp, #24]
	nonce[2] = pdu[2];
   29d7c:	f88d 8012 	strb.w	r8, [sp, #18]
	sys_put_be32(iv_index, &nonce[9]);
   29d80:	f7ff ff4d 	bl	29c1e <sys_put_be32>
	err = bt_ccm_encrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   29d84:	682a      	ldr	r2, [r5, #0]
   29d86:	88ab      	ldrh	r3, [r5, #4]
   29d88:	3207      	adds	r2, #7
   29d8a:	2100      	movs	r1, #0
   29d8c:	e9cd 1100 	strd	r1, r1, [sp]
   29d90:	e9cd 2602 	strd	r2, r6, [sp, #8]
   29d94:	3b07      	subs	r3, #7
   29d96:	a904      	add	r1, sp, #16
   29d98:	4638      	mov	r0, r7
   29d9a:	f7fd ff8e 	bl	27cba <bt_ccm_encrypt>
	if (!err) {
   29d9e:	4604      	mov	r4, r0
   29da0:	b918      	cbnz	r0, 29daa <bt_mesh_net_encrypt+0x86>
		net_buf_simple_add(buf, mic_len);
   29da2:	4631      	mov	r1, r6
   29da4:	4628      	mov	r0, r5
   29da6:	f001 ffc9 	bl	2bd3c <net_buf_simple_add>
}
   29daa:	4620      	mov	r0, r4
   29dac:	b009      	add	sp, #36	; 0x24
   29dae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nonce[0] = 0x00;
   29db2:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = pdu[1];
   29db6:	f88d 9011 	strb.w	r9, [sp, #17]
   29dba:	e7d1      	b.n	29d60 <bt_mesh_net_encrypt+0x3c>

00029dbc <bt_mesh_net_decrypt>:
{
   29dbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29dc0:	680c      	ldr	r4, [r1, #0]
{
   29dc2:	4606      	mov	r6, r0
   29dc4:	4610      	mov	r0, r2
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29dc6:	f994 2001 	ldrsb.w	r2, [r4, #1]
   29dca:	f894 9001 	ldrb.w	r9, [r4, #1]
	nonce[2] = pdu[2];
   29dce:	f894 8002 	ldrb.w	r8, [r4, #2]
	nonce[3] = pdu[3];
   29dd2:	f894 e003 	ldrb.w	lr, [r4, #3]
	nonce[4] = pdu[4];
   29dd6:	f894 c004 	ldrb.w	ip, [r4, #4]
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29dda:	2a00      	cmp	r2, #0
{
   29ddc:	460d      	mov	r5, r1
	nonce[6] = pdu[6];
   29dde:	79a2      	ldrb	r2, [r4, #6]
	nonce[5] = pdu[5];
   29de0:	7961      	ldrb	r1, [r4, #5]
{
   29de2:	b089      	sub	sp, #36	; 0x24
	uint8_t mic_len = NET_MIC_LEN(buf->data);
   29de4:	bfb4      	ite	lt
   29de6:	2708      	movlt	r7, #8
   29de8:	2704      	movge	r7, #4
	if (IS_ENABLED(CONFIG_BT_MESH_PROXY) && proxy) {
   29dea:	b353      	cbz	r3, 29e42 <bt_mesh_net_decrypt+0x86>
	nonce[0] = 0x03;
   29dec:	2303      	movs	r3, #3
   29dee:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = 0x00;
   29df2:	2300      	movs	r3, #0
   29df4:	f88d 3011 	strb.w	r3, [sp, #17]
	nonce[5] = pdu[5];
   29df8:	f88d 1015 	strb.w	r1, [sp, #21]
	sys_put_be32(iv_index, &nonce[9]);
   29dfc:	f10d 0119 	add.w	r1, sp, #25
	nonce[3] = pdu[3];
   29e00:	f88d e013 	strb.w	lr, [sp, #19]
	nonce[4] = pdu[4];
   29e04:	f88d c014 	strb.w	ip, [sp, #20]
	nonce[6] = pdu[6];
   29e08:	f88d 2016 	strb.w	r2, [sp, #22]
	nonce[7] = 0U;
   29e0c:	f88d 3017 	strb.w	r3, [sp, #23]
	nonce[8] = 0U;
   29e10:	f88d 3018 	strb.w	r3, [sp, #24]
	nonce[2] = pdu[2];
   29e14:	f88d 8012 	strb.w	r8, [sp, #18]
	sys_put_be32(iv_index, &nonce[9]);
   29e18:	f7ff ff01 	bl	29c1e <sys_put_be32>
	buf->len -= mic_len;
   29e1c:	88ab      	ldrh	r3, [r5, #4]
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   29e1e:	682a      	ldr	r2, [r5, #0]
	buf->len -= mic_len;
   29e20:	1bdb      	subs	r3, r3, r7
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   29e22:	3207      	adds	r2, #7
	buf->len -= mic_len;
   29e24:	b29b      	uxth	r3, r3
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   29e26:	2100      	movs	r1, #0
   29e28:	e9cd 1100 	strd	r1, r1, [sp]
	buf->len -= mic_len;
   29e2c:	80ab      	strh	r3, [r5, #4]
	return bt_ccm_decrypt(key, nonce, &buf->data[7], buf->len - 7, NULL, 0,
   29e2e:	e9cd 2702 	strd	r2, r7, [sp, #8]
   29e32:	3b07      	subs	r3, #7
   29e34:	a904      	add	r1, sp, #16
   29e36:	4630      	mov	r0, r6
   29e38:	f7fd ff10 	bl	27c5c <bt_ccm_decrypt>
}
   29e3c:	b009      	add	sp, #36	; 0x24
   29e3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	nonce[0] = 0x00;
   29e42:	f88d 3010 	strb.w	r3, [sp, #16]
	nonce[1] = pdu[1];
   29e46:	f88d 9011 	strb.w	r9, [sp, #17]
   29e4a:	e7d5      	b.n	29df8 <bt_mesh_net_decrypt+0x3c>

00029e4c <bt_mesh_app_encrypt>:
{
   29e4c:	b570      	push	{r4, r5, r6, lr}
   29e4e:	460d      	mov	r5, r1
   29e50:	b088      	sub	sp, #32
   29e52:	4606      	mov	r6, r0
	create_app_nonce(nonce, ctx);
   29e54:	a804      	add	r0, sp, #16
{
   29e56:	4614      	mov	r4, r2
	create_app_nonce(nonce, ctx);
   29e58:	f7ff feea 	bl	29c30 <create_app_nonce>
	err = bt_ccm_encrypt(key, nonce, buf->data, buf->len, ctx->ad,
   29e5c:	692b      	ldr	r3, [r5, #16]
   29e5e:	7868      	ldrb	r0, [r5, #1]
   29e60:	6822      	ldr	r2, [r4, #0]
   29e62:	2b00      	cmp	r3, #0
   29e64:	bf14      	ite	ne
   29e66:	2110      	movne	r1, #16
   29e68:	2100      	moveq	r1, #0
   29e6a:	2800      	cmp	r0, #0
   29e6c:	bf14      	ite	ne
   29e6e:	2008      	movne	r0, #8
   29e70:	2004      	moveq	r0, #4
   29e72:	e9cd 3100 	strd	r3, r1, [sp]
   29e76:	e9cd 2002 	strd	r2, r0, [sp, #8]
   29e7a:	88a3      	ldrh	r3, [r4, #4]
   29e7c:	4630      	mov	r0, r6
   29e7e:	a904      	add	r1, sp, #16
   29e80:	f7fd ff1b 	bl	27cba <bt_ccm_encrypt>
	if (!err) {
   29e84:	4606      	mov	r6, r0
   29e86:	b938      	cbnz	r0, 29e98 <bt_mesh_app_encrypt+0x4c>
		net_buf_simple_add(buf, APP_MIC_LEN(ctx->aszmic));
   29e88:	786b      	ldrb	r3, [r5, #1]
   29e8a:	2b00      	cmp	r3, #0
   29e8c:	bf14      	ite	ne
   29e8e:	2108      	movne	r1, #8
   29e90:	2104      	moveq	r1, #4
   29e92:	4620      	mov	r0, r4
   29e94:	f001 ff52 	bl	2bd3c <net_buf_simple_add>
}
   29e98:	4630      	mov	r0, r6
   29e9a:	b008      	add	sp, #32
   29e9c:	bd70      	pop	{r4, r5, r6, pc}

00029e9e <bt_mesh_app_decrypt>:
{
   29e9e:	b5f0      	push	{r4, r5, r6, r7, lr}
   29ea0:	460d      	mov	r5, r1
   29ea2:	b089      	sub	sp, #36	; 0x24
   29ea4:	4607      	mov	r7, r0
	create_app_nonce(nonce, ctx);
   29ea6:	a804      	add	r0, sp, #16
{
   29ea8:	4614      	mov	r4, r2
   29eaa:	461e      	mov	r6, r3
	create_app_nonce(nonce, ctx);
   29eac:	f7ff fec0 	bl	29c30 <create_app_nonce>
	err = bt_ccm_decrypt(key, nonce, buf->data, buf->len, ctx->ad,
   29eb0:	692b      	ldr	r3, [r5, #16]
   29eb2:	7868      	ldrb	r0, [r5, #1]
   29eb4:	6831      	ldr	r1, [r6, #0]
   29eb6:	2b00      	cmp	r3, #0
   29eb8:	bf14      	ite	ne
   29eba:	2210      	movne	r2, #16
   29ebc:	2200      	moveq	r2, #0
   29ebe:	2800      	cmp	r0, #0
   29ec0:	bf14      	ite	ne
   29ec2:	2008      	movne	r0, #8
   29ec4:	2004      	moveq	r0, #4
   29ec6:	e9cd 1002 	strd	r1, r0, [sp, #8]
   29eca:	e9cd 3200 	strd	r3, r2, [sp]
   29ece:	a904      	add	r1, sp, #16
   29ed0:	88a3      	ldrh	r3, [r4, #4]
   29ed2:	6822      	ldr	r2, [r4, #0]
   29ed4:	4638      	mov	r0, r7
   29ed6:	f7fd fec1 	bl	27c5c <bt_ccm_decrypt>
	if (!err) {
   29eda:	4605      	mov	r5, r0
   29edc:	b918      	cbnz	r0, 29ee6 <bt_mesh_app_decrypt+0x48>
		net_buf_simple_add(out, buf->len);
   29ede:	88a1      	ldrh	r1, [r4, #4]
   29ee0:	4630      	mov	r0, r6
   29ee2:	f001 ff2b 	bl	2bd3c <net_buf_simple_add>
}
   29ee6:	4628      	mov	r0, r5
   29ee8:	b009      	add	sp, #36	; 0x24
   29eea:	bdf0      	pop	{r4, r5, r6, r7, pc}

00029eec <bt_mesh_prov_conf_salt>:
{
   29eec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	const uint8_t conf_salt_key[16] = { 0 };
   29eee:	2200      	movs	r2, #0
   29ef0:	e9cd 2200 	strd	r2, r2, [sp]
   29ef4:	e9cd 2202 	strd	r2, r2, [sp, #8]
{
   29ef8:	460b      	mov	r3, r1
	return bt_mesh_aes_cmac_one(conf_salt_key, conf_inputs, 145, salt);
   29efa:	2291      	movs	r2, #145	; 0x91
   29efc:	4601      	mov	r1, r0
   29efe:	4668      	mov	r0, sp
   29f00:	f7ff fed8 	bl	29cb4 <bt_mesh_aes_cmac_one>
}
   29f04:	b005      	add	sp, #20
   29f06:	f85d fb04 	ldr.w	pc, [sp], #4

00029f0a <bt_mesh_prov_conf>:

int bt_mesh_prov_conf(const uint8_t conf_key[16], const uint8_t rand[16],
		      const uint8_t auth[16], uint8_t conf[16])
{
   29f0a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct bt_mesh_sg sg[] = { { rand, 16 }, { auth, 16 } };
   29f0c:	9100      	str	r1, [sp, #0]
   29f0e:	2110      	movs	r1, #16
   29f10:	e9cd 1201 	strd	r1, r2, [sp, #4]
   29f14:	9103      	str	r1, [sp, #12]

	BT_DBG("ConfirmationKey %s", bt_hex(conf_key, 16));
	BT_DBG("RandomDevice %s", bt_hex(rand, 16));
	BT_DBG("AuthValue %s", bt_hex(auth, 16));

	return bt_mesh_aes_cmac(conf_key, sg, ARRAY_SIZE(sg), conf);
   29f16:	2202      	movs	r2, #2
   29f18:	4669      	mov	r1, sp
   29f1a:	f7ff fea9 	bl	29c70 <bt_mesh_aes_cmac>
}
   29f1e:	b005      	add	sp, #20
   29f20:	f85d fb04 	ldr.w	pc, [sp], #4

00029f24 <bt_mesh_prov_decrypt>:

int bt_mesh_prov_decrypt(const uint8_t key[16], uint8_t nonce[13],
			 const uint8_t data[25 + 8], uint8_t out[25])
{
   29f24:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return bt_ccm_decrypt(key, nonce, data, 25, NULL, 0, out, 8);
   29f26:	2408      	movs	r4, #8
   29f28:	e9cd 3402 	strd	r3, r4, [sp, #8]
   29f2c:	2300      	movs	r3, #0
   29f2e:	e9cd 3300 	strd	r3, r3, [sp]
   29f32:	2319      	movs	r3, #25
   29f34:	f7fd fe92 	bl	27c5c <bt_ccm_decrypt>
}
   29f38:	b004      	add	sp, #16
   29f3a:	bd10      	pop	{r4, pc}

00029f3c <bt_mesh_beacon_auth>:
}

int bt_mesh_beacon_auth(const uint8_t beacon_key[16], uint8_t flags,
			const uint8_t net_id[8], uint32_t iv_index,
			uint8_t auth[8])
{
   29f3c:	b530      	push	{r4, r5, lr}
   29f3e:	b089      	sub	sp, #36	; 0x24
   29f40:	4604      	mov	r4, r0
   29f42:	4608      	mov	r0, r1
   29f44:	461d      	mov	r5, r3
   29f46:	4611      	mov	r1, r2

	BT_DBG("BeaconKey %s", bt_hex(beacon_key, 16));
	BT_DBG("NetId %s", bt_hex(net_id, 8));
	BT_DBG("IV Index 0x%08x", iv_index);

	msg[0] = flags;
   29f48:	f88d 0000 	strb.w	r0, [sp]
	memcpy(&msg[1], net_id, 8);
   29f4c:	2208      	movs	r2, #8
   29f4e:	f10d 0001 	add.w	r0, sp, #1
   29f52:	f7fd fc8d 	bl	27870 <memcpy>
	sys_put_be32(iv_index, &msg[9]);
   29f56:	f10d 0109 	add.w	r1, sp, #9
   29f5a:	4628      	mov	r0, r5
   29f5c:	f7ff fe5f 	bl	29c1e <sys_put_be32>

	BT_DBG("BeaconMsg %s", bt_hex(msg, sizeof(msg)));

	err = bt_mesh_aes_cmac_one(beacon_key, msg, sizeof(msg), tmp);
   29f60:	4620      	mov	r0, r4
   29f62:	ab04      	add	r3, sp, #16
   29f64:	220d      	movs	r2, #13
   29f66:	4669      	mov	r1, sp
   29f68:	f7ff fea4 	bl	29cb4 <bt_mesh_aes_cmac_one>
	if (!err) {
   29f6c:	4604      	mov	r4, r0
   29f6e:	b920      	cbnz	r0, 29f7a <bt_mesh_beacon_auth+0x3e>
		memcpy(auth, tmp, 8);
   29f70:	980c      	ldr	r0, [sp, #48]	; 0x30
   29f72:	2208      	movs	r2, #8
   29f74:	a904      	add	r1, sp, #16
   29f76:	f7fd fc7b 	bl	27870 <memcpy>
	}

	return err;
}
   29f7a:	4620      	mov	r0, r4
   29f7c:	b009      	add	sp, #36	; 0x24
   29f7e:	bd30      	pop	{r4, r5, pc}

00029f80 <k_uptime_get_32>:
{
   29f80:	b508      	push	{r3, lr}
   29f82:	f003 f8e5 	bl	2d150 <z_impl_k_uptime_ticks>
   29f86:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   29f8a:	fba0 3002 	umull	r3, r0, r0, r2
   29f8e:	fb02 0101 	mla	r1, r2, r1, r0
   29f92:	0bd8      	lsrs	r0, r3, #15
}
   29f94:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
   29f98:	bd08      	pop	{r3, pc}

00029f9a <find_group_mod_visitor>:
{
   29f9a:	b510      	push	{r4, lr}
	if (mod->elem_idx != ctx->mod->elem_idx) {
   29f9c:	684b      	ldr	r3, [r1, #4]
   29f9e:	7902      	ldrb	r2, [r0, #4]
   29fa0:	791b      	ldrb	r3, [r3, #4]
   29fa2:	429a      	cmp	r2, r3
   29fa4:	d109      	bne.n	29fba <find_group_mod_visitor+0x20>
		if (mod->groups[i] == addr) {
   29fa6:	89c3      	ldrh	r3, [r0, #14]
	ctx->entry = model_group_get(mod, ctx->addr);
   29fa8:	890a      	ldrh	r2, [r1, #8]
		if (mod->groups[i] == addr) {
   29faa:	4293      	cmp	r3, r2
   29fac:	f04f 0300 	mov.w	r3, #0
   29fb0:	d006      	beq.n	29fc0 <find_group_mod_visitor+0x26>
   29fb2:	8a04      	ldrh	r4, [r0, #16]
   29fb4:	4294      	cmp	r4, r2
   29fb6:	d002      	beq.n	29fbe <find_group_mod_visitor+0x24>
	ctx->entry = model_group_get(mod, ctx->addr);
   29fb8:	600b      	str	r3, [r1, #0]
		return BT_MESH_WALK_CONTINUE;
   29fba:	2001      	movs	r0, #1
   29fbc:	e006      	b.n	29fcc <find_group_mod_visitor+0x32>
	for (i = 0; i < ARRAY_SIZE(mod->groups); i++) {
   29fbe:	2301      	movs	r3, #1
			return &mod->groups[i];
   29fc0:	3307      	adds	r3, #7
   29fc2:	eb00 0343 	add.w	r3, r0, r3, lsl #1
		ctx->mod = mod;
   29fc6:	e9c1 3000 	strd	r3, r0, [r1]
		return BT_MESH_WALK_STOP;
   29fca:	2000      	movs	r0, #0
}
   29fcc:	bd10      	pop	{r4, pc}

00029fce <z_log_msg2_static_create.constprop.0>:
   29fce:	2300      	movs	r3, #0
   29fd0:	f7fb be82 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

00029fd4 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   29fd4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   29fd6:	ab0a      	add	r3, sp, #40	; 0x28
   29fd8:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   29fda:	9302      	str	r3, [sp, #8]
   29fdc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   29fde:	9301      	str	r3, [sp, #4]
   29fe0:	2300      	movs	r3, #0
   29fe2:	9300      	str	r3, [sp, #0]
   29fe4:	4618      	mov	r0, r3
   29fe6:	f7d9 f95f 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   29fea:	b007      	add	sp, #28
   29fec:	f85d fb04 	ldr.w	pc, [sp], #4

00029ff0 <commit_mod>:
{
   29ff0:	b570      	push	{r4, r5, r6, lr}
	if (mod->pub && mod->pub->update &&
   29ff2:	6885      	ldr	r5, [r0, #8]
   29ff4:	b1dd      	cbz	r5, 2a02e <commit_mod+0x3e>
   29ff6:	696b      	ldr	r3, [r5, #20]
   29ff8:	b1cb      	cbz	r3, 2a02e <commit_mod+0x3e>
   29ffa:	88ab      	ldrh	r3, [r5, #4]
   29ffc:	b1bb      	cbz	r3, 2a02e <commit_mod+0x3e>
		int32_t ms = bt_mesh_model_pub_period_get(mod);
   29ffe:	f7e6 fc6b 	bl	108d8 <bt_mesh_model_pub_period_get>
		if (ms > 0) {
   2a002:	1e04      	subs	r4, r0, #0
   2a004:	dd13      	ble.n	2a02e <commit_mod+0x3e>
   2a006:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2a00a:	f240 30e7 	movw	r0, #999	; 0x3e7
   2a00e:	2100      	movs	r1, #0
   2a010:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a014:	2300      	movs	r3, #0
   2a016:	fbc4 0106 	smlal	r0, r1, r4, r6
   2a01a:	f7d6 f861 	bl	e0 <__aeabi_uldivmod>
   2a01e:	4602      	mov	r2, r0
   2a020:	460b      	mov	r3, r1
			k_work_schedule(&mod->pub->timer, K_MSEC(ms));
   2a022:	f105 0018 	add.w	r0, r5, #24
}
   2a026:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			k_work_schedule(&mod->pub->timer, K_MSEC(ms));
   2a02a:	f7fa b967 	b.w	242fc <k_work_schedule>
}
   2a02e:	bd70      	pop	{r4, r5, r6, pc}

0002a030 <sig_mod_set>:
{
   2a030:	b507      	push	{r0, r1, r2, lr}
	return mod_set(false, name, len_rd, read_cb, cb_arg);
   2a032:	9300      	str	r3, [sp, #0]
   2a034:	4613      	mov	r3, r2
   2a036:	460a      	mov	r2, r1
   2a038:	4601      	mov	r1, r0
   2a03a:	2000      	movs	r0, #0
   2a03c:	f7e6 fdc8 	bl	10bd0 <mod_set>
}
   2a040:	b003      	add	sp, #12
   2a042:	f85d fb04 	ldr.w	pc, [sp], #4

0002a046 <vnd_mod_set>:
{
   2a046:	b507      	push	{r0, r1, r2, lr}
	return mod_set(true, name, len_rd, read_cb, cb_arg);
   2a048:	9300      	str	r3, [sp, #0]
   2a04a:	4613      	mov	r3, r2
   2a04c:	460a      	mov	r2, r1
   2a04e:	4601      	mov	r1, r0
   2a050:	2001      	movs	r0, #1
   2a052:	f7e6 fdbd 	bl	10bd0 <mod_set>
}
   2a056:	b003      	add	sp, #12
   2a058:	f85d fb04 	ldr.w	pc, [sp], #4

0002a05c <bt_mesh_model_has_key>:
		if (mod->keys[i] == key ||
   2a05c:	8983      	ldrh	r3, [r0, #12]
   2a05e:	428b      	cmp	r3, r1
   2a060:	d00a      	beq.n	2a078 <bt_mesh_model_has_key+0x1c>
   2a062:	f64f 72fc 	movw	r2, #65532	; 0xfffc
   2a066:	4293      	cmp	r3, r2
   2a068:	d108      	bne.n	2a07c <bt_mesh_model_has_key+0x20>
		     BT_MESH_IS_DEV_KEY(key))) {
   2a06a:	1cc8      	adds	r0, r1, #3
		    (mod->keys[i] == BT_MESH_KEY_DEV_ANY &&
   2a06c:	b280      	uxth	r0, r0
   2a06e:	2801      	cmp	r0, #1
   2a070:	bf8c      	ite	hi
   2a072:	2000      	movhi	r0, #0
   2a074:	2001      	movls	r0, #1
   2a076:	4770      	bx	lr
			return true;
   2a078:	2001      	movs	r0, #1
   2a07a:	4770      	bx	lr
	return false;
   2a07c:	2000      	movs	r0, #0
}
   2a07e:	4770      	bx	lr

0002a080 <bt_mesh_model_find_vnd>:
{
   2a080:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0U; i < elem->vnd_model_count; i++) {
   2a082:	7947      	ldrb	r7, [r0, #5]
{
   2a084:	4604      	mov	r4, r0
	for (i = 0U; i < elem->vnd_model_count; i++) {
   2a086:	2300      	movs	r3, #0
		if (elem->vnd_models[i].vnd.company == company &&
   2a088:	f04f 0c24 	mov.w	ip, #36	; 0x24
	for (i = 0U; i < elem->vnd_model_count; i++) {
   2a08c:	b2d8      	uxtb	r0, r3
   2a08e:	4287      	cmp	r7, r0
   2a090:	d801      	bhi.n	2a096 <bt_mesh_model_find_vnd+0x16>
	return NULL;
   2a092:	2000      	movs	r0, #0
}
   2a094:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (elem->vnd_models[i].vnd.company == company &&
   2a096:	68e6      	ldr	r6, [r4, #12]
   2a098:	fb0c f503 	mul.w	r5, ip, r3
   2a09c:	1970      	adds	r0, r6, r5
   2a09e:	5b75      	ldrh	r5, [r6, r5]
   2a0a0:	428d      	cmp	r5, r1
   2a0a2:	d102      	bne.n	2a0aa <bt_mesh_model_find_vnd+0x2a>
   2a0a4:	8845      	ldrh	r5, [r0, #2]
   2a0a6:	4295      	cmp	r5, r2
   2a0a8:	d0f4      	beq.n	2a094 <bt_mesh_model_find_vnd+0x14>
	for (i = 0U; i < elem->vnd_model_count; i++) {
   2a0aa:	3301      	adds	r3, #1
   2a0ac:	e7ee      	b.n	2a08c <bt_mesh_model_find_vnd+0xc>

0002a0ae <bt_mesh_model_find>:
{
   2a0ae:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0U; i < elem->model_count; i++) {
   2a0b0:	7906      	ldrb	r6, [r0, #4]
{
   2a0b2:	4602      	mov	r2, r0
	for (i = 0U; i < elem->model_count; i++) {
   2a0b4:	2300      	movs	r3, #0
		if (elem->models[i].id == id) {
   2a0b6:	2724      	movs	r7, #36	; 0x24
	for (i = 0U; i < elem->model_count; i++) {
   2a0b8:	b2d8      	uxtb	r0, r3
   2a0ba:	4286      	cmp	r6, r0
   2a0bc:	d801      	bhi.n	2a0c2 <bt_mesh_model_find+0x14>
	return NULL;
   2a0be:	2000      	movs	r0, #0
   2a0c0:	e008      	b.n	2a0d4 <bt_mesh_model_find+0x26>
		if (elem->models[i].id == id) {
   2a0c2:	fb07 f403 	mul.w	r4, r7, r3
   2a0c6:	6895      	ldr	r5, [r2, #8]
   2a0c8:	1928      	adds	r0, r5, r4
   2a0ca:	5b2c      	ldrh	r4, [r5, r4]
   2a0cc:	428c      	cmp	r4, r1
   2a0ce:	f103 0301 	add.w	r3, r3, #1
   2a0d2:	d1f1      	bne.n	2a0b8 <bt_mesh_model_find+0xa>
}
   2a0d4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002a0d6 <bt_mesh_model_extensions_walk>:
{
   2a0d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a0d8:	460e      	mov	r6, r1
	if (cb(model, user_data) == BT_MESH_WALK_STOP || !model->next) {
   2a0da:	4611      	mov	r1, r2
{
   2a0dc:	4605      	mov	r5, r0
   2a0de:	4617      	mov	r7, r2
	if (cb(model, user_data) == BT_MESH_WALK_STOP || !model->next) {
   2a0e0:	47b0      	blx	r6
   2a0e2:	b108      	cbz	r0, 2a0e8 <bt_mesh_model_extensions_walk+0x12>
   2a0e4:	69ec      	ldr	r4, [r5, #28]
   2a0e6:	b934      	cbnz	r4, 2a0f6 <bt_mesh_model_extensions_walk+0x20>
}
   2a0e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (cb(it, user_data) == BT_MESH_WALK_STOP) {
   2a0ea:	4639      	mov	r1, r7
   2a0ec:	4620      	mov	r0, r4
   2a0ee:	47b0      	blx	r6
   2a0f0:	2800      	cmp	r0, #0
   2a0f2:	d0f9      	beq.n	2a0e8 <bt_mesh_model_extensions_walk+0x12>
	for (it = model->next; it != model; it = it->next) {
   2a0f4:	69e4      	ldr	r4, [r4, #28]
   2a0f6:	42ac      	cmp	r4, r5
   2a0f8:	d1f7      	bne.n	2a0ea <bt_mesh_model_extensions_walk+0x14>
   2a0fa:	e7f5      	b.n	2a0e8 <bt_mesh_model_extensions_walk+0x12>

0002a0fc <bt_mesh_model_bind_store>:
	mod->flags |= BT_MESH_MOD_BIND_PENDING;
   2a0fc:	88c3      	ldrh	r3, [r0, #6]
   2a0fe:	f043 0301 	orr.w	r3, r3, #1
   2a102:	80c3      	strh	r3, [r0, #6]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_MOD_PENDING);
   2a104:	2008      	movs	r0, #8
   2a106:	f7eb b815 	b.w	15134 <bt_mesh_settings_store_schedule>

0002a10a <bt_mesh_model_sub_store>:
	mod->flags |= BT_MESH_MOD_SUB_PENDING;
   2a10a:	88c3      	ldrh	r3, [r0, #6]
   2a10c:	f043 0302 	orr.w	r3, r3, #2
   2a110:	80c3      	strh	r3, [r0, #6]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_MOD_PENDING);
   2a112:	2008      	movs	r0, #8
   2a114:	f7eb b80e 	b.w	15134 <bt_mesh_settings_store_schedule>

0002a118 <bt_mesh_model_pub_store>:
	mod->flags |= BT_MESH_MOD_PUB_PENDING;
   2a118:	88c3      	ldrh	r3, [r0, #6]
   2a11a:	f043 0304 	orr.w	r3, r3, #4
   2a11e:	80c3      	strh	r3, [r0, #6]
	bt_mesh_settings_store_schedule(BT_MESH_SETTINGS_MOD_PENDING);
   2a120:	2008      	movs	r0, #8
   2a122:	f7eb b807 	b.w	15134 <bt_mesh_settings_store_schedule>

0002a126 <bt_mesh_model_msg_init>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_MESH_DEBUG_ACCESS)
#define LOG_MODULE_NAME bt_mesh_msg
#include "common/log.h"

void bt_mesh_model_msg_init(struct net_buf_simple *msg, uint32_t opcode)
{
   2a126:	b538      	push	{r3, r4, r5, lr}
	if (!buf->__buf) {
   2a128:	6883      	ldr	r3, [r0, #8]
   2a12a:	4604      	mov	r4, r0
   2a12c:	b913      	cbnz	r3, 2a134 <bt_mesh_model_msg_init+0xe>
		buf->__buf = (uint8_t *)buf + sizeof(*buf);
   2a12e:	f100 030c 	add.w	r3, r0, #12
   2a132:	6083      	str	r3, [r0, #8]
	buf->data = buf->__buf + reserve_head;
   2a134:	68a3      	ldr	r3, [r4, #8]
   2a136:	6023      	str	r3, [r4, #0]
	net_buf_simple_init(msg, 0);

	switch (BT_MESH_MODEL_OP_LEN(opcode)) {
   2a138:	29ff      	cmp	r1, #255	; 0xff
	buf->len = 0U;
   2a13a:	f04f 0300 	mov.w	r3, #0
   2a13e:	80a3      	strh	r3, [r4, #4]
   2a140:	d805      	bhi.n	2a14e <bt_mesh_model_msg_init+0x28>
	case 1:
		net_buf_simple_add_u8(msg, opcode);
   2a142:	4620      	mov	r0, r4
   2a144:	b2c9      	uxtb	r1, r1
		break;
	default:
		BT_WARN("Unknown opcode format");
		break;
	}
}
   2a146:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_u8(msg, opcode);
   2a14a:	f001 be06 	b.w	2bd5a <net_buf_simple_add_u8>
	switch (BT_MESH_MODEL_OP_LEN(opcode)) {
   2a14e:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
		net_buf_simple_add_be16(msg, opcode);
   2a152:	b28d      	uxth	r5, r1
	switch (BT_MESH_MODEL_OP_LEN(opcode)) {
   2a154:	d205      	bcs.n	2a162 <bt_mesh_model_msg_init+0x3c>
		net_buf_simple_add_be16(msg, opcode);
   2a156:	4629      	mov	r1, r5
   2a158:	4620      	mov	r0, r4
}
   2a15a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_be16(msg, opcode);
   2a15e:	f001 be0e 	b.w	2bd7e <net_buf_simple_add_be16>
		net_buf_simple_add_u8(msg, ((opcode >> 16) & 0xff));
   2a162:	f3c1 4107 	ubfx	r1, r1, #16, #8
   2a166:	4620      	mov	r0, r4
   2a168:	f001 fdf7 	bl	2bd5a <net_buf_simple_add_u8>
		net_buf_simple_add_le16(msg, opcode & 0xffff);
   2a16c:	4629      	mov	r1, r5
   2a16e:	4620      	mov	r0, r4
}
   2a170:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_simple_add_le16(msg, opcode & 0xffff);
   2a174:	f001 bdf9 	b.w	2bd6a <net_buf_simple_add_le16>

0002a178 <key_idx_pack>:

#include <sys/byteorder.h>

static inline void key_idx_pack(struct net_buf_simple *buf,
				uint16_t idx1, uint16_t idx2)
{
   2a178:	b538      	push	{r3, r4, r5, lr}
	net_buf_simple_add_le16(buf, idx1 | ((idx2 & 0x00f) << 12));
   2a17a:	ea41 3102 	orr.w	r1, r1, r2, lsl #12
{
   2a17e:	4605      	mov	r5, r0
   2a180:	4614      	mov	r4, r2
	net_buf_simple_add_le16(buf, idx1 | ((idx2 & 0x00f) << 12));
   2a182:	b289      	uxth	r1, r1
   2a184:	f001 fdf1 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_u8(buf, idx2 >> 4);
   2a188:	f3c4 1107 	ubfx	r1, r4, #4, #8
   2a18c:	4628      	mov	r0, r5
}
   2a18e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_simple_add_u8(buf, idx2 >> 4);
   2a192:	f001 bde2 	b.w	2bd5a <net_buf_simple_add_u8>

0002a196 <reset_send_end>:
	bt_mesh_reset();
   2a196:	f7e1 bbd1 	b.w	b93c <bt_mesh_reset>

0002a19a <key_idx_unpack>:

static inline void key_idx_unpack(struct net_buf_simple *buf,
				  uint16_t *idx1, uint16_t *idx2)
{
   2a19a:	b410      	push	{r4}
	*idx1 = sys_get_le16(&buf->data[0]) & 0xfff;
   2a19c:	6804      	ldr	r4, [r0, #0]
   2a19e:	8823      	ldrh	r3, [r4, #0]
   2a1a0:	f3c3 030b 	ubfx	r3, r3, #0, #12
   2a1a4:	800b      	strh	r3, [r1, #0]
	*idx2 = sys_get_le16(&buf->data[1]) >> 4;
   2a1a6:	f8b4 3001 	ldrh.w	r3, [r4, #1]
	net_buf_simple_pull(buf, 3);
}
   2a1aa:	bc10      	pop	{r4}
	*idx2 = sys_get_le16(&buf->data[1]) >> 4;
   2a1ac:	091b      	lsrs	r3, r3, #4
   2a1ae:	8013      	strh	r3, [r2, #0]
	net_buf_simple_pull(buf, 3);
   2a1b0:	2103      	movs	r1, #3
   2a1b2:	f001 be33 	b.w	2be1c <net_buf_simple_pull>

0002a1b6 <bt_mesh_hb_pwr2>:
	if (!val) {
   2a1b6:	b158      	cbz	r0, 2a1d0 <bt_mesh_hb_pwr2+0x1a>
	} else if (val == 0xff || val == 0x11) {
   2a1b8:	28ff      	cmp	r0, #255	; 0xff
   2a1ba:	d007      	beq.n	2a1cc <bt_mesh_hb_pwr2+0x16>
   2a1bc:	2811      	cmp	r0, #17
   2a1be:	d005      	beq.n	2a1cc <bt_mesh_hb_pwr2+0x16>
		return (1 << (val - 1));
   2a1c0:	2301      	movs	r3, #1
   2a1c2:	3801      	subs	r0, #1
   2a1c4:	fa03 f000 	lsl.w	r0, r3, r0
   2a1c8:	b280      	uxth	r0, r0
   2a1ca:	4770      	bx	lr
		return 0xffff;
   2a1cc:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
   2a1d0:	4770      	bx	lr

0002a1d2 <create_mod_app_status.constprop.0>:
static void create_mod_app_status(struct net_buf_simple *msg,
   2a1d2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2a1d6:	f89d 9020 	ldrb.w	r9, [sp, #32]
   2a1da:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   2a1de:	4604      	mov	r4, r0
   2a1e0:	460d      	mov	r5, r1
	bt_mesh_model_msg_init(msg, OP_MOD_APP_STATUS);
   2a1e2:	f248 013e 	movw	r1, #32830	; 0x803e
static void create_mod_app_status(struct net_buf_simple *msg,
   2a1e6:	4617      	mov	r7, r2
   2a1e8:	461e      	mov	r6, r3
	bt_mesh_model_msg_init(msg, OP_MOD_APP_STATUS);
   2a1ea:	f7ff ff9c 	bl	2a126 <bt_mesh_model_msg_init>
	net_buf_simple_add_u8(msg, status);
   2a1ee:	4649      	mov	r1, r9
   2a1f0:	4620      	mov	r0, r4
   2a1f2:	f001 fdb2 	bl	2bd5a <net_buf_simple_add_u8>
	net_buf_simple_add_le16(msg, elem_addr);
   2a1f6:	4639      	mov	r1, r7
   2a1f8:	4620      	mov	r0, r4
   2a1fa:	f001 fdb6 	bl	2bd6a <net_buf_simple_add_le16>
	net_buf_simple_add_le16(msg, app_idx);
   2a1fe:	4631      	mov	r1, r6
   2a200:	4620      	mov	r0, r4
   2a202:	f001 fdb2 	bl	2bd6a <net_buf_simple_add_le16>
	if (vnd) {
   2a206:	b14d      	cbz	r5, 2a21c <create_mod_app_status.constprop.0+0x4a>
		memcpy(net_buf_simple_add(msg, 4), mod_id, 4);
   2a208:	2104      	movs	r1, #4
   2a20a:	4620      	mov	r0, r4
   2a20c:	f001 fd96 	bl	2bd3c <net_buf_simple_add>
   2a210:	2204      	movs	r2, #4
		memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
   2a212:	4641      	mov	r1, r8
}
   2a214:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
   2a218:	f7fd bb2a 	b.w	27870 <memcpy>
   2a21c:	2102      	movs	r1, #2
   2a21e:	4620      	mov	r0, r4
   2a220:	f001 fd8c 	bl	2bd3c <net_buf_simple_add>
   2a224:	2202      	movs	r2, #2
   2a226:	e7f4      	b.n	2a212 <create_mod_app_status.constprop.0+0x40>

0002a228 <z_log_msg2_static_create.constprop.0>:
	z_impl_z_log_msg2_static_create(source, desc, package, data);
   2a228:	2300      	movs	r3, #0
   2a22a:	f7fb bd55 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a22e <mod_app_key_del>:
	mod_unbind(mod, *app_idx, true);
   2a22e:	9b00      	ldr	r3, [sp, #0]
   2a230:	8819      	ldrh	r1, [r3, #0]
   2a232:	f7e7 b86f 	b.w	11314 <mod_unbind.constprop.0>

0002a236 <mod_sub_clear_visitor>:
{
   2a236:	b508      	push	{r3, lr}
	mod_sub_list_clear(mod);
   2a238:	f7e7 f9f2 	bl	11620 <mod_sub_list_clear>
}
   2a23c:	2001      	movs	r0, #1
   2a23e:	bd08      	pop	{r3, pc}

0002a240 <mod_reset>:
{
   2a240:	b510      	push	{r4, lr}
   2a242:	4604      	mov	r4, r0
	clear_count = mod_sub_list_clear(mod);
   2a244:	f7e7 f9ec 	bl	11620 <mod_sub_list_clear>
		if (clear_count) {
   2a248:	b110      	cbz	r0, 2a250 <mod_reset+0x10>
			bt_mesh_model_sub_store(mod);
   2a24a:	4620      	mov	r0, r4
   2a24c:	f7ff ff5d 	bl	2a10a <bt_mesh_model_sub_store>
	if (mod->cb && mod->cb->reset) {
   2a250:	69a3      	ldr	r3, [r4, #24]
   2a252:	b12b      	cbz	r3, 2a260 <mod_reset+0x20>
   2a254:	68db      	ldr	r3, [r3, #12]
   2a256:	b11b      	cbz	r3, 2a260 <mod_reset+0x20>
		mod->cb->reset(mod);
   2a258:	4620      	mov	r0, r4
}
   2a25a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		mod->cb->reset(mod);
   2a25e:	4718      	bx	r3
}
   2a260:	bd10      	pop	{r4, pc}

0002a262 <z_log_msg2_static_create.constprop.0>:
   2a262:	2300      	movs	r3, #0
   2a264:	f7fb bd38 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a268 <bt_mesh_adv_buf_local_ready>:
}
   2a268:	4770      	bx	lr

0002a26a <bt_mesh_adv_gatt_update>:
	bt_mesh_adv_buf_get_cancel();
   2a26a:	f7e1 bef1 	b.w	c050 <bt_mesh_adv_buf_get_cancel>

0002a26e <store_pending>:
{
   2a26e:	b508      	push	{r3, lr}
	if (atomic_test_and_clear_bit(pending_flags,
   2a270:	2000      	movs	r0, #0
   2a272:	f7ea fee7 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a276:	b118      	cbz	r0, 2a280 <store_pending+0x12>
		bt_mesh_rpl_pending_store(BT_MESH_ADDR_ALL_NODES);
   2a278:	f64f 70ff 	movw	r0, #65535	; 0xffff
   2a27c:	f7e5 fcfa 	bl	fc74 <bt_mesh_rpl_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a280:	2001      	movs	r0, #1
   2a282:	f7ea fedf 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a286:	b108      	cbz	r0, 2a28c <store_pending+0x1e>
		bt_mesh_subnet_pending_store();
   2a288:	f7e3 fcbc 	bl	dc04 <bt_mesh_subnet_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a28c:	2002      	movs	r0, #2
   2a28e:	f7ea fed9 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a292:	b108      	cbz	r0, 2a298 <store_pending+0x2a>
		bt_mesh_app_key_pending_store();
   2a294:	f7e3 ff74 	bl	e180 <bt_mesh_app_key_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a298:	2003      	movs	r0, #3
   2a29a:	f7ea fed3 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a29e:	b108      	cbz	r0, 2a2a4 <store_pending+0x36>
		bt_mesh_net_pending_net_store();
   2a2a0:	f7e3 f950 	bl	d544 <bt_mesh_net_pending_net_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2a4:	2004      	movs	r0, #4
   2a2a6:	f7ea fecd 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2aa:	b108      	cbz	r0, 2a2b0 <store_pending+0x42>
		bt_mesh_net_pending_iv_store();
   2a2ac:	f7e3 f90e 	bl	d4cc <bt_mesh_net_pending_iv_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2b0:	2005      	movs	r0, #5
   2a2b2:	f7ea fec7 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2b6:	b108      	cbz	r0, 2a2bc <store_pending+0x4e>
		bt_mesh_net_pending_seq_store();
   2a2b8:	f7e3 f97c 	bl	d5b4 <bt_mesh_net_pending_seq_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2bc:	2006      	movs	r0, #6
   2a2be:	f7ea fec1 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2c2:	b108      	cbz	r0, 2a2c8 <store_pending+0x5a>
		bt_mesh_hb_pub_pending_store();
   2a2c4:	f7e5 fff8 	bl	102b8 <bt_mesh_hb_pub_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2c8:	2007      	movs	r0, #7
   2a2ca:	f7ea febb 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2ce:	b108      	cbz	r0, 2a2d4 <store_pending+0x66>
		bt_mesh_cfg_pending_store();
   2a2d0:	f7e1 fdc8 	bl	be64 <bt_mesh_cfg_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2d4:	2008      	movs	r0, #8
   2a2d6:	f7ea feb5 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2da:	b108      	cbz	r0, 2a2e0 <store_pending+0x72>
		bt_mesh_model_pending_store();
   2a2dc:	f7e6 ff6c 	bl	111b8 <bt_mesh_model_pending_store>
	if (atomic_test_and_clear_bit(pending_flags,
   2a2e0:	2009      	movs	r0, #9
   2a2e2:	f7ea feaf 	bl	15044 <atomic_test_and_clear_bit.constprop.0>
   2a2e6:	b118      	cbz	r0, 2a2f0 <store_pending+0x82>
}
   2a2e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		bt_mesh_va_pending_store();
   2a2ec:	f7e5 bae8 	b.w	f8c0 <bt_mesh_va_pending_store>
}
   2a2f0:	bd08      	pop	{r3, pc}

0002a2f2 <friend_recv_delay>:
{
   2a2f2:	b510      	push	{r4, lr}
   2a2f4:	4604      	mov	r4, r0
	return (int32_t)frnd->recv_delay + (CONFIG_BT_MESH_FRIEND_RECV_WIN / 5);
   2a2f6:	7880      	ldrb	r0, [r0, #2]
	frnd->pending_req = 1U;
   2a2f8:	78e3      	ldrb	r3, [r4, #3]
   2a2fa:	03c0      	lsls	r0, r0, #15
   2a2fc:	f043 0304 	orr.w	r3, r3, #4
   2a300:	f500 10cc 	add.w	r0, r0, #1671168	; 0x198000
   2a304:	70e3      	strb	r3, [r4, #3]
   2a306:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a30a:	2300      	movs	r3, #0
   2a30c:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   2a310:	2100      	movs	r1, #0
   2a312:	f7d5 fee5 	bl	e0 <__aeabi_uldivmod>
   2a316:	4602      	mov	r2, r0
   2a318:	460b      	mov	r3, r1
	k_work_reschedule(&frnd->timer, K_MSEC(delay));
   2a31a:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
   2a31e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_reschedule(&frnd->timer, K_MSEC(delay));
   2a322:	f7fa b81f 	b.w	24364 <k_work_reschedule>

0002a326 <friend_clear_sent>:
{
   2a326:	b570      	push	{r4, r5, r6, lr}
			  K_SECONDS(frnd->clear.repeat_sec));
   2a328:	f8b1 50b6 	ldrh.w	r5, [r1, #182]	; 0xb6
   2a32c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
{
   2a330:	460c      	mov	r4, r1
			  K_SECONDS(frnd->clear.repeat_sec));
   2a332:	435d      	muls	r5, r3
   2a334:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2a338:	f240 30e7 	movw	r0, #999	; 0x3e7
   2a33c:	2100      	movs	r1, #0
   2a33e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2a342:	2300      	movs	r3, #0
   2a344:	fbe5 0106 	umlal	r0, r1, r5, r6
   2a348:	f7d5 feca 	bl	e0 <__aeabi_uldivmod>
   2a34c:	4602      	mov	r2, r0
   2a34e:	460b      	mov	r3, r1
	k_work_reschedule(&frnd->clear.timer,
   2a350:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
   2a354:	f7fa f806 	bl	24364 <k_work_reschedule>
	frnd->clear.repeat_sec *= 2U;
   2a358:	f8b4 30b6 	ldrh.w	r3, [r4, #182]	; 0xb6
   2a35c:	005b      	lsls	r3, r3, #1
   2a35e:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
}
   2a362:	bd70      	pop	{r4, r5, r6, pc}

0002a364 <friend_lpn_matches>:
	if (!frnd->established) {
   2a364:	78c3      	ldrb	r3, [r0, #3]
{
   2a366:	b510      	push	{r4, lr}
   2a368:	4604      	mov	r4, r0
	if (!frnd->established) {
   2a36a:	f013 0010 	ands.w	r0, r3, #16
   2a36e:	d013      	beq.n	2a398 <friend_lpn_matches+0x34>
	if (net_idx != frnd->subnet->net_idx) {
   2a370:	6923      	ldr	r3, [r4, #16]
   2a372:	8b9b      	ldrh	r3, [r3, #28]
   2a374:	428b      	cmp	r3, r1
   2a376:	d11c      	bne.n	2a3b2 <friend_lpn_matches+0x4e>
	if (BT_MESH_ADDR_IS_UNICAST(addr)) {
   2a378:	b213      	sxth	r3, r2
   2a37a:	2b00      	cmp	r3, #0
   2a37c:	dc0d      	bgt.n	2a39a <friend_lpn_matches+0x36>
		if (frnd->sub_list[i] == addr) {
   2a37e:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   2a382:	4293      	cmp	r3, r2
   2a384:	d017      	beq.n	2a3b6 <friend_lpn_matches+0x52>
   2a386:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
   2a38a:	4293      	cmp	r3, r2
   2a38c:	d013      	beq.n	2a3b6 <friend_lpn_matches+0x52>
   2a38e:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
   2a392:	1a9b      	subs	r3, r3, r2
   2a394:	4258      	negs	r0, r3
   2a396:	4158      	adcs	r0, r3
}
   2a398:	bd10      	pop	{r4, pc}
	if (frnd->lpn == BT_MESH_ADDR_UNASSIGNED) {
   2a39a:	8820      	ldrh	r0, [r4, #0]
   2a39c:	2800      	cmp	r0, #0
   2a39e:	d0fb      	beq.n	2a398 <friend_lpn_matches+0x34>
	return (addr >= frnd->lpn && addr < (frnd->lpn + frnd->num_elem));
   2a3a0:	4282      	cmp	r2, r0
   2a3a2:	d306      	bcc.n	2a3b2 <friend_lpn_matches+0x4e>
   2a3a4:	7a23      	ldrb	r3, [r4, #8]
   2a3a6:	4418      	add	r0, r3
   2a3a8:	4282      	cmp	r2, r0
   2a3aa:	bfac      	ite	ge
   2a3ac:	2000      	movge	r0, #0
   2a3ae:	2001      	movlt	r0, #1
   2a3b0:	e7f2      	b.n	2a398 <friend_lpn_matches+0x34>
		return false;
   2a3b2:	2000      	movs	r0, #0
   2a3b4:	e7f0      	b.n	2a398 <friend_lpn_matches+0x34>
			return true;
   2a3b6:	2001      	movs	r0, #1
   2a3b8:	e7ee      	b.n	2a398 <friend_lpn_matches+0x34>

0002a3ba <buf_send_start>:
{
   2a3ba:	b538      	push	{r3, r4, r5, lr}
	frnd->pending_buf = 0U;
   2a3bc:	78d3      	ldrb	r3, [r2, #3]
   2a3be:	f36f 03c3 	bfc	r3, #3, #1
	if (!frnd->established && frnd->last) {
   2a3c2:	f013 0510 	ands.w	r5, r3, #16
{
   2a3c6:	4614      	mov	r4, r2
	frnd->pending_buf = 0U;
   2a3c8:	70d3      	strb	r3, [r2, #3]
	if (!frnd->established && frnd->last) {
   2a3ca:	d106      	bne.n	2a3da <buf_send_start+0x20>
   2a3cc:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   2a3d0:	b118      	cbz	r0, 2a3da <buf_send_start+0x20>
		net_buf_unref(frnd->last);
   2a3d2:	f7f6 fa5f 	bl	20894 <net_buf_unref>
		frnd->last = NULL;
   2a3d6:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
}
   2a3da:	bd38      	pop	{r3, r4, r5, pc}

0002a3dc <z_log_msg2_static_create.constprop.0>:
   2a3dc:	2300      	movs	r3, #0
   2a3de:	f7fb bc7b 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a3e2 <net_buf_skip.isra.0>:
static inline struct net_buf *net_buf_skip(struct net_buf *buf, size_t len)
   2a3e2:	b538      	push	{r3, r4, r5, lr}
   2a3e4:	4604      	mov	r4, r0
   2a3e6:	460d      	mov	r5, r1
	while (buf && len--) {
   2a3e8:	b10c      	cbz	r4, 2a3ee <net_buf_skip.isra.0+0xc>
   2a3ea:	3d01      	subs	r5, #1
   2a3ec:	d200      	bcs.n	2a3f0 <net_buf_skip.isra.0+0xe>
}
   2a3ee:	bd38      	pop	{r3, r4, r5, pc}
	return net_buf_simple_pull_u8(&buf->b);
   2a3f0:	f104 0008 	add.w	r0, r4, #8
   2a3f4:	f001 fd22 	bl	2be3c <net_buf_simple_pull_u8>
		if (!buf->len) {
   2a3f8:	89a0      	ldrh	r0, [r4, #12]
   2a3fa:	2800      	cmp	r0, #0
   2a3fc:	d1f4      	bne.n	2a3e8 <net_buf_skip.isra.0+0x6>
			buf = net_buf_frag_del(NULL, buf);
   2a3fe:	4621      	mov	r1, r4
   2a400:	f001 fc8a 	bl	2bd18 <net_buf_frag_del>
   2a404:	4604      	mov	r4, r0
   2a406:	e7ef      	b.n	2a3e8 <net_buf_skip.isra.0+0x6>

0002a408 <purge_buffers>:
{
   2a408:	b538      	push	{r3, r4, r5, lr}
   2a40a:	4604      	mov	r4, r0
		buf->frags = NULL;
   2a40c:	2500      	movs	r5, #0
	return list->head;
   2a40e:	6820      	ldr	r0, [r4, #0]
	while (!sys_slist_is_empty(list)) {
   2a410:	b900      	cbnz	r0, 2a414 <purge_buffers+0xc>
}
   2a412:	bd38      	pop	{r3, r4, r5, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a414:	6862      	ldr	r2, [r4, #4]
	return node->next;
   2a416:	6803      	ldr	r3, [r0, #0]
	list->head = node;
   2a418:	6023      	str	r3, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a41a:	4290      	cmp	r0, r2
	list->tail = node;
   2a41c:	bf08      	it	eq
   2a41e:	6063      	streq	r3, [r4, #4]
		buf->flags &= ~NET_BUF_FRAGS;
   2a420:	7943      	ldrb	r3, [r0, #5]
		buf->frags = NULL;
   2a422:	6005      	str	r5, [r0, #0]
		buf->flags &= ~NET_BUF_FRAGS;
   2a424:	f023 0301 	bic.w	r3, r3, #1
   2a428:	7143      	strb	r3, [r0, #5]
		net_buf_unref(buf);
   2a42a:	f7f6 fa33 	bl	20894 <net_buf_unref>
   2a42e:	e7ee      	b.n	2a40e <purge_buffers+0x6>

0002a430 <clear_timeout>:
{
   2a430:	b538      	push	{r3, r4, r5, lr}
	if (frnd->clear.frnd == BT_MESH_ADDR_UNASSIGNED) {
   2a432:	f830 3c04 	ldrh.w	r3, [r0, #-4]
{
   2a436:	4604      	mov	r4, r0
	if (frnd->clear.frnd == BT_MESH_ADDR_UNASSIGNED) {
   2a438:	b1ab      	cbz	r3, 2a466 <clear_timeout+0x36>
   2a43a:	f002 fe89 	bl	2d150 <z_impl_k_uptime_ticks>
   2a43e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   2a442:	fba0 3005 	umull	r3, r0, r0, r5
   2a446:	fb05 0001 	mla	r0, r5, r1, r0
   2a44a:	0bdb      	lsrs	r3, r3, #15
	duration = k_uptime_get_32() - frnd->clear.start;
   2a44c:	f854 1c08 	ldr.w	r1, [r4, #-8]
	if (duration > 2 * frnd->poll_to) {
   2a450:	f854 2cb4 	ldr.w	r2, [r4, #-180]
   2a454:	ea43 4340 	orr.w	r3, r3, r0, lsl #17
	duration = k_uptime_get_32() - frnd->clear.start;
   2a458:	1a5b      	subs	r3, r3, r1
	if (duration > 2 * frnd->poll_to) {
   2a45a:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
   2a45e:	d903      	bls.n	2a468 <clear_timeout+0x38>
		frnd->clear.frnd = BT_MESH_ADDR_UNASSIGNED;
   2a460:	2300      	movs	r3, #0
   2a462:	f824 3c04 	strh.w	r3, [r4, #-4]
}
   2a466:	bd38      	pop	{r3, r4, r5, pc}
	send_friend_clear(frnd);
   2a468:	f1a4 00b8 	sub.w	r0, r4, #184	; 0xb8
}
   2a46c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	send_friend_clear(frnd);
   2a470:	f7ea bedc 	b.w	1522c <send_friend_clear>

0002a474 <is_seg>:
{
   2a474:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return list->head;
   2a478:	6804      	ldr	r4, [r0, #0]
   2a47a:	4688      	mov	r8, r1
   2a47c:	4616      	mov	r6, r2
	if (!buf) {
   2a47e:	b33c      	cbz	r4, 2a4d0 <is_seg+0x5c>
	net_buf_simple_save(&buf->b, &state);
   2a480:	f104 0908 	add.w	r9, r4, #8
	state->offset = net_buf_simple_headroom(buf);
   2a484:	4648      	mov	r0, r9
   2a486:	f001 fcfc 	bl	2be82 <net_buf_simple_headroom>
	net_buf_skip(buf, 5);   /* skip IVI, NID, CTL, TTL, SEQ */
   2a48a:	2105      	movs	r1, #5
   2a48c:	4605      	mov	r5, r0
   2a48e:	4620      	mov	r0, r4
	state->len = buf->len;
   2a490:	f8b4 a00c 	ldrh.w	sl, [r4, #12]
   2a494:	f7ff ffa5 	bl	2a3e2 <net_buf_skip.isra.0>
	return net_buf_simple_pull_be16(&buf->b);
   2a498:	4648      	mov	r0, r9
   2a49a:	f001 fcdf 	bl	2be5c <net_buf_simple_pull_be16>
	net_buf_skip(buf, 3);   /* skip DST, OP/AID */
   2a49e:	2103      	movs	r1, #3
   2a4a0:	4607      	mov	r7, r0
   2a4a2:	4620      	mov	r0, r4
   2a4a4:	f7ff ff9d 	bl	2a3e2 <net_buf_skip.isra.0>
   2a4a8:	4648      	mov	r0, r9
   2a4aa:	f001 fcd7 	bl	2be5c <net_buf_simple_pull_be16>
	buf->data = buf->__buf + state->offset;
   2a4ae:	6923      	ldr	r3, [r4, #16]
	buf->len = state->len;
   2a4b0:	f8a4 a00c 	strh.w	sl, [r4, #12]
	buf->data = buf->__buf + state->offset;
   2a4b4:	fa13 f585 	uxtah	r5, r3, r5
	return ((src == buf_src) && (seq_zero == buf_seq_zero));
   2a4b8:	45b8      	cmp	r8, r7
   2a4ba:	60a5      	str	r5, [r4, #8]
   2a4bc:	d106      	bne.n	2a4cc <is_seg+0x58>
   2a4be:	f3c0 008c 	ubfx	r0, r0, #2, #13
   2a4c2:	1b83      	subs	r3, r0, r6
   2a4c4:	4258      	negs	r0, r3
   2a4c6:	4158      	adcs	r0, r3
}
   2a4c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return ((src == buf_src) && (seq_zero == buf_seq_zero));
   2a4cc:	2000      	movs	r0, #0
   2a4ce:	e7fb      	b.n	2a4c8 <is_seg+0x54>
		return false;
   2a4d0:	4620      	mov	r0, r4
   2a4d2:	e7f9      	b.n	2a4c8 <is_seg+0x54>

0002a4d4 <friend_queue_has_space.part.0>:
static bool friend_queue_has_space(struct bt_mesh_friend *frnd, uint16_t addr,
   2a4d4:	b538      	push	{r3, r4, r5, lr}
   2a4d6:	4604      	mov	r4, r0
   2a4d8:	461d      	mov	r5, r3
		if (seq_auth && is_seg(seg, addr, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   2a4da:	b942      	cbnz	r2, 2a4ee <friend_queue_has_space.part.0+0x1a>
		total += seg->seg_count;
   2a4dc:	f894 0098 	ldrb.w	r0, [r4, #152]	; 0x98
	return (CONFIG_BT_MESH_FRIEND_QUEUE_SIZE - total) > seg_count;
   2a4e0:	f1c0 0010 	rsb	r0, r0, #16
   2a4e4:	42a8      	cmp	r0, r5
   2a4e6:	bf94      	ite	ls
   2a4e8:	2000      	movls	r0, #0
   2a4ea:	2001      	movhi	r0, #1
}
   2a4ec:	bd38      	pop	{r3, r4, r5, pc}
		if (seq_auth && is_seg(seg, addr, *seq_auth & TRANS_SEQ_ZERO_MASK)) {
   2a4ee:	8812      	ldrh	r2, [r2, #0]
   2a4f0:	3090      	adds	r0, #144	; 0x90
   2a4f2:	f3c2 020c 	ubfx	r2, r2, #0, #13
   2a4f6:	f7ff ffbd 	bl	2a474 <is_seg>
   2a4fa:	2800      	cmp	r0, #0
   2a4fc:	d1f6      	bne.n	2a4ec <friend_queue_has_space.part.0+0x18>
   2a4fe:	e7ed      	b.n	2a4dc <friend_queue_has_space.part.0+0x8>

0002a500 <friend_purge_old_ack>:
{
   2a500:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a504:	f8d0 40a0 	ldr.w	r4, [r0, #160]	; 0xa0
   2a508:	4682      	mov	sl, r0
   2a50a:	460f      	mov	r7, r1
   2a50c:	4690      	mov	r8, r2
	sys_snode_t *cur, *prev = NULL;
   2a50e:	2600      	movs	r6, #0
	for (cur = sys_slist_peek_head(&frnd->queue);
   2a510:	b90c      	cbnz	r4, 2a516 <friend_purge_old_ack+0x16>
}
   2a512:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (buf->len != 16) {
   2a516:	89a3      	ldrh	r3, [r4, #12]
   2a518:	2b10      	cmp	r3, #16
   2a51a:	d156      	bne.n	2a5ca <friend_purge_old_ack+0xca>
	net_buf_simple_save(&buf->b, &state);
   2a51c:	f104 0b08 	add.w	fp, r4, #8
	state->offset = net_buf_simple_headroom(buf);
   2a520:	4658      	mov	r0, fp
   2a522:	f001 fcae 	bl	2be82 <net_buf_simple_headroom>
	net_buf_skip(buf, 1); /* skip IVI, NID */
   2a526:	2101      	movs	r1, #1
   2a528:	4605      	mov	r5, r0
   2a52a:	4620      	mov	r0, r4
	state->len = buf->len;
   2a52c:	f8b4 900c 	ldrh.w	r9, [r4, #12]
   2a530:	f7ff ff57 	bl	2a3e2 <net_buf_skip.isra.0>
	return net_buf_simple_pull_u8(&buf->b);
   2a534:	4658      	mov	r0, fp
   2a536:	f001 fc81 	bl	2be3c <net_buf_simple_pull_u8>
	if (!(net_buf_pull_u8(buf) >> 7)) {
   2a53a:	0602      	lsls	r2, r0, #24
   2a53c:	d41e      	bmi.n	2a57c <friend_purge_old_ack+0x7c>
	bool found = false;
   2a53e:	2300      	movs	r3, #0
	buf->data = buf->__buf + state->offset;
   2a540:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
   2a542:	f8a4 900c 	strh.w	r9, [r4, #12]
	buf->data = buf->__buf + state->offset;
   2a546:	fa10 f585 	uxtah	r5, r0, r5
   2a54a:	60a5      	str	r5, [r4, #8]
		if (is_segack(buf, seq_auth, src)) {
   2a54c:	2b00      	cmp	r3, #0
   2a54e:	d03c      	beq.n	2a5ca <friend_purge_old_ack+0xca>
Z_GENLIST_REMOVE(slist, snode)
   2a550:	6823      	ldr	r3, [r4, #0]
   2a552:	f8da 20a4 	ldr.w	r2, [sl, #164]	; 0xa4
   2a556:	bb96      	cbnz	r6, 2a5be <friend_purge_old_ack+0xbe>
   2a558:	4294      	cmp	r4, r2
	list->head = node;
   2a55a:	f8ca 30a0 	str.w	r3, [sl, #160]	; 0xa0
Z_GENLIST_REMOVE(slist, snode)
   2a55e:	d101      	bne.n	2a564 <friend_purge_old_ack+0x64>
	list->tail = node;
   2a560:	f8ca 30a4 	str.w	r3, [sl, #164]	; 0xa4
			frnd->queue_size--;
   2a564:	f8da 30a8 	ldr.w	r3, [sl, #168]	; 0xa8
   2a568:	3b01      	subs	r3, #1
   2a56a:	f8ca 30a8 	str.w	r3, [sl, #168]	; 0xa8
			buf->frags = NULL;
   2a56e:	2300      	movs	r3, #0
   2a570:	6023      	str	r3, [r4, #0]
			net_buf_unref(buf);
   2a572:	4620      	mov	r0, r4
}
   2a574:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			net_buf_unref(buf);
   2a578:	f7f6 b98c 	b.w	20894 <net_buf_unref>
	return net_buf_simple_pull(&buf->b, len);
   2a57c:	2103      	movs	r1, #3
   2a57e:	4658      	mov	r0, fp
   2a580:	f001 fc4c 	bl	2be1c <net_buf_simple_pull>
	return net_buf_simple_pull_be16(&buf->b);
   2a584:	4658      	mov	r0, fp
   2a586:	f001 fc69 	bl	2be5c <net_buf_simple_pull_be16>
	if (src != net_buf_pull_be16(buf)) {
   2a58a:	4580      	cmp	r8, r0
   2a58c:	d1d7      	bne.n	2a53e <friend_purge_old_ack+0x3e>
	net_buf_skip(buf, 2); /* skip dst */
   2a58e:	2102      	movs	r1, #2
   2a590:	4620      	mov	r0, r4
   2a592:	f7ff ff26 	bl	2a3e2 <net_buf_skip.isra.0>
	return net_buf_simple_pull_mem(&buf->b, len);
   2a596:	2101      	movs	r1, #1
   2a598:	4658      	mov	r0, fp
   2a59a:	f001 fc47 	bl	2be2c <net_buf_simple_pull_mem>
	if (TRANS_CTL_OP((uint8_t *) net_buf_pull_mem(buf, 1)) != TRANS_CTL_OP_ACK) {
   2a59e:	7803      	ldrb	r3, [r0, #0]
   2a5a0:	065b      	lsls	r3, r3, #25
   2a5a2:	d1cc      	bne.n	2a53e <friend_purge_old_ack+0x3e>
	return net_buf_simple_pull_be16(&buf->b);
   2a5a4:	4658      	mov	r0, fp
   2a5a6:	f001 fc59 	bl	2be5c <net_buf_simple_pull_be16>
	found = ((net_buf_pull_be16(buf) >> 2) & TRANS_SEQ_ZERO_MASK) ==
   2a5aa:	f3c0 038f 	ubfx	r3, r0, #2, #16
   2a5ae:	6838      	ldr	r0, [r7, #0]
   2a5b0:	4043      	eors	r3, r0
   2a5b2:	f3c3 030c 	ubfx	r3, r3, #0, #13
   2a5b6:	fab3 f383 	clz	r3, r3
   2a5ba:	095b      	lsrs	r3, r3, #5
   2a5bc:	e7c0      	b.n	2a540 <friend_purge_old_ack+0x40>
Z_GENLIST_REMOVE(slist, snode)
   2a5be:	42a2      	cmp	r2, r4
	parent->next = child;
   2a5c0:	6033      	str	r3, [r6, #0]
	list->tail = node;
   2a5c2:	bf08      	it	eq
   2a5c4:	f8ca 60a4 	streq.w	r6, [sl, #164]	; 0xa4
}
   2a5c8:	e7cc      	b.n	2a564 <friend_purge_old_ack+0x64>
	return node->next;
   2a5ca:	4626      	mov	r6, r4
	     cur != NULL; prev = cur, cur = sys_slist_peek_next(cur)) {
   2a5cc:	6824      	ldr	r4, [r4, #0]
   2a5ce:	e79f      	b.n	2a510 <friend_purge_old_ack+0x10>

0002a5d0 <bt_mesh_prov_buf_init>:
}

static inline void bt_mesh_prov_buf_init(struct net_buf_simple *buf, uint8_t type)
{
   2a5d0:	b538      	push	{r3, r4, r5, lr}
   2a5d2:	4604      	mov	r4, r0
   2a5d4:	460d      	mov	r5, r1
	net_buf_simple_reserve(buf, PROV_BEARER_BUF_HEADROOM);
   2a5d6:	2105      	movs	r1, #5
   2a5d8:	f001 fb4a 	bl	2bc70 <net_buf_simple_reserve>
	net_buf_simple_add_u8(buf, type);
   2a5dc:	4629      	mov	r1, r5
   2a5de:	4620      	mov	r0, r4
}
   2a5e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_simple_add_u8(buf, type);
   2a5e4:	f001 bbb9 	b.w	2bd5a <net_buf_simple_add_u8>

0002a5e8 <z_log_msg2_static_create.constprop.0>:
   2a5e8:	2300      	movs	r3, #0
   2a5ea:	f7fb bb75 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a5ee <prov_fail>:
	prov_send_fail_msg(reason);
   2a5ee:	f7ec bb67 	b.w	16cc0 <prov_send_fail_msg>

0002a5f2 <sys_memcpy_swap.constprop.0>:
	for (; length > 0; length--) {
   2a5f2:	f101 0320 	add.w	r3, r1, #32
   2a5f6:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
   2a5f8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   2a5fc:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
   2a600:	428b      	cmp	r3, r1
   2a602:	d1f9      	bne.n	2a5f8 <sys_memcpy_swap.constprop.0+0x6>
}
   2a604:	4770      	bx	lr

0002a606 <atomic_or>:
{
   2a606:	4603      	mov	r3, r0
}
   2a608:	f3bf 8f5b 	dmb	ish
   2a60c:	e853 0f00 	ldrex	r0, [r3]
   2a610:	ea40 0201 	orr.w	r2, r0, r1
   2a614:	e843 2c00 	strex	ip, r2, [r3]
   2a618:	f1bc 0f00 	cmp.w	ip, #0
   2a61c:	d1f6      	bne.n	2a60c <atomic_or+0x6>
   2a61e:	f3bf 8f5b 	dmb	ish
   2a622:	4770      	bx	lr

0002a624 <z_log_msg2_static_create.constprop.0>:
   2a624:	2300      	movs	r3, #0
   2a626:	f7fb bb57 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a62a <net_buf_add_u8.isra.0>:
	return net_buf_simple_add_u8(&buf->b, val);
   2a62a:	3008      	adds	r0, #8
   2a62c:	f001 bb95 	b.w	2bd5a <net_buf_simple_add_u8>

0002a630 <buf_start>:
{
   2a630:	4608      	mov	r0, r1
   2a632:	4611      	mov	r1, r2
	if (err) {
   2a634:	b108      	cbz	r0, 2a63a <buf_start+0xa>
		buf_sent(err, user_data);
   2a636:	f7ed bd8f 	b.w	18158 <buf_sent>
}
   2a63a:	4770      	bx	lr

0002a63c <pb_adv_reset>:

void pb_adv_reset(void)
{
	reset_adv_link();
   2a63c:	f7ed b91e 	b.w	1787c <reset_adv_link>

0002a640 <clear_tx>:
}
   2a640:	4770      	bx	lr

0002a642 <pb_gatt_reset>:
}

void pb_gatt_reset(void)
{
	reset_state();
   2a642:	f7ed be2f 	b.w	182a4 <reset_state>

0002a646 <prov_ccc_changed>:
}
   2a646:	4770      	bx	lr

0002a648 <proxy_ccc_changed>:
}
   2a648:	4770      	bx	lr

0002a64a <beacon_send>:
{
   2a64a:	b530      	push	{r4, r5, lr}
   2a64c:	b08d      	sub	sp, #52	; 0x34
	NET_BUF_SIMPLE_DEFINE(buf, 23);
   2a64e:	ab06      	add	r3, sp, #24
   2a650:	f44f 12b8 	mov.w	r2, #1507328	; 0x170000
{
   2a654:	4604      	mov	r4, r0
   2a656:	460d      	mov	r5, r1
	net_buf_simple_reserve(&buf, 1);
   2a658:	a803      	add	r0, sp, #12
   2a65a:	2101      	movs	r1, #1
	NET_BUF_SIMPLE_DEFINE(buf, 23);
   2a65c:	e9cd 2304 	strd	r2, r3, [sp, #16]
   2a660:	9303      	str	r3, [sp, #12]
	net_buf_simple_reserve(&buf, 1);
   2a662:	f001 fb05 	bl	2bc70 <net_buf_simple_reserve>
	bt_mesh_beacon_create(sub, &buf);
   2a666:	a903      	add	r1, sp, #12
   2a668:	4628      	mov	r0, r5
   2a66a:	f7e1 fe83 	bl	c374 <bt_mesh_beacon_create>
	return bt_mesh_proxy_msg_send(client->cli, BT_MESH_PROXY_BEACON,
   2a66e:	2300      	movs	r3, #0
   2a670:	6820      	ldr	r0, [r4, #0]
   2a672:	9300      	str	r3, [sp, #0]
   2a674:	aa03      	add	r2, sp, #12
   2a676:	2101      	movs	r1, #1
   2a678:	f000 f83b 	bl	2a6f2 <bt_mesh_proxy_msg_send>
}
   2a67c:	b00d      	add	sp, #52	; 0x34
   2a67e:	bd30      	pop	{r4, r5, pc}

0002a680 <send_beacon_cb>:
{
   2a680:	b508      	push	{r3, lr}
   2a682:	460b      	mov	r3, r1
	return beacon_send(client, sub) != 0;
   2a684:	4601      	mov	r1, r0
   2a686:	4618      	mov	r0, r3
   2a688:	f7ff ffdf 	bl	2a64a <beacon_send>
}
   2a68c:	3800      	subs	r0, #0
   2a68e:	bf18      	it	ne
   2a690:	2001      	movne	r0, #1
   2a692:	bd08      	pop	{r3, pc}

0002a694 <buf_send_end>:
	net_buf_unref(buf);
   2a694:	4608      	mov	r0, r1
   2a696:	f7f6 b8fd 	b.w	20894 <net_buf_unref>

0002a69a <filter_add>:
{
   2a69a:	b510      	push	{r4, lr}
	if (addr == BT_MESH_ADDR_UNASSIGNED) {
   2a69c:	b179      	cbz	r1, 2a6be <filter_add+0x24>
		if (client->filter[i] == addr) {
   2a69e:	8883      	ldrh	r3, [r0, #4]
   2a6a0:	4299      	cmp	r1, r3
   2a6a2:	d00c      	beq.n	2a6be <filter_add+0x24>
   2a6a4:	88c4      	ldrh	r4, [r0, #6]
   2a6a6:	42a1      	cmp	r1, r4
   2a6a8:	d009      	beq.n	2a6be <filter_add+0x24>
   2a6aa:	8902      	ldrh	r2, [r0, #8]
   2a6ac:	4291      	cmp	r1, r2
   2a6ae:	d006      	beq.n	2a6be <filter_add+0x24>
		if (client->filter[i] == BT_MESH_ADDR_UNASSIGNED) {
   2a6b0:	b113      	cbz	r3, 2a6b8 <filter_add+0x1e>
   2a6b2:	b12c      	cbz	r4, 2a6c0 <filter_add+0x26>
   2a6b4:	b91a      	cbnz	r2, 2a6be <filter_add+0x24>
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   2a6b6:	2302      	movs	r3, #2
			client->filter[i] = addr;
   2a6b8:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   2a6bc:	8081      	strh	r1, [r0, #4]
}
   2a6be:	bd10      	pop	{r4, pc}
	for (i = 0; i < ARRAY_SIZE(client->filter); i++) {
   2a6c0:	2301      	movs	r3, #1
   2a6c2:	e7f9      	b.n	2a6b8 <filter_add+0x1e>

0002a6c4 <z_log_msg2_static_create.constprop.0>:
   2a6c4:	2300      	movs	r3, #0
   2a6c6:	f7fb bb07 	b.w	25cd8 <z_impl_z_log_msg2_static_create>

0002a6ca <sub_count_cb>:
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   2a6ca:	8b82      	ldrh	r2, [r0, #28]
   2a6cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2a6d0:	429a      	cmp	r2, r3
{
   2a6d2:	b510      	push	{r4, lr}
   2a6d4:	460c      	mov	r4, r1
	if (sub->net_idx == BT_MESH_KEY_UNUSED) {
   2a6d6:	d005      	beq.n	2a6e4 <sub_count_cb+0x1a>
	return (sub->node_id == BT_MESH_NODE_IDENTITY_RUNNING ||
   2a6d8:	7fc3      	ldrb	r3, [r0, #31]
   2a6da:	2b01      	cmp	r3, #1
   2a6dc:	d104      	bne.n	2a6e8 <sub_count_cb+0x1e>
		(*count)++;
   2a6de:	6823      	ldr	r3, [r4, #0]
   2a6e0:	3301      	adds	r3, #1
   2a6e2:	6023      	str	r3, [r4, #0]
}
   2a6e4:	2000      	movs	r0, #0
   2a6e6:	bd10      	pop	{r4, pc}
		bt_mesh_gatt_proxy_get() == BT_MESH_GATT_PROXY_ENABLED);
   2a6e8:	f7e1 fabe 	bl	bc68 <bt_mesh_gatt_proxy_get>
	if (advertise_subnet(sub)) {
   2a6ec:	2801      	cmp	r0, #1
   2a6ee:	d1f9      	bne.n	2a6e4 <sub_count_cb+0x1a>
   2a6f0:	e7f5      	b.n	2a6de <sub_count_cb+0x14>

0002a6f2 <bt_mesh_proxy_msg_send>:
{
   2a6f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct bt_conn *conn = role->conn;
   2a6f6:	f8d0 9000 	ldr.w	r9, [r0]
{
   2a6fa:	b085      	sub	sp, #20
   2a6fc:	4606      	mov	r6, r0
   2a6fe:	469a      	mov	sl, r3
	mtu = bt_gatt_get_mtu(conn) - 3;
   2a700:	4648      	mov	r0, r9
{
   2a702:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2a704:	9303      	str	r3, [sp, #12]
   2a706:	4688      	mov	r8, r1
   2a708:	4614      	mov	r4, r2
	mtu = bt_gatt_get_mtu(conn) - 3;
   2a70a:	f7fe fd7d 	bl	29208 <bt_gatt_get_mtu>
	if (mtu > msg->len) {
   2a70e:	88a3      	ldrh	r3, [r4, #4]
	mtu = bt_gatt_get_mtu(conn) - 3;
   2a710:	1ec5      	subs	r5, r0, #3
   2a712:	b2ad      	uxth	r5, r5
	if (mtu > msg->len) {
   2a714:	42ab      	cmp	r3, r5
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_COMPLETE, type));
   2a716:	f008 0b3f 	and.w	fp, r8, #63	; 0x3f
	if (mtu > msg->len) {
   2a71a:	d20f      	bcs.n	2a73c <bt_mesh_proxy_msg_send+0x4a>
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_COMPLETE, type));
   2a71c:	4659      	mov	r1, fp
			net_buf_simple_push_u8(msg, PDU_HDR(SAR_LAST, type));
   2a71e:	4620      	mov	r0, r4
   2a720:	f001 fb63 	bl	2bdea <net_buf_simple_push_u8>
			err = role->cb.send(conn, msg->data, msg->len, end, user_data);
   2a724:	68b5      	ldr	r5, [r6, #8]
   2a726:	9b03      	ldr	r3, [sp, #12]
   2a728:	88a2      	ldrh	r2, [r4, #4]
   2a72a:	6821      	ldr	r1, [r4, #0]
   2a72c:	930e      	str	r3, [sp, #56]	; 0x38
   2a72e:	4648      	mov	r0, r9
   2a730:	4653      	mov	r3, sl
   2a732:	46ac      	mov	ip, r5
}
   2a734:	b005      	add	sp, #20
   2a736:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			err = role->cb.send(conn, msg->data, msg->len, end, user_data);
   2a73a:	4760      	bx	ip
	net_buf_simple_push_u8(msg, PDU_HDR(SAR_FIRST, type));
   2a73c:	f04b 0140 	orr.w	r1, fp, #64	; 0x40
   2a740:	4620      	mov	r0, r4
   2a742:	f001 fb52 	bl	2bdea <net_buf_simple_push_u8>
	err = role->cb.send(conn, msg->data, mtu, NULL, NULL);
   2a746:	2300      	movs	r3, #0
   2a748:	68b7      	ldr	r7, [r6, #8]
   2a74a:	6821      	ldr	r1, [r4, #0]
   2a74c:	9300      	str	r3, [sp, #0]
   2a74e:	462a      	mov	r2, r5
   2a750:	4648      	mov	r0, r9
   2a752:	47b8      	blx	r7
	if (err) {
   2a754:	4607      	mov	r7, r0
   2a756:	b938      	cbnz	r0, 2a768 <bt_mesh_proxy_msg_send+0x76>
	net_buf_simple_pull(msg, mtu);
   2a758:	4629      	mov	r1, r5
   2a75a:	4620      	mov	r0, r4
   2a75c:	f001 fb5e 	bl	2be1c <net_buf_simple_pull>
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_CONT, type));
   2a760:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
	while (msg->len) {
   2a764:	88a3      	ldrh	r3, [r4, #4]
   2a766:	b91b      	cbnz	r3, 2a770 <bt_mesh_proxy_msg_send+0x7e>
}
   2a768:	4638      	mov	r0, r7
   2a76a:	b005      	add	sp, #20
   2a76c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (msg->len + 1 < mtu) {
   2a770:	3301      	adds	r3, #1
   2a772:	42ab      	cmp	r3, r5
   2a774:	da02      	bge.n	2a77c <bt_mesh_proxy_msg_send+0x8a>
			net_buf_simple_push_u8(msg, PDU_HDR(SAR_LAST, type));
   2a776:	f048 01c0 	orr.w	r1, r8, #192	; 0xc0
   2a77a:	e7d0      	b.n	2a71e <bt_mesh_proxy_msg_send+0x2c>
		net_buf_simple_push_u8(msg, PDU_HDR(SAR_CONT, type));
   2a77c:	4659      	mov	r1, fp
   2a77e:	4620      	mov	r0, r4
   2a780:	f001 fb33 	bl	2bdea <net_buf_simple_push_u8>
		err = role->cb.send(conn, msg->data, mtu, NULL, NULL);
   2a784:	2300      	movs	r3, #0
   2a786:	6821      	ldr	r1, [r4, #0]
   2a788:	f8d6 c008 	ldr.w	ip, [r6, #8]
   2a78c:	9300      	str	r3, [sp, #0]
   2a78e:	462a      	mov	r2, r5
   2a790:	4648      	mov	r0, r9
   2a792:	47e0      	blx	ip
		if (err) {
   2a794:	b920      	cbnz	r0, 2a7a0 <bt_mesh_proxy_msg_send+0xae>
		net_buf_simple_pull(msg, mtu);
   2a796:	4629      	mov	r1, r5
   2a798:	4620      	mov	r0, r4
   2a79a:	f001 fb3f 	bl	2be1c <net_buf_simple_pull>
   2a79e:	e7e1      	b.n	2a764 <bt_mesh_proxy_msg_send+0x72>
   2a7a0:	4607      	mov	r7, r0
   2a7a2:	e7e1      	b.n	2a768 <bt_mesh_proxy_msg_send+0x76>

0002a7a4 <bt_mesh_proxy_role_cleanup>:

void bt_mesh_proxy_role_cleanup(struct bt_mesh_proxy_role *role)
{
   2a7a4:	b510      	push	{r4, lr}
   2a7a6:	4604      	mov	r4, r0
	/* If this fails, the work handler exits early, as
	 * there's no active connection.
	 */
	(void)k_work_cancel_delayable(&role->sar_timer);
   2a7a8:	3010      	adds	r0, #16
   2a7aa:	f002 fb2c 	bl	2ce06 <k_work_cancel_delayable>
	bt_conn_unref(role->conn);
   2a7ae:	6820      	ldr	r0, [r4, #0]
   2a7b0:	f7fd fd9d 	bl	282ee <bt_conn_unref>
	role->conn = NULL;
   2a7b4:	2300      	movs	r3, #0
   2a7b6:	6023      	str	r3, [r4, #0]

	bt_mesh_adv_gatt_update();
}
   2a7b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_mesh_adv_gatt_update();
   2a7bc:	f7ff bd55 	b.w	2a26a <bt_mesh_adv_gatt_update>

0002a7c0 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, uint16_t mem_size, uint16_t mem_count,
	      void **mem_head)
{
   2a7c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   2a7c2:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   2a7c4:	1dc3      	adds	r3, r0, #7
{
   2a7c6:	4605      	mov	r5, r0
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   2a7c8:	f023 0303 	bic.w	r3, r3, #3

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2a7cc:	1e50      	subs	r0, r2, #1
{
   2a7ce:	460e      	mov	r6, r1
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2a7d0:	b280      	uxth	r0, r0
{
   2a7d2:	4614      	mov	r4, r2
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   2a7d4:	801a      	strh	r2, [r3, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2a7d6:	2100      	movs	r1, #0
   2a7d8:	2204      	movs	r2, #4
   2a7da:	fb06 5000 	mla	r0, r6, r0, r5
   2a7de:	f7fd f852 	bl	27886 <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   2a7e2:	3c02      	subs	r4, #2
   2a7e4:	b2a4      	uxth	r4, r4
   2a7e6:	f64f 77ff 	movw	r7, #65535	; 0xffff
   2a7ea:	42bc      	cmp	r4, r7
   2a7ec:	d101      	bne.n	2a7f2 <mem_init+0x32>
		next = (uint32_t)((uint8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   2a7ee:	b003      	add	sp, #12
   2a7f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   2a7f2:	1c63      	adds	r3, r4, #1
   2a7f4:	b29b      	uxth	r3, r3
   2a7f6:	4373      	muls	r3, r6
		next = (uint32_t)((uint8_t *) mem_pool +
   2a7f8:	18ea      	adds	r2, r5, r3
   2a7fa:	9201      	str	r2, [sp, #4]
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
   2a7fc:	1b98      	subs	r0, r3, r6
   2a7fe:	2204      	movs	r2, #4
   2a800:	eb0d 0102 	add.w	r1, sp, r2
   2a804:	4428      	add	r0, r5
   2a806:	3c01      	subs	r4, #1
   2a808:	f7fd f832 	bl	27870 <memcpy>
   2a80c:	b2a4      	uxth	r4, r4
   2a80e:	e7ec      	b.n	2a7ea <mem_init+0x2a>

0002a810 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   2a810:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   2a812:	6804      	ldr	r4, [r0, #0]
{
   2a814:	4605      	mov	r5, r0
	if (*mem_head) {
   2a816:	b18c      	cbz	r4, 2a83c <mem_acquire+0x2c>
		uint16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   2a818:	1de3      	adds	r3, r4, #7
   2a81a:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   2a81e:	2204      	movs	r2, #4
   2a820:	4621      	mov	r1, r4
   2a822:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   2a826:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   2a828:	f7fd f822 	bl	27870 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   2a82c:	9b01      	ldr	r3, [sp, #4]
   2a82e:	b123      	cbz	r3, 2a83a <mem_acquire+0x2a>
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   2a830:	1dda      	adds	r2, r3, #7
   2a832:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   2a836:	3e01      	subs	r6, #1
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   2a838:	8016      	strh	r6, [r2, #0]
				free_count;
		}

		*mem_head = head;
   2a83a:	602b      	str	r3, [r5, #0]
		return mem;
	}

	return NULL;
}
   2a83c:	4620      	mov	r0, r4
   2a83e:	b002      	add	sp, #8
   2a840:	bd70      	pop	{r4, r5, r6, pc}

0002a842 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   2a842:	b570      	push	{r4, r5, r6, lr}
	uint16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   2a844:	680c      	ldr	r4, [r1, #0]
{
   2a846:	4606      	mov	r6, r0
   2a848:	460d      	mov	r5, r1
	if (*mem_head) {
   2a84a:	b11c      	cbz	r4, 2a854 <mem_release+0x12>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   2a84c:	1de3      	adds	r3, r4, #7
   2a84e:	f023 0303 	bic.w	r3, r3, #3
   2a852:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   2a854:	2204      	movs	r2, #4
   2a856:	4629      	mov	r1, r5
   2a858:	4630      	mov	r0, r6
   2a85a:	f7fd f809 	bl	27870 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
   2a85e:	1df2      	adds	r2, r6, #7
   2a860:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   2a864:	1c63      	adds	r3, r4, #1
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
   2a866:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   2a868:	602e      	str	r6, [r5, #0]
}
   2a86a:	bd70      	pop	{r4, r5, r6, pc}

0002a86c <mem_get>:
}

void *mem_get(void *mem_pool, uint16_t mem_size, uint16_t index)
{
	return ((void *)((uint8_t *)mem_pool + (mem_size * index)));
}
   2a86c:	fb02 0001 	mla	r0, r2, r1, r0
   2a870:	4770      	bx	lr

0002a872 <mem_index_get>:

uint16_t mem_index_get(void *mem, void *mem_pool, uint16_t mem_size)
{
	return ((uint16_t)((uint8_t *)mem - (uint8_t *)mem_pool) / mem_size);
   2a872:	1a40      	subs	r0, r0, r1
   2a874:	b280      	uxth	r0, r0
}
   2a876:	fbb0 f0f2 	udiv	r0, r0, r2
   2a87a:	4770      	bx	lr

0002a87c <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(uint8_t *dst, uint8_t const *src, uint16_t len)
{
   2a87c:	b510      	push	{r4, lr}
	src += len;
   2a87e:	4411      	add	r1, r2
	while (len--) {
   2a880:	3801      	subs	r0, #1
   2a882:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2a886:	3a01      	subs	r2, #1
   2a888:	b292      	uxth	r2, r2
   2a88a:	429a      	cmp	r2, r3
   2a88c:	d100      	bne.n	2a890 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   2a88e:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   2a890:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   2a894:	f800 4f01 	strb.w	r4, [r0, #1]!
   2a898:	e7f5      	b.n	2a886 <mem_rcopy+0xa>

0002a89a <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
uint8_t mem_nz(uint8_t *src, uint16_t len)
{
	while (len--) {
   2a89a:	4401      	add	r1, r0
   2a89c:	4288      	cmp	r0, r1
   2a89e:	d101      	bne.n	2a8a4 <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   2a8a0:	2000      	movs	r0, #0
   2a8a2:	4770      	bx	lr
		if (*src++) {
   2a8a4:	f810 3b01 	ldrb.w	r3, [r0], #1
   2a8a8:	2b00      	cmp	r3, #0
   2a8aa:	d0f7      	beq.n	2a89c <mem_nz+0x2>
			return 1;
   2a8ac:	2001      	movs	r0, #1
}
   2a8ae:	4770      	bx	lr

0002a8b0 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   2a8b0:	6010      	str	r0, [r2, #0]
   2a8b2:	6008      	str	r0, [r1, #0]

	return link;
}
   2a8b4:	4770      	bx	lr

0002a8b6 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   2a8b6:	680a      	ldr	r2, [r1, #0]
{
   2a8b8:	4603      	mov	r3, r0
	if (*head != *tail) {
   2a8ba:	6800      	ldr	r0, [r0, #0]
   2a8bc:	4290      	cmp	r0, r2
   2a8be:	f04f 0200 	mov.w	r2, #0
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
   2a8c2:	bf0a      	itet	eq
   2a8c4:	600a      	streq	r2, [r1, #0]
		return NULL;
   2a8c6:	4610      	movne	r0, r2
	*head = *tail = NULL;
   2a8c8:	601a      	streq	r2, [r3, #0]

	return old_head;
}
   2a8ca:	4770      	bx	lr

0002a8cc <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   2a8cc:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   2a8ce:	6814      	ldr	r4, [r2, #0]
   2a8d0:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   2a8d2:	6814      	ldr	r4, [r2, #0]
   2a8d4:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	cpu_dmb(); /* Ensure data accesses are synchronized */
	*tail = link; /* Commit: enqueue of memq node */
   2a8d6:	6010      	str	r0, [r2, #0]

	return link;
}
   2a8d8:	bd10      	pop	{r4, pc}

0002a8da <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   2a8da:	4288      	cmp	r0, r1
   2a8dc:	d003      	beq.n	2a8e6 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   2a8de:	b11a      	cbz	r2, 2a8e8 <memq_peek+0xe>
		*mem = head->mem;
   2a8e0:	6843      	ldr	r3, [r0, #4]
   2a8e2:	6013      	str	r3, [r2, #0]
   2a8e4:	4770      	bx	lr
		return NULL;
   2a8e6:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   2a8e8:	4770      	bx	lr

0002a8ea <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   2a8ea:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   2a8ec:	4283      	cmp	r3, r0
   2a8ee:	d009      	beq.n	2a904 <memq_dequeue+0x1a>
	if (mem) {
   2a8f0:	b122      	cbz	r2, 2a8fc <memq_dequeue+0x12>
		*mem = head->mem;
   2a8f2:	6858      	ldr	r0, [r3, #4]
   2a8f4:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   2a8f6:	681a      	ldr	r2, [r3, #0]
   2a8f8:	600a      	str	r2, [r1, #0]

	return old_head;
   2a8fa:	e001      	b.n	2a900 <memq_dequeue+0x16>
	if (old_head == NULL) {
   2a8fc:	2b00      	cmp	r3, #0
   2a8fe:	d1fa      	bne.n	2a8f6 <memq_dequeue+0xc>
}
   2a900:	4618      	mov	r0, r3
   2a902:	4770      	bx	lr
		return NULL; /* queue is empty */
   2a904:	2300      	movs	r3, #0
   2a906:	e7fb      	b.n	2a900 <memq_dequeue+0x16>

0002a908 <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
uint8_t util_ones_count_get(const uint8_t *octets, uint8_t octets_len)
{
   2a908:	b510      	push	{r4, lr}
   2a90a:	1e43      	subs	r3, r0, #1
	uint8_t one_count = 0U;
   2a90c:	2000      	movs	r0, #0

	while (octets_len--) {
   2a90e:	3901      	subs	r1, #1
   2a910:	b2c9      	uxtb	r1, r1
   2a912:	29ff      	cmp	r1, #255	; 0xff
   2a914:	d100      	bne.n	2a918 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
   2a916:	bd10      	pop	{r4, pc}
		bite = *octets;
   2a918:	f813 2f01 	ldrb.w	r2, [r3, #1]!
		while (bite) {
   2a91c:	2a00      	cmp	r2, #0
   2a91e:	d0f6      	beq.n	2a90e <util_ones_count_get+0x6>
			bite &= (bite - 1);
   2a920:	1e54      	subs	r4, r2, #1
			one_count++;
   2a922:	3001      	adds	r0, #1
			bite &= (bite - 1);
   2a924:	4022      	ands	r2, r4
			one_count++;
   2a926:	b2c0      	uxtb	r0, r0
   2a928:	e7f8      	b.n	2a91c <util_ones_count_get+0x14>

0002a92a <ticker_dequeue>:
{
   2a92a:	b5f0      	push	{r4, r5, r6, r7, lr}
	previous = instance->ticker_id_head;
   2a92c:	7f42      	ldrb	r2, [r0, #29]
	node = &instance->nodes[0];
   2a92e:	6806      	ldr	r6, [r0, #0]
{
   2a930:	4605      	mov	r5, r0
   2a932:	468c      	mov	ip, r1
	previous = instance->ticker_id_head;
   2a934:	4613      	mov	r3, r2
	total = 0U;
   2a936:	2000      	movs	r0, #0
	while (current != TICKER_NULL) {
   2a938:	2aff      	cmp	r2, #255	; 0xff
   2a93a:	d101      	bne.n	2a940 <ticker_dequeue+0x16>
		return 0;
   2a93c:	2000      	movs	r0, #0
}
   2a93e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticker_current = &node[current];
   2a940:	eb02 0442 	add.w	r4, r2, r2, lsl #1
   2a944:	0127      	lsls	r7, r4, #4
   2a946:	eb06 1404 	add.w	r4, r6, r4, lsl #4
		if (current == id) {
   2a94a:	4562      	cmp	r2, ip
		total += ticker_current->ticks_to_expire;
   2a94c:	68a1      	ldr	r1, [r4, #8]
		current = ticker_current->next;
   2a94e:	5df7      	ldrb	r7, [r6, r7]
		total += ticker_current->ticks_to_expire;
   2a950:	4408      	add	r0, r1
		if (current == id) {
   2a952:	d002      	beq.n	2a95a <ticker_dequeue+0x30>
   2a954:	4613      	mov	r3, r2
		current = ticker_current->next;
   2a956:	463a      	mov	r2, r7
   2a958:	e7ee      	b.n	2a938 <ticker_dequeue+0xe>
	if (previous == current) {
   2a95a:	4293      	cmp	r3, r2
   2a95c:	d100      	bne.n	2a960 <ticker_dequeue+0x36>
		instance->ticker_id_head = ticker_current->next;
   2a95e:	776f      	strb	r7, [r5, #29]
	node[previous].next = ticker_current->next;
   2a960:	b21b      	sxth	r3, r3
   2a962:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2a966:	011b      	lsls	r3, r3, #4
   2a968:	54f7      	strb	r7, [r6, r3]
	if (ticker_current->next != TICKER_NULL) {
   2a96a:	7823      	ldrb	r3, [r4, #0]
   2a96c:	2bff      	cmp	r3, #255	; 0xff
   2a96e:	d0e6      	beq.n	2a93e <ticker_dequeue+0x14>
		node[ticker_current->next].ticks_to_expire += timeout;
   2a970:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2a974:	eb06 1303 	add.w	r3, r6, r3, lsl #4
   2a978:	689a      	ldr	r2, [r3, #8]
   2a97a:	440a      	add	r2, r1
   2a97c:	609a      	str	r2, [r3, #8]
	return (total + timeout);
   2a97e:	e7de      	b.n	2a93e <ticker_dequeue+0x14>

0002a980 <ticks_to_expire_prep>:
{
   2a980:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   2a982:	1a55      	subs	r5, r2, r1
   2a984:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
   2a988:	6883      	ldr	r3, [r0, #8]
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   2a98a:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   2a98c:	d109      	bne.n	2a9a2 <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2a98e:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   2a992:	442b      	add	r3, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
   2a994:	42a3      	cmp	r3, r4
   2a996:	d90e      	bls.n	2a9b6 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   2a998:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
   2a99a:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   2a99c:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   2a99e:	6144      	str	r4, [r0, #20]
}
   2a9a0:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2a9a2:	1a8a      	subs	r2, r1, r2
   2a9a4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   2a9a8:	4293      	cmp	r3, r2
   2a9aa:	d901      	bls.n	2a9b0 <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   2a9ac:	1a9b      	subs	r3, r3, r2
   2a9ae:	e7f1      	b.n	2a994 <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   2a9b0:	4414      	add	r4, r2
   2a9b2:	1ae4      	subs	r4, r4, r3
			ticks_to_expire = 0U;
   2a9b4:	2300      	movs	r3, #0
		ticks_to_expire_minus -= ticks_to_expire;
   2a9b6:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
   2a9b8:	2300      	movs	r3, #0
   2a9ba:	e7ef      	b.n	2a99c <ticks_to_expire_prep+0x1c>

0002a9bc <ticker_job_op_cb>:
{
   2a9bc:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   2a9be:	2200      	movs	r2, #0
   2a9c0:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   2a9c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	user_op->status = status;
   2a9c4:	6299      	str	r1, [r3, #40]	; 0x28
{
   2a9c6:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   2a9c8:	b10a      	cbz	r2, 2a9ce <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   2a9ca:	6b19      	ldr	r1, [r3, #48]	; 0x30
   2a9cc:	4710      	bx	r2
}
   2a9ce:	4770      	bx	lr

0002a9d0 <ticker_job_list_insert>:
{
   2a9d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a9d4:	b089      	sub	sp, #36	; 0x24
	node = &instance->nodes[0];
   2a9d6:	6803      	ldr	r3, [r0, #0]
   2a9d8:	9303      	str	r3, [sp, #12]
	users = &instance->users[0];
   2a9da:	6843      	ldr	r3, [r0, #4]
   2a9dc:	9305      	str	r3, [sp, #20]
	while (count_user--) {
   2a9de:	7a43      	ldrb	r3, [r0, #9]
{
   2a9e0:	4606      	mov	r6, r0
   2a9e2:	4688      	mov	r8, r1
   2a9e4:	3b01      	subs	r3, #1
   2a9e6:	fa5f fa83 	uxtb.w	sl, r3
	while (count_user--) {
   2a9ea:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   2a9ee:	d102      	bne.n	2a9f6 <ticker_job_list_insert+0x26>
}
   2a9f0:	b009      	add	sp, #36	; 0x24
   2a9f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		user = &users[count_user];
   2a9f6:	9b05      	ldr	r3, [sp, #20]
   2a9f8:	eb03 0bca 	add.w	fp, r3, sl, lsl #3
		user_ops = (void *)&user->user_op[0];
   2a9fc:	f8db 3004 	ldr.w	r3, [fp, #4]
		user_ops_first = user->first;
   2aa00:	f89b 7001 	ldrb.w	r7, [fp, #1]
		user_ops = (void *)&user->user_op[0];
   2aa04:	9304      	str	r3, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
   2aa06:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   2aa0a:	d076      	beq.n	2aafa <ticker_job_list_insert+0x12a>
				ticker = &node[id_insert];
   2aa0c:	eb08 0448 	add.w	r4, r8, r8, lsl #1
   2aa10:	9a03      	ldr	r2, [sp, #12]
   2aa12:	f8cd 8008 	str.w	r8, [sp, #8]
   2aa16:	0123      	lsls	r3, r4, #4
				user_op = NULL;
   2aa18:	2500      	movs	r5, #0
				insert_head = ticker->next;
   2aa1a:	f812 8003 	ldrb.w	r8, [r2, r3]
				ticker = &node[id_insert];
   2aa1e:	eb02 1404 	add.w	r4, r2, r4, lsl #4
	ticker->next = TICKER_NULL;
   2aa22:	23ff      	movs	r3, #255	; 0xff
   2aa24:	7023      	strb	r3, [r4, #0]
	ticker_new = &node[id];
   2aa26:	f9bd c008 	ldrsh.w	ip, [sp, #8]
	node = &instance->nodes[0];
   2aa2a:	6830      	ldr	r0, [r6, #0]
	ticker_new = &node[id];
   2aa2c:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   2aa30:	ea4f 120c 	mov.w	r2, ip, lsl #4
   2aa34:	eb00 1c0c 	add.w	ip, r0, ip, lsl #4
   2aa38:	9206      	str	r2, [sp, #24]
	ticks_to_expire = ticker_new->ticks_to_expire;
   2aa3a:	f8dc 2008 	ldr.w	r2, [ip, #8]
   2aa3e:	9201      	str	r2, [sp, #4]
	current = instance->ticker_id_head;
   2aa40:	7f72      	ldrb	r2, [r6, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   2aa42:	2aff      	cmp	r2, #255	; 0xff
   2aa44:	d00c      	beq.n	2aa60 <ticker_job_list_insert+0x90>
		(ticker_current = &node[current])->ticks_to_expire))) {
   2aa46:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
   2aa4a:	ea4f 110e 	mov.w	r1, lr, lsl #4
   2aa4e:	eb00 1e0e 	add.w	lr, r0, lr, lsl #4
   2aa52:	9107      	str	r1, [sp, #28]
		(ticks_to_expire_current =
   2aa54:	f8de 9008 	ldr.w	r9, [lr, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   2aa58:	9901      	ldr	r1, [sp, #4]
   2aa5a:	4549      	cmp	r1, r9
   2aa5c:	f080 8085 	bcs.w	2ab6a <ticker_job_list_insert+0x19a>
	if (previous == TICKER_NULL) {
   2aa60:	2bff      	cmp	r3, #255	; 0xff
		node[previous].next = id;
   2aa62:	bf18      	it	ne
   2aa64:	b21b      	sxthne	r3, r3
	ticker_new->ticks_to_expire = ticks_to_expire;
   2aa66:	9901      	ldr	r1, [sp, #4]
   2aa68:	f8cc 1008 	str.w	r1, [ip, #8]
		node[previous].next = id;
   2aa6c:	bf18      	it	ne
   2aa6e:	eb03 0343 	addne.w	r3, r3, r3, lsl #1
	ticker_new->next = current;
   2aa72:	9906      	ldr	r1, [sp, #24]
		instance->ticker_id_head = id;
   2aa74:	bf08      	it	eq
   2aa76:	9b02      	ldreq	r3, [sp, #8]
	ticker_new->next = current;
   2aa78:	5442      	strb	r2, [r0, r1]
		node[previous].next = id;
   2aa7a:	bf1d      	ittte	ne
   2aa7c:	011b      	lslne	r3, r3, #4
   2aa7e:	9902      	ldrne	r1, [sp, #8]
   2aa80:	54c1      	strbne	r1, [r0, r3]
		instance->ticker_id_head = id;
   2aa82:	7773      	strbeq	r3, [r6, #29]
	if (current != TICKER_NULL) {
   2aa84:	2aff      	cmp	r2, #255	; 0xff
   2aa86:	d007      	beq.n	2aa98 <ticker_job_list_insert+0xc8>
		node[current].ticks_to_expire -= ticks_to_expire;
   2aa88:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2aa8c:	eb00 1202 	add.w	r2, r0, r2, lsl #4
   2aa90:	9901      	ldr	r1, [sp, #4]
   2aa92:	6893      	ldr	r3, [r2, #8]
   2aa94:	1a5b      	subs	r3, r3, r1
   2aa96:	6093      	str	r3, [r2, #8]
	ticker->req = ticker->ack + 1;
   2aa98:	78a3      	ldrb	r3, [r4, #2]
   2aa9a:	3301      	adds	r3, #1
   2aa9c:	7063      	strb	r3, [r4, #1]
			if (user_op) {
   2aa9e:	2d00      	cmp	r5, #0
   2aaa0:	d0b1      	beq.n	2aa06 <ticker_job_list_insert+0x36>
				ticker_job_op_cb(user_op, status);
   2aaa2:	2100      	movs	r1, #0
   2aaa4:	4628      	mov	r0, r5
   2aaa6:	f7ff ff89 	bl	2a9bc <ticker_job_op_cb>
				if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   2aaaa:	6863      	ldr	r3, [r4, #4]
   2aaac:	2b00      	cmp	r3, #0
   2aaae:	d1aa      	bne.n	2aa06 <ticker_job_list_insert+0x36>
					ticker->fp_op_func =
   2aab0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   2aab2:	6223      	str	r3, [r4, #32]
					ticker->op_context =
   2aab4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   2aab6:	6263      	str	r3, [r4, #36]	; 0x24
   2aab8:	e7a5      	b.n	2aa06 <ticker_job_list_insert+0x36>
				user_op = &user_ops[user_ops_first];
   2aaba:	9a04      	ldr	r2, [sp, #16]
   2aabc:	2334      	movs	r3, #52	; 0x34
   2aabe:	fb17 f303 	smulbb	r3, r7, r3
   2aac2:	18d5      	adds	r5, r2, r3
				first = user_ops_first + 1;
   2aac4:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
   2aac6:	f89b 2000 	ldrb.w	r2, [fp]
				first = user_ops_first + 1;
   2aaca:	b2ff      	uxtb	r7, r7
					first = 0U;
   2aacc:	42ba      	cmp	r2, r7
   2aace:	bf08      	it	eq
   2aad0:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   2aad2:	9a04      	ldr	r2, [sp, #16]
   2aad4:	5cd3      	ldrb	r3, [r2, r3]
   2aad6:	2b04      	cmp	r3, #4
   2aad8:	d10f      	bne.n	2aafa <ticker_job_list_insert+0x12a>
				id_insert = user_op->id;
   2aada:	786b      	ldrb	r3, [r5, #1]
   2aadc:	9302      	str	r3, [sp, #8]
				ticker = &node[id_insert];
   2aade:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   2aae2:	9b03      	ldr	r3, [sp, #12]
   2aae4:	eb03 1404 	add.w	r4, r3, r4, lsl #4
				if (((ticker->req -
   2aae8:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
   2aaea:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
   2aaec:	1a9b      	subs	r3, r3, r2
				      ticker->ack) & 0xff) != 0U) {
   2aaee:	b2db      	uxtb	r3, r3
				if (((ticker->req -
   2aaf0:	b153      	cbz	r3, 2ab08 <ticker_job_list_insert+0x138>
					ticker_job_op_cb(user_op,
   2aaf2:	2101      	movs	r1, #1
   2aaf4:	4628      	mov	r0, r5
   2aaf6:	f7ff ff61 	bl	2a9bc <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   2aafa:	f89b 3002 	ldrb.w	r3, [fp, #2]
   2aafe:	42bb      	cmp	r3, r7
   2ab00:	d1db      	bne.n	2aaba <ticker_job_list_insert+0xea>
   2ab02:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   2ab06:	e76e      	b.n	2a9e6 <ticker_job_list_insert+0x16>
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   2ab08:	8aab      	ldrh	r3, [r5, #20]
				ticker_job_op_start(ticker, user_op,
   2ab0a:	6971      	ldr	r1, [r6, #20]
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   2ab0c:	f64f 72fe 	movw	r2, #65534	; 0xfffe
   2ab10:	4293      	cmp	r3, r2
   2ab12:	d006      	beq.n	2ab22 <ticker_job_list_insert+0x152>
		ticker->must_expire =
   2ab14:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2ab18:	1a98      	subs	r0, r3, r2
   2ab1a:	4242      	negs	r2, r0
   2ab1c:	4142      	adcs	r2, r0
   2ab1e:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
   2ab22:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   2ab24:	62a2      	str	r2, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   2ab26:	68ea      	ldr	r2, [r5, #12]
   2ab28:	6062      	str	r2, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
   2ab2a:	692a      	ldr	r2, [r5, #16]
   2ab2c:	6222      	str	r2, [r4, #32]
	ticker->lazy_periodic =
   2ab2e:	f64f 72fd 	movw	r2, #65533	; 0xfffd
   2ab32:	4293      	cmp	r3, r2
   2ab34:	bf88      	it	hi
   2ab36:	2300      	movhi	r3, #0
   2ab38:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
   2ab3a:	69ab      	ldr	r3, [r5, #24]
   2ab3c:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
   2ab3e:	69eb      	ldr	r3, [r5, #28]
   2ab40:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
   2ab42:	6a2b      	ldr	r3, [r5, #32]
   2ab44:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire_minus = 0U;
   2ab46:	f04f 0900 	mov.w	r9, #0
	ticker->ticks_to_expire = start->ticks_first;
   2ab4a:	68ab      	ldr	r3, [r5, #8]
   2ab4c:	60a3      	str	r3, [r4, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   2ab4e:	686a      	ldr	r2, [r5, #4]
	ticker->ticks_to_expire_minus = 0U;
   2ab50:	f8c4 9014 	str.w	r9, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   2ab54:	4620      	mov	r0, r4
   2ab56:	f7ff ff13 	bl	2a980 <ticks_to_expire_prep>
	ticker->force = 1U;
   2ab5a:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
   2ab5e:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
   2ab62:	f8a4 901e 	strh.w	r9, [r4, #30]
	ticker->force = 1U;
   2ab66:	70e3      	strb	r3, [r4, #3]
}
   2ab68:	e75b      	b.n	2aa22 <ticker_job_list_insert+0x52>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   2ab6a:	9901      	ldr	r1, [sp, #4]
   2ab6c:	ebb1 0109 	subs.w	r1, r1, r9
   2ab70:	9101      	str	r1, [sp, #4]
   2ab72:	d105      	bne.n	2ab80 <ticker_job_list_insert+0x1b0>
   2ab74:	f8bc 101e 	ldrh.w	r1, [ip, #30]
   2ab78:	f8be e01e 	ldrh.w	lr, [lr, #30]
   2ab7c:	4571      	cmp	r1, lr
   2ab7e:	d803      	bhi.n	2ab88 <ticker_job_list_insert+0x1b8>
		current = ticker_current->next;
   2ab80:	4613      	mov	r3, r2
   2ab82:	9a07      	ldr	r2, [sp, #28]
   2ab84:	5c82      	ldrb	r2, [r0, r2]
   2ab86:	e75c      	b.n	2aa42 <ticker_job_list_insert+0x72>
   2ab88:	f8cd 9004 	str.w	r9, [sp, #4]
   2ab8c:	e768      	b.n	2aa60 <ticker_job_list_insert+0x90>

0002ab8e <ticker_worker>:
{
   2ab8e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   2ab92:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
   2ab94:	2301      	movs	r3, #1
{
   2ab96:	b08d      	sub	sp, #52	; 0x34
   2ab98:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   2ab9a:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   2ab9c:	b91e      	cbnz	r6, 2aba6 <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   2ab9e:	7f43      	ldrb	r3, [r0, #29]
   2aba0:	2bff      	cmp	r3, #255	; 0xff
   2aba2:	d103      	bne.n	2abac <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   2aba4:	77c6      	strb	r6, [r0, #31]
}
   2aba6:	b00d      	add	sp, #52	; 0x34
   2aba8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   2abac:	f7f5 f914 	bl	1fdd8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2abb0:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   2abb2:	7f6f      	ldrb	r7, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2abb4:	1ac0      	subs	r0, r0, r3
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   2abb6:	7f2b      	ldrb	r3, [r5, #28]
   2abb8:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2abba:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   2abbe:	d004      	beq.n	2abca <ticker_worker+0x3c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   2abc0:	69ae      	ldr	r6, [r5, #24]
	uint8_t slot_reserved = 0;
   2abc2:	455e      	cmp	r6, fp
   2abc4:	bf94      	ite	ls
   2abc6:	2600      	movls	r6, #0
   2abc8:	2601      	movhi	r6, #1
	node = &instance->nodes[0];
   2abca:	f8d5 9000 	ldr.w	r9, [r5]
	ticks_expired = 0U;
   2abce:	f04f 0800 	mov.w	r8, #0
	while (ticker_id_head != TICKER_NULL) {
   2abd2:	2fff      	cmp	r7, #255	; 0xff
   2abd4:	d11a      	bne.n	2ac0c <ticker_worker+0x7e>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   2abd6:	7aea      	ldrb	r2, [r5, #11]
   2abd8:	7aab      	ldrb	r3, [r5, #10]
   2abda:	4293      	cmp	r3, r2
   2abdc:	d105      	bne.n	2abea <ticker_worker+0x5c>
	uint8_t idx = *ticks_elapsed_index + 1;
   2abde:	3301      	adds	r3, #1
   2abe0:	b2db      	uxtb	r3, r3
		idx = 0U;
   2abe2:	2b02      	cmp	r3, #2
   2abe4:	bf08      	it	eq
   2abe6:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   2abe8:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2abea:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2abec:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2abee:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2abf2:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2abf4:	f8c3 800c 	str.w	r8, [r3, #12]
	instance->worker_trigger = 0U;
   2abf8:	2300      	movs	r3, #0
   2abfa:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2abfc:	2104      	movs	r1, #4
   2abfe:	462b      	mov	r3, r5
   2ac00:	2003      	movs	r0, #3
   2ac02:	46a4      	mov	ip, r4
}
   2ac04:	b00d      	add	sp, #52	; 0x34
   2ac06:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2ac0a:	4760      	bx	ip
		ticker = &node[ticker_id_head];
   2ac0c:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   2ac10:	eb09 1407 	add.w	r4, r9, r7, lsl #4
   2ac14:	013a      	lsls	r2, r7, #4
		ticks_to_expire = ticker->ticks_to_expire;
   2ac16:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   2ac18:	459b      	cmp	fp, r3
   2ac1a:	d3dc      	bcc.n	2abd6 <ticker_worker+0x48>
		ticks_elapsed -= ticks_to_expire;
   2ac1c:	ebab 0b03 	sub.w	fp, fp, r3
		ticks_expired += ticks_to_expire;
   2ac20:	4498      	add	r8, r3
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   2ac22:	78a3      	ldrb	r3, [r4, #2]
   2ac24:	9303      	str	r3, [sp, #12]
		ticker_id_head = ticker->next;
   2ac26:	f819 7002 	ldrb.w	r7, [r9, r2]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   2ac2a:	7863      	ldrb	r3, [r4, #1]
   2ac2c:	9a03      	ldr	r2, [sp, #12]
   2ac2e:	1a9b      	subs	r3, r3, r2
   2ac30:	b2db      	uxtb	r3, r3
   2ac32:	2b01      	cmp	r3, #1
   2ac34:	d1cd      	bne.n	2abd2 <ticker_worker+0x44>
		if (ticker->ticks_slot != 0U &&
   2ac36:	69a3      	ldr	r3, [r4, #24]
   2ac38:	9304      	str	r3, [sp, #16]
   2ac3a:	2b00      	cmp	r3, #0
   2ac3c:	d034      	beq.n	2aca8 <ticker_worker+0x11a>
   2ac3e:	2e00      	cmp	r6, #0
   2ac40:	f040 80a8 	bne.w	2ad94 <ticker_worker+0x206>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   2ac44:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
   2ac48:	9305      	str	r3, [sp, #20]
   2ac4a:	3380      	adds	r3, #128	; 0x80
   2ac4c:	d02c      	beq.n	2aca8 <ticker_worker+0x11a>
   2ac4e:	2fff      	cmp	r7, #255	; 0xff
   2ac50:	d02a      	beq.n	2aca8 <ticker_worker+0x11a>
		int32_t lazy_current = ticker->lazy_current;
   2ac52:	8be3      	ldrh	r3, [r4, #30]
		if (lazy_current >= ticker->lazy_periodic) {
   2ac54:	8ba2      	ldrh	r2, [r4, #28]
		uint32_t current_age = ticker->ticks_periodic +
   2ac56:	6861      	ldr	r1, [r4, #4]
		if (lazy_current >= ticker->lazy_periodic) {
   2ac58:	4293      	cmp	r3, r2
			lazy_current -= ticker->lazy_periodic;
   2ac5a:	bf28      	it	cs
   2ac5c:	1a9b      	subcs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
   2ac5e:	fb03 1201 	mla	r2, r3, r1, r1
   2ac62:	9209      	str	r2, [sp, #36]	; 0x24
		uint32_t acc_ticks_to_expire = 0U;
   2ac64:	2200      	movs	r2, #0
   2ac66:	9206      	str	r2, [sp, #24]
				(lazy_current - ticker->priority);
   2ac68:	9a05      	ldr	r2, [sp, #20]
   2ac6a:	1a9b      	subs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
   2ac6c:	46ba      	mov	sl, r7
				(lazy_current - ticker->priority);
   2ac6e:	930b      	str	r3, [sp, #44]	; 0x2c
			struct ticker_node *ticker_next = &nodes[id_head];
   2ac70:	fa0f fa8a 	sxth.w	sl, sl
   2ac74:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
   2ac78:	ea4f 130a 	mov.w	r3, sl, lsl #4
   2ac7c:	eb09 1a0a 	add.w	sl, r9, sl, lsl #4
   2ac80:	9308      	str	r3, [sp, #32]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2ac82:	f8da c008 	ldr.w	ip, [sl, #8]
   2ac86:	9b06      	ldr	r3, [sp, #24]
   2ac88:	4463      	add	r3, ip
   2ac8a:	9306      	str	r3, [sp, #24]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   2ac8c:	9a06      	ldr	r2, [sp, #24]
   2ac8e:	9b04      	ldr	r3, [sp, #16]
   2ac90:	4293      	cmp	r3, r2
   2ac92:	d309      	bcc.n	2aca8 <ticker_worker+0x11a>
			if (ticker_next->ticks_slot == 0U) {
   2ac94:	f8da 3018 	ldr.w	r3, [sl, #24]
   2ac98:	2b00      	cmp	r3, #0
   2ac9a:	d13a      	bne.n	2ad12 <ticker_worker+0x184>
			id_head = ticker_next->next;
   2ac9c:	9b08      	ldr	r3, [sp, #32]
   2ac9e:	f819 a003 	ldrb.w	sl, [r9, r3]
		while (id_head != TICKER_NULL) {
   2aca2:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   2aca6:	d1e3      	bne.n	2ac70 <ticker_worker+0xe2>
		must_expire_skip = 0U;
   2aca8:	f04f 0a00 	mov.w	sl, #0
		if (ticker->ext_data) {
   2acac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2acae:	2b00      	cmp	r3, #0
   2acb0:	f000 809a 	beq.w	2ade8 <ticker_worker+0x25a>
			ticker->ext_data->ticks_drift = 0U;
   2acb4:	2200      	movs	r2, #0
			ticks_drift = ticker->ext_data->ticks_drift;
   2acb6:	6859      	ldr	r1, [r3, #4]
			ticker->ext_data->reschedule_state =
   2acb8:	721a      	strb	r2, [r3, #8]
			ticker->ext_data->ticks_drift = 0U;
   2acba:	605a      	str	r2, [r3, #4]
		ticker->ack--;
   2acbc:	9b03      	ldr	r3, [sp, #12]
   2acbe:	3b01      	subs	r3, #1
   2acc0:	70a3      	strb	r3, [r4, #2]
		if (ticker->timeout_func) {
   2acc2:	68e3      	ldr	r3, [r4, #12]
   2acc4:	469e      	mov	lr, r3
   2acc6:	2b00      	cmp	r3, #0
   2acc8:	d083      	beq.n	2abd2 <ticker_worker+0x44>
					   ticks_expired -
   2acca:	6960      	ldr	r0, [r4, #20]
   2accc:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   2acce:	6a62      	ldr	r2, [r4, #36]	; 0x24
					   ticks_expired -
   2acd0:	eba8 0000 	sub.w	r0, r8, r0
   2acd4:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   2acd6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   2acda:	f1ba 0f00 	cmp.w	sl, #0
   2acde:	f040 8085 	bne.w	2adec <ticker_worker+0x25e>
   2ace2:	8be3      	ldrh	r3, [r4, #30]
   2ace4:	f8d4 c010 	ldr.w	ip, [r4, #16]
   2ace8:	f8cd c004 	str.w	ip, [sp, #4]
   2acec:	f894 c003 	ldrb.w	ip, [r4, #3]
   2acf0:	f8cd c000 	str.w	ip, [sp]
   2acf4:	46f4      	mov	ip, lr
   2acf6:	47e0      	blx	ip
			if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   2acf8:	f1ba 0f00 	cmp.w	sl, #0
   2acfc:	f47f af69 	bne.w	2abd2 <ticker_worker+0x44>
				if (ticker->ticks_slot != 0U) {
   2ad00:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   2ad02:	f8a4 a01e 	strh.w	sl, [r4, #30]
					slot_reserved = 1U;
   2ad06:	2b00      	cmp	r3, #0
				ticker->force = 0U;
   2ad08:	f884 a003 	strb.w	sl, [r4, #3]
					slot_reserved = 1U;
   2ad0c:	bf18      	it	ne
   2ad0e:	2601      	movne	r6, #1
   2ad10:	e75f      	b.n	2abd2 <ticker_worker+0x44>
			int32_t lazy_next = ticker_next->lazy_current;
   2ad12:	f8ba 201e 	ldrh.w	r2, [sl, #30]
				ticker_next->lazy_periodic > lazy_next;
   2ad16:	f8ba 001c 	ldrh.w	r0, [sl, #28]
				ticker_next->priority;
   2ad1a:	f99a e02d 	ldrsb.w	lr, [sl, #45]	; 0x2d
   2ad1e:	f8cd e01c 	str.w	lr, [sp, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   2ad22:	f8da e004 	ldr.w	lr, [sl, #4]
			if (!lazy_next_periodic_skip) {
   2ad26:	4282      	cmp	r2, r0
			int32_t lazy_next = ticker_next->lazy_current;
   2ad28:	4613      	mov	r3, r2
				lazy_next -= ticker_next->lazy_periodic;
   2ad2a:	bf28      	it	cs
   2ad2c:	1a13      	subcs	r3, r2, r0
					  0U :
   2ad2e:	f1be 0f00 	cmp.w	lr, #0
   2ad32:	d04d      	beq.n	2add0 <ticker_worker+0x242>
   2ad34:	ebae 0c0c 	sub.w	ip, lr, ip
				(ticker->ticks_periodic == 0U) ||
   2ad38:	2900      	cmp	r1, #0
   2ad3a:	d04b      	beq.n	2add4 <ticker_worker+0x246>
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   2ad3c:	fb0e cc03 	mla	ip, lr, r3, ip
				(ticker->ticks_periodic == 0U) ||
   2ad40:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
   2ad44:	45e6      	cmp	lr, ip
   2ad46:	bf8c      	ite	hi
   2ad48:	f04f 0e01 	movhi.w	lr, #1
   2ad4c:	f04f 0e00 	movls.w	lr, #0
					(ticker->ticks_periodic != 0U) &&
   2ad50:	bf34      	ite	cc
   2ad52:	f04f 0c01 	movcc.w	ip, #1
   2ad56:	f04f 0c00 	movcs.w	ip, #0
			uint8_t next_force = (ticker_next->force > ticker->force);
   2ad5a:	f89a a003 	ldrb.w	sl, [sl, #3]
   2ad5e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
			if (!lazy_next_periodic_skip &&
   2ad62:	4282      	cmp	r2, r0
			uint8_t next_force = (ticker_next->force > ticker->force);
   2ad64:	f894 a003 	ldrb.w	sl, [r4, #3]
			if (!lazy_next_periodic_skip &&
   2ad68:	d398      	bcc.n	2ac9c <ticker_worker+0x10e>
   2ad6a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2ad6c:	4552      	cmp	r2, sl
   2ad6e:	d811      	bhi.n	2ad94 <ticker_worker+0x206>
			    (next_force ||
   2ad70:	9a07      	ldr	r2, [sp, #28]
   2ad72:	f112 0f80 	cmn.w	r2, #128	; 0x80
   2ad76:	d00d      	beq.n	2ad94 <ticker_worker+0x206>
				(lazy_next - ticker_next->priority) >
   2ad78:	1a9b      	subs	r3, r3, r2
			     next_is_critical ||
   2ad7a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2ad7c:	4293      	cmp	r3, r2
   2ad7e:	dd02      	ble.n	2ad86 <ticker_worker+0x1f8>
			     (next_has_priority && !current_is_older) ||
   2ad80:	f1be 0f00 	cmp.w	lr, #0
   2ad84:	d006      	beq.n	2ad94 <ticker_worker+0x206>
   2ad86:	9b05      	ldr	r3, [sp, #20]
   2ad88:	9a07      	ldr	r2, [sp, #28]
   2ad8a:	4293      	cmp	r3, r2
   2ad8c:	d186      	bne.n	2ac9c <ticker_worker+0x10e>
			     (equal_priority && next_is_older))) {
   2ad8e:	f1bc 0f00 	cmp.w	ip, #0
   2ad92:	d083      	beq.n	2ac9c <ticker_worker+0x10e>
			struct ticker_ext *ext_data = ticker->ext_data;
   2ad94:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		int32_t lazy_current = ticker->lazy_current;
   2ad96:	8be2      	ldrh	r2, [r4, #30]
			if (ext_data &&
   2ad98:	b14b      	cbz	r3, 2adae <ticker_worker+0x220>
   2ad9a:	6819      	ldr	r1, [r3, #0]
   2ad9c:	b1f1      	cbz	r1, 2addc <ticker_worker+0x24e>
			    ext_data->ticks_slot_window != 0U &&
   2ad9e:	7a19      	ldrb	r1, [r3, #8]
   2ada0:	b9e1      	cbnz	r1, 2addc <ticker_worker+0x24e>
			    TICKER_RESCHEDULE_STATE_NONE &&
   2ada2:	8ba1      	ldrh	r1, [r4, #28]
   2ada4:	4291      	cmp	r1, r2
   2ada6:	d819      	bhi.n	2addc <ticker_worker+0x24e>
				ext_data->reschedule_state =
   2ada8:	f04f 0101 	mov.w	r1, #1
				ext_data->reschedule_state =
   2adac:	7219      	strb	r1, [r3, #8]
			ticker->lazy_current++;
   2adae:	3201      	adds	r2, #1
			if ((ticker->must_expire == 0U) ||
   2adb0:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
			ticker->lazy_current++;
   2adb4:	b292      	uxth	r2, r2
   2adb6:	83e2      	strh	r2, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   2adb8:	b131      	cbz	r1, 2adc8 <ticker_worker+0x23a>
   2adba:	8ba1      	ldrh	r1, [r4, #28]
   2adbc:	4291      	cmp	r1, r2
   2adbe:	d203      	bcs.n	2adc8 <ticker_worker+0x23a>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
   2adc0:	b17b      	cbz	r3, 2ade2 <ticker_worker+0x254>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
   2adc2:	7a1b      	ldrb	r3, [r3, #8]
   2adc4:	2b01      	cmp	r3, #1
   2adc6:	d10c      	bne.n	2ade2 <ticker_worker+0x254>
				ticker->ack--;
   2adc8:	9b03      	ldr	r3, [sp, #12]
   2adca:	3b01      	subs	r3, #1
   2adcc:	70a3      	strb	r3, [r4, #2]
				continue;
   2adce:	e700      	b.n	2abd2 <ticker_worker+0x44>
					  0U :
   2add0:	46f4      	mov	ip, lr
   2add2:	e7b1      	b.n	2ad38 <ticker_worker+0x1aa>
				(ticker->ticks_periodic == 0U) ||
   2add4:	f04f 0e01 	mov.w	lr, #1
					(ticker->ticks_periodic != 0U) &&
   2add8:	468c      	mov	ip, r1
   2adda:	e7be      	b.n	2ad5a <ticker_worker+0x1cc>
				ext_data->reschedule_state =
   2addc:	f04f 0100 	mov.w	r1, #0
   2ade0:	e7e4      	b.n	2adac <ticker_worker+0x21e>
			must_expire_skip = 1U;
   2ade2:	f04f 0a01 	mov.w	sl, #1
   2ade6:	e761      	b.n	2acac <ticker_worker+0x11e>
			ticks_drift = 0U;
   2ade8:	4619      	mov	r1, r3
   2adea:	e767      	b.n	2acbc <ticker_worker+0x12e>
			ticker->timeout_func(ticks_at_expire,
   2adec:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2adf0:	e778      	b.n	2ace4 <ticker_worker+0x156>

0002adf2 <ticker_start>:
{
   2adf2:	b510      	push	{r4, lr}
   2adf4:	b08a      	sub	sp, #40	; 0x28
	return ticker_start_ext(instance_index, user_id, ticker_id,
   2adf6:	2400      	movs	r4, #0
   2adf8:	9409      	str	r4, [sp, #36]	; 0x24
   2adfa:	9c14      	ldr	r4, [sp, #80]	; 0x50
   2adfc:	9408      	str	r4, [sp, #32]
   2adfe:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   2ae00:	9407      	str	r4, [sp, #28]
   2ae02:	9c12      	ldr	r4, [sp, #72]	; 0x48
   2ae04:	9406      	str	r4, [sp, #24]
   2ae06:	9c11      	ldr	r4, [sp, #68]	; 0x44
   2ae08:	9405      	str	r4, [sp, #20]
   2ae0a:	9c10      	ldr	r4, [sp, #64]	; 0x40
   2ae0c:	9404      	str	r4, [sp, #16]
   2ae0e:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
   2ae12:	9403      	str	r4, [sp, #12]
   2ae14:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   2ae16:	9402      	str	r4, [sp, #8]
   2ae18:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   2ae1a:	9401      	str	r4, [sp, #4]
   2ae1c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   2ae1e:	9400      	str	r4, [sp, #0]
   2ae20:	f7ef f846 	bl	19eb0 <ticker_start_ext>
}
   2ae24:	b00a      	add	sp, #40	; 0x28
   2ae26:	bd10      	pop	{r4, pc}

0002ae28 <ticker_update>:
{
   2ae28:	b510      	push	{r4, lr}
   2ae2a:	b088      	sub	sp, #32
	return ticker_update_ext(instance_index, user_id, ticker_id,
   2ae2c:	2400      	movs	r4, #0
   2ae2e:	9407      	str	r4, [sp, #28]
   2ae30:	9c10      	ldr	r4, [sp, #64]	; 0x40
   2ae32:	9406      	str	r4, [sp, #24]
   2ae34:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   2ae36:	9405      	str	r4, [sp, #20]
   2ae38:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
   2ae3c:	9404      	str	r4, [sp, #16]
   2ae3e:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   2ae42:	9403      	str	r4, [sp, #12]
   2ae44:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   2ae46:	9402      	str	r4, [sp, #8]
   2ae48:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   2ae4a:	9401      	str	r4, [sp, #4]
   2ae4c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   2ae4e:	9400      	str	r4, [sp, #0]
   2ae50:	f7ef f87c 	bl	19f4c <ticker_update_ext>
}
   2ae54:	b008      	add	sp, #32
   2ae56:	bd10      	pop	{r4, pc}

0002ae58 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   2ae58:	f7f4 bfbe 	b.w	1fdd8 <cntr_cnt_get>

0002ae5c <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2ae5c:	1a40      	subs	r0, r0, r1
}
   2ae5e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   2ae62:	4770      	bx	lr

0002ae64 <ll_addr_read>:

uint8_t *ll_addr_read(uint8_t addr_type, uint8_t *const bdaddr)
{
   2ae64:	b538      	push	{r3, r4, r5, lr}
	uint8_t *addr;

	addr = ll_addr_get(addr_type);
   2ae66:	f7ef f917 	bl	1a098 <ll_addr_get>
{
   2ae6a:	460d      	mov	r5, r1
	if (addr) {
   2ae6c:	4604      	mov	r4, r0
   2ae6e:	b120      	cbz	r0, 2ae7a <ll_addr_read+0x16>
		memcpy(bdaddr, addr, BDADDR_SIZE);
   2ae70:	4601      	mov	r1, r0
   2ae72:	2206      	movs	r2, #6
   2ae74:	4628      	mov	r0, r5
   2ae76:	f7fc fcfb 	bl	27870 <memcpy>
	}

	return addr;
}
   2ae7a:	4620      	mov	r0, r4
   2ae7c:	bd38      	pop	{r3, r4, r5, pc}

0002ae7e <ll_tx_pwr_lvl_get>:

#include "ll.h"

uint8_t ll_tx_pwr_lvl_get(uint8_t handle_type,
		       uint16_t handle, uint8_t type, int8_t *tx_pwr_lvl)
{
   2ae7e:	b538      	push	{r3, r4, r5, lr}
   2ae80:	4604      	mov	r4, r0
	switch (handle_type) {
   2ae82:	2c02      	cmp	r4, #2
{
   2ae84:	4608      	mov	r0, r1
   2ae86:	461d      	mov	r5, r3
	switch (handle_type) {
   2ae88:	d106      	bne.n	2ae98 <ll_tx_pwr_lvl_get+0x1a>
#endif /* CONFIG_BT_OBSERVER && CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL*/
#if defined(CONFIG_BT_CONN)
		case (BT_HCI_VS_LL_HANDLE_TYPE_CONN): {
			struct ll_conn *conn;

			conn = ll_connected_get(handle);
   2ae8a:	f000 fa60 	bl	2b34e <ll_connected_get>
			if (!conn) {
   2ae8e:	b108      	cbz	r0, 2ae94 <ll_tx_pwr_lvl_get+0x16>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
				/* Level desired is maximum available */
				*tx_pwr_lvl = lll_radio_tx_pwr_max_get();
#else  /* !CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
				/* Return default if not multiple TXP */
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   2ae90:	2400      	movs	r4, #0
   2ae92:	702c      	strb	r4, [r5, #0]
			return BT_HCI_ERR_UNKNOWN_CMD;
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
   2ae94:	4620      	mov	r0, r4
   2ae96:	bd38      	pop	{r3, r4, r5, pc}
			return BT_HCI_ERR_UNKNOWN_CMD;
   2ae98:	2401      	movs	r4, #1
   2ae9a:	e7fb      	b.n	2ae94 <ll_tx_pwr_lvl_get+0x16>

0002ae9c <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   2ae9c:	2300      	movs	r3, #0
   2ae9e:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   2aea0:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   2aea2:	4770      	bx	lr

0002aea4 <meta_evt>:
{
   2aea4:	b570      	push	{r4, r5, r6, lr}
	return net_buf_simple_add(&buf->b, len);
   2aea6:	f100 0408 	add.w	r4, r0, #8
   2aeaa:	460e      	mov	r6, r1
   2aeac:	4620      	mov	r0, r4
   2aeae:	2102      	movs	r1, #2
   2aeb0:	4615      	mov	r5, r2
   2aeb2:	f000 ff43 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = evt;
   2aeb6:	233e      	movs	r3, #62	; 0x3e
   2aeb8:	7003      	strb	r3, [r0, #0]
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   2aeba:	1c6b      	adds	r3, r5, #1
	hdr->len = len;
   2aebc:	7043      	strb	r3, [r0, #1]
   2aebe:	2101      	movs	r1, #1
   2aec0:	4620      	mov	r0, r4
   2aec2:	f000 ff3b 	bl	2bd3c <net_buf_simple_add>
	me->subevent = subevt;
   2aec6:	7006      	strb	r6, [r0, #0]
   2aec8:	4629      	mov	r1, r5
   2aeca:	4620      	mov	r0, r4
}
   2aecc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2aed0:	f000 bf34 	b.w	2bd3c <net_buf_simple_add>

0002aed4 <sys_get_le64>:
{
   2aed4:	4603      	mov	r3, r0
}
   2aed6:	6800      	ldr	r0, [r0, #0]
   2aed8:	6859      	ldr	r1, [r3, #4]
   2aeda:	4770      	bx	lr

0002aedc <hci_num_cmplt_encode>:
{
   2aedc:	b570      	push	{r4, r5, r6, lr}
   2aede:	f100 0408 	add.w	r4, r0, #8
   2aee2:	460e      	mov	r6, r1
   2aee4:	4620      	mov	r0, r4
   2aee6:	2102      	movs	r1, #2
   2aee8:	4615      	mov	r5, r2
   2aeea:	f000 ff27 	bl	2bd3c <net_buf_simple_add>
	hdr->evt = evt;
   2aeee:	2313      	movs	r3, #19
	hdr->len = len;
   2aef0:	2105      	movs	r1, #5
	hdr->evt = evt;
   2aef2:	7003      	strb	r3, [r0, #0]
	hdr->len = len;
   2aef4:	7041      	strb	r1, [r0, #1]
   2aef6:	4620      	mov	r0, r4
   2aef8:	f000 ff20 	bl	2bd3c <net_buf_simple_add>
	ep->num_handles = num_handles;
   2aefc:	2301      	movs	r3, #1
   2aefe:	7003      	strb	r3, [r0, #0]
	hc->handle = sys_cpu_to_le16(handle);
   2af00:	f8a0 6001 	strh.w	r6, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   2af04:	f8a0 5003 	strh.w	r5, [r0, #3]
}
   2af08:	bd70      	pop	{r4, r5, r6, pc}

0002af0a <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_csrand_get(buf, len);
   2af0a:	f7f3 ba59 	b.w	1e3c0 <lll_csrand_get>

0002af0e <bt_encrypt_be>:
	return 0;
}

int bt_encrypt_be(const uint8_t key[16], const uint8_t plaintext[16],
		  uint8_t enc_data[16])
{
   2af0e:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt_be(key, plaintext, enc_data);
   2af10:	f000 fd6d 	bl	2b9ee <ecb_encrypt_be>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   2af14:	2000      	movs	r0, #0
   2af16:	bd08      	pop	{r3, pc}

0002af18 <ll_feat_get>:

#else /* !CONFIG_BT_CTLR_SET_HOST_FEATURE */
uint64_t ll_feat_get(void)
{
	return LL_FEAT;
}
   2af18:	208e      	movs	r0, #142	; 0x8e
   2af1a:	2100      	movs	r1, #0
   2af1c:	4770      	bx	lr

0002af1e <disabled_cb>:
	z_impl_k_sem_give(sem);
   2af1e:	f7f9 b819 	b.w	23f54 <z_impl_k_sem_give>

0002af22 <rx_demux_conn_tx_ack>:
{
   2af22:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2af24:	4605      	mov	r5, r0
   2af26:	4614      	mov	r4, r2
   2af28:	9300      	str	r3, [sp, #0]
   2af2a:	f8ad 1006 	strh.w	r1, [sp, #6]
		ull_conn_ack_dequeue();
   2af2e:	f7f2 fdfb 	bl	1db28 <ull_conn_ack_dequeue>
		ull_conn_tx_ack(handle, link, node_tx);
   2af32:	4621      	mov	r1, r4
   2af34:	9a00      	ldr	r2, [sp, #0]
   2af36:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   2af3a:	f7f2 fe39 	bl	1dbb0 <ull_conn_tx_ack>
		ull_conn_link_tx_release(link);
   2af3e:	4620      	mov	r0, r4
   2af40:	f7f2 fdbc 	bl	1dabc <ull_conn_link_tx_release>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   2af44:	466a      	mov	r2, sp
   2af46:	f10d 0106 	add.w	r1, sp, #6
   2af4a:	4628      	mov	r0, r5
   2af4c:	f7f2 fdd8 	bl	1db00 <ull_conn_ack_by_last_peek>
	} while (link);
   2af50:	4604      	mov	r4, r0
   2af52:	2800      	cmp	r0, #0
   2af54:	d1eb      	bne.n	2af2e <rx_demux_conn_tx_ack+0xc>
			ll_rx_sched();
   2af56:	f7f0 fb4b 	bl	1b5f0 <ll_rx_sched>
}
   2af5a:	b003      	add	sp, #12
   2af5c:	bd30      	pop	{r4, r5, pc}

0002af5e <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   2af5e:	2300      	movs	r3, #0
   2af60:	7003      	strb	r3, [r0, #0]
	*ticker_id = (TICKER_NODES - FLASH_TICKER_NODES);
   2af62:	2306      	movs	r3, #6
   2af64:	700b      	strb	r3, [r1, #0]
}
   2af66:	4770      	bx	lr

0002af68 <ull_rxfifo_alloc>:
 * @details This function allocates up to 'max' number of MFIFO elements by
 *          enqueuing pointers to memory elements with associated memq links.
 */
void ull_rxfifo_alloc(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
		      void *mem_free, void *link_free, uint8_t max)
{
   2af68:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2af6c:	e9dd a60d 	ldrd	sl, r6, [sp, #52]	; 0x34
   2af70:	469b      	mov	fp, r3
   2af72:	f89d 703c 	ldrb.w	r7, [sp, #60]	; 0x3c
   2af76:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2af78:	9100      	str	r1, [sp, #0]
   2af7a:	4681      	mov	r9, r0
   2af7c:	4690      	mov	r8, r2
   2af7e:	9301      	str	r3, [sp, #4]
	uint8_t idx;

	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   2af80:	b177      	cbz	r7, 2afa0 <ull_rxfifo_alloc+0x38>
	last = last + 1;
   2af82:	f89b 4000 	ldrb.w	r4, [fp]
		last = 0U;
   2af86:	9b00      	ldr	r3, [sp, #0]
	last = last + 1;
   2af88:	3401      	adds	r4, #1
   2af8a:	b2e4      	uxtb	r4, r4
		last = 0U;
   2af8c:	42a3      	cmp	r3, r4
   2af8e:	bf08      	it	eq
   2af90:	2400      	moveq	r4, #0
	if (last == first) {
   2af92:	45a0      	cmp	r8, r4
   2af94:	d004      	beq.n	2afa0 <ull_rxfifo_alloc+0x38>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(link_free);
   2af96:	4630      	mov	r0, r6
   2af98:	f7ff fc3a 	bl	2a810 <mem_acquire>
		if (!link) {
   2af9c:	4605      	mov	r5, r0
   2af9e:	b910      	cbnz	r0, 2afa6 <ull_rxfifo_alloc+0x3e>
		link->mem = NULL;
		rx->link = link;

		mfifo_by_idx_enqueue(m, s, idx, rx, l);
	}
}
   2afa0:	b003      	add	sp, #12
   2afa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rx = mem_acquire(mem_free);
   2afa6:	4650      	mov	r0, sl
   2afa8:	f7ff fc32 	bl	2a810 <mem_acquire>
		if (!rx) {
   2afac:	b930      	cbnz	r0, 2afbc <ull_rxfifo_alloc+0x54>
			mem_release(link, link_free);
   2afae:	4631      	mov	r1, r6
   2afb0:	4628      	mov	r0, r5
}
   2afb2:	b003      	add	sp, #12
   2afb4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			mem_release(link, link_free);
   2afb8:	f7ff bc43 	b.w	2a842 <mem_release>
		link->mem = NULL;
   2afbc:	2300      	movs	r3, #0
   2afbe:	606b      	str	r3, [r5, #4]
		rx->link = link;
   2afc0:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   2afc2:	f89b 5000 	ldrb.w	r5, [fp]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   2afc6:	9b01      	ldr	r3, [sp, #4]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   2afc8:	fb15 f509 	smulbb	r5, r5, r9
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   2afcc:	1e7a      	subs	r2, r7, #1
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   2afce:	5158      	str	r0, [r3, r5]
   2afd0:	b2d7      	uxtb	r7, r2
	*last = idx; /* Commit: Update write index */
   2afd2:	f88b 4000 	strb.w	r4, [fp]
}
   2afd6:	e7d3      	b.n	2af80 <ull_rxfifo_alloc+0x18>

0002afd8 <ull_rxfifo_release>:
 * @brief   Support function for RXFIFO_RELEASE macro
 * @details This function releases a node by returning it to the FIFO.
 */
void *ull_rxfifo_release(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
			 memq_link_t *link, struct node_rx_hdr *rx)
{
   2afd8:	b530      	push	{r4, r5, lr}
	last = last + 1;
   2afda:	781c      	ldrb	r4, [r3, #0]
   2afdc:	3401      	adds	r4, #1
   2afde:	b2e4      	uxtb	r4, r4
		last = 0U;
   2afe0:	42a1      	cmp	r1, r4
   2afe2:	bf08      	it	eq
   2afe4:	2400      	moveq	r4, #0
	if (last == first) {
   2afe6:	42a2      	cmp	r2, r4
   2afe8:	4605      	mov	r5, r0
   2afea:	9805      	ldr	r0, [sp, #20]
   2afec:	d008      	beq.n	2b000 <ull_rxfifo_release+0x28>

	if (!mfifo_enqueue_idx_get(n, f, *l, &idx)) {
		return NULL;
	}

	rx->link = link;
   2afee:	9a04      	ldr	r2, [sp, #16]
   2aff0:	6002      	str	r2, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   2aff2:	781a      	ldrb	r2, [r3, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   2aff4:	9903      	ldr	r1, [sp, #12]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   2aff6:	fb12 f205 	smulbb	r2, r2, r5
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   2affa:	5088      	str	r0, [r1, r2]
	*last = idx; /* Commit: Update write index */
   2affc:	701c      	strb	r4, [r3, #0]

	mfifo_by_idx_enqueue(m, s, idx, rx, l);

	return rx;
}
   2affe:	bd30      	pop	{r4, r5, pc}
		return NULL;
   2b000:	2000      	movs	r0, #0
   2b002:	e7fc      	b.n	2affe <ull_rxfifo_release+0x26>

0002b004 <lll_prepare>:
{
   2b004:	b507      	push	{r0, r1, r2, lr}
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
   2b006:	2300      	movs	r3, #0
   2b008:	e9cd 3300 	strd	r3, r3, [sp]
   2b00c:	9b04      	ldr	r3, [sp, #16]
   2b00e:	f7f3 fb15 	bl	1e63c <lll_prepare_resolve>
}
   2b012:	b003      	add	sp, #12
   2b014:	f85d fb04 	ldr.w	pc, [sp], #4

0002b018 <adv_time_get.constprop.0.isra.0>:
static uint16_t adv_time_get(struct pdu_adv *pdu, struct pdu_adv *pdu_scan,
   2b018:	b530      	push	{r4, r5, lr}
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   2b01a:	7804      	ldrb	r4, [r0, #0]
   2b01c:	f004 040f 	and.w	r4, r4, #15
				   rxtx_turn_us * (adv_chn_cnt - 1);
   2b020:	1e53      	subs	r3, r2, #1
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   2b022:	2c02      	cmp	r4, #2
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
   2b024:	b29d      	uxth	r5, r3
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   2b026:	d10d      	bne.n	2b044 <adv_time_get.constprop.0.isra.0+0x2c>
			adv_size += pdu->len;
   2b028:	7841      	ldrb	r1, [r0, #1]
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
   2b02a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
   2b02e:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   2b032:	3110      	adds	r1, #16
   2b034:	0058      	lsls	r0, r3, #1
   2b036:	00c9      	lsls	r1, r1, #3
   2b038:	f500 70c8 	add.w	r0, r0, #400	; 0x190
   2b03c:	fb01 0002 	mla	r0, r1, r2, r0
			time_us += (BYTES2US(adv_size, PHY_1M) +
   2b040:	b280      	uxth	r0, r0
}
   2b042:	bd30      	pop	{r4, r5, pc}
			if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   2b044:	2c01      	cmp	r4, #1
   2b046:	d016      	beq.n	2b076 <adv_time_get.constprop.0.isra.0+0x5e>
			BYTES2US((PDU_OVERHEAD_SIZE(PHY_1M) +
   2b048:	3110      	adds	r1, #16
		const uint16_t scan_rsp_us =
   2b04a:	00c9      	lsls	r1, r1, #3
			} else if (pdu->type == PDU_ADV_TYPE_ADV_IND) {
   2b04c:	b96c      	cbnz	r4, 2b06a <adv_time_get.constprop.0.isra.0+0x52>
				adv_size += pdu->len;
   2b04e:	7840      	ldrb	r0, [r0, #1]
				time_us += scan_req_us + EVENT_IFS_MAX_US +
   2b050:	f501 7136 	add.w	r1, r1, #728	; 0x2d8
				adv_size += pdu->len;
   2b054:	3010      	adds	r0, #16
				   BYTES2US(adv_size, PHY_1M) + EVENT_IFS_MAX_US;
   2b056:	00c3      	lsls	r3, r0, #3
				    EVENT_IFS_MAX_US + rx_to_us +
   2b058:	f503 73b3 	add.w	r3, r3, #358	; 0x166
   2b05c:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
   2b060:	3098      	adds	r0, #152	; 0x98
				    rxtx_turn_us) * (adv_chn_cnt - 1) +
   2b062:	fb13 f305 	smulbb	r3, r3, r5
			time_us += (BYTES2US(adv_size, PHY_1M) +
   2b066:	4418      	add	r0, r3
   2b068:	e7ea      	b.n	2b040 <adv_time_get.constprop.0.isra.0+0x28>
			} else if (pdu->type == PDU_ADV_TYPE_SCAN_IND) {
   2b06a:	2c06      	cmp	r4, #6
   2b06c:	d0ef      	beq.n	2b04e <adv_time_get.constprop.0.isra.0+0x36>
		uint16_t adv_size =
   2b06e:	2010      	movs	r0, #16
	uint16_t time_us = EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
   2b070:	f44f 71c8 	mov.w	r1, #400	; 0x190
   2b074:	e7ef      	b.n	2b056 <adv_time_get.constprop.0.isra.0+0x3e>
				adv_size += TARGETA_SIZE;
   2b076:	2016      	movs	r0, #22
				time_us += conn_ind_us;
   2b078:	f44f 713c 	mov.w	r1, #752	; 0x2f0
   2b07c:	e7eb      	b.n	2b056 <adv_time_get.constprop.0.isra.0+0x3e>

0002b07e <ull_adv_init>:
	err = init_reset();
   2b07e:	f7f1 b92d 	b.w	1c2dc <init_reset>

0002b082 <ull_adv_reset>:
{
   2b082:	b508      	push	{r3, lr}
		(void)disable(handle);
   2b084:	f7f1 fac8 	bl	1c618 <disable.constprop.0>
}
   2b088:	2000      	movs	r0, #0
   2b08a:	bd08      	pop	{r3, pc}

0002b08c <ull_adv_is_enabled>:
{
   2b08c:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   2b08e:	f7f1 fab5 	bl	1c5fc <ull_adv_is_enabled_get>
}
   2b092:	3800      	subs	r0, #0
   2b094:	bf18      	it	ne
   2b096:	2001      	movne	r0, #1
   2b098:	bd08      	pop	{r3, pc}

0002b09a <ull_adv_filter_pol_get>:
{
   2b09a:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   2b09c:	f7f1 faae 	bl	1c5fc <ull_adv_is_enabled_get>
	if (!adv) {
   2b0a0:	b118      	cbz	r0, 2b0aa <ull_adv_filter_pol_get+0x10>
	return adv->lll.filter_policy;
   2b0a2:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
   2b0a6:	f000 0003 	and.w	r0, r0, #3
}
   2b0aa:	bd08      	pop	{r3, pc}

0002b0ac <ull_adv_pdu_update_addrs>:
{
   2b0ac:	b510      	push	{r4, lr}
			own_id_addr = ll_addr_get(pdu->tx_addr);
   2b0ae:	460c      	mov	r4, r1
   2b0b0:	f814 0b02 	ldrb.w	r0, [r4], #2
   2b0b4:	f3c0 1080 	ubfx	r0, r0, #6, #1
   2b0b8:	f7ee ffee 	bl	1a098 <ll_addr_get>
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   2b0bc:	2206      	movs	r2, #6
			own_id_addr = ll_addr_get(pdu->tx_addr);
   2b0be:	4601      	mov	r1, r0
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   2b0c0:	4620      	mov	r0, r4
   2b0c2:	f7fc fbd5 	bl	27870 <memcpy>
}
   2b0c6:	4620      	mov	r0, r4
   2b0c8:	bd10      	pop	{r4, pc}

0002b0ca <ull_adv_data_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
   2b0ca:	291f      	cmp	r1, #31
{
   2b0cc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2b0d0:	4604      	mov	r4, r0
   2b0d2:	460d      	mov	r5, r1
   2b0d4:	4690      	mov	r8, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
   2b0d6:	d849      	bhi.n	2b16c <ull_adv_data_set+0xa2>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   2b0d8:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
   2b0dc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   2b0e0:	6adf      	ldr	r7, [r3, #44]	; 0x2c
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   2b0e2:	783b      	ldrb	r3, [r7, #0]
   2b0e4:	f003 030f 	and.w	r3, r3, #15
   2b0e8:	2b01      	cmp	r3, #1
   2b0ea:	d10a      	bne.n	2b102 <ull_adv_data_set+0x38>
		adv->ad_data_backup.len = len;
   2b0ec:	f880 1040 	strb.w	r1, [r0, #64]	; 0x40
		memcpy(adv->ad_data_backup.data, data, adv->ad_data_backup.len);
   2b0f0:	460a      	mov	r2, r1
   2b0f2:	3041      	adds	r0, #65	; 0x41
   2b0f4:	4641      	mov	r1, r8
   2b0f6:	f7fc fbbb 	bl	27870 <memcpy>
	return 0;
   2b0fa:	2000      	movs	r0, #0
}
   2b0fc:	b002      	add	sp, #8
   2b0fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
   2b102:	f10d 0107 	add.w	r1, sp, #7
   2b106:	3028      	adds	r0, #40	; 0x28
   2b108:	f000 fadf 	bl	2b6ca <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
   2b10c:	4639      	mov	r1, r7
   2b10e:	4606      	mov	r6, r0
   2b110:	f811 2b02 	ldrb.w	r2, [r1], #2
   2b114:	f3c2 1080 	ubfx	r0, r2, #6, #1
	pdu->type = prev->type;
   2b118:	f3c2 0303 	ubfx	r3, r2, #0, #4
   2b11c:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
   2b120:	f002 0280 	and.w	r2, r2, #128	; 0x80
   2b124:	4630      	mov	r0, r6
   2b126:	4313      	orrs	r3, r2
   2b128:	f800 3b02 	strb.w	r3, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   2b12c:	2206      	movs	r2, #6
   2b12e:	f7fc fb9f 	bl	27870 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   2b132:	462a      	mov	r2, r5
   2b134:	4641      	mov	r1, r8
   2b136:	f106 0008 	add.w	r0, r6, #8
	pdu->len = BDADDR_SIZE + len;
   2b13a:	3506      	adds	r5, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   2b13c:	f7fc fb98 	bl	27870 <memcpy>
	pdu->len = BDADDR_SIZE + len;
   2b140:	7075      	strb	r5, [r6, #1]
	if (adv->is_enabled) {
   2b142:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   2b146:	07db      	lsls	r3, r3, #31
   2b148:	d404      	bmi.n	2b154 <ull_adv_data_set+0x8a>
	pdu->last = idx;
   2b14a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2b14e:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
   2b152:	e7d2      	b.n	2b0fa <ull_adv_data_set+0x30>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   2b154:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
   2b158:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		err = ull_adv_time_update(adv, pdu, pdu_scan);
   2b15c:	4631      	mov	r1, r6
   2b15e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   2b160:	4620      	mov	r0, r4
   2b162:	f7d5 fb0d 	bl	780 <ull_adv_time_update>
		if (err) {
   2b166:	2800      	cmp	r0, #0
   2b168:	d0ef      	beq.n	2b14a <ull_adv_data_set+0x80>
   2b16a:	e7c7      	b.n	2b0fc <ull_adv_data_set+0x32>
		return BT_HCI_ERR_INVALID_PARAM;
   2b16c:	2012      	movs	r0, #18
   2b16e:	e7c5      	b.n	2b0fc <ull_adv_data_set+0x32>

0002b170 <ull_scan_rsp_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
   2b170:	291f      	cmp	r1, #31
{
   2b172:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2b176:	4604      	mov	r4, r0
   2b178:	460e      	mov	r6, r1
   2b17a:	4617      	mov	r7, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
   2b17c:	d83e      	bhi.n	2b1fc <ull_scan_rsp_set+0x8c>
   2b17e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
   2b182:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   2b186:	f10d 0107 	add.w	r1, sp, #7
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   2b18a:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   2b18e:	3034      	adds	r0, #52	; 0x34
   2b190:	f000 fa9b 	bl	2b6ca <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
   2b194:	4641      	mov	r1, r8
   2b196:	4605      	mov	r5, r0
   2b198:	f811 3b02 	ldrb.w	r3, [r1], #2
   2b19c:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   2b1a0:	019b      	lsls	r3, r3, #6
   2b1a2:	f043 0304 	orr.w	r3, r3, #4
   2b1a6:	7003      	strb	r3, [r0, #0]
	pdu->len = BDADDR_SIZE + len;
   2b1a8:	1db3      	adds	r3, r6, #6
   2b1aa:	7043      	strb	r3, [r0, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   2b1ac:	2206      	movs	r2, #6
   2b1ae:	3002      	adds	r0, #2
   2b1b0:	f7fc fb5e 	bl	27870 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   2b1b4:	4632      	mov	r2, r6
   2b1b6:	4639      	mov	r1, r7
   2b1b8:	f105 0008 	add.w	r0, r5, #8
   2b1bc:	f7fc fb58 	bl	27870 <memcpy>
	if (adv->is_enabled) {
   2b1c0:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
   2b1c4:	07db      	lsls	r3, r3, #31
   2b1c6:	d407      	bmi.n	2b1d8 <ull_scan_rsp_set+0x68>
	pdu->last = idx;
   2b1c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2b1cc:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
	return 0;
   2b1d0:	2000      	movs	r0, #0
}
   2b1d2:	b002      	add	sp, #8
   2b1d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   2b1d8:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   2b1dc:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   2b1e0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
		if ((pdu_adv_scan->type == PDU_ADV_TYPE_ADV_IND) ||
   2b1e2:	780b      	ldrb	r3, [r1, #0]
   2b1e4:	f013 030f 	ands.w	r3, r3, #15
   2b1e8:	d001      	beq.n	2b1ee <ull_scan_rsp_set+0x7e>
   2b1ea:	2b06      	cmp	r3, #6
   2b1ec:	d1ec      	bne.n	2b1c8 <ull_scan_rsp_set+0x58>
			err = ull_adv_time_update(adv, pdu_adv_scan, pdu);
   2b1ee:	462a      	mov	r2, r5
   2b1f0:	4620      	mov	r0, r4
   2b1f2:	f7d5 fac5 	bl	780 <ull_adv_time_update>
			if (err) {
   2b1f6:	2800      	cmp	r0, #0
   2b1f8:	d0e6      	beq.n	2b1c8 <ull_scan_rsp_set+0x58>
   2b1fa:	e7ea      	b.n	2b1d2 <ull_scan_rsp_set+0x62>
		return BT_HCI_ERR_INVALID_PARAM;
   2b1fc:	2012      	movs	r0, #18
   2b1fe:	e7e8      	b.n	2b1d2 <ull_scan_rsp_set+0x62>

0002b200 <ull_scan_init>:
}
   2b200:	2000      	movs	r0, #0
   2b202:	4770      	bx	lr

0002b204 <disable.constprop.0>:
	ll_rx_put(rx_hdr->link, rx_hdr);
	ll_rx_sched();
}
#endif /* CONFIG_BT_CTLR_ADV_EXT */

static uint8_t disable(uint8_t handle)
   2b204:	b510      	push	{r4, lr}
{
	struct ll_scan_set *scan;
	uint8_t ret;

	scan = ull_scan_is_enabled_get(handle);
   2b206:	2000      	movs	r0, #0
   2b208:	f7f1 fb26 	bl	1c858 <ull_scan_is_enabled_get>
	if (!scan) {
   2b20c:	4604      	mov	r4, r0
   2b20e:	b158      	cbz	r0, 2b228 <disable.constprop.0+0x24>
	if (scan->lll.conn) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   2b210:	4601      	mov	r1, r0
   2b212:	2000      	movs	r0, #0
   2b214:	f7f1 faf6 	bl	1c804 <ull_scan_disable>
	if (ret) {
   2b218:	b928      	cbnz	r0, 2b226 <disable.constprop.0+0x22>
		return ret;
	}

	scan->is_enabled = 0U;
   2b21a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   2b21e:	f360 0300 	bfi	r3, r0, #0, #1
   2b222:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
   2b226:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2b228:	200c      	movs	r0, #12
   2b22a:	e7fc      	b.n	2b226 <disable.constprop.0+0x22>

0002b22c <ull_scan_reset>:
{
   2b22c:	b508      	push	{r3, lr}
		(void)disable(handle);
   2b22e:	f7ff ffe9 	bl	2b204 <disable.constprop.0>
}
   2b232:	2000      	movs	r0, #0
   2b234:	bd08      	pop	{r3, pc}

0002b236 <ll_scan_enable>:
{
   2b236:	b510      	push	{r4, lr}
	if (!enable) {
   2b238:	b918      	cbnz	r0, 2b242 <ll_scan_enable+0xc>
}
   2b23a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = disable(SCAN_HANDLE_1M);
   2b23e:	f7ff bfe1 	b.w	2b204 <disable.constprop.0>
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
   2b242:	2000      	movs	r0, #0
   2b244:	f7f1 fb16 	bl	1c874 <ull_scan_is_disabled_get>
	if (!scan) {
   2b248:	4604      	mov	r4, r0
   2b24a:	b190      	cbz	r0, 2b272 <ll_scan_enable+0x3c>
	    (!is_coded_phy && (scan->own_addr_type & 0x1))) {
   2b24c:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
   2b250:	079b      	lsls	r3, r3, #30
   2b252:	d404      	bmi.n	2b25e <ll_scan_enable+0x28>
		err = ull_scan_enable(scan);
   2b254:	4620      	mov	r0, r4
}
   2b256:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = ull_scan_enable(scan);
   2b25a:	f7d5 bae9 	b.w	830 <ull_scan_enable>
		if (!mem_nz(ll_addr_get(BT_ADDR_LE_RANDOM), BDADDR_SIZE)) {
   2b25e:	2001      	movs	r0, #1
   2b260:	f7ee ff1a 	bl	1a098 <ll_addr_get>
   2b264:	2106      	movs	r1, #6
   2b266:	f7ff fb18 	bl	2a89a <mem_nz>
   2b26a:	2800      	cmp	r0, #0
   2b26c:	d1f2      	bne.n	2b254 <ll_scan_enable+0x1e>
			return BT_HCI_ERR_INVALID_PARAM;
   2b26e:	2012      	movs	r0, #18
}
   2b270:	bd10      	pop	{r4, pc}
			return BT_HCI_ERR_CMD_DISALLOWED;
   2b272:	200c      	movs	r0, #12
   2b274:	e7fc      	b.n	2b270 <ll_scan_enable+0x3a>

0002b276 <ull_scan_is_enabled>:
{
   2b276:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   2b278:	f7f1 faee 	bl	1c858 <ull_scan_is_enabled_get>
	if (!scan) {
   2b27c:	b148      	cbz	r0, 2b292 <ull_scan_is_enabled+0x1c>
	return (((uint32_t)scan->is_enabled << scan->lll.type) |
   2b27e:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
   2b282:	f890 0020 	ldrb.w	r0, [r0, #32]
   2b286:	f003 0301 	and.w	r3, r3, #1
   2b28a:	f3c0 1040 	ubfx	r0, r0, #5, #1
   2b28e:	fa03 f000 	lsl.w	r0, r3, r0
}
   2b292:	bd08      	pop	{r3, pc}

0002b294 <ull_scan_filter_pol_get>:
{
   2b294:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   2b296:	f7f1 fadf 	bl	1c858 <ull_scan_is_enabled_get>
	if (!scan) {
   2b29a:	b118      	cbz	r0, 2b2a4 <ull_scan_filter_pol_get+0x10>
	return scan->lll.filter_policy;
   2b29c:	f890 0020 	ldrb.w	r0, [r0, #32]
   2b2a0:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
   2b2a4:	bd08      	pop	{r3, pc}

0002b2a6 <sys_put_le64>:
	dst[1] = val >> 8;
   2b2a6:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   2b2aa:	7010      	strb	r0, [r2, #0]
	dst[1] = val >> 8;
   2b2ac:	7053      	strb	r3, [r2, #1]
	sys_put_le16(val >> 16, &dst[2]);
   2b2ae:	0c00      	lsrs	r0, r0, #16
	dst[1] = val >> 8;
   2b2b0:	f3c1 2307 	ubfx	r3, r1, #8, #8
	dst[0] = val;
   2b2b4:	7111      	strb	r1, [r2, #4]
	sys_put_le16(val >> 16, &dst[2]);
   2b2b6:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
   2b2b8:	7090      	strb	r0, [r2, #2]
   2b2ba:	7191      	strb	r1, [r2, #6]
	dst[1] = val >> 8;
   2b2bc:	0a00      	lsrs	r0, r0, #8
   2b2be:	0a09      	lsrs	r1, r1, #8
   2b2c0:	70d0      	strb	r0, [r2, #3]
   2b2c2:	7153      	strb	r3, [r2, #5]
   2b2c4:	71d1      	strb	r1, [r2, #7]
}
   2b2c6:	4770      	bx	lr

0002b2c8 <ctrl_tx_enqueue>:
		if (!conn->tx_ctrl) {
   2b2c8:	e9d0 3247 	ldrd	r3, r2, [r0, #284]	; 0x11c
{
   2b2cc:	b510      	push	{r4, lr}
	if (
   2b2ce:	b18b      	cbz	r3, 2b2f4 <ctrl_tx_enqueue+0x2c>
		if (conn->tx_head == conn->tx_data) {
   2b2d0:	f8d0 4128 	ldr.w	r4, [r0, #296]	; 0x128
   2b2d4:	42a3      	cmp	r3, r4
			conn->tx_data = conn->tx_data->next;
   2b2d6:	bf04      	itt	eq
   2b2d8:	681c      	ldreq	r4, [r3, #0]
   2b2da:	f8c0 4128 	streq.w	r4, [r0, #296]	; 0x128
		if (!conn->tx_ctrl) {
   2b2de:	b992      	cbnz	r2, 2b306 <ctrl_tx_enqueue+0x3e>
			tx->next = conn->tx_head->next;
   2b2e0:	681a      	ldr	r2, [r3, #0]
   2b2e2:	600a      	str	r2, [r1, #0]
			conn->tx_head->next = tx;
   2b2e4:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl = tx;
   2b2e6:	f8c0 1120 	str.w	r1, [r0, #288]	; 0x120
	if (!tx->next) {
   2b2ea:	680b      	ldr	r3, [r1, #0]
	conn->tx_ctrl_last = tx;
   2b2ec:	f8c0 1124 	str.w	r1, [r0, #292]	; 0x124
	if (!tx->next) {
   2b2f0:	b133      	cbz	r3, 2b300 <ctrl_tx_enqueue+0x38>
}
   2b2f2:	bd10      	pop	{r4, pc}
		if (!conn->tx_ctrl) {
   2b2f4:	b93a      	cbnz	r2, 2b306 <ctrl_tx_enqueue+0x3e>
			tx->next = conn->tx_head;
   2b2f6:	600a      	str	r2, [r1, #0]
				conn->tx_ctrl = tx;
   2b2f8:	e9c0 1147 	strd	r1, r1, [r0, #284]	; 0x11c
				conn->tx_ctrl_last = tx;
   2b2fc:	f8c0 1124 	str.w	r1, [r0, #292]	; 0x124
		conn->tx_data_last = tx;
   2b300:	f8c0 112c 	str.w	r1, [r0, #300]	; 0x12c
}
   2b304:	e7f5      	b.n	2b2f2 <ctrl_tx_enqueue+0x2a>
	tx->next = conn->tx_ctrl_last->next;
   2b306:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
   2b30a:	681a      	ldr	r2, [r3, #0]
   2b30c:	600a      	str	r2, [r1, #0]
	conn->tx_ctrl_last->next = tx;
   2b30e:	6019      	str	r1, [r3, #0]
   2b310:	e7eb      	b.n	2b2ea <ctrl_tx_enqueue+0x22>

0002b312 <reject_ext_ind_send.constprop.0>:
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   2b312:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2b314:	4616      	mov	r6, r2
	tx = ctrl_tx_rsp_mem_acquire(conn, rx, &err);
   2b316:	aa01      	add	r2, sp, #4
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   2b318:	460c      	mov	r4, r1
   2b31a:	4605      	mov	r5, r0
	tx = ctrl_tx_rsp_mem_acquire(conn, rx, &err);
   2b31c:	f7f1 fabe 	bl	1c89c <ctrl_tx_rsp_mem_acquire>
	if (!tx) {
   2b320:	4601      	mov	r1, r0
   2b322:	b910      	cbnz	r0, 2b32a <reject_ext_ind_send.constprop.0+0x18>
		return err;
   2b324:	9801      	ldr	r0, [sp, #4]
}
   2b326:	b002      	add	sp, #8
   2b328:	bd70      	pop	{r4, r5, r6, pc}
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2b32a:	7903      	ldrb	r3, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   2b32c:	7246      	strb	r6, [r0, #9]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2b32e:	f043 0303 	orr.w	r3, r3, #3
   2b332:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   2b334:	2303      	movs	r3, #3
   2b336:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   2b338:	2311      	movs	r3, #17
   2b33a:	71c3      	strb	r3, [r0, #7]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   2b33c:	230f      	movs	r3, #15
   2b33e:	7203      	strb	r3, [r0, #8]
	ctrl_tx_enqueue(conn, tx);
   2b340:	4628      	mov	r0, r5
   2b342:	f7ff ffc1 	bl	2b2c8 <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_RELEASE;
   2b346:	2301      	movs	r3, #1
   2b348:	7123      	strb	r3, [r4, #4]
	return 0;
   2b34a:	2000      	movs	r0, #0
   2b34c:	e7eb      	b.n	2b326 <reject_ext_ind_send.constprop.0+0x14>

0002b34e <ll_connected_get>:
{
   2b34e:	b508      	push	{r3, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
   2b350:	b918      	cbnz	r0, 2b35a <ll_connected_get+0xc>
	conn = ll_conn_get(handle);
   2b352:	f7f1 fc9d 	bl	1cc90 <ll_conn_get>
	if (conn->lll.handle != handle) {
   2b356:	8d03      	ldrh	r3, [r0, #40]	; 0x28
   2b358:	b103      	cbz	r3, 2b35c <ll_connected_get+0xe>
		return NULL;
   2b35a:	2000      	movs	r0, #0
}
   2b35c:	bd08      	pop	{r3, pc}

0002b35e <ll_conn_update>:
{
   2b35e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b362:	4605      	mov	r5, r0
   2b364:	f8bd a020 	ldrh.w	sl, [sp, #32]
   2b368:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
   2b36c:	f8bd 8028 	ldrh.w	r8, [sp, #40]	; 0x28
   2b370:	460c      	mov	r4, r1
   2b372:	4617      	mov	r7, r2
   2b374:	461e      	mov	r6, r3
	conn = ll_connected_get(handle);
   2b376:	f7ff ffea 	bl	2b34e <ll_connected_get>
	if (!conn) {
   2b37a:	2800      	cmp	r0, #0
   2b37c:	d06e      	beq.n	2b45c <ll_conn_update+0xfe>
	if (!cmd) {
   2b37e:	bb84      	cbnz	r4, 2b3e2 <ll_conn_update+0x84>
		if (!conn->llcp_conn_param.disabled &&
   2b380:	f890 30f6 	ldrb.w	r3, [r0, #246]	; 0xf6
   2b384:	069a      	lsls	r2, r3, #26
   2b386:	d408      	bmi.n	2b39a <ll_conn_update+0x3c>
		    (!conn->common.fex_valid ||
   2b388:	f890 107c 	ldrb.w	r1, [r0, #124]	; 0x7c
		if (!conn->llcp_conn_param.disabled &&
   2b38c:	f011 0101 	ands.w	r1, r1, #1
   2b390:	d045      	beq.n	2b41e <ll_conn_update+0xc0>
		     (conn->llcp_feature.features_conn &
   2b392:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
		    (!conn->common.fex_valid ||
   2b396:	079b      	lsls	r3, r3, #30
   2b398:	d424      	bmi.n	2b3e4 <ll_conn_update+0x86>
		} else if (conn->lll.role) {
   2b39a:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
   2b39e:	2b00      	cmp	r3, #0
   2b3a0:	db5e      	blt.n	2b460 <ll_conn_update+0x102>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   2b3a2:	f890 309c 	ldrb.w	r3, [r0, #156]	; 0x9c
   2b3a6:	f890 209d 	ldrb.w	r2, [r0, #157]	; 0x9d
   2b3aa:	429a      	cmp	r2, r3
   2b3ac:	d15a      	bne.n	2b464 <ll_conn_update+0x106>
		conn->llcp_cu.win_size = 1U;
   2b3ae:	2301      	movs	r3, #1
   2b3b0:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2b3b4:	f890 309e 	ldrb.w	r3, [r0, #158]	; 0x9e
		conn->llcp_cu.interval = interval_max;
   2b3b8:	f8a0 a0a0 	strh.w	sl, [r0, #160]	; 0xa0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2b3bc:	f023 030f 	bic.w	r3, r3, #15
		conn->llcp_cu.win_offset_us = 0U;
   2b3c0:	2400      	movs	r4, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2b3c2:	f043 0309 	orr.w	r3, r3, #9
		conn->llcp_cu.req++;
   2b3c6:	3201      	adds	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   2b3c8:	f8c0 40a8 	str.w	r4, [r0, #168]	; 0xa8
		conn->llcp_cu.latency = latency;
   2b3cc:	f8a0 90a2 	strh.w	r9, [r0, #162]	; 0xa2
		conn->llcp_cu.timeout = timeout;
   2b3d0:	f8a0 80a4 	strh.w	r8, [r0, #164]	; 0xa4
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2b3d4:	f880 309e 	strb.w	r3, [r0, #158]	; 0x9e
		conn->llcp_cu.req++;
   2b3d8:	f880 209c 	strb.w	r2, [r0, #156]	; 0x9c
}
   2b3dc:	4620      	mov	r0, r4
   2b3de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b3e2:	4621      	mov	r1, r4
		cmd--;
   2b3e4:	1e4c      	subs	r4, r1, #1
		if (cmd) {
   2b3e6:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
			if ((conn->llcp_conn_param.req ==
   2b3ea:	f890 30f4 	ldrb.w	r3, [r0, #244]	; 0xf4
			     conn->llcp_conn_param.ack) ||
   2b3ee:	f890 20f5 	ldrb.w	r2, [r0, #245]	; 0xf5
		if (cmd) {
   2b3f2:	d016      	beq.n	2b422 <ll_conn_update+0xc4>
			if ((conn->llcp_conn_param.req ==
   2b3f4:	4293      	cmp	r3, r2
   2b3f6:	d035      	beq.n	2b464 <ll_conn_update+0x106>
			    (conn->llcp_conn_param.state !=
   2b3f8:	f890 30f6 	ldrb.w	r3, [r0, #246]	; 0xf6
			     conn->llcp_conn_param.ack) ||
   2b3fc:	f003 020f 	and.w	r2, r3, #15
   2b400:	2a03      	cmp	r2, #3
   2b402:	d12f      	bne.n	2b464 <ll_conn_update+0x106>
			conn->llcp_conn_param.state = cmd;
   2b404:	f004 040f 	and.w	r4, r4, #15
   2b408:	f044 0410 	orr.w	r4, r4, #16
   2b40c:	f023 031f 	bic.w	r3, r3, #31
   2b410:	431c      	orrs	r4, r3
   2b412:	f880 40f6 	strb.w	r4, [r0, #246]	; 0xf6
			conn->llcp_conn_param.status = status;
   2b416:	f880 70f7 	strb.w	r7, [r0, #247]	; 0xf7
	return 0;
   2b41a:	2400      	movs	r4, #0
   2b41c:	e7de      	b.n	2b3dc <ll_conn_update+0x7e>
			cmd++;
   2b41e:	2101      	movs	r1, #1
   2b420:	e7e0      	b.n	2b3e4 <ll_conn_update+0x86>
			if (conn->llcp_conn_param.req !=
   2b422:	4293      	cmp	r3, r2
   2b424:	d11e      	bne.n	2b464 <ll_conn_update+0x106>
			conn->llcp_conn_param.state = cmd;
   2b426:	f8b0 20f6 	ldrh.w	r2, [r0, #246]	; 0xf6
			conn->llcp_conn_param.interval_min = interval_min;
   2b42a:	f8a0 60f8 	strh.w	r6, [r0, #248]	; 0xf8
			conn->llcp_conn_param.req++;
   2b42e:	3301      	adds	r3, #1
   2b430:	f880 30f4 	strb.w	r3, [r0, #244]	; 0xf4
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b434:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
			conn->llcp_conn_param.interval_max = interval_max;
   2b438:	f8a0 a0fa 	strh.w	sl, [r0, #250]	; 0xfa
			conn->llcp_conn_param.state = cmd;
   2b43c:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
   2b440:	f042 0210 	orr.w	r2, r2, #16
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b444:	2b00      	cmp	r3, #0
			conn->llcp_conn_param.latency = latency;
   2b446:	f8a0 90fc 	strh.w	r9, [r0, #252]	; 0xfc
			conn->llcp_conn_param.timeout = timeout;
   2b44a:	f8a0 80fe 	strh.w	r8, [r0, #254]	; 0xfe
			conn->llcp_conn_param.state = cmd;
   2b44e:	f8a0 20f6 	strh.w	r2, [r0, #246]	; 0xf6
			if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b452:	dac3      	bge.n	2b3dc <ll_conn_update+0x7e>
				ull_periph_latency_cancel(conn, handle);
   2b454:	4629      	mov	r1, r5
   2b456:	f7f2 fcc1 	bl	1dddc <ull_periph_latency_cancel>
   2b45a:	e7bf      	b.n	2b3dc <ll_conn_update+0x7e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2b45c:	2402      	movs	r4, #2
   2b45e:	e7bd      	b.n	2b3dc <ll_conn_update+0x7e>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   2b460:	241a      	movs	r4, #26
   2b462:	e7bb      	b.n	2b3dc <ll_conn_update+0x7e>
			return BT_HCI_ERR_CMD_DISALLOWED;
   2b464:	240c      	movs	r4, #12
   2b466:	e7b9      	b.n	2b3dc <ll_conn_update+0x7e>

0002b468 <ll_chm_get>:
{
   2b468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2b46a:	460d      	mov	r5, r1
	conn = ll_connected_get(handle);
   2b46c:	f7ff ff6f 	bl	2b34e <ll_connected_get>
	if (!conn) {
   2b470:	4604      	mov	r4, r0
   2b472:	b170      	cbz	r0, 2b492 <ll_chm_get+0x2a>
		conn->chm_updated = 0U;
   2b474:	2700      	movs	r7, #0
		memcpy(chm, conn->lll.data_chan_map,
   2b476:	f100 0634 	add.w	r6, r0, #52	; 0x34
		conn->chm_updated = 0U;
   2b47a:	f884 7130 	strb.w	r7, [r4, #304]	; 0x130
		memcpy(chm, conn->lll.data_chan_map,
   2b47e:	2205      	movs	r2, #5
   2b480:	4631      	mov	r1, r6
   2b482:	4628      	mov	r0, r5
   2b484:	f7fc f9f4 	bl	27870 <memcpy>
	} while (conn->chm_updated);
   2b488:	f894 0130 	ldrb.w	r0, [r4, #304]	; 0x130
   2b48c:	2800      	cmp	r0, #0
   2b48e:	d1f4      	bne.n	2b47a <ll_chm_get+0x12>
}
   2b490:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2b492:	2002      	movs	r0, #2
   2b494:	e7fc      	b.n	2b490 <ll_chm_get+0x28>

0002b496 <ll_feature_req_send>:
{
   2b496:	b510      	push	{r4, lr}
   2b498:	4604      	mov	r4, r0
	conn = ll_connected_get(handle);
   2b49a:	f7ff ff58 	bl	2b34e <ll_connected_get>
	if (!conn) {
   2b49e:	b188      	cbz	r0, 2b4c4 <ll_feature_req_send+0x2e>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   2b4a0:	f890 10b0 	ldrb.w	r1, [r0, #176]	; 0xb0
   2b4a4:	f890 20b1 	ldrb.w	r2, [r0, #177]	; 0xb1
   2b4a8:	428a      	cmp	r2, r1
   2b4aa:	d10d      	bne.n	2b4c8 <ll_feature_req_send+0x32>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b4ac:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
	conn->llcp_feature.req++;
   2b4b0:	3201      	adds	r2, #1
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b4b2:	2b00      	cmp	r3, #0
	conn->llcp_feature.req++;
   2b4b4:	f880 20b0 	strb.w	r2, [r0, #176]	; 0xb0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   2b4b8:	da02      	bge.n	2b4c0 <ll_feature_req_send+0x2a>
		ull_periph_latency_cancel(conn, handle);
   2b4ba:	4621      	mov	r1, r4
   2b4bc:	f7f2 fc8e 	bl	1dddc <ull_periph_latency_cancel>
	return 0;
   2b4c0:	2000      	movs	r0, #0
   2b4c2:	e000      	b.n	2b4c6 <ll_feature_req_send+0x30>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2b4c4:	2002      	movs	r0, #2
}
   2b4c6:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2b4c8:	200c      	movs	r0, #12
   2b4ca:	e7fc      	b.n	2b4c6 <ll_feature_req_send+0x30>

0002b4cc <ll_version_ind_send>:
{
   2b4cc:	b510      	push	{r4, lr}
   2b4ce:	4604      	mov	r4, r0
	conn = ll_connected_get(handle);
   2b4d0:	f7ff ff3d 	bl	2b34e <ll_connected_get>
	if (!conn) {
   2b4d4:	b188      	cbz	r0, 2b4fa <ll_version_ind_send+0x2e>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   2b4d6:	f890 10c8 	ldrb.w	r1, [r0, #200]	; 0xc8
   2b4da:	f890 20c9 	ldrb.w	r2, [r0, #201]	; 0xc9
   2b4de:	428a      	cmp	r2, r1
   2b4e0:	d10d      	bne.n	2b4fe <ll_version_ind_send+0x32>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   2b4e2:	f990 3039 	ldrsb.w	r3, [r0, #57]	; 0x39
	conn->llcp_version.req++;
   2b4e6:	3201      	adds	r2, #1
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   2b4e8:	2b00      	cmp	r3, #0
	conn->llcp_version.req++;
   2b4ea:	f880 20c8 	strb.w	r2, [r0, #200]	; 0xc8
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->lll.role) {
   2b4ee:	da02      	bge.n	2b4f6 <ll_version_ind_send+0x2a>
		ull_periph_latency_cancel(conn, handle);
   2b4f0:	4621      	mov	r1, r4
   2b4f2:	f7f2 fc73 	bl	1dddc <ull_periph_latency_cancel>
	return 0;
   2b4f6:	2000      	movs	r0, #0
   2b4f8:	e000      	b.n	2b4fc <ll_version_ind_send+0x30>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2b4fa:	2002      	movs	r0, #2
}
   2b4fc:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2b4fe:	200c      	movs	r0, #12
   2b500:	e7fc      	b.n	2b4fc <ll_version_ind_send+0x30>

0002b502 <ull_conn_init>:
	err = init_reset();
   2b502:	f7f1 b9e9 	b.w	1c8d8 <init_reset>

0002b506 <tx_demux>:
{
   2b506:	b510      	push	{r4, lr}
   2b508:	4604      	mov	r4, r0
	ull_conn_tx_demux(1);
   2b50a:	2001      	movs	r0, #1
   2b50c:	f7f2 f8dc 	bl	1d6c8 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(param, 1);
   2b510:	4620      	mov	r0, r4
   2b512:	2101      	movs	r1, #1
}
   2b514:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ull_conn_tx_lll_enqueue(param, 1);
   2b518:	f7f2 ba80 	b.w	1da1c <ull_conn_tx_lll_enqueue>

0002b51c <ull_conn_lll_max_tx_octets_get>:
}
   2b51c:	201b      	movs	r0, #27
   2b51e:	4770      	bx	lr

0002b520 <lll_chan_sel_1>:
/* Refer to Bluetooth Specification v5.2 Vol 6, Part B, Section 4.5.8.2
 * Channel Selection algorithm #1
 */
uint8_t lll_chan_sel_1(uint8_t *chan_use, uint8_t hop, uint16_t latency, uint8_t *chan_map,
		    uint8_t chan_count)
{
   2b520:	b530      	push	{r4, r5, lr}
	uint8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2b522:	fb02 1101 	mla	r1, r2, r1, r1
   2b526:	7802      	ldrb	r2, [r0, #0]
{
   2b528:	f89d 500c 	ldrb.w	r5, [sp, #12]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2b52c:	4411      	add	r1, r2
   2b52e:	2225      	movs	r2, #37	; 0x25
{
   2b530:	4604      	mov	r4, r0
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2b532:	fbb1 f0f2 	udiv	r0, r1, r2
   2b536:	fb02 1110 	mls	r1, r2, r0, r1
   2b53a:	b2c8      	uxtb	r0, r1
	*chan_use = chan_next;

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   2b53c:	08c2      	lsrs	r2, r0, #3
	*chan_use = chan_next;
   2b53e:	7020      	strb	r0, [r4, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   2b540:	5c9c      	ldrb	r4, [r3, r2]
   2b542:	f001 0107 	and.w	r1, r1, #7
   2b546:	fa44 f101 	asr.w	r1, r4, r1
   2b54a:	f011 0101 	ands.w	r1, r1, #1
   2b54e:	d109      	bne.n	2b564 <lll_chan_sel_1+0x44>
		uint8_t chan_index;

		chan_index = chan_next % chan_count;
   2b550:	fbb0 f2f5 	udiv	r2, r0, r5
   2b554:	fb05 0212 	mls	r2, r5, r2, r0
   2b558:	1e5c      	subs	r4, r3, #1
   2b55a:	b2d2      	uxtb	r2, r2
	uint8_t chan_next;
	uint8_t byte_count;

	chan_next = 0U;
	byte_count = 5U;
	while (byte_count--) {
   2b55c:	3304      	adds	r3, #4
	chan_next = 0U;
   2b55e:	4608      	mov	r0, r1
	while (byte_count--) {
   2b560:	42a3      	cmp	r3, r4
   2b562:	d100      	bne.n	2b566 <lll_chan_sel_1+0x46>
}
   2b564:	bd30      	pop	{r4, r5, pc}
		uint8_t bite;
		uint8_t bit_count;

		bite = *chan_map;
   2b566:	f100 0108 	add.w	r1, r0, #8
   2b56a:	f814 5f01 	ldrb.w	r5, [r4, #1]!
		bit_count = 8U;
		while (bit_count--) {
   2b56e:	b2c9      	uxtb	r1, r1
   2b570:	4288      	cmp	r0, r1
   2b572:	d0f5      	beq.n	2b560 <lll_chan_sel_1+0x40>
			if (bite & 0x01) {
   2b574:	f015 0f01 	tst.w	r5, #1
   2b578:	d003      	beq.n	2b582 <lll_chan_sel_1+0x62>
				if (chan_index == 0U) {
   2b57a:	2a00      	cmp	r2, #0
   2b57c:	d0f2      	beq.n	2b564 <lll_chan_sel_1+0x44>
					break;
				}
				chan_index--;
   2b57e:	3a01      	subs	r2, #1
   2b580:	b2d2      	uxtb	r2, r2
			}
			chan_next++;
   2b582:	3001      	adds	r0, #1
   2b584:	b2c0      	uxtb	r0, r0
			bite >>= 1;
   2b586:	086d      	lsrs	r5, r5, #1
   2b588:	e7f2      	b.n	2b570 <lll_chan_sel_1+0x50>

0002b58a <filter_find.part.0>:
static uint32_t filter_find(const struct lll_filter *const filter,
   2b58a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2b58e:	4605      	mov	r5, r0
   2b590:	460f      	mov	r7, r1
   2b592:	4690      	mov	r8, r2
   2b594:	f100 062c 	add.w	r6, r0, #44	; 0x2c
	index = FAL_SIZE;
   2b598:	2408      	movs	r4, #8
	while (index--) {
   2b59a:	3c01      	subs	r4, #1
   2b59c:	d202      	bcs.n	2b5a4 <filter_find.part.0+0x1a>
	return FILTER_IDX_NONE;
   2b59e:	f04f 09ff 	mov.w	r9, #255	; 0xff
   2b5a2:	e012      	b.n	2b5ca <filter_find.part.0+0x40>
		if ((filter->enable_bitmask & BIT(index)) &&
   2b5a4:	782b      	ldrb	r3, [r5, #0]
   2b5a6:	40e3      	lsrs	r3, r4
   2b5a8:	07da      	lsls	r2, r3, #31
   2b5aa:	d401      	bmi.n	2b5b0 <filter_find.part.0+0x26>
   2b5ac:	3e06      	subs	r6, #6
   2b5ae:	e7f4      	b.n	2b59a <filter_find.part.0+0x10>
		    (((filter->addr_type_bitmask >> index) & 0x01) ==
   2b5b0:	786b      	ldrb	r3, [r5, #1]
   2b5b2:	4123      	asrs	r3, r4
   2b5b4:	407b      	eors	r3, r7
		if ((filter->enable_bitmask & BIT(index)) &&
   2b5b6:	07db      	lsls	r3, r3, #31
   2b5b8:	d4f8      	bmi.n	2b5ac <filter_find.part.0+0x22>
		    !memcmp(filter->bdaddr[index], bdaddr, BDADDR_SIZE)) {
   2b5ba:	2206      	movs	r2, #6
   2b5bc:	4641      	mov	r1, r8
   2b5be:	4630      	mov	r0, r6
   2b5c0:	46a1      	mov	r9, r4
   2b5c2:	f7fc f944 	bl	2784e <memcmp>
		     (addr_type & 0x01)) &&
   2b5c6:	2800      	cmp	r0, #0
   2b5c8:	d1f0      	bne.n	2b5ac <filter_find.part.0+0x22>
}
   2b5ca:	4648      	mov	r0, r9
   2b5cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0002b5d0 <ll_fal_size_get>:
}
   2b5d0:	2008      	movs	r0, #8
   2b5d2:	4770      	bx	lr

0002b5d4 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   2b5d4:	2000      	movs	r0, #0
   2b5d6:	f7ed bf91 	b.w	194fc <mayfly_run>

0002b5da <isr_race>:
	radio_status_reset();
   2b5da:	f7f4 bd2d 	b.w	20038 <radio_status_reset>

0002b5de <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   2b5de:	4668      	mov	r0, sp
   2b5e0:	f020 0107 	bic.w	r1, r0, #7
   2b5e4:	468d      	mov	sp, r1
   2b5e6:	b501      	push	{r0, lr}
	isr_radio();
   2b5e8:	f7f4 fc3c 	bl	1fe64 <isr_radio>
	ISR_DIRECT_PM();
   2b5ec:	f7d9 f87e 	bl	46ec <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   2b5f0:	f7d9 f96e 	bl	48d0 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   2b5f4:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   2b5f8:	4685      	mov	sp, r0
   2b5fa:	4770      	bx	lr

0002b5fc <lll_rand_isr_get>:
   2b5fc:	f7f2 beee 	b.w	1e3dc <lll_csrand_isr_get>

0002b600 <lll_reset>:
}
   2b600:	2000      	movs	r0, #0
   2b602:	4770      	bx	lr

0002b604 <lll_prepare_done>:
}
   2b604:	2000      	movs	r0, #0
   2b606:	4770      	bx	lr

0002b608 <lll_is_abort_cb>:
}
   2b608:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   2b60c:	4770      	bx	lr

0002b60e <lll_event_offset_get>:
{
   2b60e:	4603      	mov	r3, r0
		return MAX(ull->ticks_active_to_start,
   2b610:	e9d0 0201 	ldrd	r0, r2, [r0, #4]
	} else if (ull->ticks_prepare_to_start & XON_BITMASK) {
   2b614:	2a00      	cmp	r2, #0
   2b616:	da04      	bge.n	2b622 <lll_event_offset_get+0x14>
		return MAX(ull->ticks_active_to_start,
   2b618:	68db      	ldr	r3, [r3, #12]
   2b61a:	4298      	cmp	r0, r3
   2b61c:	bf38      	it	cc
   2b61e:	4618      	movcc	r0, r3
   2b620:	4770      	bx	lr
		return MAX(ull->ticks_active_to_start,
   2b622:	4290      	cmp	r0, r2
   2b624:	bf38      	it	cc
   2b626:	4610      	movcc	r0, r2
}
   2b628:	4770      	bx	lr

0002b62a <lll_preempt_calc>:
{
   2b62a:	b510      	push	{r4, lr}
   2b62c:	4614      	mov	r4, r2
	ticks_now = ticker_ticks_now_get();
   2b62e:	f7ff fc13 	bl	2ae58 <ticker_ticks_now_get>
	diff = ticks_now - ticks_at_event;
   2b632:	1b00      	subs	r0, r0, r4
	if (diff & BIT(HAL_TICKER_CNTR_MSBIT)) {
   2b634:	0203      	lsls	r3, r0, #8
   2b636:	d405      	bmi.n	2b644 <lll_preempt_calc+0x1a>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   2b638:	3003      	adds	r0, #3
	if (diff > HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) {
   2b63a:	2809      	cmp	r0, #9
   2b63c:	bf94      	ite	ls
   2b63e:	2000      	movls	r0, #0
   2b640:	2001      	movhi	r0, #1
}
   2b642:	bd10      	pop	{r4, pc}
		return 0;
   2b644:	2000      	movs	r0, #0
   2b646:	e7fc      	b.n	2b642 <lll_preempt_calc+0x18>

0002b648 <lll_radio_rx_ready_delay_get>:
	return radio_rx_ready_delay_get(phy, flags);
   2b648:	f000 ba2f 	b.w	2baaa <radio_rx_ready_delay_get>

0002b64c <lll_isr_tx_status_reset>:
{
   2b64c:	b508      	push	{r3, lr}
	radio_status_reset();
   2b64e:	f7f4 fcf3 	bl	20038 <radio_status_reset>
}
   2b652:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_status_reset();
   2b656:	f7f4 be3d 	b.w	202d4 <radio_tmr_status_reset>

0002b65a <lll_isr_rx_status_reset>:
{
   2b65a:	b508      	push	{r3, lr}
	radio_status_reset();
   2b65c:	f7f4 fcec 	bl	20038 <radio_status_reset>
	radio_tmr_status_reset();
   2b660:	f7f4 fe38 	bl	202d4 <radio_tmr_status_reset>
}
   2b664:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   2b668:	f7f4 bde4 	b.w	20234 <radio_rssi_status_reset>

0002b66c <lll_isr_status_reset>:
{
   2b66c:	b508      	push	{r3, lr}
	radio_status_reset();
   2b66e:	f7f4 fce3 	bl	20038 <radio_status_reset>
	radio_tmr_status_reset();
   2b672:	f7f4 fe2f 	bl	202d4 <radio_tmr_status_reset>
	radio_filter_status_reset();
   2b676:	f7f4 fe15 	bl	202a4 <radio_filter_status_reset>
	radio_ar_status_reset();
   2b67a:	f7f4 ff2f 	bl	204dc <radio_ar_status_reset>
}
   2b67e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   2b682:	f7f4 bdd7 	b.w	20234 <radio_rssi_status_reset>

0002b686 <lll_isr_abort>:
{
   2b686:	b510      	push	{r4, lr}
   2b688:	4604      	mov	r4, r0
	lll_isr_status_reset();
   2b68a:	f7ff ffef 	bl	2b66c <lll_isr_status_reset>
	lll_isr_cleanup(param);
   2b68e:	4620      	mov	r0, r4
}
   2b690:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   2b694:	f7f2 bf80 	b.w	1e598 <lll_isr_cleanup>

0002b698 <clock_ready>:
   2b698:	f101 0010 	add.w	r0, r1, #16
   2b69c:	f7f8 bc5a 	b.w	23f54 <z_impl_k_sem_give>

0002b6a0 <lll_clock_ppm_local_get>:
}
   2b6a0:	2032      	movs	r0, #50	; 0x32
   2b6a2:	4770      	bx	lr

0002b6a4 <isr_abort>:
{
   2b6a4:	b510      	push	{r4, lr}
   2b6a6:	4604      	mov	r4, r0
	lll_isr_status_reset();
   2b6a8:	f7ff ffe0 	bl	2b66c <lll_isr_status_reset>
	radio_filter_disable();
   2b6ac:	f7f4 fdf0 	bl	20290 <radio_filter_disable>
	lll_isr_cleanup(param);
   2b6b0:	4620      	mov	r0, r4
}
   2b6b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   2b6b6:	f7f2 bf6f 	b.w	1e598 <lll_isr_cleanup>

0002b6ba <lll_adv_reset>:
   2b6ba:	f7f3 b9a3 	b.w	1ea04 <lll_adv_init>

0002b6be <lll_adv_data_reset>:
{
   2b6be:	4603      	mov	r3, r0
	pdu->first = 0U;
   2b6c0:	2000      	movs	r0, #0
   2b6c2:	7018      	strb	r0, [r3, #0]
	pdu->last = 0U;
   2b6c4:	7058      	strb	r0, [r3, #1]
	pdu->pdu[1] = NULL;
   2b6c6:	6098      	str	r0, [r3, #8]
}
   2b6c8:	4770      	bx	lr

0002b6ca <lll_adv_pdu_alloc>:
{
   2b6ca:	b510      	push	{r4, lr}
	first = pdu->first;
   2b6cc:	7804      	ldrb	r4, [r0, #0]
	last = pdu->last;
   2b6ce:	7843      	ldrb	r3, [r0, #1]
	if (first == last) {
   2b6d0:	429c      	cmp	r4, r3
	first = pdu->first;
   2b6d2:	b2e2      	uxtb	r2, r4
	if (first == last) {
   2b6d4:	d10d      	bne.n	2b6f2 <lll_adv_pdu_alloc+0x28>
		last++;
   2b6d6:	3301      	adds	r3, #1
   2b6d8:	b2db      	uxtb	r3, r3
		if (last == DOUBLE_BUFFER_SIZE) {
   2b6da:	2b02      	cmp	r3, #2
   2b6dc:	d100      	bne.n	2b6e0 <lll_adv_pdu_alloc+0x16>
			last = 0U;
   2b6de:	2300      	movs	r3, #0
	*idx = last;
   2b6e0:	eb00 0483 	add.w	r4, r0, r3, lsl #2
   2b6e4:	700b      	strb	r3, [r1, #0]
	p = (void *)pdu->pdu[last];
   2b6e6:	6860      	ldr	r0, [r4, #4]
	if (p) {
   2b6e8:	b910      	cbnz	r0, 2b6f0 <lll_adv_pdu_alloc+0x26>
	p = lll_adv_pdu_alloc_pdu_adv();
   2b6ea:	f7f3 f9b3 	bl	1ea54 <lll_adv_pdu_alloc_pdu_adv>
	pdu->pdu[last] = (void *)p;
   2b6ee:	6060      	str	r0, [r4, #4]
}
   2b6f0:	bd10      	pop	{r4, pc}
		pdu->last = first;
   2b6f2:	7042      	strb	r2, [r0, #1]
		first_latest = pdu->first;
   2b6f4:	7804      	ldrb	r4, [r0, #0]
		if (first_latest != first) {
   2b6f6:	42a2      	cmp	r2, r4
   2b6f8:	d0f2      	beq.n	2b6e0 <lll_adv_pdu_alloc+0x16>
			pdu->last = last;
   2b6fa:	7043      	strb	r3, [r0, #1]
			last++;
   2b6fc:	e7eb      	b.n	2b6d6 <lll_adv_pdu_alloc+0xc>

0002b6fe <isr_done>:
{
   2b6fe:	b510      	push	{r4, lr}
   2b700:	4604      	mov	r4, r0
	lll_isr_status_reset();
   2b702:	f7ff ffb3 	bl	2b66c <lll_isr_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   2b706:	7a23      	ldrb	r3, [r4, #8]
   2b708:	f003 0271 	and.w	r2, r3, #113	; 0x71
   2b70c:	2a01      	cmp	r2, #1
		lll->chan_map_curr = lll->chan_map;
   2b70e:	bf02      	ittt	eq
   2b710:	f3c3 0242 	ubfxeq	r2, r3, #1, #3
   2b714:	f362 1306 	bfieq	r3, r2, #4, #3
   2b718:	7223      	strbeq	r3, [r4, #8]
	if (lll->chan_map_curr &&
   2b71a:	7a23      	ldrb	r3, [r4, #8]
   2b71c:	f013 0f70 	tst.w	r3, #112	; 0x70
   2b720:	d00e      	beq.n	2b740 <isr_done+0x42>
	    (!lll->conn || !lll->conn->periph.cancelled) &&
   2b722:	6863      	ldr	r3, [r4, #4]
   2b724:	b11b      	cbz	r3, 2b72e <isr_done+0x30>
   2b726:	f893 3020 	ldrb.w	r3, [r3, #32]
   2b72a:	079b      	lsls	r3, r3, #30
   2b72c:	d408      	bmi.n	2b740 <isr_done+0x42>
		pdu = chan_prepare(lll);
   2b72e:	4620      	mov	r0, r4
   2b730:	f7f3 fa3a 	bl	1eba8 <chan_prepare.isra.0>
		radio_tx_enable();
   2b734:	f7f4 fc68 	bl	20008 <radio_tx_enable>
}
   2b738:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   2b73c:	f7f4 beb4 	b.w	204a8 <radio_tmr_end_capture>
	radio_filter_disable();
   2b740:	f7f4 fda6 	bl	20290 <radio_filter_disable>
	lll_isr_cleanup(param);
   2b744:	4620      	mov	r0, r4
}
   2b746:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   2b74a:	f7f2 bf25 	b.w	1e598 <lll_isr_cleanup>

0002b74e <resume_prepare_cb>:
	ull = HDR_LLL2ULL(p->param);
   2b74e:	68c3      	ldr	r3, [r0, #12]
{
   2b750:	b570      	push	{r4, r5, r6, lr}
   2b752:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
   2b754:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   2b756:	f7ff fb7f 	bl	2ae58 <ticker_ticks_now_get>
   2b75a:	4605      	mov	r5, r0
   2b75c:	4630      	mov	r0, r6
   2b75e:	f7ff ff56 	bl	2b60e <lll_event_offset_get>
	p->remainder = 0;
   2b762:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   2b764:	1a2d      	subs	r5, r5, r0
   2b766:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   2b768:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   2b76a:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   2b76c:	4620      	mov	r0, r4
}
   2b76e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   2b772:	f7f3 ba97 	b.w	1eca4 <prepare_cb>

0002b776 <lll_adv_scan_req_check>:
{
   2b776:	b510      	push	{r4, lr}
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
   2b778:	7a40      	ldrb	r0, [r0, #9]
{
   2b77a:	f89d 4008 	ldrb.w	r4, [sp, #8]
		 devmatch_ok) &&
   2b77e:	07c0      	lsls	r0, r0, #31
   2b780:	d500      	bpl.n	2b784 <lll_adv_scan_req_check+0xe>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0U) ||
   2b782:	b174      	cbz	r4, 2b7a2 <lll_adv_scan_req_check+0x2c>
}

static bool isr_rx_sr_adva_check(uint8_t tx_addr, uint8_t *addr,
				 struct pdu_adv *sr)
{
	return (tx_addr == sr->rx_addr) &&
   2b784:	7808      	ldrb	r0, [r1, #0]
   2b786:	ebb2 1fd0 	cmp.w	r2, r0, lsr #7
   2b78a:	d108      	bne.n	2b79e <lll_adv_scan_req_check+0x28>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   2b78c:	2206      	movs	r2, #6
   2b78e:	3108      	adds	r1, #8
   2b790:	4618      	mov	r0, r3
   2b792:	f7fc f85c 	bl	2784e <memcmp>
	return (tx_addr == sr->rx_addr) &&
   2b796:	fab0 f080 	clz	r0, r0
   2b79a:	0940      	lsrs	r0, r0, #5
}
   2b79c:	bd10      	pop	{r4, pc}
	return (tx_addr == sr->rx_addr) &&
   2b79e:	2000      	movs	r0, #0
   2b7a0:	e7fc      	b.n	2b79c <lll_adv_scan_req_check+0x26>
		 devmatch_ok) &&
   2b7a2:	4620      	mov	r0, r4
   2b7a4:	e7fa      	b.n	2b79c <lll_adv_scan_req_check+0x26>

0002b7a6 <lll_adv_connect_ind_check>:
{
   2b7a6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2b7a8:	9f07      	ldr	r7, [sp, #28]
   2b7aa:	f89d 4020 	ldrb.w	r4, [sp, #32]
   2b7ae:	4606      	mov	r6, r0
   2b7b0:	460d      	mov	r5, r1
   2b7b2:	4618      	mov	r0, r3
	if (tgt_addr) {
   2b7b4:	b1ef      	cbz	r7, 2b7f2 <lll_adv_connect_ind_check+0x4c>
}

static inline bool isr_rx_ci_adva_check(uint8_t tx_addr, uint8_t *addr,
					struct pdu_adv *ci)
{
	return (tx_addr == ci->rx_addr) &&
   2b7b6:	780b      	ldrb	r3, [r1, #0]
   2b7b8:	ebb2 1fd3 	cmp.w	r2, r3, lsr #7
   2b7bc:	d003      	beq.n	2b7c6 <lll_adv_connect_ind_check+0x20>
		       isr_rx_ci_adva_check(tx_addr, addr, ci) &&
   2b7be:	2000      	movs	r0, #0
   2b7c0:	f000 0001 	and.w	r0, r0, #1
}
   2b7c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		!memcmp(addr, ci->connect_ind.adv_addr, BDADDR_SIZE);
   2b7c6:	2206      	movs	r2, #6
   2b7c8:	3108      	adds	r1, #8
   2b7ca:	f7fc f840 	bl	2784e <memcmp>
		       isr_rx_ci_adva_check(tx_addr, addr, ci) &&
   2b7ce:	2800      	cmp	r0, #0
   2b7d0:	d1f5      	bne.n	2b7be <lll_adv_connect_ind_check+0x18>
	return (rx_addr == ci->tx_addr) &&
   2b7d2:	782b      	ldrb	r3, [r5, #0]
   2b7d4:	f89d 2018 	ldrb.w	r2, [sp, #24]
   2b7d8:	f3c3 1380 	ubfx	r3, r3, #6, #1
   2b7dc:	4293      	cmp	r3, r2
   2b7de:	d1ef      	bne.n	2b7c0 <lll_adv_connect_ind_check+0x1a>
	       !memcmp(tgt_addr, ci->connect_ind.init_addr, BDADDR_SIZE);
   2b7e0:	2206      	movs	r2, #6
   2b7e2:	1ca9      	adds	r1, r5, #2
   2b7e4:	4638      	mov	r0, r7
   2b7e6:	f7fc f832 	bl	2784e <memcmp>
	return (rx_addr == ci->tx_addr) &&
   2b7ea:	fab0 f080 	clz	r0, r0
   2b7ee:	0940      	lsrs	r0, r0, #5
   2b7f0:	e7e6      	b.n	2b7c0 <lll_adv_connect_ind_check+0x1a>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
   2b7f2:	7a73      	ldrb	r3, [r6, #9]
		(devmatch_ok)) &&
   2b7f4:	079b      	lsls	r3, r3, #30
   2b7f6:	d500      	bpl.n	2b7fa <lll_adv_connect_ind_check+0x54>
	return (((lll->filter_policy & BT_LE_ADV_FP_FILTER_CONN_IND) == 0) ||
   2b7f8:	b174      	cbz	r4, 2b818 <lll_adv_connect_ind_check+0x72>
	return (tx_addr == ci->rx_addr) &&
   2b7fa:	782b      	ldrb	r3, [r5, #0]
   2b7fc:	ebb2 1fd3 	cmp.w	r2, r3, lsr #7
   2b800:	d108      	bne.n	2b814 <lll_adv_connect_ind_check+0x6e>
		!memcmp(addr, ci->connect_ind.adv_addr, BDADDR_SIZE);
   2b802:	2206      	movs	r2, #6
   2b804:	f105 0108 	add.w	r1, r5, #8
   2b808:	f7fc f821 	bl	2784e <memcmp>
	return (tx_addr == ci->rx_addr) &&
   2b80c:	fab0 f080 	clz	r0, r0
   2b810:	0940      	lsrs	r0, r0, #5
   2b812:	e7d7      	b.n	2b7c4 <lll_adv_connect_ind_check+0x1e>
   2b814:	2000      	movs	r0, #0
   2b816:	e7d5      	b.n	2b7c4 <lll_adv_connect_ind_check+0x1e>
		(devmatch_ok)) &&
   2b818:	4620      	mov	r0, r4
   2b81a:	e7d3      	b.n	2b7c4 <lll_adv_connect_ind_check+0x1e>

0002b81c <prepare_cb>:
	return common_prepare_cb(p, false);
   2b81c:	2100      	movs	r1, #0
   2b81e:	f7f3 bbe7 	b.w	1eff0 <common_prepare_cb>

0002b822 <isr_abort>:
{
   2b822:	b510      	push	{r4, lr}
   2b824:	4604      	mov	r4, r0
	lll_isr_status_reset();
   2b826:	f7ff ff21 	bl	2b66c <lll_isr_status_reset>
	radio_filter_disable();
   2b82a:	f7f4 fd31 	bl	20290 <radio_filter_disable>
	lll_isr_cleanup(param);
   2b82e:	4620      	mov	r0, r4
}
   2b830:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   2b834:	f7f2 beb0 	b.w	1e598 <lll_isr_cleanup>

0002b838 <isr_done>:
{
   2b838:	b508      	push	{r3, lr}
	isr_common_done(param);
   2b83a:	f7f3 fca9 	bl	1f190 <isr_common_done>
	radio_rx_enable();
   2b83e:	f7f4 fbdd 	bl	1fffc <radio_rx_enable>
}
   2b842:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   2b846:	f7f4 be2f 	b.w	204a8 <radio_tmr_end_capture>

0002b84a <isr_window>:
{
   2b84a:	b510      	push	{r4, lr}
   2b84c:	4604      	mov	r4, r0
	isr_common_done(param);
   2b84e:	f7f3 fc9f 	bl	1f190 <isr_common_done>
	if (++lll->chan == ADV_CHAN_MAX) {
   2b852:	7923      	ldrb	r3, [r4, #4]
   2b854:	f3c3 0241 	ubfx	r2, r3, #1, #2
   2b858:	3201      	adds	r2, #1
   2b85a:	f002 0203 	and.w	r2, r2, #3
   2b85e:	2a03      	cmp	r2, #3
   2b860:	bf14      	ite	ne
   2b862:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   2b866:	f36f 0342 	bfceq	r3, #1, #2
   2b86a:	7123      	strb	r3, [r4, #4]
	lll_chan_set(37 + lll->chan);
   2b86c:	7920      	ldrb	r0, [r4, #4]
   2b86e:	f3c0 0041 	ubfx	r0, r0, #1, #2
   2b872:	3025      	adds	r0, #37	; 0x25
   2b874:	f7f2 fe5e 	bl	1e534 <lll_chan_set>
	remainder_us = radio_tmr_start_now(0);
   2b878:	2000      	movs	r0, #0
   2b87a:	f7f4 fdb5 	bl	203e8 <radio_tmr_start_now>
}
   2b87e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_tmr_end_capture();
   2b882:	f7f4 be11 	b.w	204a8 <radio_tmr_end_capture>

0002b886 <resume_prepare_cb>:
	ull = HDR_LLL2ULL(p->param);
   2b886:	68c3      	ldr	r3, [r0, #12]
{
   2b888:	b570      	push	{r4, r5, r6, lr}
   2b88a:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
   2b88c:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   2b88e:	f7ff fae3 	bl	2ae58 <ticker_ticks_now_get>
   2b892:	4605      	mov	r5, r0
   2b894:	4630      	mov	r0, r6
   2b896:	f7ff feba 	bl	2b60e <lll_event_offset_get>
	p->remainder = 0;
   2b89a:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   2b89c:	1a2d      	subs	r5, r5, r0
   2b89e:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   2b8a0:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   2b8a2:	8123      	strh	r3, [r4, #8]
	return common_prepare_cb(p, true);
   2b8a4:	4620      	mov	r0, r4
   2b8a6:	2101      	movs	r1, #1
}
   2b8a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return common_prepare_cb(p, true);
   2b8ac:	f7f3 bba0 	b.w	1eff0 <common_prepare_cb>

0002b8b0 <isr_done_cleanup>:
{
   2b8b0:	b530      	push	{r4, r5, lr}
   2b8b2:	4604      	mov	r4, r0
   2b8b4:	b085      	sub	sp, #20
	lll_isr_status_reset();
   2b8b6:	f7ff fed9 	bl	2b66c <lll_isr_status_reset>
	if (lll_is_done(param, &is_resume)) {
   2b8ba:	f10d 010f 	add.w	r1, sp, #15
   2b8be:	4620      	mov	r0, r4
   2b8c0:	f7f2 fe2a 	bl	1e518 <lll_is_done>
   2b8c4:	4605      	mov	r5, r0
   2b8c6:	b9c0      	cbnz	r0, 2b8fa <isr_done_cleanup+0x4a>
	radio_filter_disable();
   2b8c8:	f7f4 fce2 	bl	20290 <radio_filter_disable>
	if (++lll->chan == ADV_CHAN_MAX) {
   2b8cc:	7923      	ldrb	r3, [r4, #4]
   2b8ce:	f3c3 0241 	ubfx	r2, r3, #1, #2
   2b8d2:	3201      	adds	r2, #1
   2b8d4:	f002 0203 	and.w	r2, r2, #3
   2b8d8:	2a03      	cmp	r2, #3
   2b8da:	bf14      	ite	ne
   2b8dc:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   2b8e0:	f365 0342 	bfieq	r3, r5, #1, #2
   2b8e4:	7123      	strb	r3, [r4, #4]
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   2b8e6:	2300      	movs	r3, #0
   2b8e8:	9300      	str	r3, [sp, #0]
   2b8ea:	2203      	movs	r2, #3
   2b8ec:	4619      	mov	r1, r3
   2b8ee:	4618      	mov	r0, r3
   2b8f0:	f7ee fb78 	bl	19fe4 <ticker_stop>
	lll_isr_cleanup(param);
   2b8f4:	4620      	mov	r0, r4
   2b8f6:	f7f2 fe4f 	bl	1e598 <lll_isr_cleanup>
}
   2b8fa:	b005      	add	sp, #20
   2b8fc:	bd30      	pop	{r4, r5, pc}

0002b8fe <lll_scan_init>:
}
   2b8fe:	2000      	movs	r0, #0
   2b900:	4770      	bx	lr

0002b902 <lll_scan_reset>:
   2b902:	2000      	movs	r0, #0
   2b904:	4770      	bx	lr

0002b906 <lll_conn_init>:
{
   2b906:	b508      	push	{r3, lr}

static void empty_tx_init(void)
{
	struct pdu_data *p;

	p = (void *)radio_pkt_empty_get();
   2b908:	f7f4 fbd6 	bl	200b8 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   2b90c:	7803      	ldrb	r3, [r0, #0]
   2b90e:	2201      	movs	r2, #1
   2b910:	f362 0301 	bfi	r3, r2, #0, #2
   2b914:	7003      	strb	r3, [r0, #0]
}
   2b916:	2000      	movs	r0, #0
   2b918:	bd08      	pop	{r3, pc}

0002b91a <lll_conn_reset>:
}
   2b91a:	2000      	movs	r0, #0
   2b91c:	4770      	bx	lr

0002b91e <lll_conn_flush>:
}
   2b91e:	4770      	bx	lr

0002b920 <lll_conn_tx_pkt_set>:
{
   2b920:	b510      	push	{r4, lr}
   2b922:	460c      	mov	r4, r1
	radio_phy_set(phy, flags);
   2b924:	2100      	movs	r1, #0
   2b926:	4608      	mov	r0, r1
   2b928:	f7f4 faf0 	bl	1ff0c <radio_phy_set>
		radio_pkt_configure(RADIO_PKT_CONF_LENGTH_8BIT, max_tx_octets, pkt_flags);
   2b92c:	2008      	movs	r0, #8
   2b92e:	2201      	movs	r2, #1
   2b930:	211b      	movs	r1, #27
   2b932:	f7f4 fb31 	bl	1ff98 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   2b936:	4620      	mov	r0, r4
}
   2b938:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_pkt_tx_set(pdu_data_tx);
   2b93c:	f7f4 bb58 	b.w	1fff0 <radio_pkt_tx_set>

0002b940 <lll_conn_pdu_tx_prep>:
{
   2b940:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2b944:	4604      	mov	r4, r0
   2b946:	4688      	mov	r8, r1
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   2b948:	aa01      	add	r2, sp, #4
   2b94a:	e9d0 010f 	ldrd	r0, r1, [r0, #60]	; 0x3c
   2b94e:	f7fe ffc4 	bl	2a8da <memq_peek>
	if (lll->empty || !link) {
   2b952:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   2b956:	075b      	lsls	r3, r3, #29
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   2b958:	4681      	mov	r9, r0
	if (lll->empty || !link) {
   2b95a:	d400      	bmi.n	2b95e <lll_conn_pdu_tx_prep+0x1e>
   2b95c:	b9b8      	cbnz	r0, 2b98e <lll_conn_pdu_tx_prep+0x4e>
		lll->empty = 1U;
   2b95e:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
   2b962:	f043 0304 	orr.w	r3, r3, #4
   2b966:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
		p = (void *)radio_pkt_empty_get();
   2b96a:	f7f4 fba5 	bl	200b8 <radio_pkt_empty_get>
   2b96e:	7803      	ldrb	r3, [r0, #0]
   2b970:	4605      	mov	r5, r0
		if (link || FORCE_MD_CNT_GET()) {
   2b972:	f1b9 0f00 	cmp.w	r9, #0
   2b976:	d007      	beq.n	2b988 <lll_conn_pdu_tx_prep+0x48>
			p->md = 1U;
   2b978:	f043 0310 	orr.w	r3, r3, #16
			p->md = 0U;
   2b97c:	702b      	strb	r3, [r5, #0]
	*pdu_data_tx = p;
   2b97e:	f8c8 5000 	str.w	r5, [r8]
}
   2b982:	b003      	add	sp, #12
   2b984:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			p->md = 0U;
   2b988:	f369 1304 	bfi	r3, r9, #4, #1
   2b98c:	e7f6      	b.n	2b97c <lll_conn_pdu_tx_prep+0x3c>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   2b98e:	9f01      	ldr	r7, [sp, #4]
   2b990:	f894 6051 	ldrb.w	r6, [r4, #81]	; 0x51
		if (!lll->packet_tx_head_len) {
   2b994:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   2b998:	3704      	adds	r7, #4
   2b99a:	19bd      	adds	r5, r7, r6
		if (!lll->packet_tx_head_len) {
   2b99c:	b913      	cbnz	r3, 2b9a4 <lll_conn_pdu_tx_prep+0x64>
			lll->packet_tx_head_len = p->len;
   2b99e:	786b      	ldrb	r3, [r5, #1]
   2b9a0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		if (lll->packet_tx_head_offset) {
   2b9a4:	b126      	cbz	r6, 2b9b0 <lll_conn_pdu_tx_prep+0x70>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   2b9a6:	5dbb      	ldrb	r3, [r7, r6]
   2b9a8:	2201      	movs	r2, #1
   2b9aa:	f362 0301 	bfi	r3, r2, #0, #2
   2b9ae:	55bb      	strb	r3, [r7, r6]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   2b9b0:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
   2b9b4:	1b9b      	subs	r3, r3, r6
   2b9b6:	706b      	strb	r3, [r5, #1]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   2b9b8:	4620      	mov	r0, r4
   2b9ba:	f7ff fdaf 	bl	2b51c <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   2b9be:	786b      	ldrb	r3, [r5, #1]
   2b9c0:	4283      	cmp	r3, r0
   2b9c2:	d90b      	bls.n	2b9dc <lll_conn_pdu_tx_prep+0x9c>
			p->len = max_tx_octets;
   2b9c4:	7068      	strb	r0, [r5, #1]
			p->md = 1U;
   2b9c6:	5dbb      	ldrb	r3, [r7, r6]
			p->md = 1U;
   2b9c8:	f043 0310 	orr.w	r3, r3, #16
			p->md = 0U;
   2b9cc:	55bb      	strb	r3, [r7, r6]
		p->rfu = 0U;
   2b9ce:	5dbb      	ldrb	r3, [r7, r6]
   2b9d0:	f36f 1347 	bfc	r3, #5, #3
   2b9d4:	55bb      	strb	r3, [r7, r6]
		p->resv = 0U;
   2b9d6:	2300      	movs	r3, #0
   2b9d8:	70ab      	strb	r3, [r5, #2]
   2b9da:	e7d0      	b.n	2b97e <lll_conn_pdu_tx_prep+0x3e>
		} else if ((link->next != lll->memq_tx.tail) ||
   2b9dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2b9de:	f8d9 2000 	ldr.w	r2, [r9]
   2b9e2:	429a      	cmp	r2, r3
   2b9e4:	5dbb      	ldrb	r3, [r7, r6]
   2b9e6:	d1ef      	bne.n	2b9c8 <lll_conn_pdu_tx_prep+0x88>
			p->md = 0U;
   2b9e8:	f36f 1304 	bfc	r3, #4, #1
   2b9ec:	e7ee      	b.n	2b9cc <lll_conn_pdu_tx_prep+0x8c>

0002b9ee <ecb_encrypt_be>:

void ecb_encrypt_be(uint8_t const *const key_be, uint8_t const *const clear_text_be,
		    uint8_t * const cipher_text_be)
{
   2b9ee:	b530      	push	{r4, r5, lr}
   2b9f0:	b08d      	sub	sp, #52	; 0x34
   2b9f2:	460d      	mov	r5, r1
   2b9f4:	4614      	mov	r4, r2
	struct ecb_param ecb;

	memcpy(&ecb.key[0], key_be, sizeof(ecb.key));
   2b9f6:	4601      	mov	r1, r0
   2b9f8:	2210      	movs	r2, #16
   2b9fa:	4668      	mov	r0, sp
   2b9fc:	f7fb ff38 	bl	27870 <memcpy>
	memcpy(&ecb.clear_text[0], clear_text_be, sizeof(ecb.clear_text));
   2ba00:	2210      	movs	r2, #16
   2ba02:	4629      	mov	r1, r5
   2ba04:	eb0d 0002 	add.w	r0, sp, r2
   2ba08:	f7fb ff32 	bl	27870 <memcpy>

	do_ecb(&ecb);
   2ba0c:	4668      	mov	r0, sp
   2ba0e:	f7f4 f9f1 	bl	1fdf4 <do_ecb>

	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
   2ba12:	2210      	movs	r2, #16
   2ba14:	a908      	add	r1, sp, #32
   2ba16:	4620      	mov	r0, r4
   2ba18:	f7fb ff2a 	bl	27870 <memcpy>
}
   2ba1c:	b00d      	add	sp, #52	; 0x34
   2ba1e:	bd30      	pop	{r4, r5, pc}

0002ba20 <ecb_encrypt>:

void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
		 uint8_t * const cipher_text_le, uint8_t * const cipher_text_be)
{
   2ba20:	b570      	push	{r4, r5, r6, lr}
   2ba22:	b08c      	sub	sp, #48	; 0x30
   2ba24:	460e      	mov	r6, r1
   2ba26:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   2ba28:	4601      	mov	r1, r0
   2ba2a:	2210      	movs	r2, #16
   2ba2c:	4668      	mov	r0, sp
{
   2ba2e:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   2ba30:	f7fe ff24 	bl	2a87c <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   2ba34:	2210      	movs	r2, #16
   2ba36:	eb0d 0002 	add.w	r0, sp, r2
   2ba3a:	4631      	mov	r1, r6
   2ba3c:	f7fe ff1e 	bl	2a87c <mem_rcopy>

	do_ecb(&ecb);
   2ba40:	4668      	mov	r0, sp
   2ba42:	f7f4 f9d7 	bl	1fdf4 <do_ecb>

	if (cipher_text_le) {
   2ba46:	b125      	cbz	r5, 2ba52 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   2ba48:	2210      	movs	r2, #16
   2ba4a:	a908      	add	r1, sp, #32
   2ba4c:	4628      	mov	r0, r5
   2ba4e:	f7fe ff15 	bl	2a87c <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   2ba52:	b124      	cbz	r4, 2ba5e <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   2ba54:	2210      	movs	r2, #16
   2ba56:	a908      	add	r1, sp, #32
   2ba58:	4620      	mov	r0, r4
   2ba5a:	f7fb ff09 	bl	27870 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   2ba5e:	b00c      	add	sp, #48	; 0x30
   2ba60:	bd70      	pop	{r4, r5, r6, pc}

0002ba62 <radio_setup>:
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   2ba62:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2ba66:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   2ba6a:	2100      	movs	r1, #0
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   2ba6c:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	NRF_AMLI->RAMPRI.SPIS1   = 0xFFFFFFFFUL;
   2ba70:	f8c3 2e04 	str.w	r2, [r3, #3588]	; 0xe04
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   2ba74:	f8c3 1e08 	str.w	r1, [r3, #3592]	; 0xe08
	NRF_AMLI->RAMPRI.ECB     = 0xFFFFFFFFUL;
   2ba78:	f8c3 2e0c 	str.w	r2, [r3, #3596]	; 0xe0c
	NRF_AMLI->RAMPRI.CCM     = 0x00000000UL;
   2ba7c:	f8c3 1e10 	str.w	r1, [r3, #3600]	; 0xe10
	NRF_AMLI->RAMPRI.AAR     = 0xFFFFFFFFUL;
   2ba80:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
	NRF_AMLI->RAMPRI.SAADC   = 0xFFFFFFFFUL;
   2ba84:	f8c3 2e18 	str.w	r2, [r3, #3608]	; 0xe18
	NRF_AMLI->RAMPRI.UARTE   = 0xFFFFFFFFUL;
   2ba88:	f8c3 2e1c 	str.w	r2, [r3, #3612]	; 0xe1c
	NRF_AMLI->RAMPRI.SERIAL0 = 0xFFFFFFFFUL;
   2ba8c:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
	NRF_AMLI->RAMPRI.SERIAL2 = 0xFFFFFFFFUL;
   2ba90:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
	NRF_AMLI->RAMPRI.NFCT    = 0xFFFFFFFFUL;
   2ba94:	f8c3 2e28 	str.w	r2, [r3, #3624]	; 0xe28
	NRF_AMLI->RAMPRI.I2S     = 0xFFFFFFFFUL;
   2ba98:	f8c3 2e2c 	str.w	r2, [r3, #3628]	; 0xe2c
	NRF_AMLI->RAMPRI.PDM     = 0xFFFFFFFFUL;
   2ba9c:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
	NRF_AMLI->RAMPRI.PWM     = 0xFFFFFFFFUL;
   2baa0:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
}
   2baa4:	4770      	bx	lr

0002baa6 <radio_tx_chain_delay_get>:
}
   2baa6:	2001      	movs	r0, #1
   2baa8:	4770      	bx	lr

0002baaa <radio_rx_ready_delay_get>:
}
   2baaa:	2029      	movs	r0, #41	; 0x29
   2baac:	4770      	bx	lr

0002baae <radio_rx_chain_delay_get>:
		return HAL_RADIO_NRF52832_RX_CHAIN_DELAY_2M_US;
   2baae:	2802      	cmp	r0, #2
}
   2bab0:	bf14      	ite	ne
   2bab2:	200a      	movne	r0, #10
   2bab4:	2006      	moveq	r0, #6
   2bab6:	4770      	bx	lr

0002bab8 <radio_phy_flags_rx_get>:
}
   2bab8:	2000      	movs	r0, #0
   2baba:	4770      	bx	lr

0002babc <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2babc:	4288      	cmp	r0, r1
   2babe:	d00a      	beq.n	2bad6 <mayfly_prio_is_equal+0x1a>
	return (caller_id == callee_id) ||
   2bac0:	2801      	cmp	r0, #1
   2bac2:	d104      	bne.n	2bace <mayfly_prio_is_equal+0x12>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   2bac4:	2902      	cmp	r1, #2
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   2bac6:	bf14      	ite	ne
   2bac8:	2000      	movne	r0, #0
   2baca:	2001      	moveq	r0, #1
   2bacc:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2bace:	2802      	cmp	r0, #2
   2bad0:	d103      	bne.n	2bada <mayfly_prio_is_equal+0x1e>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   2bad2:	2901      	cmp	r1, #1
   2bad4:	e7f7      	b.n	2bac6 <mayfly_prio_is_equal+0xa>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2bad6:	2001      	movs	r0, #1
   2bad8:	4770      	bx	lr
   2bada:	2000      	movs	r0, #0
}
   2badc:	4770      	bx	lr

0002bade <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(uint32_t value)
{
   2bade:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
   2bae0:	2000      	movs	r0, #0
   2bae2:	f7f4 b97f 	b.w	1fde4 <cntr_cmp_set>

0002bae6 <sys_put_le32>:
	dst[1] = val >> 8;
   2bae6:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   2baea:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   2baec:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   2baee:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   2baf0:	0a00      	lsrs	r0, r0, #8
   2baf2:	704b      	strb	r3, [r1, #1]
   2baf4:	70c8      	strb	r0, [r1, #3]
}
   2baf6:	4770      	bx	lr

0002baf8 <hci_vendor_read_static_addr>:
				 uint8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   2baf8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
   2bafc:	b510      	push	{r4, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   2bafe:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   2bb02:	3201      	adds	r2, #1
{
   2bb04:	4604      	mov	r4, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   2bb06:	d106      	bne.n	2bb16 <hci_vendor_read_static_addr+0x1e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   2bb08:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   2bb0c:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   2bb10:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   2bb12:	4293      	cmp	r3, r2
   2bb14:	d044      	beq.n	2bba0 <hci_vendor_read_static_addr+0xa8>
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   2bb16:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2bb1a:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   2bb1e:	f010 0001 	ands.w	r0, r0, #1
   2bb22:	d036      	beq.n	2bb92 <hci_vendor_read_static_addr+0x9a>
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
   2bb24:	4621      	mov	r1, r4
   2bb26:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
   2bb2a:	f7ff ffdc 	bl	2bae6 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
   2bb2e:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
   2bb32:	7123      	strb	r3, [r4, #4]
	dst[1] = val >> 8;
   2bb34:	f3c3 2307 	ubfx	r3, r3, #8, #8

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
   2bb38:	f063 033f 	orn	r3, r3, #63	; 0x3f
   2bb3c:	7163      	strb	r3, [r4, #5]

		/* If no public address is provided and a static address is
		 * available, then it is recommended to return an identity root
		 * key (if available) from this command.
		 */
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   2bb3e:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
   2bb42:	3101      	adds	r1, #1
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   2bb44:	f104 0306 	add.w	r3, r4, #6
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   2bb48:	d024      	beq.n	2bb94 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   2bb4a:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   2bb4e:	3101      	adds	r1, #1
   2bb50:	d020      	beq.n	2bb94 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   2bb52:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   2bb56:	3101      	adds	r1, #1
   2bb58:	d01c      	beq.n	2bb94 <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   2bb5a:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   2bb5e:	3101      	adds	r1, #1
   2bb60:	d018      	beq.n	2bb94 <hci_vendor_read_static_addr+0x9c>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   2bb62:	4619      	mov	r1, r3
   2bb64:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
   2bb68:	f7ff ffbd 	bl	2bae6 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
   2bb6c:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
   2bb70:	f104 010a 	add.w	r1, r4, #10
   2bb74:	f7ff ffb7 	bl	2bae6 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
   2bb78:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
   2bb7c:	f104 010e 	add.w	r1, r4, #14
   2bb80:	f7ff ffb1 	bl	2bae6 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
   2bb84:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   2bb88:	f104 0112 	add.w	r1, r4, #18
   2bb8c:	f7ff ffab 	bl	2bae6 <sys_put_le32>
		} else {
			/* Mark IR as invalid */
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
		}

		return 1;
   2bb90:	2001      	movs	r0, #1
	}

	return 0;
}
   2bb92:	bd10      	pop	{r4, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
   2bb94:	2210      	movs	r2, #16
   2bb96:	2100      	movs	r1, #0
   2bb98:	4618      	mov	r0, r3
   2bb9a:	f7fb fe74 	bl	27886 <memset>
   2bb9e:	e7f7      	b.n	2bb90 <hci_vendor_read_static_addr+0x98>
	return 0;
   2bba0:	2000      	movs	r0, #0
   2bba2:	e7f6      	b.n	2bb92 <hci_vendor_read_static_addr+0x9a>

0002bba4 <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(uint8_t ir[16], uint8_t er[16])
{
   2bba4:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
   2bba6:	2210      	movs	r2, #16
{
   2bba8:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
   2bbaa:	2100      	movs	r1, #0
   2bbac:	f7fb fe6b 	bl	27886 <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   2bbb0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2bbb4:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   2bbb8:	3301      	adds	r3, #1
   2bbba:	d023      	beq.n	2bc04 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   2bbbc:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   2bbc0:	3301      	adds	r3, #1
   2bbc2:	d01f      	beq.n	2bc04 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   2bbc4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   2bbc8:	3301      	adds	r3, #1
   2bbca:	d01b      	beq.n	2bc04 <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   2bbcc:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   2bbd0:	3301      	adds	r3, #1
   2bbd2:	d017      	beq.n	2bc04 <hci_vendor_read_key_hierarchy_roots+0x60>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
   2bbd4:	4621      	mov	r1, r4
   2bbd6:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   2bbda:	f7ff ff84 	bl	2bae6 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
   2bbde:	1d21      	adds	r1, r4, #4
   2bbe0:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   2bbe4:	f7ff ff7f 	bl	2bae6 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
   2bbe8:	f104 0108 	add.w	r1, r4, #8
   2bbec:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   2bbf0:	f7ff ff79 	bl	2bae6 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   2bbf4:	f104 010c 	add.w	r1, r4, #12
   2bbf8:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
   2bbfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   2bc00:	f7ff bf71 	b.w	2bae6 <sys_put_le32>
		(void)memset(er, 0x00, 16);
   2bc04:	4620      	mov	r0, r4
   2bc06:	2210      	movs	r2, #16
}
   2bc08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
   2bc0c:	2100      	movs	r1, #0
   2bc0e:	f7fb be3a 	b.w	27886 <memset>

0002bc12 <sys_put_be32>:
	sys_put_be16(val >> 16, dst);
   2bc12:	0c03      	lsrs	r3, r0, #16
	dst[0] = val >> 8;
   2bc14:	0e02      	lsrs	r2, r0, #24
	dst[1] = val;
   2bc16:	704b      	strb	r3, [r1, #1]
	dst[0] = val >> 8;
   2bc18:	f3c0 2307 	ubfx	r3, r0, #8, #8
   2bc1c:	700a      	strb	r2, [r1, #0]
   2bc1e:	708b      	strb	r3, [r1, #2]
	dst[1] = val;
   2bc20:	70c8      	strb	r0, [r1, #3]
}
   2bc22:	4770      	bx	lr

0002bc24 <fixed_data_unref>:
}
   2bc24:	4770      	bx	lr

0002bc26 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2bc26:	6a41      	ldr	r1, [r0, #36]	; 0x24
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   2bc28:	6849      	ldr	r1, [r1, #4]
   2bc2a:	6809      	ldr	r1, [r1, #0]
   2bc2c:	f7f4 bd9e 	b.w	2076c <net_buf_alloc_len>

0002bc30 <net_buf_get>:
{
   2bc30:	b570      	push	{r4, r5, r6, lr}
   2bc32:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   2bc34:	f7f8 f95a 	bl	23eec <z_impl_k_queue_get>
	if (!buf) {
   2bc38:	4605      	mov	r5, r0
   2bc3a:	b128      	cbz	r0, 2bc48 <net_buf_get+0x18>
   2bc3c:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   2bc3e:	7963      	ldrb	r3, [r4, #5]
   2bc40:	f013 0301 	ands.w	r3, r3, #1
   2bc44:	d102      	bne.n	2bc4c <net_buf_get+0x1c>
	frag->frags = NULL;
   2bc46:	6023      	str	r3, [r4, #0]
}
   2bc48:	4628      	mov	r0, r5
   2bc4a:	bd70      	pop	{r4, r5, r6, pc}
   2bc4c:	2300      	movs	r3, #0
   2bc4e:	2200      	movs	r2, #0
   2bc50:	4630      	mov	r0, r6
   2bc52:	f7f8 f94b 	bl	23eec <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   2bc56:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   2bc58:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   2bc5a:	f023 0301 	bic.w	r3, r3, #1
   2bc5e:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   2bc60:	4604      	mov	r4, r0
   2bc62:	e7ec      	b.n	2bc3e <net_buf_get+0xe>

0002bc64 <net_buf_simple_init_with_data>:
	buf->size  = size;
   2bc64:	b292      	uxth	r2, r2
	buf->__buf = data;
   2bc66:	6081      	str	r1, [r0, #8]
	buf->data  = data;
   2bc68:	6001      	str	r1, [r0, #0]
	buf->size  = size;
   2bc6a:	80c2      	strh	r2, [r0, #6]
	buf->len   = size;
   2bc6c:	8082      	strh	r2, [r0, #4]
}
   2bc6e:	4770      	bx	lr

0002bc70 <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   2bc70:	6883      	ldr	r3, [r0, #8]
   2bc72:	440b      	add	r3, r1
   2bc74:	6003      	str	r3, [r0, #0]
}
   2bc76:	4770      	bx	lr

0002bc78 <net_buf_slist_put>:
{
   2bc78:	b510      	push	{r4, lr}
	for (tail = buf; tail->frags; tail = tail->frags) {
   2bc7a:	460b      	mov	r3, r1
   2bc7c:	681c      	ldr	r4, [r3, #0]
   2bc7e:	b984      	cbnz	r4, 2bca2 <net_buf_slist_put+0x2a>
	__asm__ volatile(
   2bc80:	f04f 0220 	mov.w	r2, #32
   2bc84:	f3ef 8411 	mrs	r4, BASEPRI
   2bc88:	f382 8812 	msr	BASEPRI_MAX, r2
   2bc8c:	f3bf 8f6f 	isb	sy
	return list->tail;
   2bc90:	6842      	ldr	r2, [r0, #4]
Z_GENLIST_APPEND_LIST(slist, snode)
   2bc92:	b962      	cbnz	r2, 2bcae <net_buf_slist_put+0x36>
	list->head = node;
   2bc94:	6001      	str	r1, [r0, #0]
	list->tail = node;
   2bc96:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   2bc98:	f384 8811 	msr	BASEPRI, r4
   2bc9c:	f3bf 8f6f 	isb	sy
}
   2bca0:	bd10      	pop	{r4, pc}
		tail->flags |= NET_BUF_FRAGS;
   2bca2:	795a      	ldrb	r2, [r3, #5]
   2bca4:	f042 0201 	orr.w	r2, r2, #1
   2bca8:	715a      	strb	r2, [r3, #5]
   2bcaa:	4623      	mov	r3, r4
   2bcac:	e7e6      	b.n	2bc7c <net_buf_slist_put+0x4>
	parent->next = child;
   2bcae:	6011      	str	r1, [r2, #0]
}
   2bcb0:	e7f1      	b.n	2bc96 <net_buf_slist_put+0x1e>

0002bcb2 <net_buf_put>:
{
   2bcb2:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   2bcb4:	460a      	mov	r2, r1
   2bcb6:	6814      	ldr	r4, [r2, #0]
   2bcb8:	b914      	cbnz	r4, 2bcc0 <net_buf_put+0xe>
}
   2bcba:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   2bcbc:	f000 bfa3 	b.w	2cc06 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   2bcc0:	7953      	ldrb	r3, [r2, #5]
   2bcc2:	f043 0301 	orr.w	r3, r3, #1
   2bcc6:	7153      	strb	r3, [r2, #5]
   2bcc8:	4622      	mov	r2, r4
   2bcca:	e7f4      	b.n	2bcb6 <net_buf_put+0x4>

0002bccc <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   2bccc:	7902      	ldrb	r2, [r0, #4]
   2bcce:	3201      	adds	r2, #1
   2bcd0:	7102      	strb	r2, [r0, #4]
	return buf;
}
   2bcd2:	4770      	bx	lr

0002bcd4 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   2bcd4:	4603      	mov	r3, r0
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
   2bcd6:	4618      	mov	r0, r3
   2bcd8:	681b      	ldr	r3, [r3, #0]
   2bcda:	2b00      	cmp	r3, #0
   2bcdc:	d1fb      	bne.n	2bcd6 <net_buf_frag_last+0x2>
		buf = buf->frags;
	}

	return buf;
}
   2bcde:	4770      	bx	lr

0002bce0 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
   2bce0:	6802      	ldr	r2, [r0, #0]
{
   2bce2:	b510      	push	{r4, lr}
	if (parent->frags) {
   2bce4:	b12a      	cbz	r2, 2bcf2 <net_buf_frag_insert+0x12>
   2bce6:	460b      	mov	r3, r1
	while (buf->frags) {
   2bce8:	461c      	mov	r4, r3
   2bcea:	681b      	ldr	r3, [r3, #0]
   2bcec:	2b00      	cmp	r3, #0
   2bcee:	d1fb      	bne.n	2bce8 <net_buf_frag_insert+0x8>
		net_buf_frag_last(frag)->frags = parent->frags;
   2bcf0:	6022      	str	r2, [r4, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   2bcf2:	6001      	str	r1, [r0, #0]
}
   2bcf4:	bd10      	pop	{r4, pc}

0002bcf6 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
   2bcf6:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(frag);

	if (!head) {
   2bcf8:	4604      	mov	r4, r0
   2bcfa:	b920      	cbnz	r0, 2bd06 <net_buf_frag_add+0x10>
	buf->ref++;
   2bcfc:	790b      	ldrb	r3, [r1, #4]
   2bcfe:	3301      	adds	r3, #1
   2bd00:	710b      	strb	r3, [r1, #4]
		return net_buf_ref(frag);
   2bd02:	4608      	mov	r0, r1
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
   2bd04:	bd10      	pop	{r4, pc}
   2bd06:	4603      	mov	r3, r0
	while (buf->frags) {
   2bd08:	4618      	mov	r0, r3
   2bd0a:	681b      	ldr	r3, [r3, #0]
   2bd0c:	2b00      	cmp	r3, #0
   2bd0e:	d1fb      	bne.n	2bd08 <net_buf_frag_add+0x12>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
   2bd10:	f7ff ffe6 	bl	2bce0 <net_buf_frag_insert>
   2bd14:	4620      	mov	r0, r4
   2bd16:	e7f5      	b.n	2bd04 <net_buf_frag_add+0xe>

0002bd18 <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
   2bd18:	b510      	push	{r4, lr}
	struct net_buf *next_frag;

	__ASSERT_NO_MSG(frag);

	if (parent) {
   2bd1a:	b108      	cbz	r0, 2bd20 <net_buf_frag_del+0x8>
		__ASSERT_NO_MSG(parent->frags);
		__ASSERT_NO_MSG(parent->frags == frag);
		parent->frags = frag->frags;
   2bd1c:	680b      	ldr	r3, [r1, #0]
   2bd1e:	6003      	str	r3, [r0, #0]
	}

	next_frag = frag->frags;
   2bd20:	680c      	ldr	r4, [r1, #0]

	frag->frags = NULL;
   2bd22:	2300      	movs	r3, #0

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
   2bd24:	4608      	mov	r0, r1
	frag->frags = NULL;
   2bd26:	600b      	str	r3, [r1, #0]
	net_buf_unref(frag);
   2bd28:	f7f4 fdb4 	bl	20894 <net_buf_unref>
#endif

	return next_frag;
}
   2bd2c:	4620      	mov	r0, r4
   2bd2e:	bd10      	pop	{r4, pc}

0002bd30 <net_buf_simple_clone>:
#define NET_BUF_SIMPLE_INFO(fmt, ...)
#endif /* CONFIG_NET_BUF_SIMPLE_LOG */

void net_buf_simple_clone(const struct net_buf_simple *original,
			  struct net_buf_simple *clone)
{
   2bd30:	460b      	mov	r3, r1
	memcpy(clone, original, sizeof(struct net_buf_simple));
   2bd32:	220c      	movs	r2, #12
   2bd34:	4601      	mov	r1, r0
   2bd36:	4618      	mov	r0, r3
   2bd38:	f7fb bd9a 	b.w	27870 <memcpy>

0002bd3c <net_buf_simple_add>:
	return buf->data + buf->len;
   2bd3c:	8883      	ldrh	r3, [r0, #4]
   2bd3e:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   2bd40:	4419      	add	r1, r3
   2bd42:	8081      	strh	r1, [r0, #4]
	return tail;
}
   2bd44:	18d0      	adds	r0, r2, r3
   2bd46:	4770      	bx	lr

0002bd48 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   2bd48:	b430      	push	{r4, r5}
   2bd4a:	8884      	ldrh	r4, [r0, #4]
   2bd4c:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
   2bd4e:	18a3      	adds	r3, r4, r2
   2bd50:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   2bd52:	1928      	adds	r0, r5, r4
}
   2bd54:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   2bd56:	f7fb bd8b 	b.w	27870 <memcpy>

0002bd5a <net_buf_simple_add_u8>:
   2bd5a:	8883      	ldrh	r3, [r0, #4]
   2bd5c:	6802      	ldr	r2, [r0, #0]

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   2bd5e:	b510      	push	{r4, lr}
	buf->len += len;
   2bd60:	1c5c      	adds	r4, r3, #1
   2bd62:	8084      	strh	r4, [r0, #4]
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   2bd64:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   2bd66:	18d0      	adds	r0, r2, r3
   2bd68:	bd10      	pop	{r4, pc}

0002bd6a <net_buf_simple_add_le16>:
   2bd6a:	8883      	ldrh	r3, [r0, #4]
   2bd6c:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, uint16_t val)
{
   2bd6e:	b530      	push	{r4, r5, lr}
   2bd70:	18d4      	adds	r4, r2, r3
	buf->len += len;
   2bd72:	1c9d      	adds	r5, r3, #2
   2bd74:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   2bd76:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   2bd78:	0a09      	lsrs	r1, r1, #8
   2bd7a:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   2bd7c:	bd30      	pop	{r4, r5, pc}

0002bd7e <net_buf_simple_add_be16>:
   2bd7e:	8883      	ldrh	r3, [r0, #4]
   2bd80:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_be16(struct net_buf_simple *buf, uint16_t val)
{
   2bd82:	b530      	push	{r4, r5, lr}
	buf->len += len;
   2bd84:	1c9d      	adds	r5, r3, #2
   2bd86:	8085      	strh	r5, [r0, #4]
   2bd88:	18d4      	adds	r4, r2, r3
	dst[0] = val >> 8;
   2bd8a:	0a08      	lsrs	r0, r1, #8
   2bd8c:	54d0      	strb	r0, [r2, r3]
	dst[1] = val;
   2bd8e:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be16(val, net_buf_simple_add(buf, sizeof(val)));
}
   2bd90:	bd30      	pop	{r4, r5, pc}

0002bd92 <net_buf_simple_add_le24>:
   2bd92:	8883      	ldrh	r3, [r0, #4]

void net_buf_simple_add_le24(struct net_buf_simple *buf, uint32_t val)
{
   2bd94:	b530      	push	{r4, r5, lr}
   2bd96:	6804      	ldr	r4, [r0, #0]
	buf->len += len;
   2bd98:	1cdd      	adds	r5, r3, #3
   2bd9a:	18e2      	adds	r2, r4, r3
   2bd9c:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   2bd9e:	54e1      	strb	r1, [r4, r3]
	dst[1] = val >> 8;
   2bda0:	f3c1 2307 	ubfx	r3, r1, #8, #8
	dst[2] = val >> 16;
   2bda4:	0c09      	lsrs	r1, r1, #16
	dst[1] = val >> 8;
   2bda6:	7053      	strb	r3, [r2, #1]
	dst[2] = val >> 16;
   2bda8:	7091      	strb	r1, [r2, #2]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le24(val, net_buf_simple_add(buf, 3));
}
   2bdaa:	bd30      	pop	{r4, r5, pc}

0002bdac <net_buf_simple_add_be32>:

	sys_put_le32(val, net_buf_simple_add(buf, sizeof(val)));
}

void net_buf_simple_add_be32(struct net_buf_simple *buf, uint32_t val)
{
   2bdac:	4603      	mov	r3, r0
   2bdae:	4608      	mov	r0, r1
   2bdb0:	889a      	ldrh	r2, [r3, #4]
   2bdb2:	6819      	ldr	r1, [r3, #0]
   2bdb4:	b410      	push	{r4}
	buf->len += len;
   2bdb6:	1d14      	adds	r4, r2, #4
   2bdb8:	809c      	strh	r4, [r3, #4]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be32(val, net_buf_simple_add(buf, sizeof(val)));
   2bdba:	4411      	add	r1, r2
}
   2bdbc:	bc10      	pop	{r4}
	sys_put_be32(val, net_buf_simple_add(buf, sizeof(val)));
   2bdbe:	f7ff bf28 	b.w	2bc12 <sys_put_be32>

0002bdc2 <net_buf_simple_push>:

	return sys_be64_to_cpu(val);
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
   2bdc2:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   2bdc4:	6800      	ldr	r0, [r0, #0]
	buf->len += len;
   2bdc6:	889a      	ldrh	r2, [r3, #4]
	buf->data -= len;
   2bdc8:	1a40      	subs	r0, r0, r1
	buf->len += len;
   2bdca:	4411      	add	r1, r2
	buf->data -= len;
   2bdcc:	6018      	str	r0, [r3, #0]
	buf->len += len;
   2bdce:	8099      	strh	r1, [r3, #4]
	return buf->data;
}
   2bdd0:	4770      	bx	lr

0002bdd2 <net_buf_simple_push_be16>:
	buf->data -= len;
   2bdd2:	6803      	ldr	r3, [r0, #0]
   2bdd4:	1e9a      	subs	r2, r3, #2
   2bdd6:	6002      	str	r2, [r0, #0]
	buf->len += len;
   2bdd8:	8882      	ldrh	r2, [r0, #4]
   2bdda:	3202      	adds	r2, #2
   2bddc:	8082      	strh	r2, [r0, #4]
	dst[0] = val >> 8;
   2bdde:	0a0a      	lsrs	r2, r1, #8
   2bde0:	f803 2c02 	strb.w	r2, [r3, #-2]
	dst[1] = val;
   2bde4:	f803 1c01 	strb.w	r1, [r3, #-1]
void net_buf_simple_push_be16(struct net_buf_simple *buf, uint16_t val)
{
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be16(val, net_buf_simple_push(buf, sizeof(val)));
}
   2bde8:	4770      	bx	lr

0002bdea <net_buf_simple_push_u8>:
	buf->data -= len;
   2bdea:	6802      	ldr	r2, [r0, #0]
   2bdec:	1e53      	subs	r3, r2, #1
   2bdee:	6003      	str	r3, [r0, #0]
	buf->len += len;
   2bdf0:	8883      	ldrh	r3, [r0, #4]
   2bdf2:	3301      	adds	r3, #1
   2bdf4:	8083      	strh	r3, [r0, #4]

void net_buf_simple_push_u8(struct net_buf_simple *buf, uint8_t val)
{
	uint8_t *data = net_buf_simple_push(buf, 1);

	*data = val;
   2bdf6:	f802 1c01 	strb.w	r1, [r2, #-1]
}
   2bdfa:	4770      	bx	lr

0002bdfc <net_buf_simple_push_be24>:
	buf->data -= len;
   2bdfc:	6803      	ldr	r3, [r0, #0]
   2bdfe:	1eda      	subs	r2, r3, #3
   2be00:	6002      	str	r2, [r0, #0]
	buf->len += len;
   2be02:	8882      	ldrh	r2, [r0, #4]
   2be04:	3203      	adds	r2, #3
   2be06:	8082      	strh	r2, [r0, #4]
	dst[0] = val >> 16;
   2be08:	0c0a      	lsrs	r2, r1, #16
   2be0a:	f803 2c03 	strb.w	r2, [r3, #-3]
	dst[0] = val >> 8;
   2be0e:	f3c1 2207 	ubfx	r2, r1, #8, #8
   2be12:	f803 2c02 	strb.w	r2, [r3, #-2]
	dst[1] = val;
   2be16:	f803 1c01 	strb.w	r1, [r3, #-1]
void net_buf_simple_push_be24(struct net_buf_simple *buf, uint32_t val)
{
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be24(val, net_buf_simple_push(buf, 3));
}
   2be1a:	4770      	bx	lr

0002be1c <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   2be1c:	8882      	ldrh	r2, [r0, #4]
   2be1e:	1a52      	subs	r2, r2, r1
{
   2be20:	4603      	mov	r3, r0
	buf->len -= len;
   2be22:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   2be24:	6800      	ldr	r0, [r0, #0]
   2be26:	4408      	add	r0, r1
   2be28:	6018      	str	r0, [r3, #0]
}
   2be2a:	4770      	bx	lr

0002be2c <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   2be2c:	4603      	mov	r3, r0
	void *data = buf->data;
   2be2e:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   2be30:	889a      	ldrh	r2, [r3, #4]
   2be32:	1a52      	subs	r2, r2, r1
	buf->data += len;
   2be34:	4401      	add	r1, r0
	buf->len -= len;
   2be36:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   2be38:	6019      	str	r1, [r3, #0]

	return data;
}
   2be3a:	4770      	bx	lr

0002be3c <net_buf_simple_pull_u8>:

uint8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
   2be3c:	b510      	push	{r4, lr}
	uint8_t val;

	val = buf->data[0];
   2be3e:	6803      	ldr	r3, [r0, #0]
   2be40:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
   2be42:	2101      	movs	r1, #1
   2be44:	f7ff ffea 	bl	2be1c <net_buf_simple_pull>

	return val;
}
   2be48:	4620      	mov	r0, r4
   2be4a:	bd10      	pop	{r4, pc}

0002be4c <net_buf_simple_pull_le16>:

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   2be4c:	b510      	push	{r4, lr}
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   2be4e:	6803      	ldr	r3, [r0, #0]
   2be50:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   2be52:	2102      	movs	r1, #2
   2be54:	f7ff ffe2 	bl	2be1c <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   2be58:	4620      	mov	r0, r4
   2be5a:	bd10      	pop	{r4, pc}

0002be5c <net_buf_simple_pull_be16>:

uint16_t net_buf_simple_pull_be16(struct net_buf_simple *buf)
{
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   2be5c:	6803      	ldr	r3, [r0, #0]
{
   2be5e:	b510      	push	{r4, lr}
   2be60:	881c      	ldrh	r4, [r3, #0]
   2be62:	ba64      	rev16	r4, r4
   2be64:	b2a4      	uxth	r4, r4
	net_buf_simple_pull(buf, sizeof(val));
   2be66:	2102      	movs	r1, #2
   2be68:	f7ff ffd8 	bl	2be1c <net_buf_simple_pull>

	return sys_be16_to_cpu(val);
}
   2be6c:	4620      	mov	r0, r4
   2be6e:	bd10      	pop	{r4, pc}

0002be70 <net_buf_simple_pull_be32>:

	return sys_le32_to_cpu(val);
}

uint32_t net_buf_simple_pull_be32(struct net_buf_simple *buf)
{
   2be70:	b510      	push	{r4, lr}
   2be72:	6803      	ldr	r3, [r0, #0]
   2be74:	681c      	ldr	r4, [r3, #0]
	uint32_t val;

	val = UNALIGNED_GET((uint32_t *)buf->data);
	net_buf_simple_pull(buf, sizeof(val));
   2be76:	2104      	movs	r1, #4
   2be78:	ba24      	rev	r4, r4
   2be7a:	f7ff ffcf 	bl	2be1c <net_buf_simple_pull>

	return sys_be32_to_cpu(val);
}
   2be7e:	4620      	mov	r0, r4
   2be80:	bd10      	pop	{r4, pc}

0002be82 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   2be82:	6802      	ldr	r2, [r0, #0]
   2be84:	6880      	ldr	r0, [r0, #8]
}
   2be86:	1a10      	subs	r0, r2, r0
   2be88:	4770      	bx	lr

0002be8a <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   2be8a:	8883      	ldrh	r3, [r0, #4]
   2be8c:	88c2      	ldrh	r2, [r0, #6]
   2be8e:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   2be90:	6803      	ldr	r3, [r0, #0]
   2be92:	6880      	ldr	r0, [r0, #8]
   2be94:	1a18      	subs	r0, r3, r0
}
   2be96:	1a10      	subs	r0, r2, r0
   2be98:	4770      	bx	lr

0002be9a <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   2be9a:	6903      	ldr	r3, [r0, #16]
   2be9c:	b2c9      	uxtb	r1, r1
   2be9e:	220c      	movs	r2, #12
   2bea0:	fb01 3302 	mla	r3, r1, r2, r3
   2bea4:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
   2bea6:	f000 0007 	and.w	r0, r0, #7
   2beaa:	4770      	bx	lr

0002beac <set_on_state>:
	__asm__ volatile(
   2beac:	f04f 0320 	mov.w	r3, #32
   2beb0:	f3ef 8211 	mrs	r2, BASEPRI
   2beb4:	f383 8812 	msr	BASEPRI_MAX, r3
   2beb8:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   2bebc:	6803      	ldr	r3, [r0, #0]
   2bebe:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   2bec2:	f043 0302 	orr.w	r3, r3, #2
   2bec6:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   2bec8:	f382 8811 	msr	BASEPRI, r2
   2becc:	f3bf 8f6f 	isb	sy
}
   2bed0:	4770      	bx	lr

0002bed2 <stop>:
{
   2bed2:	4603      	mov	r3, r0
   2bed4:	b570      	push	{r4, r5, r6, lr}
	struct nrf_clock_control_data *data = dev->data;
   2bed6:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
   2bed8:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   2beda:	f04f 0420 	mov.w	r4, #32
   2bede:	f3ef 8611 	mrs	r6, BASEPRI
   2bee2:	f384 8812 	msr	BASEPRI_MAX, r4
   2bee6:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2beea:	250c      	movs	r5, #12
   2beec:	fb05 0401 	mla	r4, r5, r1, r0
   2bef0:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   2bef2:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   2bef6:	d001      	beq.n	2befc <stop+0x2a>
   2bef8:	42a2      	cmp	r2, r4
   2befa:	d111      	bne.n	2bf20 <stop+0x4e>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   2befc:	fb05 0001 	mla	r0, r5, r1, r0
   2bf00:	2201      	movs	r2, #1
   2bf02:	6402      	str	r2, [r0, #64]	; 0x40
	int err = 0;
   2bf04:	2000      	movs	r0, #0
	__asm__ volatile(
   2bf06:	f386 8811 	msr	BASEPRI, r6
   2bf0a:	f3bf 8f6f 	isb	sy
	if (err < 0) {
   2bf0e:	b930      	cbnz	r0, 2bf1e <stop+0x4c>
	get_sub_config(dev, type)->stop();
   2bf10:	685b      	ldr	r3, [r3, #4]
   2bf12:	220c      	movs	r2, #12
   2bf14:	fb02 3101 	mla	r1, r2, r1, r3
   2bf18:	684b      	ldr	r3, [r1, #4]
   2bf1a:	4798      	blx	r3
	return 0;
   2bf1c:	2000      	movs	r0, #0
}
   2bf1e:	bd70      	pop	{r4, r5, r6, pc}
		err = -EPERM;
   2bf20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2bf24:	e7ef      	b.n	2bf06 <stop+0x34>

0002bf26 <api_stop>:
	return stop(dev, subsys, CTX_API);
   2bf26:	2280      	movs	r2, #128	; 0x80
   2bf28:	f7ff bfd3 	b.w	2bed2 <stop>

0002bf2c <async_start>:
{
   2bf2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2bf2e:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   2bf30:	6904      	ldr	r4, [r0, #16]
{
   2bf32:	4605      	mov	r5, r0
   2bf34:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   2bf36:	f04f 0020 	mov.w	r0, #32
   2bf3a:	f3ef 8c11 	mrs	ip, BASEPRI
   2bf3e:	f380 8812 	msr	BASEPRI_MAX, r0
   2bf42:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2bf46:	260c      	movs	r6, #12
   2bf48:	fb06 4601 	mla	r6, r6, r1, r4
   2bf4c:	6c30      	ldr	r0, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   2bf4e:	f000 0e07 	and.w	lr, r0, #7
   2bf52:	f1be 0f01 	cmp.w	lr, #1
   2bf56:	d110      	bne.n	2bf7a <async_start+0x4e>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   2bf58:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
   2bf5a:	2600      	movs	r6, #0
	__asm__ volatile(
   2bf5c:	f38c 8811 	msr	BASEPRI, ip
   2bf60:	f3bf 8f6f 	isb	sy
	if (err < 0) {
   2bf64:	b93e      	cbnz	r6, 2bf76 <async_start+0x4a>
	subdata->cb = cb;
   2bf66:	200c      	movs	r0, #12
   2bf68:	4341      	muls	r1, r0
   2bf6a:	440c      	add	r4, r1
	subdata->user_data = user_data;
   2bf6c:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   2bf70:	686b      	ldr	r3, [r5, #4]
   2bf72:	585b      	ldr	r3, [r3, r1]
   2bf74:	4798      	blx	r3
}
   2bf76:	4630      	mov	r0, r6
   2bf78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   2bf7a:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
		err = -EALREADY;
   2bf7e:	4287      	cmp	r7, r0
   2bf80:	bf14      	ite	ne
   2bf82:	f04f 36ff 	movne.w	r6, #4294967295	; 0xffffffff
   2bf86:	f06f 0677 	mvneq.w	r6, #119	; 0x77
   2bf8a:	e7e7      	b.n	2bf5c <async_start+0x30>

0002bf8c <api_start>:
{
   2bf8c:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   2bf8e:	2480      	movs	r4, #128	; 0x80
   2bf90:	9400      	str	r4, [sp, #0]
   2bf92:	f7ff ffcb 	bl	2bf2c <async_start>
}
   2bf96:	b002      	add	sp, #8
   2bf98:	bd10      	pop	{r4, pc}

0002bf9a <onoff_started_callback>:
	return &data->mgr[type];
   2bf9a:	6900      	ldr	r0, [r0, #16]
{
   2bf9c:	b410      	push	{r4}
	return &data->mgr[type];
   2bf9e:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   2bfa0:	241c      	movs	r4, #28
   2bfa2:	fb03 0004 	mla	r0, r3, r4, r0
   2bfa6:	2100      	movs	r1, #0
}
   2bfa8:	bc10      	pop	{r4}
	notify(mgr, 0);
   2bfaa:	4710      	bx	r2

0002bfac <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   2bfac:	2000      	movs	r0, #0
   2bfae:	f7f6 bc7b 	b.w	228a8 <nrfx_clock_stop>

0002bfb2 <blocking_start_callback>:
{
   2bfb2:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   2bfb4:	f7f7 bfce 	b.w	23f54 <z_impl_k_sem_give>

0002bfb8 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2bfb8:	6843      	ldr	r3, [r0, #4]
   2bfba:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   2bfbc:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   2bfc0:	600b      	str	r3, [r1, #0]
}
   2bfc2:	2000      	movs	r0, #0
   2bfc4:	4770      	bx	lr

0002bfc6 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2bfc6:	6843      	ldr	r3, [r0, #4]
   2bfc8:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   2bfca:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   2bfce:	4042      	eors	r2, r0
   2bfd0:	400a      	ands	r2, r1
   2bfd2:	4042      	eors	r2, r0
    p_reg->OUT = value;
   2bfd4:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   2bfd8:	2000      	movs	r0, #0
   2bfda:	4770      	bx	lr

0002bfdc <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2bfdc:	6843      	ldr	r3, [r0, #4]
   2bfde:	685b      	ldr	r3, [r3, #4]
}
   2bfe0:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
   2bfe2:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   2bfe6:	4770      	bx	lr

0002bfe8 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2bfe8:	6843      	ldr	r3, [r0, #4]
   2bfea:	685b      	ldr	r3, [r3, #4]
}
   2bfec:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   2bfee:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   2bff2:	4770      	bx	lr

0002bff4 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2bff4:	6843      	ldr	r3, [r0, #4]
   2bff6:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   2bff8:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
   2bffc:	404b      	eors	r3, r1
    p_reg->OUT = value;
   2bffe:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
   2c002:	2000      	movs	r0, #0
   2c004:	4770      	bx	lr

0002c006 <gpio_nrfx_manage_callback>:
	return port->data;
   2c006:	6903      	ldr	r3, [r0, #16]
	return list->head;
   2c008:	6858      	ldr	r0, [r3, #4]
{
   2c00a:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
   2c00c:	b158      	cbz	r0, 2c026 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2c00e:	2400      	movs	r4, #0
   2c010:	4281      	cmp	r1, r0
   2c012:	d112      	bne.n	2c03a <gpio_nrfx_manage_callback+0x34>
	return node->next;
   2c014:	6808      	ldr	r0, [r1, #0]
	return list->tail;
   2c016:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
   2c018:	b954      	cbnz	r4, 2c030 <gpio_nrfx_manage_callback+0x2a>
   2c01a:	428d      	cmp	r5, r1
	list->head = node;
   2c01c:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   2c01e:	d100      	bne.n	2c022 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   2c020:	6098      	str	r0, [r3, #8]
	parent->next = child;
   2c022:	2000      	movs	r0, #0
   2c024:	6008      	str	r0, [r1, #0]
	if (set) {
   2c026:	b96a      	cbnz	r2, 2c044 <gpio_nrfx_manage_callback+0x3e>
	return 0;
   2c028:	2000      	movs	r0, #0
}
   2c02a:	bd30      	pop	{r4, r5, pc}
   2c02c:	4628      	mov	r0, r5
   2c02e:	e7ef      	b.n	2c010 <gpio_nrfx_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
   2c030:	428d      	cmp	r5, r1
	parent->next = child;
   2c032:	6020      	str	r0, [r4, #0]
	list->tail = node;
   2c034:	bf08      	it	eq
   2c036:	609c      	streq	r4, [r3, #8]
}
   2c038:	e7f3      	b.n	2c022 <gpio_nrfx_manage_callback+0x1c>
	return node->next;
   2c03a:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2c03c:	4604      	mov	r4, r0
   2c03e:	2d00      	cmp	r5, #0
   2c040:	d1f4      	bne.n	2c02c <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   2c042:	b13a      	cbz	r2, 2c054 <gpio_nrfx_manage_callback+0x4e>
Z_GENLIST_PREPEND(slist, snode)
   2c044:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
   2c046:	685a      	ldr	r2, [r3, #4]
   2c048:	600a      	str	r2, [r1, #0]
	list->head = node;
   2c04a:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   2c04c:	2800      	cmp	r0, #0
   2c04e:	d1eb      	bne.n	2c028 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   2c050:	6099      	str	r1, [r3, #8]
}
   2c052:	e7ea      	b.n	2c02a <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   2c054:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   2c058:	e7e7      	b.n	2c02a <gpio_nrfx_manage_callback+0x24>

0002c05a <pin_interrupt_configure>:
		return -ENOTSUP;
   2c05a:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
}
   2c05e:	bf14      	ite	ne
   2c060:	f06f 0085 	mvnne.w	r0, #133	; 0x85
   2c064:	2000      	moveq	r0, #0
   2c066:	4770      	bx	lr

0002c068 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   2c068:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   2c06a:	ab0a      	add	r3, sp, #40	; 0x28
   2c06c:	9305      	str	r3, [sp, #20]
	z_impl_z_log_msg2_runtime_vcreate(domain_id, source, level, data, dlen, fmt, ap);
   2c06e:	9302      	str	r3, [sp, #8]
   2c070:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2c072:	9301      	str	r3, [sp, #4]
   2c074:	2300      	movs	r3, #0
   2c076:	9300      	str	r3, [sp, #0]
   2c078:	4618      	mov	r0, r3
   2c07a:	f7d7 f915 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   2c07e:	b007      	add	sp, #28
   2c080:	f85d fb04 	ldr.w	pc, [sp], #4

0002c084 <k_sem_take.constprop.0.isra.0>:
	return z_impl_k_sem_take(sem, timeout);
   2c084:	f7f7 bf8c 	b.w	23fa0 <z_impl_k_sem_take>

0002c088 <i2c_write>:
{
   2c088:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.len = num_bytes;
   2c08a:	e9cd 1201 	strd	r1, r2, [sp, #4]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2c08e:	2202      	movs	r2, #2
   2c090:	f88d 200c 	strb.w	r2, [sp, #12]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
   2c094:	6882      	ldr	r2, [r0, #8]
   2c096:	a901      	add	r1, sp, #4
   2c098:	6894      	ldr	r4, [r2, #8]
   2c09a:	2201      	movs	r2, #1
   2c09c:	47a0      	blx	r4
}
   2c09e:	b004      	add	sp, #16
   2c0a0:	bd10      	pop	{r4, pc}

0002c0a2 <i2c_reg_write_word_be>:
{
   2c0a2:	b507      	push	{r0, r1, r2, lr}
	uint8_t tx_buf[3] = { reg_addr, value >> 8, value & 0xff };
   2c0a4:	f88d 2004 	strb.w	r2, [sp, #4]
   2c0a8:	0a1a      	lsrs	r2, r3, #8
   2c0aa:	f88d 2005 	strb.w	r2, [sp, #5]
   2c0ae:	f88d 3006 	strb.w	r3, [sp, #6]
	return i2c_write(dev, tx_buf, 3, dev_addr);
   2c0b2:	2203      	movs	r2, #3
   2c0b4:	460b      	mov	r3, r1
   2c0b6:	a901      	add	r1, sp, #4
   2c0b8:	f7ff ffe6 	bl	2c088 <i2c_write>
}
   2c0bc:	b003      	add	sp, #12
   2c0be:	f85d fb04 	ldr.w	pc, [sp], #4

0002c0c2 <port_write>:
{
   2c0c2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2c0c6:	4605      	mov	r5, r0
   2c0c8:	4689      	mov	r9, r1
   2c0ca:	4614      	mov	r4, r2
   2c0cc:	4698      	mov	r8, r3
	if (k_is_in_isr()) {
   2c0ce:	f000 fcc6 	bl	2ca5e <k_is_in_isr>
   2c0d2:	bb08      	cbnz	r0, 2c118 <port_write+0x56>
	const struct sx1509b_config *cfg = dev->config;
   2c0d4:	686f      	ldr	r7, [r5, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
   2c0d6:	692d      	ldr	r5, [r5, #16]
	k_sem_take(&drv_data->lock, K_FOREVER);
   2c0d8:	f105 0620 	add.w	r6, r5, #32
   2c0dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c0e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c0e4:	4630      	mov	r0, r6
   2c0e6:	f7ff ffcd 	bl	2c084 <k_sem_take.constprop.0.isra.0>
	uint16_t orig_out = *outp;
   2c0ea:	8b28      	ldrh	r0, [r5, #24]
	int rc = i2c_reg_write_word_be(drv_data->i2c_master, cfg->i2c_slave_addr,
   2c0ec:	8939      	ldrh	r1, [r7, #8]
	uint16_t out = ((orig_out & ~mask) | (value & mask)) ^ toggle;
   2c0ee:	4044      	eors	r4, r0
   2c0f0:	ea04 0409 	and.w	r4, r4, r9
   2c0f4:	ea84 0408 	eor.w	r4, r4, r8
   2c0f8:	4044      	eors	r4, r0
   2c0fa:	b2a4      	uxth	r4, r4
	int rc = i2c_reg_write_word_be(drv_data->i2c_master, cfg->i2c_slave_addr,
   2c0fc:	6868      	ldr	r0, [r5, #4]
   2c0fe:	4623      	mov	r3, r4
   2c100:	2210      	movs	r2, #16
   2c102:	f7ff ffce 	bl	2c0a2 <i2c_reg_write_word_be>
	if (rc == 0) {
   2c106:	4607      	mov	r7, r0
   2c108:	b900      	cbnz	r0, 2c10c <port_write+0x4a>
		*outp = out;
   2c10a:	832c      	strh	r4, [r5, #24]
	z_impl_k_sem_give(sem);
   2c10c:	4630      	mov	r0, r6
   2c10e:	f7f7 ff21 	bl	23f54 <z_impl_k_sem_give>
}
   2c112:	4638      	mov	r0, r7
   2c114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EWOULDBLOCK;
   2c118:	f06f 070a 	mvn.w	r7, #10
   2c11c:	e7f9      	b.n	2c112 <port_write+0x50>

0002c11e <port_toggle_bits>:
	return port_write(dev, 0, 0, pins);
   2c11e:	2200      	movs	r2, #0
{
   2c120:	460b      	mov	r3, r1
	return port_write(dev, 0, 0, pins);
   2c122:	4611      	mov	r1, r2
   2c124:	f7ff bfcd 	b.w	2c0c2 <port_write>

0002c128 <port_clear_bits>:
	return port_write(dev, pins, 0, 0);
   2c128:	2300      	movs	r3, #0
   2c12a:	461a      	mov	r2, r3
   2c12c:	f7ff bfc9 	b.w	2c0c2 <port_write>

0002c130 <port_set_bits>:
{
   2c130:	460a      	mov	r2, r1
	return port_write(dev, pins, pins, 0);
   2c132:	2300      	movs	r3, #0
   2c134:	f7ff bfc5 	b.w	2c0c2 <port_write>

0002c138 <port_set_masked>:
	return port_write(dev, mask, value, 0);
   2c138:	2300      	movs	r3, #0
   2c13a:	f7ff bfc2 	b.w	2c0c2 <port_write>

0002c13e <write_pin_state>:
{
   2c13e:	b530      	push	{r4, r5, lr}
   2c140:	b087      	sub	sp, #28
   2c142:	460c      	mov	r4, r1
	pin_buf.reg = SX1509B_REG_INPUT_DISABLE;
   2c144:	2100      	movs	r1, #0
   2c146:	f88d 1004 	strb.w	r1, [sp, #4]
	pin_buf.pins.input_disable = sys_cpu_to_be16(pins->input_disable);
   2c14a:	8811      	ldrh	r1, [r2, #0]
   2c14c:	ba49      	rev16	r1, r1
   2c14e:	f8ad 1005 	strh.w	r1, [sp, #5]
	pin_buf.pins.long_slew = sys_cpu_to_be16(pins->long_slew);
   2c152:	8851      	ldrh	r1, [r2, #2]
   2c154:	ba49      	rev16	r1, r1
   2c156:	f8ad 1007 	strh.w	r1, [sp, #7]
	pin_buf.pins.low_drive = sys_cpu_to_be16(pins->low_drive);
   2c15a:	8891      	ldrh	r1, [r2, #4]
   2c15c:	ba49      	rev16	r1, r1
   2c15e:	f8ad 1009 	strh.w	r1, [sp, #9]
	pin_buf.pins.pull_up = sys_cpu_to_be16(pins->pull_up);
   2c162:	88d1      	ldrh	r1, [r2, #6]
   2c164:	ba49      	rev16	r1, r1
   2c166:	f8ad 100b 	strh.w	r1, [sp, #11]
	pin_buf.pins.pull_down = sys_cpu_to_be16(pins->pull_down);
   2c16a:	8911      	ldrh	r1, [r2, #8]
   2c16c:	ba49      	rev16	r1, r1
   2c16e:	f8ad 100d 	strh.w	r1, [sp, #13]
	pin_buf.pins.open_drain = sys_cpu_to_be16(pins->open_drain);
   2c172:	8951      	ldrh	r1, [r2, #10]
   2c174:	ba49      	rev16	r1, r1
   2c176:	f8ad 100f 	strh.w	r1, [sp, #15]
	pin_buf.pins.polarity = sys_cpu_to_be16(pins->polarity);
   2c17a:	8991      	ldrh	r1, [r2, #12]
   2c17c:	ba49      	rev16	r1, r1
   2c17e:	f8ad 1011 	strh.w	r1, [sp, #17]
	pin_buf.pins.dir = sys_cpu_to_be16(pins->dir);
   2c182:	89d1      	ldrh	r1, [r2, #14]
   2c184:	8a12      	ldrh	r2, [r2, #16]
{
   2c186:	4605      	mov	r5, r0
	pin_buf.pins.dir = sys_cpu_to_be16(pins->dir);
   2c188:	ba49      	rev16	r1, r1
   2c18a:	f8ad 1013 	strh.w	r1, [sp, #19]
	pin_buf.pins.data = sys_cpu_to_be16(pins->data);
   2c18e:	ba51      	rev16	r1, r2
   2c190:	f8ad 1015 	strh.w	r1, [sp, #21]
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   2c194:	6860      	ldr	r0, [r4, #4]
   2c196:	8929      	ldrh	r1, [r5, #8]
	if (data_first) {
   2c198:	b163      	cbz	r3, 2c1b4 <write_pin_state+0x76>
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   2c19a:	4613      	mov	r3, r2
   2c19c:	2210      	movs	r2, #16
   2c19e:	f7ff ff80 	bl	2c0a2 <i2c_reg_write_word_be>
		if (rc == 0) {
   2c1a2:	b928      	cbnz	r0, 2c1b0 <write_pin_state+0x72>
			rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
   2c1a4:	892b      	ldrh	r3, [r5, #8]
   2c1a6:	6860      	ldr	r0, [r4, #4]
   2c1a8:	2211      	movs	r2, #17
   2c1aa:	a901      	add	r1, sp, #4
		rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
   2c1ac:	f7ff ff6c 	bl	2c088 <i2c_write>
}
   2c1b0:	b007      	add	sp, #28
   2c1b2:	bd30      	pop	{r4, r5, pc}
		rc = i2c_write(drv_data->i2c_master, &pin_buf.reg,
   2c1b4:	460b      	mov	r3, r1
   2c1b6:	2213      	movs	r2, #19
   2c1b8:	a901      	add	r1, sp, #4
   2c1ba:	e7f7      	b.n	2c1ac <write_pin_state+0x6e>

0002c1bc <sx1509b_config>:
{
   2c1bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sx1509b_config *cfg = dev->config;
   2c1c0:	f8d0 a004 	ldr.w	sl, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
   2c1c4:	6904      	ldr	r4, [r0, #16]
{
   2c1c6:	460d      	mov	r5, r1
   2c1c8:	4617      	mov	r7, r2
	if (k_is_in_isr()) {
   2c1ca:	f000 fc48 	bl	2ca5e <k_is_in_isr>
   2c1ce:	4683      	mov	fp, r0
   2c1d0:	2800      	cmp	r0, #0
   2c1d2:	f040 808c 	bne.w	2c2ee <sx1509b_config+0x132>
	if ((flags & GPIO_DS_ALT) != 0) {
   2c1d6:	f417 0fa0 	tst.w	r7, #5242880	; 0x500000
   2c1da:	f040 808b 	bne.w	2c2f4 <sx1509b_config+0x138>
	k_sem_take(&drv_data->lock, K_FOREVER);
   2c1de:	f104 0920 	add.w	r9, r4, #32
   2c1e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c1e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c1ea:	4648      	mov	r0, r9
   2c1ec:	f7ff ff4a 	bl	2c084 <k_sem_take.constprop.0.isra.0>
		drv_data->led_drv_enable &= ~BIT(pin);
   2c1f0:	2601      	movs	r6, #1
	if (drv_data->led_drv_enable & BIT(pin)) {
   2c1f2:	8b63      	ldrh	r3, [r4, #26]
		drv_data->led_drv_enable &= ~BIT(pin);
   2c1f4:	40ae      	lsls	r6, r5
   2c1f6:	b2b6      	uxth	r6, r6
	if (drv_data->led_drv_enable & BIT(pin)) {
   2c1f8:	fa23 f505 	lsr.w	r5, r3, r5
		drv_data->led_drv_enable &= ~BIT(pin);
   2c1fc:	ea6f 0806 	mvn.w	r8, r6
	if (drv_data->led_drv_enable & BIT(pin)) {
   2c200:	07e9      	lsls	r1, r5, #31
		drv_data->led_drv_enable &= ~BIT(pin);
   2c202:	fa1f f888 	uxth.w	r8, r8
	if (drv_data->led_drv_enable & BIT(pin)) {
   2c206:	d44f      	bmi.n	2c2a8 <sx1509b_config+0xec>
	pins->open_drain &= ~BIT(pin);
   2c208:	8a63      	ldrh	r3, [r4, #18]
   2c20a:	ea03 0208 	and.w	r2, r3, r8
   2c20e:	8262      	strh	r2, [r4, #18]
	if ((flags & GPIO_SINGLE_ENDED) != 0) {
   2c210:	07ba      	lsls	r2, r7, #30
   2c212:	d45c      	bmi.n	2c2ce <sx1509b_config+0x112>
		pins->pull_up |= BIT(pin);
   2c214:	89e3      	ldrh	r3, [r4, #14]
	if ((flags & GPIO_PULL_UP) != 0) {
   2c216:	06f8      	lsls	r0, r7, #27
		pins->pull_up |= BIT(pin);
   2c218:	bf4c      	ite	mi
   2c21a:	4333      	orrmi	r3, r6
		pins->pull_up &= ~BIT(pin);
   2c21c:	ea03 0308 	andpl.w	r3, r3, r8
   2c220:	81e3      	strh	r3, [r4, #14]
		pins->pull_down |= BIT(pin);
   2c222:	8a23      	ldrh	r3, [r4, #16]
	if ((flags & GPIO_PULL_DOWN) != 0) {
   2c224:	06b9      	lsls	r1, r7, #26
		pins->pull_down |= BIT(pin);
   2c226:	bf4c      	ite	mi
   2c228:	4333      	orrmi	r3, r6
		pins->pull_down &= ~BIT(pin);
   2c22a:	ea03 0308 	andpl.w	r3, r3, r8
   2c22e:	8223      	strh	r3, [r4, #16]
		pins->input_disable &= ~BIT(pin);
   2c230:	8923      	ldrh	r3, [r4, #8]
	if ((flags & GPIO_INPUT) != 0) {
   2c232:	05fa      	lsls	r2, r7, #23
		pins->input_disable &= ~BIT(pin);
   2c234:	bf4c      	ite	mi
   2c236:	ea08 0303 	andmi.w	r3, r8, r3
		pins->input_disable |= BIT(pin);
   2c23a:	4333      	orrpl	r3, r6
	if ((flags & GPIO_OUTPUT) != 0) {
   2c23c:	05bd      	lsls	r5, r7, #22
   2c23e:	8123      	strh	r3, [r4, #8]
		pins->dir &= ~BIT(pin);
   2c240:	8ae3      	ldrh	r3, [r4, #22]
	if ((flags & GPIO_OUTPUT) != 0) {
   2c242:	d54e      	bpl.n	2c2e2 <sx1509b_config+0x126>
		pins->dir &= ~BIT(pin);
   2c244:	ea08 0303 	and.w	r3, r8, r3
		if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
   2c248:	0578      	lsls	r0, r7, #21
		pins->dir &= ~BIT(pin);
   2c24a:	82e3      	strh	r3, [r4, #22]
		if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
   2c24c:	d544      	bpl.n	2c2d8 <sx1509b_config+0x11c>
			pins->data &= ~BIT(pin);
   2c24e:	8b23      	ldrh	r3, [r4, #24]
   2c250:	ea08 0303 	and.w	r3, r8, r3
			pins->data |= BIT(pin);
   2c254:	8323      	strh	r3, [r4, #24]
			data_first = true;
   2c256:	f04f 0b01 	mov.w	fp, #1
		debounce->debounce_enable |= BIT(pin);
   2c25a:	f8b4 301d 	ldrh.w	r3, [r4, #29]
	if ((flags & GPIO_INT_DEBOUNCE) != 0) {
   2c25e:	033a      	lsls	r2, r7, #12
		debounce->debounce_enable |= BIT(pin);
   2c260:	bf4c      	ite	mi
   2c262:	431e      	orrmi	r6, r3
		debounce->debounce_enable &= ~BIT(pin);
   2c264:	ea08 0603 	andpl.w	r6, r8, r3
   2c268:	f8a4 601d 	strh.w	r6, [r4, #29]
	rc = write_pin_state(cfg, drv_data, pins, data_first);
   2c26c:	465b      	mov	r3, fp
   2c26e:	f104 0208 	add.w	r2, r4, #8
   2c272:	4621      	mov	r1, r4
   2c274:	4650      	mov	r0, sl
   2c276:	f7ff ff62 	bl	2c13e <write_pin_state>
	if (rc == 0) {
   2c27a:	4605      	mov	r5, r0
   2c27c:	bb00      	cbnz	r0, 2c2c0 <sx1509b_config+0x104>
		debounce_buf.reg = SX1509B_REG_DEBOUNCE_CONFIG;
   2c27e:	2322      	movs	r3, #34	; 0x22
   2c280:	f88d 3004 	strb.w	r3, [sp, #4]
			= debounce->debounce_config;
   2c284:	7f23      	ldrb	r3, [r4, #28]
   2c286:	f88d 3005 	strb.w	r3, [sp, #5]
			= sys_cpu_to_be16(debounce->debounce_enable);
   2c28a:	f8b4 301d 	ldrh.w	r3, [r4, #29]
		rc = i2c_write(drv_data->i2c_master,
   2c28e:	6860      	ldr	r0, [r4, #4]
			= sys_cpu_to_be16(debounce->debounce_enable);
   2c290:	ba5b      	rev16	r3, r3
		rc = i2c_write(drv_data->i2c_master,
   2c292:	2204      	movs	r2, #4
			= sys_cpu_to_be16(debounce->debounce_enable);
   2c294:	f8ad 3006 	strh.w	r3, [sp, #6]
		rc = i2c_write(drv_data->i2c_master,
   2c298:	eb0d 0102 	add.w	r1, sp, r2
   2c29c:	f8ba 3008 	ldrh.w	r3, [sl, #8]
   2c2a0:	f7ff fef2 	bl	2c088 <i2c_write>
   2c2a4:	4605      	mov	r5, r0
   2c2a6:	e00b      	b.n	2c2c0 <sx1509b_config+0x104>
		drv_data->led_drv_enable &= ~BIT(pin);
   2c2a8:	ea03 0308 	and.w	r3, r3, r8
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   2c2ac:	f8ba 1008 	ldrh.w	r1, [sl, #8]
   2c2b0:	6860      	ldr	r0, [r4, #4]
		drv_data->led_drv_enable &= ~BIT(pin);
   2c2b2:	8363      	strh	r3, [r4, #26]
		rc = i2c_reg_write_word_be(drv_data->i2c_master,
   2c2b4:	2220      	movs	r2, #32
   2c2b6:	f7ff fef4 	bl	2c0a2 <i2c_reg_write_word_be>
		if (rc) {
   2c2ba:	4605      	mov	r5, r0
   2c2bc:	2800      	cmp	r0, #0
   2c2be:	d0a3      	beq.n	2c208 <sx1509b_config+0x4c>
   2c2c0:	4648      	mov	r0, r9
   2c2c2:	f7f7 fe47 	bl	23f54 <z_impl_k_sem_give>
}
   2c2c6:	4628      	mov	r0, r5
   2c2c8:	b003      	add	sp, #12
   2c2ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((flags & GPIO_LINE_OPEN_DRAIN) != 0) {
   2c2ce:	077d      	lsls	r5, r7, #29
   2c2d0:	d50a      	bpl.n	2c2e8 <sx1509b_config+0x12c>
			pins->open_drain |= BIT(pin);
   2c2d2:	4333      	orrs	r3, r6
   2c2d4:	8263      	strh	r3, [r4, #18]
   2c2d6:	e79d      	b.n	2c214 <sx1509b_config+0x58>
		} else if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
   2c2d8:	0539      	lsls	r1, r7, #20
   2c2da:	d5be      	bpl.n	2c25a <sx1509b_config+0x9e>
			pins->data |= BIT(pin);
   2c2dc:	8b23      	ldrh	r3, [r4, #24]
   2c2de:	4333      	orrs	r3, r6
   2c2e0:	e7b8      	b.n	2c254 <sx1509b_config+0x98>
		pins->dir |= BIT(pin);
   2c2e2:	4333      	orrs	r3, r6
   2c2e4:	82e3      	strh	r3, [r4, #22]
   2c2e6:	e7b8      	b.n	2c25a <sx1509b_config+0x9e>
			rc = -ENOTSUP;
   2c2e8:	f06f 0585 	mvn.w	r5, #133	; 0x85
   2c2ec:	e7e8      	b.n	2c2c0 <sx1509b_config+0x104>
		return -EWOULDBLOCK;
   2c2ee:	f06f 050a 	mvn.w	r5, #10
   2c2f2:	e7e8      	b.n	2c2c6 <sx1509b_config+0x10a>
		return -ENOTSUP;
   2c2f4:	f06f 0585 	mvn.w	r5, #133	; 0x85
   2c2f8:	e7e5      	b.n	2c2c6 <sx1509b_config+0x10a>

0002c2fa <port_get>:
{
   2c2fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c2fe:	b088      	sub	sp, #32
	const struct sx1509b_config *cfg = dev->config;
   2c300:	f8d0 8004 	ldr.w	r8, [r0, #4]
	struct sx1509b_drv_data *drv_data = dev->data;
   2c304:	6907      	ldr	r7, [r0, #16]
{
   2c306:	460d      	mov	r5, r1
	if (k_is_in_isr()) {
   2c308:	f000 fba9 	bl	2ca5e <k_is_in_isr>
   2c30c:	4604      	mov	r4, r0
   2c30e:	bb78      	cbnz	r0, 2c370 <port_get+0x76>
	k_sem_take(&drv_data->lock, K_FOREVER);
   2c310:	f107 0620 	add.w	r6, r7, #32
   2c314:	4630      	mov	r0, r6
   2c316:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c31a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c31e:	f7ff feb1 	bl	2c084 <k_sem_take.constprop.0.isra.0>
	msg[0].buf = (uint8_t *)write_buf;
   2c322:	f10d 0205 	add.w	r2, sp, #5
   2c326:	9202      	str	r2, [sp, #8]
	msg[0].len = num_write;
   2c328:	2201      	movs	r2, #1
	rc = i2c_write_read(drv_data->i2c_master, cfg->i2c_slave_addr,
   2c32a:	6878      	ldr	r0, [r7, #4]
   2c32c:	9203      	str	r2, [sp, #12]
	uint8_t cmd = SX1509B_REG_DATA;
   2c32e:	2310      	movs	r3, #16
	msg[1].buf = (uint8_t *)read_buf;
   2c330:	f10d 0206 	add.w	r2, sp, #6
   2c334:	f88d 3005 	strb.w	r3, [sp, #5]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   2c338:	2107      	movs	r1, #7
	rc = i2c_write_read(drv_data->i2c_master, cfg->i2c_slave_addr,
   2c33a:	f8b8 3008 	ldrh.w	r3, [r8, #8]
	msg[1].buf = (uint8_t *)read_buf;
   2c33e:	9205      	str	r2, [sp, #20]
	msg[1].len = num_read;
   2c340:	2202      	movs	r2, #2
	msg[0].flags = I2C_MSG_WRITE;
   2c342:	f88d 4010 	strb.w	r4, [sp, #16]
	msg[1].len = num_read;
   2c346:	9206      	str	r2, [sp, #24]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   2c348:	f88d 101c 	strb.w	r1, [sp, #28]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
   2c34c:	6881      	ldr	r1, [r0, #8]
   2c34e:	688c      	ldr	r4, [r1, #8]
   2c350:	a902      	add	r1, sp, #8
   2c352:	47a0      	blx	r4
	if (rc != 0) {
   2c354:	4604      	mov	r4, r0
   2c356:	b920      	cbnz	r0, 2c362 <port_get+0x68>
	*value = sys_be16_to_cpu(pin_data);
   2c358:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   2c35c:	ba5b      	rev16	r3, r3
   2c35e:	b29b      	uxth	r3, r3
   2c360:	602b      	str	r3, [r5, #0]
   2c362:	4630      	mov	r0, r6
   2c364:	f7f7 fdf6 	bl	23f54 <z_impl_k_sem_give>
}
   2c368:	4620      	mov	r0, r4
   2c36a:	b008      	add	sp, #32
   2c36c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EWOULDBLOCK;
   2c370:	f06f 040a 	mvn.w	r4, #10
   2c374:	e7f8      	b.n	2c368 <port_get+0x6e>

0002c376 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   2c376:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   2c378:	ab0a      	add	r3, sp, #40	; 0x28
   2c37a:	9305      	str	r3, [sp, #20]
   2c37c:	9302      	str	r3, [sp, #8]
   2c37e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2c380:	9301      	str	r3, [sp, #4]
   2c382:	2300      	movs	r3, #0
   2c384:	9300      	str	r3, [sp, #0]
   2c386:	2201      	movs	r2, #1
   2c388:	4618      	mov	r0, r3
   2c38a:	f7d6 ff8d 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   2c38e:	b007      	add	sp, #28
   2c390:	f85d fb04 	ldr.w	pc, [sp], #4

0002c394 <twim_0_init>:
		      POST_KERNEL,					       \
		      CONFIG_I2C_INIT_PRIORITY,				       \
		      &i2c_nrfx_twim_driver_api)

#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
   2c394:	b510      	push	{r4, lr}
   2c396:	2200      	movs	r2, #0
   2c398:	4604      	mov	r4, r0
   2c39a:	2101      	movs	r1, #1
   2c39c:	2003      	movs	r0, #3
   2c39e:	f7d8 f98d 	bl	46bc <z_arm_irq_priority_set>
   2c3a2:	4620      	mov	r0, r4
   2c3a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2c3a8:	f7f4 be98 	b.w	210dc <init_twim>

0002c3ac <twim_1_init>:
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   2c3ac:	b510      	push	{r4, lr}
   2c3ae:	2200      	movs	r2, #0
   2c3b0:	4604      	mov	r4, r0
   2c3b2:	2101      	movs	r1, #1
   2c3b4:	2004      	movs	r0, #4
   2c3b6:	f7d8 f981 	bl	46bc <z_arm_irq_priority_set>
   2c3ba:	4620      	mov	r0, r4
   2c3bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2c3c0:	f7f4 be8c 	b.w	210dc <init_twim>

0002c3c4 <z_impl_hwinfo_get_device_id>:
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
   2c3c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
NRF_STATIC_INLINE uint32_t nrf_ficr_deviceid_get(NRF_FICR_Type const * p_reg, uint32_t reg_id)
{
#if defined(FICR_INFO_DEVICEID_DEVICEID_Msk)
    return p_reg->INFO.DEVICEID[reg_id];
#else
    return p_reg->DEVICEID[reg_id];
   2c3c6:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
   2c3ca:	2908      	cmp	r1, #8
   2c3cc:	6e66      	ldr	r6, [r4, #100]	; 0x64
   2c3ce:	6e65      	ldr	r5, [r4, #100]	; 0x64
   2c3d0:	6e62      	ldr	r2, [r4, #100]	; 0x64
   2c3d2:	6e63      	ldr	r3, [r4, #100]	; 0x64
	struct nrf_uid dev_id;

	dev_id.id[0] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 1));
   2c3d4:	ea4f 2515 	mov.w	r5, r5, lsr #8
   2c3d8:	ea4f 6303 	mov.w	r3, r3, lsl #24
   2c3dc:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
   2c3e0:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
   2c3e4:	ea4f 2202 	mov.w	r2, r2, lsl #8
   2c3e8:	ea43 0305 	orr.w	r3, r3, r5
   2c3ec:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
   2c3f0:	ea43 0302 	orr.w	r3, r3, r2
   2c3f4:	9300      	str	r3, [sp, #0]
   2c3f6:	6e26      	ldr	r6, [r4, #96]	; 0x60
   2c3f8:	6e25      	ldr	r5, [r4, #96]	; 0x60
   2c3fa:	6e22      	ldr	r2, [r4, #96]	; 0x60
   2c3fc:	6e23      	ldr	r3, [r4, #96]	; 0x60
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
   2c3fe:	ea4f 2415 	mov.w	r4, r5, lsr #8
   2c402:	ea4f 6303 	mov.w	r3, r3, lsl #24
   2c406:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
   2c40a:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
   2c40e:	ea43 0304 	orr.w	r3, r3, r4
   2c412:	ea4f 2402 	mov.w	r4, r2, lsl #8
   2c416:	bf28      	it	cs
   2c418:	2108      	movcs	r1, #8
   2c41a:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
   2c41e:	4323      	orrs	r3, r4

	if (length > sizeof(dev_id.id)) {
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   2c420:	460a      	mov	r2, r1
   2c422:	460c      	mov	r4, r1
   2c424:	4669      	mov	r1, sp
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
   2c426:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   2c428:	f7fb fa22 	bl	27870 <memcpy>

	return length;
}
   2c42c:	4620      	mov	r0, r4
   2c42e:	b002      	add	sp, #8
   2c430:	bd70      	pop	{r4, r5, r6, pc}

0002c432 <gpio_pin_set_dt>:
{
   2c432:	4603      	mov	r3, r0
   2c434:	460a      	mov	r2, r1
	return gpio_pin_set(spec->port, spec->pin, value);
   2c436:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   2c438:	7919      	ldrb	r1, [r3, #4]
   2c43a:	2301      	movs	r3, #1
   2c43c:	fa03 f101 	lsl.w	r1, r3, r1
   2c440:	6903      	ldr	r3, [r0, #16]
   2c442:	681b      	ldr	r3, [r3, #0]
   2c444:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   2c446:	bf18      	it	ne
   2c448:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   2c44c:	b112      	cbz	r2, 2c454 <gpio_pin_set_dt+0x22>
	return api->port_set_bits_raw(port, pins);
   2c44e:	6883      	ldr	r3, [r0, #8]
   2c450:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   2c452:	4718      	bx	r3
   2c454:	6883      	ldr	r3, [r0, #8]
   2c456:	691b      	ldr	r3, [r3, #16]
   2c458:	e7fb      	b.n	2c452 <gpio_pin_set_dt+0x20>

0002c45a <disable_sync>:
{
   2c45a:	b530      	push	{r4, r5, lr}
	int rc = onoff_sync_lock(&data->srv, &key);
   2c45c:	6904      	ldr	r4, [r0, #16]
	const struct driver_config *cfg = dev->config;
   2c45e:	6845      	ldr	r5, [r0, #4]
{
   2c460:	b085      	sub	sp, #20
	int rc = onoff_sync_lock(&data->srv, &key);
   2c462:	a903      	add	r1, sp, #12
   2c464:	4620      	mov	r0, r4
   2c466:	f7f8 ff93 	bl	25390 <onoff_sync_lock>
	if  ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   2c46a:	7d29      	ldrb	r1, [r5, #20]
   2c46c:	f011 0101 	ands.w	r1, r1, #1
	int rc = onoff_sync_lock(&data->srv, &key);
   2c470:	4603      	mov	r3, r0
	if  ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   2c472:	d114      	bne.n	2c49e <disable_sync+0x44>
	} else if (rc == 1) {
   2c474:	2801      	cmp	r0, #1
   2c476:	d10c      	bne.n	2c492 <disable_sync+0x38>
		rc = gpio_pin_set_dt(&cfg->enable, false);
   2c478:	f105 000c 	add.w	r0, r5, #12
   2c47c:	f7ff ffd9 	bl	2c432 <gpio_pin_set_dt>
   2c480:	4603      	mov	r3, r0
	return onoff_sync_finalize(&data->srv, key, NULL, rc, false);
   2c482:	2200      	movs	r2, #0
   2c484:	9903      	ldr	r1, [sp, #12]
   2c486:	9200      	str	r2, [sp, #0]
   2c488:	4620      	mov	r0, r4
   2c48a:	f7f8 ff8c 	bl	253a6 <onoff_sync_finalize>
}
   2c48e:	b005      	add	sp, #20
   2c490:	bd30      	pop	{r4, r5, pc}
		rc = -EINVAL;
   2c492:	2800      	cmp	r0, #0
   2c494:	bf14      	ite	ne
   2c496:	4603      	movne	r3, r0
   2c498:	f06f 0315 	mvneq.w	r3, #21
   2c49c:	e7f1      	b.n	2c482 <disable_sync+0x28>
		rc = 0;
   2c49e:	2300      	movs	r3, #0
   2c4a0:	e7ef      	b.n	2c482 <disable_sync+0x28>

0002c4a2 <enable_sync>:
{
   2c4a2:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	int rc = onoff_sync_lock(&data->srv, &key);
   2c4a4:	6905      	ldr	r5, [r0, #16]
	const struct driver_config *cfg = dev->config;
   2c4a6:	6846      	ldr	r6, [r0, #4]
{
   2c4a8:	460c      	mov	r4, r1
	int rc = onoff_sync_lock(&data->srv, &key);
   2c4aa:	4628      	mov	r0, r5
   2c4ac:	a903      	add	r1, sp, #12
   2c4ae:	f7f8 ff6f 	bl	25390 <onoff_sync_lock>
	if ((rc == 0)
   2c4b2:	4603      	mov	r3, r0
   2c4b4:	b940      	cbnz	r0, 2c4c8 <enable_sync+0x26>
	    && ((cfg->options & OPTION_ALWAYS_ON) == 0)) {
   2c4b6:	7d32      	ldrb	r2, [r6, #20]
   2c4b8:	07d2      	lsls	r2, r2, #31
   2c4ba:	d405      	bmi.n	2c4c8 <enable_sync+0x26>
		rc = gpio_pin_set_dt(&cfg->enable, true);
   2c4bc:	2101      	movs	r1, #1
   2c4be:	f106 000c 	add.w	r0, r6, #12
   2c4c2:	f7ff ffb6 	bl	2c432 <gpio_pin_set_dt>
   2c4c6:	4603      	mov	r3, r0
	return onoff_sync_finalize(&data->srv, key, cli, rc, true);
   2c4c8:	2201      	movs	r2, #1
   2c4ca:	9200      	str	r2, [sp, #0]
   2c4cc:	9903      	ldr	r1, [sp, #12]
   2c4ce:	4622      	mov	r2, r4
   2c4d0:	4628      	mov	r0, r5
   2c4d2:	f7f8 ff68 	bl	253a6 <onoff_sync_finalize>
}
   2c4d6:	b004      	add	sp, #16
   2c4d8:	bd70      	pop	{r4, r5, r6, pc}

0002c4da <disable_onoff>:
	return onoff_release(&data->mgr);
   2c4da:	6900      	ldr	r0, [r0, #16]
   2c4dc:	3004      	adds	r0, #4
   2c4de:	f7f8 bf32 	b.w	25346 <onoff_release>

0002c4e2 <enable_onoff>:
	return onoff_request(&data->mgr, cli);
   2c4e2:	6900      	ldr	r0, [r0, #16]
   2c4e4:	3004      	adds	r0, #4
   2c4e6:	f7f8 bee5 	b.w	252b4 <onoff_request>

0002c4ea <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   2c4ea:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   2c4ec:	ab0a      	add	r3, sp, #40	; 0x28
   2c4ee:	9305      	str	r3, [sp, #20]
   2c4f0:	9302      	str	r3, [sp, #8]
   2c4f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2c4f4:	9301      	str	r3, [sp, #4]
   2c4f6:	2300      	movs	r3, #0
   2c4f8:	9300      	str	r3, [sp, #0]
   2c4fa:	4618      	mov	r0, r3
   2c4fc:	f7d6 fed4 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   2c500:	b007      	add	sp, #28
   2c502:	f85d fb04 	ldr.w	pc, [sp], #4

0002c506 <onoff_worker>:
{
   2c506:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (data->task == WORK_TASK_ENABLE) {
   2c50a:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
	const struct driver_config *cfg = data->dev->config;
   2c50e:	f850 3c20 	ldr.w	r3, [r0, #-32]
	onoff_notify_fn notify = data->notify;
   2c512:	6b07      	ldr	r7, [r0, #48]	; 0x30
	const struct driver_config *cfg = data->dev->config;
   2c514:	685d      	ldr	r5, [r3, #4]
	if (data->task == WORK_TASK_ENABLE) {
   2c516:	2901      	cmp	r1, #1
{
   2c518:	4604      	mov	r4, r0
	struct driver_data_onoff *data
   2c51a:	f1a0 0620 	sub.w	r6, r0, #32
	if (data->task == WORK_TASK_ENABLE) {
   2c51e:	d10f      	bne.n	2c540 <onoff_worker+0x3a>
		rc = gpio_pin_set_dt(&cfg->enable, true);
   2c520:	f105 000c 	add.w	r0, r5, #12
   2c524:	f7ff ff85 	bl	2c432 <gpio_pin_set_dt>
		delay_us = cfg->startup_delay_us;
   2c528:	686a      	ldr	r2, [r5, #4]
		rc = gpio_pin_set_dt(&cfg->enable, true);
   2c52a:	4603      	mov	r3, r0
	data->notify = NULL;
   2c52c:	2100      	movs	r1, #0
   2c52e:	6321      	str	r1, [r4, #48]	; 0x30
	data->task = WORK_TASK_UNDEFINED;
   2c530:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
	finalize_transition(data, notify, delay_us, rc);
   2c534:	4630      	mov	r0, r6
   2c536:	4639      	mov	r1, r7
}
   2c538:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
   2c53c:	f7f5 b808 	b.w	21550 <finalize_transition>
	} else if (data->task == WORK_TASK_DISABLE) {
   2c540:	2902      	cmp	r1, #2
   2c542:	d107      	bne.n	2c554 <onoff_worker+0x4e>
		rc = gpio_pin_set_dt(&cfg->enable, false);
   2c544:	2100      	movs	r1, #0
   2c546:	f105 000c 	add.w	r0, r5, #12
   2c54a:	f7ff ff72 	bl	2c432 <gpio_pin_set_dt>
		delay_us = cfg->off_on_delay_us;
   2c54e:	68aa      	ldr	r2, [r5, #8]
		rc = gpio_pin_set_dt(&cfg->enable, false);
   2c550:	4603      	mov	r3, r0
		delay_us = cfg->off_on_delay_us;
   2c552:	e7eb      	b.n	2c52c <onoff_worker+0x26>
	int rc = 0;
   2c554:	2300      	movs	r3, #0
	uint32_t delay_us = 0;
   2c556:	461a      	mov	r2, r3
   2c558:	e7e8      	b.n	2c52c <onoff_worker+0x26>

0002c55a <stop>:
{
   2c55a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct driver_config *cfg = data->dev->config;
   2c55e:	f850 3c04 	ldr.w	r3, [r0, #-4]
{
   2c562:	4604      	mov	r4, r0
	struct driver_data_onoff *data =
   2c564:	1f06      	subs	r6, r0, #4
	const struct driver_config *cfg = data->dev->config;
   2c566:	6858      	ldr	r0, [r3, #4]
{
   2c568:	460d      	mov	r5, r1
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   2c56a:	7d01      	ldrb	r1, [r0, #20]
   2c56c:	f011 0101 	ands.w	r1, r1, #1
   2c570:	d113      	bne.n	2c59a <stop+0x40>
	uint32_t delay_us = cfg->off_on_delay_us;
   2c572:	6887      	ldr	r7, [r0, #8]
	rc = gpio_pin_set_dt(&cfg->enable, false);
   2c574:	300c      	adds	r0, #12
   2c576:	f7ff ff5c 	bl	2c432 <gpio_pin_set_dt>
	if (rc == -EWOULDBLOCK) {
   2c57a:	f110 0f0b 	cmn.w	r0, #11
	rc = gpio_pin_set_dt(&cfg->enable, false);
   2c57e:	4603      	mov	r3, r0
	if (rc == -EWOULDBLOCK) {
   2c580:	d10d      	bne.n	2c59e <stop+0x44>
		data->task = WORK_TASK_DISABLE;
   2c582:	2302      	movs	r3, #2
   2c584:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		data->notify = notify;
   2c588:	64e5      	str	r5, [r4, #76]	; 0x4c
		k_work_schedule(&data->dwork, K_NO_WAIT);
   2c58a:	f104 001c 	add.w	r0, r4, #28
   2c58e:	2200      	movs	r2, #0
}
   2c590:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		k_work_schedule(&data->dwork, K_NO_WAIT);
   2c594:	2300      	movs	r3, #0
   2c596:	f7f7 beb1 	b.w	242fc <k_work_schedule>
	int rc = 0;
   2c59a:	2300      	movs	r3, #0
		delay_us = 0;
   2c59c:	461f      	mov	r7, r3
	finalize_transition(data, notify, delay_us, rc);
   2c59e:	463a      	mov	r2, r7
   2c5a0:	4629      	mov	r1, r5
   2c5a2:	4630      	mov	r0, r6
}
   2c5a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
   2c5a8:	f7f4 bfd2 	b.w	21550 <finalize_transition>

0002c5ac <start>:
{
   2c5ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct driver_config *cfg = data->dev->config;
   2c5b0:	f850 3c04 	ldr.w	r3, [r0, #-4]
{
   2c5b4:	4604      	mov	r4, r0
	struct driver_data_onoff *data =
   2c5b6:	1f07      	subs	r7, r0, #4
	const struct driver_config *cfg = data->dev->config;
   2c5b8:	6858      	ldr	r0, [r3, #4]
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   2c5ba:	7d03      	ldrb	r3, [r0, #20]
   2c5bc:	07db      	lsls	r3, r3, #31
{
   2c5be:	460d      	mov	r5, r1
	if ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   2c5c0:	d414      	bmi.n	2c5ec <start+0x40>
	uint32_t delay_us = cfg->startup_delay_us;
   2c5c2:	6846      	ldr	r6, [r0, #4]
	rc = gpio_pin_set_dt(&cfg->enable, true);
   2c5c4:	2101      	movs	r1, #1
   2c5c6:	300c      	adds	r0, #12
   2c5c8:	f7ff ff33 	bl	2c432 <gpio_pin_set_dt>
	if (rc == -EWOULDBLOCK) {
   2c5cc:	f110 0f0b 	cmn.w	r0, #11
	rc = gpio_pin_set_dt(&cfg->enable, true);
   2c5d0:	4603      	mov	r3, r0
	if (rc == -EWOULDBLOCK) {
   2c5d2:	d10d      	bne.n	2c5f0 <start+0x44>
		data->task = WORK_TASK_ENABLE;
   2c5d4:	2301      	movs	r3, #1
   2c5d6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
		data->notify = notify;
   2c5da:	64e5      	str	r5, [r4, #76]	; 0x4c
		k_work_schedule(&data->dwork, K_NO_WAIT);
   2c5dc:	f104 001c 	add.w	r0, r4, #28
   2c5e0:	2200      	movs	r2, #0
}
   2c5e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		k_work_schedule(&data->dwork, K_NO_WAIT);
   2c5e6:	2300      	movs	r3, #0
   2c5e8:	f7f7 be88 	b.w	242fc <k_work_schedule>
	int rc = 0;
   2c5ec:	2300      	movs	r3, #0
		delay_us = 0;
   2c5ee:	461e      	mov	r6, r3
	finalize_transition(data, notify, delay_us, rc);
   2c5f0:	4632      	mov	r2, r6
   2c5f2:	4629      	mov	r1, r5
   2c5f4:	4638      	mov	r0, r7
}
   2c5f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	finalize_transition(data, notify, delay_us, rc);
   2c5fa:	f7f4 bfa9 	b.w	21550 <finalize_transition>

0002c5fe <erase_op>:
{
   2c5fe:	b570      	push	{r4, r5, r6, lr}
   2c600:	4604      	mov	r4, r0
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2c602:	f000 f93b 	bl	2c87c <nrfx_nvmc_flash_page_size_get>
	if (e_ctx->enable_time_limit) {
   2c606:	7b23      	ldrb	r3, [r4, #12]
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2c608:	4605      	mov	r5, r0
	if (e_ctx->enable_time_limit) {
   2c60a:	b10b      	cbz	r3, 2c610 <erase_op+0x12>
		nrf_flash_sync_get_timestamp_begin();
   2c60c:	f7f5 f9c6 	bl	2199c <nrf_flash_sync_get_timestamp_begin>
{
   2c610:	2600      	movs	r6, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
   2c612:	6860      	ldr	r0, [r4, #4]
   2c614:	f7f6 fce4 	bl	22fe0 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
   2c618:	68a3      	ldr	r3, [r4, #8]
   2c61a:	1b5b      	subs	r3, r3, r5
   2c61c:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
   2c61e:	6863      	ldr	r3, [r4, #4]
   2c620:	442b      	add	r3, r5
   2c622:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
   2c624:	7b23      	ldrb	r3, [r4, #12]
		i++;
   2c626:	3601      	adds	r6, #1
		if (e_ctx->enable_time_limit) {
   2c628:	b93b      	cbnz	r3, 2c63a <erase_op+0x3c>
	} while (e_ctx->len > 0);
   2c62a:	68a3      	ldr	r3, [r4, #8]
   2c62c:	2b00      	cmp	r3, #0
   2c62e:	d1f0      	bne.n	2c612 <erase_op+0x14>
	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
   2c630:	68a0      	ldr	r0, [r4, #8]
}
   2c632:	3800      	subs	r0, #0
   2c634:	bf18      	it	ne
   2c636:	2001      	movne	r0, #1
   2c638:	bd70      	pop	{r4, r5, r6, pc}
			if (nrf_flash_sync_check_time_limit(i)) {
   2c63a:	4630      	mov	r0, r6
   2c63c:	f7d5 f8a8 	bl	1790 <nrf_flash_sync_check_time_limit>
   2c640:	2800      	cmp	r0, #0
   2c642:	d0f2      	beq.n	2c62a <erase_op+0x2c>
   2c644:	e7f4      	b.n	2c630 <erase_op+0x32>

0002c646 <is_regular_addr_valid>:
{
   2c646:	b538      	push	{r3, r4, r5, lr}
   2c648:	4605      	mov	r5, r0
   2c64a:	460c      	mov	r4, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
   2c64c:	f000 f910 	bl	2c870 <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
   2c650:	2d00      	cmp	r5, #0
   2c652:	db07      	blt.n	2c664 <is_regular_addr_valid+0x1e>
	return (addr >= boundary_start &&
   2c654:	42a8      	cmp	r0, r5
   2c656:	d905      	bls.n	2c664 <is_regular_addr_valid+0x1e>
			(len <= (boundary_start + boundary_size - addr)));
   2c658:	1b40      	subs	r0, r0, r5
			(addr < (boundary_start + boundary_size)) &&
   2c65a:	4284      	cmp	r4, r0
   2c65c:	bf8c      	ite	hi
   2c65e:	2000      	movhi	r0, #0
   2c660:	2001      	movls	r0, #1
}
   2c662:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
   2c664:	2000      	movs	r0, #0
   2c666:	e7fc      	b.n	2c662 <is_regular_addr_valid+0x1c>

0002c668 <nrf_flash_sync_is_required>:
	return ticker_is_initialized(0);
   2c668:	2000      	movs	r0, #0
   2c66a:	f7ed bc03 	b.w	19e74 <ticker_is_initialized>

0002c66e <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(const struct device *dev, off_t offs,
			       uint32_t index, struct flash_pages_info *info)
{
   2c66e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2c672:	461c      	mov	r4, r3
	const struct flash_driver_api *api = dev->api;
   2c674:	6883      	ldr	r3, [r0, #8]
	const struct flash_pages_layout *layout;
	size_t layout_size;
	uint32_t index_jmp;

	info->start_offset = 0;
   2c676:	f04f 0800 	mov.w	r8, #0
	info->index = 0U;

	api->page_layout(dev, &layout, &layout_size);
   2c67a:	691b      	ldr	r3, [r3, #16]
	info->start_offset = 0;
   2c67c:	f8c4 8000 	str.w	r8, [r4]
{
   2c680:	460d      	mov	r5, r1
   2c682:	4616      	mov	r6, r2
	info->index = 0U;
   2c684:	f8c4 8008 	str.w	r8, [r4, #8]
	api->page_layout(dev, &layout, &layout_size);
   2c688:	aa01      	add	r2, sp, #4
   2c68a:	4669      	mov	r1, sp
   2c68c:	4798      	blx	r3

	while (layout_size--) {
   2c68e:	e9dd 7c00 	ldrd	r7, ip, [sp]
   2c692:	4640      	mov	r0, r8
		info->size = layout->pages_size;
   2c694:	f107 0e04 	add.w	lr, r7, #4
	while (layout_size--) {
   2c698:	4560      	cmp	r0, ip
   2c69a:	d104      	bne.n	2c6a6 <flash_get_page_info+0x38>
		}

		layout++;
	}

	return -EINVAL; /* page at offs or idx doesn't exist */
   2c69c:	f06f 0015 	mvn.w	r0, #21
}
   2c6a0:	b003      	add	sp, #12
   2c6a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		info->size = layout->pages_size;
   2c6a6:	f85e 9030 	ldr.w	r9, [lr, r0, lsl #3]
			index_jmp = index - info->index;
   2c6aa:	68a1      	ldr	r1, [r4, #8]
			index_jmp = (offs - info->start_offset) / info->size;
   2c6ac:	6822      	ldr	r2, [r4, #0]
		info->size = layout->pages_size;
   2c6ae:	f8c4 9004 	str.w	r9, [r4, #4]
		if (offs == 0) {
   2c6b2:	b985      	cbnz	r5, 2c6d6 <flash_get_page_info+0x68>
			index_jmp = index - info->index;
   2c6b4:	1a73      	subs	r3, r6, r1
		index_jmp = MIN(index_jmp, layout->pages_count);
   2c6b6:	f857 8030 	ldr.w	r8, [r7, r0, lsl #3]
   2c6ba:	4543      	cmp	r3, r8
   2c6bc:	bf28      	it	cs
   2c6be:	4643      	movcs	r3, r8
		info->start_offset += (index_jmp * info->size);
   2c6c0:	fb03 2209 	mla	r2, r3, r9, r2
		info->index += index_jmp;
   2c6c4:	4419      	add	r1, r3
		if (index_jmp < layout->pages_count) {
   2c6c6:	4598      	cmp	r8, r3
		info->start_offset += (index_jmp * info->size);
   2c6c8:	6022      	str	r2, [r4, #0]
		info->index += index_jmp;
   2c6ca:	60a1      	str	r1, [r4, #8]
		if (index_jmp < layout->pages_count) {
   2c6cc:	f100 0001 	add.w	r0, r0, #1
   2c6d0:	d9e2      	bls.n	2c698 <flash_get_page_info+0x2a>
			return 0;
   2c6d2:	2000      	movs	r0, #0
   2c6d4:	e7e4      	b.n	2c6a0 <flash_get_page_info+0x32>
			index_jmp = (offs - info->start_offset) / info->size;
   2c6d6:	1aab      	subs	r3, r5, r2
   2c6d8:	fbb3 f3f9 	udiv	r3, r3, r9
   2c6dc:	e7eb      	b.n	2c6b6 <flash_get_page_info+0x48>

0002c6de <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(const struct device *dev, off_t offs,
				       struct flash_pages_info *info)
{
   2c6de:	4613      	mov	r3, r2
	return flash_get_page_info(dev, offs, 0U, info);
   2c6e0:	2200      	movs	r2, #0
   2c6e2:	f7ff bfc4 	b.w	2c66e <flash_get_page_info>

0002c6e6 <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
   2c6e6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
   2c6ea:	6883      	ldr	r3, [r0, #8]
{
   2c6ec:	b086      	sub	sp, #24
	api->page_layout(dev, &layout, &num_blocks);
   2c6ee:	691b      	ldr	r3, [r3, #16]
{
   2c6f0:	4688      	mov	r8, r1
   2c6f2:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
   2c6f4:	a901      	add	r1, sp, #4
   2c6f6:	aa02      	add	r2, sp, #8
   2c6f8:	4798      	blx	r3
	off_t off = 0;
   2c6fa:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
   2c6fc:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
   2c6fe:	4625      	mov	r5, r4
   2c700:	9b02      	ldr	r3, [sp, #8]
   2c702:	42ab      	cmp	r3, r5
   2c704:	d802      	bhi.n	2c70c <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
   2c706:	b006      	add	sp, #24
   2c708:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
   2c70c:	9f01      	ldr	r7, [sp, #4]
   2c70e:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
   2c712:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
   2c714:	687b      	ldr	r3, [r7, #4]
   2c716:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   2c718:	683a      	ldr	r2, [r7, #0]
   2c71a:	42b2      	cmp	r2, r6
   2c71c:	eb0a 0306 	add.w	r3, sl, r6
   2c720:	d802      	bhi.n	2c728 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
   2c722:	3501      	adds	r5, #1
   2c724:	469a      	mov	sl, r3
   2c726:	e7eb      	b.n	2c700 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
   2c728:	4649      	mov	r1, r9
   2c72a:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
   2c72c:	9403      	str	r4, [sp, #12]
			page_info.index = page;
   2c72e:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
   2c730:	47c0      	blx	r8
   2c732:	2800      	cmp	r0, #0
   2c734:	d0e7      	beq.n	2c706 <flash_page_foreach+0x20>
			off += page_info.size;
   2c736:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
   2c738:	3601      	adds	r6, #1
			off += page_info.size;
   2c73a:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
   2c73c:	e7ec      	b.n	2c718 <flash_page_foreach+0x32>

0002c73e <uarte_nrfx_config_get>:
	*cfg = data->uart_config;
   2c73e:	6902      	ldr	r2, [r0, #16]
{
   2c740:	460b      	mov	r3, r1
	*cfg = data->uart_config;
   2c742:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   2c746:	e883 0003 	stmia.w	r3, {r0, r1}
}
   2c74a:	2000      	movs	r0, #0
   2c74c:	4770      	bx	lr

0002c74e <uarte_nrfx_err_check>:
	return config->uarte_regs;
   2c74e:	6843      	ldr	r3, [r0, #4]
   2c750:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   2c752:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   2c756:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   2c75a:	4770      	bx	lr

0002c75c <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   2c75c:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = dev->data;
   2c75e:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   2c760:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2c762:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   2c766:	b148      	cbz	r0, 2c77c <uarte_nrfx_poll_in+0x20>
	*c = data->rx_data;
   2c768:	7c52      	ldrb	r2, [r2, #17]
   2c76a:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2c76c:	2000      	movs	r0, #0
   2c76e:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   2c772:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2c776:	2201      	movs	r2, #1
   2c778:	601a      	str	r2, [r3, #0]
	return 0;
   2c77a:	4770      	bx	lr
		return -1;
   2c77c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   2c780:	4770      	bx	lr

0002c782 <is_tx_ready.isra.0>:
	return config->uarte_regs;
   2c782:	6802      	ldr	r2, [r0, #0]
static bool is_tx_ready(const struct device *dev)
   2c784:	4603      	mov	r3, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2c786:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   2c78a:	b940      	cbnz	r0, 2c79e <is_tx_ready.isra.0+0x1c>
	bool ppi_endtx = config->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   2c78c:	685b      	ldr	r3, [r3, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   2c78e:	079b      	lsls	r3, r3, #30
   2c790:	d406      	bmi.n	2c7a0 <is_tx_ready.isra.0+0x1e>
   2c792:	f8d2 0120 	ldr.w	r0, [r2, #288]	; 0x120
   2c796:	3800      	subs	r0, #0
   2c798:	bf18      	it	ne
   2c79a:	2001      	movne	r0, #1
   2c79c:	4770      	bx	lr
   2c79e:	2001      	movs	r0, #1
}
   2c7a0:	4770      	bx	lr

0002c7a2 <uarte_nrfx_isr_int>:
	const struct uarte_nrfx_config *config = dev->config;
   2c7a2:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   2c7a4:	6813      	ldr	r3, [r2, #0]
    return p_reg->INTENSET & mask;
   2c7a6:	f8d3 1304 	ldr.w	r1, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   2c7aa:	05c9      	lsls	r1, r1, #23
   2c7ac:	d518      	bpl.n	2c7e0 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2c7ae:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   2c7b2:	b1a9      	cbz	r1, 2c7e0 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   2c7b4:	f04f 0020 	mov.w	r0, #32
   2c7b8:	f3ef 8111 	mrs	r1, BASEPRI
   2c7bc:	f380 8812 	msr	BASEPRI_MAX, r0
   2c7c0:	f3bf 8f6f 	isb	sy
   2c7c4:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   2c7c8:	b130      	cbz	r0, 2c7d8 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2c7ca:	2000      	movs	r0, #0
   2c7cc:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
   2c7d0:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2c7d4:	2001      	movs	r0, #1
   2c7d6:	60d8      	str	r0, [r3, #12]
	__asm__ volatile(
   2c7d8:	f381 8811 	msr	BASEPRI, r1
   2c7dc:	f3bf 8f6f 	isb	sy
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   2c7e0:	6852      	ldr	r2, [r2, #4]
   2c7e2:	06d2      	lsls	r2, r2, #27
   2c7e4:	d515      	bpl.n	2c812 <uarte_nrfx_isr_int+0x70>
	__asm__ volatile(
   2c7e6:	f04f 0120 	mov.w	r1, #32
   2c7ea:	f3ef 8211 	mrs	r2, BASEPRI
   2c7ee:	f381 8812 	msr	BASEPRI_MAX, r1
   2c7f2:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2c7f6:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   2c7fa:	b111      	cbz	r1, 2c802 <uarte_nrfx_isr_int+0x60>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   2c7fc:	2100      	movs	r1, #0
   2c7fe:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   2c802:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   2c806:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   2c80a:	f382 8811 	msr	BASEPRI, r2
   2c80e:	f3bf 8f6f 	isb	sy
}
   2c812:	4770      	bx	lr

0002c814 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   2c814:	4770      	bx	lr

0002c816 <sys_clock_cycle_get_32>:
{
   2c816:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   2c818:	f7f5 fc8e 	bl	22138 <z_nrf_rtc_timer_read>
}
   2c81c:	bd08      	pop	{r3, pc}

0002c81e <nrf52_errata_108>:
            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   2c81e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2c822:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
   2c826:	1c42      	adds	r2, r0, #1
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   2c828:	bf04      	itt	eq
   2c82a:	f04f 4370 	moveq.w	r3, #4026531840	; 0xf0000000
   2c82e:	f893 0fe0 	ldrbeq.w	r0, [r3, #4064]	; 0xfe0
}
   2c832:	1f83      	subs	r3, r0, #6
   2c834:	4258      	negs	r0, r3
   2c836:	4158      	adcs	r0, r3
   2c838:	4770      	bx	lr

0002c83a <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   2c83a:	4700      	bx	r0

0002c83c <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   2c83c:	f000 bc8a 	b.w	2d154 <z_impl_k_busy_wait>

0002c840 <nrfx_clock_enable>:
{
   2c840:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   2c842:	2000      	movs	r0, #0
   2c844:	f7d7 ff2c 	bl	46a0 <arch_irq_is_enabled>
   2c848:	b918      	cbnz	r0, 2c852 <nrfx_clock_enable+0x12>
}
   2c84a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   2c84e:	f7d7 bf03 	b.w	4658 <arch_irq_enable>
   2c852:	bd08      	pop	{r3, pc}

0002c854 <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   2c854:	f000 001f 	and.w	r0, r0, #31
   2c858:	0080      	lsls	r0, r0, #2
   2c85a:	f100 40a0 	add.w	r0, r0, #1342177280	; 0x50000000
    uint32_t cnf = reg->PIN_CNF[pin_number];
   2c85e:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
    cnf &= ~to_update;
   2c862:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   2c866:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   2c86a:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
}
   2c86e:	4770      	bx	lr

0002c870 <nrfx_nvmc_flash_size_get>:
    return p_reg->CODEPAGESIZE;
   2c870:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2c874:	691a      	ldr	r2, [r3, #16]
    return p_reg->CODESIZE;
   2c876:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   2c878:	4350      	muls	r0, r2
   2c87a:	4770      	bx	lr

0002c87c <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   2c87c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2c880:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   2c882:	4770      	bx	lr

0002c884 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   2c884:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2c888:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   2c88a:	4770      	bx	lr

0002c88c <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   2c88c:	7b0a      	ldrb	r2, [r1, #12]
{
   2c88e:	4603      	mov	r3, r0
    switch (p_cb->xfer_desc.type)
   2c890:	2a03      	cmp	r2, #3
   2c892:	d829      	bhi.n	2c8e8 <xfer_completeness_check+0x5c>
   2c894:	e8df f002 	tbb	[pc, r2]
   2c898:	02192521 	.word	0x02192521
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2c89c:	688a      	ldr	r2, [r1, #8]
   2c89e:	0350      	lsls	r0, r2, #13
   2c8a0:	d504      	bpl.n	2c8ac <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
   2c8a2:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
   2c8a6:	6908      	ldr	r0, [r1, #16]
   2c8a8:	4290      	cmp	r0, r2
   2c8aa:	d107      	bne.n	2c8bc <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2c8ac:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   2c8ae:	0352      	lsls	r2, r2, #13
   2c8b0:	d41a      	bmi.n	2c8e8 <xfer_completeness_check+0x5c>
   2c8b2:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   2c8b6:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   2c8b8:	4291      	cmp	r1, r2
   2c8ba:	d015      	beq.n	2c8e8 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2c8bc:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2c8be:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2c8c0:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2c8c4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   2c8c8:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   2c8ca:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   2c8ce:	6908      	ldr	r0, [r1, #16]
   2c8d0:	4290      	cmp	r0, r2
   2c8d2:	d1f3      	bne.n	2c8bc <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
   2c8d4:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   2c8d8:	e7ed      	b.n	2c8b6 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
   2c8da:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   2c8de:	6909      	ldr	r1, [r1, #16]
   2c8e0:	e7ea      	b.n	2c8b8 <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
   2c8e2:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   2c8e6:	e7fa      	b.n	2c8de <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   2c8e8:	2001      	movs	r0, #1
}
   2c8ea:	4770      	bx	lr

0002c8ec <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   2c8ec:	f7f6 bef4 	b.w	236d8 <_DoInit>

0002c8f0 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   2c8f0:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   2c8f2:	f7ff fffb 	bl	2c8ec <SEGGER_RTT_Init>

	return 0;
}
   2c8f6:	2000      	movs	r0, #0
   2c8f8:	bd08      	pop	{r3, pc}

0002c8fa <z_device_state_init>:
}
   2c8fa:	4770      	bx	lr

0002c8fc <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   2c8fc:	b138      	cbz	r0, 2c90e <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   2c8fe:	68c3      	ldr	r3, [r0, #12]
   2c900:	8818      	ldrh	r0, [r3, #0]
   2c902:	f3c0 0008 	ubfx	r0, r0, #0, #9
   2c906:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   2c90a:	4258      	negs	r0, r3
   2c90c:	4158      	adcs	r0, r3
}
   2c90e:	4770      	bx	lr

0002c910 <z_log_msg2_runtime_create.constprop.0>:
static inline void z_log_msg2_runtime_create(uint8_t domain_id,
   2c910:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	va_start(ap, fmt);
   2c912:	ab0a      	add	r3, sp, #40	; 0x28
   2c914:	9305      	str	r3, [sp, #20]
   2c916:	9302      	str	r3, [sp, #8]
   2c918:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2c91a:	9301      	str	r3, [sp, #4]
   2c91c:	2300      	movs	r3, #0
   2c91e:	9300      	str	r3, [sp, #0]
   2c920:	2201      	movs	r2, #1
   2c922:	4618      	mov	r0, r3
   2c924:	f7d6 fcc0 	bl	32a8 <z_impl_z_log_msg2_runtime_vcreate>
}
   2c928:	b007      	add	sp, #28
   2c92a:	f85d fb04 	ldr.w	pc, [sp], #4

0002c92e <arch_system_halt>:
	__asm__ volatile(
   2c92e:	f04f 0220 	mov.w	r2, #32
   2c932:	f3ef 8311 	mrs	r3, BASEPRI
   2c936:	f382 8812 	msr	BASEPRI_MAX, r2
   2c93a:	f3bf 8f6f 	isb	sy
	for (;;) {
   2c93e:	e7fe      	b.n	2c93e <arch_system_halt+0x10>

0002c940 <k_heap_init>:
{
   2c940:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   2c942:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   2c946:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   2c94a:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   2c94c:	f7f8 bee3 	b.w	25716 <sys_heap_init>

0002c950 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   2c950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c954:	b085      	sub	sp, #20
   2c956:	4606      	mov	r6, r0
   2c958:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2c95a:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
{
   2c95e:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2c960:	f000 fbfc 	bl	2d15c <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   2c964:	f106 0a14 	add.w	sl, r6, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2c968:	4605      	mov	r5, r0
   2c96a:	460f      	mov	r7, r1
   2c96c:	f04f 0320 	mov.w	r3, #32
   2c970:	f3ef 8411 	mrs	r4, BASEPRI
   2c974:	f383 8812 	msr	BASEPRI_MAX, r3
   2c978:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2c97c:	f106 0b0c 	add.w	fp, r6, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   2c980:	464a      	mov	r2, r9
   2c982:	4641      	mov	r1, r8
   2c984:	4630      	mov	r0, r6
   2c986:	f7f8 fe5e 	bl	25646 <sys_heap_aligned_alloc>
   2c98a:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   2c98c:	f7f8 f9ba 	bl	24d04 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   2c990:	9b03      	ldr	r3, [sp, #12]
   2c992:	b13b      	cbz	r3, 2c9a4 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   2c994:	f384 8811 	msr	BASEPRI, r4
   2c998:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   2c99c:	4618      	mov	r0, r3
   2c99e:	b005      	add	sp, #20
   2c9a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   2c9a4:	1a28      	subs	r0, r5, r0
   2c9a6:	eb67 0101 	sbc.w	r1, r7, r1
   2c9aa:	2801      	cmp	r0, #1
   2c9ac:	f171 0200 	sbcs.w	r2, r1, #0
   2c9b0:	dbf0      	blt.n	2c994 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2c9b2:	e9cd 0100 	strd	r0, r1, [sp]
   2c9b6:	465a      	mov	r2, fp
   2c9b8:	4621      	mov	r1, r4
   2c9ba:	4650      	mov	r0, sl
   2c9bc:	f7f7 fe70 	bl	246a0 <z_pend_curr>
	__asm__ volatile(
   2c9c0:	f04f 0320 	mov.w	r3, #32
   2c9c4:	f3ef 8411 	mrs	r4, BASEPRI
   2c9c8:	f383 8812 	msr	BASEPRI_MAX, r3
   2c9cc:	f3bf 8f6f 	isb	sy
   2c9d0:	e7d6      	b.n	2c980 <k_heap_aligned_alloc+0x30>

0002c9d2 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   2c9d2:	b538      	push	{r3, r4, r5, lr}
   2c9d4:	4604      	mov	r4, r0
   2c9d6:	f04f 0320 	mov.w	r3, #32
   2c9da:	f3ef 8511 	mrs	r5, BASEPRI
   2c9de:	f383 8812 	msr	BASEPRI_MAX, r3
   2c9e2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   2c9e6:	f7f8 fdf6 	bl	255d6 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   2c9ea:	f104 000c 	add.w	r0, r4, #12
   2c9ee:	f000 fb2e 	bl	2d04e <z_unpend_all>
   2c9f2:	b130      	cbz	r0, 2ca02 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   2c9f4:	4629      	mov	r1, r5
   2c9f6:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   2c9fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   2c9fe:	f7f7 bcfd 	b.w	243fc <z_reschedule>
	__asm__ volatile(
   2ca02:	f385 8811 	msr	BASEPRI, r5
   2ca06:	f3bf 8f6f 	isb	sy
}
   2ca0a:	bd38      	pop	{r3, r4, r5, pc}

0002ca0c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   2ca0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ca0e:	4604      	mov	r4, r0
   2ca10:	460d      	mov	r5, r1
	__asm__ volatile(
   2ca12:	f04f 0320 	mov.w	r3, #32
   2ca16:	f3ef 8611 	mrs	r6, BASEPRI
   2ca1a:	f383 8812 	msr	BASEPRI_MAX, r3
   2ca1e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   2ca22:	6947      	ldr	r7, [r0, #20]
   2ca24:	b977      	cbnz	r7, 2ca44 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   2ca26:	f000 fafa 	bl	2d01e <z_unpend_first_thread>

		if (pending_thread != NULL) {
   2ca2a:	b158      	cbz	r0, 2ca44 <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   2ca2c:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   2ca2e:	6142      	str	r2, [r0, #20]
   2ca30:	67c7      	str	r7, [r0, #124]	; 0x7c
			z_ready_thread(pending_thread);
   2ca32:	f000 fa83 	bl	2cf3c <z_ready_thread>
			z_reschedule(&slab->lock, key);
   2ca36:	4631      	mov	r1, r6
   2ca38:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   2ca3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   2ca40:	f7f7 bcdc 	b.w	243fc <z_reschedule>
	**(char ***) mem = slab->free_list;
   2ca44:	682b      	ldr	r3, [r5, #0]
   2ca46:	6962      	ldr	r2, [r4, #20]
   2ca48:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   2ca4a:	682b      	ldr	r3, [r5, #0]
   2ca4c:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   2ca4e:	69a3      	ldr	r3, [r4, #24]
   2ca50:	3b01      	subs	r3, #1
   2ca52:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   2ca54:	f386 8811 	msr	BASEPRI, r6
   2ca58:	f3bf 8f6f 	isb	sy
}
   2ca5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002ca5e <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2ca5e:	f3ef 8005 	mrs	r0, IPSR
}
   2ca62:	3800      	subs	r0, #0
   2ca64:	bf18      	it	ne
   2ca66:	2001      	movne	r0, #1
   2ca68:	4770      	bx	lr

0002ca6a <z_impl_k_thread_name_set>:
}
   2ca6a:	f06f 0057 	mvn.w	r0, #87	; 0x57
   2ca6e:	4770      	bx	lr

0002ca70 <k_thread_name_get>:
}
   2ca70:	2000      	movs	r0, #0
   2ca72:	4770      	bx	lr

0002ca74 <z_impl_k_thread_start>:
	z_sched_start(thread);
   2ca74:	f7f7 bdb8 	b.w	245e8 <z_sched_start>

0002ca78 <z_pm_save_idle_exit>:
{
   2ca78:	b508      	push	{r3, lr}
	pm_system_resume();
   2ca7a:	f7d7 fb25 	bl	40c8 <pm_system_resume>
}
   2ca7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   2ca82:	f7ff bec7 	b.w	2c814 <sys_clock_idle_exit>

0002ca86 <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
   2ca86:	f990 300e 	ldrsb.w	r3, [r0, #14]
   2ca8a:	428b      	cmp	r3, r1
   2ca8c:	d001      	beq.n	2ca92 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
   2ca8e:	f7f7 be1b 	b.w	246c8 <z_set_prio>
}
   2ca92:	2000      	movs	r0, #0
   2ca94:	4770      	bx	lr

0002ca96 <z_impl_k_mutex_init>:
{
   2ca96:	4603      	mov	r3, r0
	mutex->owner = NULL;
   2ca98:	2000      	movs	r0, #0
	mutex->lock_count = 0U;
   2ca9a:	e9c3 0002 	strd	r0, r0, [r3, #8]
   2ca9e:	e9c3 3300 	strd	r3, r3, [r3]
}
   2caa2:	4770      	bx	lr

0002caa4 <queue_insert>:
{
   2caa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2caa8:	4699      	mov	r9, r3
   2caaa:	4604      	mov	r4, r0
   2caac:	f89d 3020 	ldrb.w	r3, [sp, #32]
   2cab0:	460d      	mov	r5, r1
   2cab2:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2cab4:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   2cab8:	f04f 0220 	mov.w	r2, #32
   2cabc:	f3ef 8711 	mrs	r7, BASEPRI
   2cac0:	f382 8812 	msr	BASEPRI_MAX, r2
   2cac4:	f3bf 8f6f 	isb	sy
	if (is_append) {
   2cac8:	b103      	cbz	r3, 2cacc <queue_insert+0x28>
	return list->tail;
   2caca:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   2cacc:	4630      	mov	r0, r6
   2cace:	f000 faa6 	bl	2d01e <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   2cad2:	b158      	cbz	r0, 2caec <queue_insert+0x48>
   2cad4:	2400      	movs	r4, #0
   2cad6:	67c4      	str	r4, [r0, #124]	; 0x7c
   2cad8:	f8c0 8014 	str.w	r8, [r0, #20]
	z_ready_thread(thread);
   2cadc:	f000 fa2e 	bl	2cf3c <z_ready_thread>
	z_reschedule(&queue->lock, key);
   2cae0:	4630      	mov	r0, r6
   2cae2:	4639      	mov	r1, r7
   2cae4:	f7f7 fc8a 	bl	243fc <z_reschedule>
	return 0;
   2cae8:	2000      	movs	r0, #0
   2caea:	e00c      	b.n	2cb06 <queue_insert+0x62>
	if (alloc) {
   2caec:	f1b9 0f00 	cmp.w	r9, #0
   2caf0:	d01b      	beq.n	2cb2a <queue_insert+0x86>
	return z_thread_aligned_alloc(0, size);
   2caf2:	2108      	movs	r1, #8
   2caf4:	f7f8 fa3a 	bl	24f6c <z_thread_aligned_alloc>
		if (anode == NULL) {
   2caf8:	b938      	cbnz	r0, 2cb0a <queue_insert+0x66>
	__asm__ volatile(
   2cafa:	f387 8811 	msr	BASEPRI, r7
   2cafe:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   2cb02:	f06f 000b 	mvn.w	r0, #11
}
   2cb06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   2cb0a:	2301      	movs	r3, #1
		anode->data = data;
   2cb0c:	f8c0 8004 	str.w	r8, [r0, #4]
   2cb10:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2cb12:	6803      	ldr	r3, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cb14:	f003 0203 	and.w	r2, r3, #3
Z_GENLIST_INSERT(sflist, sfnode)
   2cb18:	b95d      	cbnz	r5, 2cb32 <queue_insert+0x8e>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cb1a:	6823      	ldr	r3, [r4, #0]
   2cb1c:	4313      	orrs	r3, r2
   2cb1e:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2cb20:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   2cb22:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2cb24:	b973      	cbnz	r3, 2cb44 <queue_insert+0xa0>
	list->tail = node;
   2cb26:	6060      	str	r0, [r4, #4]
}
   2cb28:	e00c      	b.n	2cb44 <queue_insert+0xa0>
	node->next_and_flags = flags;
   2cb2a:	f8c8 9000 	str.w	r9, [r8]
}
   2cb2e:	4640      	mov	r0, r8
   2cb30:	e7ef      	b.n	2cb12 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2cb32:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   2cb34:	f033 0303 	bics.w	r3, r3, #3
   2cb38:	d110      	bne.n	2cb5c <queue_insert+0xb8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cb3a:	6002      	str	r2, [r0, #0]
	return list->tail;
   2cb3c:	6862      	ldr	r2, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   2cb3e:	b93a      	cbnz	r2, 2cb50 <queue_insert+0xac>
	list->head = node;
   2cb40:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   2cb44:	2104      	movs	r1, #4
   2cb46:	f104 0010 	add.w	r0, r4, #16
   2cb4a:	f000 fc99 	bl	2d480 <z_handle_obj_poll_events>
   2cb4e:	e7c7      	b.n	2cae0 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2cb50:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cb52:	f003 0303 	and.w	r3, r3, #3
   2cb56:	4303      	orrs	r3, r0
   2cb58:	6013      	str	r3, [r2, #0]
   2cb5a:	e7e4      	b.n	2cb26 <queue_insert+0x82>
   2cb5c:	4313      	orrs	r3, r2
   2cb5e:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2cb60:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cb62:	f003 0303 	and.w	r3, r3, #3
   2cb66:	4303      	orrs	r3, r0
   2cb68:	602b      	str	r3, [r5, #0]
}
   2cb6a:	e7eb      	b.n	2cb44 <queue_insert+0xa0>

0002cb6c <z_queue_node_peek>:
{
   2cb6c:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   2cb6e:	4604      	mov	r4, r0
   2cb70:	b130      	cbz	r0, 2cb80 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2cb72:	6802      	ldr	r2, [r0, #0]
   2cb74:	0793      	lsls	r3, r2, #30
   2cb76:	d003      	beq.n	2cb80 <z_queue_node_peek+0x14>
		ret = anode->data;
   2cb78:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   2cb7a:	b109      	cbz	r1, 2cb80 <z_queue_node_peek+0x14>
			k_free(anode);
   2cb7c:	f000 fc8e 	bl	2d49c <k_free>
}
   2cb80:	4620      	mov	r0, r4
   2cb82:	bd10      	pop	{r4, pc}

0002cb84 <z_impl_k_queue_init>:
	list->head = NULL;
   2cb84:	2300      	movs	r3, #0
	list->tail = NULL;
   2cb86:	e9c0 3300 	strd	r3, r3, [r0]
   2cb8a:	f100 0308 	add.w	r3, r0, #8
   2cb8e:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   2cb92:	f100 0310 	add.w	r3, r0, #16
   2cb96:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   2cb9a:	4770      	bx	lr

0002cb9c <z_impl_k_queue_cancel_wait>:
{
   2cb9c:	b570      	push	{r4, r5, r6, lr}
   2cb9e:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2cba0:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2cba4:	f04f 0320 	mov.w	r3, #32
   2cba8:	f3ef 8611 	mrs	r6, BASEPRI
   2cbac:	f383 8812 	msr	BASEPRI_MAX, r3
   2cbb0:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   2cbb4:	4628      	mov	r0, r5
   2cbb6:	f000 fa32 	bl	2d01e <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   2cbba:	b120      	cbz	r0, 2cbc6 <z_impl_k_queue_cancel_wait+0x2a>
   2cbbc:	2200      	movs	r2, #0
   2cbbe:	67c2      	str	r2, [r0, #124]	; 0x7c
	thread->base.swap_data = data;
   2cbc0:	6142      	str	r2, [r0, #20]
	z_ready_thread(thread);
   2cbc2:	f000 f9bb 	bl	2cf3c <z_ready_thread>
	z_handle_obj_poll_events(&queue->poll_events, state);
   2cbc6:	f104 0010 	add.w	r0, r4, #16
   2cbca:	2108      	movs	r1, #8
   2cbcc:	f000 fc58 	bl	2d480 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   2cbd0:	4631      	mov	r1, r6
   2cbd2:	4628      	mov	r0, r5
}
   2cbd4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   2cbd8:	f7f7 bc10 	b.w	243fc <z_reschedule>

0002cbdc <k_queue_append>:
{
   2cbdc:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   2cbde:	2301      	movs	r3, #1
   2cbe0:	9300      	str	r3, [sp, #0]
   2cbe2:	2300      	movs	r3, #0
{
   2cbe4:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   2cbe6:	4619      	mov	r1, r3
   2cbe8:	f7ff ff5c 	bl	2caa4 <queue_insert>
}
   2cbec:	b003      	add	sp, #12
   2cbee:	f85d fb04 	ldr.w	pc, [sp], #4

0002cbf2 <k_queue_prepend>:
{
   2cbf2:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, false);
   2cbf4:	2300      	movs	r3, #0
{
   2cbf6:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   2cbf8:	9300      	str	r3, [sp, #0]
   2cbfa:	4619      	mov	r1, r3
   2cbfc:	f7ff ff52 	bl	2caa4 <queue_insert>
}
   2cc00:	b003      	add	sp, #12
   2cc02:	f85d fb04 	ldr.w	pc, [sp], #4

0002cc06 <k_queue_append_list>:
{
   2cc06:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2cc0a:	4605      	mov	r5, r0
   2cc0c:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
   2cc0e:	460c      	mov	r4, r1
   2cc10:	b391      	cbz	r1, 2cc78 <k_queue_append_list+0x72>
   2cc12:	b38a      	cbz	r2, 2cc78 <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2cc14:	f100 0708 	add.w	r7, r0, #8
   2cc18:	f04f 0320 	mov.w	r3, #32
   2cc1c:	f3ef 8811 	mrs	r8, BASEPRI
   2cc20:	f383 8812 	msr	BASEPRI_MAX, r3
   2cc24:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
   2cc28:	4638      	mov	r0, r7
   2cc2a:	f000 f9f8 	bl	2d01e <z_unpend_first_thread>
   2cc2e:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
   2cc32:	b920      	cbnz	r0, 2cc3e <k_queue_append_list+0x38>
	return list->tail;
   2cc34:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   2cc36:	b9ca      	cbnz	r2, 2cc6c <k_queue_append_list+0x66>
	list->head = node;
   2cc38:	602c      	str	r4, [r5, #0]
	list->tail = node;
   2cc3a:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   2cc3c:	e00a      	b.n	2cc54 <k_queue_append_list+0x4e>
   2cc3e:	6144      	str	r4, [r0, #20]
   2cc40:	f8c0 907c 	str.w	r9, [r0, #124]	; 0x7c
	z_ready_thread(thread);
   2cc44:	f000 f97a 	bl	2cf3c <z_ready_thread>
		head = *(void **)head;
   2cc48:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   2cc4a:	4638      	mov	r0, r7
   2cc4c:	f000 f9e7 	bl	2d01e <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   2cc50:	2c00      	cmp	r4, #0
   2cc52:	d1ee      	bne.n	2cc32 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
   2cc54:	2104      	movs	r1, #4
   2cc56:	f105 0010 	add.w	r0, r5, #16
   2cc5a:	f000 fc11 	bl	2d480 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   2cc5e:	4638      	mov	r0, r7
   2cc60:	4641      	mov	r1, r8
   2cc62:	f7f7 fbcb 	bl	243fc <z_reschedule>
	return 0;
   2cc66:	2000      	movs	r0, #0
}
   2cc68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2cc6c:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2cc6e:	f003 0303 	and.w	r3, r3, #3
   2cc72:	431c      	orrs	r4, r3
   2cc74:	6014      	str	r4, [r2, #0]
}
   2cc76:	e7e0      	b.n	2cc3a <k_queue_append_list+0x34>
		return -EINVAL;
   2cc78:	f06f 0015 	mvn.w	r0, #21
   2cc7c:	e7f4      	b.n	2cc68 <k_queue_append_list+0x62>

0002cc7e <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   2cc7e:	b15a      	cbz	r2, 2cc98 <z_impl_k_sem_init+0x1a>
   2cc80:	428a      	cmp	r2, r1
   2cc82:	d309      	bcc.n	2cc98 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   2cc84:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   2cc88:	e9c0 1202 	strd	r1, r2, [r0, #8]
   2cc8c:	e9c0 0000 	strd	r0, r0, [r0]
   2cc90:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   2cc94:	2000      	movs	r0, #0
   2cc96:	4770      	bx	lr
		return -EINVAL;
   2cc98:	f06f 0015 	mvn.w	r0, #21
}
   2cc9c:	4770      	bx	lr

0002cc9e <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
   2cc9e:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   2cca0:	2301      	movs	r3, #1
   2cca2:	408b      	lsls	r3, r1
   2cca4:	ea22 0303 	bic.w	r3, r2, r3
   2cca8:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   2ccaa:	fa22 f001 	lsr.w	r0, r2, r1
}
   2ccae:	f000 0001 	and.w	r0, r0, #1
   2ccb2:	4770      	bx	lr

0002ccb4 <unschedule_locked>:
{
   2ccb4:	b538      	push	{r3, r4, r5, lr}
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   2ccb6:	2103      	movs	r1, #3
{
   2ccb8:	4605      	mov	r5, r0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   2ccba:	300c      	adds	r0, #12
   2ccbc:	f7ff ffef 	bl	2cc9e <flag_test_and_clear>
   2ccc0:	4604      	mov	r4, r0
   2ccc2:	b118      	cbz	r0, 2cccc <unschedule_locked+0x18>
		z_abort_timeout(&dwork->timeout);
   2ccc4:	f105 0010 	add.w	r0, r5, #16
   2ccc8:	f000 f9ee 	bl	2d0a8 <z_abort_timeout>
}
   2cccc:	4620      	mov	r0, r4
   2ccce:	bd38      	pop	{r3, r4, r5, pc}

0002ccd0 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   2ccd0:	b120      	cbz	r0, 2ccdc <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   2ccd2:	2200      	movs	r2, #0
   2ccd4:	4611      	mov	r1, r2
   2ccd6:	3088      	adds	r0, #136	; 0x88
   2ccd8:	f000 b9c9 	b.w	2d06e <z_sched_wake>
}
   2ccdc:	4770      	bx	lr

0002ccde <cancel_async_locked>:
	return (*flagp & BIT(bit)) != 0U;
   2ccde:	68c3      	ldr	r3, [r0, #12]
{
   2cce0:	b570      	push	{r4, r5, r6, lr}
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2cce2:	f3c3 0540 	ubfx	r5, r3, #1, #1
   2cce6:	079b      	lsls	r3, r3, #30
{
   2cce8:	4604      	mov	r4, r0
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2ccea:	d416      	bmi.n	2cd1a <cancel_async_locked+0x3c>
		queue_remove_locked(work->queue, work);
   2ccec:	6886      	ldr	r6, [r0, #8]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
   2ccee:	2102      	movs	r1, #2
   2ccf0:	300c      	adds	r0, #12
   2ccf2:	f7ff ffd4 	bl	2cc9e <flag_test_and_clear>
   2ccf6:	b180      	cbz	r0, 2cd1a <cancel_async_locked+0x3c>
	return list->head;
   2ccf8:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2ccfc:	b16a      	cbz	r2, 2cd1a <cancel_async_locked+0x3c>
   2ccfe:	4294      	cmp	r4, r2
   2cd00:	d11b      	bne.n	2cd3a <cancel_async_locked+0x5c>
	return node->next;
   2cd02:	6822      	ldr	r2, [r4, #0]
	return list->tail;
   2cd04:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
Z_GENLIST_REMOVE(slist, snode)
   2cd08:	b98d      	cbnz	r5, 2cd2e <cancel_async_locked+0x50>
   2cd0a:	428c      	cmp	r4, r1
	list->head = node;
   2cd0c:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
Z_GENLIST_REMOVE(slist, snode)
   2cd10:	d101      	bne.n	2cd16 <cancel_async_locked+0x38>
	list->tail = node;
   2cd12:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
	parent->next = child;
   2cd16:	2300      	movs	r3, #0
   2cd18:	6023      	str	r3, [r4, #0]
	return *flagp;
   2cd1a:	68e3      	ldr	r3, [r4, #12]
	if (ret != 0) {
   2cd1c:	f013 000f 	ands.w	r0, r3, #15
	*flagp |= BIT(bit);
   2cd20:	bf1e      	ittt	ne
   2cd22:	f043 0302 	orrne.w	r3, r3, #2
   2cd26:	60e3      	strne	r3, [r4, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
   2cd28:	f003 000f 	andne.w	r0, r3, #15
}
   2cd2c:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_REMOVE(slist, snode)
   2cd2e:	428c      	cmp	r4, r1
	parent->next = child;
   2cd30:	602a      	str	r2, [r5, #0]
	list->tail = node;
   2cd32:	bf08      	it	eq
   2cd34:	f8c6 5084 	streq.w	r5, [r6, #132]	; 0x84
}
   2cd38:	e7ed      	b.n	2cd16 <cancel_async_locked+0x38>
	return node->next;
   2cd3a:	4615      	mov	r5, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2cd3c:	6812      	ldr	r2, [r2, #0]
   2cd3e:	e7dd      	b.n	2ccfc <cancel_async_locked+0x1e>

0002cd40 <work_timeout>:
{
   2cd40:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2cd42:	4604      	mov	r4, r0
   2cd44:	f04f 0320 	mov.w	r3, #32
   2cd48:	f3ef 8511 	mrs	r5, BASEPRI
   2cd4c:	f383 8812 	msr	BASEPRI_MAX, r3
   2cd50:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   2cd54:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   2cd56:	f1a0 0610 	sub.w	r6, r0, #16
   2cd5a:	2103      	movs	r1, #3
   2cd5c:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   2cd5e:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   2cd60:	f7ff ff9d 	bl	2cc9e <flag_test_and_clear>
   2cd64:	b128      	cbz	r0, 2cd72 <work_timeout+0x32>
		queue = dw->queue;
   2cd66:	69a3      	ldr	r3, [r4, #24]
   2cd68:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   2cd6a:	a901      	add	r1, sp, #4
   2cd6c:	4630      	mov	r0, r6
   2cd6e:	f7f7 fa0d 	bl	2418c <submit_to_queue_locked>
	__asm__ volatile(
   2cd72:	f385 8811 	msr	BASEPRI, r5
   2cd76:	f3bf 8f6f 	isb	sy
}
   2cd7a:	b002      	add	sp, #8
   2cd7c:	bd70      	pop	{r4, r5, r6, pc}

0002cd7e <k_work_init>:
{
   2cd7e:	b538      	push	{r3, r4, r5, lr}
   2cd80:	4604      	mov	r4, r0
   2cd82:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2cd84:	2210      	movs	r2, #16
   2cd86:	2100      	movs	r1, #0
   2cd88:	f7fa fd7d 	bl	27886 <memset>
   2cd8c:	6065      	str	r5, [r4, #4]
}
   2cd8e:	bd38      	pop	{r3, r4, r5, pc}

0002cd90 <k_work_busy_get>:
	__asm__ volatile(
   2cd90:	f04f 0220 	mov.w	r2, #32
   2cd94:	f3ef 8311 	mrs	r3, BASEPRI
   2cd98:	f382 8812 	msr	BASEPRI_MAX, r2
   2cd9c:	f3bf 8f6f 	isb	sy
	return flags_get(&work->flags) & K_WORK_MASK;
   2cda0:	68c0      	ldr	r0, [r0, #12]
   2cda2:	f000 000f 	and.w	r0, r0, #15
	__asm__ volatile(
   2cda6:	f383 8811 	msr	BASEPRI, r3
   2cdaa:	f3bf 8f6f 	isb	sy
}
   2cdae:	4770      	bx	lr

0002cdb0 <k_work_submit_to_queue>:
{
   2cdb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2cdb2:	9001      	str	r0, [sp, #4]
   2cdb4:	4608      	mov	r0, r1
	__asm__ volatile(
   2cdb6:	f04f 0320 	mov.w	r3, #32
   2cdba:	f3ef 8511 	mrs	r5, BASEPRI
   2cdbe:	f383 8812 	msr	BASEPRI_MAX, r3
   2cdc2:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   2cdc6:	a901      	add	r1, sp, #4
   2cdc8:	f7f7 f9e0 	bl	2418c <submit_to_queue_locked>
   2cdcc:	4604      	mov	r4, r0
	__asm__ volatile(
   2cdce:	f385 8811 	msr	BASEPRI, r5
   2cdd2:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
   2cdd6:	2800      	cmp	r0, #0
   2cdd8:	dd04      	ble.n	2cde4 <k_work_submit_to_queue+0x34>
	return z_impl_k_is_preempt_thread();
   2cdda:	f7f7 fdbf 	bl	2495c <z_impl_k_is_preempt_thread>
   2cdde:	b108      	cbz	r0, 2cde4 <k_work_submit_to_queue+0x34>
	z_impl_k_yield();
   2cde0:	f7f7 fd14 	bl	2480c <z_impl_k_yield>
}
   2cde4:	4620      	mov	r0, r4
   2cde6:	b003      	add	sp, #12
   2cde8:	bd30      	pop	{r4, r5, pc}

0002cdea <k_work_init_delayable>:
{
   2cdea:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   2cdec:	2230      	movs	r2, #48	; 0x30
{
   2cdee:	4604      	mov	r4, r0
   2cdf0:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   2cdf2:	2100      	movs	r1, #0
   2cdf4:	f7fa fd47 	bl	27886 <memset>
   2cdf8:	f44f 7380 	mov.w	r3, #256	; 0x100
   2cdfc:	6065      	str	r5, [r4, #4]
   2cdfe:	60e3      	str	r3, [r4, #12]
}
   2ce00:	bd38      	pop	{r3, r4, r5, pc}

0002ce02 <k_work_delayable_busy_get>:
   2ce02:	f7ff bfc5 	b.w	2cd90 <k_work_busy_get>

0002ce06 <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   2ce06:	b538      	push	{r3, r4, r5, lr}
   2ce08:	4604      	mov	r4, r0
	__asm__ volatile(
   2ce0a:	f04f 0320 	mov.w	r3, #32
   2ce0e:	f3ef 8511 	mrs	r5, BASEPRI
   2ce12:	f383 8812 	msr	BASEPRI_MAX, r3
   2ce16:	f3bf 8f6f 	isb	sy
	(void)unschedule_locked(dwork);
   2ce1a:	f7ff ff4b 	bl	2ccb4 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   2ce1e:	4620      	mov	r0, r4
   2ce20:	f7ff ff5d 	bl	2ccde <cancel_async_locked>
	__asm__ volatile(
   2ce24:	f385 8811 	msr	BASEPRI, r5
   2ce28:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   2ce2c:	bd38      	pop	{r3, r4, r5, pc}

0002ce2e <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
   2ce2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ce30:	4604      	mov	r4, r0
   2ce32:	460d      	mov	r5, r1
	__asm__ volatile(
   2ce34:	f04f 0320 	mov.w	r3, #32
   2ce38:	f3ef 8711 	mrs	r7, BASEPRI
   2ce3c:	f383 8812 	msr	BASEPRI_MAX, r3
   2ce40:	f3bf 8f6f 	isb	sy
	return flags_get(&dwork->work.flags) & K_WORK_MASK;
   2ce44:	68c3      	ldr	r3, [r0, #12]
   2ce46:	f003 030f 	and.w	r3, r3, #15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
   2ce4a:	2b00      	cmp	r3, #0
   2ce4c:	bf14      	ite	ne
   2ce4e:	2601      	movne	r6, #1
   2ce50:	2600      	moveq	r6, #0
	bool need_wait = false;

	if (pending) {
   2ce52:	d009      	beq.n	2ce68 <k_work_cancel_delayable_sync+0x3a>
	(void)unschedule_locked(dwork);
   2ce54:	f7ff ff2e 	bl	2ccb4 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   2ce58:	4620      	mov	r0, r4
   2ce5a:	f7ff ff40 	bl	2ccde <cancel_async_locked>
		(void)cancel_delayable_async_locked(dwork);
		need_wait = cancel_sync_locked(&dwork->work, canceller);
   2ce5e:	4629      	mov	r1, r5
   2ce60:	4620      	mov	r0, r4
   2ce62:	f7f7 f975 	bl	24150 <cancel_sync_locked>
   2ce66:	4603      	mov	r3, r0
	__asm__ volatile(
   2ce68:	f387 8811 	msr	BASEPRI, r7
   2ce6c:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);

	if (need_wait) {
   2ce70:	b13b      	cbz	r3, 2ce82 <k_work_cancel_delayable_sync+0x54>
	return z_impl_k_sem_take(sem, timeout);
   2ce72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2ce76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2ce7a:	f105 0008 	add.w	r0, r5, #8
   2ce7e:	f7f7 f88f 	bl	23fa0 <z_impl_k_sem_take>
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
   2ce82:	4630      	mov	r0, r6
   2ce84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002ce86 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   2ce86:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   2ce8a:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   2ce8c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2ce8e:	2300      	movs	r3, #0
	node->prev = NULL;
   2ce90:	e9c0 3300 	strd	r3, r3, [r0]
}
   2ce94:	4770      	bx	lr

0002ce96 <unpend_thread_no_timeout>:
{
   2ce96:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   2ce98:	f7ff fff5 	bl	2ce86 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2ce9c:	7b43      	ldrb	r3, [r0, #13]
   2ce9e:	f023 0302 	bic.w	r3, r3, #2
   2cea2:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   2cea4:	2300      	movs	r3, #0
   2cea6:	6083      	str	r3, [r0, #8]
}
   2cea8:	bd08      	pop	{r3, pc}

0002ceaa <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
   2ceaa:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   2ceae:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
   2ceb2:	4283      	cmp	r3, r0
		return b2 - b1;
   2ceb4:	bf14      	ite	ne
   2ceb6:	1ac0      	subne	r0, r0, r3
	return 0;
   2ceb8:	2000      	moveq	r0, #0
}
   2ceba:	4770      	bx	lr

0002cebc <z_unpend_thread_no_timeout>:
{
   2cebc:	b508      	push	{r3, lr}
	__asm__ volatile(
   2cebe:	f04f 0320 	mov.w	r3, #32
   2cec2:	f3ef 8111 	mrs	r1, BASEPRI
   2cec6:	f383 8812 	msr	BASEPRI_MAX, r3
   2ceca:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   2cece:	f7ff ffe2 	bl	2ce96 <unpend_thread_no_timeout>
	__asm__ volatile(
   2ced2:	f381 8811 	msr	BASEPRI, r1
   2ced6:	f3bf 8f6f 	isb	sy
}
   2ceda:	bd08      	pop	{r3, pc}

0002cedc <z_unpend_thread>:
{
   2cedc:	b510      	push	{r4, lr}
	__asm__ volatile(
   2cede:	f04f 0320 	mov.w	r3, #32
   2cee2:	f3ef 8411 	mrs	r4, BASEPRI
   2cee6:	f383 8812 	msr	BASEPRI_MAX, r3
   2ceea:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   2ceee:	f7ff ffd2 	bl	2ce96 <unpend_thread_no_timeout>
	__asm__ volatile(
   2cef2:	f384 8811 	msr	BASEPRI, r4
   2cef6:	f3bf 8f6f 	isb	sy
}
   2cefa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2cefe:	3018      	adds	r0, #24
   2cf00:	f000 b8d2 	b.w	2d0a8 <z_abort_timeout>

0002cf04 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2cf04:	4603      	mov	r3, r0
   2cf06:	b920      	cbnz	r0, 2cf12 <z_reschedule_irqlock+0xe>
   2cf08:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   2cf0c:	b90a      	cbnz	r2, 2cf12 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   2cf0e:	f7d7 bc23 	b.w	4758 <arch_swap>
   2cf12:	f383 8811 	msr	BASEPRI, r3
   2cf16:	f3bf 8f6f 	isb	sy
}
   2cf1a:	4770      	bx	lr

0002cf1c <z_reschedule_unlocked>:
	__asm__ volatile(
   2cf1c:	f04f 0320 	mov.w	r3, #32
   2cf20:	f3ef 8011 	mrs	r0, BASEPRI
   2cf24:	f383 8812 	msr	BASEPRI_MAX, r3
   2cf28:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   2cf2c:	f7ff bfea 	b.w	2cf04 <z_reschedule_irqlock>

0002cf30 <z_priq_dumb_best>:
{
   2cf30:	4603      	mov	r3, r0
	return list->head == list;
   2cf32:	6800      	ldr	r0, [r0, #0]
}
   2cf34:	4283      	cmp	r3, r0
   2cf36:	bf08      	it	eq
   2cf38:	2000      	moveq	r0, #0
   2cf3a:	4770      	bx	lr

0002cf3c <z_ready_thread>:
{
   2cf3c:	b510      	push	{r4, lr}
   2cf3e:	f04f 0320 	mov.w	r3, #32
   2cf42:	f3ef 8411 	mrs	r4, BASEPRI
   2cf46:	f383 8812 	msr	BASEPRI_MAX, r3
   2cf4a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   2cf4e:	f7f7 fb15 	bl	2457c <ready_thread>
	__asm__ volatile(
   2cf52:	f384 8811 	msr	BASEPRI, r4
   2cf56:	f3bf 8f6f 	isb	sy
}
   2cf5a:	bd10      	pop	{r4, pc}

0002cf5c <z_thread_timeout>:
{
   2cf5c:	b510      	push	{r4, lr}
   2cf5e:	4601      	mov	r1, r0
	__asm__ volatile(
   2cf60:	f04f 0320 	mov.w	r3, #32
   2cf64:	f3ef 8411 	mrs	r4, BASEPRI
   2cf68:	f383 8812 	msr	BASEPRI_MAX, r3
   2cf6c:	f3bf 8f6f 	isb	sy
		if (!killed) {
   2cf70:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   2cf74:	f013 0f28 	tst.w	r3, #40	; 0x28
   2cf78:	d10d      	bne.n	2cf96 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   2cf7a:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   2cf7e:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   2cf80:	b10b      	cbz	r3, 2cf86 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   2cf82:	f7ff ff88 	bl	2ce96 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   2cf86:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   2cf8a:	f023 0314 	bic.w	r3, r3, #20
   2cf8e:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   2cf92:	f7f7 faf3 	bl	2457c <ready_thread>
	__asm__ volatile(
   2cf96:	f384 8811 	msr	BASEPRI, r4
   2cf9a:	f3bf 8f6f 	isb	sy
}
   2cf9e:	bd10      	pop	{r4, pc}

0002cfa0 <add_to_waitq_locked>:
{
   2cfa0:	b538      	push	{r3, r4, r5, lr}
   2cfa2:	4604      	mov	r4, r0
   2cfa4:	460d      	mov	r5, r1
	unready_thread(thread);
   2cfa6:	f7f7 fb3d 	bl	24624 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   2cfaa:	7b63      	ldrb	r3, [r4, #13]
   2cfac:	f043 0302 	orr.w	r3, r3, #2
   2cfb0:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   2cfb2:	b195      	cbz	r5, 2cfda <add_to_waitq_locked+0x3a>
   2cfb4:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   2cfb6:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2cfb8:	429d      	cmp	r5, r3
   2cfba:	d015      	beq.n	2cfe8 <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2cfbc:	b1a3      	cbz	r3, 2cfe8 <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
   2cfbe:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   2cfc2:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   2cfc6:	4291      	cmp	r1, r2
   2cfc8:	d008      	beq.n	2cfdc <add_to_waitq_locked+0x3c>
		return b2 - b1;
   2cfca:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   2cfcc:	2a00      	cmp	r2, #0
   2cfce:	dd05      	ble.n	2cfdc <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
   2cfd0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2cfd2:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   2cfd6:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2cfd8:	605c      	str	r4, [r3, #4]
}
   2cfda:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   2cfdc:	686a      	ldr	r2, [r5, #4]
   2cfde:	4293      	cmp	r3, r2
   2cfe0:	d002      	beq.n	2cfe8 <add_to_waitq_locked+0x48>
   2cfe2:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2cfe4:	2b00      	cmp	r3, #0
   2cfe6:	d1ec      	bne.n	2cfc2 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
   2cfe8:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   2cfea:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   2cfee:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2cff0:	606c      	str	r4, [r5, #4]
}
   2cff2:	e7f2      	b.n	2cfda <add_to_waitq_locked+0x3a>

0002cff4 <z_unpend1_no_timeout>:
{
   2cff4:	b510      	push	{r4, lr}
	__asm__ volatile(
   2cff6:	f04f 0320 	mov.w	r3, #32
   2cffa:	f3ef 8411 	mrs	r4, BASEPRI
   2cffe:	f383 8812 	msr	BASEPRI_MAX, r3
   2d002:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   2d006:	f7ff ff93 	bl	2cf30 <z_priq_dumb_best>
		if (thread != NULL) {
   2d00a:	4601      	mov	r1, r0
   2d00c:	b108      	cbz	r0, 2d012 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   2d00e:	f7ff ff42 	bl	2ce96 <unpend_thread_no_timeout>
	__asm__ volatile(
   2d012:	f384 8811 	msr	BASEPRI, r4
   2d016:	f3bf 8f6f 	isb	sy
}
   2d01a:	4608      	mov	r0, r1
   2d01c:	bd10      	pop	{r4, pc}

0002d01e <z_unpend_first_thread>:
{
   2d01e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2d020:	f04f 0320 	mov.w	r3, #32
   2d024:	f3ef 8511 	mrs	r5, BASEPRI
   2d028:	f383 8812 	msr	BASEPRI_MAX, r3
   2d02c:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   2d030:	f7ff ff7e 	bl	2cf30 <z_priq_dumb_best>
		if (thread != NULL) {
   2d034:	4604      	mov	r4, r0
   2d036:	b120      	cbz	r0, 2d042 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   2d038:	f7ff ff2d 	bl	2ce96 <unpend_thread_no_timeout>
   2d03c:	3018      	adds	r0, #24
   2d03e:	f000 f833 	bl	2d0a8 <z_abort_timeout>
	__asm__ volatile(
   2d042:	f385 8811 	msr	BASEPRI, r5
   2d046:	f3bf 8f6f 	isb	sy
}
   2d04a:	4620      	mov	r0, r4
   2d04c:	bd38      	pop	{r3, r4, r5, pc}

0002d04e <z_unpend_all>:
{
   2d04e:	b538      	push	{r3, r4, r5, lr}
   2d050:	4605      	mov	r5, r0
	int need_sched = 0;
   2d052:	2000      	movs	r0, #0
	return list->head == list;
   2d054:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d056:	42a5      	cmp	r5, r4
   2d058:	d000      	beq.n	2d05c <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   2d05a:	b904      	cbnz	r4, 2d05e <z_unpend_all+0x10>
}
   2d05c:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   2d05e:	4620      	mov	r0, r4
   2d060:	f7ff ff3c 	bl	2cedc <z_unpend_thread>
		z_ready_thread(thread);
   2d064:	4620      	mov	r0, r4
   2d066:	f7ff ff69 	bl	2cf3c <z_ready_thread>
		need_sched = 1;
   2d06a:	2001      	movs	r0, #1
   2d06c:	e7f2      	b.n	2d054 <z_unpend_all+0x6>

0002d06e <z_sched_wake>:
{
   2d06e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2d070:	f04f 0320 	mov.w	r3, #32
   2d074:	f3ef 8511 	mrs	r5, BASEPRI
   2d078:	f383 8812 	msr	BASEPRI_MAX, r3
   2d07c:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   2d080:	f7ff ff56 	bl	2cf30 <z_priq_dumb_best>
		if (thread != NULL) {
   2d084:	4604      	mov	r4, r0
   2d086:	b150      	cbz	r0, 2d09e <z_sched_wake+0x30>
   2d088:	67c1      	str	r1, [r0, #124]	; 0x7c
   2d08a:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
   2d08c:	f7ff ff03 	bl	2ce96 <unpend_thread_no_timeout>
   2d090:	3018      	adds	r0, #24
   2d092:	f000 f809 	bl	2d0a8 <z_abort_timeout>
			ready_thread(thread);
   2d096:	4620      	mov	r0, r4
   2d098:	f7f7 fa70 	bl	2457c <ready_thread>
			ret = true;
   2d09c:	2001      	movs	r0, #1
	__asm__ volatile(
   2d09e:	f385 8811 	msr	BASEPRI, r5
   2d0a2:	f3bf 8f6f 	isb	sy
}
   2d0a6:	bd38      	pop	{r3, r4, r5, pc}

0002d0a8 <z_abort_timeout>:
{
   2d0a8:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d0aa:	f04f 0220 	mov.w	r2, #32
   2d0ae:	f3ef 8411 	mrs	r4, BASEPRI
   2d0b2:	f382 8812 	msr	BASEPRI_MAX, r2
   2d0b6:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   2d0ba:	6803      	ldr	r3, [r0, #0]
   2d0bc:	b13b      	cbz	r3, 2d0ce <z_abort_timeout+0x26>
			remove_timeout(to);
   2d0be:	f7f7 fd0b 	bl	24ad8 <remove_timeout>
			ret = 0;
   2d0c2:	2000      	movs	r0, #0
	__asm__ volatile(
   2d0c4:	f384 8811 	msr	BASEPRI, r4
   2d0c8:	f3bf 8f6f 	isb	sy
}
   2d0cc:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   2d0ce:	f06f 0015 	mvn.w	r0, #21
   2d0d2:	e7f7      	b.n	2d0c4 <z_abort_timeout+0x1c>

0002d0d4 <z_timeout_remaining>:
{
   2d0d4:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d0d6:	f04f 0320 	mov.w	r3, #32
   2d0da:	f3ef 8411 	mrs	r4, BASEPRI
   2d0de:	f383 8812 	msr	BASEPRI_MAX, r3
   2d0e2:	f3bf 8f6f 	isb	sy
		ticks = timeout_rem(timeout);
   2d0e6:	f7f7 fd11 	bl	24b0c <timeout_rem>
	__asm__ volatile(
   2d0ea:	f384 8811 	msr	BASEPRI, r4
   2d0ee:	f3bf 8f6f 	isb	sy
}
   2d0f2:	bd10      	pop	{r4, pc}

0002d0f4 <z_get_next_timeout_expiry>:
{
   2d0f4:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d0f6:	f04f 0320 	mov.w	r3, #32
   2d0fa:	f3ef 8411 	mrs	r4, BASEPRI
   2d0fe:	f383 8812 	msr	BASEPRI_MAX, r3
   2d102:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   2d106:	f7f7 fcc1 	bl	24a8c <next_timeout>
	__asm__ volatile(
   2d10a:	f384 8811 	msr	BASEPRI, r4
   2d10e:	f3bf 8f6f 	isb	sy
}
   2d112:	bd10      	pop	{r4, pc}

0002d114 <z_set_timeout_expiry>:
{
   2d114:	b570      	push	{r4, r5, r6, lr}
   2d116:	4604      	mov	r4, r0
   2d118:	460d      	mov	r5, r1
	__asm__ volatile(
   2d11a:	f04f 0320 	mov.w	r3, #32
   2d11e:	f3ef 8611 	mrs	r6, BASEPRI
   2d122:	f383 8812 	msr	BASEPRI_MAX, r3
   2d126:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   2d12a:	f7f7 fcaf 	bl	24a8c <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   2d12e:	2801      	cmp	r0, #1
   2d130:	dd05      	ble.n	2d13e <z_set_timeout_expiry+0x2a>
   2d132:	42a0      	cmp	r0, r4
   2d134:	db03      	blt.n	2d13e <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   2d136:	4629      	mov	r1, r5
   2d138:	4620      	mov	r0, r4
   2d13a:	f7f5 f979 	bl	22430 <sys_clock_set_timeout>
	__asm__ volatile(
   2d13e:	f386 8811 	msr	BASEPRI, r6
   2d142:	f3bf 8f6f 	isb	sy
}
   2d146:	bd70      	pop	{r4, r5, r6, pc}

0002d148 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   2d148:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   2d14a:	f7f7 fddb 	bl	24d04 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   2d14e:	bd08      	pop	{r3, pc}

0002d150 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   2d150:	f7f7 bdd8 	b.w	24d04 <sys_clock_tick_get>

0002d154 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   2d154:	b108      	cbz	r0, 2d15a <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   2d156:	f7d7 bfd1 	b.w	50fc <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   2d15a:	4770      	bx	lr

0002d15c <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2d15c:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   2d160:	bf08      	it	eq
   2d162:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   2d166:	b538      	push	{r3, r4, r5, lr}
   2d168:	4605      	mov	r5, r0
   2d16a:	460c      	mov	r4, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2d16c:	d01d      	beq.n	2d1aa <sys_clock_timeout_end_calc+0x4e>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2d16e:	ea51 0300 	orrs.w	r3, r1, r0
   2d172:	d103      	bne.n	2d17c <sys_clock_timeout_end_calc+0x20>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   2d174:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   2d178:	f7f7 bdc4 	b.w	24d04 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   2d17c:	f06f 0301 	mvn.w	r3, #1
   2d180:	1a18      	subs	r0, r3, r0
   2d182:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2d186:	eb63 0101 	sbc.w	r1, r3, r1
   2d18a:	2900      	cmp	r1, #0
   2d18c:	da0c      	bge.n	2d1a8 <sys_clock_timeout_end_calc+0x4c>
		return sys_clock_tick_get() + MAX(1, dt);
   2d18e:	f7f7 fdb9 	bl	24d04 <sys_clock_tick_get>
   2d192:	2d01      	cmp	r5, #1
   2d194:	4622      	mov	r2, r4
   2d196:	f174 0400 	sbcs.w	r4, r4, #0
   2d19a:	462b      	mov	r3, r5
   2d19c:	bfbc      	itt	lt
   2d19e:	2301      	movlt	r3, #1
   2d1a0:	2200      	movlt	r2, #0
   2d1a2:	1818      	adds	r0, r3, r0
   2d1a4:	eb41 0102 	adc.w	r1, r1, r2
}
   2d1a8:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   2d1aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2d1ae:	4601      	mov	r1, r0
   2d1b0:	e7fa      	b.n	2d1a8 <sys_clock_timeout_end_calc+0x4c>

0002d1b2 <k_timer_init>:
	timer->status = 0U;
   2d1b2:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   2d1b4:	e9c0 1208 	strd	r1, r2, [r0, #32]
   2d1b8:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   2d1bc:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   2d1c0:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   2d1c4:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   2d1c6:	6343      	str	r3, [r0, #52]	; 0x34
}
   2d1c8:	4770      	bx	lr

0002d1ca <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   2d1ca:	b510      	push	{r4, lr}
   2d1cc:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   2d1ce:	f7ff ff6b 	bl	2d0a8 <z_abort_timeout>

	if (inactive) {
   2d1d2:	b9b0      	cbnz	r0, 2d202 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   2d1d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d1d6:	b10b      	cbz	r3, 2d1dc <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   2d1d8:	4620      	mov	r0, r4
   2d1da:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   2d1dc:	f104 0018 	add.w	r0, r4, #24
   2d1e0:	f7ff ff08 	bl	2cff4 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   2d1e4:	b168      	cbz	r0, 2d202 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   2d1e6:	f7ff fea9 	bl	2cf3c <z_ready_thread>
	__asm__ volatile(
   2d1ea:	f04f 0320 	mov.w	r3, #32
   2d1ee:	f3ef 8011 	mrs	r0, BASEPRI
   2d1f2:	f383 8812 	msr	BASEPRI_MAX, r3
   2d1f6:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   2d1fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   2d1fe:	f7ff be81 	b.w	2cf04 <z_reschedule_irqlock>
   2d202:	bd10      	pop	{r4, pc}

0002d204 <add_event>:
{
   2d204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d206:	460d      	mov	r5, r1
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   2d208:	e9d0 1300 	ldrd	r1, r3, [r0]
   2d20c:	4288      	cmp	r0, r1
   2d20e:	4604      	mov	r4, r0
   2d210:	d00d      	beq.n	2d22e <add_event+0x2a>
	if ((pending == NULL) ||
   2d212:	b163      	cbz	r3, 2d22e <add_event+0x2a>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   2d214:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2d216:	b100      	cbz	r0, 2d21a <add_event+0x16>
   2d218:	3860      	subs	r0, #96	; 0x60
   2d21a:	f1a2 0760 	sub.w	r7, r2, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
   2d21e:	4639      	mov	r1, r7
   2d220:	f7ff fe43 	bl	2ceaa <z_sched_prio_cmp>
	if ((pending == NULL) ||
   2d224:	2800      	cmp	r0, #0
   2d226:	dc02      	bgt.n	2d22e <add_event+0x2a>
	return list->head == list;
   2d228:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d22a:	42b4      	cmp	r4, r6
   2d22c:	d109      	bne.n	2d242 <add_event+0x3e>
	sys_dnode_t *const tail = list->tail;
   2d22e:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
   2d230:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
   2d234:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2d236:	6065      	str	r5, [r4, #4]
}
   2d238:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   2d23a:	6863      	ldr	r3, [r4, #4]
   2d23c:	42b3      	cmp	r3, r6
   2d23e:	d0f6      	beq.n	2d22e <add_event+0x2a>
   2d240:	6836      	ldr	r6, [r6, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   2d242:	2e00      	cmp	r6, #0
   2d244:	d0f3      	beq.n	2d22e <add_event+0x2a>
		if (z_sched_prio_cmp(poller_thread(poller),
   2d246:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2d248:	b101      	cbz	r1, 2d24c <add_event+0x48>
   2d24a:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
   2d24c:	4638      	mov	r0, r7
   2d24e:	f7ff fe2c 	bl	2ceaa <z_sched_prio_cmp>
   2d252:	2800      	cmp	r0, #0
   2d254:	ddf1      	ble.n	2d23a <add_event+0x36>
	sys_dnode_t *const prev = successor->prev;
   2d256:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   2d258:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
   2d25c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2d25e:	6075      	str	r5, [r6, #4]
			return;
   2d260:	e7ea      	b.n	2d238 <add_event+0x34>

0002d262 <register_events>:
{
   2d262:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   2d266:	2500      	movs	r5, #0
{
   2d268:	468b      	mov	fp, r1
   2d26a:	4614      	mov	r4, r2
   2d26c:	461f      	mov	r7, r3
   2d26e:	4682      	mov	sl, r0
	int events_registered = 0;
   2d270:	462e      	mov	r6, r5
	event->poller = NULL;
   2d272:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
   2d274:	455d      	cmp	r5, fp
   2d276:	db02      	blt.n	2d27e <register_events+0x1c>
}
   2d278:	4630      	mov	r0, r6
   2d27a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d27e:	f04f 0320 	mov.w	r3, #32
   2d282:	f3ef 8911 	mrs	r9, BASEPRI
   2d286:	f383 8812 	msr	BASEPRI_MAX, r3
   2d28a:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   2d28e:	f89a 300d 	ldrb.w	r3, [sl, #13]
   2d292:	f003 031f 	and.w	r3, r3, #31
   2d296:	3b01      	subs	r3, #1
   2d298:	2b07      	cmp	r3, #7
   2d29a:	d80f      	bhi.n	2d2bc <register_events+0x5a>
   2d29c:	e8df f003 	tbb	[pc, r3]
   2d2a0:	0a0e041e 	.word	0x0a0e041e
   2d2a4:	250e0e0e 	.word	0x250e0e0e
		if (k_sem_count_get(event->sem) > 0U) {
   2d2a8:	f8da 3010 	ldr.w	r3, [sl, #16]
   2d2ac:	689b      	ldr	r3, [r3, #8]
   2d2ae:	b12b      	cbz	r3, 2d2bc <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   2d2b0:	2302      	movs	r3, #2
   2d2b2:	e020      	b.n	2d2f6 <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
   2d2b4:	f8da 3010 	ldr.w	r3, [sl, #16]
   2d2b8:	681b      	ldr	r3, [r3, #0]
   2d2ba:	bb8b      	cbnz	r3, 2d320 <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
   2d2bc:	bb47      	cbnz	r7, 2d310 <register_events+0xae>
   2d2be:	7823      	ldrb	r3, [r4, #0]
   2d2c0:	b333      	cbz	r3, 2d310 <register_events+0xae>
	switch (event->type) {
   2d2c2:	f89a 300d 	ldrb.w	r3, [sl, #13]
   2d2c6:	f003 031f 	and.w	r3, r3, #31
   2d2ca:	3b01      	subs	r3, #1
   2d2cc:	2b07      	cmp	r3, #7
   2d2ce:	d830      	bhi.n	2d332 <register_events+0xd0>
   2d2d0:	e8df f003 	tbb	[pc, r3]
   2d2d4:	282f2833 	.word	0x282f2833
   2d2d8:	382f2f2f 	.word	0x382f2f2f
		if (event->signal->signaled != 0U) {
   2d2dc:	f8da 3010 	ldr.w	r3, [sl, #16]
   2d2e0:	689b      	ldr	r3, [r3, #8]
   2d2e2:	2b00      	cmp	r3, #0
   2d2e4:	d0ea      	beq.n	2d2bc <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
   2d2e6:	2301      	movs	r3, #1
   2d2e8:	e005      	b.n	2d2f6 <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
   2d2ea:	f8da 3010 	ldr.w	r3, [sl, #16]
   2d2ee:	6a1b      	ldr	r3, [r3, #32]
   2d2f0:	2b00      	cmp	r3, #0
   2d2f2:	d0e3      	beq.n	2d2bc <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
   2d2f4:	2310      	movs	r3, #16
	event->state |= state;
   2d2f6:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
   2d2fa:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
   2d2fe:	f3c2 3145 	ubfx	r1, r2, #13, #6
   2d302:	430b      	orrs	r3, r1
   2d304:	f363 3252 	bfi	r2, r3, #13, #6
   2d308:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
   2d30c:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   2d310:	f389 8811 	msr	BASEPRI, r9
   2d314:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   2d318:	3501      	adds	r5, #1
   2d31a:	f10a 0a14 	add.w	sl, sl, #20
   2d31e:	e7a9      	b.n	2d274 <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   2d320:	2304      	movs	r3, #4
   2d322:	e7e8      	b.n	2d2f6 <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
   2d324:	f8da 0010 	ldr.w	r0, [sl, #16]
   2d328:	4622      	mov	r2, r4
   2d32a:	4651      	mov	r1, sl
   2d32c:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
   2d32e:	f7ff ff69 	bl	2d204 <add_event>
	event->poller = poller;
   2d332:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
   2d336:	3601      	adds	r6, #1
   2d338:	e7ea      	b.n	2d310 <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
   2d33a:	f8da 0010 	ldr.w	r0, [sl, #16]
   2d33e:	4622      	mov	r2, r4
   2d340:	4651      	mov	r1, sl
   2d342:	e7f4      	b.n	2d32e <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
   2d344:	f8da 0010 	ldr.w	r0, [sl, #16]
   2d348:	4622      	mov	r2, r4
   2d34a:	4651      	mov	r1, sl
   2d34c:	3024      	adds	r0, #36	; 0x24
   2d34e:	e7ee      	b.n	2d32e <register_events+0xcc>

0002d350 <signal_poll_event>:
{
   2d350:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
   2d354:	6884      	ldr	r4, [r0, #8]
{
   2d356:	4605      	mov	r5, r0
   2d358:	460e      	mov	r6, r1
	if (poller != NULL) {
   2d35a:	b144      	cbz	r4, 2d36e <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
   2d35c:	7863      	ldrb	r3, [r4, #1]
   2d35e:	2b01      	cmp	r3, #1
   2d360:	d136      	bne.n	2d3d0 <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
   2d362:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   2d366:	f013 0302 	ands.w	r3, r3, #2
   2d36a:	d10a      	bne.n	2d382 <signal_poll_event+0x32>
		poller->is_polling = false;
   2d36c:	7023      	strb	r3, [r4, #0]
	event->state |= state;
   2d36e:	68eb      	ldr	r3, [r5, #12]
   2d370:	f3c3 3145 	ubfx	r1, r3, #13, #6
   2d374:	430e      	orrs	r6, r1
	event->poller = NULL;
   2d376:	2000      	movs	r0, #0
	event->state |= state;
   2d378:	f366 3352 	bfi	r3, r6, #13, #6
	event->poller = NULL;
   2d37c:	60a8      	str	r0, [r5, #8]
	event->state |= state;
   2d37e:	60eb      	str	r3, [r5, #12]
	return retcode;
   2d380:	e00b      	b.n	2d39a <signal_poll_event+0x4a>
	if (z_is_thread_timeout_expired(thread)) {
   2d382:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
   2d386:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2d38a:	bf08      	it	eq
   2d38c:	f112 0f02 	cmneq.w	r2, #2
   2d390:	d105      	bne.n	2d39e <signal_poll_event+0x4e>
		poller->is_polling = false;
   2d392:	2300      	movs	r3, #0
   2d394:	7023      	strb	r3, [r4, #0]
		return -EAGAIN;
   2d396:	f06f 000a 	mvn.w	r0, #10
}
   2d39a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   2d39e:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
   2d3a2:	4640      	mov	r0, r8
   2d3a4:	f7ff fd9a 	bl	2cedc <z_unpend_thread>
	arch_thread_return_value_set(thread,
   2d3a8:	2e08      	cmp	r6, #8
   2d3aa:	bf0c      	ite	eq
   2d3ac:	f06f 0303 	mvneq.w	r3, #3
   2d3b0:	2300      	movne	r3, #0
   2d3b2:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2d3b4:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   2d3b8:	06db      	lsls	r3, r3, #27
   2d3ba:	d102      	bne.n	2d3c2 <signal_poll_event+0x72>
	if (!z_is_thread_ready(thread)) {
   2d3bc:	f854 7c48 	ldr.w	r7, [r4, #-72]
   2d3c0:	b10f      	cbz	r7, 2d3c6 <signal_poll_event+0x76>
		poller->is_polling = false;
   2d3c2:	2300      	movs	r3, #0
   2d3c4:	e7d2      	b.n	2d36c <signal_poll_event+0x1c>
	z_ready_thread(thread);
   2d3c6:	4640      	mov	r0, r8
   2d3c8:	f7ff fdb8 	bl	2cf3c <z_ready_thread>
		poller->is_polling = false;
   2d3cc:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
   2d3ce:	e7ce      	b.n	2d36e <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
   2d3d0:	2b02      	cmp	r3, #2
   2d3d2:	d1f6      	bne.n	2d3c2 <signal_poll_event+0x72>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   2d3d4:	7823      	ldrb	r3, [r4, #0]
   2d3d6:	2b00      	cmp	r3, #0
   2d3d8:	d0c9      	beq.n	2d36e <signal_poll_event+0x1e>
   2d3da:	f854 7c04 	ldr.w	r7, [r4, #-4]
   2d3de:	2f00      	cmp	r7, #0
   2d3e0:	d0f4      	beq.n	2d3cc <signal_poll_event+0x7c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
   2d3e2:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
   2d3e6:	f1a4 0914 	sub.w	r9, r4, #20
   2d3ea:	f104 0014 	add.w	r0, r4, #20
   2d3ee:	f7ff fe5b 	bl	2d0a8 <z_abort_timeout>
		twork->poll_result = 0;
   2d3f2:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		k_work_submit_to_queue(work_q, &twork->work);
   2d3f6:	4649      	mov	r1, r9
   2d3f8:	4638      	mov	r0, r7
   2d3fa:	f7ff fcd9 	bl	2cdb0 <k_work_submit_to_queue>
		poller->is_polling = false;
   2d3fe:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
   2d402:	e7b4      	b.n	2d36e <signal_poll_event+0x1e>

0002d404 <clear_event_registrations>:
	while (num_events--) {
   2d404:	2314      	movs	r3, #20
{
   2d406:	b5f0      	push	{r4, r5, r6, r7, lr}
   2d408:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
   2d40c:	2400      	movs	r4, #0
   2d40e:	2601      	movs	r6, #1
	while (num_events--) {
   2d410:	b901      	cbnz	r1, 2d414 <clear_event_registrations+0x10>
}
   2d412:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
   2d414:	f810 3c07 	ldrb.w	r3, [r0, #-7]
	event->poller = NULL;
   2d418:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
   2d41c:	f003 031f 	and.w	r3, r3, #31
   2d420:	2b08      	cmp	r3, #8
   2d422:	f1a0 0714 	sub.w	r7, r0, #20
   2d426:	d80d      	bhi.n	2d444 <clear_event_registrations+0x40>
   2d428:	fa06 f303 	lsl.w	r3, r6, r3
   2d42c:	f413 7f8b 	tst.w	r3, #278	; 0x116
   2d430:	d008      	beq.n	2d444 <clear_event_registrations+0x40>
	return node->next != NULL;
   2d432:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   2d436:	b12b      	cbz	r3, 2d444 <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
   2d438:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
   2d43c:	602b      	str	r3, [r5, #0]
	next->prev = prev;
   2d43e:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   2d440:	e940 4405 	strd	r4, r4, [r0, #-20]
   2d444:	f382 8811 	msr	BASEPRI, r2
   2d448:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2d44c:	f04f 0320 	mov.w	r3, #32
   2d450:	f3ef 8211 	mrs	r2, BASEPRI
   2d454:	f383 8812 	msr	BASEPRI_MAX, r3
   2d458:	f3bf 8f6f 	isb	sy
   2d45c:	3901      	subs	r1, #1
   2d45e:	4638      	mov	r0, r7
   2d460:	e7d6      	b.n	2d410 <clear_event_registrations+0xc>

0002d462 <k_poll_event_init>:
{
   2d462:	b510      	push	{r4, lr}
	event->type = type;
   2d464:	04d2      	lsls	r2, r2, #19
   2d466:	0209      	lsls	r1, r1, #8
   2d468:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
   2d46c:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
   2d470:	430a      	orrs	r2, r1
   2d472:	7b01      	ldrb	r1, [r0, #12]
	event->poller = NULL;
   2d474:	2400      	movs	r4, #0
	event->type = type;
   2d476:	430a      	orrs	r2, r1
	event->obj = obj;
   2d478:	e9c0 2303 	strd	r2, r3, [r0, #12]
	event->poller = NULL;
   2d47c:	6084      	str	r4, [r0, #8]
}
   2d47e:	bd10      	pop	{r4, pc}

0002d480 <z_handle_obj_poll_events>:
{
   2d480:	4603      	mov	r3, r0
	return list->head == list;
   2d482:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   2d484:	4283      	cmp	r3, r0
   2d486:	d008      	beq.n	2d49a <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
   2d488:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   2d48c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   2d48e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2d490:	2300      	movs	r3, #0
	node->prev = NULL;
   2d492:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
   2d496:	f7ff bf5b 	b.w	2d350 <signal_poll_event>
}
   2d49a:	4770      	bx	lr

0002d49c <k_free>:
	if (ptr != NULL) {
   2d49c:	b120      	cbz	r0, 2d4a8 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   2d49e:	1f01      	subs	r1, r0, #4
   2d4a0:	f850 0c04 	ldr.w	r0, [r0, #-4]
   2d4a4:	f7ff ba95 	b.w	2c9d2 <k_heap_free>
}
   2d4a8:	4770      	bx	lr
	...

0002d4ac <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   2d4ac:	f7f5 b818 	b.w	224e0 <SystemInit>
